- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Protobuf Primer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Protobuf 初学者指南
- en: As we now understand the basic networking concepts behind gRPC, we can touch
    upon another pillar in the construction of your gRPC APIs. This pillar is **Protocol
    Buffers**, more commonly known as **Protobuf**. It is an important part of the
    communication process because, as we saw in the previous chapter, every message
    is encoded into binary, and this is exactly what Protobuf is doing for us in gRPC.
    In this chapter, the goal is to understand what Protobuf is and why it is needed
    for high-efficiency communication. Finally, we are going to look at some details
    concerning the serialization and deserialization of messages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了 gRPC 背后的基本网络概念，我们可以触及构建你的 gRPC API 的另一个支柱。这个支柱是 **协议缓冲区**，更通俗地称为 **Protobuf**。它是通信过程中的一个重要部分，因为我们看到，在上一章中，每条消息都被编码成二进制，这正是
    Protobuf 在 gRPC 中为我们所做的事情。在本章中，目标是理解 Protobuf 是什么以及为什么它对于高效通信是必需的。最后，我们将探讨一些关于消息序列化和反序列化的细节。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Protobuf is an **Interface Description** **Language** (**IDL**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protobuf 是一种 **接口描述** **语言**（**IDL**）
- en: Serialization/deserialization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化/反序列化
- en: Protobuf versus JSON
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protobuf 与 JSON 的比较
- en: Encoding details
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码细节
- en: Common types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见类型
- en: Services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Prerequisites
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'You can find the code for this chapter at https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter2.
    In this chapter, we are going to discuss how Protocol Buffers serializes and deserializes
    data. While this can be done by writing code, we are going to stay away from that
    in order to learn how to use the protoc compiler to debug and optimize our Protobuf
    schemas. Thus, if you want to reproduce the examples specified, you will need
    to download the protoc compiler from the Protobuf GitHub *Releases* page (https://github.com/protocolbuffers/protobuf/releases).
    The easiest way to get started is to download the binary releases. These releases
    are named with this convention: `protoc-${VERSION}-${OS}-{ARCHITECTURE}`. Uncompress
    the zip file and follow the `readme.txt` instructions (note: we do intend to use
    Well-Known Types in the future so make sure you also install the includes). After
    that, you should be able to run the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter2
    找到本章的代码。在本章中，我们将讨论 Protocol Buffers 如何序列化和反序列化数据。虽然这可以通过编写代码来完成，但我们将避免这样做，以便学习如何使用
    protoc 编译器来调试和优化我们的 Protobuf 模式。因此，如果你想重现指定的示例，你需要从 Protobuf GitHub *发布* 页面（https://github.com/protocolbuffers/protobuf/releases）下载
    protoc 编译器。开始的最简单方法是下载二进制发布版本。这些发布版本按照以下约定命名：`protoc-${VERSION}-${OS}-{ARCHITECTURE}`。解压缩
    zip 文件，并遵循 `readme.txt` 指示（注意：我们打算在未来使用已知类型，所以请确保你也安装了包含文件）。之后，你应该能够运行以下命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finally, as always, you will be able to find the companion code in the GitHub
    repository under the folder for the current chapter (`chapter2`).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像往常一样，你可以在GitHub仓库当前章节文件夹（`chapter2`）下找到配套代码。
- en: Protobuf is an IDL
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Protobuf 是一种 IDL
- en: Protobuf is a language. More precisely, it is an IDL. It is important to make
    such a distinction because, as we will see more in detail later, in Protobuf,
    we do not write any logic the way we do in a programming language, but instead,
    we write data schemas, which are contracts to be used for serialization and are
    to be fulfilled by deserialization. So, before explaining all the rules that we
    need to follow when writing a `.proto` file and going through all the details
    about serialization and deserialization, we need to first get a sense of what
    an IDL is and what is the goal of such a language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 是一种语言。更确切地说，它是一种 IDL。做出这种区分很重要，因为正如我们稍后会更详细地看到的那样，在 Protobuf 中，我们不会像在编程语言中那样编写任何逻辑，而是编写数据模式，这些模式是用于序列化的合约，并且需要在反序列化时得到满足。因此，在我们解释编写
    `.proto` 文件时需要遵循的所有规则，并详细了解序列化和反序列化的所有细节之前，我们首先需要了解什么是 IDL 以及这种语言的目标。
- en: An IDL, as we saw earlier, is an acronym for *Interface Description Language*,
    and as we can see, the name contains three parts. The first part, **Interface**,
    describes a piece of code that sits in between two or more applications and hides
    the complexity of implementation. As such, we do not make any assumptions about
    the hardware on which an application is running, the OS on which it runs, and
    in which programming language it is written. This interface is, by design, hardware-,
    OS-, and language-agnostic. This is important for Protobuf and several other serialization
    data schemas because it lets developers write the code once and it can be used
    across different projects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所看到的，IDL是*接口描述语言*的缩写，我们可以看到，名称包含三个部分。第一部分是**接口**，描述了一段代码，位于两个或更多应用程序之间，隐藏了实现的复杂性。因此，我们不对应用程序运行的硬件、运行的操作系统以及用哪种编程语言编写的假设。这个接口按设计是硬件无关、操作系统无关和语言无关的。这对于Protobuf和几个其他序列化数据模式来说很重要，因为它允许开发者一次编写代码，并且可以在不同的项目中使用。
- en: 'The second part is `Account` that contains an ID, a username, and the rights
    this account has, we could write the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是包含ID、用户名和该账户拥有的权限的`Account`，我们可以编写以下内容：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we skip some of the details that are not important at this stage, we can
    see that we define the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们跳过一些在这个阶段不重要的细节，我们可以看到我们定义了以下内容：
- en: An enumeration listing all the possible rights and an extra role called `ACCOUNT_RIGHT_UNSPECIFIED`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个列出所有可能权限的枚举和一个额外的角色`ACCOUNT_RIGHT_UNSPECIFIED`
- en: A message (equivalent to a class or struct) listing the three properties that
    an `Account` type should have
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个消息（相当于类或结构体），列出`Account`类型应该拥有的三个属性
- en: Again, without looking at the details, it is readable, and the relationship
    between `Account` and `AccountRight` is easy to understand.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，不查看细节，它也是可读的，并且`Account`和`AccountRight`之间的关系很容易理解。
- en: 'Finally, the last part is `Account` type defined previously would give in Go:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一部分是之前定义的`Account`类型在Go中的表示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code, there are important things to notice. Let us break this code
    into pieces:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，有一些重要的事情需要注意。让我们将此代码分解成几个部分：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our `AccountRight` enum is defined as constants with values of type `int32`.
    Each enum variant’s name is prefixed with the name of the enum, and each constant
    has the value that we set after the equals sign in the Protobuf code. These values
    are called field tags, and we will introduce them later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`AccountRight`枚举定义为具有`int32`类型的值的常量。每个枚举变体的名称都以前缀枚举的名称开头，每个常量都有我们在Protobuf代码中等于号后面的设置值。这些值被称为字段标签，我们将在本章后面介绍它们。
- en: 'Now, take a look at the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下以下代码：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have our `Account` message transpiled to a struct with `Id`, `Username`,
    and `Right` exported fields. Each of these fields has a type that is converted
    from a Protobuf type to a Golang type. In our example here, Go types and Protobuf
    types have the exact same names, but it is important to know that in some cases,
    the types will translate differently. Such an example is `double` in Protobuf,
    which will translate to `float64` for Go. Finally, we have the field tags, referenced
    in the metadata following the field. Once again, their meaning will be explained
    later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们的`Account`消息被转换为一个具有`Id`、`Username`和`Right`导出字段的struct。这些字段中的每个字段都有一个类型，该类型从Protobuf类型转换为Golang类型。在我们的例子中，Go类型和Protobuf类型具有完全相同的名称，但重要的是要知道在某些情况下，类型将不同地转换。这样的例子是Protobuf中的`double`，它将转换为Go的`float64`。最后，我们还有字段标签，在字段后面的元数据中引用。再次，它们的含义将在本章后面解释。
- en: So, to recapitulate, an IDL is a piece of code sitting between different applications
    and describing objects and their relationships by following certain defined rules.
    This IDL, in the case of Protobuf, will be read, and it will be used to generate
    code in another language. And after that, this generated code will be used by
    the user code to serialize and deserialize data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了总结，IDL是一段代码，位于不同的应用程序之间，通过遵循某些定义的规则来描述对象及其关系。在这种情况下，Protobuf的IDL将被读取，并用于在另一种语言中生成代码。然后，生成的代码将被用户代码用于序列化和反序列化数据。
- en: Serialization and deserialization
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化和反序列化
- en: Serialization and deserialization are two concepts that are used in many ways
    and in many kinds of applications. This section is going to discuss these two
    concepts in the context of Protobuf. So, even if you feel confident about your
    understanding of these two notions, it is important to get your head straight
    and understand them properly. Once you do, it will be easier to deal with the
    *Encoding details* section where we are going to delve deeper into how Protobuf
    serializes and deserializes data under the hood.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化是许多方式和许多类型的应用程序中使用的两个概念。本节将讨论这两个概念在Protobuf的背景下。因此，即使你对这两个概念的理解很有信心，了解它们也是非常重要的。一旦你做到了，处理*编码细节*部分就会更容易，我们将深入探讨Protobuf如何底层序列化和反序列化数据。
- en: Let us start with serialization and then let us touch upon deserialization,
    which is just the opposite process. The goal of serialization is to store data,
    generally in a more compact or readable representation, to use it later. For Protobuf,
    this serialization happens on the data that you set in your generated code’s objects.
    For example, if we set the `Id`, `Username`, and `Right` fields in our `Account`
    struct, this data will be what Protobuf will work on. It will turn each field
    into a binary representation with different algorithms depending on the field
    type. And after that, we use this in-memory binary to either send data over the
    network (with gRPC, for example) or store it in more persistent storage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从序列化开始，然后简要提及反序列化，它是一个相反的过程。序列化的目的是存储数据，通常以更紧凑或可读的表示形式，以便以后使用。对于Protobuf，这种序列化发生在你生成的代码对象中设置的数据上。例如，如果我们设置了`Id`、`Username`和`Right`字段在我们的`Account`结构体中，这些数据将是Protobuf将要处理的数据。它将根据字段类型使用不同的算法将每个字段转换为二进制表示。然后，我们使用这个内存中的二进制数据，要么通过网络（例如使用gRPC）发送数据，要么将其存储在更持久的存储中。
- en: Once it is time for us to use this serialized data again, Protobuf will perform
    deserialization. This is the process of reading the binary created earlier and
    populating the data back into an object in your favorite programming language
    to be able to act on it. Once again, Protobuf will use different algorithms depending
    on the type of data to read the underlying binary and know how to set or not set
    each of the fields of the object in question.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次使用这个序列化数据时，Protobuf将执行反序列化。这是一个读取之前创建的二进制文件并将数据重新填充到你喜欢的编程语言中的对象的过程，以便能够对其采取行动。再次强调，Protobuf将根据读取的数据类型使用不同的算法来读取底层的二进制文件，并知道如何设置或不设置相关对象的每个字段。
- en: To summarize, Protobuf performs binary serialization to make data more compact
    than other formats such as XML or JSON. To do so, it will read data from the different
    fields of the generated code’s object, turn it into binary with different algorithms,
    and then when we finally need the data, Protobuf will read the data and populate
    the fields of a given object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Protobuf通过二进制序列化使数据比其他格式（如XML或JSON）更紧凑。为此，它将从生成的代码对象的各个字段中读取数据，将其转换为二进制，并使用不同的算法，然后当我们最终需要数据时，Protobuf将读取数据并填充给定对象的字段。
- en: Protobuf versus JSON
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Protobuf 与 JSON
- en: If you’ve already worked on the backend or even frontend, there is a 99.99 percent
    chance that you’ve worked with JSON. This is by far the most popular data schema
    out there and there are reasons why it is the case. In this section, we are going
    to discuss the pros and cons of both JSON and Protobuf and we are going to explain
    which one is more suitable for which situation. The goal here is to be objective
    because as engineers, we need to be to choose the right tool for the right job.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在后端甚至前端工作过，有99.99%的几率你已经使用过JSON。这无疑是目前最受欢迎的数据模式，并且有原因使其成为如此。在本节中，我们将讨论JSON和Protobuf的优缺点，并解释哪种情况更适合哪种情况。我们的目标是保持客观，因为作为工程师，我们需要选择适合正确工作的正确工具。
- en: 'As we could write chapters about the pros and cons of each technology, we are
    going to reduce the scope of these advantages and disadvantages to three categories.
    These categories are the ones that developers care the most about when developing
    applications, as detailed here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以为每种技术的优缺点写上章节，我们将缩小这些优缺点的范围到三个类别。这些类别是开发者在开发应用程序时最关心的，具体如下：
- en: '**Size of serialized data**: We want to reduce the bandwidth when sending data
    over the network'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化数据的大小**：我们希望在通过网络发送数据时减少带宽'
- en: '**Readability of the data schema and the serialized data**: We want to be able
    to have a descriptive schema so that newcomers or users can quickly understand
    it, and we want to be able to visualize the data serialized for debugging or editing
    purposes'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据模式和序列化数据的可读性**：我们希望能够有一个描述性的模式，以便新来者或用户可以快速理解它，并且我们希望能够可视化序列化的数据，用于调试或编辑目的。'
- en: '**Strictness of the schema**: This quickly becomes a requirement when APIs
    grow, and we need to ensure the correct type of data is being sent and received
    between different applications'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式严格性**：当API增长时，这迅速成为一项需求，我们需要确保不同应用程序之间发送和接收的数据类型是正确的'
- en: Serialized data size
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化数据大小
- en: 'In serialization, the Holy Grail is, in a lot of use cases, reducing the size
    of your data. This is because most often, we want to send that data to another
    application across the network, and the lighter the payload, the faster it should
    arrive on the other side. *In this space, Protobuf is the clear winner against
    JSON*. This is the case because JSON serializes to text whereas Protobuf serializes
    to binary and thus has more room to improve how compact the serialized data is.
    An example of that is numbers. If you set a number to the `id` field in JSON,
    you would get something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化过程中，许多用例中的圣杯是减少数据的大小。这是因为我们通常希望将数据发送到网络上的另一个应用程序，负载越轻，它应该到达另一侧的速度就越快。*在这个领域，Protobuf相对于JSON是明显的赢家*。这是因为JSON序列化为文本，而Protobuf序列化为二进制，因此有更多的空间来改进序列化数据的大小。一个例子是数字。如果你在JSON中将一个数字设置为`id`字段，你会得到类似以下的内容：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we have some boilerplate with the braces, but most importantly we have
    a number that takes three characters, or three bytes. In Protobuf, if we set the
    same value to the same field, we would get the hexadecimal shown in the following
    callout.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一些带有大括号的模板代码，但最重要的是我们有一个占用三个字符或三个字节的数字。在Protobuf中，如果我们对同一个字段设置相同的值，我们将在以下示例中看到其十六进制表示。
- en: Important note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'In the `chapter2` folder of the companion GitHub repository, you will find
    the files need to reproduce all the results in this chapter. With protoc, we will
    be able to display the hexadecimal representation of our serialized data. To do
    that, you can run the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在配套GitHub仓库的`chapter2`文件夹中，你可以找到复制本章所有结果所需的文件。使用protoc，我们将能够显示我们序列化数据的十六进制表示。为此，你可以运行以下命令：
- en: 'Linux/Mac: `cat ${INPUT_FILE_NAME}.txt | protoc --encode=${MESSAGE_NAME} ${PROTO_FILE_NAME}.proto
    |` `hexdump –C`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'Linux/Mac: `cat ${INPUT_FILE_NAME}.txt | protoc --encode=${MESSAGE_NAME} ${PROTO_FILE_NAME}.proto
    |` `hexdump –C`'
- en: 'Windows (PowerShell): ``(Get-Content ${INPUT_FILE_NAME}.txt | protoc --encode=${MESSAGE_NAME}
    ${PROTO_FILE_NAME}.proto) -join "`n" |`` `Format-Hex`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'Windows (PowerShell): ``(Get-Content ${INPUT_FILE_NAME}.txt | protoc --encode=${MESSAGE_NAME}
    ${PROTO_FILE_NAME}.proto) -join "`n" |`` `Format-Hex`'
- en: 'For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '`$ cat account.txt` `| protoc --encode=Account account.proto |` `hexdump -C`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ cat account.txt` `| protoc --encode=Account account.proto |` `hexdump -C`'
- en: '`00000000 08 7b |.{|`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`00000000 08 7b |.{|`'
- en: '`00000002`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`00000002`'
- en: Right now, this might look like magic numbers, but we are going to see in the
    next section how it is encoded into two bytes. Now, two bytes instead of three
    might look negligible but imagine this kind of difference at scale, and you would
    have wasted millions of bytes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这可能会看起来像是魔法数字，但我们在下一节将看到它是如何编码成两个字节的。现在，两个字节而不是三个字节可能看起来微不足道，但想象一下这种差异在规模上的影响，你就会浪费数百万字节。
- en: Readability
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性
- en: 'The next important thing about data schema serialization is readability. However,
    readability is a little bit too broad, especially in the context of Protobuf.
    As we saw, as opposed to JSON, Protobuf separates the schema from the serialized
    data. We write the schema in a `.proto` file and then the serialization will give
    us some binary. In JSON, the schema is the actual serialized data. So, to be clearer
    and more precise about readability, let us split readability into two parts: the
    readability of the schema and the readability of the serialized data.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模式序列化的下一个重要问题是可读性。然而，可读性这个概念有点过于宽泛，尤其是在Protobuf的上下文中。正如我们所见，与JSON相比，Protobuf将模式与序列化数据分开。我们在`.proto`文件中编写模式，然后序列化将给我们一些二进制数据。在JSON中，模式就是实际的序列化数据。因此，为了更清晰和更精确地描述可读性，让我们将可读性分为两部分：模式的可读性和序列化数据的可读性。
- en: As for the readability of the schema, this is a matter of preference, but there
    are a few points that make Protobuf stand out. The first one of them is that Protobuf
    can contain comments, and this is nice to have for extra documentation describing
    requirements. JSON does not allow comments in the schema, so we must find a different
    way to provide documentation. Generally, it is done with GitHub wikis or other
    external documentation platforms. This is a problem because this kind of documentation
    quickly becomes outdated when the project and the team working on it get bigger.
    A simple oversight and your documentation do not describe the real state of your
    API. With Protobuf, it is still possible to have outdated documentation, but as
    the documentation is closer to the code, it provides more incentive and awareness
    to change the related comment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 至于方案的可读性，这是一个个人偏好的问题，但有一些要点使Protobuf脱颖而出。其中之一是Protobuf可以包含注释，这对于描述需求的额外文档来说是个好东西。JSON不允许在方案中包含注释，因此我们必须找到不同的方式来提供文档。通常，这是通过GitHub
    wiki或其他外部文档平台来完成的。这是一个问题，因为当项目和团队变大时，这种类型的文档很快就会过时。一个简单的疏忽，你的文档就不会描述你的API的真实状态。使用Protobuf，尽管仍然可能存在过时的文档，但文档与代码更接近，这提供了更多激励和意识来更改相关的注释。
- en: The second feature that makes Protobuf more readable is the fact that it has
    explicit types. JSON has types but they are implicit. You know that a field contains
    a string if its value is surrounded by double quotes, a number when the value
    is only digits, and so on. In Protobuf, especially for numbers, we get more information
    out of types. If we have an `int32` type, we can obviously know that this is a
    number, but on top of that, we know that it can accept negative numbers and we
    are able to know the range of numbers that can be stored in this field. Explicit
    types are important not only for security (more on that later) but also for letting
    the developer know the details of each field and letting them describe accurately
    their schemas to fulfill the business requirements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf更易读的第二个特性是它具有显式的类型。JSON有类型，但它们是隐式的。你知道如果一个字段的值被双引号包围，那么它包含一个字符串；如果值仅是数字，那么它是一个数字，等等。在Protobuf中，尤其是对于数字，我们从类型中获得了更多信息。如果我们有一个`int32`类型，我们可以明显知道这是一个数字，但除此之外，我们还知道它可以接受负数，并且我们可以知道可以存储在这个字段中的数字范围。显式类型不仅对于安全性（稍后会更详细地讨论）很重要，而且还可以让开发者了解每个字段的详细信息，并让他们能够准确地描述其模式以满足业务需求。
- en: '*For readability of the schema, I think we can agree that Protobuf is the winner
    here* because it can be written as self-documenting code and we get explicit types
    for every field in objects.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了方案的易读性，我认为我们可以一致认为Protobuf在这里是赢家*，因为它可以被编写为自文档化的代码，并且我们为对象中的每个字段都获得了显式的类型。'
- en: '*As for the readability of serialized data, JSON is the clear winner here*.
    As mentioned, JSON is both the data schema and the serialized data. What you see
    is what you get. Protobuf, however, serializes the data to binary, and it is way
    harder to read that, even if you know how Protobuf serializes and deserializes
    data. In the end, this is a trade-off between readability and serialized data
    size here. Protobuf will outperform JSON on serialized data and is way more explicit
    on the readability of the data schema. However, if you need human-readable data
    that can be edited by hand, Protobuf is not the right fit for your use case.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*至于序列化数据的可读性，JSON在这里是明显的赢家*。如前所述，JSON既是数据模式也是序列化数据。你所看到的就是你所得到的。然而，Protobuf将数据序列化为二进制，即使你知道如何序列化和反序列化Protobuf数据，阅读起来也相当困难。最终，这是可读性和序列化数据大小之间的权衡。在序列化数据方面，Protobuf将优于JSON，并且在数据模式的可读性方面更加明确。然而，如果你需要可以手动编辑的人可读数据，Protobuf可能不是你的用例的最佳选择。'
- en: Schema strictness
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方案严格性
- en: Finally, the last category is the strictness of the schema. This is usually
    a nice feature to have when your team and your project scale because it ensures
    that the schema is correctly populated, and for a certain target language, it
    shortens the feedback loop for the developers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个类别是方案的严格性。当你的团队和项目规模扩大时，这通常是一个很好的特性，因为它确保了方案被正确填充，并且对于某些目标语言，它缩短了开发者的反馈循环。
- en: Schemas are always valid ones because every field has an explicit type that
    can only contain certain values. We simply cannot pass a string to a field that
    was expecting a number or a negative number to a field that was expecting a positive
    number. This is enforced in the generated code by either runtime checks for dynamic
    languages or at compile time for typed languages. In our case, since Go is a typed
    language, we will have compile-time checks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 模式总是有效的，因为每个字段都有一个明确的类型，只能包含特定的值。我们绝对不能将字符串传递给期望数字的字段，或者将负数传递给期望正数的字段。这种约束在生成的代码中通过动态语言的运行时检查或类型语言的编译时检查来执行。在我们的情况下，由于
    Go 是一种类型语言，我们将有编译时检查。
- en: And finally, in typed languages, a schema shortens the feedback loop because
    instead of having a runtime check that might or might not trigger an error, we
    simply have a compilation error. This makes our software more reliable, and developers
    can feel confident that if they were able to compile, the data set into the object
    would be valid.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在类型语言中，模式缩短了反馈循环，因为我们不再需要可能触发或可能不触发错误的运行时检查，我们只需要一个编译错误。这使得我们的软件更加可靠，开发者可以确信，如果他们能够编译，那么放入对象中的数据集将是有效的。
- en: In pure JSON, we cannot ensure that our schema is correct at compile time. Most
    often, developers will add extra configurations such as JSON Schema to have this
    kind of assurance at runtime. This adds complexity to our project and requires
    every developer to be disciplined because they could simply go about their code
    without developing the schema. In Protobuf, we do schema-driven development. The
    schema comes first, and then our application revolves around the generated types.
    Furthermore, we have assurance at compile time that the values that we set are
    correct and we do not need to replicate the setup to all our microservices or
    subprojects. In the end, we spend less time on configuration and we spend more
    time thinking about our data schemas and the data encoding.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯 JSON 中，我们无法确保在编译时我们的模式是正确的。通常，开发者会添加额外的配置，如 JSON Schema，以便在运行时获得这种保证。这增加了我们项目的复杂性，并要求每个开发者都应自律，因为他们可以简单地编写代码而不开发模式。在
    Protobuf 中，我们进行模式驱动开发。模式首先出现，然后我们的应用程序围绕生成的类型展开。此外，我们在编译时确保我们设置的值是正确的，我们不需要将设置复制到所有我们的微服务或子项目中。最终，我们在配置上花费的时间更少，我们在数据模式和数据编码上的思考时间更多。
- en: Encoding details
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码细节
- en: Up until now, we talked a lot about “algorithms”; however, we did not get too
    much into the specifics. In this section, we are going to see the major algorithms
    that are behind the serialization and deserialization processes in Protobuf. We
    are first going to see all the types that we can use for our fields, then with
    that, we are going to divide them into three categories, and finally, we are going
    to explain which algorithm is used for each category.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们谈论了很多关于“算法”的内容；然而，我们并没有深入到具体的细节。在本节中，我们将探讨在 Protobuf 中序列化和反序列化过程中所涉及的
    主要算法。我们首先将查看我们可以用于字段的全部类型，然后根据这些类型，我们将它们分为三个类别，最后我们将解释每个类别所使用的算法。
- en: 'In Protobuf, types that are considered simple and that are provided by Protobuf
    out of the box are called **scalar types**. We can use 15 of such types, as listed
    here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Protobuf 中，被认为是简单且由 Protobuf 自带提供的类型被称为**标量类型**。我们可以使用这里列出的 15 种此类类型：
- en: '`int32`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32`'
- en: '`int64`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int64`'
- en: '`uint32`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint32`'
- en: '`uint64`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint64`'
- en: '`sint32`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sint32`'
- en: '`sint64`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sint64`'
- en: '`fixed32`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed32`'
- en: '`fixed64`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed64`'
- en: '`sfixed32`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sfixed32`'
- en: '`sfixed64`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sfixed64`'
- en: '`double`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`float`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`string`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`bytes`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes`'
- en: '`bool`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`'
- en: And out of these 15 types, 10 are for integers (the 10 first ones). These types
    might be intimidating at first, but do not worry too much about how to choose
    between them right now; we are going to discuss that throughout this section.
    The most important thing to understand right now is that two-thirds of the types
    are for integers, and this shows what Protobuf is good at—encoding integers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这 15 种类型中，有 10 种是用于整数的（前 10 种）。这些类型一开始可能看起来有些令人畏惧，但请不要过于担心如何在这之间做出选择，我们将在本节中讨论这一点。现在最重要的理解是，三分之二的类型是用于整数的，这显示了
    Protobuf 的优势——编码整数。
- en: 'Now that we know the scalar types, let us separate these types into three categories.
    However, we are not here to make simple categories such as numbers, arrays, and
    so on. We want to make categories that are related to the Protobuf serialization
    algorithms. In total, we have three: fixed-size numbers, variable-size integers
    (varints), and length-delimited types. Here is a table with each category populated:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了标量类型，让我们将这些类型分为三个类别。然而，我们在这里不是为了创建简单的类别，比如数字、数组等等。我们想要创建与 Protobuf
    序列化算法相关的类别。总共有三个：固定大小数字、可变大小整数（varints）和长度限定类型。以下是一个包含每个类别的表格：
- en: '| **Fixed-size numbers** | **Varints** | **Length-delimited types** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **固定大小数字** | **Varints** | **Length-delimited types** |'
- en: '| `fixed32` | `int32` | `string` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `fixed32` | `int32` | `string` |'
- en: '| `fixed64` | `int64` | `bytes` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `fixed64` | `int64` | `bytes` |'
- en: '| `sfixed32` | `uint32` |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `sfixed32` | `uint32` |  |'
- en: '| `sfixed64` | `uint64` |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `sfixed64` | `uint64` |  |'
- en: '| `double` | `bool` |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `bool` |  |'
- en: '| `float` |  |  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `float` |  |  |'
- en: Let’s go through each now.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍。
- en: Fixed-size numbers
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定大小数字
- en: 'The easiest one to understand for developers who are used to typed languages
    is fixed-size numbers. If you worked with lower-level languages in which you tried
    to optimize storage space, you know that we can, on most hardware, store an integer
    in 32 bits (4 bytes) or in 64 bits (8 bytes). `fixed32` and `fixed64` are just
    binary representations of a normal number that you would have in languages that
    give you control over the storage size of your integers (for example, Go, C++,
    Rust, and so on). If we serialize the number 42 into a `fixed32` type, we will
    have the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于习惯于静态语言的开发者来说，最容易理解的是固定大小数字。如果你在尝试优化存储空间的底层语言中工作过，你知道在大多数硬件上，我们可以用 32 位（4
    字节）或 64 位（8 字节）存储一个整数。`fixed32` 和 `fixed64` 只是正常数字的二进制表示，这些数字在允许你控制整数存储大小的语言中（例如
    Go、C++、Rust 等）会有。如果我们把数字 42 序列化为 `fixed32` 类型，我们将得到以下结果：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, `2a` is `42`, and `0d` is a combination of the field tag and the type
    of the field (more about that later in this section). In the same manner, if we
    serialize `42` in a `fixed64` type, we will have the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`2a` 是 `42`，而 `0d` 是字段标签和字段类型的组合（关于这一点将在本节后面详细介绍）。以同样的方式，如果我们以 `fixed64`
    类型序列化 `42`，我们将得到以下结果：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And the only thing that changed is the combination between the type of the field
    and the field tag (`09`). This is mostly because we changed the type to 64-bit
    numbers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一改变的是字段类型和字段标签的组合（`09`）。这主要是因为我们将类型更改为 64 位数字。
- en: 'Two other scalar types that are easy to understand are `float` and `double`.
    Once again, Protobuf produces the binary representation of these types. If we
    encode `42.42` as `float`, we will get the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 两种易于理解的标量类型是 `float` 和 `double`。再次强调，Protobuf 会生成这些类型的二进制表示。如果我们把 `42.42` 编码为
    `float`，将会得到以下输出：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, this is a little bit more complicated to decode, but this is
    simply because float numbers are encoded differently. If you are interested in
    this kind of data storage, you can look at the *IEEE Standard for Floating-Point
    Arithmetic* (*IEEE 754*), which explains how a float is formed in memory. What
    is important to note here is that floats are encoded in 4 bytes, and in front,
    we have our tag + type. And for a `double` type with a value of `42.42`, we will
    get the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，解码稍微复杂一些，但这仅仅是因为浮点数以不同的方式编码。如果你对这种数据存储感兴趣，可以查看 *IEEE 浮点算术标准* (*IEEE 754*)，它解释了浮点数在内存中的形成方式。这里需要注意的是，浮点数以
    4 个字节编码，前面是我们的标签 + 类型。而对于值为 `42.42` 的 `double` 类型，我们将得到以下结果：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is encoded in 8 bytes and the tag + type. Note that the tag + type also
    changed here because we are in the realm of 64-bit numbers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这以 8 字节编码，并带有标签 + 类型。请注意，标签 + 类型在这里也发生了变化，因为我们现在处于 64 位数字的领域。
- en: 'Finally, we are left with `sfixed32` and `sfixed64`. We did not mention it
    earlier, but `fixed32` and `fixed64` are unsigned numbers. This means that we
    cannot store negative numbers in fields with these types. `sfixed32` and `sfixed64`
    solve that. So, if we encode –42 in a `sfixed32` type, we will have the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们剩下 `sfixed32` 和 `sfixed64`。我们之前没有提到它，但 `fixed32` 和 `fixed64` 是无符号数。这意味着我们无法在具有这些类型的字段中存储负数。`sfixed32`
    和 `sfixed64` 解决了这个问题。因此，如果我们把 `-42` 编码为 `sfixed32` 类型，我们将得到以下结果：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is obtained by taking the binary for 42, flipping all the bits (1’s complement),
    and adding one (2’s complement). Otherwise, if you serialize a positive number,
    you will have the same binary as the `fixed32` type. Then, if we encode –42 in
    a field with type `sfixed64`, we will get the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过取42的二进制表示，翻转所有位（1的补码），然后加1（2的补码）得到的。否则，如果你序列化一个正数，你将得到与`fixed32`类型相同的二进制表示。然后，如果我们用类型为`sfixed64`的字段编码-42，我们将得到以下结果：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is like the `sfixed32` type, only the tag + type was changed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于`sfixed32`类型，只是标签+类型发生了变化。
- en: To summarize, fixed integers are simple binary representations of integers that
    resemble how they are stored in most computers’ memory. As their name suggests,
    their serialized data will always be serialized into the same number of bytes.
    For some use cases, this is fine to use such representations; however, in most
    cases, we would like to reduce the number of bits that are just here for padding.
    And in these use cases, we will use something called varints.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，固定整数是整数在大多数计算机内存中存储方式的简单二进制表示。正如其名所示，它们的序列化数据将始终序列化成相同数量的字节。对于某些用例，使用这种表示是可行的；然而，在大多数情况下，我们希望减少仅用于填充的比特数。在这些用例中，我们将使用称为varints的东西。
- en: Varints
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Varints
- en: 'Now that we have seen fixed integers, let us move to another type of serialization
    for numbers: variable-length integers. As its name suggests, we will not get a
    fixed number of bytes when serializing an integer.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了固定整数，让我们转向另一种数字序列化类型：可变长度整数。正如其名所示，在序列化整数时，我们不会得到固定数量的字节。
- en: To be more precise, the smaller the integer, the smaller the number of bytes
    it will be serialized into, and the bigger the integer, the larger the number
    of bytes. Let us look at how the algorithm works.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精确，整数越小，它序列化成的字节数就越少，整数越大，它序列化成的字节数就越多。让我们看看算法是如何工作的。
- en: 'In this example, let us serialize the number 300\. To start, we are going to
    take the binary representation of that number:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们序列化数字300。首先，我们将取这个数字的二进制表示：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this binary, we can now split it into groups of 7 bits and pad with zeros
    if needed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个二进制，我们现在可以将其分成7位一组，并在需要时用零填充：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, since we lack 2 more bits to create 2 bytes, we are going to add 1 as
    the **most significant bit** (**MSB**) for all the groups except the first one,
    and we are going to add 0 as the MSB for the first group:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们缺少2个比特来创建2个字节，我们将为除了第一个组之外的所有组添加1作为**最高有效位**（**MSB**），并且我们将为第一个组添加0作为MSB：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These MSBs are continuation bits. This means that, when we have 1, we still
    have 7 bits to read after, and if we have 0, this is the last group to be read.
    Finally, we put this number into little-endian order, and we have the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些MSB是连续位。这意味着，当我们有1时，我们后面还有7个比特要读取，如果我们有0，这就是要读取的最后一个组。最后，我们将这个数字放入小端序，我们得到以下：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or, we would have `AC 02` in hexadecimal. Now that we have serialized 300 into
    `AC 02`, and keeping in mind that deserialization is the opposite of serialization,
    we can deserialize that data. We take our binary representation for `AC 02`, drop
    the continuation bits (MSBs), and we reverse the order of bytes. In the end, we
    have the following binary:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们会在十六进制中表示为`AC 02`。现在我们已经将300序列化为`AC 02`，并且考虑到反序列化是序列化的相反过程，我们可以反序列化这些数据。我们取`AC
    02`的二进制表示，丢弃连续位（MSB），并反转字节的顺序。最后，我们得到以下二进制：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the same binary we started with. It equals 300.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的起始二进制相同。它等于300。
- en: 'Now, in the real world, you might have larger numbers. For a quick reference
    on positive numbers, here is a list of the thresholds at which the number of bytes
    will increase:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在现实世界中，你可能会遇到更大的数字。关于正数的快速参考，以下是一个列表，列出了字节数量增加的阈值：
- en: '| **Threshold value** | **Byte size** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **阈值值** | **字节大小** |'
- en: '| 0 | 0 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 |'
- en: '| 1 | 1 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 128 | 2 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 2 |'
- en: '| 16,384 | 3 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 16,384 | 3 |'
- en: '| 2,097,152 | 4 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 2,097,152 | 4 |'
- en: '| 268,435,456 | 5 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 268,435,456 | 5 |'
- en: '| 34,359,738,368 | 6 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 34,359,738,368 | 6 |'
- en: '| 4,398,046,511,104 | 7 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 4,398,046,511,104 | 7 |'
- en: '| 562,949,953,421,312 | 8 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 562,949,953,421,312 | 8 |'
- en: '| 72,057,594,037,927,936 | 9 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 72,057,594,037,927,936 | 9 |'
- en: '| 9,223,372,036,854,775,807 | 9 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 9,223,372,036,854,775,807 | 9 |'
- en: 'An astute reader might have noticed that having a varint is often beneficial,
    but in some cases, we might encode our values into more bytes than needed. For
    example, if we encode 72,057,594,037,927,936 into an `int64` type, it will be
    serialized into 9 bytes, while with a `fixed64` type, it will be encoded into
    8\. Furthermore, a problem coming from the encoding that we just saw is that negative
    numbers will be encoded into a large positive number and thus will be encoded
    into 9 bytes. That begs the following question: *How can we efficiently choose
    between the different* *integer types?*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敏锐的读者可能会注意到，使用varint通常是有益的，但在某些情况下，我们可能将值编码成比所需更多的字节。例如，如果我们把720,575,904,037,927,936编码成`int64`类型，它将被序列化为9字节，而使用`fixed64`类型，它将被编码为8字节。此外，我们刚才看到的编码问题之一是负数将被编码成一个大的正数，因此将被编码成9字节。这引出了以下问题：*我们如何有效地在不同的整数类型之间进行选择？*
- en: How to choose?
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何选择？
- en: 'The answer is, as always, it depends. However, we can be systematic in our
    choices to avoid many errors. We mostly have three choices that we need to make
    depending on the data we want to serialize:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，一如既往，这取决于具体情况。然而，我们可以系统地做出选择，以避免许多错误。我们主要需要根据我们想要序列化的数据做出以下三个选择：
- en: The range of numbers needed
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的数字范围
- en: The need for negative numbers
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负数的需要
- en: The data distribution
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分布
- en: The range
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范围
- en: By now, you might have noticed that the 32 and 64 suffixes on our types are
    not always about the number of bits into which our data will be serialized. For
    varints, this is more about the range of numbers that can be serialized. These
    ranges are dependent on the algorithm used for serialization.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经注意到我们类型上的32和64后缀并不总是关于我们的数据将被序列化成多少位。对于varints，这更多的是关于可以序列化的数字范围。这些范围取决于用于序列化的算法。
- en: 'For fixed, signed, and variable-length integers, the range of numbers is the
    same as the one developers are used to with 32 and 64 bits. This means that we
    get the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于固定、有符号和可变长度的整数，数字的范围与开发者在32位和64位上所习惯的范围相同。这意味着我们得到以下：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `NUMBER_OF_BITS` is either 32 or 64 depending on the type you want to
    use.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`NUMBER_OF_BITS`取决于你想要使用的类型，是32还是64。
- en: 'For unsigned numbers (`uint`)—this is again like what developers are expecting—we
    will get the following range:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无符号数字（`uint`）——这又像是开发者所期望的那样——我们将得到以下范围：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The need for negative numbers
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 负数的需要
- en: In the case where you simply do not need negative numbers (for example, for
    IDs), the ideal type to use is an unsigned integer (`uint32`, `uint64`). This
    will prevent you from encoding negative numbers, it will have twice the range
    in positive numbers compared to signed integers, and it will serialize using the
    varint algorithm.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在你根本不需要负数的情况下（例如，对于ID），理想的使用类型是无符号整数（`uint32`，`uint64`）。这将防止你编码负数，与有符号整数相比，它在正数上有两倍的取值范围，并且将使用varint算法进行序列化。
- en: And another type that you will potentially work with is the one for signed integers
    (`sint32`, `sint64`). We won’t go into details about how to serialize them, but
    the algorithm transforms any negative number into a positive number (ZigZag encoding)
    and serializes the positive number with the varint algorithm. This is more efficient
    for serializing negative numbers because instead of being serialized as a large
    positive number (9 bytes), we take advantage of the varint encoding. However,
    this is less efficient for serializing positive numbers because now we interleave
    the previously negative numbers and the positive numbers. This means that for
    the same positive number, we might have different amounts of encoding bytes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会遇到另一种类型，即用于有符号整数的类型（`sint32`，`sint64`）。我们不会深入讲解如何序列化它们，但算法会将任何负数转换成正数（ZigZag编码），然后使用varint算法序列化正数。这对于序列化负数来说更有效率，因为我们可以利用varint编码，而不是将负数序列化为一个大的正数（9字节），现在我们使用varint编码。然而，对于序列化正数来说，这就不太有效率了，因为现在我们混合了之前是负数的数字和正数。这意味着对于相同的正数，我们可能会有不同数量的编码字节。
- en: The data distribution
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据分布
- en: Finally, one thing that is worth mentioning is that encoding efficiency is highly
    dependent on your data distribution. You might have chosen some types depending
    on some assumptions, but your actual data might be different. Two common examples
    are choosing an `int32` or `int64` type because we expect to have few negative
    values and choosing an `int64` type because we expect to have few very big numbers.
    Both situations might result in significant inefficiencies because, in both cases,
    we might get a lot of values serialized into 9 bytes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的一点是，编码效率高度依赖于你的数据分布。你可能根据某些假设选择了某些类型，但你的实际数据可能不同。两个常见的例子是选择`int32`或`int64`类型，因为我们预计很少会有负值，以及选择`int64`类型，因为我们预计很少会有非常大的数字。在这两种情况下，都可能导致显著的低效，因为在这两种情况下，我们可能会将很多值序列化为9个字节。
- en: Unfortunately, there is no way of deciding the type that will always perfectly
    fit the data. In this kind of situation, there is nothing better than doing experiments
    on real data that is representative of your whole dataset. This will give you
    an idea of what you are doing correctly and what you are doing wrong.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有一种方法可以决定一个始终完美匹配数据的类型。在这种情况下，最好的办法是在代表你整个数据集的真实数据上做实验。这将给你一个关于你做对了什么和做错了什么的想法。
- en: Length-delimited types
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度限定类型
- en: Now that we’ve seen all the types for numbers, we are left with the length-delimited
    types. These are the types, such as string and bytes, from which we cannot know
    the length at compile time. Think about these as dynamic arrays.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了数字的所有类型，我们剩下的是长度限定类型。这些类型，如字符串和字节，我们在编译时无法知道它们的长度。将这些视为动态数组。
- en: 'To serialize such a dynamic structure, we simply prefix the raw data with the
    length of that data that is following. This means that if we have a string of
    length 10 and content “0123456789”, we will have the following sequence of bytes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要序列化这种动态结构，我们只需在随后的原始数据前加上该数据的长度。这意味着如果我们有一个长度为10的字符串，内容为“0123456789”，我们将有以下字节序列：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the first `0a` instance is the field tag + type, the second `0a` instance
    is the hexadecimal representation of 10, and then we have the ASCII values for
    each character. To see why 0 turns into 30, you can check the ASCII manual by
    typing `man ascii` in your terminal and looking for the hexadecimal set. You should
    have a similar output to the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个`0a`实例是字段标签+类型，第二个`0a`实例是10的十六进制表示，然后是我们每个字符的ASCII值。要了解为什么0变成30，你可以在你的终端中输入`man
    ascii`并查找十六进制集，以查看ASCII手册。你应该会有以下类似的输出：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the first number of each pair is the hexadecimal value for the second
    one.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每一对中的第一个数字是第二个数字的十六进制值。
- en: 'Another kind of message field that will be serialized into a length-delimited
    type is a repeated field. A repeated field is the equivalent of a list. To write
    such a field, we simply add the `repeated` keyword before the field type. If we
    wanted to serialize a list of IDs, we could write the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将被序列化为长度限定类型的消息字段是重复字段。重复字段相当于列表。要写入这样的字段，我们只需在字段类型前加上`repeated`关键字。如果我们想序列化ID列表，我们可以写出以下内容：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And with this, we could store 0 or more IDs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以存储0个或多个ID。
- en: 'Similarly, these fields will be serialized with the length as a prefix. If
    we take the `ids` field and serialize the numbers from 1 to 9, we will have the
    following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这些字段将以长度作为前缀进行序列化。如果我们取`ids`字段并将数字从1到9进行序列化，我们将有以下序列：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a list of 9 elements followed by 1, 2, … and so on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含9个元素的列表，后面跟着1，2，……等等。
- en: Important note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Repeated fields are only serialized as length-delimited types when they are
    storing scalar types except for strings and bytes. These repeated fields are considered
    packed. For complex types or user-defined types (messages), the values will be
    encoded in a less optimal way. Each value will be encoded separately and prefixed
    by the type + tag byte(s) instead of having the type + tag serialized only once.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重复字段仅在存储标量类型（除了字符串和字节）时作为长度限定类型进行序列化。这些重复字段被认为是打包的。对于复杂类型或用户定义的类型（消息），值将以不太优化的方式进行编码。每个值都将单独编码，并以前面加上类型+标签字节（而不是只序列化一次类型+标签）。
- en: Field tags and wire types
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段标签和线类型
- en: 'Up until now, you read “tag + type” multiple times and we did not really see
    what this means. As mentioned, the first byte(s) of every serialized field will
    be a combination of the field type and the field tag. Let us start by seeing what
    a field tag is. You surely noticed something different about the syntax of a field.
    Each time we define a field, we add an equals sign and then an incrementing number.
    Here’s an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你多次读取了“标签+类型”，但我们并没有真正看到这意味着什么。正如之前提到的，每个序列化字段的第一个字节（或字节）将是一个字段类型和字段标签的组合。让我们先看看字段标签是什么。你肯定注意到了字段语法的不同之处。每次我们定义一个字段时，我们都会添加一个等号，然后是一个递增的数字。以下是一个例子：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While they look like an assignment of value to the field, they are only here
    to give a unique identifier to the field. These identifiers, called tags, might
    look insignificant but they are the most important bit of information for serialization.
    They are used to tell Protobuf into which field to deserialize which data. As
    we saw earlier during the presentation of the different serialization algorithms,
    the field name is not serialized—only the type and the tag are. And thus, when
    deserialization kicks in, it will see a number and it will know where to redirect
    the following datum.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们看起来像是将值分配给字段，但它们只是在这里为字段提供一个唯一的标识符。这些标识符，称为标签，可能看起来微不足道，但它们是序列化最重要的信息。它们用于告诉Protobuf将哪些数据反序列化到哪个字段。正如我们在不同序列化算法的展示中看到的，字段名称不会被序列化——只有类型和标签会被序列化。因此，当反序列化开始时，它会看到一个数字，并知道将后续的数据重定向到何处。
- en: 'Now that we know that these tags are simply identifiers, let us see how these
    values are encoded. Tags are simply serialized as varints but they are serialized
    with a wire type. A wire type is a number that is given to a group of types in
    Protobuf. Here is the list of wire types:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道这些标签只是标识符，让我们看看这些值是如何编码的。标签简单地作为varint序列化，但它们与线缆类型一起序列化。线缆类型是分配给Protobuf中一组类型的数字。以下是线缆类型的列表：
- en: '| **Type** | **Meaning** | **Used for** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **含义** | **用于** |'
- en: '| 0 | Varint | `int32`, `int64`, `uint32`, `uint64`, `sint32`, `sint64`, `bool`,
    `enum` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Varint | `int32`、`int64`、`uint32`、`uint64`、`sint32`、`sint64`、`bool`、`enum`
    |'
- en: '| 1 | 64-bit | `fixed64`, `sfixed64`, `double` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64位 | `fixed64`、`sfixed64`、`double` |'
- en: '| 2 | Length-delimited | string, bytes, packed repeated fields |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 长度限定 | 字符串、字节、打包重复字段 |'
- en: '| 5 | 32-bit | `fixed32`, `sfixed32`, `float` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 32位 | `fixed32`、`sfixed32`、`float` |'
- en: Here, 0 is the type for varints, 1 is for 64-bit, and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，0是varint的类型，1是64位，以此类推。
- en: 'To combine the tag and the wire type, Protobuf uses a concept called bit packing.
    This is a technique that is designed to reduce the number of bits into which the
    data will be serialized. In our case here, the data is the field metadata (the
    famous tag + type). So, here is how it works. The last 3 bits of the serialized
    metadata are reserved for the wire type, and the rest is for the tag. If we take
    the first example that we mentioned in the *Fixed-size numbers* section, where
    we serialized 42 in a `fixed32` field with tag 1, we had the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将标签和线缆类型组合起来，Protobuf使用了一个称为位打包的概念。这是一种旨在减少数据序列化所需位数的技巧。在我们的例子中，数据是字段元数据（著名的标签+类型）。所以，这是它的工作方式。序列化元数据的最后3位是保留给线缆类型的，其余的是标签。如果我们拿我们在“固定大小数字”部分提到的第一个例子，在那里我们使用标签1将42序列化到`fixed32`字段中，我们得到以下内容：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This time we are only interested in the `0d` part. This is the metadata of
    the field. To see how this was serialized, let us turn `0d` into binary (with
    0 padding):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们只对`0d`部分感兴趣。这是字段的元数据。为了看到它是如何序列化的，让我们将`0d`转换为二进制（使用0填充）：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we have 101 (5) for the wire type—this is the wire type for 32 bits—and
    we have 00001 (1) for tag 1\. Now, since the tag is serialized as a varint, it
    means that we could have more than 1 byte for that metadata. Here’s a reference
    for knowing the thresholds at which the number of bytes will increase:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为线缆类型有101（5）——这是32位线缆类型——并且为标签1有00001（1）。现在，由于标签被序列化为varint，这意味着该元数据的字节可能超过1个。以下是一个参考，了解字节数量增加的阈值：
- en: '| **Field tag** | **Size (****in bits)** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **字段标签** | **大小（**位**）** |'
- en: '| 1 | 5 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 5 |'
- en: '| 16 | 13 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 13 |'
- en: '| 2,048 | 21 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 2,048 | 21 |'
- en: '| 262,144 | 29 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 262,144 | 29 |'
- en: '| 33,554,432 | 37 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 33,554,432 | 37 |'
- en: '| 536,870,911 | 37 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 536,870,911 | 37 |'
- en: This means that, as fields without values set to them will not be serialized,
    we need to keep the lowest tags to the fields that are the most often populated.
    This will lower the overhead needed to store the metadata. In general, 15 tags
    are enough, but if you come up with a situation where you need more tags, you
    might consider moving a group of data into a new message with lower tags.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，由于没有设置值的字段将不会被序列化，我们需要保留最低的标签给那些最常填充的字段。这将降低存储元数据所需的开销。一般来说，15 个标签就足够了，但如果您遇到需要更多标签的情况，您可能需要考虑将一组数据移动到一个具有更低标签的新消息中。
- en: Common types
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见类型
- en: As of now, if you checked the companion code, you could see that we are defining
    a lot of “boring” types that are just wrappers around one field. It is important
    to note that we wrote them by hand to simply give an example of how you would
    inspect the serialization of certain data. Most of the time, you will be able
    to use already defined types that are doing the same.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果您检查了配套代码，您会看到我们定义了很多“无聊”的类型，它们只是围绕一个字段进行包装。需要注意的是，我们是手动编写的，只是为了简单地给出如何检查某些数据序列化的示例。大多数时候，您将能够使用已经定义的、做同样事情的类型。
- en: Well-known types
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知类型
- en: Protobuf itself comes with a bunch of already defined types. We call them *well-known
    types*. While a lot of them are rarely useful outside of the Protobuf library
    itself or advanced use cases, some of them are important, and we are going to
    use some of them in this book.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 本身自带了一组已经定义的类型。我们称它们为 *已知类型*。虽然其中许多类型在 Protobuf 库本身或高级用例之外很少有用，但其中一些类型很重要，我们将在本书中使用一些这些类型。
- en: 'The ones that we can understand quite easily are the wrappers. We wrote some
    by hand earlier. They usually start with the name of the type they are wrapping
    and finish with `Value`. Here is a list of wrappers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易理解的类型是包装器。我们之前手动编写了一些。它们通常以它们所包装的类型名称开头，并以 `Value` 结尾。以下是一个包装器的列表：
- en: '`BoolValue`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoolValue`'
- en: '`BytesValue`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BytesValue`'
- en: '`DoubleValue`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleValue`'
- en: '`EnumValue`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnumValue`'
- en: '`FloatValue`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FloatValue`'
- en: '`Int32Value`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int32Value`'
- en: '`Int64Value`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int64Value`'
- en: '`StringValue`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringValue`'
- en: '`UInt32Value`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UInt32Value`'
- en: '`UInt64Value`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UInt64Value`'
- en: These types might be interesting for debugging use cases such as the ones we
    saw earlier or just to serialize simple data such as a number, a string, and so
    on.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型可能对调试用例很有趣，比如我们之前看到的那些，或者只是序列化简单的数据，比如数字、字符串等。
- en: 'Then, there are types representing time, such as `Duration` and `Timestamp`.
    These two types are defined in the exact same way ([Duration | Timestamp] is not
    proper protobuf syntax, it means that we could replace by either of both terms):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有一些表示时间的类型，如 `Duration` 和 `Timestamp`。这两个类型是以完全相同的方式定义的（[Duration | Timestamp]
    不是一个正确的 Protobuf 语法，它的意思是我们可以用其中的任何一个术语来替换）：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, as their name suggests, they represent different concepts. A `Duration`
    type is the difference between the start and end time, whereas a `Timestamp` type
    is a simple point in time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如它们的名称所暗示的，它们代表不同的概念。`Duration` 类型是开始时间和结束时间之间的差异，而 `Timestamp` 类型是一个简单的时间点。
- en: Finally, one last important well-known type is `FieldMask`. This is a type that
    represents a set of fields that should be included when serializing another type.
    To understand this one, it might be better to give an example. Let us say that
    we have an API endpoint returning an account with `id`, `username`, and `email`.
    If you wanted to only get the account’s email address to prepare a list of people
    you want to send a promotional email to, you could use a `FieldMask` type to tell
    Protobuf to only serialize the `email` field. This lets us reduce the additional
    cost of serialization and deserialization because now we only deal with one field
    instead of three.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个非常重要的已知类型是 `FieldMask`。这是一个表示在序列化另一个类型时应包含的字段集合的类型。为了理解这个类型，可能给出一个例子会更好。假设我们有一个
    API 端点返回一个包含 `id`、`username` 和 `email` 的账户。如果您只想获取账户的电子邮件地址以准备一个您想要发送促销电子邮件的人的名单，您可以使用
    `FieldMask` 类型告诉 Protobuf 只序列化 `email` 字段。这让我们减少了序列化和反序列化的额外成本，因为我们现在只处理一个字段而不是三个。
- en: Google common types
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google 常见类型
- en: 'On top of well-known types, there are types that are defined by Google. These
    are defined in the `googleapis/api-commo``n-protos` GitHub repository under the
    `goo``gle/type` directory and are easily usable in Golang code. I encourage you
    to check all the types, but I want to mention some interesting ones:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在已知的类型之上，还有一些是由 Google 定义的类型。这些类型定义在 `googleapis/api-common-protos` GitHub 仓库下的
    `google/type` 目录中，并且可以在 Golang 代码中轻松使用。我鼓励您检查所有类型，但我想要提及一些有趣的类型：
- en: '`LatLng`: A latitude/longitude pair storing the values as doubles'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LatLng`: 存储为双精度浮点数的纬度/经度对'
- en: '`Money`: An amount of money with its currency as defined by ISO 4217'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Money`: 带有按 ISO 4217 定义的货币的金额'
- en: '`Date`: Year, Month, and Day stored as `int32`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date`: 年、月和日以 `int32` 存储的日期'
- en: Once again, go to the repository to check all the others. These types are battle-tested
    and in a lot of cases more optimized than trivial types that we would write. However,
    be aware that these types might also not be a good fit for your use cases. There
    is no such thing as a one-size-fits-all solution.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，前往仓库检查所有其他内容。这些类型已经过实战检验，并且在很多情况下比我们编写的简单类型更优化。然而，请注意，这些类型可能也不适合您的用例。没有一种适合所有情况的解决方案。
- en: Services
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'Finally, the last construct that is important to see and that we are going
    to work with during this book is the service one. In Protobuf, a service is a
    collection of RPC endpoints that contains two major parts. The first part is the
    input of the RPC, and the second is the output. So, if we wanted to define a service
    for our accounts, we could have something like the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要关注并将在本书中使用的最后一个结构是服务。在 Protobuf 中，一个服务是一组 RPC 端点，包含两个主要部分。第一部分是 RPC 的输入，第二部分是输出。因此，如果我们想为我们的账户定义一个服务，我们可以有如下所示的内容：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we define a message representing a request, and another one representing
    the response and we use these as input and output of our `getAccount` RPC call.
    In the next chapter, we are going to cover more advanced usage of the services,
    but right now what is important to understand is that Protobuf defines the services
    but does not generate the code for them. Only gRPC will.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个表示请求的消息，另一个表示响应的消息，我们使用这些作为 `getAccount` RPC 调用的输入和输出。在下一章中，我们将介绍更多关于服务的先进用法，但当前重要的是要理解
    Protobuf 定义了服务，但不会为它们生成代码。只有 gRPC 会这样做。
- en: Protobuf’s services are here to describe a contract, and it is the job of an
    RPC framework to fulfill that contract on the client and server part. Notice that
    I wrote *an RPC framework* and not simply gRPC. Any RPC framework could read the
    information provided by Protobuf’s services and generate code out of it. The goal
    of Protobuf here is to be independent of any language and framework. What the
    application does with the serialized data is not important to Protobuf.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 的服务在这里是为了描述一个合同，并且是 RPC 框架的工作在客户端和服务器端履行这个合同。请注意，我写的是 *一个 RPC 框架*，而不是简单的
    gRPC。任何 RPC 框架都可以读取 Protobuf 服务提供的信息并从中生成代码。在这里，Protobuf 的目标是独立于任何语言和框架。应用程序对序列化数据所做的事情对
    Protobuf 来说并不重要。
- en: 'Finally, these services are the pillars of gRPC. As we are going to see later
    in this book, we will use them to make requests, and we are going to implement
    them on the server side to return responses. Using the defined services on the
    client side will let us feel like we are directly calling a function on the server.
    If we talk about `AccountService`, for example, we can make a call to `GetAccount`
    by having the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这些服务是 gRPC 的支柱。正如我们将在本书后面看到的那样，我们将使用它们来发起请求，并在服务器端实现它们以返回响应。在客户端使用定义的服务将让我们感觉就像直接在服务器上调用一个函数。如果我们以
    `AccountService` 为例，我们可以通过以下代码调用 `GetAccount`：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `client` is an instance of a gRPC client, `req` is an instance of `GetAccountRequest`,
    and `res` is an instance of `GetAccountResponse`. In this case, it feels a little
    bit like we are calling `GetAccount`, which is implemented on the server side.
    However, this is the doing of gRPC. It will hide all the complex ceremony of serializing
    and deserializing objects and sending those to the client and server.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`client` 是 gRPC 客户端的实例，`req` 是 `GetAccountRequest` 的实例，而 `res` 是 `GetAccountResponse`
    的实例。在这种情况下，这有点像我们在调用服务器端实现的 `GetAccount`。然而，这是 gRPC 的作用。它将隐藏所有复杂的序列化和反序列化对象以及将它们发送到客户端和服务器的过程。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to write messages and services, and we saw how scalar
    types are serialized and deserialized. This prepared us for the rest of the book,
    where we are going to use this knowledge extensively.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何编写消息和服务，以及标量类型是如何序列化和反序列化的。这为我们准备了一本书的其余部分，我们将广泛使用这些知识。
- en: In the next chapter, we are going to talk about gRPC, why it uses Protobuf for
    serialization and deserialization, and what it is doing behind the scenes, and
    we are going to compare it with REST and GraphQL APIs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论gRPC，为什么它使用Protobuf进行序列化和反序列化，以及它在幕后做了什么，我们还将将其与REST和GraphQL API进行比较。
- en: Quiz
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: What is the number 32 representing in the `int32` scalar type?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字32在`int32`标量类型中代表什么？
- en: The number of bits the serialized data will be stored in
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化数据将存储的位数
- en: The range of numbers that can fit into the scalar type
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以适合标量类型的数字范围
- en: Whether the type can accept negative numbers or not
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型是否可以接受负数
- en: What is varint encoding doing?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: varint编码在做什么？
- en: Compressing data in such a way that a smaller number of bytes will be required
    for serializing data
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式压缩数据，使得序列化数据所需的字节数更少
- en: Turning every negative number into positive numbers
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个负数转换为正数
- en: What is ZigZag encoding doing?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ZigZag编码在做什么？
- en: Compressing data in such a way that a smaller number of bytes will be required
    for serializing data
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式压缩数据，使得序列化数据所需的字节数更少
- en: Turning every negative number into a positive number
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个负数转换为正数
- en: In the following code, what is the `= 1` syntax and what is it used for?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，`= 1`语法是什么，它用来做什么？
- en: '[PRE29]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is assigning the value 1 to a field
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是在将值1赋给一个字段
- en: 1 is an identifier that has no other purpose than helping developers
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1是一个标识符，其唯一目的是帮助开发者
- en: 1 is an identifier that is helping the compiler know into which field to deserialize
    the binary data.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1是一个标识符，它帮助编译器知道将二进制数据反序列化到哪个字段。
- en: What is a message?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息是什么？
- en: An object that contains fields and represents an entity
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含字段并代表实体的对象
- en: A collection of API endpoints
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: API端点集合
- en: A list of possible states
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能状态列表
- en: What is an enum?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举是什么？
- en: An object that contains fields and represents an entity
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含字段并代表实体的对象
- en: A collection of API endpoints
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: API端点集合
- en: A list of possible states
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能状态列表
- en: What is a service?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务是什么？
- en: An object that contains fields and represents an entity
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含字段并代表实体的对象
- en: A collection of API endpoints
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: API端点集合
- en: A list of possible states
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能状态列表
- en: Answers
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: B
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: A
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: C
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: A
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: C
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: B
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
