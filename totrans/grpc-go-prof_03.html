<html><head></head><body>
<div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-57"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-58"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.2.1">Introduction to gRPC</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Now that we have a basic understanding of how data flows over the network and how Protobuf works, we can enter the gRPC world. </span><span class="koboSpan" id="kobo.3.2">In this chapter, the goal is to understand what gRPC is doing on top of HTTP/2 and why Protobuf is the perfect fit for gRPC, and also to see that gRPC is a mature technology backed up by major companies in the industry. </span><span class="koboSpan" id="kobo.3.3">This will give us a sense of why gRPC is described as “Protobuf over HTTP/2” and make us confident in using it without fearing that the technology is too new and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">without community.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Major use cases </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">for gRPC</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Advantages of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">using Protobuf</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">The role of gRPC on top </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">of Protobuf</span></span></li>
</ul>
<h1 id="_idParaDest-59"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.13.1">Prerequisites</span></h1>
<p><span class="koboSpan" id="kobo.14.1">You can find the code for this chapter at </span><a href="https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3"><span class="koboSpan" id="kobo.15.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3</span></a><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">During this chapter, I will be using protoc to generate Go code out of </span><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">.proto</span></strong><span class="koboSpan" id="kobo.18.1"> files. </span><span class="koboSpan" id="kobo.18.2">This means that you need to make sure you have protoc installed. </span><span class="koboSpan" id="kobo.18.3">You can download a zip file from the </span><strong class="bold"><span class="koboSpan" id="kobo.19.1">Releases</span></strong><span class="koboSpan" id="kobo.20.1"> page of the Protobuf GitHub repository (</span><a href="https://github.com/protocolbuffers/protobuf/releases"><span class="koboSpan" id="kobo.21.1">https://github.com/protocolbuffers/protobuf/releases</span></a><span class="koboSpan" id="kobo.22.1">); uncompress it and follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">readme.txt</span></strong><span class="koboSpan" id="kobo.24.1"> instructions (note: we do intend to use Well-Known Types in the future so make sure you also install the includes). </span><span class="koboSpan" id="kobo.24.2">On top of protoc, you are going to need two protoc plugins: </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">protoc-gen-go</span></strong><span class="koboSpan" id="kobo.26.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">protoc-gen-go-grpc</span></strong><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">The former generates Protobuf code, and the latter generates gRPC code. </span><span class="koboSpan" id="kobo.28.3">To add them, you can simply run the </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">following commands:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.30.1">
$ go install google.golang.org/protobuf/cmd/protoc-gen-go
  @latest
$ go install google.golang.org/grpc/cmd/protoc-gen-go-
  grpc@latest</span></pre>
<p><span class="koboSpan" id="kobo.31.1">And finally, make sure that your </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">GOPATH</span></strong><span class="koboSpan" id="kobo.33.1"> environment variable is in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">PATH</span></strong><span class="koboSpan" id="kobo.35.1"> environment variable. </span><span class="koboSpan" id="kobo.35.2">Normally, this is already done for you on the installation of Golang, but if you get any error related to not finding </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">protoc-gen-go</span></strong><span class="koboSpan" id="kobo.37.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">protoc-gen-go-grpc</span></strong><span class="koboSpan" id="kobo.39.1">, you will need to do it manually. </span><span class="koboSpan" id="kobo.39.2">To get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">GOPATH</span></strong><span class="koboSpan" id="kobo.41.1"> environment variable, you can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.43.1">
$ go env GOPATH</span></pre>
<p><span class="koboSpan" id="kobo.44.1">And then, depending on your OS, you can go through the steps of adding the output to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">PATH</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.46.1">environment variable.</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.47.1">A mature technology</span></h1>
<p><span class="koboSpan" id="kobo.48.1">gRPC is not just another new cool framework</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.49.1"> that you can disregard as being a fad It is a framework that has been battle-tested at scale for over a decade by Google. </span><span class="koboSpan" id="kobo.49.2">Originally, the project was for internal use, but in 2016, Google decided to provide an open source version of it that was not tied to the specifics of the company’s internal tooling </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">and architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">After that, companies such as Uber—and a lot more—migrated their existing services to gRPC for efficiency but also for all the extra features that it offers. </span><span class="koboSpan" id="kobo.51.2">Moreover, some open projects such as etcd, which is a distributed key-value store used at the core of Kubernetes, use gRPC for communication across </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">multiple instances.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Recently, Microsoft joined the effort around building a .NET implementation of gRPC. </span><span class="koboSpan" id="kobo.53.2">While it is not the goal of this book to explain what it did, it clearly shows an interest in the project. </span><span class="koboSpan" id="kobo.53.3">Furthermore, the more that companies such as this are willing to contribute, the more resources will be out there and the greater the community/tooling available will be. </span><span class="koboSpan" id="kobo.53.4">The project has a powerful backup, and this is good for all </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">of us.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Now, all of this sounds amazing, but I am aware that most of us will not reach the scale of these giants, so it is important to understand what gRPC is good at. </span><span class="koboSpan" id="kobo.55.2">Let us see some use cases where it shines. </span><span class="koboSpan" id="kobo.55.3">The first use case</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.56.1"> that everyone is talking about is communication for microservices. </span><span class="koboSpan" id="kobo.56.2">This use case is an appealing one, especially for polyglot microservices. </span><span class="koboSpan" id="kobo.56.3">Our job as software engineers is to choose the right job for the right tool and code generation in different languages to enable us to </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">do that.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Another use case is real-time updates. </span><span class="koboSpan" id="kobo.58.2">As we saw, gRPC gives us the possibility of streaming data. </span><span class="koboSpan" id="kobo.58.3">This comes in multiple flavors such as server streaming, which could be useful for keeping up to date with data such as stock prices. </span><span class="koboSpan" id="kobo.58.4">Then, we have client streaming, which could be useful for sensors streaming data to backends. </span><span class="koboSpan" id="kobo.58.5">And finally, we have bi-directional streaming, which could be interesting when both the client and server need to be aware of each other’s updates, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">messaging apps.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Another</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.61.1"> important use case is </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">inter-process communication</span></strong><span class="koboSpan" id="kobo.63.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.64.1">IPC</span></strong><span class="koboSpan" id="kobo.65.1">). </span><span class="koboSpan" id="kobo.65.2">This is communication happening</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.66.1"> on the same machine between different processes. </span><span class="koboSpan" id="kobo.66.2">It can be</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.67.1"> useful for synchronizing two or more distinct applications, implementing </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">separation of concerns</span></strong><span class="koboSpan" id="kobo.69.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.70.1">SOC</span></strong><span class="koboSpan" id="kobo.71.1">) with a modular architecture, or increasing security by having </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">application sandboxing.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Obviously, I presented the most common applications of gRPC that I can see out there, but there are a lot more applications of it, and it is important that you test it on your use case to see whether it fits your requirements. </span><span class="koboSpan" id="kobo.73.2">And if you are interested in testing gRPC, you will need to start trying to find out how Protobuf can reduce your payloads and </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">application efficiency.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.75.1">Why Protobuf?</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">By now, you should </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.77.1">understand that Protobuf provides us with a way of writing data schemas describing how our data should be serialized and deserialized. </span><span class="koboSpan" id="kobo.77.2">Then, the Protobuf compiler (protoc) lets us generate some code from these schemas to use the generated types in our code, and these serializable types are exactly what gRPC uses to let user code interact with request and response objects and let the gRPC framework send binary representations of them over </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">the wire.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">The binary representation of messages is the biggest reason Protobuf is used as the default data schema for gRPC. </span><span class="koboSpan" id="kobo.79.2">The data is serialized in way fewer bytes than traditional data schemas (XML, JSON, and so on). </span><span class="koboSpan" id="kobo.79.3">This means that not only can the message be delivered faster, but also that it will be </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">deserialized faster.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.81.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.82.1">The following experiment is mostly done to show Protobuf’s performance. </span><span class="koboSpan" id="kobo.82.2">Examples are exaggerated, but this will give you a sense of the additional cost that JSON has during deserialization. </span><span class="koboSpan" id="kobo.82.3">The results might vary across the run, OS, and hardware, so if you want to run your own experiment, you can find the benchmarking code and data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">chapter3</span></strong><span class="koboSpan" id="kobo.84.1"> folder (</span><a href="https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3"><span class="koboSpan" id="kobo.85.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3</span></a><span class="koboSpan" id="kobo.86.1">). </span><span class="koboSpan" id="kobo.86.2">To get the data, you will have to unzip it with gzip. </span><span class="koboSpan" id="kobo.86.3">You can do that by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">gzip -dk accounts.json.gz</span></strong><span class="koboSpan" id="kobo.88.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">gzip -dk accounts.bin.gz</span></strong><span class="koboSpan" id="kobo.90.1"> command. </span><span class="koboSpan" id="kobo.90.2">After that, to run the experiment, you first need to compile the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">.proto</span></strong><span class="koboSpan" id="kobo.92.1"> files with </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">protoc --go_out=proto -Iproto --go_opt=module=</span></strong><span class="koboSpan" id="kobo.94.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/proto proto/*</span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">.proto</span></strong><span class="koboSpan" id="kobo.96.1">, and then you can execute the Go code by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">go run main.go</span></strong><span class="koboSpan" id="kobo.98.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">chapter3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.100.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">To demonstrate that, we can do a simple experiment—we can generate 100,000 accounts (with an ID + username), run the deserialization 1,000 times, and calculate the mean time needed to deserialize all the data. </span><span class="koboSpan" id="kobo.101.2">Here are the results from one of the runs with untrimmed (newlines and spaces) JSON against the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">Protobuf binary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.103.1">
JSON: 49.773ms
PB: 9.995ms</span></pre>
<p><span class="koboSpan" id="kobo.104.1">However, most developers do trim their JSON, so here is the result after removing newlines </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">and spaces:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
JSON: 38.692ms
PB: 9.712ms</span></pre>
<p><span class="koboSpan" id="kobo.107.1">It is better but still significantly</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.108.1"> slower </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">than Protobuf.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">And finally, we can look at the serialized data size for the data used in the experiment. </span><span class="koboSpan" id="kobo.110.2">For the uncompressed JSON versus uncompressed Protobuf, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
1.3M  accounts.bin
3.1M  accounts.json</span></pre>
<p><span class="koboSpan" id="kobo.113.1">And for the compressed version (gzip), we have </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">this output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
571K accounts.bin.gz
650K accounts.json.gz</span></pre>
<p><span class="koboSpan" id="kobo.116.1">I encourage you to experiment more with this and especially experiment for your use cases but, unless there is a big mistake in the proto file design, you will find that Protobuf is way more efficient in terms of size and </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">serialization/deserialization time.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">On top of providing data serialization, we saw that Protobuf also has a concept of service, which is a contract between clients and servers. </span><span class="koboSpan" id="kobo.118.2">While this concept is not linked exclusively to gRPC (you could generate code wrapping other frameworks), gRPC uses that to generate the appropriate API endpoints. </span><span class="koboSpan" id="kobo.118.3">This provides us with type safety on both the client and server sides. </span><span class="koboSpan" id="kobo.118.4">If we try to send incorrect data and we work in a compiled language, we will get a compilation error instead of getting an error at runtime. </span><span class="koboSpan" id="kobo.118.5">This dramatically shortens the feedback loop for developers and reduces the area of possible failures in </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">Finally, Protobuf itself is language-agnostic. </span><span class="koboSpan" id="kobo.120.2">This means that this is an independent data schema, and it can be shared across multiple projects. </span><span class="koboSpan" id="kobo.120.3">If you have code written in C++ for some microcontroller, sending data to a backend written in Go, which is in turn sending data to a web frontend in JS, you can simply share the same Protobuf file and generate your models with protoc. </span><span class="koboSpan" id="kobo.120.4">You do not have to rewrite them every time in the different projects. </span><span class="koboSpan" id="kobo.120.5">This decreases the area that needs to be updated on adding or updating features and provides an interface that multiple teams need to </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">agree on.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">In the end, Protobuf enables faster</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.123.1"> communication (for example, through gRPC) by creating smaller payloads, it provides us with type safety on both ends of the communication, and it does all that across multiple languages so that we can use the right tool for the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">right job.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.125.1">What is gRPC doing?</span></h1>
<p><span class="koboSpan" id="kobo.126.1">gRPC is described as “Protobuf over HTTP/2.” </span><span class="koboSpan" id="kobo.126.2">This</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.127.1"> means that gRPC will generate all the communication code wrapping the gRPC framework and stand on Protobuf’s shoulders to serialize and deserialize data. </span><span class="koboSpan" id="kobo.127.2">To know which API endpoints are available on the client and server, gRPC will look at the services defined in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">.proto</span></strong><span class="koboSpan" id="kobo.129.1"> files, and from that, it will learn the basic information needed to generate some metadata and the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">functions needed.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">The first thing to understand with gRPC is that there are multiple implementations. </span><span class="koboSpan" id="kobo.131.2">In Go, for example, you get a pure implementation of gRPC. </span><span class="koboSpan" id="kobo.131.3">This means that the entire code generation process and communication is written in Go. </span><span class="koboSpan" id="kobo.131.4">Other languages might have similar implementations, but a lot of them are wrappers around the C implementation. </span><span class="koboSpan" id="kobo.131.5">While we do not need to know anything about them in the context of this book, it is important to know that they are available because it explains the presence of plugins for the </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">protoc compiler.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">As you know, there are a lot of languages out there. </span><span class="koboSpan" id="kobo.133.2">Some are relatively new, and some are pretty old, so staying on top of every language’s evolution is practically infeasible. </span><span class="koboSpan" id="kobo.133.3">That is why we have protoc plugins. </span><span class="koboSpan" id="kobo.133.4">Every developer or company interested in supporting a language can write such a plugin to generate code that will send Protobuf over HTTP/2. </span><span class="koboSpan" id="kobo.133.5">This is, for example, the case for Swift support, which was added </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">by Apple.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">Since we are talking about Go, we want to look at what kind of code is generated to get a sense of how gRPC works</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.136.1"> but also to know how to debug and where to look for function signatures. </span><span class="koboSpan" id="kobo.136.2">Let us start with a simple service—in </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">proto/account.proto</span></strong><span class="koboSpan" id="kobo.138.1">, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
syntax = "proto3";
option go_package = "github.com/PacktPublishing/
  gRPC-Go-for-Professionals";
message Account {
  uint64 id = 1;
  string username = 2;
}
message LogoutRequest {
</span><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.141.1">  Account account = 1;
}
message LogoutResponse {}
service AccountService {
  rpc Logout (LogoutRequest) returns (LogoutResponse);
}</span></pre>
<p><span class="koboSpan" id="kobo.142.1">In this service, we have an API endpoint named </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">Logout</span></strong><span class="koboSpan" id="kobo.144.1"> that takes as a parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">LogoutRequest</span></strong><span class="koboSpan" id="kobo.146.1"> (a wrapper around </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Account</span></strong><span class="koboSpan" id="kobo.148.1">) and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">LogoutResponse</span></strong><span class="koboSpan" id="kobo.150.1"> parameter. </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">LogoutResponse</span></strong><span class="koboSpan" id="kobo.152.1"> is an empty message  because we want to send the account for which the session needs to be stopped and we do not need any result, just an indicator that the call </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">went well.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">Then, to generate Protobuf and gRPC code out of this, we will run the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
$ protoc --go_out=. </span><span class="koboSpan" id="kobo.156.2">\
         --go_opt=module=github.com/PacktPublishing/gRPC-Go-for-
           Professionals \
         --go-grpc_out=. </span><span class="koboSpan" id="kobo.156.3">\
         --go-grpc_opt=module=github.com/PacktPublishing/gRPC-Go-for-
           Professionals \
         proto/account.proto</span></pre>
<p><span class="koboSpan" id="kobo.157.1">We already saw with Protobuf that</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.158.1"> the messages will be turned into structs, but now we also have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">_grpc.pb.go</span></strong><span class="koboSpan" id="kobo.160.1"> file that contains the gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">communication code.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.162.1">The server</span></h2>
<p><span class="koboSpan" id="kobo.163.1">Let us look at what was generated on the server side</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.164.1"> first. </span><span class="koboSpan" id="kobo.164.2">We are going to start from the bottom of the file with the service descriptor. </span><span class="koboSpan" id="kobo.164.3">But first, we need to know what a descriptor is. </span><span class="koboSpan" id="kobo.164.4">In Protobuf and gRPC context, a descriptor</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.165.1"> is a meta object that represents Protobuf code. </span><span class="koboSpan" id="kobo.165.2">This means that, in our case, we have a Go object representing a service or other concepts. </span><span class="koboSpan" id="kobo.165.3">In fact, we did not deep-dive into it in the previous chapter but if you look at the generated code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Account</span></strong><span class="koboSpan" id="kobo.167.1">, you will also find </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Desc</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.169.1">being mentioned.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">For our </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">AccountService</span></strong><span class="koboSpan" id="kobo.172.1"> service, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">following descriptor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
var AccountService_ServiceDesc = grpc.ServiceDesc{
  ServiceName: "</span><strong class="bold"><span class="koboSpan" id="kobo.175.1">AccountService</span></strong><span class="koboSpan" id="kobo.176.1">",
  HandlerType: (</span><strong class="bold"><span class="koboSpan" id="kobo.177.1">*AccountServiceServer</span></strong><span class="koboSpan" id="kobo.178.1">)(nil),
  Methods: []grpc.MethodDesc{
    {
      MethodName: </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">"Logout"</span></strong><span class="koboSpan" id="kobo.180.1">,
      Handler: </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">_AccountService_Logout_Handler</span></strong><span class="koboSpan" id="kobo.182.1">,
    },
  },
  Streams: []grpc.StreamDesc{},
  Metadata: "account.proto",
}</span></pre>
<p><span class="koboSpan" id="kobo.183.1">This means that we have a service called </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">AccountService</span></strong><span class="koboSpan" id="kobo.185.1"> that is linked to a type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">AccountServiceServer</span></strong><span class="koboSpan" id="kobo.187.1">, and this service has a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Logout</span></strong><span class="koboSpan" id="kobo.189.1"> that should be handled by a function </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">_AccountService_Logout_Handler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">You should find the handler</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.194.1"> above the service descriptor. </span><span class="koboSpan" id="kobo.194.2">This looks like the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">following (simplified):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
func _AccountService_Logou</span><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.197.1">t_Handler(srv interface{}, ctx
  context.Cont</span><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.198.1">ext, dec func(interface{}) error, interceptor
    grpc.UnaryServer</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.199.1">Interceptor) (interface{</span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.200.1">}, err</span><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.201.1">or) {
  in := new(Logout</span><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.202.1">Request)
  if er</span><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.203.1">r := de</span><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.204.1">c(in); err != nil {
    return nil, err
  }
  if i</span><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.205.1">nterceptor == nil {
    return srv.(Accoun</span><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.206.1">tServiceServer).Logout(ctx, in)
  }
  //...
</span><span class="koboSpan" id="kobo.206.2">}</span></pre>
<p><span class="koboSpan" id="kobo.207.1">This handler is responsible for creating a new object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">LogoutRequest</span></strong><span class="koboSpan" id="kobo.209.1"> and populating it before passing it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Logout</span></strong><span class="koboSpan" id="kobo.211.1"> function in an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">AccountServiceServer</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">Note here that we are going to assume that we always have an interceptor equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">nil</span></strong><span class="koboSpan" id="kobo.215.1"> because this is a more advanced feature, but later, we are going to see an example of how to set one up and </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">use it.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Finally, we see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">AccountServiceServer</span></strong><span class="koboSpan" id="kobo.219.1"> type being mentioned. </span><span class="koboSpan" id="kobo.219.2">Here is what it </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
type AccountServiceServer </span><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.222.1">interface {
  Logout(context.Context, *LogoutRequest) (*LogoutResponse,
    error)
  mustEmbedUnimplementedAccountServiceServer()
}</span></pre>
<p><span class="koboSpan" id="kobo.223.1">This is a type that contains the function signatures of our RPC endpoints and </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">mustEmbed</span></strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">UnimplementedAccountServiceServer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">Before going to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Logout</span></strong><span class="koboSpan" id="kobo.230.1"> function, let us </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">understand </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">mustEmbedUnimplemented</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">
AccountServiceServer</span></strong><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">This is an important concept for gRPC because</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.235.1"> it is here to provide a forward-compatible implementation of our service, and what it means is that older versions of our API will be able to communicate with newer ones </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">without crashing.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">If you check under the definition of </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">AccountServiceServer</span></strong><span class="koboSpan" id="kobo.239.1">, you will see </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
// UnimplementedAccountServiceServer must be embedded to
  have forward compatible implementations.
</span><span class="koboSpan" id="kobo.241.2">type UnimplementedAccountServiceServer struct {
}
func (UnimplementedAccountServiceServer)
  Logout(context.Context, *LogoutRequest) (*LogoutResponse,
    error) {
  return nil, status.Errorf(codes.Unimplemented, "</span><strong class="bold"><span class="koboSpan" id="kobo.242.1">method</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.243.1">    Logout not implemented</span></strong><span class="koboSpan" id="kobo.244.1">")
}</span></pre>
<p><span class="koboSpan" id="kobo.245.1">With that, we can understand that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">UnimplementedAccountServiceServer</span></strong><span class="koboSpan" id="kobo.247.1"> type must be embedded somewhere, and this </span><em class="italic"><span class="koboSpan" id="kobo.248.1">somewhere</span></em><span class="koboSpan" id="kobo.249.1"> is in a type that we are going to define later in this book when we are going to write our API endpoints. </span><span class="koboSpan" id="kobo.249.2">We are going to have the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.251.1">
type struct Server {
  UnimplementedAccountServiceServer
}</span></pre>
<p><span class="koboSpan" id="kobo.252.1">This is called type embedding, and this</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.253.1"> is the way Go goes about adding properties and methods from another type. </span><span class="koboSpan" id="kobo.253.2">You might have heard the advice to prefer composition over inheritance, and that is just that. </span><span class="koboSpan" id="kobo.253.3">We add the methods’ definitions from </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">UnimplementedAccountServiceServer</span></strong><span class="koboSpan" id="kobo.255.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">Server</span></strong><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">This will let us have the default implementations that return </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">method Logout not implemented</span></strong><span class="koboSpan" id="kobo.259.1"> generated for us. </span><span class="koboSpan" id="kobo.259.2">This means that if a server without a full implementation receives a call on one of its unimplemented API endpoints, it will return an error but not crash because of the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">non-existent endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">Once we understand that, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Logout</span></strong><span class="koboSpan" id="kobo.263.1"> method signature is trivial. </span><span class="koboSpan" id="kobo.263.2">As mentioned, later we are going to define our own server type that embeds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">UnimplementedAccountServiceServer</span></strong><span class="koboSpan" id="kobo.265.1"> type, and we are going to override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">Logout</span></strong><span class="koboSpan" id="kobo.267.1"> function with the implementation. </span><span class="koboSpan" id="kobo.267.2">Any call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">Logout</span></strong><span class="koboSpan" id="kobo.269.1"> will then be redirected to the implementation</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.270.1"> and not to the default </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">generated code.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.272.1">The client</span></h2>
<p><span class="koboSpan" id="kobo.273.1">The generated code for the client</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.274.1"> is even simpler than the server code. </span><span class="koboSpan" id="kobo.274.2">We have an interface called </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">AccountServiceClient</span></strong><span class="koboSpan" id="kobo.276.1"> that contains all the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">API endpoints:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
type AccountServiceClient interface {
  Logout(ctx context.Context, in *LogoutRequest, opts
    ...grpc.CallOption) (*LogoutResponse, error)
}</span></pre>
<p><span class="koboSpan" id="kobo.279.1">And we have the actual implementation</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.280.1"> of that interface, </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">accountServiceClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
type accountServiceClient struct {
  cc grpc.ClientConnInterface
}
func NewAccountServiceClient(cc grpc.ClientConnInterface)
  AccountServiceClient {
  return &amp;accountServiceClient{cc}
}
func (c *acc</span><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.285.1">ountServiceClient) Logout(ctx context.Context,
  in *LogoutRequest, opts ...grpc.CallOption)
    (*LogoutRe</span><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.286.1">sponse,</span><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.287.1"> error) {
  out := new</span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.288.1">(LogoutResponse)
  err := c.cc.Invoke(ctx, </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">"/AccountService/Logout"</span></strong><span class="koboSpan" id="kobo.290.1">, in,
    </span><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.291.1">out, op</span><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.292.1">ts...)
  if err != nil {
    return nil, err
  }
  return out, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.293.1">We can notice one important thing in this piece of code. </span><span class="koboSpan" id="kobo.293.2">We have an endpoint route called </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">/AccountService/Logout</span></strong><span class="koboSpan" id="kobo.295.1">. </span><span class="koboSpan" id="kobo.295.2">If you take a look back at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">AccountService_ServiceDesc</span></strong><span class="koboSpan" id="kobo.297.1"> variable described in the section titled </span><em class="italic"><span class="koboSpan" id="kobo.298.1">The server</span></em><span class="koboSpan" id="kobo.299.1">, you will find out that this route is a concatenation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">ServiceName</span></strong><span class="koboSpan" id="kobo.301.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">MethodName</span></strong><span class="koboSpan" id="kobo.303.1"> properties. </span><span class="koboSpan" id="kobo.303.2">This will let the server know how to route that request to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">_AccountService_Logout_Handler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.305.1"> handler</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">That is all. </span><span class="koboSpan" id="kobo.306.2">We can see that gRPC is handling all the boilerplate</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.307.1"> code to call an endpoint. </span><span class="koboSpan" id="kobo.307.2">We just need to create an object following the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">AccountServiceClient</span></strong><span class="koboSpan" id="kobo.309.1"> interface by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">NewAccountServiceClient</span></strong><span class="koboSpan" id="kobo.311.1">, and then with that object, we can call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">Logout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.313.1"> member.</span></span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.314.1">The read/write flow</span></h1>
<p><span class="koboSpan" id="kobo.315.1">Now that we have</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.316.1"> seen what Protobuf and gRPC are, it is time to go back to the read/write flow that we presented in </span><a href="B19664_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.317.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.318.1">. </span><span class="koboSpan" id="kobo.318.2">The goal of doing this is to make it a little bit more detailed and include what </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">we learned.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">As a quick reminder, we saw that they are mostly three levels when writing and reading data. </span><span class="koboSpan" id="kobo.320.2">We have the user code, the gRPC framework, and the transport layers. </span><span class="koboSpan" id="kobo.320.3">What is interesting for us here is mostly the user code. </span><span class="koboSpan" id="kobo.320.4">We did not go into too much detail in </span><a href="B19664_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.321.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.322.1"> but now that we are equipped with more knowledge on what gRPC is doing, we can understand the process </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">more clearly.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">The user-code layer is the code that developers write and interacts with the gRPC framework. </span><span class="koboSpan" id="kobo.324.2">For the client, this is calling the endpoints, and for the server, this is the implementation of the endpoints. </span><span class="koboSpan" id="kobo.324.3">If we keep going with our </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">AccountService</span></strong><span class="koboSpan" id="kobo.326.1"> service, we can give a concrete example of the </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">read/write flow.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">The first thing that we can do is separate the user-code layer into two parts: the implementation and the generated code. </span><span class="koboSpan" id="kobo.328.2">Furthermore, in </span><a href="B19664_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.329.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.330.1">, we gave a rather generic schema where we described the overall flow and drew a cryptic component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Other Actor</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">Let us now split the server and the client into two different actors, and we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">following system:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.334.1"><img alt="Figure 3.1 – Specialization of the read/write flow for AccountService" src="image/B19664_03_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.335.1">Figure 3.1 – Specialization of the read/write flow for AccountService</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.336.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.337.1">In the preceding diagram, I am using abbreviations “c” and “s” to refer to the client and server respectively. </span><span class="koboSpan" id="kobo.337.2">“c” is an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">AccountServiceClient</span></strong><span class="koboSpan" id="kobo.339.1"> created by </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">NewAccountServiceClient</span></strong><span class="koboSpan" id="kobo.341.1">, and “s” is an instance of a type defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Implementation</span></strong><span class="koboSpan" id="kobo.343.1"> that defines the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Logout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">We can see a few important things happening</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.347.1"> once we expand the diagram. </span><span class="koboSpan" id="kobo.347.2">The first interesting concept is that the generated code is shared across the different communication actors. </span><span class="koboSpan" id="kobo.347.3">We saw that the gRPC Go plugin will generate a single file containing the server and client types. </span><span class="koboSpan" id="kobo.347.4">This means that this file should be shared between all actors written </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">in Go.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">We can also notice that the gRPC framework and generated code abstract everything for us. </span><span class="koboSpan" id="kobo.349.2">This lets us focus only on calling an endpoint with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Request</span></strong><span class="koboSpan" id="kobo.351.1"> object and on writing the endpoint handling that </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Request</span></strong><span class="koboSpan" id="kobo.353.1"> object and returning a </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Response</span></strong><span class="koboSpan" id="kobo.355.1"> object. </span><span class="koboSpan" id="kobo.355.2">This highly limits the amount of code we need to write and thus makes our code more testable because we need to focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">less code.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">Finally, the last important thing to notice is that we can limit ourselves to reading the generated code to understand</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.358.1"> the parameters and return types of each of our endpoints. </span><span class="koboSpan" id="kobo.358.2">This is helpful because either the generated code will be picked up by your IDE and you will have autocompletion or you can simply check one file to get the information </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">you need.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.360.1">Why does gRPC matter?</span></h1>
<p><span class="koboSpan" id="kobo.361.1">Now that we have a sense</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.362.1"> of what gRPC is, we can get into why it matters. </span><span class="koboSpan" id="kobo.362.2">To explain gRPC’s role, we are going to compare it with two other ways of performing client/server communication. </span><span class="koboSpan" id="kobo.362.3">The first one is the traditional REST API architecture based on HTTP and JSON, and the second one </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">is GraphQL.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.364.1">REST</span></h2>
<p><span class="koboSpan" id="kobo.365.1">While I am assuming</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.366.1"> that most of you reading</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.367.1"> this book are familiar with REST APIs, I still believe that it is important to introduce the principles of designing such APIs. </span><span class="koboSpan" id="kobo.367.2">It will help us understand in which ways gRPC is like REST and in which </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">it differs.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">A REST API, as with every other technology in this comparison study, is an interface between an information provider and a consumer. </span><span class="koboSpan" id="kobo.369.2">When writing such an API, we expose endpoints on specific URLs (routes) that can be used by a client to create, read, update, and </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">delete resource(s).</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">However, REST APIs are different from gRPC and GraphQL. </span><span class="koboSpan" id="kobo.371.2">The main difference is that REST is not a framework—it is a set of architectural practices th</span><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.372.1">at can be implemented in different ways. </span><span class="koboSpan" id="kobo.372.2">The main constraints</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.373.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.375.1">The client, server, and resources are the main entities during communication. </span><span class="koboSpan" id="kobo.375.2">The client requests resources from the server and the server returns the </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">relevant resources.</span></span></li>
<li><span class="koboSpan" id="kobo.377.1">Requests and responses are managed by HTTP. </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">GET</span></strong><span class="koboSpan" id="kobo.379.1"> is used to read resources, </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">POST</span></strong><span class="koboSpan" id="kobo.381.1"> to create resources, </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">PUT</span></strong><span class="koboSpan" id="kobo.383.1"> to update resources, </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">PATCH</span></strong><span class="koboSpan" id="kobo.385.1"> to update part of a resource, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">DELETE</span></strong><span class="koboSpan" id="kobo.387.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">remove resources.</span></span></li>
<li><span class="koboSpan" id="kobo.389.1">No client-related information should be stored between requests. </span><span class="koboSpan" id="kobo.389.2">This is a stateless</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.390.1"> communication, and each request </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">is separate.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.392.1">Finally, even though such APIs</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.393.1"> are not bound to any data format, the most used one is JSON. </span><span class="koboSpan" id="kobo.393.2">This is mostly</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.394.1"> because JSON has a wide community, and a lot of languages and frameworks can handle this </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">data format.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.396.1">GraphQL</span></h2>
<p><span class="koboSpan" id="kobo.397.1">GraphQL is presented as a query language</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.398.1"> for APIs. </span><span class="koboSpan" id="kobo.398.2">It lets developers write data schemas that describe the data available, and it lets them query a specific set of fields present in </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">the schema.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">As it lets us write queries, we can have more generic endpoints and request only the fields that we are interested in for a certain feature. </span><span class="koboSpan" id="kobo.400.2">This solves the problem of overfetching and underfetching because we only get the amount of data that we </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">asked for.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">On top of all of this, as GraphQL mainly uses JSON as data format and uses explicit types and comments in its own data schema, this makes GraphQL more readable and self-documenting. </span><span class="koboSpan" id="kobo.402.2">This makes this technology more mature for companies at scale because we can do type-checking at compile time and shorten the feedback loop, and we do not have to separate documentation and code, thus it will be less likely to be not </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">in sync.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.404.1">Comparison with gRPC</span></h2>
<p><span class="koboSpan" id="kobo.405.1">Now that we have had an overview of what each technology does, we can get started with comparing them with gRPC. </span><span class="koboSpan" id="kobo.405.2">We are going to focus on the biggest differentiators between these four ways of designing an API. </span><span class="koboSpan" id="kobo.405.3">These differentiators</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.406.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.408.1">The transport, data format, and data schema used </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">for communication</span></span></li>
<li><span class="koboSpan" id="kobo.410.1">Separation of concern of </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">API endpoints</span></span></li>
<li><span class="koboSpan" id="kobo.412.1">The developers’ workflow when </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">writing APIs</span></span></li>
<li><span class="koboSpan" id="kobo.414.1">The convenience of </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">out-of-the-box features</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.416.1">Transport, data format, and data schema</span></h3>
<p><span class="koboSpan" id="kobo.417.1">In this regard, GraphQL and REST APIs</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.418.1"> are similar. </span><span class="koboSpan" id="kobo.418.2">They both</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.419.1"> use HTTP/1.1 for the underlying transport and, more often than not, developers use JSON for sending structured data. </span><span class="koboSpan" id="kobo.419.2">On the other side, gRPC uses HTTP/2 and Protobuf by default. </span><span class="koboSpan" id="kobo.419.3">This means that, with gRPC, we have smaller payloads to send over the wire and we have more efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">connection handling.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">There are certain things to be more careful about when we are dealing with Protobuf than when we have to deal with JSON. </span><span class="koboSpan" id="kobo.421.2">Protobuf provides implicit default values depending on the type of field, and these default values do not get serialized into the final binary. </span><span class="koboSpan" id="kobo.421.3">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">int32</span></strong><span class="koboSpan" id="kobo.423.1"> has a default value of 0. </span><span class="koboSpan" id="kobo.423.2">This means that we cannot differentiate between the value 0 being set or whether the field was not set. </span><span class="koboSpan" id="kobo.423.3">Of course, there are ways of dealing with that, but it makes the client-side usage a little bit more involved. </span><span class="koboSpan" id="kobo.423.4">In this respect, GraphQL handles default values differently. </span><span class="koboSpan" id="kobo.423.5">We can pass the default values as parameters of our endpoints, </span><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.424.1">and this means that we can handle particular cases in a more </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">user-friendly way.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">Finally, it is important to mention that all these technologies are quite flexible regarding the kind of data format that you can transport over the wire. </span><span class="koboSpan" id="kobo.426.2">REST APIs handle binary and other kinds of data, GraphQL can also accept binary data, and gRPC can send JSON data. </span><span class="koboSpan" id="kobo.426.3">However, problems come with this flexibility. </span><span class="koboSpan" id="kobo.426.4">If you are using binary over a REST API, you let both the client and the server interpret what this binary means. </span><span class="koboSpan" id="kobo.426.5">There is no type safety and we need to handle serialization/deserialization errors that otherwise would be handled by libraries or frameworks. </span><span class="koboSpan" id="kobo.426.6">If you use binary with GraphQL, you are greatly reducing the number of community tools that you can use. </span><span class="koboSpan" id="kobo.426.7">And finally, if you use JSON with gRPC, you are losing all the advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">of Protobuf.</span></span></p>
<h3><span class="koboSpan" id="kobo.428.1">Separation of concern of API endpoints</span></h3>
<p><span class="koboSpan" id="kobo.429.1">Designing separation of concern for APIs can be tricky</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.430.1"> and lead to problems such as underfetching or overfetching. </span><span class="koboSpan" id="kobo.430.2">GraphQL was designed to solve these problems of getting too much or too little data when making a request. </span><span class="koboSpan" id="kobo.430.3">With it, you can simply ask for a specific set of fields that you need for a certain feature. </span><span class="koboSpan" id="kobo.430.4">While it is possible to do a similar thing with gRPC and REST APIs, it remains non-user-friendly when your API is facing </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">external users.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">However, separation of concern in APIs can help us with a few things. </span><span class="koboSpan" id="kobo.432.2">First, it can help us reduce the scope of testing for an endpoint. </span><span class="koboSpan" id="kobo.432.3">Instead of thinking about all the possible inputs and outputs that an endpoint might have, we are only focusing on a specific input and a </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">specific output.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">And second, having smaller and more specific endpoints will help in the case of API abuse. </span><span class="koboSpan" id="kobo.434.2">As we can clearly know which request was made to which endpoint, we can rate-limit them per client</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.435.1"> and thus secure our APIs. </span><span class="koboSpan" id="kobo.435.2">With more flexible API endpoints such as in GraphQL, this is intrinsically harder to implement because we need to ponder whether to rate limit on the whole route, a specific input, or just a </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">simple query.</span></span></p>
<h3><span class="koboSpan" id="kobo.437.1">The developers’ workflow</span></h3>
<p><span class="koboSpan" id="kobo.438.1">Another important aspect </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.439.1">of these technologies that is often overlooked is the developers’ workflow when writing an API. </span><span class="koboSpan" id="kobo.439.2">With REST APIs, we are mostly working on the server and the client separately, and this process is error-prone. </span><span class="koboSpan" id="kobo.439.3">If we do not have specifications on what data to expect, we are in for long sessions of debugging. </span><span class="koboSpan" id="kobo.439.4">Furthermore, even if we have specifications on the data, developers are humans and humans make mistakes. </span><span class="koboSpan" id="kobo.439.5">The client might have expected a certain kind of data, but the server is </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">sending another.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Now, this is not a problem that concerns only REST APIs—gRPC and GraphQL APIs also have this problem. </span><span class="koboSpan" id="kobo.441.2">However, the problem scope is reduced because we can make sure that only a certain type can be used as a request and another as a response. </span><span class="koboSpan" id="kobo.441.3">This lets us focus on the happy path instead of writing code that is checking whether the serialization and </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">deserialization failed.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">The gRPC and GraphQL way of developing APIs is called </span><strong class="bold"><span class="koboSpan" id="kobo.444.1">schema-driven development</span></strong><span class="koboSpan" id="kobo.445.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.446.1">SDD</span></strong><span class="koboSpan" id="kobo.447.1">). </span><span class="koboSpan" id="kobo.447.2">We first focus on writing a schema</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.448.1"> that defines all higher-level requirements of our API, and then </span><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.449.1">we dive into the implementation. </span><span class="koboSpan" id="kobo.449.2">This greatly reduces the scope of errors that we can get at runtime and also shortens the feedback loop for developers. </span><span class="koboSpan" id="kobo.449.3">We cannot send a string instead of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">int</span></strong><span class="koboSpan" id="kobo.451.1">, and it will tell us that at compile time. </span><span class="koboSpan" id="kobo.451.2">This also makes the scope of tests much smaller because we can now focus on the feature itself and not on the many possible errors that could happen due to </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">external problems.</span></span></p>
<h3><span class="koboSpan" id="kobo.453.1">Convenience</span></h3>
<p><span class="koboSpan" id="kobo.454.1">Finally, another overlooked</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.455.1"> topic is how convenient using technology is. </span><span class="koboSpan" id="kobo.455.2">This can be due to the community developing tools or simply out-of-the-box features coming with the framework. </span><span class="koboSpan" id="kobo.455.3">In this case, technologies using JSON often have more tools and support. </span><span class="koboSpan" id="kobo.455.4">This is the case because JSON has been widely used for a long time and it is attractive because of its </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">human readability.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">However, even with the lack of tool compared to JSON-backed APIs, gRPC was designed on principles that helped Google scale and secure its products, it has a lot of amazing features that you can get without any extra dependencies. </span><span class="koboSpan" id="kobo.457.2">gRPC has interceptors, TLS authentication, and many other high-end features built in as part of the official framework, and thus it is simpler to write secure and </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">performant code.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Finally, GraphQL is the only technology of the three that is explicit about endpoints having side effects. </span><span class="koboSpan" id="kobo.459.2">This can be documented for gRPC or REST APIs; however, this cannot be checked statically. </span><span class="koboSpan" id="kobo.459.3">This is important because this makes the APIs’ users more aware of what is happening in the background, and it might lead to better choices for </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">appropriate routes.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.461.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.462.1">To summarize, gRPC is a mature technology adopted by tech giants but also the open source community to create efficient and performant client/server communication. </span><span class="koboSpan" id="kobo.462.2">This is not only true in the distributed system but also in the local environment with the use of IPC. </span><span class="koboSpan" id="kobo.462.3">gRPC uses Protobuf by default due to its compact binary serialization and</span><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.463.1"> fast deserialization but also for its type safety and language agnosticism. </span><span class="koboSpan" id="kobo.463.2">On top of that, gRPC generates code to send Protobuf over HTTP/2. </span><span class="koboSpan" id="kobo.463.3">It generates a server and a client for us so that we do not have to think about the details of communication. </span><span class="koboSpan" id="kobo.463.4">All the details are handled by the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">gRPC framework.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">In the next chapter, we are finally going to get our hands dirty. </span><span class="koboSpan" id="kobo.465.2">We are going to set up a gRPC project, make sure that our code generation is working properly, and write some boilerplate code for both the server and </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">the client.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.467.1">Quiz</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.468.1">What is one of the reasons Protobuf is the default data format </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">for gRPC?</span></span><ol><li><span class="koboSpan" id="kobo.470.1">The serialized data </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">is human-readable</span></span></li><li><span class="koboSpan" id="kobo.472.1">It is </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">dynamically typed</span></span></li><li><span class="koboSpan" id="kobo.474.1">It </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">is type-safe</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.476.1">In the Go implementation, which component generates </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">server/client code?</span></span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.478.1">Protoc</span></span></li><li><span class="koboSpan" id="kobo.479.1">The gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">Go plugin</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.481.1">Other</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.482.1">What are service descriptors in the context of </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">gRPC-generated code?</span></span><ol><li><span class="koboSpan" id="kobo.484.1">They describe which endpoints a service has and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">handle requests</span></span></li><li><span class="koboSpan" id="kobo.486.1">They describe how to </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">return responses</span></span></li><li><span class="koboSpan" id="kobo.488.1">Both </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">of these</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.490.1">How will the user code be able to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">logout endpoint?</span></span><ol><li><span class="koboSpan" id="kobo.492.1">By writing code in the generated </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">Logout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1"> function</span></span></li><li><span class="koboSpan" id="kobo.495.1">By creating a copy of the generated code and </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">editing it</span></span></li><li><span class="koboSpan" id="kobo.497.1">By using type embedding with the generated server and implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Logout</span></strong><span class="koboSpan" id="kobo.499.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">that type</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-71"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.501.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.502.1">C</span></li>
<li><span class="koboSpan" id="kobo.503.1">B</span></li>
<li><span class="koboSpan" id="kobo.504.1">A</span></li>
<li><span class="koboSpan" id="kobo.505.1">C</span></li>
</ol>
</div>
</body></html>