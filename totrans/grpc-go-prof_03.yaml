- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Introduction to gRPC
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC 简介
- en: Now that we have a basic understanding of how data flows over the network and
    how Protobuf works, we can enter the gRPC world. In this chapter, the goal is
    to understand what gRPC is doing on top of HTTP/2 and why Protobuf is the perfect
    fit for gRPC, and also to see that gRPC is a mature technology backed up by major
    companies in the industry. This will give us a sense of why gRPC is described
    as “Protobuf over HTTP/2” and make us confident in using it without fearing that
    the technology is too new and without community.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对数据在网络中如何流动以及 Protobuf 如何工作有了基本的了解，我们可以进入 gRPC 世界。在本章中，目标是理解 gRPC 在 HTTP/2
    上做了什么，为什么 Protobuf 是 gRPC 的完美匹配，并且看到 gRPC 是一个由行业中的主要公司支持的技术。这将让我们明白为什么 gRPC 被描述为“HTTP/2
    上的 Protobuf”，并让我们在使用它时充满信心，无需担心技术太新或缺乏社区。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Major use cases for gRPC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 的主要用例
- en: Advantages of using Protobuf
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Protobuf 的优势
- en: The role of gRPC on top of Protobuf
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Protobuf 之上 gRPC 的作用
- en: Prerequisites
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'You can find the code for this chapter at [https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3).
    During this chapter, I will be using protoc to generate Go code out of `.proto`
    files. This means that you need to make sure you have protoc installed. You can
    download a zip file from the `readme.txt` instructions (note: we do intend to
    use Well-Known Types in the future so make sure you also install the includes).
    On top of protoc, you are going to need two protoc plugins: `protoc-gen-go` and
    `protoc-gen-go-grpc`. The former generates Protobuf code, and the latter generates
    gRPC code. To add them, you can simply run the following commands:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3)找到本章的代码。在本章中，我将使用
    protoc 从 `.proto` 文件生成 Go 代码。这意味着你需要确保你已经安装了 protoc。你可以从 `readme.txt` 指令中下载一个
    zip 文件（注意：我们打算在未来使用已知类型，所以请确保你也安装了包含文件）。在 protoc 之上，你还需要两个 protoc 插件：`protoc-gen-go`
    和 `protoc-gen-go-grpc`。前者生成 Protobuf 代码，后者生成 gRPC 代码。要添加它们，你可以简单地运行以下命令：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And finally, make sure that your `GOPATH` environment variable is in your `PATH`
    environment variable. Normally, this is already done for you on the installation
    of Golang, but if you get any error related to not finding `protoc-gen-go` or
    `protoc-gen-go-grpc`, you will need to do it manually. To get the `GOPATH` environment
    variable, you can run the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保你的 `GOPATH` 环境变量包含在你的 `PATH` 环境变量中。通常，在安装 Golang 时这已经为你完成了，但如果你在找不到 `protoc-gen-go`
    或 `protoc-gen-go-grpc` 时遇到任何错误，你需要手动完成。要获取 `GOPATH` 环境变量，你可以运行以下命令：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And then, depending on your OS, you can go through the steps of adding the output
    to your `PATH` environment variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据你的操作系统，你可以按照步骤将输出添加到你的 `PATH` 环境变量中。
- en: A mature technology
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个成熟的技术
- en: gRPC is not just another new cool framework that you can disregard as being
    a fad It is a framework that has been battle-tested at scale for over a decade
    by Google. Originally, the project was for internal use, but in 2016, Google decided
    to provide an open source version of it that was not tied to the specifics of
    the company’s internal tooling and architecture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 不仅仅是一个你可以忽视的新酷框架，它是一个经过 Google 在规模上战斗测试超过十年的框架。最初，该项目是用于内部使用，但在 2016 年，Google
    决定提供一个开源版本，这个版本不依赖于公司内部工具和架构的特定性。
- en: After that, companies such as Uber—and a lot more—migrated their existing services
    to gRPC for efficiency but also for all the extra features that it offers. Moreover,
    some open projects such as etcd, which is a distributed key-value store used at
    the core of Kubernetes, use gRPC for communication across multiple instances.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，像 Uber 这样的公司以及更多公司迁移了它们现有的服务到 gRPC，以提高效率，同时也为了它提供的所有额外功能。此外，一些开源项目，如 etcd，它是一个在
    Kubernetes 核心中使用的分布式键值存储，使用 gRPC 在多个实例之间进行通信。
- en: Recently, Microsoft joined the effort around building a .NET implementation
    of gRPC. While it is not the goal of this book to explain what it did, it clearly
    shows an interest in the project. Furthermore, the more that companies such as
    this are willing to contribute, the more resources will be out there and the greater
    the community/tooling available will be. The project has a powerful backup, and
    this is good for all of us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，微软加入了构建 .NET 实现的 gRPC 项目的努力。虽然本书的目标不是解释它所做的一切，但它显然对项目表现出浓厚的兴趣。此外，像这样的公司越愿意贡献，可用的资源就越多，社区和工具也越强大。该项目得到了强有力的支持，这对我们所有人来说都是好事。
- en: Now, all of this sounds amazing, but I am aware that most of us will not reach
    the scale of these giants, so it is important to understand what gRPC is good
    at. Let us see some use cases where it shines. The first use case that everyone
    is talking about is communication for microservices. This use case is an appealing
    one, especially for polyglot microservices. Our job as software engineers is to
    choose the right job for the right tool and code generation in different languages
    to enable us to do that.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些都听起来很棒，但我意识到我们中的大多数人不会达到这些巨头的规模，因此了解 gRPC 的优点很重要。让我们看看它在哪些用例中表现出色。第一个大家都在谈论的用例是微服务之间的通信。这个用例很有吸引力，特别是对于多语言微服务。作为软件工程师，我们的任务是选择合适的工具，以及在不同语言中进行代码生成，以便我们能够做到这一点。
- en: Another use case is real-time updates. As we saw, gRPC gives us the possibility
    of streaming data. This comes in multiple flavors such as server streaming, which
    could be useful for keeping up to date with data such as stock prices. Then, we
    have client streaming, which could be useful for sensors streaming data to backends.
    And finally, we have bi-directional streaming, which could be interesting when
    both the client and server need to be aware of each other’s updates, such as messaging
    apps.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是实时更新。正如我们所见，gRPC 给我们提供了流式传输数据的能力。这有多种形式，如服务器端流式传输，这可能有助于保持与股票价格等数据的同步。然后，我们有客户端流式传输，这可能有助于传感器将数据流式传输到后端。最后，我们还有双向流式传输，当客户端和服务器都需要意识到对方的更新时，这可能很有趣，例如在消息应用中。
- en: Another important use case is **inter-process communication** (**IPC**). This
    is communication happening on the same machine between different processes. It
    can be useful for synchronizing two or more distinct applications, implementing
    **separation of concerns** (**SOC**) with a modular architecture, or increasing
    security by having application sandboxing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的用例是**进程间通信**（**IPC**）。这是在同一台机器上不同进程之间发生的通信。它可以用于同步两个或多个不同的应用程序，通过模块化架构实现**关注点分离**（**SOC**），或者通过应用程序沙箱化来提高安全性。
- en: Obviously, I presented the most common applications of gRPC that I can see out
    there, but there are a lot more applications of it, and it is important that you
    test it on your use case to see whether it fits your requirements. And if you
    are interested in testing gRPC, you will need to start trying to find out how
    Protobuf can reduce your payloads and application efficiency.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我介绍了我在外面看到的 gRPC 最常见应用，但它的应用还有很多，重要的是你要在自己的用例中测试它，看看它是否符合你的要求。如果你对测试 gRPC
    感兴趣，你需要开始尝试找出 Protobuf 如何减少你的有效载荷和应用程序效率。
- en: Why Protobuf?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是 Protobuf？
- en: By now, you should understand that Protobuf provides us with a way of writing
    data schemas describing how our data should be serialized and deserialized. Then,
    the Protobuf compiler (protoc) lets us generate some code from these schemas to
    use the generated types in our code, and these serializable types are exactly
    what gRPC uses to let user code interact with request and response objects and
    let the gRPC framework send binary representations of them over the wire.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经理解了 Protobuf 为我们提供了一种编写数据模式的方法，描述了我们的数据应该如何进行序列化和反序列化。然后，Protobuf
    编译器（protoc）让我们从这些模式中生成一些代码，以便在代码中使用生成的类型，而这些可序列化类型正是 gRPC 用于让用户代码与请求和响应对象交互，并通过网络发送它们的二进制表示。
- en: The binary representation of messages is the biggest reason Protobuf is used
    as the default data schema for gRPC. The data is serialized in way fewer bytes
    than traditional data schemas (XML, JSON, and so on). This means that not only
    can the message be delivered faster, but also that it will be deserialized faster.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的二进制表示是 Protobuf 被用作 gRPC 默认数据模式的最大原因。数据序列化所需的字节数比传统数据模式（如 XML、JSON 等）要少得多。这意味着不仅消息可以更快地传递，而且反序列化也会更快。
- en: Important note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The following experiment is mostly done to show Protobuf’s performance. Examples
    are exaggerated, but this will give you a sense of the additional cost that JSON
    has during deserialization. The results might vary across the run, OS, and hardware,
    so if you want to run your own experiment, you can find the benchmarking code
    and data in the `chapter3` folder ([https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3)).
    To get the data, you will have to unzip it with gzip. You can do that by running
    the `gzip -dk accounts.json.gz` or `gzip -dk accounts.bin.gz` command. After that,
    to run the experiment, you first need to compile the `.proto` files with `protoc
    --go_out=proto -Iproto --go_opt=module=`https://github.com/PacktPublishing/gRPC-Go-for-Professionals/proto
    proto/*`.proto`, and then you can execute the Go code by running `go run main.go`
    in the `chapter3` folder.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实验主要是为了展示 Protobuf 的性能。示例被夸大了，但这将给你一个关于 JSON 在反序列化过程中额外成本的感觉。结果可能会因运行、操作系统和硬件而异，所以如果你想运行自己的实验，你可以在
    `chapter3` 文件夹中找到基准测试代码和数据（[https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter3)）。要获取数据，你需要使用
    gzip 解压缩它。你可以通过运行 `gzip -dk accounts.json.gz` 或 `gzip -dk accounts.bin.gz` 命令来完成。之后，为了运行实验，你首先需要使用
    `protoc --go_out=proto -Iproto --go_opt=module=`https://github.com/PacktPublishing/gRPC-Go-for-Professionals/proto
    proto/*`.proto` 编译 `.proto` 文件，然后你可以在 `chapter3` 文件夹中通过运行 `go run main.go` 来执行
    Go 代码。
- en: 'To demonstrate that, we can do a simple experiment—we can generate 100,000
    accounts (with an ID + username), run the deserialization 1,000 times, and calculate
    the mean time needed to deserialize all the data. Here are the results from one
    of the runs with untrimmed (newlines and spaces) JSON against the Protobuf binary:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，我们可以进行一个简单的实验——我们可以生成 100,000 个账户（带有 ID 和用户名），运行 1,000 次反序列化，并计算反序列化所有数据所需的平均时间。以下是其中一个运行结果，与未修剪的（换行符和空格）JSON
    相比，与 Protobuf 二进制文件：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, most developers do trim their JSON, so here is the result after removing
    newlines and spaces:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数开发者都会修剪他们的 JSON，所以这是移除换行符和空格后的结果：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is better but still significantly slower than Protobuf.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它更好，但仍然比 Protobuf 慢得多。
- en: 'And finally, we can look at the serialized data size for the data used in the
    experiment. For the uncompressed JSON versus uncompressed Protobuf, we have the
    following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以查看实验中使用的序列化数据大小。对于未压缩的 JSON 与未压缩的 Protobuf，我们有以下输出：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And for the compressed version (gzip), we have this output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于压缩版本（gzip），我们有以下输出：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I encourage you to experiment more with this and especially experiment for your
    use cases but, unless there is a big mistake in the proto file design, you will
    find that Protobuf is way more efficient in terms of size and serialization/deserialization
    time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你更多地实验这个，特别是针对你的用例进行实验，但除非在 proto 文件设计中有重大错误，否则你会发现 Protobuf 在大小和序列化/反序列化时间方面要高效得多。
- en: On top of providing data serialization, we saw that Protobuf also has a concept
    of service, which is a contract between clients and servers. While this concept
    is not linked exclusively to gRPC (you could generate code wrapping other frameworks),
    gRPC uses that to generate the appropriate API endpoints. This provides us with
    type safety on both the client and server sides. If we try to send incorrect data
    and we work in a compiled language, we will get a compilation error instead of
    getting an error at runtime. This dramatically shortens the feedback loop for
    developers and reduces the area of possible failures in our code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供数据序列化之外，我们还发现 Protobuf 还有一个服务概念，这是客户端和服务器之间的一个合约。虽然这个概念并不专属于 gRPC（你可以生成其他框架的代码包装），但
    gRPC 使用它来生成适当的 API 端点。这为我们提供了客户端和服务器两边的类型安全。如果我们尝试发送错误的数据，并且我们在编译型语言中工作，我们将得到编译错误而不是在运行时得到错误。这大大缩短了开发者的反馈循环，并减少了代码中可能失败的区域。
- en: Finally, Protobuf itself is language-agnostic. This means that this is an independent
    data schema, and it can be shared across multiple projects. If you have code written
    in C++ for some microcontroller, sending data to a backend written in Go, which
    is in turn sending data to a web frontend in JS, you can simply share the same
    Protobuf file and generate your models with protoc. You do not have to rewrite
    them every time in the different projects. This decreases the area that needs
    to be updated on adding or updating features and provides an interface that multiple
    teams need to agree on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Protobuf本身是语言无关的。这意味着这是一个独立的数据模式，可以在多个项目中共享。如果你为某个微控制器编写了C++代码，并将数据发送到用Go编写的后端，而后端又将数据发送到用JS编写的Web前端，你可以简单地共享相同的Protobuf文件，并使用protoc生成你的模型。你不必在每次不同的项目中都重写它们。这减少了在添加或更新功能时需要更新的区域，并为多个团队需要达成一致意见的接口提供了支持。
- en: In the end, Protobuf enables faster communication (for example, through gRPC)
    by creating smaller payloads, it provides us with type safety on both ends of
    the communication, and it does all that across multiple languages so that we can
    use the right tool for the right job.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Protobuf通过创建更小的有效负载（例如，通过gRPC）来启用更快的通信，它为我们提供了通信两端的类型安全，并且它可以在多种语言中完成所有这些，这样我们就可以为不同的任务使用合适的工具。
- en: What is gRPC doing?
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC在做什么？
- en: gRPC is described as “Protobuf over HTTP/2.” This means that gRPC will generate
    all the communication code wrapping the gRPC framework and stand on Protobuf’s
    shoulders to serialize and deserialize data. To know which API endpoints are available
    on the client and server, gRPC will look at the services defined in our `.proto`
    files, and from that, it will learn the basic information needed to generate some
    metadata and the functions needed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC被描述为“HTTP/2上的Protobuf”。这意味着gRPC将生成所有通信代码，这些代码包装在gRPC框架中，并站在Protobuf的肩膀上以序列化和反序列化数据。为了知道客户端和服务器上可用的哪些API端点，gRPC将查看我们`.proto`文件中定义的服务，并从中学到生成一些元数据和所需函数所需的基本信息。
- en: The first thing to understand with gRPC is that there are multiple implementations.
    In Go, for example, you get a pure implementation of gRPC. This means that the
    entire code generation process and communication is written in Go. Other languages
    might have similar implementations, but a lot of them are wrappers around the
    C implementation. While we do not need to know anything about them in the context
    of this book, it is important to know that they are available because it explains
    the presence of plugins for the protoc compiler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于gRPC，首先需要理解的是，它有多种实现。例如，在Go中，你得到一个纯gRPC实现。这意味着整个代码生成过程和通信都是用Go编写的。其他语言可能有类似的实现，但很多都是围绕C实现进行包装的。虽然在这个书的背景下我们不需要了解它们，但重要的是要知道它们是可用的，因为这解释了protoc编译器插件的存在。
- en: As you know, there are a lot of languages out there. Some are relatively new,
    and some are pretty old, so staying on top of every language’s evolution is practically
    infeasible. That is why we have protoc plugins. Every developer or company interested
    in supporting a language can write such a plugin to generate code that will send
    Protobuf over HTTP/2\. This is, for example, the case for Swift support, which
    was added by Apple.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，现在有很多种语言。有些相对较新，有些则相当古老，所以跟上每种语言的演变实际上是不切实际的。这就是为什么我们有protoc插件。任何对支持一种语言感兴趣的开发商或公司都可以编写这样的插件来生成代码，该代码将发送通过HTTP/2的Protobuf。例如，Swift支持就是由苹果公司添加的。
- en: 'Since we are talking about Go, we want to look at what kind of code is generated
    to get a sense of how gRPC works but also to know how to debug and where to look
    for function signatures. Let us start with a simple service—in `proto/account.proto`,
    we have the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在谈论Go语言，我们想看看生成什么样的代码，以便了解gRPC是如何工作的，同时也知道如何调试以及在哪里查找函数签名。让我们从一个简单的服务开始——在`proto/account.proto`中，我们有以下内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this service, we have an API endpoint named `Logout` that takes as a parameter
    `LogoutRequest` (a wrapper around `Account`) and returns a `LogoutResponse` parameter.
    `LogoutResponse` is an empty message because we want to send the account for which
    the session needs to be stopped and we do not need any result, just an indicator
    that the call went well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个服务中，我们有一个名为`Logout`的API端点，它接受一个参数`LogoutRequest`（`Account`的包装器）并返回一个`LogoutResponse`参数。`LogoutResponse`是一个空消息，因为我们想发送需要停止会话的账户，我们不需要任何结果，只需要一个指示调用成功的标志。
- en: 'Then, to generate Protobuf and gRPC code out of this, we will run the following
    command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了从这个中生成 Protobuf 和 gRPC 代码，我们将运行以下命令：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We already saw with Protobuf that the messages will be turned into structs,
    but now we also have a `_grpc.pb.go` file that contains the gRPC communication
    code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在 Protobuf 中，消息将被转换为结构体，但现在我们还有一个包含 gRPC 通信代码的 `_grpc.pb.go` 文件。
- en: The server
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器
- en: Let us look at what was generated on the server side first. We are going to
    start from the bottom of the file with the service descriptor. But first, we need
    to know what a descriptor is. In Protobuf and gRPC context, a descriptor is a
    meta object that represents Protobuf code. This means that, in our case, we have
    a Go object representing a service or other concepts. In fact, we did not deep-dive
    into it in the previous chapter but if you look at the generated code for `Account`,
    you will also find `Desc` being mentioned.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看服务器端生成了什么。我们将从文件的底部开始，从服务描述符开始。但在那之前，我们需要知道什么是描述符。在 Protobuf 和 gRPC
    的上下文中，描述符是一个元对象，它表示 Protobuf 代码。这意味着在我们的情况下，我们有一个 Go 对象代表一个服务或其他概念。实际上，我们在上一章中没有深入探讨它，但如果你查看
    `Account` 生成的代码，你也会发现提到了 `Desc`。
- en: 'For our `AccountService` service, we have the following descriptor:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `AccountService` 服务，我们有以下描述符：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that we have a service called `AccountService` that is linked to
    a type called `AccountServiceServer`, and this service has a method called `Logout`
    that should be handled by a function called `_AccountService_Logout_Handler`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们有一个名为 `AccountService` 的服务，它与名为 `AccountServiceServer` 的类型相关联，并且这个服务有一个名为
    `Logout` 的方法，该方法应由名为 `_AccountService_Logout_Handler` 的函数处理。
- en: 'You should find the handler above the service descriptor. This looks like the
    following (simplified):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在服务描述符上方找到这个处理程序。它看起来如下（简化版）：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This handler is responsible for creating a new object of type `LogoutRequest`
    and populating it before passing it to the `Logout` function in an object of type
    `AccountServiceServer`. Note here that we are going to assume that we always have
    an interceptor equal to `nil` because this is a more advanced feature, but later,
    we are going to see an example of how to set one up and use it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序负责创建一个类型为 `LogoutRequest` 的新对象，并在将其传递给类型为 `AccountServiceServer` 的 `Logout`
    函数之前填充它。注意，这里我们假设我们总是有一个等于 `nil` 的拦截器，因为这是一个更高级的功能，但稍后我们将看到一个如何设置并使用它的例子。
- en: 'Finally, we see the `AccountServiceServer` type being mentioned. Here is what
    it looks like:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到提到了 `AccountServiceServer` 类型。它看起来是这样的：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a type that contains the function signatures of our RPC endpoints and
    a `mustEmbed``UnimplementedAccountServiceServer` function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含我们的 RPC 端点函数签名和 `mustEmbedUnimplementedAccountServiceServer` 函数的类型。
- en: Before going to the `Logout` function, let us understand `mustEmbedUnimplemented`
    **AccountServiceServer**. This is an important concept for gRPC because it is
    here to provide a forward-compatible implementation of our service, and what it
    means is that older versions of our API will be able to communicate with newer
    ones without crashing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前往 `Logout` 函数之前，让我们先理解 `mustEmbedUnimplemented` **AccountServiceServer**。这对于
    gRPC 来说是一个重要的概念，因为它在这里提供我们服务的向前兼容实现，这意味着我们 API 的旧版本将能够与新版本通信而不会崩溃。
- en: 'If you check under the definition of `AccountServiceServer`, you will see the
    following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查 `AccountServiceServer` 的定义，你会看到以下内容：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With that, we can understand that this `UnimplementedAccountServiceServer`
    type must be embedded somewhere, and this *somewhere* is in a type that we are
    going to define later in this book when we are going to write our API endpoints.
    We are going to have the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以理解这个 `UnimplementedAccountServiceServer` 类型必须在某个地方嵌入，而这个“某个地方”就是我们将在本书后面定义的类型，当我们编写
    API 端点时。我们将有以下的代码：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is called type embedding, and this is the way Go goes about adding properties
    and methods from another type. You might have heard the advice to prefer composition
    over inheritance, and that is just that. We add the methods’ definitions from
    `UnimplementedAccountServiceServer` to `Server`. This will let us have the default
    implementations that return `method Logout not implemented` generated for us.
    This means that if a server without a full implementation receives a call on one
    of its unimplemented API endpoints, it will return an error but not crash because
    of the non-existent endpoint.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为类型嵌入，这是Go添加来自另一个类型的属性和方法的方式。你可能听说过建议优先使用组合而非继承，这正是如此。我们将 `UnimplementedAccountServiceServer`
    中的方法定义添加到 `Server` 中。这将使我们能够生成默认实现，返回 `method Logout not implemented`。这意味着如果一个没有完整实现的服务器在其未实现的API端点之一上收到调用，它将返回错误但不会因为不存在的端点而崩溃。
- en: Once we understand that, the `Logout` method signature is trivial. As mentioned,
    later we are going to define our own server type that embeds the `UnimplementedAccountServiceServer`
    type, and we are going to override the `Logout` function with the implementation.
    Any call to `Logout` will then be redirected to the implementation and not to
    the default generated code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了这一点，`Logout` 方法的签名就很简单了。如前所述，稍后我们将定义自己的服务器类型，该类型嵌入 `UnimplementedAccountServiceServer`
    类型，并将覆盖 `Logout` 函数的实现。任何对 `Logout` 的调用都将被重定向到实现，而不是默认生成的代码。
- en: The client
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端
- en: 'The generated code for the client is even simpler than the server code. We
    have an interface called `AccountServiceClient` that contains all the API endpoints:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端生成的代码甚至比服务器代码还要简单。我们有一个名为 `AccountServiceClient` 的接口，其中包含所有API端点：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And we have the actual implementation of that interface, called `accountServiceClient`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有该接口的实际实现，称为 `accountServiceClient`：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can notice one important thing in this piece of code. We have an endpoint
    route called `/AccountService/Logout`. If you take a look back at the `AccountService_ServiceDesc`
    variable described in the section titled *The server*, you will find out that
    this route is a concatenation of the `ServiceName` and `MethodName` properties.
    This will let the server know how to route that request to the `_AccountService_Logout_Handler`
    handler
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这段代码中注意到一个重要的事情。我们有一个端点路由 `/AccountService/Logout`。如果你回顾一下标题为 *服务器* 的部分中描述的
    `AccountService_ServiceDesc` 变量，你会发现这个路由是 `ServiceName` 和 `MethodName` 属性的连接。这将让服务器知道如何将这个请求路由到
    `_AccountService_Logout_Handler` 处理器。
- en: That is all. We can see that gRPC is handling all the boilerplate code to call
    an endpoint. We just need to create an object following the `AccountServiceClient`
    interface by calling `NewAccountServiceClient`, and then with that object, we
    can call the `Logout` member.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。我们可以看到gRPC正在处理调用端点的所有样板代码。我们只需要通过调用 `NewAccountServiceClient` 来创建一个遵循 `AccountServiceClient`
    接口的对象，然后通过这个对象，我们可以调用 `Logout` 成员。
- en: The read/write flow
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写流程
- en: Now that we have seen what Protobuf and gRPC are, it is time to go back to the
    read/write flow that we presented in [*Chapter 1*](B19664_01.xhtml#_idTextAnchor014).
    The goal of doing this is to make it a little bit more detailed and include what
    we learned.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了什么是Protobuf和gRPC，是时候回到我们在 [*第一章*](B19664_01.xhtml#_idTextAnchor014)
    中展示的读写流程了。这样做是为了让它更详细一些，并包括我们所学的知识。
- en: As a quick reminder, we saw that they are mostly three levels when writing and
    reading data. We have the user code, the gRPC framework, and the transport layers.
    What is interesting for us here is mostly the user code. We did not go into too
    much detail in [*Chapter 1*](B19664_01.xhtml#_idTextAnchor014) but now that we
    are equipped with more knowledge on what gRPC is doing, we can understand the
    process more clearly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速提醒，我们在编写和读取数据时看到它们主要是三个级别。我们有用户代码、gRPC框架和传输层。对我们来说，这里最有趣的是用户代码。我们没有在 [*第一章*](B19664_01.xhtml#_idTextAnchor014)
    中过多地深入细节，但现在我们有了更多关于gRPC是如何工作的知识，我们可以更清楚地理解这个过程。
- en: The user-code layer is the code that developers write and interacts with the
    gRPC framework. For the client, this is calling the endpoints, and for the server,
    this is the implementation of the endpoints. If we keep going with our `AccountService`
    service, we can give a concrete example of the read/write flow.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代码层是开发者编写的并与gRPC框架交互的代码。对于客户端，这是调用端点，对于服务器，这是端点的实现。如果我们继续使用我们的 `AccountService`
    服务，我们可以给出一个读写流程的具体例子。
- en: 'The first thing that we can do is separate the user-code layer into two parts:
    the implementation and the generated code. Furthermore, in [*Chapter 1*](B19664_01.xhtml#_idTextAnchor014),
    we gave a rather generic schema where we described the overall flow and drew a
    cryptic component called `Other Actor`. Let us now split the server and the client
    into two different actors, and we have the following system:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先可以做的就是将用户代码层分成两部分：实现和生成的代码。此外，在[*第一章*](B19664_01.xhtml#_idTextAnchor014)中，我们提供了一个相当通用的架构，其中我们描述了整体流程并绘制了一个神秘的组件，称为`Other
    Actor`。现在，让我们将服务器和客户端分成两个不同的参与者，我们得到以下系统：
- en: '![Figure 3.1 – Specialization of the read/write flow for AccountService](img/B19664_03_001.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – AccountService的读写流程专业化](img/B19664_03_001.jpg)'
- en: Figure 3.1 – Specialization of the read/write flow for AccountService
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – AccountService的读写流程专业化
- en: Important note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the preceding diagram, I am using abbreviations “c” and “s” to refer to the
    client and server respectively. “c” is an instance of `AccountServiceClient` created
    by `NewAccountServiceClient`, and “s” is an instance of a type defined in `Implementation`
    that defines the `Logout` function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我使用缩写“c”和“s”分别指代客户端和服务器。“c”是由`NewAccountServiceClient`创建的`AccountServiceClient`实例，“s”是定义在`Implementation`中的一种类型，该类型定义了`Logout`函数。
- en: We can see a few important things happening once we expand the diagram. The
    first interesting concept is that the generated code is shared across the different
    communication actors. We saw that the gRPC Go plugin will generate a single file
    containing the server and client types. This means that this file should be shared
    between all actors written in Go.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们展开这个图，我们就能看到一些重要的事情正在发生。第一个有趣的概念是生成的代码在各个不同的通信参与者之间是共享的。我们看到gRPC Go插件会生成一个包含服务器和客户端类型的单个文件。这意味着这个文件应该在所有用Go编写的参与者之间共享。
- en: We can also notice that the gRPC framework and generated code abstract everything
    for us. This lets us focus only on calling an endpoint with a `Request` object
    and on writing the endpoint handling that `Request` object and returning a `Response`
    object. This highly limits the amount of code we need to write and thus makes
    our code more testable because we need to focus on less code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注意到，gRPC框架和生成的代码为我们抽象了一切。这让我们只需关注调用一个带有`Request`对象的端点，并编写处理该`Request`对象并返回`Response`对象的端点处理。这极大地限制了我们需要编写的代码量，因此使得我们的代码更容易测试，因为我们只需要关注更少的代码。
- en: Finally, the last important thing to notice is that we can limit ourselves to
    reading the generated code to understand the parameters and return types of each
    of our endpoints. This is helpful because either the generated code will be picked
    up by your IDE and you will have autocompletion or you can simply check one file
    to get the information you need.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要注意的最后一件事是，我们可以限制自己只阅读生成的代码来了解我们每个端点的参数和返回类型。这很有帮助，因为生成的代码将被你的IDE捕获，你将获得自动完成，或者你可以简单地检查一个文件来获取你需要的信息。
- en: Why does gRPC matter?
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC为什么重要？
- en: Now that we have a sense of what gRPC is, we can get into why it matters. To
    explain gRPC’s role, we are going to compare it with two other ways of performing
    client/server communication. The first one is the traditional REST API architecture
    based on HTTP and JSON, and the second one is GraphQL.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对gRPC有了概念，我们可以探讨它为什么重要。为了解释gRPC的作用，我们将将其与两种其他执行客户端/服务器通信的方式进行比较。第一种是基于HTTP和JSON的传统REST
    API架构，第二种是GraphQL。
- en: REST
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST
- en: While I am assuming that most of you reading this book are familiar with REST
    APIs, I still believe that it is important to introduce the principles of designing
    such APIs. It will help us understand in which ways gRPC is like REST and in which
    it differs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我假设大多数阅读这本书的人对REST API都很熟悉，但我仍然认为介绍设计此类API的原则很重要。这将帮助我们理解gRPC在哪些方面与REST相似，在哪些方面不同。
- en: A REST API, as with every other technology in this comparison study, is an interface
    between an information provider and a consumer. When writing such an API, we expose
    endpoints on specific URLs (routes) that can be used by a client to create, read,
    update, and delete resource(s).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: REST API，就像本比较研究中提到的其他每项技术一样，是信息提供者和消费者之间的接口。在编写这样的API时，我们会在特定的URL（路由）上公开端点，客户端可以使用这些端点来创建、读取、更新和删除资源。
- en: 'However, REST APIs are different from gRPC and GraphQL. The main difference
    is that REST is not a framework—it is a set of architectural practices that can
    be implemented in different ways. The main constraints are the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，REST API与gRPC和GraphQL不同。主要区别在于REST不是一个框架——它是一组可以在不同方式中实现的架构实践。主要的约束如下：
- en: The client, server, and resources are the main entities during communication.
    The client requests resources from the server and the server returns the relevant
    resources.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端、服务器和资源是通信过程中的主要实体。客户端从服务器请求资源，服务器返回相关资源。
- en: Requests and responses are managed by HTTP. `GET` is used to read resources,
    `POST` to create resources, `PUT` to update resources, `PATCH` to update part
    of a resource, and `DELETE` to remove resources.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求和响应由HTTP管理。`GET`用于读取资源，`POST`用于创建资源，`PUT`用于更新资源，`PATCH`用于更新资源的一部分，`DELETE`用于删除资源。
- en: No client-related information should be stored between requests. This is a stateless
    communication, and each request is separate.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求之间不应存储任何与客户端相关的信息。这是一种无状态通信，每个请求都是独立的。
- en: Finally, even though such APIs are not bound to any data format, the most used
    one is JSON. This is mostly because JSON has a wide community, and a lot of languages
    and frameworks can handle this data format.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管这样的API没有绑定到任何数据格式，但最常用的格式是JSON。这主要是因为JSON拥有广泛的社区，许多语言和框架都能处理这种数据格式。
- en: GraphQL
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL
- en: GraphQL is presented as a query language for APIs. It lets developers write
    data schemas that describe the data available, and it lets them query a specific
    set of fields present in the schema.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL被呈现为API的查询语言。它允许开发者编写描述可用数据的数据模式，并允许他们查询模式中存在的特定字段集。
- en: As it lets us write queries, we can have more generic endpoints and request
    only the fields that we are interested in for a certain feature. This solves the
    problem of overfetching and underfetching because we only get the amount of data
    that we asked for.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它允许我们编写查询，我们可以拥有更通用的端点，并且只请求我们感兴趣的特征字段。这解决了过度获取和不足获取的问题，因为我们只获取我们请求的数据量。
- en: On top of all of this, as GraphQL mainly uses JSON as data format and uses explicit
    types and comments in its own data schema, this makes GraphQL more readable and
    self-documenting. This makes this technology more mature for companies at scale
    because we can do type-checking at compile time and shorten the feedback loop,
    and we do not have to separate documentation and code, thus it will be less likely
    to be not in sync.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之上，由于GraphQL主要使用JSON作为数据格式，并在其数据模式中使用显式类型和注释，这使得GraphQL更易于阅读和自文档化。这使得这项技术在规模化的公司中更加成熟，因为我们可以在编译时进行类型检查，缩短反馈循环，我们不需要将文档和代码分开，因此它不太可能不同步。
- en: Comparison with gRPC
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与gRPC的比较
- en: 'Now that we have had an overview of what each technology does, we can get started
    with comparing them with gRPC. We are going to focus on the biggest differentiators
    between these four ways of designing an API. These differentiators are the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经概述了每种技术的作用，我们可以开始比较它们与gRPC。我们将重点关注这四种设计API方式之间的最大区别。这些区别如下：
- en: The transport, data format, and data schema used for communication
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于通信的传输、数据格式和数据模式
- en: Separation of concern of API endpoints
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API端点的关注点分离
- en: The developers’ workflow when writing APIs
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者在编写API时的流程
- en: The convenience of out-of-the-box features
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开箱即用的功能便利性
- en: Transport, data format, and data schema
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输、数据格式和数据模式
- en: In this regard, GraphQL and REST APIs are similar. They both use HTTP/1.1 for
    the underlying transport and, more often than not, developers use JSON for sending
    structured data. On the other side, gRPC uses HTTP/2 and Protobuf by default.
    This means that, with gRPC, we have smaller payloads to send over the wire and
    we have more efficient connection handling.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，GraphQL和REST API是相似的。它们都使用HTTP/1.1作为底层传输，并且大多数情况下，开发者使用JSON发送结构化数据。另一方面，gRPC默认使用HTTP/2和Protobuf。这意味着，在gRPC中，我们有更小的有效负载要发送，并且我们有更高效的连接处理。
- en: There are certain things to be more careful about when we are dealing with Protobuf
    than when we have to deal with JSON. Protobuf provides implicit default values
    depending on the type of field, and these default values do not get serialized
    into the final binary. For example, `int32` has a default value of 0\. This means
    that we cannot differentiate between the value 0 being set or whether the field
    was not set. Of course, there are ways of dealing with that, but it makes the
    client-side usage a little bit more involved. In this respect, GraphQL handles
    default values differently. We can pass the default values as parameters of our
    endpoints, and this means that we can handle particular cases in a more user-friendly
    way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理Protobuf而不是JSON时，有一些事情需要更加小心。Protobuf根据字段的类型提供隐式默认值，并且这些默认值不会序列化到最终的二进制文件中。例如，`int32`的默认值是0。这意味着我们无法区分值0被设置还是字段没有被设置。当然，有处理这种情况的方法，但这使得客户端的使用稍微复杂一些。在这方面，GraphQL处理默认值的方式不同。我们可以将默认值作为端点的参数传递，这意味着我们可以以更用户友好的方式处理特定情况。
- en: Finally, it is important to mention that all these technologies are quite flexible
    regarding the kind of data format that you can transport over the wire. REST APIs
    handle binary and other kinds of data, GraphQL can also accept binary data, and
    gRPC can send JSON data. However, problems come with this flexibility. If you
    are using binary over a REST API, you let both the client and the server interpret
    what this binary means. There is no type safety and we need to handle serialization/deserialization
    errors that otherwise would be handled by libraries or frameworks. If you use
    binary with GraphQL, you are greatly reducing the number of community tools that
    you can use. And finally, if you use JSON with gRPC, you are losing all the advantages
    of Protobuf.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要提到，所有这些技术都非常灵活，可以处理通过网络传输的数据格式。REST API处理二进制和其他类型的数据，GraphQL也可以接受二进制数据，而gRPC可以发送JSON数据。然而，这种灵活性也带来了问题。如果你在REST
    API上使用二进制，你让客户端和服务器解释这个二进制代表什么。没有类型安全，我们需要处理序列化/反序列化错误，否则这些错误将由库或框架处理。如果你使用GraphQL的二进制，你将大大减少可以使用的社区工具数量。最后，如果你使用gRPC的JSON，你将失去Protobuf的所有优势。
- en: Separation of concern of API endpoints
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API端点的关注点分离
- en: Designing separation of concern for APIs can be tricky and lead to problems
    such as underfetching or overfetching. GraphQL was designed to solve these problems
    of getting too much or too little data when making a request. With it, you can
    simply ask for a specific set of fields that you need for a certain feature. While
    it is possible to do a similar thing with gRPC and REST APIs, it remains non-user-friendly
    when your API is facing external users.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 设计API的关注点分离可能很棘手，可能导致问题，如未获取或过度获取。GraphQL被设计用来解决在请求时获取过多或过少数据的问题。有了它，你可以简单地请求特定功能所需的特定字段集。虽然使用gRPC和REST
    API也可以做类似的事情，但当你的API面对外部用户时，这仍然不够用户友好。
- en: However, separation of concern in APIs can help us with a few things. First,
    it can help us reduce the scope of testing for an endpoint. Instead of thinking
    about all the possible inputs and outputs that an endpoint might have, we are
    only focusing on a specific input and a specific output.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，API中的关注点分离可以帮助我们处理一些事情。首先，它可以帮助我们缩小端点的测试范围。我们不需要考虑端点可能具有的所有可能的输入和输出，我们只需要关注特定的输入和输出。
- en: And second, having smaller and more specific endpoints will help in the case
    of API abuse. As we can clearly know which request was made to which endpoint,
    we can rate-limit them per client and thus secure our APIs. With more flexible
    API endpoints such as in GraphQL, this is intrinsically harder to implement because
    we need to ponder whether to rate limit on the whole route, a specific input,
    or just a simple query.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，拥有更小、更具体的端点将有助于API滥用的处理。因为我们可以清楚地知道哪个请求被发送到了哪个端点，我们可以按客户端对它们进行速率限制，从而保护我们的API。在像GraphQL这样的更灵活的API端点中，这本质上更难实现，因为我们需要考虑是否要在整个路由、特定的输入或只是一个简单的查询上进行速率限制。
- en: The developers’ workflow
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发者的工作流程
- en: Another important aspect of these technologies that is often overlooked is the
    developers’ workflow when writing an API. With REST APIs, we are mostly working
    on the server and the client separately, and this process is error-prone. If we
    do not have specifications on what data to expect, we are in for long sessions
    of debugging. Furthermore, even if we have specifications on the data, developers
    are humans and humans make mistakes. The client might have expected a certain
    kind of data, but the server is sending another.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术的另一个重要方面，但常常被忽视的是，开发者编写API时的开发流程。使用REST API时，我们通常分别在不同的服务器和客户端上工作，这个过程容易出错。如果没有关于预期数据的规范，我们可能会陷入长时间的调试。此外，即使我们有数据规范，开发者也是人，人都会犯错误。客户端可能期望某种类型的数据，但服务器发送的却是另一种。
- en: Now, this is not a problem that concerns only REST APIs—gRPC and GraphQL APIs
    also have this problem. However, the problem scope is reduced because we can make
    sure that only a certain type can be used as a request and another as a response.
    This lets us focus on the happy path instead of writing code that is checking
    whether the serialization and deserialization failed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这不仅仅是一个只影响REST API的问题——gRPC和GraphQL API也存在这个问题。然而，问题范围缩小了，因为我们能确保只有特定类型的数据可以用作请求，另一种用作响应。这使得我们可以专注于“快乐路径”，而不是编写检查序列化和反序列化是否失败的代码。
- en: The gRPC and GraphQL way of developing APIs is called `int`, and it will tell
    us that at compile time. This also makes the scope of tests much smaller because
    we can now focus on the feature itself and not on the many possible errors that
    could happen due to external problems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC和GraphQL开发API的方式被称为`int`，它将在编译时告诉我们。这也使得测试范围缩小，因为我们现在可以专注于功能本身，而不是由于外部问题可能发生的许多可能的错误。
- en: Convenience
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 便利性
- en: Finally, another overlooked topic is how convenient using technology is. This
    can be due to the community developing tools or simply out-of-the-box features
    coming with the framework. In this case, technologies using JSON often have more
    tools and support. This is the case because JSON has been widely used for a long
    time and it is attractive because of its human readability.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，另一个被忽视的话题是使用技术的便利性。这可能是由于社区开发工具，或者仅仅是框架自带的一些即用功能。在这种情况下，使用JSON的技术通常拥有更多的工具和支持。这是因为JSON已经广泛使用很长时间了，它因其可读性而受到青睐。
- en: However, even with the lack of tool compared to JSON-backed APIs, gRPC was designed
    on principles that helped Google scale and secure its products, it has a lot of
    amazing features that you can get without any extra dependencies. gRPC has interceptors,
    TLS authentication, and many other high-end features built in as part of the official
    framework, and thus it is simpler to write secure and performant code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使与JSON支持的API相比缺少工具，gRPC也是基于帮助谷歌扩展和保障其产品的原则设计的，它拥有许多你无需额外依赖就能获得的功能。gRPC具有拦截器、TLS认证以及许多其他内置的高端特性，作为官方框架的一部分，因此编写安全且高效的代码变得更加简单。
- en: Finally, GraphQL is the only technology of the three that is explicit about
    endpoints having side effects. This can be documented for gRPC or REST APIs; however,
    this cannot be checked statically. This is important because this makes the APIs’
    users more aware of what is happening in the background, and it might lead to
    better choices for appropriate routes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，GraphQL是三种技术中唯一明确指出端点具有副作用的技术。这可以在gRPC或REST API中记录；然而，这不能进行静态检查。这很重要，因为它使API用户更加了解后台发生的事情，并可能导致更好的路由选择。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: To summarize, gRPC is a mature technology adopted by tech giants but also the
    open source community to create efficient and performant client/server communication.
    This is not only true in the distributed system but also in the local environment
    with the use of IPC. gRPC uses Protobuf by default due to its compact binary serialization
    and fast deserialization but also for its type safety and language agnosticism.
    On top of that, gRPC generates code to send Protobuf over HTTP/2\. It generates
    a server and a client for us so that we do not have to think about the details
    of communication. All the details are handled by the gRPC framework.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，gRPC是一种成熟的技术，被科技巨头和开源社区采用，用于创建高效且性能卓越的客户端/服务器通信。这不仅适用于分布式系统，也适用于使用IPC的本地环境。gRPC默认使用Protobuf，因为它具有紧凑的二进制序列化和快速反序列化能力，同时也因为其类型安全和语言无关性。在此基础上，gRPC会生成代码，通过HTTP/2发送Protobuf。它为我们生成服务器和客户端，这样我们就不必考虑通信的细节。所有细节都由gRPC框架处理。
- en: In the next chapter, we are finally going to get our hands dirty. We are going
    to set up a gRPC project, make sure that our code generation is working properly,
    and write some boilerplate code for both the server and the client.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们终于要开始动手实践了。我们将设置一个gRPC项目，确保我们的代码生成工作正常，并为服务器和客户端编写一些样板代码。
- en: Quiz
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: What is one of the reasons Protobuf is the default data format for gRPC?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Protobuf成为gRPC默认数据格式的其中一个原因是什么？
- en: The serialized data is human-readable
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化的数据是可读的
- en: It is dynamically typed
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是动态类型的
- en: It is type-safe
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是类型安全的
- en: In the Go implementation, which component generates server/client code?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Go实现中，哪个组件生成服务器/客户端代码？
- en: Protoc
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Protoc
- en: The gRPC Go plugin
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: gRPC Go插件
- en: Other
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他
- en: What are service descriptors in the context of gRPC-generated code?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在gRPC生成的代码的上下文中，什么是服务描述符？
- en: They describe which endpoints a service has and how to handle requests
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们描述了服务有哪些端点以及如何处理请求
- en: They describe how to return responses
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们描述了如何返回响应
- en: Both of these
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个
- en: How will the user code be able to implement the logout endpoint?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户代码将如何实现登出端点？
- en: By writing code in the generated `Logout` function
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在生成的`Logout`函数中编写代码
- en: By creating a copy of the generated code and editing it
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建生成的代码的副本并编辑它
- en: By using type embedding with the generated server and implementing `Logout`
    for that type
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用生成的服务器中的类型嵌入并实现该类型的`Logout`
- en: Answers
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: C
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: B
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: A
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: C
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
