<html><head></head><body>
<div id="_idContainer020">
<h1 class="chapter-number" id="_idParaDest-72"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-73"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.2.1">Setting Up a Project</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As the chapter title suggests, we are going to set up a gRPC project from scratch. </span><span class="koboSpan" id="kobo.3.2">We are first going to create </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.4.1">our Protobuf schema as we are doing schema-driven development. </span><span class="koboSpan" id="kobo.4.2">Once the schema is created, we will generate Go code. </span><span class="koboSpan" id="kobo.4.3">Finally, we are going to write the templates for the server and client so that we can reuse them later in </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">Common gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">project architecture</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Generating Go code out of </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">a schema</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Writing reusable </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">server/client templates</span></span></li>
</ul>
<h1 id="_idParaDest-74"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.14.1">Prerequisites</span></h1>
<p><span class="koboSpan" id="kobo.15.1">I assume that </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.16.1">you already have protoc installed from the last chapter. </span><span class="koboSpan" id="kobo.16.2">If you do not, this is the right time to install it because without it, you will not benefit as much from </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">In this chapter, I will show common ways of setting up a gRPC project. </span><span class="koboSpan" id="kobo.18.2">I will use protoc, Buf, and Bazel. </span><span class="koboSpan" id="kobo.18.3">Thus, depending on the one(s) you are interested in, you will have to download the tool(s). </span><span class="koboSpan" id="kobo.18.4">Buf is an abstraction over protoc that lets us run protoc commands more easily. </span><span class="koboSpan" id="kobo.18.5">On top of that, it provides features such as linting and detecting breaking changes. </span><span class="koboSpan" id="kobo.18.6">You can download Buf from here: </span><a href="https://docs.buf.build/installation"><span class="koboSpan" id="kobo.19.1">https://docs.buf.build/installation</span></a><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">I will also use Bazel to automatically generate Go code from Protobuf and the binary of our server and client. </span><span class="koboSpan" id="kobo.20.3">If you are interested in using it, you can check the installation </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">documentation (</span></span><a href="https://github.com/bazelbuild/bazelisk#installation"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/bazelbuild/bazelisk#installation</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">Finally, you can find the code for this chapter under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">chapter4</span></strong><span class="koboSpan" id="kobo.26.1"> folder in the accompanying GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">repository (</span></span><a href="https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">).</span></span></p>
<h1 id="_idParaDest-75"><span class="koboSpan" id="kobo.30.1">Creatin</span><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.31.1">g a .proto file definition</span></h1>
<p><span class="koboSpan" id="kobo.32.1">Since the</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.33.1"> goal of this chapter is to write a template that we can use for later projects, we are going to create a dummy proto file that will let us test whether our build system is working properly or not. </span><span class="koboSpan" id="kobo.33.2">This dummy proto file will contain both a message and a service because we want to test code generation for both Protobuf </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">and gRPC.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">The message, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">DummyMessage</span></strong><span class="koboSpan" id="kobo.37.1">, will be defined </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.39.1">
message DummyMessage {}</span></pre>
<p><span class="koboSpan" id="kobo.40.1">The service, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">DummyService</span></strong><span class="koboSpan" id="kobo.42.1">, will be defined </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.44.1">
service DummyService {}</span></pre>
<p><span class="koboSpan" id="kobo.45.1">Now, because we are planning to generate Golang code, we still need to define an option called </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">go_package</span></strong><span class="koboSpan" id="kobo.47.1"> and set its value to the name of the Go module concatenated with the name of the subfolder containing the proto files. </span><span class="koboSpan" id="kobo.47.2">This option is important because it lets us define the package in which the generated code should be. </span><span class="koboSpan" id="kobo.47.3">In our case, the project architecture is </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.49.1">
.
</span><span class="koboSpan" id="kobo.49.2">├── client
│   └── go.mod
├── go.work
├── proto
│   ├── dummy
│   │   └── v1
│   │       └── dummy.proto
│   └── go.mod
└── server
    └── go.mod</span></pre>
<p><span class="koboSpan" id="kobo.50.1">We have a monorepo (Go workspace) with three submodules: </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">client</span></strong><span class="koboSpan" id="kobo.52.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">proto</span></strong><span class="koboSpan" id="kobo.54.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">server</span></strong><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">We create</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.57.1"> each submodule by going into each folder and running the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">following command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.59.1">$ go mod init github.com/github.com/PacktPublishing/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.60.1">gRPC-Go-for-Professionals/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.61.1">$FOLDER_NAME</span></strong></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">$FOLDER_NAME</span></strong><span class="koboSpan" id="kobo.63.1"> should be replaced with the name of the folder you are currently in (</span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">client</span></strong><span class="koboSpan" id="kobo.65.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">proto</span></strong><span class="koboSpan" id="kobo.67.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">server</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">To make the process a little bit quicker, we can create a command that will list the folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">root</span></strong><span class="koboSpan" id="kobo.73.1"> directory and execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">go</span></strong><span class="koboSpan" id="kobo.75.1"> command. </span><span class="koboSpan" id="kobo.75.2">To do so, you can use the following UNIX (</span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">Linux/macOS) comma</span><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.77.1">nd:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
$ find . </span><span class="koboSpan" id="kobo.78.2">-maxdepth 1 -type d -n</span><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.79.1">ot -path . </span><span class="koboSpan" id="kobo.79.2">-execdir sh -c "pushd {}; go
mod init 'github.com/PacktPublishing/
gRPC-Go-for-Professionals/{}';
popd" ";"</span></pre>
<p><span class="koboSpan" id="kobo.80.1">If you are on Windows, you can use PowerShell to run </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.82.1">$ Get-ChildItem . </span><span class="koboSpan" id="kobo.82.2">-Name -Directory | ForEach-Obj</span><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.83.1">ect { Push-</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.84.1">Location $_; go mod init "github.com/PacktPublishing/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.85.1">gRPC-Go-for-Professionals/$_" ;</span></strong>
<strong class="bold"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.86.1">Pop-Location }</span></strong></pre>
<p><span class="koboSpan" id="kobo.87.1">After that, we can create the workspace file. </span><span class="koboSpan" id="kobo.87.2">We do so by going to the root of the project (</span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">chapter4</span></strong><span class="koboSpan" id="kobo.89.1">) and running </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.91.1">$ go work init client server proto</span></strong></pre>
<p><span class="koboSpan" id="kobo.92.1">We now have the </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">following </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">go.work</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
go 1.20
use </span><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.97.1">(
  ./clien</span><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.98.1">t
  ./prot</span><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.99.1">o
  ./server
)</span></pre>
<p><span class="koboSpan" id="kobo.100.1">Each submodule has the </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">following </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">go.mod</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.104.1">
module $MODULE_NAME/$SUBMODULE_NAME
go 1.20</span></pre>
<p><span class="koboSpan" id="kobo.105.1">Here, we’ll </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.106.1">replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">$MODULE_NAME</span></strong><span class="koboSpan" id="kobo.108.1"> with a URL such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">github.com/PacktPublishing/gRPC-Go-for-Professionals</span></strong><span class="koboSpan" id="kobo.110.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">$SUBMODULE_NAME</span></strong><span class="koboSpan" id="kobo.112.1">, with the respective name of the folder containing the file. </span><span class="koboSpan" id="kobo.112.2">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">go.mod</span></strong><span class="koboSpan" id="kobo.114.1"> in the client, we will have </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
module github.com/PacktPublishing/gRPC-Go-for-Professionals/client
go 1.20</span></pre>
<p><span class="koboSpan" id="kobo.117.1">Finally, we can complete </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">dummy.proto</span></strong><span class="koboSpan" id="kobo.119.1"> by adding the following line to </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">our file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
option go_package = "github.com/PacktPublishing/
gRPC-Go-for-Professionals/
proto/dummy/v1";</span></pre>
<p><span class="koboSpan" id="kobo.122.1">We now have the </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">following </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">dummy.proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
syntax = "proto3";
option go_package = "github.com/PacktPublishing/
gRPC-Go-for-Professionals/proto/dummy/v1";
message DummyMessage {}
service DummyService {}</span></pre>
<p><span class="koboSpan" id="kobo.127.1">That is all we need</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.128.1"> to test the code generation out of </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">dummy.proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.132.1">Generating Go code</span></h1>
<p><span class="koboSpan" id="kobo.133.1">To stay</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.134.1"> impartial in terms of the tools you need to generate code, I will present three different tools from the lowest level to the highest. </span><span class="koboSpan" id="kobo.134.2">We are going to start by seeing how to manually generate code with protoc. </span><span class="koboSpan" id="kobo.134.3">Then, because we do not want to write lengthy command lines all the time, we are going to see how to make this generation easier with Buf. </span><span class="koboSpan" id="kobo.134.4">Finally, we are going to see how to use Bazel to integrate the code generation as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">our build.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.136.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.137.1">In this section, I’m going to show basic ways of compiling your proto files. </span><span class="koboSpan" id="kobo.137.2">Most of the time, these commands will get you by, but sometimes you might have to check each tool’s documentation. </span><span class="koboSpan" id="kobo.137.3">For protoc, you can run </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">protoc --help</span></strong><span class="koboSpan" id="kobo.139.1"> and get a list of the options. </span><span class="koboSpan" id="kobo.139.2">For Buf, you can go to the online documentation: </span><a href="https://docs.buf.build/installation"><span class="koboSpan" id="kobo.140.1">https://docs.buf.build/installation</span></a><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">For Bazel, you also have online documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">at </span></span><a href="https://bazel.build/reference/be/protocol-buffer"><span class="No-Break"><span class="koboSpan" id="kobo.143.1">https://bazel.build/reference/be/protocol-buffer</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.144.1">.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.145.1">Protoc</span></h2>
<p><span class="koboSpan" id="kobo.146.1">Using</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.147.1"> protoc is </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.148.1">the manual way of generating code out of proto files. </span><span class="koboSpan" id="kobo.148.2">This technique might be fine if you are only dealing with a few proto files and you do not have a lot of dependencies between files (imports). </span><span class="koboSpan" id="kobo.148.3">Otherwise, this will be quite painful, as we </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">will see.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">However, I still believe that we should learn the </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.151.1">protoc command a bit so that we get a sense of what we can do with it. </span><span class="koboSpan" id="kobo.151.2">Also, higher-level tools are based on protoc, so this will help us under</span><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.152.1">stand its </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">different features.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">With our </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">dummy.proto</span></strong><span class="koboSpan" id="kobo.156.1"> file from the previous section, we can run protoc in the root folder (</span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">chapter4</span></strong><span class="koboSpan" id="kobo.158.1">) like </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.160.1">$ protoc --go_out=. </span><span class="koboSpan" id="kobo.160.2">\</span></strong><span class="koboSpan" id="kobo.161.1">
         --go_opt=module=github.com/PacktPublishing/
                 gRPC-Go-for-Professionals \
         --go-grpc_out=. </span><span class="koboSpan" id="kobo.161.2">\
         --go-grpc_opt=module=github.com/PacktPublishing/
                  gRPC-Go-for-Professionals \
         proto/dummy/v1/dummy.proto</span></pre>
<p><span class="koboSpan" id="kobo.162.1">Now, this might look a bit scary and, in fact, is not the shortest command that you could write to do this. </span><span class="koboSpan" id="kobo.162.2">I am going to show you a more compact one when we talk about Buf. </span><span class="koboSpan" id="kobo.162.3">But first, let us dissect the preceding command </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">into parts.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">Before discussing </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">--go_out</span></strong><span class="koboSpan" id="kobo.166.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">--go-grpc_out</span></strong><span class="koboSpan" id="kobo.168.1">, let us look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">--go_opt=module</span></strong><span class="koboSpan" id="kobo.170.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">--go-grpc_opt=module</span></strong><span class="koboSpan" id="kobo.172.1">. </span><span class="koboSpan" id="kobo.172.2">These options are telling protoc about the common module to be stripped out by the value passed for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">go_package</span></strong><span class="koboSpan" id="kobo.174.1"> option in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">proto</span></strong><span class="koboSpan" id="kobo.176.1"> file. </span><span class="koboSpan" id="kobo.176.2">Say we have </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.178.1">
option go_package = "github.com/PacktPublishing/
gRPC-Go-for-Professionals/proto/dummy/v1";</span></pre>
<p><span class="koboSpan" id="kobo.179.1">Then, -</span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">-go_opt=module=github.com/PacktPublishing/gRPC-Go-for-Professionals</span></strong><span class="koboSpan" id="kobo.181.1"> will strip the value after </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">module=</span></strong><span class="koboSpan" id="kobo.183.1"> from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">go_package</span></strong><span class="koboSpan" id="kobo.185.1">, so now we only </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">have </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">/proto/dummy/v1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">Now that we understand this, we can get to </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">--go_out</span></strong><span class="koboSpan" id="kobo.191.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">--go-grpc_out</span></strong><span class="koboSpan" id="kobo.193.1">. </span><span class="koboSpan" id="kobo.193.2">These two options tell protoc where to </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.194.1">generate the Go code. </span><span class="koboSpan" id="kobo.194.2">In our case, it seems that we are telling protoc to generate our code at the root level, but in fact, because it is combined with the two</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.195.1"> previous options, it will generate the code right next to the proto file. </span><span class="koboSpan" id="kobo.195.2">This is due to the stripping of the pac</span><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.196.1">kage, which leads protoc to generate the code in the folder </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">proto/dummy/v1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1"> package</span></span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Now, you can see how painful it might be to write that kind of command all the time. </span><span class="koboSpan" id="kobo.201.2">Most people do not do that. </span><span class="koboSpan" id="kobo.201.3">They either write a script to do it automatically or use other tools, such </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">as Buf.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.203.1">Buf</span></h2>
<p><span class="koboSpan" id="kobo.204.1">For </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.205.1">Buf, we </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.206.1">have a little bit more setup to do to generate code. </span><span class="koboSpan" id="kobo.206.2">At the root of the project (</span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">chapter4</span></strong><span class="koboSpan" id="kobo.208.1">), we are going to create a Buf module. </span><span class="koboSpan" id="kobo.208.2">To do that, we can simply run </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.210.1">$ buf mod init</span></strong></pre>
<p><span class="koboSpan" id="kobo.211.1">This creates a file </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.212.1">called </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">buf.yaml</span></strong><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">This file is where you can set project-level options such as linting or even tracking breaking changes. </span><span class="koboSpan" id="kobo.214.3">These are beyond the scope of this book, but if you are interested in this tool, check out the </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">documentation (</span></span><a href="https://buf.build/docs/tutorials/getting-started-with-buf-cli/"><span class="No-Break"><span class="koboSpan" id="kobo.216.1">https://buf.build/docs/tutorials/getting-started-with-buf-cli/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.217.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">Once we have that, we need to write the configuration for generation. </span><span class="koboSpan" id="kobo.218.2">In a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">buf.gen.yaml</span></strong><span class="koboSpan" id="kobo.220.1">, we will have </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.222.1">
version: v1
plugins:
  - plugin: go
    out: proto
    opt: paths=source_relative
  - plugin: go-grpc
    out: proto
    opt: paths=source_relative</span></pre>
<p><span class="koboSpan" id="kobo.223.1">Here, we are defining the use of the Go plugin for Protobuf and gRPC. </span><span class="koboSpan" id="kobo.223.2">For each, we are saying that we want to generate the code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">proto</span></strong><span class="koboSpan" id="kobo.225.1"> directory, and we are using another </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">--go_opt</span></strong><span class="koboSpan" id="kobo.227.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">--go-grpc_opt</span></strong><span class="koboSpan" id="kobo.229.1"> for protoc, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">paths=source_relative</span></strong><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">When this is set, the generated code is placed in the same directory </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.232.1">as the input file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">dummy.proto</span></strong><span class="koboSpan" id="kobo.234.1">). </span><span class="koboSpan" id="kobo.234.2">So, in the end, Buf is running something like what we did in the protoc section. </span><span class="koboSpan" id="kobo.234.3">It is running </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.236.1">$ protoc --go_out=. </span><span class="koboSpan" id="kobo.236.2">\</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.237.1">         --go_opt=paths=source_relative \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.238.1">         --go-grpc_out=. </span><span class="koboSpan" id="kobo.238.2">\</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.239.1">         --go-grpc_opt=paths=source_relative \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.240.1">         proto/dummy/v1/dummy.proto</span></strong></pre>
<p><span class="koboSpan" id="kobo.241.1">In order to run generation using Buf, we simply need to run the following command (</span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">in chapter4):</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.243.1">$ buf generate proto</span></strong></pre>
<p><span class="koboSpan" id="kobo.244.1">Using Buf is </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.245.1">pretty common for mid-size or large projects. </span><span class="koboSpan" id="kobo.245.2">It helps with automation of code generation and is easy to get started with. </span><span class="koboSpan" id="kobo.245.3">However, you might have noticed that you need to generate the code in one step and then build your Go application. </span><span class="koboSpan" id="kobo.245.4">Bazel will help us consolidate everything in </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">one step.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.247.1">Bazel</span></h2>
<p class="callout-heading"><span class="koboSpan" id="kobo.248.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.249.1">In this section, I will be using variables called </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">GO_VERSION</span></strong><span class="koboSpan" id="kobo.251.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">RULES_GO_VERSION</span></strong><span class="koboSpan" id="kobo.253.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">RULES_GO_SHA256</span></strong><span class="koboSpan" id="kobo.255.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">GAZELLE_VERSION</span></strong><span class="koboSpan" id="kobo.257.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">GAZELLE_SHA256</span></strong><span class="koboSpan" id="kobo.259.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">PROTO_VERSION</span></strong><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">We have not included these variables in this section to ensure that the book remains easily updated. </span><span class="koboSpan" id="kobo.261.3">You can find the versions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">versions.bzl</span></strong><span class="koboSpan" id="kobo.263.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">chapter4</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.265.1">folder (</span></span><a href="https://github.com/PacktPublishing/Implementing-gRPC-in-Golang-Microservice/tree/main/chapter4"><span class="No-Break"><span class="koboSpan" id="kobo.266.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.267.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">Bazel </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.269.1">is</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.270.1"> a little bit trickier to set up, but it is worth the effort. </span><span class="koboSpan" id="kobo.270.2">Once you have your build system up and running, you will be able to build the whole application (generation and build) and/or run it in </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">one command.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">In Bazel, we start</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.273.1"> by defining a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">WORKSPACE.bazel</span></strong><span class="koboSpan" id="kobo.275.1"> at the root level. </span><span class="koboSpan" id="kobo.275.2">In this file, we define all the dependencies for our project. </span><span class="koboSpan" id="kobo.275.3">In our case, we have dependencies on Protobuf and Go. </span><span class="koboSpan" id="kobo.275.4">On top of that, we are also going to add a dependency to Gazelle, which will help us create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">BUILD.bazel</span></strong><span class="koboSpan" id="kobo.277.1"> file needed to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">So, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">WORKSPACE.bazel</span></strong><span class="koboSpan" id="kobo.281.1">, before</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.282.1"> anything else, we are going to define our workspace name, import our version variables, and import some utilities to clone Git repositories an</span><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.283.1">d </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">download archives:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
workspace(name = "github_com_packtpublishing_grpc_go_for_
professionals")
load("//:versions.bzl",
  "GO_VERSION",
  "RULES_GO_VERSION",
  "RULES_GO_SHA256",
  "GAZELLE_VERSION",
  "GAZELLE_SHA256",</span><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.286.1">
  "PROTO_VERSION"
)
load("@bazel_tools//tools/build_defs/repo:http.bzl"</span><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.287.1">,
  "http_archive")
load("@bazel_tools//tools/build_defs/repo:git.bzl",
  "git_repository")</span></pre>
<p><span class="koboSpan" id="kobo.288.1">After that, we</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.289.1"> are going to define the dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">for Gazelle:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
http_archive(
  name = "bazel_gazelle",
  sha256 = GAZELLE_SHA256,
  urls = [
    "https://mirror.bazel.build/github.com/bazelbuild/
    bazel-gazelle/releases/download/%s/bazel-gazelle-
    %s.tar.gz" % (GAZELLE_VERSION, GAZELLE_VERSION),
    "https://github.com/bazelbuild/bazel-gazelle/
    releases/download/%s/bazel-gazelle-%s.tar.gz" %
    (GAZELLE_VERSION, GAZELLE_VERSION),
  ],
)</span></pre>
<p><span class="koboSpan" id="kobo.292.1">Then, we </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.293.1">need to pull the dependency for building Go binaries, applications, and </span><a id="_idIndexMarker152"/><span class="No-Break"><span class="koboSpan" id="kobo.294.1">so on:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
http_archive(
  name = "io_bazel_rules_go",
  sha256 = RULES_GO_SHA256,
  urls = [
    "https://mirror.bazel.build/github.com/bazelbuild/
    rules_go/releases/download/%s/rules_go-%s.zip" %
    (RULES_GO_VERSION, RULES_GO_VERSION),
    "https://github.com/bazelbuild/rules_go/releases/
    download/%s/rules_go-%s.zip" % (RULES_GO_VERSION,
    RULES_GO_VERSION),
  ],
)</span></pre>
<p><span class="koboSpan" id="kobo.296.1">Now that we have that, we can pull the dependencies of </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">rules_go</span></strong><span class="koboSpan" id="kobo.298.1">, set the toolchain for building the Go project, and tell Gazelle where to find ou</span><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.299.1">r </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">WORKSPACE.bazel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.301.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
load("@io_bazel_rules_go//go:deps.bzl",
  "go_register_toolchains", "</span><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.303.1">go_rules_dependencies")
load("@bazel_gazelle//:deps.bzl", "gazelle_dependencies")
go_rules_dependencies()
go_register_toolchains(version = GO_VERSION)
gazelle_dependencies(go_repository_default_config =
  "//:WORKSPACE.bazel")</span></pre>
<p><span class="koboSpan" id="kobo.304.1">Finally, we </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.305.1">pull the</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.306.1"> dependency for Protobuf and load </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">its dependencies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
git_repository(
  name = "com_google_protobuf",
  tag = PROTO_VERSION,
  remote = "https://github.com/pro</span><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.309.1">tocolbuffers/protobuf"
)
load("@com_google_protobuf//:protobuf_deps.bzl",
  "protobuf_deps")
protobuf_deps()</span></pre>
<p><span class="koboSpan" id="kobo.310.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">WORKSPACE.bazel</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.312.1">is complete.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Let us now move to </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">BUILD.bazel</span></strong><span class="koboSpan" id="kobo.315.1"> at the root level. </span><span class="koboSpan" id="kobo.315.2">In this file, we are going to define the command to run Gazelle, and we are going to let Gazelle know the Go module name and that we want it to not consider the Go files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">proto</span></strong><span class="koboSpan" id="kobo.317.1"> directory. </span><span class="koboSpan" id="kobo.317.2">We do so because otherwise, Gazelle would think that the Go file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">proto</span></strong><span class="koboSpan" id="kobo.319.1"> directory should also have its own Bazel target file and this might create</span><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.320.1"> problems down </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">the road:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
load("@bazel_gazelle//:def.bzl", "gazelle")
# </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">gazelle:exclude</span></strong><span class="koboSpan" id="kobo.324.1"> proto/**/*.go
# </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">gazelle:prefix</span></strong><span class="koboSpan" id="kobo.326.1"> github.com/PacktPublishing/gRPC-Go-for-Professionals
gazelle(name = "gazelle")</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.327.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.328.1">With that, we can now run </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.330.1">$ bazel run //:gazelle</span></strong></pre>
<p class="callout"><span class="koboSpan" id="kobo.331.1">If you have installed Bazel through Bazelisk, Bazel will try to get its newest version each time you run a bazel command. </span><span class="koboSpan" id="kobo.331.2">In order to avoid this, you can create a file called .bazelversion containing the version of bazel you currently have installed. </span><span class="koboSpan" id="kobo.331.3">You can find the version </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">by typing</span></span></p>
<p class="callout"><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.333.1">bazel --version</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.334.1">An example can be found in the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">chapter4 folder.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">After the</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.337.1"> dependencies</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.338.1"> are pulled up and compiled, you should be able to see a </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">BUILD.bazel</span></strong><span class="koboSpan" id="kobo.340.1"> file generated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">proto/dummy/v1</span></strong><span class="koboSpan" id="kobo.342.1"> directory. </span><span class="koboSpan" id="kobo.342.2">The most important part of this file is the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">following </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">go_library</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.346.1">
go_library(
  name = "dummy",
  embed = [":v1_go_proto"],
  importpath = "github.com/PacktPublishing/gRPC-Go-for-
    Professionals/proto/dummy/v1",
  visibility = ["//visibility:public"],
)</span></pre>
<p><span class="koboSpan" id="kobo.347.1">Later, we will use this library and link it to our binary. </span><span class="koboSpan" id="kobo.347.2">It contains all the generated code that we need to </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">get star</span><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.349.1">ted.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.350.1">Server boilerplate</span></h1>
<p><span class="koboSpan" id="kobo.351.1">Our build system is</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.352.1"> ready. </span><span class="koboSpan" id="kobo.352.2">We can now focus on the code. </span><span class="koboSpan" id="kobo.352.3">But before going into that, let us define what we want. </span><span class="koboSpan" id="kobo.352.4">In this section, we want to build a template for the gRPC server that we can reuse for later chapters and even later projects outside of the book. </span><span class="koboSpan" id="kobo.352.5">To do that, there are a few things that we want </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">to avoid:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.354.1">Implementation details such as </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">service implementation</span></span></li>
<li><span class="koboSpan" id="kobo.356.1">Specific </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">connection options</span></span></li>
<li><span class="koboSpan" id="kobo.358.1">Setting an IP address </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">as constant</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.360.1">We can solve these by not caring about the generated code anymore. </span><span class="koboSpan" id="kobo.360.2">It was just for testing our build system. </span><span class="koboSpan" id="kobo.360.3">Then, we will default to an insecure connection for testing. </span><span class="koboSpan" id="kobo.360.4">Finally, we will take the IP address as an argument for </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">our program.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Let us do that step </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">by step:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.364.1">We are first going to need to add the gRPC dependency to </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">server/go.mod</span></strong><span class="koboSpan" id="kobo.366.1">. </span><span class="koboSpan" id="kobo.366.2">So, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">server</span></strong><span class="koboSpan" id="kobo.368.1"> directory, we can type the </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.370.1">$ go get google.golang.org/grpc</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.371.1">Then, we are going to take the first argument passed to the program and return a usage message if no argument </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">is passed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.373.1">
args := os.Args[1:]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.374.1">
if len(args) == 0 {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.375.1">
  log.Fatalln("usage: server [IP_ADDR]")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.376.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.377.1">
addr := args[0]</span></pre></li>
<li><span class="koboSpan" id="kobo.378.1">After that, we need to listen for the incoming connection. </span><span class="koboSpan" id="kobo.378.2">We can do that with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">net.Listen</span></strong><span class="koboSpan" id="kobo.380.1"> provided in Go. </span><span class="koboSpan" id="kobo.380.2">This listener will need to be closed at the end of the program. </span><span class="koboSpan" id="kobo.380.3">This might be when a user kills it or if the server fails. </span><span class="koboSpan" id="kobo.380.4">And obviously, if</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.381.1"> we get an error during the construction of that listener, we just want the program to fai</span><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.382.1">l and let the </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">user know:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.384.1">
lis, err :</span><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.385.1">= net.L</span><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.386.1">isten("tcp", addr)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.387.1">
if err != nil {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.388.1">
  log.Fatalf("failed to listen: %v\n", err)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.389.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.390.1">
defer func(lis net.Listene</span><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.391.1">r) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.392.1">
  if err := lis.Close(); err != nil {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.393.1">
    log.Fatalf("unexpected error: %v", err)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.394.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.395.1">
}(lis)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.396.1">
log.Printf("listening at %s\n", addr)</span></pre></li>
<li><span class="koboSpan" id="kobo.397.1">Now, with all of this, we can start creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">grpc.Server</span></strong><span class="koboSpan" id="kobo.399.1">. </span><span class="koboSpan" id="kobo.399.2">We first need to define some connection options. </span><span class="koboSpan" id="kobo.399.3">As this is a template for future projects, we are going to keep the options empty. </span><span class="koboSpan" id="kobo.399.4">With this array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">grpc.ServerOption</span></strong><span class="koboSpan" id="kobo.401.1"> objects, we can create a new gRPC server. </span><span class="koboSpan" id="kobo.401.2">This is the server that we will use later to register endpoints. </span><span class="koboSpan" id="kobo.401.3">After that, we will need to close the server at some point, so we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">defer</span></strong><span class="koboSpan" id="kobo.403.1"> statement for that. </span><span class="koboSpan" id="kobo.403.2">Finally, we call a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Serve</span></strong><span class="koboSpan" id="kobo.405.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">grpc.Server</span></strong><span class="koboSpan" id="kobo.407.1"> that we created. </span><span class="koboSpan" id="kobo.407.2">This takes the listener as a parameter. </span><span class="koboSpan" id="kobo.407.3">It can fail, so if there is an error, we return that to </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">the client:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.409.1">
opts := []grpc.ServerOption{}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.410.1">
s := grpc.NewServer(opts...)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.411.1">
//registration of endpoints</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.412.1">
defer s.Stop()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.413.1">
if err := s.Serve(lis); err != nil {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
  log.Fatalf("failed to serve: %v\n", err)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.415.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.416.1">In the end, we </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.417.1">have the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">main</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.419.1">function (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">server</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
package main
import (
  "log"
  "net"
  "os"
  "google.golang.org/grpc"
)
func main() {
  args := os.Args[1:]
  if len(args) == 0 {
    log.Fatalln("usage: server [IP_ADDR]")
  }
  addr := args[0]
  lis, err := net.Listen("tcp", addr)
  if err != nil {
    log.Fatalf("failed to listen: %v\n", err)
  }
  defer f</span><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.425.1">unc(lis net.Listener</span><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.426.1">) {
    if err := lis.Close(); err != nil {
      log.Fatalf("unexpected error: %v", err)
    }
  }(lis)
  log.Printf("listening at %s\n", addr)
  opts := []grpc.ServerOption{}
  s := grpc.NewServer(opts...)
  //registration of endpoints
  defer s.Stop()
  if err := s.Serve(lis); err != nil {
    log.Fatalf("failed to serve: %v\n", err)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.427.1">We are now able to run our server by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">go run</span></strong><span class="koboSpan" id="kobo.429.1"> command on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">server/main.go</span></strong><span class="koboSpan" id="kobo.431.1">. </span><span class="koboSpan" id="kobo.431.2">We</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.432.1"> can terminate the execution by using </span><em class="italic"><span class="koboSpan" id="kobo.433.1">Ctrl</span></em><span class="koboSpan" id="kobo.434.1"> + </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.435.1">C</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.437.1">$ go run server/main.go 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.438.1">
listening at 0.0.0.0:50051</span></pre>
<h2 id="_idParaDest-81"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.439.1">Bazel</span></h2>
<p><span class="koboSpan" id="kobo.440.1">If you want</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.441.1"> to use Bazel, you will need a couple of extra steps. </span><span class="koboSpan" id="kobo.441.2">The </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.442.1">first step is to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">BUILD.bazel</span></strong><span class="koboSpan" id="kobo.444.1"> in our root directory. </span><span class="koboSpan" id="kobo.444.2">In there, we are going to use a Gazelle command that will detect all the dependencies needed for our project and dump them in a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">deps.bzl</span></strong><span class="koboSpan" id="kobo.446.1">. </span><span class="koboSpan" id="kobo.446.2">So, after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">gazelle</span></strong><span class="koboSpan" id="kobo.448.1"> command</span><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.449.1">, we can just add </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
gazelle(
  name = "gazelle-update-repos",
  args = [
    "-from_file=go.work",
    "-to_macro=deps.bzl%go_dependencies",
    "-prune",
  ],
  command = "update-repos",
)</span></pre>
<p><span class="koboSpan" id="kobo.452.1">Now, we ca</span><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.453.1">n run </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.455.1">$ bazel run //:gazelle-update-repos</span></strong></pre>
<p><span class="koboSpan" id="kobo.456.1">After it has finished detecting all the dependencies of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">server</span></strong><span class="koboSpan" id="kobo.458.1"> module, it will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">deps.bzl</span></strong><span class="koboSpan" id="kobo.460.1"> file and link it inside our </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">WORKSPACE.bazel</span></strong><span class="koboSpan" id="kobo.462.1">. </span><span class="koboSpan" id="kobo.462.2">You should have the foll</span><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.463.1">owing line in the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">workspace file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
load("//:deps.bzl", "go_dependencies")
# gazelle:repository_macro deps.bzl%go_dependencies
go_dependencies()</span></pre>
<p><span class="koboSpan" id="kobo.466.1">Finally, we</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.467.1"> can rerun our </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">gazelle</span></strong><span class="koboSpan" id="kobo.469.1"> command to make sure it creates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">BUILD.bazel</span></strong><span class="koboSpan" id="kobo.471.1"> file for our server. </span><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.472.1">We run </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.474.1">$ bazel run //:gazelle</span></strong></pre>
<p><span class="koboSpan" id="kobo.475.1">We then get </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.476.1">our </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">BUILD.bazel</span></strong><span class="koboSpan" id="kobo.478.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">server</span></strong><span class="koboSpan" id="kobo.480.1"> directory. </span><span class="koboSpan" id="kobo.480.2">The most important thing to note is that in this file, we can see Bazel linked gRPC to </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">server_lib</span></strong><span class="koboSpan" id="kobo.482.1">. </span><span class="koboSpan" id="kobo.482.2">We should have something </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
go_library(
  name = "server_lib",
  srcs = ["main.go"],
  deps = [
    </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">"@org_golang_google_grpc//:go_default_library",</span></strong><span class="koboSpan" id="kobo.486.1">
  ],
  #...
</span><span class="koboSpan" id="kobo.486.2">)</span></pre>
<p><span class="koboSpan" id="kobo.487.1">We can now run our</span><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.488.1"> server in an equivalent way as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">run</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.491.1"> command:</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.492.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.493.1">This command will pull Protobuf and build it. </span><span class="koboSpan" id="kobo.493.2">Recent Protobuf version require to be built with C++14 or newer. </span><span class="koboSpan" id="kobo.493.3">You can tell bazel to automatically specify the C++ version to build Protobuf with in a file called .bazelrc. </span><span class="koboSpan" id="kobo.493.4">In order to keep this chapter version-independent, we recommend you to check the .bazelrc file in the chapter4 of the Github repository. </span><span class="koboSpan" id="kobo.493.5">You can copy paste the file in your </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">project folder.</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.495.1">$ bazel run //server:server 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.496.1">
listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.497.1">And so, we are done with the server. </span><span class="koboSpan" id="kobo.497.2">This is a simple template that will let us create new servers pretty easily in the next chapters. </span><span class="koboSpan" id="kobo.497.3">It is listening on a given port and waiting for some requests. </span><span class="koboSpan" id="kobo.497.4">Now, in order to make it easy to carry out such requests, let us create a template for </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">the client.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.499.1">Client boilerplate</span></h1>
<p><span class="koboSpan" id="kobo.500.1">Let us now </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.501.1">write the client boilerplate. </span><span class="koboSpan" id="kobo.501.2">This will be very similar to writing the server boilerplate but instead of creating a listener on an IP and port, we are going to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">grpc.Dial</span></strong><span class="koboSpan" id="kobo.503.1"> function and pass the connection options </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Once again, we are not going to hardcode the address we are going to connect to. </span><span class="koboSpan" id="kobo.505.2">We are going to take that as </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">a parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
args := os.Args[1:]
if len(args) == 0 {
  log.Fatalln("usage: client [IP_ADDR]")
}
addr := args[0]</span></pre>
<p><span class="koboSpan" id="kobo.508.1">After that, we are going to create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">DialOption</span></strong><span class="koboSpan" id="kobo.510.1">, and to keep this boilerplate generic, we are going to make an insecure connection to the server with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">insecure.NewCredentials()</span></strong><span class="koboSpan" id="kobo.512.1"> function. </span><span class="koboSpan" id="kobo.512.2">Do not worry though; we will discuss h</span><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.513.1">ow to make secure </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">connections later:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.515.1">
opts := []grpc.DialOption{
  grpc.WithTransportCredentials(insecure.NewCredentials()),
}</span></pre>
<p><span class="koboSpan" id="kobo.516.1">Finally, we can just call for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">grpc.Dial</span></strong><span class="koboSpan" id="kobo.518.1"> function to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">grpc.ClientConn</span></strong><span class="koboSpan" id="kobo.520.1"> object. </span><span class="koboSpan" id="kobo.520.2">This is the object that we are going to need later to call the API endpoints. </span><span class="koboSpan" id="kobo.520.3">Lastly, this is a connection object, so at the end of our client’s lifet</span><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.521.1">ime, we are going to </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">close it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
conn,</span><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.524.1"> err := grpc.Dial(addr, opts...)
if err != nil {
  log.Fatalf("did not connect: %v", err)
}
defe</span><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.525.1">r func(conn *grpc.Cli</span><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.526.1">entConn) {
  if err := conn.Close(); err != nil {
    log.Fatalf("unexpected error: %v", err)
  }
}(conn)</span></pre>
<p><span class="koboSpan" id="kobo.527.1">That is </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.528.1">pretty much it for the client. </span><span class="koboSpan" id="kobo.528.2">The complete code is the </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">following (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">client/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.532.1">
package main
import (
  "log"
  "os"
  "google.golang.org/grpc"
  "google.golang.o</span><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.533.1">rg/grpc/credentials/insecure"
)
func main() {
  args := os.Args[1:]
  if len(args) == 0 {
    log.Fatalln("usage: client</span><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.534.1"> [IP_ADDR]")
  }
  addr := args[0]
  opts := []grpc.DialOption{
    grpc.WithTransportCredentials(in</span><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.535.1">secure.NewCredentials()),
  }
  conn, </span><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.536.1">err := grpc.Dial(addr, opts...)
  if err != nil {
    log.Fatalf("did not connect: %v", err)
  }
  defer</span><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.537.1"> func(conn *grpc.Clie</span><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.538.1">ntConn) {
    if err := conn.Close(); err != nil {
      log.Fatalf("unexpected error: %v", err)
    }
  }(conn)
}</span></pre>
<p><span class="koboSpan" id="kobo.539.1">Clearly, right now, it is</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.540.1"> not doing anything; however, we can test it by running our </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">server first:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.542.1">$ go run server/main.go 0.0.0.0:50051</span></strong></pre>
<p><span class="koboSpan" id="kobo.543.1">Then, we run </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">our client:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.545.1">$ go run client/main.go 0.0.0.0:50051</span></strong></pre>
<p><span class="koboSpan" id="kobo.546.1">The server </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.547.1">should wait infinitely and the client should be returning without any error on the terminal. </span><span class="koboSpan" id="kobo.547.2">If this is the case, you are ready to write some gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">API endpoints.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.549.1">Bazel</span></h2>
<p><span class="koboSpan" id="kobo.550.1">This time, Bazel’s setup </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.551.1">will not be as long as for the server. </span><span class="koboSpan" id="kobo.551.2">This is mostly because we already have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">deps.bzl</span></strong><span class="koboSpan" id="kobo.553.1"> file and we can reuse it for the client. </span><span class="koboSpan" id="kobo.553.2">All we need to do is use Gazelle to generate our </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">B</span><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.555.1">UILD.bazel</span></strong><span class="koboSpan" id="kobo.556.1"> and we </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">are done:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.558.1">$ bazel run //:gazelle</span></strong></pre>
<p><span class="koboSpan" id="kobo.559.1">We should now have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">BUILD.bazel</span></strong><span class="koboSpan" id="kobo.561.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">client</span></strong><span class="koboSpan" id="kobo.563.1"> directory. </span><span class="koboSpan" id="kobo.563.2">The most important thing to note is that in this file, we can see Bazel linked gRPC to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">client_lib</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">We should have something </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.567.1">
go_library(
  name = "client_lib",
  srcs = ["main.go"],
  deps = [
    </span><strong class="bold"><span class="koboSpan" id="kobo.568.1">"@org_golang_google_grpc//:go_default_library",</span></strong><span class="koboSpan" id="kobo.569.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.570.1">"@org_golang_google_grpc//credentials/insecure",</span></strong><span class="koboSpan" id="kobo.571.1">
  ],
  #...
</span><span class="koboSpan" id="kobo.571.2">)</span></pre>
<p><span class="koboSpan" id="kobo.572.1">We can now run our client in an equivalent way as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">run</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.576.1">
$ bazel run //client:client 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.577.1">We now have both our server and client. </span><span class="koboSpan" id="kobo.577.2">As of now, they do not do anything, but this is the intended purpose. </span><span class="koboSpan" id="kobo.577.3">Later in this book, by just copying them, we will be able to focus only on what matters, which </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.578.1">is the API. </span><span class="koboSpan" id="kobo.578.2">Before doing any of that though, let us have a quick look at some of the most important options for the server and </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">client setup.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.580.1">Server and Dial options</span></h1>
<p><span class="koboSpan" id="kobo.581.1">We touched </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.582.1">upon </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">ServerOption</span></strong><span class="koboSpan" id="kobo.584.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">DialOption</span></strong><span class="koboSpan" id="kobo.586.1"> briefly with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">grpc.ServerOption</span></strong><span class="koboSpan" id="kobo.588.1"> object and</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.589.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">grpc.WithTransportCredentials</span></strong><span class="koboSpan" id="kobo.591.1"> function. </span><span class="koboSpan" id="kobo.591.2">However, there are a lot of other options you can choose from. </span><span class="koboSpan" id="kobo.591.3">For readability’s sake, I will not go into detail about every one of them, but I want to present some major options that you will probably use. </span><span class="koboSpan" id="kobo.591.4">All </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">ServerOptions</span></strong><span class="koboSpan" id="kobo.593.1"> can be found at </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.594.1">the root of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">grpc-go</span></strong><span class="koboSpan" id="kobo.596.1"> repository in the file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">server.go</span></strong><span class="koboSpan" id="kobo.598.1"> (</span><a href="https://github.com/grpc/grpc-go/blob/master/server.go"><span class="koboSpan" id="kobo.599.1">https://github.com/grpc/grpc-go/blob/master/server.go</span></a><span class="koboSpan" id="kobo.600.1">) and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">DialOptions</span></strong><span class="koboSpan" id="kobo.602.1"> in the file </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.603.1">called </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">dialoptions.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1"> (</span></span><a href="https://github.com/grpc/grpc-go/blob/master/dialoptions.go"><span class="No-Break"><span class="koboSpan" id="kobo.606.1">https://github.com/grpc/grpc-go/blob/master/dialoptions.go</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.607.1">).</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.608.1">grpc.Creds</span></h2>
<p><span class="koboSpan" id="kobo.609.1">This is an option, on both the server and client sides, that we will use when we talk about securing APIs. </span><span class="koboSpan" id="kobo.609.2">For now, we saw that we can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">grpc.WithTransportCredentials</span></strong><span class="koboSpan" id="kobo.611.1"> with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">insecure.NewCredentials</span></strong><span class="koboSpan" id="kobo.613.1"> result, and this gives us an insecure connection. </span><span class="koboSpan" id="kobo.613.2">This means that none of the requests and responses are encrypted; anyone could intercept these messages and </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">read them.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">grpc.Creds</span></strong><span class="koboSpan" id="kobo.616.1"> lets </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.617.1">us provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">TransportCredentials</span></strong><span class="koboSpan" id="kobo.619.1"> object instance, which is a common interface for all the supported transport security protocols, such as TLS and SSL. </span><span class="koboSpan" id="kobo.619.2">If we had a certificate file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">server.crt</span></strong><span class="koboSpan" id="kobo.621.1"> and a key file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">server.pem</span></strong><span class="koboSpan" id="kobo.623.1">, we could create the </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">following </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">ServerOption</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
certFile </span><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.628.1">:= "server.crt"
keyFile := "server.pem"
creds, err := credentials.</span><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.629.1">NewServ</span><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.630.1">erTLSFromFile(certFile, keyFile)
if err != nil {
  log.Fatalf("fai</span><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.631.1">led loading certificates: %v\n", err)
}
opts = append(opts, grpc.Creds(creds))</span></pre>
<p><span class="koboSpan" id="kobo.632.1">Similarly, on the</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.633.1"> client side, we would have a </span><strong class="bold"><span class="koboSpan" id="kobo.634.1">Certificate Authority</span></strong><span class="koboSpan" id="kobo.635.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.636.1">CA</span></strong><span class="koboSpan" id="kobo.637.1">) certificate </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.638.1">and we would need to create the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">DialOptions</span></strong><span class="koboSpan" id="kobo.640.1"> to be able to communic</span><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.641.1">ate with </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">the server:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">
certFile := "ca.crt"
creds, err := crede</span><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.644.1">ntials.NewClientTLSFromFile(
  certFile, "")
if err != nil {
  log.Fatalf("error while loading</span><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.645.1"> CA trust certificate:
    %v\n", err)
}
opts = append(opts, grpc.WithTransportCredentials(creds))</span></pre>
<p><span class="koboSpan" id="kobo.646.1">As of now, you do not worry too much about that. </span><span class="koboSpan" id="kobo.646.2">As I mentioned, we will use this later and see how to get </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">the certificates.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.648.1">grpc.*Interceptor</span></h2>
<p><span class="koboSpan" id="kobo.649.1">If you are</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.650.1"> not familiar with interceptors, these are pieces of code that are called before or after handling a request (server side) or sending a request (client side). </span><span class="koboSpan" id="kobo.650.2">The goal is generally to enrich the request with some extra information, but it can also be used to log requests or deny certain requests if they do not have the right headers, </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">for example.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">We will see later how to define interceptors, but imagine that we have a piece of code logging our requests and another one checking that the authorization header is set. </span><span class="koboSpan" id="kobo.652.2">We could chain these</span><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.653.1"> interceptors on the server side </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.655.1">
 opts = append(opts, grpc.ChainUnaryInterceptor
  (LogInterceptor(), CheckHeaderInterceptor()))</span></pre>
<p><span class="koboSpan" id="kobo.656.1">Note that the </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.657.1">order of these interceptors is important because they will be called in the order provided in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">grpc.ChainUnaryInterceptor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">For the client side, we could have the same kind of log interceptor and another one adding the authorization header with a cached value of the token needed for authentication with the server. </span><span class="koboSpan" id="kobo.660.2">Th</span><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.661.1">is would give something like </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
opts = append(opts, grpc.WithChainUnaryInterceptor
  (LogInterceptor(), AddHeaderInterceptor()))</span></pre>
<p><span class="koboSpan" id="kobo.664.1">Finally, note that you can use other functions to add these interceptors. </span><span class="koboSpan" id="kobo.664.2">Here are the </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">other ones:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">WithUnaryInterceptor</span></strong><span class="koboSpan" id="kobo.667.1"> to set one unary </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">RPC interceptor</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">WithStreamInterceptor</span></strong><span class="koboSpan" id="kobo.670.1"> to set one stream </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">RPC interceptor</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">WithChainStreamInterceptor</span></strong><span class="koboSpan" id="kobo.673.1"> to chain multiple stream </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">RPC interceptors</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.675.1">We saw two important options that are configurable on both the server and client sides. </span><span class="koboSpan" id="kobo.675.2">By using credentials, we can secure our communication between the communication actors, and by using interceptors, we can run arbitrary code before sending or receiving requests. </span><span class="koboSpan" id="kobo.675.3">Obviously, we just saw two options and there are many more on both sides. </span><span class="koboSpan" id="kobo.675.4">If you are interested in checking out all of them, I invite you to go to the GitHub repository linked at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">this section.</span></span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.677.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.678.1">In this chapter, we created templates for our future servers and clients. </span><span class="koboSpan" id="kobo.678.2">The goal was to write the boilerplate code and set up our build so that we can generate code and run our </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">Go applications.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">We saw that we can use protoc manually to generate Go code and use it with our application. </span><span class="koboSpan" id="kobo.680.2">We then saw that we can make the process a little bit smoother by using Buf to generate the code for us. </span><span class="koboSpan" id="kobo.680.3">Finally, we saw that we can use Bazel to both generate our code and run our application in a </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">single step.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">Finally, we saw that we can use multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">ServerOptions</span></strong><span class="koboSpan" id="kobo.684.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">DialOptions</span></strong><span class="koboSpan" id="kobo.686.1"> to tweak the server and client. </span><span class="koboSpan" id="kobo.686.2">We mostly looked at </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">grpc.Creds</span></strong><span class="koboSpan" id="kobo.688.1"> and interceptors, but there are a lot more options that we can check in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">grpc-go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.690.1"> repository.</span></span></p>
<p><span class="koboSpan" id="kobo.691.1">In the next chapter, we will see how to write each type of API provided in gRPC. </span><span class="koboSpan" id="kobo.691.2">We will start with unary APIs, then check server and client streaming APIs, and finally, see how to write bidirectional </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">streaming endpoints.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.693.1">Quiz</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.694.1">What is the advantage of using </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">protoc manually?</span></span><ol><li><span class="koboSpan" id="kobo.696.1">No setup needed; you only need to </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">install protoc.</span></span></li><li><span class="koboSpan" id="kobo.698.1">Shorter </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">generation commands.</span></span></li><li><span class="koboSpan" id="kobo.700.1">We can both generate Go code and run </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">the application.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.702.1">What is the advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">using Buf?</span></span><ol><li><span class="koboSpan" id="kobo.704.1">No setup needed; you only need to </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">install protoc.</span></span></li><li><span class="koboSpan" id="kobo.706.1">Shorter </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">generation commands.</span></span></li><li><span class="koboSpan" id="kobo.708.1">We can both generate Go code and run </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">the application.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.710.1">What is the advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">using Bazel?</span></span><ol><li><span class="koboSpan" id="kobo.712.1">No setup needed; you only need to </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">install protoc.</span></span></li><li><span class="koboSpan" id="kobo.714.1">Shorter </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">generation commands.</span></span></li><li><span class="koboSpan" id="kobo.716.1">We can both generate Go code and run </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">the application.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.718.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">an interceptor?</span></span><ol><li><span class="koboSpan" id="kobo.720.1">An external piece of code that intercepts the payload of </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">the communication</span></span></li><li><span class="koboSpan" id="kobo.722.1">A piece of code that runs in the </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">server handler</span></span></li><li><span class="koboSpan" id="kobo.724.1">A piece of code that runs before or after handling or sending </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">a request</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-89"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.726.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.727.1">A</span></li>
<li><span class="koboSpan" id="kobo.728.1">B</span></li>
<li><span class="koboSpan" id="kobo.729.1">C</span></li>
<li><span class="koboSpan" id="kobo.730.1">C</span></li>
</ol>
</div>
</body></html>