["```go\nmessage DummyMessage {}\n```", "```go\nservice DummyService {}\n```", "```go\n.\n├── client\n│   └── go.mod\n├── go.work\n├── proto\n│   ├── dummy\n│   │   └── v1\n│   │       └── dummy.proto\n│   └── go.mod\n└── server\n    └── go.mod\n```", "```go\n$ go mod init github.com/github.com/PacktPublishing/\ngRPC-Go-for-Professionals/\n$FOLDER_NAME\n```", "```go\n$ find . -maxdepth 1 -type d -not -path . -execdir sh -c \"pushd {}; go\nmod init 'github.com/PacktPublishing/\ngRPC-Go-for-Professionals/{}';\npopd\" \";\"\n```", "```go\n$ Get-ChildItem . -Name -Directory | ForEach-Object { Push-\nLocation $_; go mod init \"github.com/PacktPublishing/\ngRPC-Go-for-Professionals/$_\" ;\nPop-Location }\n```", "```go\n$ go work init client server proto\n```", "```go\ngo 1.20\nuse (\n  ./client\n  ./proto\n  ./server\n)\n```", "```go\nmodule $MODULE_NAME/$SUBMODULE_NAME\ngo 1.20\n```", "```go\nmodule github.com/PacktPublishing/gRPC-Go-for-Professionals/client\ngo 1.20\n```", "```go\noption go_package = \"github.com/PacktPublishing/\ngRPC-Go-for-Professionals/\nproto/dummy/v1\";\n```", "```go\nsyntax = \"proto3\";\noption go_package = \"github.com/PacktPublishing/\ngRPC-Go-for-Professionals/proto/dummy/v1\";\nmessage DummyMessage {}\nservice DummyService {}\n```", "```go\n$ protoc --go_out=. \\\n         --go_opt=module=github.com/PacktPublishing/\n                 gRPC-Go-for-Professionals \\\n         --go-grpc_out=. \\\n         --go-grpc_opt=module=github.com/PacktPublishing/\n                  gRPC-Go-for-Professionals \\\n         proto/dummy/v1/dummy.proto\n```", "```go\noption go_package = \"github.com/PacktPublishing/\ngRPC-Go-for-Professionals/proto/dummy/v1\";\n```", "```go\n$ buf mod init\n```", "```go\nversion: v1\nplugins:\n  - plugin: go\n    out: proto\n    opt: paths=source_relative\n  - plugin: go-grpc\n    out: proto\n    opt: paths=source_relative\n```", "```go\n$ protoc --go_out=. \\\n         --go_opt=paths=source_relative \\\n         --go-grpc_out=. \\\n         --go-grpc_opt=paths=source_relative \\\n         proto/dummy/v1/dummy.proto\n```", "```go\n$ buf generate proto\n```", "```go\nworkspace(name = \"github_com_packtpublishing_grpc_go_for_\nprofessionals\")\nload(\"//:versions.bzl\",\n  \"GO_VERSION\",\n  \"RULES_GO_VERSION\",\n  \"RULES_GO_SHA256\",\n  \"GAZELLE_VERSION\",\n  \"GAZELLE_SHA256\",\n  \"PROTO_VERSION\"\n)\nload(\"@bazel_tools//tools/build_defs/repo:http.bzl\",\n  \"http_archive\")\nload(\"@bazel_tools//tools/build_defs/repo:git.bzl\",\n  \"git_repository\")\n```", "```go\nhttp_archive(\n  name = \"bazel_gazelle\",\n  sha256 = GAZELLE_SHA256,\n  urls = [\n    \"https://mirror.bazel.build/github.com/bazelbuild/\n    bazel-gazelle/releases/download/%s/bazel-gazelle-\n    %s.tar.gz\" % (GAZELLE_VERSION, GAZELLE_VERSION),\n    \"https://github.com/bazelbuild/bazel-gazelle/\n    releases/download/%s/bazel-gazelle-%s.tar.gz\" %\n    (GAZELLE_VERSION, GAZELLE_VERSION),\n  ],\n)\n```", "```go\nhttp_archive(\n  name = \"io_bazel_rules_go\",\n  sha256 = RULES_GO_SHA256,\n  urls = [\n    \"https://mirror.bazel.build/github.com/bazelbuild/\n    rules_go/releases/download/%s/rules_go-%s.zip\" %\n    (RULES_GO_VERSION, RULES_GO_VERSION),\n    \"https://github.com/bazelbuild/rules_go/releases/\n    download/%s/rules_go-%s.zip\" % (RULES_GO_VERSION,\n    RULES_GO_VERSION),\n  ],\n)\n```", "```go\nload(\"@io_bazel_rules_go//go:deps.bzl\",\n  \"go_register_toolchains\", \"go_rules_dependencies\")\nload(\"@bazel_gazelle//:deps.bzl\", \"gazelle_dependencies\")\ngo_rules_dependencies()\ngo_register_toolchains(version = GO_VERSION)\ngazelle_dependencies(go_repository_default_config =\n  \"//:WORKSPACE.bazel\")\n```", "```go\ngit_repository(\n  name = \"com_google_protobuf\",\n  tag = PROTO_VERSION,\n  remote = \"https://github.com/protocolbuffers/protobuf\"\n)\nload(\"@com_google_protobuf//:protobuf_deps.bzl\",\n  \"protobuf_deps\")\nprotobuf_deps()\n```", "```go\nload(\"@bazel_gazelle//:def.bzl\", \"gazelle\")\n# gazelle:exclude proto/**/*.go\n# gazelle:prefix github.com/PacktPublishing/gRPC-Go-for-Professionals\ngazelle(name = \"gazelle\")\n```", "```go\n$ bazel run //:gazelle\n```", "```go\ngo_library(\n  name = \"dummy\",\n  embed = [\":v1_go_proto\"],\n  importpath = \"github.com/PacktPublishing/gRPC-Go-for-\n    Professionals/proto/dummy/v1\",\n  visibility = [\"//visibility:public\"],\n)\n```", "```go\n    $ go get google.golang.org/grpc\n    ```", "```go\n    args := os.Args[1:]\n    ```", "```go\n    if len(args) == 0 {\n    ```", "```go\n      log.Fatalln(\"usage: server [IP_ADDR]\")\n    ```", "```go\n    }\n    ```", "```go\n    addr := args[0]\n    ```", "```go\n    lis, err := net.Listen(\"tcp\", addr)\n    ```", "```go\n    if err != nil {\n    ```", "```go\n      log.Fatalf(\"failed to listen: %v\\n\", err)\n    ```", "```go\n    }\n    ```", "```go\n    defer func(lis net.Listener) {\n    ```", "```go\n      if err := lis.Close(); err != nil {\n    ```", "```go\n        log.Fatalf(\"unexpected error: %v\", err)\n    ```", "```go\n      }\n    ```", "```go\n    }(lis)\n    ```", "```go\n    log.Printf(\"listening at %s\\n\", addr)\n    ```", "```go\n    opts := []grpc.ServerOption{}\n    ```", "```go\n    s := grpc.NewServer(opts...)\n    ```", "```go\n    //registration of endpoints\n    ```", "```go\n    defer s.Stop()\n    ```", "```go\n    if err := s.Serve(lis); err != nil {\n    ```", "```go\n      log.Fatalf(\"failed to serve: %v\\n\", err)\n    ```", "```go\n    }\n    ```", "```go\npackage main\nimport (\n  \"log\"\n  \"net\"\n  \"os\"\n  \"google.golang.org/grpc\"\n)\nfunc main() {\n  args := os.Args[1:]\n  if len(args) == 0 {\n    log.Fatalln(\"usage: server [IP_ADDR]\")\n  }\n  addr := args[0]\n  lis, err := net.Listen(\"tcp\", addr)\n  if err != nil {\n    log.Fatalf(\"failed to listen: %v\\n\", err)\n  }\n  defer func(lis net.Listener) {\n    if err := lis.Close(); err != nil {\n      log.Fatalf(\"unexpected error: %v\", err)\n    }\n  }(lis)\n  log.Printf(\"listening at %s\\n\", addr)\n  opts := []grpc.ServerOption{}\n  s := grpc.NewServer(opts...)\n  //registration of endpoints\n  defer s.Stop()\n  if err := s.Serve(lis); err != nil {\n    log.Fatalf(\"failed to serve: %v\\n\", err)\n  }\n}\n```", "```go\n$ go run server/main.go 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\ngazelle(\n  name = \"gazelle-update-repos\",\n  args = [\n    \"-from_file=go.work\",\n    \"-to_macro=deps.bzl%go_dependencies\",\n    \"-prune\",\n  ],\n  command = \"update-repos\",\n)\n```", "```go\n$ bazel run //:gazelle-update-repos\n```", "```go\nload(\"//:deps.bzl\", \"go_dependencies\")\n# gazelle:repository_macro deps.bzl%go_dependencies\ngo_dependencies()\n```", "```go\n$ bazel run //:gazelle\n```", "```go\ngo_library(\n  name = \"server_lib\",\n  srcs = [\"main.go\"],\n  deps = [\n    \"@org_golang_google_grpc//:go_default_library\",\n  ],\n  #...\n)\n```", "```go\n$ bazel run //server:server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\nargs := os.Args[1:]\nif len(args) == 0 {\n  log.Fatalln(\"usage: client [IP_ADDR]\")\n}\naddr := args[0]\n```", "```go\nopts := []grpc.DialOption{\n  grpc.WithTransportCredentials(insecure.NewCredentials()),\n}\n```", "```go\nconn, err := grpc.Dial(addr, opts...)\nif err != nil {\n  log.Fatalf(\"did not connect: %v\", err)\n}\ndefer func(conn *grpc.ClientConn) {\n  if err := conn.Close(); err != nil {\n    log.Fatalf(\"unexpected error: %v\", err)\n  }\n}(conn)\n```", "```go\npackage main\nimport (\n  \"log\"\n  \"os\"\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/insecure\"\n)\nfunc main() {\n  args := os.Args[1:]\n  if len(args) == 0 {\n    log.Fatalln(\"usage: client [IP_ADDR]\")\n  }\n  addr := args[0]\n  opts := []grpc.DialOption{\n    grpc.WithTransportCredentials(insecure.NewCredentials()),\n  }\n  conn, err := grpc.Dial(addr, opts...)\n  if err != nil {\n    log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer func(conn *grpc.ClientConn) {\n    if err := conn.Close(); err != nil {\n      log.Fatalf(\"unexpected error: %v\", err)\n    }\n  }(conn)\n}\n```", "```go\n$ go run server/main.go 0.0.0.0:50051\n```", "```go\n$ go run client/main.go 0.0.0.0:50051\n```", "```go\n$ bazel run //:gazelle\n```", "```go\ngo_library(\n  name = \"client_lib\",\n  srcs = [\"main.go\"],\n  deps = [\n    \"@org_golang_google_grpc//:go_default_library\",\n    \"@org_golang_google_grpc//credentials/insecure\",\n  ],\n  #...\n)\n```", "```go\n$ bazel run //client:client 0.0.0.0:50051\n```", "```go\ncertFile := \"server.crt\"\nkeyFile := \"server.pem\"\ncreds, err := credentials.NewServerTLSFromFile(certFile, keyFile)\nif err != nil {\n  log.Fatalf(\"failed loading certificates: %v\\n\", err)\n}\nopts = append(opts, grpc.Creds(creds))\n```", "```go\ncertFile := \"ca.crt\"\ncreds, err := credentials.NewClientTLSFromFile(\n  certFile, \"\")\nif err != nil {\n  log.Fatalf(\"error while loading CA trust certificate:\n    %v\\n\", err)\n}\nopts = append(opts, grpc.WithTransportCredentials(creds))\n```", "```go\n opts = append(opts, grpc.ChainUnaryInterceptor\n  (LogInterceptor(), CheckHeaderInterceptor()))\n```", "```go\nopts = append(opts, grpc.WithChainUnaryInterceptor\n  (LogInterceptor(), AddHeaderInterceptor()))\n```"]