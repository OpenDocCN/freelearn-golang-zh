- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up a Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the chapter title suggests, we are going to set up a gRPC project from scratch.
    We are first going to create our Protobuf schema as we are doing schema-driven
    development. Once the schema is created, we will generate Go code. Finally, we
    are going to write the templates for the server and client so that we can reuse
    them later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Common gRPC project architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating Go code out of a schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing reusable server/client templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume that you already have protoc installed from the last chapter. If you
    do not, this is the right time to install it because without it, you will not
    benefit as much from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will show common ways of setting up a gRPC project. I will
    use protoc, Buf, and Bazel. Thus, depending on the one(s) you are interested in,
    you will have to download the tool(s). Buf is an abstraction over protoc that
    lets us run protoc commands more easily. On top of that, it provides features
    such as linting and detecting breaking changes. You can download Buf from here:
    [https://docs.buf.build/installation](https://docs.buf.build/installation). I
    will also use Bazel to automatically generate Go code from Protobuf and the binary
    of our server and client. If you are interested in using it, you can check the
    installation documentation ([https://github.com/bazelbuild/bazelisk#installation](https://github.com/bazelbuild/bazelisk#installation)).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can find the code for this chapter under the `chapter4` folder
    in the accompanying GitHub repository ([https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .proto file definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the goal of this chapter is to write a template that we can use for later
    projects, we are going to create a dummy proto file that will let us test whether
    our build system is working properly or not. This dummy proto file will contain
    both a message and a service because we want to test code generation for both
    Protobuf and gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message, called `DummyMessage`, will be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The service, called `DummyService`, will be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, because we are planning to generate Golang code, we still need to define
    an option called `go_package` and set its value to the name of the Go module concatenated
    with the name of the subfolder containing the proto files. This option is important
    because it lets us define the package in which the generated code should be. In
    our case, the project architecture is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a monorepo (Go workspace) with three submodules: `client`, `proto`,
    and `server`. We create each submodule by going into each folder and running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`$FOLDER_NAME` should be replaced with the name of the folder you are currently
    in (`client`, `proto`, or `server`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the process a little bit quicker, we can create a command that will
    list the folder in the `root` directory and execute the `go` command. To do so,
    you can use the following UNIX (Linux/macOS) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are on Windows, you can use PowerShell to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can create the workspace file. We do so by going to the root
    of the project (`chapter4`) and running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the following `go.work`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each submodule has the following `go.mod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ll replace `$MODULE_NAME` with a URL such as `github.com/PacktPublishing/gRPC-Go-for-Professionals`
    and `$SUBMODULE_NAME`, with the respective name of the folder containing the file.
    In the case of `go.mod` in the client, we will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can complete `dummy.proto` by adding the following line to our
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the following `dummy.proto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That is all we need to test the code generation out of our `dummy.proto`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Go code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To stay impartial in terms of the tools you need to generate code, I will present
    three different tools from the lowest level to the highest. We are going to start
    by seeing how to manually generate code with protoc. Then, because we do not want
    to write lengthy command lines all the time, we are going to see how to make this
    generation easier with Buf. Finally, we are going to see how to use Bazel to integrate
    the code generation as part of our build.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I’m going to show basic ways of compiling your proto files.
    Most of the time, these commands will get you by, but sometimes you might have
    to check each tool’s documentation. For protoc, you can run `protoc --help` and
    get a list of the options. For Buf, you can go to the online documentation: [https://docs.buf.build/installation](https://docs.buf.build/installation).
    For Bazel, you also have online documentation at [https://bazel.build/reference/be/protocol-buffer](https://bazel.build/reference/be/protocol-buffer).'
  prefs: []
  type: TYPE_NORMAL
- en: Protoc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using protoc is the manual way of generating code out of proto files. This technique
    might be fine if you are only dealing with a few proto files and you do not have
    a lot of dependencies between files (imports). Otherwise, this will be quite painful,
    as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: However, I still believe that we should learn the protoc command a bit so that
    we get a sense of what we can do with it. Also, higher-level tools are based on
    protoc, so this will help us understand its different features.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `dummy.proto` file from the previous section, we can run protoc in
    the root folder (`chapter4`) like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, this might look a bit scary and, in fact, is not the shortest command that
    you could write to do this. I am going to show you a more compact one when we
    talk about Buf. But first, let us dissect the preceding command into parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before discussing `--go_out` and `--go-grpc_out`, let us look at `--go_opt=module`
    and `--go-grpc_opt=module`. These options are telling protoc about the common
    module to be stripped out by the value passed for the `go_package` option in our
    `proto` file. Say we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then, -`-go_opt=module=github.com/PacktPublishing/gRPC-Go-for-Professionals`
    will strip the value after `module=` from our `go_package`, so now we only have
    `/proto/dummy/v1`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand this, we can get to `--go_out` and `--go-grpc_out`. These
    two options tell protoc where to generate the Go code. In our case, it seems that
    we are telling protoc to generate our code at the root level, but in fact, because
    it is combined with the two previous options, it will generate the code right
    next to the proto file. This is due to the stripping of the package, which leads
    protoc to generate the code in the folder `/``proto/dummy/v1` package.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can see how painful it might be to write that kind of command all the
    time. Most people do not do that. They either write a script to do it automatically
    or use other tools, such as Buf.
  prefs: []
  type: TYPE_NORMAL
- en: Buf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Buf, we have a little bit more setup to do to generate code. At the root
    of the project (`chapter4`), we are going to create a Buf module. To do that,
    we can simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This creates a file called `buf.yaml`. This file is where you can set project-level
    options such as linting or even tracking breaking changes. These are beyond the
    scope of this book, but if you are interested in this tool, check out the documentation
    ([https://buf.build/docs/tutorials/getting-started-with-buf-cli/](https://buf.build/docs/tutorials/getting-started-with-buf-cli/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have that, we need to write the configuration for generation. In a
    file called `buf.gen.yaml`, we will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining the use of the Go plugin for Protobuf and gRPC. For each,
    we are saying that we want to generate the code in the `proto` directory, and
    we are using another `--go_opt` and `--go-grpc_opt` for protoc, which is `paths=source_relative`.
    When this is set, the generated code is placed in the same directory as the input
    file (`dummy.proto`). So, in the end, Buf is running something like what we did
    in the protoc section. It is running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run generation using Buf, we simply need to run the following command
    (in chapter4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using Buf is pretty common for mid-size or large projects. It helps with automation
    of code generation and is easy to get started with. However, you might have noticed
    that you need to generate the code in one step and then build your Go application.
    Bazel will help us consolidate everything in one step.
  prefs: []
  type: TYPE_NORMAL
- en: Bazel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I will be using variables called `GO_VERSION`, `RULES_GO_VERSION`,
    `RULES_GO_SHA256`, `GAZELLE_VERSION`, `GAZELLE_SHA256`, and `PROTO_VERSION`. We
    have not included these variables in this section to ensure that the book remains
    easily updated. You can find the versions in the `versions.bzl` file in the `chapter4`
    folder ([https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4](https://github.com/PacktPublishing/Implementing-gRPC-in-Golang-Microservice/tree/main/chapter4)).
  prefs: []
  type: TYPE_NORMAL
- en: Bazel is a little bit trickier to set up, but it is worth the effort. Once you
    have your build system up and running, you will be able to build the whole application
    (generation and build) and/or run it in one command.
  prefs: []
  type: TYPE_NORMAL
- en: In Bazel, we start by defining a file called `WORKSPACE.bazel` at the root level.
    In this file, we define all the dependencies for our project. In our case, we
    have dependencies on Protobuf and Go. On top of that, we are also going to add
    a dependency to Gazelle, which will help us create the `BUILD.bazel` file needed
    to generate our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in `WORKSPACE.bazel`, before anything else, we are going to define our
    workspace name, import our version variables, and import some utilities to clone
    Git repositories and download archives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we are going to define the dependency for Gazelle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to pull the dependency for building Go binaries, applications,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have that, we can pull the dependencies of `rules_go`, set the
    toolchain for building the Go project, and tell Gazelle where to find our `WORKSPACE.bazel`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we pull the dependency for Protobuf and load its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our `WORKSPACE.bazel` is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now move to `BUILD.bazel` at the root level. In this file, we are going
    to define the command to run Gazelle, and we are going to let Gazelle know the
    Go module name and that we want it to not consider the Go files in the `proto`
    directory. We do so because otherwise, Gazelle would think that the Go file in
    the `proto` directory should also have its own Bazel target file and this might
    create problems down the road:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we can now run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you have installed Bazel through Bazelisk, Bazel will try to get its newest
    version each time you run a bazel command. In order to avoid this, you can create
    a file called .bazelversion containing the version of bazel you currently have
    installed. You can find the version by typing
  prefs: []
  type: TYPE_NORMAL
- en: '**bazel --version**'
  prefs: []
  type: TYPE_NORMAL
- en: An example can be found in the chapter4 folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the dependencies are pulled up and compiled, you should be able to see
    a `BUILD.bazel` file generated in the `proto/dummy/v1` directory. The most important
    part of this file is the following `go_library`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Later, we will use this library and link it to our binary. It contains all the
    generated code that we need to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Server boilerplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our build system is ready. We can now focus on the code. But before going into
    that, let us define what we want. In this section, we want to build a template
    for the gRPC server that we can reuse for later chapters and even later projects
    outside of the book. To do that, there are a few things that we want to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation details such as service implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific connection options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting an IP address as constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can solve these by not caring about the generated code anymore. It was just
    for testing our build system. Then, we will default to an insecure connection
    for testing. Finally, we will take the IP address as an argument for our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us do that step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are first going to need to add the gRPC dependency to `server/go.mod`. So,
    in the `server` directory, we can type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we are going to take the first argument passed to the program and return
    a usage message if no argument is passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we need to listen for the incoming connection. We can do that with
    the `net.Listen` provided in Go. This listener will need to be closed at the end
    of the program. This might be when a user kills it or if the server fails. And
    obviously, if we get an error during the construction of that listener, we just
    want the program to fail and let the user know:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, with all of this, we can start creating a `grpc.Server`. We first need
    to define some connection options. As this is a template for future projects,
    we are going to keep the options empty. With this array of `grpc.ServerOption`
    objects, we can create a new gRPC server. This is the server that we will use
    later to register endpoints. After that, we will need to close the server at some
    point, so we use a `defer` statement for that. Finally, we call a function called
    `Serve` on the `grpc.Server` that we created. This takes the listener as a parameter.
    It can fail, so if there is an error, we return that to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the end, we have the following `main` function (`server`/`main.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now able to run our server by running the `go run` command on our `server/main.go`.
    We can terminate the execution by using *Ctrl* + *C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Bazel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to use Bazel, you will need a couple of extra steps. The first
    step is to update the `BUILD.bazel` in our root directory. In there, we are going
    to use a Gazelle command that will detect all the dependencies needed for our
    project and dump them in a file called `deps.bzl`. So, after the `gazelle` command,
    we can just add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After it has finished detecting all the dependencies of the `server` module,
    it will create a `deps.bzl` file and link it inside our `WORKSPACE.bazel`. You
    should have the following line in the workspace file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can rerun our `gazelle` command to make sure it creates the `BUILD.bazel`
    file for our server. We run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get our `BUILD.bazel` in the `server` directory. The most important
    thing to note is that in this file, we can see Bazel linked gRPC to `server_lib`.
    We should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run our server in an equivalent way as the `go` `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This command will pull Protobuf and build it. Recent Protobuf version require
    to be built with C++14 or newer. You can tell bazel to automatically specify the
    C++ version to build Protobuf with in a file called .bazelrc. In order to keep
    this chapter version-independent, we recommend you to check the .bazelrc file
    in the chapter4 of the Github repository. You can copy paste the file in your
    project folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: And so, we are done with the server. This is a simple template that will let
    us create new servers pretty easily in the next chapters. It is listening on a
    given port and waiting for some requests. Now, in order to make it easy to carry
    out such requests, let us create a template for the client.
  prefs: []
  type: TYPE_NORMAL
- en: Client boilerplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now write the client boilerplate. This will be very similar to writing
    the server boilerplate but instead of creating a listener on an IP and port, we
    are going to call the `grpc.Dial` function and pass the connection options to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we are not going to hardcode the address we are going to connect
    to. We are going to take that as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we are going to create an instance of `DialOption`, and to keep
    this boilerplate generic, we are going to make an insecure connection to the server
    with the `insecure.NewCredentials()` function. Do not worry though; we will discuss
    how to make secure connections later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can just call for the `grpc.Dial` function to create a `grpc.ClientConn`
    object. This is the object that we are going to need later to call the API endpoints.
    Lastly, this is a connection object, so at the end of our client’s lifetime, we
    are going to close it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'That is pretty much it for the client. The complete code is the following (`client/main.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, right now, it is not doing anything; however, we can test it by running
    our server first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we run our client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The server should wait infinitely and the client should be returning without
    any error on the terminal. If this is the case, you are ready to write some gRPC
    API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Bazel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time, Bazel’s setup will not be as long as for the server. This is mostly
    because we already have the `deps.bzl` file and we can reuse it for the client.
    All we need to do is use Gazelle to generate our `BUILD.bazel` and we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now have a `BUILD.bazel` in the `client` directory. The most important
    thing to note is that in this file, we can see Bazel linked gRPC to the `client_lib`.
    We should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run our client in an equivalent way as the `go` `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We now have both our server and client. As of now, they do not do anything,
    but this is the intended purpose. Later in this book, by just copying them, we
    will be able to focus only on what matters, which is the API. Before doing any
    of that though, let us have a quick look at some of the most important options
    for the server and client setup.
  prefs: []
  type: TYPE_NORMAL
- en: Server and Dial options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched upon `ServerOption` and `DialOption` briefly with the `grpc.ServerOption`
    object and the `grpc.WithTransportCredentials` function. However, there are a
    lot of other options you can choose from. For readability’s sake, I will not go
    into detail about every one of them, but I want to present some major options
    that you will probably use. All `ServerOptions` can be found at the root of the
    `grpc-go` repository in the file called `server.go` ([https://github.com/grpc/grpc-go/blob/master/server.go](https://github.com/grpc/grpc-go/blob/master/server.go))
    and the `DialOptions` in the file called `dialoptions.go` ([https://github.com/grpc/grpc-go/blob/master/dialoptions.go](https://github.com/grpc/grpc-go/blob/master/dialoptions.go)).
  prefs: []
  type: TYPE_NORMAL
- en: grpc.Creds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an option, on both the server and client sides, that we will use when
    we talk about securing APIs. For now, we saw that we can call `grpc.WithTransportCredentials`
    with an `insecure.NewCredentials` result, and this gives us an insecure connection.
    This means that none of the requests and responses are encrypted; anyone could
    intercept these messages and read them.
  prefs: []
  type: TYPE_NORMAL
- en: '`grpc.Creds` lets us provide a `TransportCredentials` object instance, which
    is a common interface for all the supported transport security protocols, such
    as TLS and SSL. If we had a certificate file called `server.crt` and a key file
    called `server.pem`, we could create the following `ServerOption`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, on the client side, we would have a `DialOptions` to be able to
    communicate with the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As of now, you do not worry too much about that. As I mentioned, we will use
    this later and see how to get the certificates.
  prefs: []
  type: TYPE_NORMAL
- en: grpc.*Interceptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are not familiar with interceptors, these are pieces of code that are
    called before or after handling a request (server side) or sending a request (client
    side). The goal is generally to enrich the request with some extra information,
    but it can also be used to log requests or deny certain requests if they do not
    have the right headers, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see later how to define interceptors, but imagine that we have a piece
    of code logging our requests and another one checking that the authorization header
    is set. We could chain these interceptors on the server side like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order of these interceptors is important because they will be
    called in the order provided in the `grpc.ChainUnaryInterceptor` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the client side, we could have the same kind of log interceptor and another
    one adding the authorization header with a cached value of the token needed for
    authentication with the server. This would give something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, note that you can use other functions to add these interceptors. Here
    are the other ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WithUnaryInterceptor` to set one unary RPC interceptor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WithStreamInterceptor` to set one stream RPC interceptor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WithChainStreamInterceptor` to chain multiple stream RPC interceptors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw two important options that are configurable on both the server and client
    sides. By using credentials, we can secure our communication between the communication
    actors, and by using interceptors, we can run arbitrary code before sending or
    receiving requests. Obviously, we just saw two options and there are many more
    on both sides. If you are interested in checking out all of them, I invite you
    to go to the GitHub repository linked at the beginning of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created templates for our future servers and clients. The
    goal was to write the boilerplate code and set up our build so that we can generate
    code and run our Go applications.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that we can use protoc manually to generate Go code and use it with our
    application. We then saw that we can make the process a little bit smoother by
    using Buf to generate the code for us. Finally, we saw that we can use Bazel to
    both generate our code and run our application in a single step.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw that we can use multiple `ServerOptions` and `DialOptions` to
    tweak the server and client. We mostly looked at `grpc.Creds` and interceptors,
    but there are a lot more options that we can check in the `grpc-go` repository.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to write each type of API provided in gRPC.
    We will start with unary APIs, then check server and client streaming APIs, and
    finally, see how to write bidirectional streaming endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the advantage of using protoc manually?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No setup needed; you only need to install protoc.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Shorter generation commands.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We can both generate Go code and run the application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of using Buf?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No setup needed; you only need to install protoc.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Shorter generation commands.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We can both generate Go code and run the application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of using Bazel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No setup needed; you only need to install protoc.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Shorter generation commands.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We can both generate Go code and run the application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an interceptor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An external piece of code that intercepts the payload of the communication
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A piece of code that runs in the server handler
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A piece of code that runs before or after handling or sending a request
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
