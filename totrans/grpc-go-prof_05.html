<html><head></head><body>
<div id="_idContainer021">
<h1 class="chapter-number" id="_idParaDest-90"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-91"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.2.1">Types of gRPC Endpoints</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we are going to see the different types of gRPC endpoints that you can write. </span><span class="koboSpan" id="kobo.3.2">For each of the endpoints, we are going to understand what the idea behind the type of communication we are talking about is, and we are going to define an RPC endpoint in our Protobuf service. </span><span class="koboSpan" id="kobo.3.3">Finally, we are going to implement that endpoint and write a client to consume the endpoint. </span><span class="koboSpan" id="kobo.3.4">At the end of this chapter, the goal is to implement a TODO API that will let us create, update, delete, and list the tasks in our </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">TODO list.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">What the four types of RPC endpoints you can </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">write are</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">When to use each </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">of them</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">How to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">endpoint’s logic</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">How to consume a </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">gRPC endpoint</span></span></li>
</ul>
<h1 id="_idParaDest-92"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">You can find the code for this chapter in the folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">chapter5</span></strong><span class="koboSpan" id="kobo.18.1"> in the companion repo for this book </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">at </span></span><a href="https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter5"><span class="No-Break"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter5</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.21.1">.</span></span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.22.1">Using the template</span></h1>
<p class="callout-heading"><span class="koboSpan" id="kobo.23.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.24.1">This section is only necessary if you want to work with the same architecture as the github repository. </span><span class="koboSpan" id="kobo.24.2">Continuing working on the code from the previous code is </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">totally fine.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">If you remember, the goal of the previous chapter</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.27.1"> was to create a template that we can use to create a new gRPC project. </span><span class="koboSpan" id="kobo.27.2">As we will start such a project now, we will need to copy the content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">chapter4</span></strong><span class="koboSpan" id="kobo.29.1"> folder into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">chapter5</span></strong><span class="koboSpan" id="kobo.31.1"> folder. </span><span class="koboSpan" id="kobo.31.2">To do that, simply run the </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">following commands:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.33.1">
$ mkdir chapter5
$ cp -R chapter4/* chapter5</span></pre>
<p><span class="koboSpan" id="kobo.34.1">We pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">–R</span></strong><span class="koboSpan" id="kobo.36.1"> in our case because we want to recursively copy all the files in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">chapter4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.38.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">And finally, we can also clean the template a little bit. </span><span class="koboSpan" id="kobo.39.2">We can remove the dummy directory in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">proto</span></strong><span class="koboSpan" id="kobo.41.1"> folder because this was just there for testing our code generation. </span><span class="koboSpan" id="kobo.41.2">Then, if you used </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">bazel</span></strong><span class="koboSpan" id="kobo.43.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">chapter4</span></strong><span class="koboSpan" id="kobo.45.1">, we can delete all the build folders that start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">bazel-</span></strong><span class="koboSpan" id="kobo.47.1"> prefix. </span><span class="koboSpan" id="kobo.47.2">To do that, we can just simply remove them </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.49.1">
$ cd chapter5
$ rm -rf proto/dummy
$ rm -rf bazel-*</span></pre>
<p><span class="koboSpan" id="kobo.50.1">We are now ready to use this template</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.51.1"> and see the different API endpoints that we can write </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">with gRPC.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.53.1">A Unary API</span></h1>
<p class="callout-heading"><span class="koboSpan" id="kobo.54.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.55.1">In terms of the underlying</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.56.1"> protocol, as we mentioned in </span><a href="B19664_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.58.1">, </span><em class="italic"><span class="koboSpan" id="kobo.59.1">Networking Primer</span></em><span class="koboSpan" id="kobo.60.1">, the Unary API uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">Send Header</span></strong><span class="koboSpan" id="kobo.62.1"> followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">Send Message</span></strong><span class="koboSpan" id="kobo.64.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">Half-Close</span></strong><span class="koboSpan" id="kobo.66.1"> from the client side, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">Send Message</span></strong><span class="koboSpan" id="kobo.68.1"> plus </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">Send Trailer</span></strong><span class="koboSpan" id="kobo.70.1"> from the server side. </span><span class="koboSpan" id="kobo.70.2">If you need a refresher on these operations, I recommend you quickly check the </span><em class="italic"><span class="koboSpan" id="kobo.71.1">RPC operations</span></em><span class="koboSpan" id="kobo.72.1"> section in </span><a href="B19664_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.73.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.74.1"> of this book. </span><span class="koboSpan" id="kobo.74.2">This will help get a sense of what is going on when you are calling this </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">API endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">The easiest and most familiar API endpoint that you can write is a unary endpoint. </span><span class="koboSpan" id="kobo.76.2">These roughly translate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">GET</span></strong><span class="koboSpan" id="kobo.78.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">POST</span></strong><span class="koboSpan" id="kobo.80.1">, and other HTTP verbs that you probably worked with in REST APIs. </span><span class="koboSpan" id="kobo.80.2">You send a request and you get a response. </span><span class="koboSpan" id="kobo.80.3">Generally, these endpoints will be the ones that you use the most often to represent the treatment of one resource. </span><span class="koboSpan" id="kobo.80.4">For example, if you write a login method, you just need to send </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">LoginRequest</span></strong><span class="koboSpan" id="kobo.82.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">receive </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">LoginResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">For this section, we are going to write an RPC</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.87.1"> endpoint called </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">AddTask</span></strong><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">As its name suggests, this endpoint will create a new task in the list. </span><span class="koboSpan" id="kobo.89.3">So before being able</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.90.1"> to do that, we need to define what a </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.91.1">task</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.92.1"> is.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">A task is an object that contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">following</span></span><span class="No-Break"><a id="_idIndexMarker185"/></span><span class="No-Break"><span class="koboSpan" id="kobo.95.1"> properties:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">id</span></strong><span class="koboSpan" id="kobo.97.1">: A number that is an identifier of </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">that task</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">description</span></strong><span class="koboSpan" id="kobo.100.1">: The actual task to be done and that the </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">user reads</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">done</span></strong><span class="koboSpan" id="kobo.103.1">: Whether or not the task is </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">already done</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">due_date</span></strong><span class="koboSpan" id="kobo.106.1">: When this task </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">is due</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.108.1">And if we translate that to Protobuf code, we would have something like the following (the file in </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">chapter5/proto/todo/v1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.110.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">todo.proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.113.1">
syntax = "proto3";
package todo.v1;
import "google/protobuf/timestamp.proto";
option go_package = "github.com/PacktPublishing/
  gRPC-Go-for-Professionals/proto/todo/v1";
message Task {
  uint64 id = 1;
  string description = 2;
  bool done = 3;
  </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">google.protobuf.Timestamp</span></strong><span class="koboSpan" id="kobo.115.1"> due_date = 4;
}</span></pre>
<p><span class="koboSpan" id="kobo.116.1">Notice the use of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">Timestamp</span></strong><span class="koboSpan" id="kobo.118.1"> type here. </span><span class="koboSpan" id="kobo.118.2">This is a well-known type</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.119.1"> that is provided with Protobuf under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">google.protobuf</span></strong><span class="koboSpan" id="kobo.121.1"> package. </span><span class="koboSpan" id="kobo.121.2">We are using this type to represent a point in time in the future at which the task should be completed. </span><span class="koboSpan" id="kobo.121.3">We could have rewritten our own </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Date</span></strong><span class="koboSpan" id="kobo.123.1"> type or used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Date</span></strong><span class="koboSpan" id="kobo.125.1"> type defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">googleapis</span></strong><span class="koboSpan" id="kobo.127.1"> repository (</span><a href="https://github.com/googleapis/googleapis/blob/master/google/type/date.proto"><span class="koboSpan" id="kobo.128.1">https://github.com/googleapis/googleapis/blob/master/google/type/date.proto</span></a><span class="koboSpan" id="kobo.129.1">) but </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">Timestamp</span></strong><span class="koboSpan" id="kobo.131.1"> is sufficient for </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">this API.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">Now that we have our task, we can think about our RPC endpoint. </span><span class="koboSpan" id="kobo.133.2">We want our endpoint to receive a task, which should be inserted into the list, and to return the identifier for that task to </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">the client:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.135.1">
message AddTaskRequest {
  string description = 1;
  google.protobuf.Timestamp due_date = 2;
}
message AddTaskResponse {
  uint64 id = 1;
}
service TodoService {
  rpc AddTask(AddTaskRequest) returns (AddTaskResponse);
}</span></pre>
<p><span class="koboSpan" id="kobo.136.1">One important thing to notice here is that instead of using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">Task</span></strong><span class="koboSpan" id="kobo.138.1"> message as the parameter for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">AddTask</span></strong><span class="koboSpan" id="kobo.140.1"> endpoint, we created a wrapper (</span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">AddTaskRequest</span></strong><span class="koboSpan" id="kobo.142.1">) around the necessary pieces of information for the endpoint. </span><span class="koboSpan" id="kobo.142.2">Nothing more, nothing less. </span><span class="koboSpan" id="kobo.142.3">We could have used the message directly but this may have led the client to send unnecessary data over the wire (e.g., setting the ID, which would be overlooked by the server). </span><span class="koboSpan" id="kobo.142.4">Furthermore, for future versions of our API, we could add more fields to </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">AddTaskRequest</span></strong><span class="koboSpan" id="kobo.144.1"> without affecting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">Task</span></strong><span class="koboSpan" id="kobo.146.1"> message. </span><span class="koboSpan" id="kobo.146.2">We effectively decouple</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.147.1"> the actual data representation for the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">request/response representation.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.149.1">Code generation</span></h2>
<p class="callout-heading"><span class="koboSpan" id="kobo.150.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.151.1">If you are unsure by now on how to generate code</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.152.1"> out of a proto file, I highly recommend that you check </span><a href="B19664_04.xhtml#_idTextAnchor136"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.153.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.154.1">, where we presented three methods for doing that. </span><span class="koboSpan" id="kobo.154.2">In this chapter, we are going to generate everything manually, but you can find how to do the same with Buf and Bazel in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">chapter5</span></strong><span class="koboSpan" id="kobo.156.1"> folder of the </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Now that we have created the interface for our API endpoint, we want to be able to implement the logic behind it. </span><span class="koboSpan" id="kobo.158.2">The first step to do that is to generate some Go code. </span><span class="koboSpan" id="kobo.158.3">To do that, we are going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">protoc</span></strong><span class="koboSpan" id="kobo.160.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">source_relative</span></strong><span class="koboSpan" id="kobo.162.1"> value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">paths</span></strong><span class="koboSpan" id="kobo.164.1"> option. </span><span class="koboSpan" id="kobo.164.2">So, knowing that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">todo.proto</span></strong><span class="koboSpan" id="kobo.166.1"> file is under </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">proto/todo/v1/</span></strong><span class="koboSpan" id="kobo.168.1">, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
$ protoc --go_out=. </span><span class="koboSpan" id="kobo.170.2">\
         --go_opt=paths=source_relative \
         --go-grpc_out=. </span><span class="koboSpan" id="kobo.170.3">\
         --go-grpc_opt=paths=source_relative \
           proto/todo/v1/*.proto</span></pre>
<p><span class="koboSpan" id="kobo.171.1">After running that, you should have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">proto/todo/v1/</span></strong><span class="koboSpan" id="kobo.173.1"> directory like </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
proto/todo/v1/
├── todo.pb.go
├── todo.proto
└── todo_grpc.pb.go</span></pre>
<p><span class="koboSpan" id="kobo.176.1">That is all we need to </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">get started.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.178.1">Inspecting the generated code</span></h2>
<p><span class="koboSpan" id="kobo.179.1">In the generated code, we have</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.180.1"> two files – the Protobuf-generated code and the gRPC code. </span><span class="koboSpan" id="kobo.180.2">The Protobuf-generated code is in a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">todo.pb.go</span></strong><span class="koboSpan" id="kobo.182.1">. </span><span class="koboSpan" id="kobo.182.2">If we inspect this file, the most important thing that we can see is the following code (which </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">is simplified):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
type Task struct {
  Id uint64
  Description string
  Done bool
  DueDate *timestamppb.Timestamp
}
type AddTaskRequest struct {
  Description string
  DueDate *timestamppb.Timestamp
}
type AddTaskResponse struct {
  Id uint64
}</span></pre>
<p><span class="koboSpan" id="kobo.185.1">This means we can now create </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Task</span></strong><span class="koboSpan" id="kobo.187.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">TaskRequest</span></strong><span class="koboSpan" id="kobo.189.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">TaskResponse</span></strong><span class="koboSpan" id="kobo.191.1"> instances in our Go code, and that is exactly what we will do later in </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">For the gRPC-generated code (</span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">todo_grpc.pb.go</span></strong><span class="koboSpan" id="kobo.195.1">), there are interfaces generated for both the client and the server. </span><span class="koboSpan" id="kobo.195.2">They should look like </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
type TodoServiceClient interface {
  AddTask(ctx context.Context, in *AddTaskRequest, opts
    ...grpc.CallOption) (*AddTaskResponse, error)
}
type TodoServiceServer interface {
  AddTask(context.Context, *AddTaskRequest)
    (*AddTaskResponse, error)
  mustEmbedUnimplementedTodoServiceServer()
}</span></pre>
<p><span class="koboSpan" id="kobo.198.1">They look similar, but the server-side </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">AddTask</span></strong><span class="koboSpan" id="kobo.200.1"> is the only one that we need to implement the logic for. </span><span class="koboSpan" id="kobo.200.2">The client-side </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">AddTask</span></strong><span class="koboSpan" id="kobo.202.1"> basically generates the request for calling the API endpoint </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.203.1">on our server and returning us the response that </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">it received.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.205.1">Registering a service</span></h2>
<p><span class="koboSpan" id="kobo.206.1">To let gRPC know how to handle</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.207.1"> a certain request, we need to register the implementation of a service. </span><span class="koboSpan" id="kobo.207.2">To register such a service, we are going to call a generated function, which is present in </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">todo_grpc.pb.go</span></strong><span class="koboSpan" id="kobo.209.1">. </span><span class="koboSpan" id="kobo.209.2">In our case, this function is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">RegisterTodoServiceServer</span></strong><span class="koboSpan" id="kobo.211.1"> and its function signature is </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
func RegisterTodoServiceServer(s grpc.ServiceRegistrar, srv
  TodoServiceServer)</span></pre>
<p><span class="koboSpan" id="kobo.214.1">It takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">grpc.ServiceRegistrar</span></strong><span class="koboSpan" id="kobo.216.1">, which is an interface that </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">grpc.Server</span></strong><span class="koboSpan" id="kobo.218.1"> implements, and takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">TodoServiceServer</span></strong><span class="koboSpan" id="kobo.220.1">, which is the interface that we saw earlier. </span><span class="koboSpan" id="kobo.220.2">This function will link the generic gRPC server provided by the framework with our implementation of the endpoints so that the framework knows how to </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">handle requests.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">So, the first thing</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.223.1"> to do is to create our server. </span><span class="koboSpan" id="kobo.223.2">We are first going to create a struct that embeds </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">UnimplementedTodoServiceServer</span></strong><span class="koboSpan" id="kobo.225.1">, which is a generated struct that contains the default implementation of the endpoints. </span><span class="koboSpan" id="kobo.225.2">In our case, the default implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
func (UnimplementedTodoServiceServer) AddTask
  (context.Context, *AddTaskRequest) (*AddTaskResponse,
    error) {
  return nil, status.Errorf(codes.Unimplemented, "method
    AddTask not implemented")
}</span></pre>
<p><span class="koboSpan" id="kobo.228.1">If we do not implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">AddTask</span></strong><span class="koboSpan" id="kobo.230.1"> in our server, this endpoint will be called, and it will return an error every time we call it. </span><span class="koboSpan" id="kobo.230.2">Right now, that does not seem useful because this does nothing other than return an error, but the fact is that this is a safety net, and we are going to see why when we talk about evolving </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">our APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">Next, our server will contain a reference to our database. </span><span class="koboSpan" id="kobo.232.2">You can adapt this to use any database you are familiar with, but in our case, we are going to abstract the database away with an interface because this will let us focus on gRPC and not on another technology such as, for </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">example, MongoDB.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">So, our server type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">server/server.go</span></strong><span class="koboSpan" id="kobo.236.1">) will look </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
package main
import (
  pb "github.com/PacktPublishing/gRPC-Go-for-Professionals/proto/    todo</span><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.239.1">/v1"
)
type server struct {
  d db
  pb.UnimplementedTodoServiceServer
}</span></pre>
<p><span class="koboSpan" id="kobo.240.1">Now, let us see what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">db</span></strong><span class="koboSpan" id="kobo.242.1"> interface looks like. </span><span class="koboSpan" id="kobo.242.2">We are going to first have a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">addTask</span></strong><span class="koboSpan" id="kobo.244.1">, which takes a description and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">dueDate</span></strong><span class="koboSpan" id="kobo.246.1"> value and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">id</span></strong><span class="koboSpan" id="kobo.248.1"> value for the task created or an error. </span><span class="koboSpan" id="kobo.248.2">Now, the important thing to note is that this database interface should be decoupled from the generated code. </span><span class="koboSpan" id="kobo.248.3">This is, once again, due to the evolution of our API because if we were to change our endpoints or </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Request</span></strong><span class="koboSpan" id="kobo.250.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Response</span></strong><span class="koboSpan" id="kobo.252.1"> objects, we would have to change our interface and all the implementations. </span><span class="koboSpan" id="kobo.252.2">Here, the interface is independent of the generated code. </span><span class="koboSpan" id="kobo.252.3">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">server/db.go</span></strong><span class="koboSpan" id="kobo.254.1">, we can now write </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
package main
import "time"
type db interface {
  addTask(description string, dueDate time.Time) (uint64,
    error)
}</span></pre>
<p><span class="koboSpan" id="kobo.257.1">This interface will let us test</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.258.1"> against fake database implementations and implement an in-memory database for </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">non-release environments.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">The last step is to implement the in-memory database. </span><span class="koboSpan" id="kobo.260.2">We are going to have a regular array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Task</span></strong><span class="koboSpan" id="kobo.262.1"> storing our to-dos and </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">addTask</span></strong><span class="koboSpan" id="kobo.264.1"> will simply append a task to that array and return the ID of the current task. </span><span class="koboSpan" id="kobo.264.2">In a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">server/in_memory.go</span></strong><span class="koboSpan" id="kobo.266.1">, we can add </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
package main
import (
  "time"
  pb "github.com/PacktPublishing/gRPC-Go-for-Professionals/
    proto/todo/v1"
  "google.golang.org/protobuf/types/known/timestamppb"
)
type inMemoryDb str</span><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.269.1">uct {
  tasks []*pb.</span><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.270.1">Task
}
func New() db {
  return &amp;inMemoryDb{}
}
func (d *inMemoryDb) addTask(description string, dueDate
  time.Time) (uint64, error) {
  nextId := uint64(len(d.</span><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.271.1">tasks) + 1)
  task := &amp;pb.Task{
    Id: nextId,
    Description: description,
    DueDate: timestamppb.New(dueDate),
  }
</span><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.272.1">
  d.tasks = append(d.tasks, task)
  return nextId, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.273.1">There are a few things to note</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.274.1"> about this implementation. </span><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.275.1">First, this is probably obvious, but this is not an optimal “database” and is only used for development purposes. </span><span class="koboSpan" id="kobo.275.2">Second, without going into too much detail, we could use Golang build tags to choose the database we wanted to run at compile time. </span><span class="koboSpan" id="kobo.275.3">For example, if we had our </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">inMemoryDb</span></strong><span class="koboSpan" id="kobo.277.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">mongoDb</span></strong><span class="koboSpan" id="kobo.279.1"> implementation, we could have </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">go:build</span></strong><span class="koboSpan" id="kobo.281.1"> tags at the top of each file. </span><span class="koboSpan" id="kobo.281.2">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">in_memory.go</span></strong><span class="koboSpan" id="kobo.283.1">, we could have </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
//go:build in_memory_db
//...
</span><span class="koboSpan" id="kobo.285.2">type inMemoryD</span><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.286.1">b struct
func New() db</span></pre>
<p><span class="koboSpan" id="kobo.287.1">And for </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">mongodb.go</span></strong><span class="koboSpan" id="kobo.289.1">, we could </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">have this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
//go:build mongodb
//...
</span><span class="koboSpan" id="kobo.291.2">type mongoD</span><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.292.1">b struct
func New() db</span></pre>
<p><span class="koboSpan" id="kobo.293.1">This would let us select at comp</span><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.294.1">ile time which </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">New</span></strong><span class="koboSpan" id="kobo.296.1"> function we wanted to use and thus create either an </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">inMemoryDb</span></strong><span class="koboSpan" id="kobo.298.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">mongoDb</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Finally, you might have noticed that we are using the generated code in the implementation of this “database.” </span><span class="koboSpan" id="kobo.301.2">As this is a “database” that we use as a dev environment, it does not really matter if this implementation is coupled with our generated code. </span><span class="koboSpan" id="kobo.301.3">The most important thing is to not couple the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">db</span></strong><span class="koboSpan" id="kobo.303.1"> interface with it so that you can use any database without even having to deal with the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">generated code.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Now, we are finally ready to register our server type. </span><span class="koboSpan" id="kobo.305.2">To do that, we can just go into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">server/main.go main</span></strong><span class="koboSpan" id="kobo.307.1"> function and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">following line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.309.1">
import pb "github.com/PacktPublishing/gRPC-Go-for-Professionals/
    proto/</span><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.310.1">todo/v1"
//...
</span><span class="koboSpan" id="kobo.310.2">s := grpc.NewServer(opts...)
</span><strong class="bold"><span class="koboSpan" id="kobo.311.1">pb.RegisterTodoSer</span><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.312.1">viceServer(s,</span><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.313.1"> &amp;server{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.314.1">  d: New(),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.315.1">})</span></strong><span class="koboSpan" id="kobo.316.1">
defer s.Stop()</span></pre>
<p><span class="koboSpan" id="kobo.317.1">This means that we have now linked the gRPC server called </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">s</span></strong><span class="koboSpan" id="kobo.319.1"> to the server instance created.</span><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.320.1"> Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">New</span></strong><span class="koboSpan" id="kobo.322.1"> function</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.323.1"> here is the function that we defined inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">in_memory.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1"> file.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.326.1">Implementing AddTask</span></h2>
<p><span class="koboSpan" id="kobo.327.1">For the implementation, we are going</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.328.1"> to create</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.329.1"> a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">server/impl.go</span></strong><span class="koboSpan" id="kobo.331.1"> that will contain the implementation of all our endpoints. </span><span class="koboSpan" id="kobo.331.2">Note that this is purely for convenience and that you could have a file per </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">RPC endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">Now, as you might remember, the generated interface for our server wants us to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">following function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.335.1">
AddTask(context.Context, *AddTaskRequest)
  (*AddTaskResponse, error)</span></pre>
<p><span class="koboSpan" id="kobo.336.1">So, we can just add that function to our server type by writing the function preface with the name of the server instance and the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">server type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">(s *server)</span></strong><span class="koboSpan" id="kobo.340.1"> AddTask(_ context.Context, in
  *pb.AddTaskRequest) (*pb.AddTaskResponse, error) {
}</span></pre>
<p><span class="koboSpan" id="kobo.341.1">And finally, we can implement </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.342.1">the function. </span><span class="koboSpan" id="kobo.342.2">This will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">addTask</span></strong><span class="koboSpan" id="kobo.344.1"> function</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.345.1"> from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">db</span></strong><span class="koboSpan" id="kobo.347.1"> interface, and as this never returns errors (for now), we are going to take the given ID and return that </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">AddTaskResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
package main
import (
  "context"
  pb "github.com/PacktPublishing/gRPC-Go-for-Professionals/proto/    todo/v1"
)
func (s *server) AddTask(_ context.Context, in
  *pb.AddTaskRequest) (*pb.AddTaskRespo</span><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.352.1">nse, error) {
  id, _ := s.d.addTask(in.Description, in.DueDate.AsTime())
  return &amp;pb.AddTa</span><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.353.1">skResponse{Id: id}, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.354.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">AsTime</span></strong><span class="koboSpan" id="kobo.356.1"> is a function provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">google.golang.org/protobuf/types/known/timestamppb</span></strong><span class="koboSpan" id="kobo.358.1"> package, which returns a Golang </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">time.Time</span></strong><span class="koboSpan" id="kobo.360.1"> object. </span><span class="koboSpan" id="kobo.360.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">timestamppb</span></strong><span class="koboSpan" id="kobo.362.1"> package is a collection of functions that lets us manipulate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">google.protobuf.Timestamp</span></strong><span class="koboSpan" id="kobo.364.1"> object and use it in an idiomatic way in our </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">Go code.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">Right now, you might feel that this</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.367.1"> is too simplistic but remember</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.368.1"> that we are just at the beginning of our API. </span><span class="koboSpan" id="kobo.368.2">Later in the book, we will do error handling and see how to reject </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">incorrect arguments.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.370.1">Calling AddTask from a client</span></h2>
<p><span class="koboSpan" id="kobo.371.1">Finally, let us see how to call</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.372.1"> the endpoint from Go client code. </span><span class="koboSpan" id="kobo.372.2">This is simple</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.373.1"> since we already have the boilerplate that we created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">previous chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">We will create a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">AddTask</span></strong><span class="koboSpan" id="kobo.377.1">, which will call the API endpoint that we registered in the server. </span><span class="koboSpan" id="kobo.377.2">To do so, we are going to need to pass an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">TodoServiceClient</span></strong><span class="koboSpan" id="kobo.379.1">, a description of the task, and a due date. </span><span class="koboSpan" id="kobo.379.2">We will create the client instance later but note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">TodoServiceClient</span></strong><span class="koboSpan" id="kobo.381.1"> is the interface that we saw when we inspected the generated code. </span><span class="koboSpan" id="kobo.381.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">client/main.go</span></strong><span class="koboSpan" id="kobo.383.1">, we can add </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
import  (
  //...
</span><span class="koboSpan" id="kobo.385.2">  google.golang.org/protobuf/types/known/timestamppb
  pb "github.com/PacktPublishing/gRPC-Go-for-Professionals/
  proto/todo/v1"
  //...
</span><span class="koboSpan" id="kobo.385.3">)
func addTask(c pb.TodoServiceClient, description string,
  dueDate time.Time) uint64 {
}</span></pre>
<p><span class="koboSpan" id="kobo.386.1">After that, with the parameters, we can just construct a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">AddTaskRequest</span></strong><span class="koboSpan" id="kobo.388.1"> and send it to </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">the server.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
func addTask(c pb.TodoServiceClient, description string,
  dueDat</span><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.391.1">e time.Time) uint64 {
  req := &amp;pb.AddTaskRequest{
    Description: description,
    DueDate: timestamppb.N</span><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.392.1">ew(dueDate),
  }
  res, err := c.AddTask(context.Background(), req)
  //...
</span><span class="koboSpan" id="kobo.392.2">}</span></pre>
<p><span class="koboSpan" id="kobo.393.1">Finally, we will receive</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.394.1"> either an </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">AddTaskResponse</span></strong><span class="koboSpan" id="kobo.396.1"> or an error</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.397.1"> from our API call. </span><span class="koboSpan" id="kobo.397.2">If there is an error, we log that on the screen, and if there is not, we log and return </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the ID:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
func addTask(c pb.TodoServiceClient, description string,
  dueDate time.Ti</span><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.400.1">me) uin</span><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.401.1">t64 {
  //...
</span><span class="koboSpan" id="kobo.401.2">  if err != nil {
    panic(err)
  }
  fmt.Printf("added task: %d\n", res.Id)
  return res.Id
}</span></pre>
<p><span class="koboSpan" id="kobo.402.1">To call this function, we need</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.403.1"> to use a generated</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.404.1"> function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">NewTodoServiceClient</span></strong><span class="koboSpan" id="kobo.406.1">, to which we pass a connection, and it returns a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">TodoServiceClient</span></strong><span class="koboSpan" id="kobo.408.1">. </span><span class="koboSpan" id="kobo.408.2">And with that, we can simply add the following lines to the end of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">main</span></strong><span class="koboSpan" id="kobo.410.1"> fu</span><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.411.1">nction in </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">the client:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
conn, err := g</span><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.414.1">rpc.Dia</span><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.415.1">l(addr, opts...)
if err != nil {
  log.Fatalf("d</span><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.416.1">id not connect: %v", err)
}
</span><strong class="bold"><span class="koboSpan" id="kobo.417.1">c := pb.NewTodoServiceClient(conn)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.418.1">fmt.Println("--------ADD---</span><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.419.1">-----")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.420.1">dueDate := time.Now().Add(5 * time.Second)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.421.1">addTask(c, "This is a task", dueDate)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.422.1">fmt.Println("-------------------")</span></strong><span class="koboSpan" id="kobo.423.1">
defer func(conn</span><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.424.1"> *grpc.ClientConn) {
  /*...*/}(conn)</span></pre>
<p><span class="koboSpan" id="kobo.425.1">Note that here we are adding a task with a five-second due date and a description of </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">This is a task</span></strong><span class="koboSpan" id="kobo.427.1">. </span><span class="koboSpan" id="kobo.427.2">This is just an example and I encourage you to try to make more calls by yourself with </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">di</span><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.429.1">fferent values.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Now, we can basically run our server and client and see how they are interacting. </span><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.431.1">To run the server, use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">run</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.434.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
$ go run ./server 0.0.0.0:50051
listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.436.1">And then, on another termina</span><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.437.1">l, we can run the cl</span><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.438.1">ient in a </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">similar way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
$ go run ./client 0.0.0.0:50051
--------ADD--------
added task: 1
-------------------</span></pre>
<p><span class="koboSpan" id="kobo.441.1">And finally, to kill the server, you can just press </span><em class="italic"><span class="koboSpan" id="kobo.442.1">Ctrl + C</span></em><span class="koboSpan" id="kobo.443.1"> in the terminal </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">running it.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">So, we can see that we have a service implementation</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.446.1"> registered to our server, and our client</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.447.1"> is correctly sending a request and getting a response back. </span><span class="koboSpan" id="kobo.447.2">What we made is a simple example of a Unary </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">API endpoint.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.449.1">Bazel</span></h2>
<p class="callout-heading"><span class="koboSpan" id="kobo.450.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.451.1">In this section, we will see how to run an application with Bazel. </span><span class="koboSpan" id="kobo.451.2">However, because it would become repetitive if every section had such an explanation, I wanted to warn you that we will not go through these steps each time. </span><span class="koboSpan" id="kobo.451.3">For each section, you can run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">bazel run</span></strong><span class="koboSpan" id="kobo.453.1"> commands (for the server and client) that you will see under, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">gazelle</span></strong><span class="koboSpan" id="kobo.455.1"> command should be useful only for </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">At this</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.458.1"> poi</span><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.459.1">nt, your Bazel BUILD files</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.460.1"> are probably out of date. </span><span class="koboSpan" id="kobo.460.2">To synchronize them, we can simply run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">gazelle</span></strong><span class="koboSpan" id="kobo.462.1"> command and it will update all our dependencies and files </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">to compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
$ bazel run //:gazelle</span></pre>
<p><span class="koboSpan" id="kobo.465.1">After that, we should be able to run the server and client easily by running this command to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">the server:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
$ bazel run //server:server 0.0.0.0:50051
listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.468.1">Meanwhile, use the following to run </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">the client:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
$ bazel run //client:client 0.0.0.0:50051
--------ADD--------
added task: 1
-------------------</span></pre>
<p><span class="koboSpan" id="kobo.471.1">This is anothe</span><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.472.1">r example</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.473.1"> of how our server</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.474.1"> and client are working proper</span><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.475.1">ly. </span><span class="koboSpan" id="kobo.475.2">We can run them with both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">go run</span></strong><span class="koboSpan" id="kobo.477.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">bazel run</span></strong><span class="koboSpan" id="kobo.479.1"> commands. </span><span class="koboSpan" id="kobo.479.2">We are now confident with the Unary API; let us move to the server </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">streaming API.</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.481.1">The server streaming API</span></h1>
<p class="callout-heading"><span class="koboSpan" id="kobo.482.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.483.1">In terms of the underlying</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.484.1"> protocol, the server streaming API uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">Send Header</span></strong><span class="koboSpan" id="kobo.486.1"> followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">Send Message</span></strong><span class="koboSpan" id="kobo.488.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">Half-Close</span></strong><span class="koboSpan" id="kobo.490.1"> from the client side, and multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Send Message</span></strong><span class="koboSpan" id="kobo.492.1"> plus </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">Send Trailer</span></strong><span class="koboSpan" id="kobo.494.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">server side.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">Now, that we know how to register a service, interact with a “database,” and run our client and server, everything will be faster. </span><span class="koboSpan" id="kobo.496.2">We will focus mostly on the API endpoint itself. </span><span class="koboSpan" id="kobo.496.3">In our case, we are going to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">ListTasks</span></strong><span class="koboSpan" id="kobo.498.1"> endpoint, which, as its name suggests, lists all the available tasks in </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">One thing that we are going to do to make this a little bit fancier is that for each task listed, we are going to return whether this task is overdue or not. </span><span class="koboSpan" id="kobo.500.2">This is mostly done so that you can see how to provide more information about a certain object in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">response</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">So, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">todo.proto</span></strong><span class="koboSpan" id="kobo.505.1"> file, we are going to add an RPC endpoint called </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">ListTasks</span></strong><span class="koboSpan" id="kobo.507.1">, which will take </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">ListTasksRequest</span></strong><span class="koboSpan" id="kobo.509.1"> and return a stream of </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">ListTasksResponse</span></strong><span class="koboSpan" id="kobo.511.1">. </span><span class="koboSpan" id="kobo.511.2">This is what a server streaming API is. </span><span class="koboSpan" id="kobo.511.3">We get one request and return zero or </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">more responses:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.513.1">
message ListTasksRequest {
}
message ListTasksResponse {
  Task task = 1;
  bool overdue = 2;
}
service TodoService {
  //...
</span><span class="koboSpan" id="kobo.513.2">  rpc ListTasks(ListTasksRequest) returns (</span><strong class="bold"><span class="koboSpan" id="kobo.514.1">stream</span></strong><span class="koboSpan" id="kobo.515.1"> ListTasksResponse);
}</span></pre>
<p><span class="koboSpan" id="kobo.516.1">Note that this time, we send an empty object</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.517.1"> as a request, and we get multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">Task</span></strong><span class="koboSpan" id="kobo.519.1"> and whether they are overdue. </span><span class="koboSpan" id="kobo.519.2">We could make the request a bit more intelligent by sending a range of IDs of tasks we want to list (paging), but for the sake of conciseness, we have chosen to make </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">it simple.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.521.1">Evolving the database</span></h2>
<p><span class="koboSpan" id="kobo.522.1">Before being</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.523.1"> able to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">ListTasks</span></strong><span class="koboSpan" id="kobo.525.1"> endpoint, we need a way to access all the elements in our TODO list. </span><span class="koboSpan" id="kobo.525.2">Once again, we do not want to tie the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">db</span></strong><span class="koboSpan" id="kobo.527.1"> interface to our generated code, so we have a </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">few choices:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.529.1">We create some abstractions to iterate over the tasks. </span><span class="koboSpan" id="kobo.529.2">This might be fine for our in-memory database, but how would this work with Postgres, </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">for example?</span></span></li>
<li><span class="koboSpan" id="kobo.531.1">We tie our interface to an already existing abstraction such as cursors for databases. </span><span class="koboSpan" id="kobo.531.2">This is a bit better, but we still couple </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">our interface.</span></span></li>
<li><span class="koboSpan" id="kobo.533.1">We simply leave the iteration to our implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">db</span></strong><span class="koboSpan" id="kobo.535.1"> interface and we apply a user-provided function to all the rows. </span><span class="koboSpan" id="kobo.535.2">With this, we are not coupled to any </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">other component.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.537.1">So, we are going to leave</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.538.1"> iteration to the implementation of our interface. </span><span class="koboSpan" id="kobo.538.2">This means that the new function that we will add to </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">inMemoryDb</span></strong><span class="koboSpan" id="kobo.540.1"> will iterate over all the tasks and apply a function given as a parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">to each:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.542.1">
type db </span><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.543.1">interface {
  //...
</span><span class="koboSpan" id="kobo.543.2">  getTasks(f func(interface{}) error) error
}</span></pre>
<p><span class="koboSpan" id="kobo.544.1">As you can see, the function pas</span><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.545.1">sed as a parameter will itself get an </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">interface{}</span></strong><span class="koboSpan" id="kobo.547.1"> as a parameter. </span><span class="koboSpan" id="kobo.547.2">This is not type-safe; however, we are going to make sure that we receive a </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">Task</span></strong><span class="koboSpan" id="kobo.549.1"> at runtime when dealing with </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">it later.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">Then, for the in-memory implementation, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">the following:</span></span><a id="_idTextAnchor250"/></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
func (d *inMemoryDb) getTasks(f func(in</span><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.554.1">terface{}) error)
  error {
  </span><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.555.1">for _, task := r</span><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.556.1">ange d.tasks {
    if err </span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.557.1">:= f(task); err != nil {
      return err
    }
  }
  return nil
}</span></pre>
<p><span class="koboSpan" id="kobo.558.1">There is one thing to notice here. </span><span class="koboSpan" id="kobo.558.2">We are going to make errors fatal to the process. </span><span class="koboSpan" id="kobo.558.3">If the user-provided function returns an error, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">getTask</span><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.560.1">s</span></strong><span class="koboSpan" id="kobo.561.1"> function will return </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">an error.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">That is it for the database; we</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.564.1"> can now get all the tasks from it and apply some kind of logic to the tasks. </span><span class="koboSpan" id="kobo.564.2">Let us </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">implement </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">ListTasks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.568.1">Implementing ListTasks</span></h2>
<p><span class="koboSpan" id="kobo.569.1">To implement</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.570.1"> the endpoint, let us generate</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.571.1"> the Go code out of the proto files and take the function signature that we need to implement. </span><span class="koboSpan" id="kobo.571.2">We just run </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.573.1">
$ protoc --go_out=. </span><span class="koboSpan" id="kobo.573.2">\
         --go_opt=paths=source_relative \
         --go-grpc_out=. </span><span class="koboSpan" id="kobo.573.3">\
         --go-grpc_opt=paths=source_relative \
         proto/todo/v1/*.proto</span></pre>
<p><span class="koboSpan" id="kobo.574.1">And if we look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">proto/todo/v1/todo_grpc.pb.go</span></strong><span class="koboSpan" id="kobo.576.1">, we can now see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">TodoServiceServer</span></strong><span class="koboSpan" id="kobo.578.1"> interface has one </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">more function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.580.1">
type TodoServiceServer interface {
  //...
</span><span class="koboSpan" id="kobo.580.2">  ListTasks(*ListTasksRequest, TodoService_ListTasksServer)
    error
  //...
</span><span class="koboSpan" id="kobo.580.3">}</span></pre>
<p><span class="koboSpan" id="kobo.581.1">As we can see, the signature changed a bit from the one we had from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">AddTask</span></strong><span class="koboSpan" id="kobo.583.1"> function. </span><span class="koboSpan" id="kobo.583.2">We now only return an error or </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">nil</span></strong><span class="koboSpan" id="kobo.585.1">, and we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">TodoService_ListTasksServer</span></strong><span class="koboSpan" id="kobo.587.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">a parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">If you dig deeper into the generated code, you will see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">TodoService_ListTasksServer</span></strong><span class="koboSpan" id="kobo.591.1"> is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
type TodoService_ListTasksServer interface {
  Send(*ListTasksResponse) error
  grpc.ServerStream
}</span></pre>
<p><span class="koboSpan" id="kobo.594.1">This is a stream on which you can send </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">ListTasksResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.596.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">Now that we know that, let us implement the function in our code. </span><span class="koboSpan" id="kobo.597.2">We can go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">impl.go</span></strong><span class="koboSpan" id="kobo.599.1"> file under the server and copy and paste the function signature of </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">ListTasks</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.601.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">TodoServiceServer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
func (s *server) ListTasks(req *pb.ListTasksRequest, stream
  pb.TodoService_ListTasksServer) error</span></pre>
<p><span class="koboSpan" id="kobo.605.1">Obviously, we added the server type to specify that we are implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">ListTasks</span></strong><span class="koboSpan" id="kobo.607.1"> for our server and we named the parameters. </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">req</span></strong><span class="koboSpan" id="kobo.609.1"> is the request that we receive from the client and </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">stream</span></strong><span class="koboSpan" id="kobo.611.1"> is the object that we are going to use to send </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">multiple answers.</span></span></p>
<p><span class="koboSpan" id="kobo.613.1">Then, the logic of our function</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.614.1"> is once again straightforward. </span><span class="koboSpan" id="kobo.614.2">We are going</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.615.1"> to loop over all tasks, making sure that we are dealing with </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">Task</span></strong><span class="koboSpan" id="kobo.617.1"> objects, and for each of these tasks, we are going to “calculate” the overdue by checking whether these tasks are done (with no overdue for tasks that are done) and whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">due_date</span></strong><span class="koboSpan" id="kobo.619.1"> field is before the current time. </span><span class="koboSpan" id="kobo.619.2">In summary, we will just create </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">ListTasksResponse</span></strong><span class="koboSpan" id="kobo.621.1"> with this information and send that to the </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">client (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">server/impl.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
func (s *server) ListTasks(req *pb.ListTasksRequest, stream
  pb.TodoService_ListTasksSe</span><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.626.1">rver) error {
  return s.</span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.627.1">d.getTasks(func(t interfa</span><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.628.1">ce{}) error {
    task </span><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.629.1">:= t</span><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.630.1">.(*pb.Task)
    overdue := task.DueDate != nil &amp;</span><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.631.1">&amp; !task.Done &amp;&amp;
      ta</span><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.632.1">sk.DueDate.AsTime().Before(time.Now().UTC())
    err := stream.Send(&amp;pb.ListTasksResponse{
      Task: task,
      Overdue: overdue,
    })
    return err
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.633.1">One thing to notice is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">AsTime</span></strong><span class="koboSpan" id="kobo.635.1"> function will create a time in the UTC time zone, so when you compare a time with it you need it to also be in UTC. </span><span class="koboSpan" id="kobo.635.2">That is why we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">time.Now().UTC()</span></strong><span class="koboSpan" id="kobo.637.1"> and not </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">simply </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">time.Now()</span></strong></span></p>
<p><span class="koboSpan" id="kobo.640.1">There are obvio</span><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.641.1">usly ways in which this function can fail (e.g., what if the variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">t</span></strong><span class="koboSpan" id="kobo.643.1"> is not a </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">Task</span></strong><span class="koboSpan" id="kobo.645.1">?) but right now, let us not worry</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.646.1"> too much about error </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.647.1">handling. </span><span class="koboSpan" id="kobo.647.2">We are going to see that later. </span><span class="koboSpan" id="kobo.647.3">Let us now call this endpoint from </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">the client.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.649.1">Calling ListTasks from a client</span></h2>
<p><span class="koboSpan" id="kobo.650.1">To call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">ListTasks</span></strong><span class="koboSpan" id="kobo.652.1"> API endpoint</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.653.1"> from the client, we need to understand</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.654.1"> how to consume a server-streaming RPC endpoint. </span><span class="koboSpan" id="kobo.654.2">To do so, we check the method signature or the generated function in the interface name’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">TodoServiceClient</span></strong><span class="koboSpan" id="kobo.656.1">. </span><span class="koboSpan" id="kobo.656.2">It should look like </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.658.1">
ListTasks(ctx context.Context, in *ListTasksRequest, opts
...grpc.CallOption) (TodoService_ListTasksClient, error)</span></pre>
<p><span class="koboSpan" id="kobo.659.1">We can see that we will need to pass a context and a request and that there are some optional call options. </span><span class="koboSpan" id="kobo.659.2">Then, we can also see that we will get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">TodoService_ListTasksClient</span></strong><span class="koboSpan" id="kobo.661.1"> or an </span><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.662.1">error. </span><span class="koboSpan" id="kobo.662.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">TodoService_ListTasksClient</span></strong><span class="koboSpan" id="kobo.664.1"> type is very similar to the stream we dealt with in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">ListTasks</span></strong><span class="koboSpan" id="kobo.666.1"> endpoint. </span><span class="koboSpan" id="kobo.666.2">The main difference though is that, instead of having a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">Send</span></strong><span class="koboSpan" id="kobo.668.1">, we now have a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">Recv</span></strong><span class="koboSpan" id="kobo.670.1">. </span><span class="koboSpan" id="kobo.670.2">Here is the definition </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">TodoService_ListTasksClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
type TodoService_ListTasksClient interface {
  Recv() (*ListTasksResponse, error)
  grpc.ClientStream
}</span></pre>
<p><span class="koboSpan" id="kobo.675.1">So, what we are going to do with this stream is we are going to loop over all the responses that we can get from </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">Recv</span></strong><span class="koboSpan" id="kobo.677.1">, and then at some point, the server will say: “I am done.” </span><span class="koboSpan" id="kobo.677.2">This happens when we get an error that is equal </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">io.EOF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">We can create a function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">client/main.go</span></strong><span class="koboSpan" id="kobo.683.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">printTasks</span></strong><span class="koboSpan" id="kobo.685.1"> that will repeatedly call </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">Recv </span></strong><span class="koboSpan" id="kobo.687.1">and check whether we are finished or have an error, and if that is not the case, it will print the string</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.688.1"> representation</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.689.1"> of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">Task</span></strong><span class="koboSpan" id="kobo.691.1"> object on </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">the terminal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.693.1">
func printTasks(c pb.TodoServiceCli</span><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.694.1">ent) {
  req := &amp;pb.ListTasksRequest{}
  stream, err</span><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.695.1"> := c.L</span><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.696.1">istTasks(context.Background(), req)
  if err != nil {
    log.Fatalf("u</span><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.697.1">nexpected error: %v", err)
  }
  for {
    res, err := stream.Recv()
</span><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.698.1">    if </span><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.699.1">err == io.EOF {
      break
    }
    if err != nil {
      log.Fatalf("unexpected error: %v", err)
    }
    fmt.Println(res.Task.String(), "overdue: ",
       res.Overdue)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.700.1">Once we have this, we can call that function</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.701.1"> after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">addTask</span></strong><span class="koboSpan" id="kobo.703.1"> call that we made</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.704.1"> in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.706.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.707.1">
fmt.</span><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.708.1">Println("--------ADD--------")
//...
</span><strong class="bold"><span class="koboSpan" id="kobo.709.1">fmt.Println("--------LIST-------")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.710.1">printTasks(c)</span><a id="_idTextAnchor274"/></strong>
<strong class="bold"><span class="koboSpan" id="kobo.711.1">fmt.Println("-------------------")</span></strong></pre>
<p><span class="koboSpan" id="kobo.712.1">We can now use </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">go run</span></strong><span class="koboSpan" id="kobo.714.1"> to run our server first and then our client. </span><span class="koboSpan" id="kobo.714.2">So, at the r</span><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.715.1">oot of the project, we can run </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.717.1">$ go run ./server 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.718.1">
listening a</span><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.719.1">t 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.720.1">And then, we run </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">our client:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.722.1">$ go run ./client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.723.1">
//...
</span><span class="koboSpan" id="kobo.723.2">--------LIST-------
id:1 description:"This is a task" due_date:
  {seconds:1680158076 nanos:574914000} overdue: false
-------------------</span></pre>
<p><span class="koboSpan" id="kobo.724.1">This works as expected. </span><span class="koboSpan" id="kobo.724.2">Now, I would encourage you to try to add more tasks by yourself, try different values, and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">printTasks</span></strong><span class="koboSpan" id="kobo.726.1"> function after adding them all. </span><span class="koboSpan" id="kobo.726.2">This should help you get familiar with </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">Now that we can add tasks</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.729.1"> and list them all, it would be nice if we could update</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.730.1"> already existing tasks. </span><span class="koboSpan" id="kobo.730.2">This might be interesting for marking a task as done and changing the due date. </span><span class="koboSpan" id="kobo.730.3">We are going to test that through the client </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">streaming API.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.732.1">The client streaming API</span></h1>
<p class="callout-heading"><span class="koboSpan" id="kobo.733.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.734.1">In terms of the underlying</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.735.1"> protocol, the client streaming API uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">Send Header</span></strong><span class="koboSpan" id="kobo.737.1"> followed by multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">Send Message</span></strong><span class="koboSpan" id="kobo.739.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">Half-Close</span></strong><span class="koboSpan" id="kobo.741.1"> from the client side, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">Send Message</span></strong><span class="koboSpan" id="kobo.743.1"> plus </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">Send Trailer</span></strong><span class="koboSpan" id="kobo.745.1"> from the server side. </span></p>
<p><span class="koboSpan" id="kobo.746.1">With client streaming API endpoints, we can send zero or more requests and get one response. </span><span class="koboSpan" id="kobo.746.2">This is an important concept, especially for uploading data in real time. </span><span class="koboSpan" id="kobo.746.3">An example of this could be that we click on an edit button in our frontend, which triggers an edit session, and we post each edit being made in real time. </span><span class="koboSpan" id="kobo.746.4">Obviously, since we are not working with such fancy frontends, we are only going to focus on making the API compatible with this kind </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">of feature.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">To define a client streaming API, we simply need to write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">stream</span></strong><span class="koboSpan" id="kobo.750.1"> keyword in the parameter clause instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">return</span></strong><span class="koboSpan" id="kobo.752.1">. </span><span class="koboSpan" id="kobo.752.2">Previously, for our server streaming, we had </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.754.1">
rpc ListTasks(ListTasksRequest) returns (</span><strong class="bold"><span class="koboSpan" id="kobo.755.1">stream </span></strong><span class="koboSpan" id="kobo.756.1">ListTasksResponse);</span></pre>
<p><span class="koboSpan" id="kobo.757.1">Now, we will have the following</span><a id="_idTextAnchor278"/> <span class="No-Break"><span class="koboSpan" id="kobo.758.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">UpdateTasks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.761.1">
message UpdateTasksRequest {
</span><strong class="bold"><span class="koboSpan" id="kobo.762.1">  Task task = 1;</span></strong><span class="koboSpan" id="kobo.763.1">
}
message UpdateTasksResponse {
</span><strong class="bold"><span class="koboSpan" id="kobo.764.1">}</span></strong><span class="koboSpan" id="kobo.765.1">
service TodoService {
  //...
</span><span class="koboSpan" id="kobo.765.2">  rpc UpdateTasks(</span><strong class="bold"><span class="koboSpan" id="kobo.766.1">stream</span></strong><span class="koboSpan" id="kobo.767.1"> UpdateTasksRequest) returns
    (UpdateTasksResponse);
}</span></pre>
<p><span class="koboSpan" id="kobo.768.1">Note that, in this case, we are using the full Task message in the request, not separated fields like in </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">AddTask</span></strong><span class="koboSpan" id="kobo.770.1">. </span><span class="koboSpan" id="kobo.770.2">This is not a mistake and we will talk about this more </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">during </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">chapter6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">This effectively means that the client sends multiple requests, and the server returns one response. </span><span class="koboSpan" id="kobo.774.2">We are now</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.775.1"> one step closer to implementing our endpoint. </span><span class="koboSpan" id="kobo.775.2">However, let us talk about the database before </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">doing that.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.777.1">Evolving the database</span></h2>
<p><span class="koboSpan" id="kobo.778.1">Before thinking</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.779.1"> about implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.781.1">, we need to see how we interact with the database. </span><span class="koboSpan" id="kobo.781.2">The first thing to consider is what information can be updated for a given task. </span><span class="koboSpan" id="kobo.781.3">In our case, we do not want the client to be able to update an ID; this is a detail that is handled by the database. </span><span class="koboSpan" id="kobo.781.4">However, for all the other information, we want to let the user be able to update it. </span><span class="koboSpan" id="kobo.781.5">When a task is done, we need to be able to set </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">done</span></strong><span class="koboSpan" id="kobo.783.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">true</span></strong><span class="koboSpan" id="kobo.785.1">. </span><span class="koboSpan" id="kobo.785.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">Task</span></strong><span class="koboSpan" id="kobo.787.1"> description needs updating, the client should be able to change it in the database. </span><span class="koboSpan" id="kobo.787.2">And finally, when the due date changes, the client should also be able to </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">update it.</span></span></p>
<p><span class="koboSpan" id="kobo.789.1">Knowing that, we can define our function signature for </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">updateTask</span></strong><span class="koboSpan" id="kobo.791.1"> in our database. </span><span class="koboSpan" id="kobo.791.2">It will take the task ID and all the information that can be changed as parameters and return an error </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">nil</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
type db interface {
  //...
</span><span class="koboSpan" id="kobo.795.2">  updateTask(id uint64, description string, dueDate
    time.Time, done bool) error
}</span></pre>
<p><span class="koboSpan" id="kobo.796.1">Once again, it looks a little bit much to pass that many parameters, but we do not want to couple this interface with any of the generated code. </span><span class="koboSpan" id="kobo.796.2">If later we need to add more information or remove some, this is as easy as updating this interface and updating </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">the implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.798.1">Now, to implement that, we are going to go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">in_memory.go</span></strong><span class="koboSpan" id="kobo.800.1"> file. </span><span class="koboSpan" id="kobo.800.2">The function will simply iterate through all the tasks in the database, and if any </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">Task</span></strong><span class="koboSpan" id="kobo.802.1"> has the same ID as the ID passed in the parameter, we will update all the fields one </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">by one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.804.1">
func (d *inMemoryDb) updateTask(id uint64, description
  string, dueDate time.Time, done bool) error {
  for i, task := range d.tasks {
    if task.Id == id {
      t := d.tasks[i]
      t.Description = description
      t.DueDate = timestamppb.New(dueDate)
      t.Done = done
      return nil
    }
  }
  return fmt.Errorf("task with id %d not found", id)
}</span></pre>
<p><span class="koboSpan" id="kobo.805.1">Now that means that every time we receive a request, we are going to iterate through all the tasks. </span><span class="koboSpan" id="kobo.805.2">This is not highly efficient, especially when the database becomes bigger. </span><span class="koboSpan" id="kobo.805.3">However, we are also not working with a real</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.806.1"> database so it should be good enough for our use case in </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">this book.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.808.1">Implementing UpdateTasks</span></h2>
<p><span class="koboSpan" id="kobo.809.1">To implement the endpoint, let us generate</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.810.1"> the Go code</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.811.1"> out of the proto files and take the function signature that we need to implement. </span><span class="koboSpan" id="kobo.811.2">We just run </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.813.1">
$ protoc --go_out=. </span><span class="koboSpan" id="kobo.813.2">\
         --go_opt=paths=source_relative \
         --go-grpc_out=. </span><span class="koboSpan" id="kobo.813.3">\
         --go-grpc_opt=paths=source_relative \
         proto/todo/v1/*.proto</span></pre>
<p><span class="koboSpan" id="kobo.814.1">And if we look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">proto/todo/v1/todo_grpc.pb.go</span></strong><span class="koboSpan" id="kobo.816.1">, we can now see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">TodoServiceServer</span></strong><span class="koboSpan" id="kobo.818.1"> interface has one </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">more function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.820.1">
type TodoServiceServer interface {
  //...
</span><span class="koboSpan" id="kobo.820.2">  UpdateTasks(TodoService_UpdateTasksServe</span><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.821.1">r) error
  //...
</span><span class="koboSpan" id="kobo.821.2">}</span></pre>
<p><span class="koboSpan" id="kobo.822.1">As we can see, the signature changed is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">ListTasks</span></strong><span class="koboSpan" id="kobo.824.1">; however, this time, we do not even deal with a request. </span><span class="koboSpan" id="kobo.824.2">We simply deal with a stream of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">TodoService_UpdateTasksServer</span></strong><span class="koboSpan" id="kobo.826.1"> type. </span><span class="koboSpan" id="kobo.826.2">If we check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">TodoService_UpdateTasksServer</span></strong><span class="koboSpan" id="kobo.828.1"> type definition, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.830.1">
type TodoService_UpdateTasksServer interface {
  SendAndClose(*UpdateTasksResponse) error
  Recv() (*UpdateTasksRequest, error)
  grpc.ServerStream
}</span></pre>
<p><span class="koboSpan" id="kobo.831.1">We are already familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">Recv</span></strong><span class="koboSpan" id="kobo.833.1"> function. </span><span class="koboSpan" id="kobo.833.2">It lets us get an object, but now we also have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">SendAndClose</span></strong><span class="koboSpan" id="kobo.835.1"> function. </span><span class="koboSpan" id="kobo.835.2">This function lets us tell the client that we are done on the server side. </span><span class="koboSpan" id="kobo.835.3">This is used to close the stream when the client sends </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">an </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">io.EOF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.839.1">Armed with that knowledge, we can implement our endpoint. </span><span class="koboSpan" id="kobo.839.2">We are going to repeatedly call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">Recv</span></strong><span class="koboSpan" id="kobo.841.1"> function on the stream, and if we receive an </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">io.EOF</span></strong><span class="koboSpan" id="kobo.843.1">, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">SendAndClose</span></strong><span class="koboSpan" id="kobo.845.1"> function; otherwise, we will</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.846.1"> call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">updateTask</span></strong><span class="koboSpan" id="kobo.848.1"> function</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.849.1"> on </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">our database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.851.1">
func (s *server) UpdateTasks(stream p</span><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.852.1">b.TodoService
  _UpdateTasksServer) error {
  for {
    req, err := stream.Recv()
    if err == io.EOF {
      return </span><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.853.1">stream.</span><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.854.1">SendAndClose(&amp;pb.Up</span><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.855.1">dateTasksResponse{})
    }
    if err != nil {
      return err
    }
    s.d.updateTask(
      req.Task.Id,
      req.Task.Description,
      req.Task.DueDate.AsTime(),
      req.Task.Done,
    )
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.856.1">We should now be able to trigger</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.857.1"> this API endpoint to change</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.858.1"> a given set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">Task</span></strong><span class="koboSpan" id="kobo.860.1"> in real time. </span><span class="koboSpan" id="kobo.860.2">Let us now see how a client can call </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">the endpoint.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.862.1">Calling UpdateTasks from a client</span></h2>
<p><span class="koboSpan" id="kobo.863.1">This time, since we are working</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.864.1"> with client streaming, we are</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.865.1"> going to do the opposite from what we did for server streaming. </span><span class="koboSpan" id="kobo.865.2">The client will repeatedly call </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">Send</span></strong><span class="koboSpan" id="kobo.867.1"> and the server will repeatedly call </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">Recv</span></strong><span class="koboSpan" id="kobo.869.1">. </span><span class="koboSpan" id="kobo.869.2">And in the end, the client will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">CloseAndRecv</span></strong><span class="koboSpan" id="kobo.871.1"> function, which is defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">generated code.</span></span></p>
<p><span class="koboSpan" id="kobo.873.1">If we look at the generated code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.875.1"> on the client side, we will see the following signature in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">TodoServiceClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.877.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">
UpdateTasks(ctx context.Context, opts ...grpc.CallOption)
  (TodoService_UpdateTasksClient, error)</span></pre>
<p><span class="koboSpan" id="kobo.879.1">Notice that now the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.881.1"> function does not take any </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">request</span></strong><span class="koboSpan" id="kobo.883.1"> parameters, but it will return a stream of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">TodoService_UpdateTasksClient</span></strong><span class="koboSpan" id="kobo.885.1"> type. </span><span class="koboSpan" id="kobo.885.2">This type, as mentioned, will contain two functions: </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">Send</span></strong><span class="koboSpan" id="kobo.887.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">CloseAndRecv</span></strong><span class="koboSpan" id="kobo.889.1">. </span><span class="koboSpan" id="kobo.889.2">If we look at the generated code, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.891.1">
type TodoService_UpdateTasksClient interface {
  Send(*UpdateTasksRequest) error
  CloseAndRecv() (*UpdateTasksResponse, error)
  grpc.ClientStream
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">Send</span></strong><span class="koboSpan" id="kobo.893.1"> is sent </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">UpdateTasksRequest</span></strong><span class="koboSpan" id="kobo.895.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">CloseAndRecv</span></strong><span class="koboSpan" id="kobo.897.1"> will tell the server that it is done sending requests and ask </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">UpdateTasksResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">Now that we understand</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.902.1"> that we can implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.904.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">client/main.go</span></strong><span class="koboSpan" id="kobo.906.1"> file, we are going to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.908.1"> function from the gRPC client. </span><span class="koboSpan" id="kobo.908.2">This will return a stream and then we are going to send given tasks through it. </span><span class="koboSpan" id="kobo.908.3">Once we have looped through all the tasks that needed to be updated, we will call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">CloseAndRecv</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.910.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.911.1">
func updateTasks(c p</span><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.912.1">b.TodoServiceClient, reqs
...*pb.UpdateTasksRequ</span><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.913.1">est) {
</span><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.914.1">  stream, err := c.UpdateTasks(context.Background())
  if err != nil {
    log.Fatalf("</span><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.915.1">unexpected error: %v", err)
  }</span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.916.1">
  for</span><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.917.1"> _, req := range reqs {
    err :</span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.918.1">= strea</span><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.919.1">m.Send(req)
    if err != nil {
      return
    }
    if err != nil {
  </span><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.920.1">    </span><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.921.1">log.Fatalf("unexpected error: %v", err)
    }
    if req.Task != nil {
      fmt.Printf("updated task with id: %d\n</span><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.922.1">", req.</span><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.923.1">Task.Id)
    }
  }
  if _, err = stream.CloseAndRecv(); err != nil {
    log.Fatalf("unexpected error: %v", err)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.924.1">Now, as you can see in </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">updateTasks</span></strong><span class="koboSpan" id="kobo.926.1">, we need to pass zero</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.927.1"> or more </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">UpdateTasksRequest</span></strong><span class="koboSpan" id="kobo.929.1"> as parameters. </span><span class="koboSpan" id="kobo.929.2">To get the IDs needed to create </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.930.1">task instances and fill the </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">UpdateTasksRequest.task</span></strong><span class="koboSpan" id="kobo.932.1"> field, we are going to record the IDs of tasks created before with </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">addTasks</span></strong><span class="koboSpan" id="kobo.934.1">. </span><span class="koboSpan" id="kobo.934.2">So, formerly, we had the following </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.938.1">
addTa</span><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.939.1">sk(c, "This is a task", dueDate)</span></pre>
<p><span class="koboSpan" id="kobo.940.1">We will now </span><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.941.1">have something like </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.943.1">
id1 := addTask(c, "This is a t</span><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.944.1">ask", dueDate)
id2 := addTask(c, "This is another task", dueDate)
id3 := addTask(c, "And yet another task", dueDate)</span></pre>
<p><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.945.1">And now, we can create an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">UpdateTasksRequest</span></strong><span class="koboSpan" id="kobo.947.1"> just </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.949.1">
[]*pb.UpdateTasksRequest{
  {Task: &amp;pb.Task{Id: id1, Description: "A better name for
    the task"}},
  {Task: &amp;pb.Task{Id: id2, DueDate: timestamppb.New
    (dueDate.Add(5 * time.Hour))}},
  {Task: &amp;pb.Task{Id: id3, Done: true}},
}</span></pre>
<p><span class="koboSpan" id="kobo.950.1">This means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">Task</span></strong><span class="koboSpan" id="kobo.952.1"> object with </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">id1</span></strong><span class="koboSpan" id="kobo.954.1"> will be updated to have a new description, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">Task</span></strong><span class="koboSpan" id="kobo.956.1"> object with </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">id2</span></strong><span class="koboSpan" id="kobo.958.1"> will be updated to have a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">due_date</span></strong><span class="koboSpan" id="kobo.960.1"> value, and finally, the last one will be marked </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">done</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.964.1">We can now pass the client to </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">updateTasks</span></strong><span class="koboSpan" id="kobo.966.1"> and expand this array as a variadic parameter by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">…</span></strong><span class="koboSpan" id="kobo.968.1"> operator. </span><span class="koboSpan" id="kobo.968.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">main</span></strong><span class="koboSpan" id="kobo.970.1">, we can now a</span><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.971.1">dd </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.973.1">
fmt.Println("-------UPDATE------")
updateTasks(c, []*pb.UpdateTasksRequest{
  {Task: &amp;pb.Task{Id: id1, Description: "A better name for
    the task"}},
  {Task: &amp;pb.Task{Id: id2, DueDate: timestamppb.New
    (dueDate.Add(5 * time.Hour))}},
  {Task: &amp;pb.Task{Id: id3, Done: true}},
}...)
print</span><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.974.1">Tasks(c)
fmt.Println("-------------------")</span></pre>
<p><span class="koboSpan" id="kobo.975.1">We</span><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.976.1"> can now run</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.977.1"> that in a similar</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.978.1"> way </span><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.979.1">to the previous sections. </span><span class="koboSpan" id="kobo.979.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">go run</span></strong><span class="koboSpan" id="kobo.981.1"> to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">server first:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.983.1">
$ go run ./server 0.0.0.0:50051
listening at 0.</span><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.984.1">0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.985.1">And then we run the client to call the </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">API endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.987.1">
$ go run ./client 0.0.0.0:50051
//...
</span><span class="koboSpan" id="kobo.987.2">-------UPDATE------
updated task with id: 1
updated task with id: 2
updated task with id: 3
id:1  description:"A better name for the task"  due_date:{}
id:2  due_date:{seconds:16802677</span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.988.1">68  nanos:127075000}
id:3  done:true  due_date:{}
-------------------</span></pre>
<p><span class="koboSpan" id="kobo.989.1">Before moving on, there is an important thing to note here. </span><span class="koboSpan" id="kobo.989.2">You might be a little bit surprised about the fact that the tasks lost some information when updating them. </span><span class="koboSpan" id="kobo.989.3">This is because Protobuf will use the default value of a field when it is not set – meaning that if the client sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">Task</span></strong><span class="koboSpan" id="kobo.991.1"> object with only </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">done</span></strong><span class="koboSpan" id="kobo.993.1"> being equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">true</span></strong><span class="koboSpan" id="kobo.995.1">, the description will be deserialized as an empty string and </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">due_date</span></strong><span class="koboSpan" id="kobo.997.1"> will be an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">google.protobuf.Timestamp</span></strong><span class="koboSpan" id="kobo.999.1">. </span><span class="koboSpan" id="kobo.999.2">For now, this is highly inefficient because we need to resend all the information to update a single field. </span><span class="koboSpan" id="kobo.999.3">Later in the book, we are going to talk about how to solve this issue. </span><span class="koboSpan" id="kobo.999.4">We can now update multiple tasks</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.1000.1"> in real time based on their IDs. </span><span class="koboSpan" id="kobo.1000.2">Let us now move to the last API type available: </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">bidirectional streaming.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.1002.1">The bidirectional streaming API</span></h1>
<p class="callout-heading"><span class="koboSpan" id="kobo.1003.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1004.1">In terms of the underlying protocol, the bidirectional streaming API uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">Send Header</span></strong><span class="koboSpan" id="kobo.1006.1"> from the client side, followed by multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">Send Message</span></strong><span class="koboSpan" id="kobo.1008.1"> from the server and/or client side, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">Half-Close</span></strong><span class="koboSpan" id="kobo.1010.1"> from the client side, and finally </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">Send Trailer</span></strong><span class="koboSpan" id="kobo.1012.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">server side.</span></span></p>
<p><span class="koboSpan" id="kobo.1014.1">In a bidirectional streaming API, the goal </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.1015.1">is to let the client send zero or more requests and let the server send zero or more responses. </span><span class="koboSpan" id="kobo.1015.2">We are going to use this to simulate a feature that is like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">updateTasks</span></strong><span class="koboSpan" id="kobo.1017.1"> but in which we are going to have direct feedback from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">DeleteTasks</span></strong><span class="koboSpan" id="kobo.1019.1"> endpoint API after each deletion instead of waiting for all the deletions to </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">be done.</span></span></p>
<p><span class="koboSpan" id="kobo.1021.1">One thing to be clear about before continuing with the implementation is the question of why not to design </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">DeleteTasks</span></strong><span class="koboSpan" id="kobo.1023.1"> as a server streaming API or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">updateTasks</span></strong><span class="koboSpan" id="kobo.1025.1"> as a bidirectional streaming API. </span><span class="koboSpan" id="kobo.1025.2">The difference between these two tasks is how “destructive” they are. </span><span class="koboSpan" id="kobo.1025.3">We can make an update directly on the client even before sending the requests to the server. </span><span class="koboSpan" id="kobo.1025.4">If any error is present, we can simply look at the list we have on the client and synchronize it with the one on the server depending on the modified time. </span><span class="koboSpan" id="kobo.1025.5">For a deletion, this would be a little bit more involved. </span><span class="koboSpan" id="kobo.1025.6">We could keep the deleted row on the client and garbage would collect it later, or we would need to store the information somewhere else to synchronize it with the server. </span><span class="koboSpan" id="kobo.1025.7">This creates a little bit </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">more overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.1027.1">So, we are going to send multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">DeleteTasksRequest</span></strong><span class="koboSpan" id="kobo.1029.1">, and for each, we are going to have the confirmation that it was deleted. </span><span class="koboSpan" id="kobo.1029.2">And, if an error occurs, we are still sure that the tasks preceding the error were deleted on the server. </span><span class="koboSpan" id="kobo.1029.3">Our RPC and messages look like </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1031.1">
message DeleteTasksRequest {
  uint64 id = 1;
}
message DeleteTasksResponse {
}
service TodoService {
  //...
</span><span class="koboSpan" id="kobo.1031.2">  rpc DeleteTasks(</span><strong class="bold"><span class="koboSpan" id="kobo.1032.1">stream</span></strong><span class="koboSpan" id="kobo.1033.1"> DeleteTasksRequest) returns
    (</span><strong class="bold"><span class="koboSpan" id="kobo.1034.1">stream</span></strong><span class="koboSpan" id="kobo.1035.1"> DeleteTasksResponse);
}</span></pre>
<p><span class="koboSpan" id="kobo.1036.1">We repeatedly send the ID of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">Task</span></strong><span class="koboSpan" id="kobo.1038.1"> we want to delete, and if we receive a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">DeleteTasksResponse</span></strong><span class="koboSpan" id="kobo.1040.1">, this means that</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.1041.1"> the task was deleted. </span><span class="koboSpan" id="kobo.1041.2">Otherwise, we get </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">an error.</span></span></p>
<p><span class="koboSpan" id="kobo.1043.1">Now, before diving into the implementation, let us look at our </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">database interface.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.1045.1">Evolving the database</span></h2>
<p><span class="koboSpan" id="kobo.1046.1">As we want to remove a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">Task</span></strong><span class="koboSpan" id="kobo.1048.1"> object</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.1049.1"> in the database, we are going to need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">deleteTask</span></strong><span class="koboSpan" id="kobo.1051.1"> function. </span><span class="koboSpan" id="kobo.1051.2">This function will take an ID of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">Task</span></strong><span class="koboSpan" id="kobo.1053.1"> object to be deleted, act on it, and return an error or nil. </span><span class="koboSpan" id="kobo.1053.2">We can add the following function </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">server/db.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1057.1">
type db interface {
  //...
</span><span class="koboSpan" id="kobo.1057.2">  deleteTask(id uint64) error
}</span></pre>
<p><span class="koboSpan" id="kobo.1058.1">Implementing that looks a lot like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">updateTask</span></strong><span class="koboSpan" id="kobo.1060.1">. </span><span class="koboSpan" id="kobo.1060.2">However, instead of updating information when we find the task with the right ID, we are going to delete it with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">go slice</span></strong><span class="koboSpan" id="kobo.1062.1"> trick. </span><span class="koboSpan" id="kobo.1062.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">server/in_memory.go</span></strong><span class="koboSpan" id="kobo.1064.1">, we now have </span><a id="_idTextAnchor311"/><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1066.1">
func (d *inMemoryDb) deleteTask(id uint64) error {
  for i, task := range d.tas</span><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.1067.1">ks {
    if task.Id == id {
      d.tasks = append(d.tasks[:i], d.tasks[i+1:]...)
      return nil
    }
  }
  return fmt.Errorf("task with id %d not found", id)
}</span></pre>
<p><span class="koboSpan" id="kobo.1068.1">The slice trick takes the elements after the current task and appends them to the previous task. </span><span class="koboSpan" id="kobo.1068.2">This effectively overrides</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.1069.1"> the current task in the array and thus deletes it. </span><span class="koboSpan" id="kobo.1069.2">With that, we are now ready to implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">DeleteTasks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1"> endpoint.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.1072.1">Implementing DeleteTasks</span></h2>
<p><span class="koboSpan" id="kobo.1073.1">Before implementing </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.1074.1">the actual endpoint, we need</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.1075.1"> to understand how we will deal with the generated code. </span><span class="koboSpan" id="kobo.1075.2">So, let us generate the code with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1077.1">
$ protoc --go_out=. </span><span class="koboSpan" id="kobo.1077.2">\
         --go_opt=paths=source_relative \
         --go-grpc_out=. </span><span class="koboSpan" id="kobo.1077.3">\
         --go-grpc_opt=paths=source_relative \
         proto/todo/v1/*.proto</span></pre>
<p><span class="koboSpan" id="kobo.1078.1">And if we check </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">todo_grpc.pb.go</span></strong><span class="koboSpan" id="kobo.1080.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">proto/todo/v1</span></strong><span class="koboSpan" id="kobo.1082.1"> folder, we should have the following function added </span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">TodoServiceServer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1085.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1086.1">
DeleteTasks(TodoService_DeleteTasksServer) error</span></pre>
<p><span class="koboSpan" id="kobo.1087.1">This is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.1089.1"> function because we get a stream, and we return either an error or nil. </span><span class="koboSpan" id="kobo.1089.2">However, instead of having </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">Send</span></strong><span class="koboSpan" id="kobo.1091.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">SendAndClose</span></strong><span class="koboSpan" id="kobo.1093.1"> functions, we now have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">Send</span></strong><span class="koboSpan" id="kobo.1095.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">Recv</span></strong><span class="koboSpan" id="kobo.1097.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">TodoService_DeleteTasksServer</span></strong><span class="koboSpan" id="kobo.1099.1"> is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1101.1">
type TodoService_DeleteTasksServer interface {
  Send(*DeleteTasksResponse) error
  Recv() (*DeleteTasksRequest, error)
  grpc.ServerStream
}</span></pre>
<p><span class="koboSpan" id="kobo.1102.1">This means that, in our</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.1103.1"> case, we can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">Recv</span></strong><span class="koboSpan" id="kobo.1105.1"> to get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">DeleteTasksRequest</span></strong><span class="koboSpan" id="kobo.1107.1">, and for each of them we are going</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.1108.1"> to send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">DeleteTasksResponse</span></strong><span class="koboSpan" id="kobo.1110.1">. </span><span class="koboSpan" id="kobo.1110.2">Finally, since we are working with a stream, we still need to check for errors and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">io.EOF</span></strong><span class="koboSpan" id="kobo.1112.1">. </span><span class="koboSpan" id="kobo.1112.2">When we get </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">io.EOF</span></strong><span class="koboSpan" id="kobo.1114.1">, we will just end the function </span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">return</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1118.1">
func (s *server) D</span><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.1119.1">eleteTasks(stream
  pb.TodoService_DeleteTasksServer) error {
  for {
    r</span><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.1120.1">eq, err</span><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.1121.1"> := stream.Recv()
    if err == io.EOF {
      return nil
    }
    if err != nil {
      return err
    }
    s.d.deleteTask(req.Id)
    stream.Send(&amp;pb.DeleteTasksResponse{})
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1122.1">One thing to note here is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">stream.Send</span></strong><span class="koboSpan" id="kobo.1124.1"> call. </span><span class="koboSpan" id="kobo.1124.2">Even though this is simple, this is what differentiates client streaming from bidirectional streaming. </span><span class="koboSpan" id="kobo.1124.3">If we did not have that call, we would effectively send multiple requests from the client, and in the end, the server would return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">nil</span></strong><span class="koboSpan" id="kobo.1126.1"> to close the stream. </span><span class="koboSpan" id="kobo.1126.2">This would be exactly the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.1128.1">. </span><span class="koboSpan" id="kobo.1128.2">But because</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.1129.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">Send</span></strong><span class="koboSpan" id="kobo.1131.1"> call, we now have direct feedback</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.1132.1"> after </span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1">each deletion.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.1134.1">Calling UpdateTasks from the client</span></h2>
<p><span class="koboSpan" id="kobo.1135.1">Now that we have our endpoint, we can call</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.1136.1"> it from the client. </span><span class="koboSpan" id="kobo.1136.2">Before</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.1137.1"> we can do it though, we need to look at the generated code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">TodoServiceClient</span></strong><span class="koboSpan" id="kobo.1139.1">. </span><span class="koboSpan" id="kobo.1139.2">We should now have the </span><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">following function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1141.1">
DeleteTasks(ctx context.Context, opts ..</span><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.1142.1">.grpc.CallOption)
  (TodoService_DeleteTasksClient, error)</span></pre>
<p><span class="koboSpan" id="kobo.1143.1">Once again, this is similar to what we saw in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">ListTasks</span></strong><span class="koboSpan" id="kobo.1145.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.1147.1"> functions because it returns a string that we can interact with. </span><span class="koboSpan" id="kobo.1147.2">However, as you can guess, we can now use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">Send</span></strong><span class="koboSpan" id="kobo.1149.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">Recv</span></strong><span class="koboSpan" id="kobo.1151.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">TodoService_DeleteTasksClient</span></strong><span class="koboSpan" id="kobo.1153.1"> looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1155.1">
type TodoService_DeleteTasksClient interface {
  Send(*DeleteTasksRequest) error
  Recv() (*DeleteTasksResponse, error)
  grpc.ClientStream
}</span></pre>
<p><span class="koboSpan" id="kobo.1156.1">With that generated code and the underlying gRPC framework, we can now send multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">DeleteTasksRequest</span></strong><span class="koboSpan" id="kobo.1158.1"> and get </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">multiple </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">DeleteTasksResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1162.1">Now, we are going to create a new function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">client/main.go</span></strong><span class="koboSpan" id="kobo.1164.1"> that will take variadic parameters of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">DeleteTasksRequest</span></strong><span class="koboSpan" id="kobo.1166.1">. </span><span class="koboSpan" id="kobo.1166.2">Then, we are going to create a channel that will help us wait for the entire process of receiving and sending to finish. </span><span class="koboSpan" id="kobo.1166.3">If we did not do that, we would return from the function before finishing. </span><span class="koboSpan" id="kobo.1166.4">This channel will be used in a goroutine that will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">Recv</span></strong><span class="koboSpan" id="kobo.1168.1"> in the background. </span><span class="koboSpan" id="kobo.1168.2">Once we receive an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">io.EOF</span></strong><span class="koboSpan" id="kobo.1170.1"> in this goroutine, we are going to close the channel. </span><span class="koboSpan" id="kobo.1170.2">Finally, we are going to go over all the requests and send them, and once we are done, we are going to wait for the channel to </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">be closed.</span></span></p>
<p><span class="koboSpan" id="kobo.1172.1">This might seem a little</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.1173.1"> bit abstract right now but think about the job that the client needs to do. </span><span class="koboSpan" id="kobo.1173.2">It needs to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">Recv</span></strong><span class="koboSpan" id="kobo.1175.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">Send</span></strong><span class="koboSpan" id="kobo.1177.1"> simultaneously; thus, we need</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.1178.1"> some simple </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">concurrent code:</span></span></p>
<pre class="source-code">
<a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.1180.1">func deleteTasks(c pb.TodoServiceClient, reqs
..</span><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.1181.1">.*pb.De</span><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.1182.1">leteTasksRequest) {
  stream, err := c.DeleteTasks(context.Backgro</span><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.1183.1">und())
  </span><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.1184.1">if err != nil {
    log.Fatalf("unexpected e</span><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.1185.1">rror: %v", err)
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.1186.1">waitc := make(chan struct{})</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1187.1">  go func()</span></strong><span class="koboSpan" id="kobo.1188.1"> {
    for {
      _, err := stream</span><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.1189.1">.Recv()</span><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.1190.1">
      if err == io.EOF {
        </span><strong class="bold"><span class="koboSpan" id="kobo.1191.1">close(waitc)</span></strong><span class="koboSpan" id="kobo.1192.1">
        break
      }
      if err != nil {
        log.Fatalf("error while rec</span><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.1193.1">eiving: %v\n", err)
      }</span><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.1194.1">
      log.Println("dele</span><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.1195.1">ted tas</span><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.1196.1">ks")
    }
  }()
  for _, req := </span><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.1197.1">range reqs {
    if err := </span><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.1198.1">stream.</span><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.1199.1">Send(req); err != nil {
      return
    }
  }
  if err := stream.CloseSend(); err != nil {
    return
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.1200.1">&lt;-waitc</span></strong><span class="koboSpan" id="kobo.1201.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1202.1">Finally, before running our server</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.1203.1"> and client, let</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.1204.1"> us call that function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">main</span></strong><span class="koboSpan" id="kobo.1206.1"> function. </span><span class="koboSpan" id="kobo.1206.2">We are going to delete all the tasks that we created with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">addTasks</span></strong><span class="koboSpan" id="kobo.1208.1"> and prove that there are no more </span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.1209.1">tasks by trying to print all </span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1">of them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1211.1">
fmt.Println("-------DELETE------")
deleteTasks(c, []*pb.DeleteTasksRequest{
  {Id: id1},
  {Id: id2},
  {Id: id3},
}...)
printT</span><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.1212.1">asks(c)
fmt.Println("-------------------")</span></pre>
<p><span class="koboSpan" id="kobo.1213.1">With that, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">server first:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1215.1">$ go run</span><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.1216.1"> ./server 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.1217.1">
listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.1218.1">And then we can run </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">our client:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1220.1">$ go run ./client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.1221.1">
//...
</span><span class="koboSpan" id="kobo.1221.2">-------DELETE------
2023/03/31 18:54:21 deleted tasks
2023/03/31 18:54:21 deleted tasks
2023/03/31 18:54:21 deleted tasks
-------------------</span></pre>
<p><span class="koboSpan" id="kobo.1222.1">Notice here that, instead of having a single response like client streaming, we have three responses (three </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">deleted tasks</span></strong><span class="koboSpan" id="kobo.1224.1">). </span><span class="koboSpan" id="kobo.1224.2">This is because we get a response per request. </span><span class="koboSpan" id="kobo.1224.3">We effectively implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">bidirectional streaming.</span></span></p>
<p><span class="koboSpan" id="kobo.1226.1">We implemented bidirectional streaming</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.1227.1"> here, which let us</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.1228.1"> get feedback for each request we sent to the server. </span><span class="koboSpan" id="kobo.1228.2">With that, we can make sure that we update resources on the client side without having to wait for a response or error from the server. </span><span class="koboSpan" id="kobo.1228.3">This is interesting for use cases like ours that need </span><span class="No-Break"><span class="koboSpan" id="kobo.1229.1">real-time updates.</span></span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.1230.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1231.1">In this chapter, we saw the different types of APIs we can write in gRPC. </span><span class="koboSpan" id="kobo.1231.2">We saw that we can create similar API endpoints as the ones we are used to in REST APIs. </span><span class="koboSpan" id="kobo.1231.3">These endpoints are called unary endpoints. </span><span class="koboSpan" id="kobo.1231.4">Then, we saw that we can make server streaming APIs to let the server return multiple responses. </span><span class="koboSpan" id="kobo.1231.5">Similarly, we saw that a client can return multiple requests with client streaming. </span><span class="koboSpan" id="kobo.1231.6">And finally, we saw that we can “mix” server and client streaming to get </span><span class="No-Break"><span class="koboSpan" id="kobo.1232.1">bidirectional streaming.</span></span></p>
<p><span class="koboSpan" id="kobo.1233.1">Our current endpoints are simplistic and do not handle a lot of cases that are crucial for </span><span class="No-Break"><span class="koboSpan" id="kobo.1234.1">production-grade APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.1235.1">In the next chapter, we will start seeing what we can improve at the API level. </span><span class="koboSpan" id="kobo.1235.2">This will let us first focus on the usability of the API before diving deeper into all the aspects of </span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">production-grade APIs.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.1237.1">Quiz</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1238.1">What kind of API endpoint should you use when you want to send one request and receive </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">one response?</span></span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.1240.1">Bidirectional streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1241.1">Client streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">Unary</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1243.1">What kind of API endpoint should you use when you want to send zero or more requests and receive </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">one response?</span></span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.1245.1">Server streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">Bidirectional streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">Client streaming</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1248.1">What kind of API endpoint should you use when you want to send one request and receive zero or </span><span class="No-Break"><span class="koboSpan" id="kobo.1249.1">more responses?</span></span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">Server streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">Client streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1252.1">Bidirectional streaming</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1253.1">What kind of API endpoint should you use when you want to send zero or more requests and receive zero or </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">more responses?</span></span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">Client streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">Bidirectional streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">Server streaming</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-115"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.1258.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1259.1">C</span></li>
<li><span class="koboSpan" id="kobo.1260.1">C</span></li>
<li><span class="koboSpan" id="kobo.1261.1">A</span></li>
<li><span class="koboSpan" id="kobo.1262.1">B</span></li>
</ol>
</div>
</body></html>