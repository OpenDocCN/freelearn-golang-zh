- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Types of gRPC Endpoints
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC端点的类型
- en: In this chapter, we are going to see the different types of gRPC endpoints that
    you can write. For each of the endpoints, we are going to understand what the
    idea behind the type of communication we are talking about is, and we are going
    to define an RPC endpoint in our Protobuf service. Finally, we are going to implement
    that endpoint and write a client to consume the endpoint. At the end of this chapter,
    the goal is to implement a TODO API that will let us create, update, delete, and
    list the tasks in our TODO list.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到您可以编写的不同类型的gRPC端点。对于每个端点，我们将了解我们正在讨论的通信类型的背后理念，并在我们的Protobuf服务中定义一个RPC端点。最后，我们将实现该端点并编写一个客户端来消费该端点。本章的最终目标是实现一个TODO
    API，它将允许我们创建、更新、删除和列出我们的TODO列表中的任务。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要主题：
- en: What the four types of RPC endpoints you can write are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以编写的四种RPC端点类型
- en: When to use each of them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用每个端点
- en: How to implement the endpoint’s logic
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现端点的逻辑
- en: How to consume a gRPC endpoint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何消费gRPC端点
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code for this chapter in the folder called `chapter5` in the
    companion repo for this book at [https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter5](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter5).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的配套仓库中找到本章的代码，该仓库位于[https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter5](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter5)。
- en: Using the template
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section is only necessary if you want to work with the same architecture
    as the github repository. Continuing working on the code from the previous code
    is totally fine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想与github仓库相同的架构一起工作，本节是必要的。继续从上一章的代码工作是完全可行的。
- en: 'If you remember, the goal of the previous chapter was to create a template
    that we can use to create a new gRPC project. As we will start such a project
    now, we will need to copy the content of the `chapter4` folder into the `chapter5`
    folder. To do that, simply run the following commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，上一章的目标是创建一个模板，我们可以用它来创建一个新的gRPC项目。既然我们现在要开始这样一个项目，我们需要将`chapter4`文件夹的内容复制到`chapter5`文件夹中。为此，只需运行以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We pass `–R` in our case because we want to recursively copy all the files in
    the `chapter4` folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们传递`–R`是因为我们想要递归地复制`chapter4`文件夹中的所有文件。
- en: 'And finally, we can also clean the template a little bit. We can remove the
    dummy directory in the `proto` folder because this was just there for testing
    our code generation. Then, if you used `bazel` for `chapter4`, we can delete all
    the build folders that start with the `bazel-` prefix. To do that, we can just
    simply remove them as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以稍微清理一下模板。我们可以在`proto`文件夹中删除虚拟目录，因为这个目录只是为了测试我们的代码生成。然后，如果你为`chapter4`使用了`bazel`，我们可以删除所有以`bazel-`前缀开始的构建文件夹。为此，我们只需简单地按照以下方式删除它们：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are now ready to use this template and see the different API endpoints that
    we can write with gRPC.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始使用这个模板，并查看我们可以使用gRPC编写的不同API端点。
- en: A Unary API
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一元API
- en: Important note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: In terms of the underlying protocol, as we mentioned in [*Chapter 1*](B19664_01.xhtml#_idTextAnchor014),
    *Networking Primer*, the Unary API uses `Send Header` followed by `Send Message`
    and `Half-Close` from the client side, and `Send Message` plus `Send Trailer`
    from the server side. If you need a refresher on these operations, I recommend
    you quickly check the *RPC operations* section in [*Chapter 1*](B19664_01.xhtml#_idTextAnchor014)
    of this book. This will help get a sense of what is going on when you are calling
    this API endpoint.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层协议方面，正如我们在[*第一章*](B19664_01.xhtml#_idTextAnchor014)中提到的，*网络基础*，一元API使用客户端的`Send
    Header`、`Send Message`和`Half-Close`，以及服务器端的`Send Message`和`Send Trailer`。如果您需要对这些操作进行复习，我建议您快速查看本书[*第一章*](B19664_01.xhtml#_idTextAnchor014)中的*RPC操作*部分。这将帮助您在调用此API端点时了解正在发生的事情。
- en: The easiest and most familiar API endpoint that you can write is a unary endpoint.
    These roughly translate to `GET`, `POST`, and other HTTP verbs that you probably
    worked with in REST APIs. You send a request and you get a response. Generally,
    these endpoints will be the ones that you use the most often to represent the
    treatment of one resource. For example, if you write a login method, you just
    need to send `LoginRequest` and receive `LoginResponse`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写的最简单且最熟悉的API端点是单参数端点。这些大致对应于`GET`、`POST`以及其他你可能已经在REST API中使用过的HTTP动词。你发送一个请求，然后得到一个响应。通常，这些端点将是你最常使用的，用于表示一个资源的处理。例如，如果你编写一个登录方法，你只需要发送`LoginRequest`并接收`LoginResponse`。
- en: For this section, we are going to write an RPC endpoint called `AddTask`. As
    its name suggests, this endpoint will create a new task in the list. So before
    being able to do that, we need to define what a *task* is.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将编写一个名为`AddTask`的RPC端点。正如其名称所暗示的，这个端点将在列表中创建一个新的任务。因此，在能够做到这一点之前，我们需要定义什么是*任务*。
- en: 'A task is an object that contains the following properties:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是一个包含以下属性的对象：
- en: '`id`: A number that is an identifier of that task'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：一个标识该任务的数字'
- en: '`description`: The actual task to be done and that the user reads'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：实际要完成的任务以及用户所阅读的内容'
- en: '`done`: Whether or not the task is already done'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done`：任务是否已经完成'
- en: '`due_date`: When this task is due'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`due_date`：当这个任务到期时'
- en: 'And if we translate that to Protobuf code, we would have something like the
    following (the file in `chapter5/proto/todo/v1` called `todo.proto`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些翻译成Protobuf代码，我们可能会有以下内容（位于`chapter5/proto/todo/v1`目录下的`todo.proto`文件）：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice the use of a `Timestamp` type here. This is a well-known type that is
    provided with Protobuf under the `google.protobuf` package. We are using this
    type to represent a point in time in the future at which the task should be completed.
    We could have rewritten our own `Date` type or used the `Date` type defined in
    the `googleapis` repository ([https://github.com/googleapis/googleapis/blob/master/google/type/date.proto](https://github.com/googleapis/googleapis/blob/master/google/type/date.proto))
    but `Timestamp` is sufficient for this API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里使用了`Timestamp`类型。这是一个在`google.protobuf`包下提供的知名类型。我们使用这个类型来表示任务应该在未来的某个时间点完成。我们可以重写我们自己的`Date`类型或使用在`googleapis`存储库中定义的`Date`类型（[https://github.com/googleapis/googleapis/blob/master/google/type/date.proto](https://github.com/googleapis/googleapis/blob/master/google/type/date.proto)），但`Timestamp`对于这个API来说已经足够了。
- en: 'Now that we have our task, we can think about our RPC endpoint. We want our
    endpoint to receive a task, which should be inserted into the list, and to return
    the identifier for that task to the client:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了任务，我们可以考虑我们的RPC端点。我们希望我们的端点能够接收一个任务，该任务应被插入到列表中，并返回该任务的标识符给客户端：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One important thing to notice here is that instead of using the `Task` message
    as the parameter for the `AddTask` endpoint, we created a wrapper (`AddTaskRequest`)
    around the necessary pieces of information for the endpoint. Nothing more, nothing
    less. We could have used the message directly but this may have led the client
    to send unnecessary data over the wire (e.g., setting the ID, which would be overlooked
    by the server). Furthermore, for future versions of our API, we could add more
    fields to `AddTaskRequest` without affecting the `Task` message. We effectively
    decouple the actual data representation for the request/response representation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的一个重要事项是，我们不是使用`Task`消息作为`AddTask`端点的参数，而是在端点所需的信息周围创建了一个包装器（`AddTaskRequest`）。不多也不少。我们本来可以直接使用消息，但这可能会导致客户端在网络上发送不必要的额外数据（例如，设置ID，这可能会被服务器忽略）。此外，对于我们API的将来版本，我们可以在`AddTaskRequest`中添加更多字段，而不会影响`Task`消息。我们有效地解耦了请求/响应的实际数据表示。
- en: Code generation
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码生成
- en: Important note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are unsure by now on how to generate code out of a proto file, I highly
    recommend that you check [*Chapter 4*](B19664_04.xhtml#_idTextAnchor136), where
    we presented three methods for doing that. In this chapter, we are going to generate
    everything manually, but you can find how to do the same with Buf and Bazel in
    the `chapter5` folder of the GitHub repository.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还不确定如何从proto文件生成代码，我强烈建议你查看[*第4章*](B19664_04.xhtml#_idTextAnchor136)，在那里我们介绍了三种生成代码的方法。在本章中，我们将手动生成一切，但你可以在GitHub存储库的`chapter5`目录中找到如何使用Buf和Bazel完成相同操作的方法。
- en: 'Now that we have created the interface for our API endpoint, we want to be
    able to implement the logic behind it. The first step to do that is to generate
    some Go code. To do that, we are going to use `protoc` and the `source_relative`
    value for the `paths` option. So, knowing that our `todo.proto` file is under
    `proto/todo/v1/`, we can run the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的API端点创建了接口，我们希望能够实现其背后的逻辑。为此，第一步是生成一些Go代码。为了做到这一点，我们将使用`protoc`和`paths`选项的`source_relative`值。所以，知道我们的`todo.proto`文件位于`proto/todo/v1/`下，我们可以运行以下命令：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After running that, you should have a `proto/todo/v1/` directory like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行之后，你应该有一个`proto/todo/v1/`目录，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That is all we need to get started.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们开始所需的所有内容。
- en: Inspecting the generated code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查生成的代码
- en: 'In the generated code, we have two files – the Protobuf-generated code and
    the gRPC code. The Protobuf-generated code is in a file called `todo.pb.go`. If
    we inspect this file, the most important thing that we can see is the following
    code (which is simplified):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的代码中，我们有两个文件——Protobuf生成的代码和gRPC代码。Protobuf生成的代码在一个名为`todo.pb.go`的文件中。如果我们检查这个文件，我们可以看到的最重要的事情是以下代码（这是简化的）：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This means we can now create `Task`, `TaskRequest`, and `TaskResponse` instances
    in our Go code, and that is exactly what we will do later in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在可以在Go代码中创建`Task`、`TaskRequest`和`TaskResponse`实例，这正是我们在本章后面将要做的。
- en: 'For the gRPC-generated code (`todo_grpc.pb.go`), there are interfaces generated
    for both the client and the server. They should look like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于gRPC生成的代码（`todo_grpc.pb.go`），为客户端和服务器都生成了接口。它们应该看起来像以下这样：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: They look similar, but the server-side `AddTask` is the only one that we need
    to implement the logic for. The client-side `AddTask` basically generates the
    request for calling the API endpoint on our server and returning us the response
    that it received.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来很相似，但服务器端的`AddTask`是我们唯一需要实现逻辑的。客户端的`AddTask`基本上是生成调用我们服务器上的API端点的请求，并返回它接收到的响应。
- en: Registering a service
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册服务
- en: 'To let gRPC know how to handle a certain request, we need to register the implementation
    of a service. To register such a service, we are going to call a generated function,
    which is present in `todo_grpc.pb.go`. In our case, this function is called `RegisterTodoServiceServer`
    and its function signature is the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让gRPC知道如何处理某个请求，我们需要注册服务的实现。为了注册这样的服务，我们将调用一个生成的函数，该函数存在于`todo_grpc.pb.go`中。在我们的例子中，这个函数叫做`RegisterTodoServiceServer`，其函数签名如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It takes `grpc.ServiceRegistrar`, which is an interface that `grpc.Server` implements,
    and takes `TodoServiceServer`, which is the interface that we saw earlier. This
    function will link the generic gRPC server provided by the framework with our
    implementation of the endpoints so that the framework knows how to handle requests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受`grpc.ServiceRegistrar`接口，这是`grpc.Server`实现的接口，以及`TodoServiceServer`接口，这是我们之前看到的接口。这个函数将把框架提供的通用gRPC服务器与我们的端点实现链接起来，以便框架知道如何处理请求。
- en: 'So, the first thing to do is to create our server. We are first going to create
    a struct that embeds `UnimplementedTodoServiceServer`, which is a generated struct
    that contains the default implementation of the endpoints. In our case, the default
    implementation is the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先要做的是创建我们的服务器。我们首先将创建一个嵌入`UnimplementedTodoServiceServer`的结构体，这是一个生成的结构体，其中包含端点的默认实现。在我们的例子中，默认实现如下：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we do not implement `AddTask` in our server, this endpoint will be called,
    and it will return an error every time we call it. Right now, that does not seem
    useful because this does nothing other than return an error, but the fact is that
    this is a safety net, and we are going to see why when we talk about evolving
    our APIs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在我们的服务器中实现`AddTask`，这个端点将被调用，并且每次调用它时都会返回一个错误。目前这看起来似乎没有用，因为这除了返回错误之外什么也不做，但事实是这是一个安全网，我们将在讨论API演变时看到原因。
- en: Next, our server will contain a reference to our database. You can adapt this
    to use any database you are familiar with, but in our case, we are going to abstract
    the database away with an interface because this will let us focus on gRPC and
    not on another technology such as, for example, MongoDB.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的服务器将包含对我们数据库的引用。你可以根据你熟悉的任何数据库进行适配，但在这个例子中，我们将使用接口来抽象数据库，因为这将让我们专注于gRPC，而不是其他技术，例如MongoDB。
- en: 'So, our server type (`server/server.go`) will look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的服务器类型（`server/server.go`）将看起来像这样：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let us see what the `db` interface looks like. We are going to first have
    a function called `addTask`, which takes a description and a `dueDate` value and
    returns the `id` value for the task created or an error. Now, the important thing
    to note is that this database interface should be decoupled from the generated
    code. This is, once again, due to the evolution of our API because if we were
    to change our endpoints or `Request`/`Response` objects, we would have to change
    our interface and all the implementations. Here, the interface is independent
    of the generated code. In `server/db.go`, we can now write the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `db` 接口的样子。我们首先将有一个名为 `addTask` 的函数，它接受一个描述和一个 `dueDate` 值，并返回创建的任务的
    `id` 值或错误。现在，需要注意的是，这个数据库接口应该与生成代码解耦。这再次是因为我们 API 的演变，因为如果我们改变端点或 `Request`/`Response`
    对象，我们就必须更改我们的接口和所有实现。在这里，接口与生成代码独立。在 `server/db.go` 中，我们现在可以编写以下内容：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This interface will let us test against fake database implementations and implement
    an in-memory database for non-release environments.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口将允许我们对伪造的数据库实现进行测试，并为非发布环境实现内存数据库。
- en: 'The last step is to implement the in-memory database. We are going to have
    a regular array of `Task` storing our to-dos and `addTask` will simply append
    a task to that array and return the ID of the current task. In a file called `server/in_memory.go`,
    we can add the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是实现内存数据库。我们将有一个常规数组 `Task` 来存储我们的待办事项，`addTask` 将简单地向该数组追加一个任务并返回当前任务的 ID。在名为
    `server/in_memory.go` 的文件中，我们可以添加以下内容：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are a few things to note about this implementation. First, this is probably
    obvious, but this is not an optimal “database” and is only used for development
    purposes. Second, without going into too much detail, we could use Golang build
    tags to choose the database we wanted to run at compile time. For example, if
    we had our `inMemoryDb` and a `mongoDb` implementation, we could have `go:build`
    tags at the top of each file. For `in_memory.go`, we could have the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个实现，有几个需要注意的事项。首先，这可能是显而易见的，但这不是一个最优的“数据库”，并且仅用于开发目的。其次，不深入细节，我们可以使用 Golang
    构建标签在编译时选择我们想要运行的数据库。例如，如果我们有 `inMemoryDb` 和 `mongoDb` 实现，我们可以在每个文件的顶部添加 `go:build`
    标签。对于 `in_memory.go`，我们可以有如下内容：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And for `mongodb.go`, we could have this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `mongodb.go`，我们可以有如下内容：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This would let us select at compile time which `New` function we wanted to use
    and thus create either an `inMemoryDb` or `mongoDb` instance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在编译时选择我们想要使用的 `New` 函数，从而创建 `inMemoryDb` 或 `mongoDb` 实例。
- en: Finally, you might have noticed that we are using the generated code in the
    implementation of this “database.” As this is a “database” that we use as a dev
    environment, it does not really matter if this implementation is coupled with
    our generated code. The most important thing is to not couple the `db` interface
    with it so that you can use any database without even having to deal with the
    generated code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能已经注意到，我们在实现这个“数据库”时使用了生成的代码。由于这是一个作为开发环境使用的“数据库”，这个实现是否与我们的生成代码耦合并不重要。最重要的是，不要将
    `db` 接口与其耦合，这样你就可以使用任何数据库，甚至无需处理生成代码。
- en: 'Now, we are finally ready to register our server type. To do that, we can just
    go into our `server/main.go main` function and add the following line:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于准备好注册我们的服务器类型了。为此，我们只需进入我们的 `server/main.go main` 函数并添加以下行：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This means that we have now linked the gRPC server called `s` to the server
    instance created. Note that the `New` function here is the function that we defined
    inside the `in_memory.go` file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在已经将名为 `s` 的 gRPC 服务器链接到了创建的服务器实例。请注意，这里的 `New` 函数是我们定义在 `in_memory.go`
    文件中的函数。
- en: Implementing AddTask
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 AddTask
- en: For the implementation, we are going to create a file called `server/impl.go`
    that will contain the implementation of all our endpoints. Note that this is purely
    for convenience and that you could have a file per RPC endpoint.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现，我们将创建一个名为 `server/impl.go` 的文件，该文件将包含所有端点的实现。请注意，这纯粹是为了方便，你也可以为每个 RPC 端点创建一个文件。
- en: 'Now, as you might remember, the generated interface for our server wants us
    to implement the following function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能还记得，我们服务器的生成接口要求我们实现以下函数：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, we can just add that function to our server type by writing the function
    preface with the name of the server instance and the server type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需将这个函数添加到我们的服务器类型中，通过编写以服务器实例名称和服务器类型命名的函数前缀即可：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, we can implement the function. This will call the `addTask` function
    from our `db` interface, and as this never returns errors (for now), we are going
    to take the given ID and return that as `AddTaskResponse`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现这个函数。这将调用我们的 `db` 接口中的 `addTask` 函数，由于目前这个函数从不返回错误（现在是这样），我们将获取给定的
    ID 并将其作为 `AddTaskResponse` 返回：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that `AsTime` is a function provided by the `google.golang.org/protobuf/types/known/timestamppb`
    package, which returns a Golang `time.Time` object. The `timestamppb` package
    is a collection of functions that lets us manipulate the `google.protobuf.Timestamp`
    object and use it in an idiomatic way in our Go code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`AsTime` 是由 `google.golang.org/protobuf/types/known/timestamppb` 包提供的一个函数，它返回一个
    Golang `time.Time` 对象。`timestamppb` 包是一组函数，允许我们操作 `google.protobuf.Timestamp`
    对象，并在我们的 Go 代码中以惯用的方式使用它。
- en: Right now, you might feel that this is too simplistic but remember that we are
    just at the beginning of our API. Later in the book, we will do error handling
    and see how to reject incorrect arguments.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可能觉得这太简单了，但请记住，我们刚刚开始我们的 API。在本书的后面部分，我们将进行错误处理，并了解如何拒绝不正确的参数。
- en: Calling AddTask from a client
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端调用 AddTask
- en: Finally, let us see how to call the endpoint from Go client code. This is simple
    since we already have the boilerplate that we created in the previous chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何从 Go 客户端代码中调用端点。这很简单，因为我们已经在上一章中创建了样板代码。
- en: 'We will create a function called `AddTask`, which will call the API endpoint
    that we registered in the server. To do so, we are going to need to pass an instance
    of `TodoServiceClient`, a description of the task, and a due date. We will create
    the client instance later but note that `TodoServiceClient` is the interface that
    we saw when we inspected the generated code. In `client/main.go`, we can add the
    following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `AddTask` 的函数，该函数将调用我们在服务器上注册的 API 端点。为此，我们需要传递一个 `TodoServiceClient`
    实例、任务的描述和截止日期。我们稍后会创建客户端实例，但请注意 `TodoServiceClient` 是我们在检查生成的代码时看到的接口。在 `client/main.go`
    中，我们可以添加以下内容：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After that, with the parameters, we can just construct a new instance of `AddTaskRequest`
    and send it to the server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用参数，我们只需构建一个新的 `AddTaskRequest` 实例并将其发送到服务器。
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we will receive either an `AddTaskResponse` or an error from our API
    call. If there is an error, we log that on the screen, and if there is not, we
    log and return the ID:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将从我们的 API 调用中接收到 `AddTaskResponse` 或错误。如果有错误，我们将在屏幕上记录它，如果没有错误，我们记录并返回
    ID：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To call this function, we need to use a generated function called `NewTodoServiceClient`,
    to which we pass a connection, and it returns a new instance of `TodoServiceClient`.
    And with that, we can simply add the following lines to the end of our `main`
    function in the client:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此函数，我们需要使用一个名为 `NewTodoServiceClient` 的生成函数，我们将一个连接传递给它，它返回一个新的 `TodoServiceClient`
    实例。然后，我们只需简单地将以下几行代码添加到客户端的 `main` 函数末尾：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that here we are adding a task with a five-second due date and a description
    of `This is a task`. This is just an example and I encourage you to try to make
    more calls by yourself with different values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里我们正在添加一个五秒截止日期和描述为 `This is a task` 的任务。这只是一个示例，我鼓励你自己尝试使用不同的值进行更多调用。
- en: 'Now, we can basically run our server and client and see how they are interacting.
    To run the server, use this `go` `run` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们基本上可以运行我们的服务器和客户端，看看它们是如何交互的。要运行服务器，使用这个 `go` `run` 命令：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And then, on another terminal, we can run the client in a similar way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中，我们可以以类似的方式运行客户端：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And finally, to kill the server, you can just press *Ctrl + C* in the terminal
    running it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要停止服务器，你只需在运行它的终端中按 *Ctrl + C* 即可。
- en: So, we can see that we have a service implementation registered to our server,
    and our client is correctly sending a request and getting a response back. What
    we made is a simple example of a Unary API endpoint.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到我们已经在服务器上注册了一个服务实现，我们的客户端正在正确地发送请求并返回响应。我们所做的是一个简单的 Unary API 端点示例。
- en: Bazel
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: Important note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: In this section, we will see how to run an application with Bazel. However,
    because it would become repetitive if every section had such an explanation, I
    wanted to warn you that we will not go through these steps each time. For each
    section, you can run the `bazel run` commands (for the server and client) that
    you will see under, and the `gazelle` command should be useful only for this section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用Bazel运行应用程序。然而，由于如果每个部分都有这样的说明就会变得重复，我想提醒您，我们不会每次都走这些步骤。对于每个部分，您都可以运行下面的`bazel
    run`命令（对于服务器和客户端），而`gazelle`命令仅适用于本节。
- en: 'At this point, your Bazel BUILD files are probably out of date. To synchronize
    them, we can simply run the `gazelle` command and it will update all our dependencies
    and files to compile:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的Bazel BUILD文件可能已经过时。为了同步它们，我们可以简单地运行`gazelle`命令，它将更新所有依赖项和文件以进行编译：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After that, we should be able to run the server and client easily by running
    this command to execute the server:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过运行以下命令轻松运行服务器和客户端来执行服务器：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Meanwhile, use the following to run the client:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，使用以下命令运行客户端：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is another example of how our server and client are working properly. We
    can run them with both the `go run` and `bazel run` commands. We are now confident
    with the Unary API; let us move to the server streaming API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的服务器和客户端工作正常的一个另一个例子。我们可以使用`go run`和`bazel run`命令来运行它们。我们现在对Unary API有信心；让我们转向服务器流式API。
- en: The server streaming API
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器流式API
- en: Important note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In terms of the underlying protocol, the server streaming API uses `Send Header`
    followed by `Send Message` and `Half-Close` from the client side, and multiple
    `Send Message` plus `Send Trailer` from the server side.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层协议方面，服务器流式API使用客户端的`Send Header`、`Send Message`和`Half-Close`，以及服务器端的多个`Send
    Message`和`Send Trailer`。
- en: Now, that we know how to register a service, interact with a “database,” and
    run our client and server, everything will be faster. We will focus mostly on
    the API endpoint itself. In our case, we are going to create a `ListTasks` endpoint,
    which, as its name suggests, lists all the available tasks in the database.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何注册服务、与“数据库”交互以及运行客户端和服务器后，一切都会更快。我们将主要关注API端点本身。在我们的例子中，我们将创建一个`ListTasks`端点，正如其名称所暗示的，它将列出数据库中所有可用的任务。
- en: One thing that we are going to do to make this a little bit fancier is that
    for each task listed, we are going to return whether this task is overdue or not.
    This is mostly done so that you can see how to provide more information about
    a certain object in the `response` object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的其中一件事是，对于每个列出的任务，我们将返回该任务是否已过期。这样做主要是为了让您了解如何在`response`对象中提供有关某个对象的更多信息。
- en: 'So, in the `todo.proto` file, we are going to add an RPC endpoint called `ListTasks`,
    which will take `ListTasksRequest` and return a stream of `ListTasksResponse`.
    This is what a server streaming API is. We get one request and return zero or
    more responses:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`todo.proto`文件中，我们将添加一个名为`ListTasks`的RPC端点，它将接受`ListTasksRequest`并返回一个`ListTasksResponse`流。这就是服务器流式API。我们接收一个请求并返回零个或多个响应：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that this time, we send an empty object as a request, and we get multiple
    `Task` and whether they are overdue. We could make the request a bit more intelligent
    by sending a range of IDs of tasks we want to list (paging), but for the sake
    of conciseness, we have chosen to make it simple.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们发送一个空对象作为请求，并获取多个`Task`及其是否过期。我们可以通过发送我们想要列出的任务ID范围（分页）来使请求更加智能，但为了简洁起见，我们选择使其简单。
- en: Evolving the database
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库的演变
- en: 'Before being able to implement the `ListTasks` endpoint, we need a way to access
    all the elements in our TODO list. Once again, we do not want to tie the `db`
    interface to our generated code, so we have a few choices:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够实现`ListTasks`端点之前，我们需要一种方法来访问我们的TODO列表中的所有元素。再次强调，我们不希望将`db`接口绑定到我们的生成代码，因此我们有几种选择：
- en: We create some abstractions to iterate over the tasks. This might be fine for
    our in-memory database, but how would this work with Postgres, for example?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一些抽象来遍历任务。这对于我们的内存数据库可能很好，但例如与Postgres一起使用时会如何呢？
- en: We tie our interface to an already existing abstraction such as cursors for
    databases. This is a bit better, but we still couple our interface.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将我们的接口绑定到一个已经存在的抽象，例如数据库的游标。这稍微好一些，但我们仍然耦合了我们的接口。
- en: We simply leave the iteration to our implementation of the `db` interface and
    we apply a user-provided function to all the rows. With this, we are not coupled
    to any other component.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只是将迭代留给我们的`db`接口实现，并将一个用户提供的函数应用于所有行。这样，我们就不会耦合到任何其他组件。
- en: 'So, we are going to leave iteration to the implementation of our interface.
    This means that the new function that we will add to `inMemoryDb` will iterate
    over all the tasks and apply a function given as a parameter to each:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将迭代留给我们的接口实现。这意味着我们将要添加到`inMemoryDb`的新函数将遍历所有任务并将一个作为参数提供的函数应用于每一个：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the function passed as a parameter will itself get an `interface{}`
    as a parameter. This is not type-safe; however, we are going to make sure that
    we receive a `Task` at runtime when dealing with it later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，作为参数传递的函数本身将获得一个`interface{}`作为参数。这并不是类型安全的；然而，我们将确保在稍后处理时运行时接收一个`Task`。
- en: 'Then, for the in-memory implementation, we have the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于内存实现，我们有以下内容：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There is one thing to notice here. We are going to make errors fatal to the
    process. If the user-provided function returns an error, the `getTasks` function
    will return an error.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个需要注意的地方。我们将使错误对进程致命。如果用户提供的函数返回一个错误，`getTasks`函数将返回一个错误。
- en: That is it for the database; we can now get all the tasks from it and apply
    some kind of logic to the tasks. Let us implement `ListTasks`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是数据库的全部内容；我们现在可以从它获取所有任务并对任务应用某种逻辑。让我们实现`ListTasks`。
- en: Implementing ListTasks
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现ListTasks
- en: 'To implement the endpoint, let us generate the Go code out of the proto files
    and take the function signature that we need to implement. We just run the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现端点，让我们从proto文件生成Go代码，并取我们需要实现的函数签名。我们只需运行以下命令：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And if we look at `proto/todo/v1/todo_grpc.pb.go`, we can now see that the
    `TodoServiceServer` interface has one more function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`proto/todo/v1/todo_grpc.pb.go`，我们现在可以看到`TodoServiceServer`接口有一个额外的函数：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, the signature changed a bit from the one we had from the `AddTask`
    function. We now only return an error or `nil`, and we have `TodoService_ListTasksServer`
    as a parameter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，签名与从`AddTask`函数得到的签名略有不同。我们现在只返回一个错误或`nil`，并且我们将`TodoService_ListTasksServer`作为一个参数。
- en: 'If you dig deeper into the generated code, you will see that `TodoService_ListTasksServer`
    is defined as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入研究生成的代码，你会看到`TodoService_ListTasksServer`被定义为以下内容：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a stream on which you can send `ListTasksResponse` objects.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以发送`ListTasksResponse`对象的流。
- en: 'Now that we know that, let us implement the function in our code. We can go
    to the `impl.go` file under the server and copy and paste the function signature
    of `ListTasks` into `TodoServiceServer`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这一点，让我们在我们的代码中实现这个函数。我们可以进入服务器下的`impl.go`文件，并将`ListTasks`函数的签名复制粘贴到`TodoServiceServer`中：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Obviously, we added the server type to specify that we are implementing `ListTasks`
    for our server and we named the parameters. `req` is the request that we receive
    from the client and `stream` is the object that we are going to use to send multiple
    answers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们添加了服务器类型来指定我们正在为我们的服务器实现`ListTasks`，并且我们命名了参数。`req`是我们从客户端接收的请求，`stream`是我们将用来发送多个答案的对象。
- en: 'Then, the logic of our function is once again straightforward. We are going
    to loop over all tasks, making sure that we are dealing with `Task` objects, and
    for each of these tasks, we are going to “calculate” the overdue by checking whether
    these tasks are done (with no overdue for tasks that are done) and whether the
    `due_date` field is before the current time. In summary, we will just create `ListTasksResponse`
    with this information and send that to the client (`server/impl.go`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们函数的逻辑再次简单明了。我们将遍历所有任务，确保我们处理的是`Task`对象，并且对于这些任务中的每一个，我们将“计算”逾期情况，通过检查这些任务是否完成（对于完成的任务没有逾期）以及`due_date`字段是否在当前时间之前。总之，我们将只创建包含这些信息的`ListTasksResponse`并发送给客户端（`server/impl.go`）：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One thing to notice is that the `AsTime` function will create a time in the
    UTC time zone, so when you compare a time with it you need it to also be in UTC.
    That is why we have `time.Now().UTC()` and not simply `time.Now()`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的地方是，`AsTime`函数将创建一个UTC时区的时间，所以当你与它比较时间时，也需要它也在UTC时区。这就是为什么我们有`time.Now().UTC()`而不是简单地`time.Now()`。
- en: There are obviously ways in which this function can fail (e.g., what if the
    variable called `t` is not a `Task`?) but right now, let us not worry too much
    about error handling. We are going to see that later. Let us now call this endpoint
    from the client.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个函数可能会失败（例如，如果名为`t`的变量不是一个`Task`怎么办？）但现阶段，我们不必过于担心错误处理。我们稍后会看到。现在，让我们从客户端调用这个端点。
- en: Calling ListTasks from a client
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端调用ListTasks
- en: 'To call the `ListTasks` API endpoint from the client, we need to understand
    how to consume a server-streaming RPC endpoint. To do so, we check the method
    signature or the generated function in the interface name’s `TodoServiceClient`.
    It should look like the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要从客户端调用`ListTasks` API端点，我们需要了解如何消费服务器流式RPC端点。要做到这一点，我们检查方法签名或接口名称中的生成函数`TodoServiceClient`。它应该看起来像以下这样：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can see that we will need to pass a context and a request and that there
    are some optional call options. Then, we can also see that we will get a `TodoService_ListTasksClient`
    or an error. The `TodoService_ListTasksClient` type is very similar to the stream
    we dealt with in the `ListTasks` endpoint. The main difference though is that,
    instead of having a function called `Send`, we now have a function called `Recv`.
    Here is the definition of `TodoService_ListTasksClient`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们需要传递一个上下文和一个请求，还有一些可选的调用选项。然后，我们还可以看到我们将得到一个`TodoService_ListTasksClient`或一个错误。`TodoService_ListTasksClient`类型与我们之前在`ListTasks`端点中处理的流非常相似。不过，主要的区别是，我们不再有一个名为`Send`的函数，我们现在有一个名为`Recv`的函数。以下是`TodoService_ListTasksClient`的定义：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So, what we are going to do with this stream is we are going to loop over all
    the responses that we can get from `Recv`, and then at some point, the server
    will say: “I am done.” This happens when we get an error that is equal to `io.EOF`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将如何处理这个流呢？我们将遍历从`Recv`获取的所有响应，然后某个时刻，服务器会说：“我完成了。”这发生在我们得到一个等于`io.EOF`的错误时。
- en: 'We can create a function in `client/main.go` called `printTasks` that will
    repeatedly call `Recv` and check whether we are finished or have an error, and
    if that is not the case, it will print the string representation of our `Task`
    object on the terminal:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`client/main.go`中创建一个名为`printTasks`的函数，该函数将反复调用`Recv`并检查我们是否完成或有错误，如果没有这种情况，它将在终端上打印我们的`Task`对象的字符串表示：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once we have this, we can call that function after the `addTask` call that
    we made in our `main` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们就可以在`main`函数中`addTask`调用之后调用该函数：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now use `go run` to run our server first and then our client. So, at
    the root of the project, we can run the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`go run`先运行我们的服务器，然后是我们的客户端。所以，在项目的根目录下，我们可以运行以下命令：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And then, we run our client:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行我们的客户端：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This works as expected. Now, I would encourage you to try to add more tasks
    by yourself, try different values, and use the `printTasks` function after adding
    them all. This should help you get familiar with the API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如预期的那样工作。现在，我鼓励你尝试自己添加更多任务，尝试不同的值，并在添加所有任务后使用`printTasks`函数。这应该有助于你熟悉API。
- en: Now that we can add tasks and list them all, it would be nice if we could update
    already existing tasks. This might be interesting for marking a task as done and
    changing the due date. We are going to test that through the client streaming
    API.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够添加任务并列出所有任务，如果我们可以更新已经存在的任务那就太好了。这可能对标记任务为完成和更改截止日期很有用。我们将通过客户端流式API来测试这一点。
- en: The client streaming API
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端流式API
- en: Important note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In terms of the underlying protocol, the client streaming API uses `Send Header`
    followed by multiple `Send Message` and a `Half-Close` from the client side, and
    `Send Message` plus `Send Trailer` from the server side.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层协议方面，客户端流式API使用客户端的`Send Header`，然后是多个`Send Message`和一个`Half-Close`，以及服务器端的`Send
    Message`和`Send Trailer`。
- en: With client streaming API endpoints, we can send zero or more requests and get
    one response. This is an important concept, especially for uploading data in real
    time. An example of this could be that we click on an edit button in our frontend,
    which triggers an edit session, and we post each edit being made in real time.
    Obviously, since we are not working with such fancy frontends, we are only going
    to focus on making the API compatible with this kind of feature.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端流式API端点，我们可以发送零个或多个请求并得到一个响应。这是一个重要的概念，尤其是在实时上传数据时。一个例子可能是我们在前端点击一个编辑按钮，这会触发一个编辑会话，并且我们实时地发布每个编辑。显然，由于我们不是在处理这样复杂的前端，我们只会关注使API与这种功能兼容。
- en: 'To define a client streaming API, we simply need to write the `stream` keyword
    in the parameter clause instead of `return`. Previously, for our server streaming,
    we had the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个客户端流式 API，我们只需在参数子句中写入 `stream` 关键字而不是 `return`。之前，对于我们的服务器流式，我们有以下内容：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we will have the following for `UpdateTasks`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将有以下的 `UpdateTasks`：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that, in this case, we are using the full Task message in the request,
    not separated fields like in `AddTask`. This is not a mistake and we will talk
    about this more during `chapter6`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们使用的是完整的 Task 消息作为请求，而不是像 `AddTask` 中的那样分开的字段。这并不是一个错误，我们将在第 6 章中进一步讨论这个问题。
- en: This effectively means that the client sends multiple requests, and the server
    returns one response. We are now one step closer to implementing our endpoint.
    However, let us talk about the database before doing that.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着客户端发送多个请求，服务器返回一个响应。我们现在又向实现端点迈进了一步。然而，在这样做之前，让我们先谈谈数据库。
- en: Evolving the database
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库的演变
- en: Before thinking about implementing `UpdateTasks`, we need to see how we interact
    with the database. The first thing to consider is what information can be updated
    for a given task. In our case, we do not want the client to be able to update
    an ID; this is a detail that is handled by the database. However, for all the
    other information, we want to let the user be able to update it. When a task is
    done, we need to be able to set `done` to `true`. When the `Task` description
    needs updating, the client should be able to change it in the database. And finally,
    when the due date changes, the client should also be able to update it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑实现 `UpdateTasks` 之前，我们需要看看我们如何与数据库交互。首先考虑的是，对于给定的任务，可以更新哪些信息。在我们的案例中，我们不希望客户端能够更新
    ID；这是由数据库处理的一个细节。然而，对于所有其他信息，我们希望让用户能够更新它。当任务完成时，我们需要能够将 `done` 设置为 `true`。当 `Task`
    描述需要更新时，客户端应该能够在数据库中更改它。最后，当截止日期更改时，客户端也应该能够更新它。
- en: 'Knowing that, we can define our function signature for `updateTask` in our
    database. It will take the task ID and all the information that can be changed
    as parameters and return an error or `nil`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些后，我们可以在数据库中定义 `updateTask` 的函数签名。它将接受任务 ID 和所有可以更改的信息作为参数，并返回一个错误或 `nil`：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once again, it looks a little bit much to pass that many parameters, but we
    do not want to couple this interface with any of the generated code. If later
    we need to add more information or remove some, this is as easy as updating this
    interface and updating the implementation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，传递这么多参数看起来有点多，但我们不希望将此接口与任何生成的代码耦合。如果我们以后需要添加更多信息或删除一些，这就像更新此接口和更新实现一样简单。
- en: 'Now, to implement that, we are going to go to the `in_memory.go` file. The
    function will simply iterate through all the tasks in the database, and if any
    `Task` has the same ID as the ID passed in the parameter, we will update all the
    fields one by one:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了实现这一点，我们将进入 `in_memory.go` 文件。该函数将简单地遍历数据库中的所有任务，如果任何 `Task` 的 ID 与参数中传入的
    ID 相同，我们将逐个更新所有字段：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that means that every time we receive a request, we are going to iterate
    through all the tasks. This is not highly efficient, especially when the database
    becomes bigger. However, we are also not working with a real database so it should
    be good enough for our use case in this book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次我们收到请求时，我们都会遍历所有任务。这并不高效，尤其是在数据库变得更大时。然而，我们也不是在处理真实的数据库，所以对于这本书中的用例来说应该足够好了。
- en: Implementing UpdateTasks
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 UpdateTasks
- en: 'To implement the endpoint, let us generate the Go code out of the proto files
    and take the function signature that we need to implement. We just run the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现端点，让我们从 proto 文件生成 Go 代码，并获取我们需要实现的函数签名。我们只需运行以下命令：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And if we look at `proto/todo/v1/todo_grpc.pb.go`, we can now see that the
    `TodoServiceServer` interface has one more function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `proto/todo/v1/todo_grpc.pb.go`，我们现在可以看到 `TodoServiceServer` 接口有一个额外的函数：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we can see, the signature changed is similar to `ListTasks`; however, this
    time, we do not even deal with a request. We simply deal with a stream of the
    `TodoService_UpdateTasksServer` type. If we check the `TodoService_UpdateTasksServer`
    type definition, we have the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，签名变更类似于 `ListTasks`；然而，这次我们甚至不处理请求。我们只是处理 `TodoService_UpdateTasksServer`
    类型的流。如果我们检查 `TodoService_UpdateTasksServer` 类型的定义，我们会看到以下内容：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We are already familiar with the `Recv` function. It lets us get an object,
    but now we also have a `SendAndClose` function. This function lets us tell the
    client that we are done on the server side. This is used to close the stream when
    the client sends an `io.EOF`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了`Recv`函数。它让我们获取一个对象，但现在我们还有一个`SendAndClose`函数。这个函数让我们告诉客户端我们在服务器端已完成。这用于在客户端发送`io.EOF`时关闭流。
- en: 'Armed with that knowledge, we can implement our endpoint. We are going to repeatedly
    call the `Recv` function on the stream, and if we receive an `io.EOF`, we will
    use the `SendAndClose` function; otherwise, we will call the `updateTask` function
    on our database:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们可以实现我们的端点。我们将反复在流上调用`Recv`函数，如果我们收到`io.EOF`，我们将使用`SendAndClose`函数；否则，我们将调用我们数据库上的`updateTask`函数：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We should now be able to trigger this API endpoint to change a given set of
    `Task` in real time. Let us now see how a client can call the endpoint.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够触发这个API端点以实时更改一组`Task`。现在让我们看看客户端如何调用端点。
- en: Calling UpdateTasks from a client
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端调用UpdateTasks
- en: This time, since we are working with client streaming, we are going to do the
    opposite from what we did for server streaming. The client will repeatedly call
    `Send` and the server will repeatedly call `Recv`. And in the end, the client
    will call the `CloseAndRecv` function, which is defined in the generated code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，因为我们正在处理客户端流，我们将与服务器流相反。客户端将反复调用`Send`，服务器将反复调用`Recv`。最后，客户端将调用定义在生成的代码中的`CloseAndRecv`函数。
- en: 'If we look at the generated code for `UpdateTasks` on the client side, we will
    see the following signature in the `TodoServiceClient` type:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看客户端的`UpdateTasks`生成的代码，我们将在`TodoServiceClient`类型中看到以下签名：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Notice that now the `UpdateTasks` function does not take any `request` parameters,
    but it will return a stream of the `TodoService_UpdateTasksClient` type. This
    type, as mentioned, will contain two functions: `Send` and `CloseAndRecv`. If
    we look at the generated code, we have the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在`UpdateTasks`函数不再接受任何`request`参数，但它将返回一个`TodoService_UpdateTasksClient`类型的流。正如提到的，这个类型将包含两个函数：`Send`和`CloseAndRecv`。如果我们查看生成的代码，我们将看到以下内容：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`Send` is sent `UpdateTasksRequest` and `CloseAndRecv` will tell the server
    that it is done sending requests and ask for `UpdateTasksResponse`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send`发送`UpdateTasksRequest`，而`CloseAndRecv`将通知服务器它已完成发送请求，并请求`UpdateTasksResponse`。'
- en: 'Now that we understand that we can implement the `UpdateTasks` function in
    the `client/main.go` file, we are going to call the `UpdateTasks` function from
    the gRPC client. This will return a stream and then we are going to send given
    tasks through it. Once we have looped through all the tasks that needed to be
    updated, we will call the `CloseAndRecv` function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了，我们可以在`client/main.go`文件中实现`UpdateTasks`函数，我们将从gRPC客户端调用`UpdateTasks`函数。这将返回一个流，然后我们将通过它发送给定的任务。一旦我们遍历了所有需要更新的任务，我们将调用`CloseAndRecv`函数：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, as you can see in `updateTasks`, we need to pass zero or more `UpdateTasksRequest`
    as parameters. To get the IDs needed to create task instances and fill the `UpdateTasksRequest.task`
    field, we are going to record the IDs of tasks created before with `addTasks`.
    So, formerly, we had the following in `main`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你在`updateTasks`中看到的，我们需要传递零个或多个`UpdateTasksRequest`作为参数。为了获取创建任务实例并填充`UpdateTasksRequest.task`字段所需的ID，我们将使用`addTasks`记录之前创建的任务的ID。因此，以前在`main`中我们有以下内容：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will now have something like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将得到以下类似的内容：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And now, we can create an array of `UpdateTasksRequest` just like so:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个`UpdateTasksRequest`数组，就像这样：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This means that the `Task` object with `id1` will be updated to have a new description,
    the `Task` object with `id2` will be updated to have a new `due_date` value, and
    finally, the last one will be marked as `done`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着具有`id1`的`Task`对象将被更新为具有新的描述，具有`id2`的`Task`对象将被更新为具有新的`due_date`值，最后，最后一个将被标记为`done`。
- en: 'We can now pass the client to `updateTasks` and expand this array as a variadic
    parameter by using the `…` operator. In `main`, we can now add the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将客户端传递给`updateTasks`，并通过使用`…`操作符将这个数组作为可变参数展开。在`main`函数中，我们现在可以添加以下内容：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can now run that in a similar way to the previous sections. We use `go run`
    to run the server first:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以以类似前几节的方式运行它。我们使用`go run`首先运行服务器：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And then we run the client to call the API endpoint:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行客户端来调用API端点：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Before moving on, there is an important thing to note here. You might be a
    little bit surprised about the fact that the tasks lost some information when
    updating them. This is because Protobuf will use the default value of a field
    when it is not set – meaning that if the client sends a `Task` object with only
    `done` being equal to `true`, the description will be deserialized as an empty
    string and `due_date` will be an empty `google.protobuf.Timestamp`. For now, this
    is highly inefficient because we need to resend all the information to update
    a single field. Later in the book, we are going to talk about how to solve this
    issue. We can now update multiple tasks in real time based on their IDs. Let us
    now move to the last API type available: bidirectional streaming.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，这里有一个重要的事情需要注意。你可能会对任务在更新时丢失一些信息的事实感到惊讶。这是因为Protobuf会在字段未设置时使用默认值——这意味着如果客户端发送一个只有`done`等于`true`的`Task`对象，描述将被反序列化为空字符串，而`due_date`将是一个空的`google.protobuf.Timestamp`。目前，这非常低效，因为我们需要重新发送所有信息来更新单个字段。在本书的后面，我们将讨论如何解决这个问题。现在，我们可以根据它们的ID实时更新多个任务。现在，让我们转向最后一种可用的API类型：双向流。
- en: The bidirectional streaming API
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向流式API
- en: Important note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: In terms of the underlying protocol, the bidirectional streaming API uses `Send
    Header` from the client side, followed by multiple `Send Message` from the server
    and/or client side, `Half-Close` from the client side, and finally `Send Trailer`
    from the server side.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就底层协议而言，双向流式API使用客户端的`Send Header`，然后是服务器和/或客户端的多个`Send Message`，客户端的`Half-Close`，最后是服务器的`Send
    Trailer`。
- en: In a bidirectional streaming API, the goal is to let the client send zero or
    more requests and let the server send zero or more responses. We are going to
    use this to simulate a feature that is like `updateTasks` but in which we are
    going to have direct feedback from the `DeleteTasks` endpoint API after each deletion
    instead of waiting for all the deletions to be done.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向流式API中，目标是让客户端发送零个或多个请求，并让服务器发送零个或多个响应。我们将使用这一点来模拟一个类似于`updateTasks`的功能，但在其中，我们将在每次删除后直接从`DeleteTasks`端点API获得反馈，而不是等待所有删除操作完成。
- en: One thing to be clear about before continuing with the implementation is the
    question of why not to design `DeleteTasks` as a server streaming API or `updateTasks`
    as a bidirectional streaming API. The difference between these two tasks is how
    “destructive” they are. We can make an update directly on the client even before
    sending the requests to the server. If any error is present, we can simply look
    at the list we have on the client and synchronize it with the one on the server
    depending on the modified time. For a deletion, this would be a little bit more
    involved. We could keep the deleted row on the client and garbage would collect
    it later, or we would need to store the information somewhere else to synchronize
    it with the server. This creates a little bit more overhead.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续实施之前，需要明确的一点是关于为什么不将`DeleteTasks`设计为服务器流式API或`updateTasks`设计为双向流式API的问题。这两个任务之间的区别在于它们的“破坏性”程度。我们可以在发送请求到服务器之前直接在客户端进行更新。如果存在任何错误，我们只需查看客户端上的列表，并根据修改时间将其与服务器上的列表同步。对于删除操作，这会稍微复杂一些。我们可以在客户端保留已删除的行，稍后由垃圾回收器回收，或者我们需要在其他地方存储信息以与服务器同步。这会带来更多的开销。
- en: 'So, we are going to send multiple `DeleteTasksRequest`, and for each, we are
    going to have the confirmation that it was deleted. And, if an error occurs, we
    are still sure that the tasks preceding the error were deleted on the server.
    Our RPC and messages look like the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将发送多个`DeleteTasksRequest`，并且对于每一个，我们将得到确认它已被删除。如果发生错误，我们仍然可以确信错误之前的任务已在服务器上删除。我们的RPC和消息如下所示：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We repeatedly send the ID of the `Task` we want to delete, and if we receive
    a `DeleteTasksResponse`, this means that the task was deleted. Otherwise, we get
    an error.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们反复发送我们想要删除的`Task`的ID，如果我们收到`DeleteTasksResponse`，这意味着任务已被删除。否则，我们会得到一个错误。
- en: Now, before diving into the implementation, let us look at our database interface.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在深入实施之前，让我们看看我们的数据库接口。
- en: Evolving the database
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库的演变
- en: 'As we want to remove a `Task` object in the database, we are going to need
    a `deleteTask` function. This function will take an ID of the `Task` object to
    be deleted, act on it, and return an error or nil. We can add the following function
    to `server/db.go`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想要在数据库中删除一个 `Task` 对象，我们将需要一个 `deleteTask` 函数。这个函数将接受要删除的 `Task` 对象的 ID，对其执行操作，并返回一个错误或
    nil。我们可以在 `server/db.go` 中添加以下函数：
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Implementing that looks a lot like `updateTask`. However, instead of updating
    information when we find the task with the right ID, we are going to delete it
    with a `go slice` trick. In `server/in_memory.go`, we now have the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 实现起来很像 `updateTask`。然而，当我们找到具有正确 ID 的任务时，我们不会更新信息，而是使用 `go slice` 技巧来删除它。在 `server/in_memory.go`
    中，我们现在有以下内容：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The slice trick takes the elements after the current task and appends them to
    the previous task. This effectively overrides the current task in the array and
    thus deletes it. With that, we are now ready to implement the `DeleteTasks` endpoint.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 切片技巧将当前任务之后的元素追加到前一个任务中。这实际上覆盖了数组中的当前任务，从而删除了它。有了这个，我们现在可以准备实现 `DeleteTasks`
    端点。
- en: Implementing DeleteTasks
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现删除任务
- en: 'Before implementing the actual endpoint, we need to understand how we will
    deal with the generated code. So, let us generate the code with the following
    command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现实际端点之前，我们需要了解我们将如何处理生成的代码。因此，让我们使用以下命令生成代码：
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And if we check `todo_grpc.pb.go` in the `proto/todo/v1` folder, we should
    have the following function added to `TodoServiceServer`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 `proto/todo/v1` 文件夹中的 `todo_grpc.pb.go`，我们应该在 `TodoServiceServer` 中添加以下函数：
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is similar to the `UpdateTasks` function because we get a stream, and
    we return either an error or nil. However, instead of having `Send` and `SendAndClose`
    functions, we now have `Send` and `Recv`. `TodoService_DeleteTasksServer` is defined
    like so:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `UpdateTasks` 函数类似，因为我们得到一个流，我们返回一个错误或 nil。然而，我们没有 `Send` 和 `SendAndClose`
    函数，我们现在有 `Send` 和 `Recv`。`TodoService_DeleteTasksServer` 定义如下：
- en: '[PRE64]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This means that, in our case, we can call `Recv` to get a `DeleteTasksRequest`,
    and for each of them we are going to send a `DeleteTasksResponse`. Finally, since
    we are working with a stream, we still need to check for errors and `io.EOF`.
    When we get `io.EOF`, we will just end the function with `return`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在我们的情况下，我们可以调用 `Recv` 来获取 `DeleteTasksRequest`，然后为每个请求发送一个 `DeleteTasksResponse`。最后，因为我们正在处理流，我们仍然需要检查错误和
    `io.EOF`。当我们得到 `io.EOF` 时，我们只需使用 `return` 结束函数：
- en: '[PRE65]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: One thing to note here is the `stream.Send` call. Even though this is simple,
    this is what differentiates client streaming from bidirectional streaming. If
    we did not have that call, we would effectively send multiple requests from the
    client, and in the end, the server would return `nil` to close the stream. This
    would be exactly the same as `UpdateTasks`. But because of the `Send` call, we
    now have direct feedback after each deletion.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是 `stream.Send` 调用。尽管这很简单，但这区分了客户端流和双向流。如果我们没有这个调用，我们实际上会从客户端发送多个请求，最终服务器会返回
    `nil` 来关闭流。这将与 `UpdateTasks` 完全相同。但因为 `Send` 调用，我们现在在每次删除后都有直接的反馈。
- en: Calling UpdateTasks from the client
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端调用 UpdateTasks
- en: 'Now that we have our endpoint, we can call it from the client. Before we can
    do it though, we need to look at the generated code for `TodoServiceClient`. We
    should now have the following function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的端点，我们可以从客户端调用它。在我们这样做之前，我们需要查看 `TodoServiceClient` 生成的代码。我们现在应该有以下函数：
- en: '[PRE66]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once again, this is similar to what we saw in the `ListTasks` and `UpdateTasks`
    functions because it returns a string that we can interact with. However, as you
    can guess, we can now use `Send` and `Recv`. `TodoService_DeleteTasksClient` looks
    like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与我们在 `ListTasks` 和 `UpdateTasks` 函数中看到的内容类似，因为它返回一个我们可以与之交互的字符串。然而，正如你所猜到的，我们现在可以使用
    `Send` 和 `Recv`。`TodoService_DeleteTasksClient` 看起来是这样的：
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With that generated code and the underlying gRPC framework, we can now send
    multiple `DeleteTasksRequest` and get multiple `DeleteTasksResponse`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个生成的代码和底层的 gRPC 框架，我们现在可以发送多个 `DeleteTasksRequest` 并获取多个 `DeleteTasksResponse`。
- en: Now, we are going to create a new function in `client/main.go` that will take
    variadic parameters of `DeleteTasksRequest`. Then, we are going to create a channel
    that will help us wait for the entire process of receiving and sending to finish.
    If we did not do that, we would return from the function before finishing. This
    channel will be used in a goroutine that will use `Recv` in the background. Once
    we receive an `io.EOF` in this goroutine, we are going to close the channel. Finally,
    we are going to go over all the requests and send them, and once we are done,
    we are going to wait for the channel to be closed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `client/main.go` 中创建一个新的函数，该函数将接受 `DeleteTasksRequest` 的可变参数。然后，我们将创建一个通道，它将帮助我们等待接收和发送的整个过程的完成。如果我们没有这样做，我们会在完成之前从函数中返回。这个通道将在一个goroutine中使用，该goroutine将在后台使用
    `Recv`。一旦在这个goroutine中接收到 `io.EOF`，我们将关闭这个通道。最后，我们将遍历所有请求并发送它们，一旦完成，我们将等待通道关闭。
- en: 'This might seem a little bit abstract right now but think about the job that
    the client needs to do. It needs to use `Recv` and `Send` simultaneously; thus,
    we need some simple concurrent code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能现在看起来有点抽象，但想想客户需要完成的任务。它需要同时使用 `Recv` 和 `Send`；因此，我们需要一些简单的并发代码：
- en: '[PRE68]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, before running our server and client, let us call that function in
    the `main` function. We are going to delete all the tasks that we created with
    `addTasks` and prove that there are no more tasks by trying to print all of them:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在运行服务器和客户端之前，让我们在 `main` 函数中调用该函数。我们将删除使用 `addTasks` 创建的所有任务，并通过尝试打印所有任务来证明没有更多任务：
- en: '[PRE69]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'With that, we can run the server first:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过那样，我们可以先运行服务器：
- en: '[PRE70]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And then we can run our client:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以运行我们的客户端：
- en: '[PRE71]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice here that, instead of having a single response like client streaming,
    we have three responses (three `deleted tasks`). This is because we get a response
    per request. We effectively implemented bidirectional streaming.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，与客户端流只有一个响应不同，我们有三个响应（三个已删除的任务）。这是因为我们对每个请求都得到一个响应。我们实际上实现了双向流。
- en: We implemented bidirectional streaming here, which let us get feedback for each
    request we sent to the server. With that, we can make sure that we update resources
    on the client side without having to wait for a response or error from the server.
    This is interesting for use cases like ours that need real-time updates.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实现了双向流，这使得我们可以获取我们发送给服务器的每个请求的反馈。有了这个，我们可以确保在不需要等待服务器响应或错误的情况下更新客户端的资源。这对于需要实时更新的用例来说很有趣。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw the different types of APIs we can write in gRPC. We
    saw that we can create similar API endpoints as the ones we are used to in REST
    APIs. These endpoints are called unary endpoints. Then, we saw that we can make
    server streaming APIs to let the server return multiple responses. Similarly,
    we saw that a client can return multiple requests with client streaming. And finally,
    we saw that we can “mix” server and client streaming to get bidirectional streaming.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了我们可以编写的不同类型的 gRPC API。我们看到了我们可以创建与我们在 REST API 中熟悉的类似 API 端点。这些端点被称为单一端点。然后，我们看到了我们可以创建服务器流
    API，让服务器返回多个响应。同样，我们看到了客户端可以通过客户端流返回多个请求。最后，我们看到了我们可以“混合”服务器和客户端流以获得双向流。
- en: Our current endpoints are simplistic and do not handle a lot of cases that are
    crucial for production-grade APIs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的端点很简单，没有处理对生产级 API 至关重要的许多情况。
- en: In the next chapter, we will start seeing what we can improve at the API level.
    This will let us first focus on the usability of the API before diving deeper
    into all the aspects of production-grade APIs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始看到我们可以在 API 层面上进行哪些改进。这将让我们首先关注 API 的可用性，然后再深入到生产级 API 的所有方面。
- en: Quiz
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: What kind of API endpoint should you use when you want to send one request and
    receive one response?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想发送一个请求并接收一个响应时，你应该使用哪种类型的 API 端点？
- en: Bidirectional streaming
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双向流
- en: Client streaming
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端流
- en: Unary
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单一
- en: What kind of API endpoint should you use when you want to send zero or more
    requests and receive one response?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想发送零个或多个请求并接收一个响应时，你应该使用哪种类型的 API 端点？
- en: Server streaming
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器流
- en: Bidirectional streaming
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双向流
- en: Client streaming
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端流
- en: What kind of API endpoint should you use when you want to send one request and
    receive zero or more responses?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想发送一个请求并接收零个或多个响应时，你应该使用哪种类型的 API 端点？
- en: Server streaming
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器流
- en: Client streaming
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端流
- en: Bidirectional streaming
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双向流
- en: What kind of API endpoint should you use when you want to send zero or more
    requests and receive zero or more responses?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想发送零个或多个请求并接收零个或多个响应时，应该使用哪种API端点？
- en: Client streaming
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端流
- en: Bidirectional streaming
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双向流
- en: Server streaming
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器流
- en: Answers
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: C
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: C
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: A
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
