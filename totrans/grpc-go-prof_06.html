<html><head></head><body>
<div id="_idContainer022">
<h1 class="chapter-number" id="_idParaDest-116"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-117"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.2.1"> Designing Effective APIs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">While gRPC is performant, it is easy to make mistakes that will cost you in the long term or at scale. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we are going to see the considerations that are important in order to design efficient APIs in gRPC. </span><span class="koboSpan" id="kobo.3.3">Since we are talking about API design, the considerations are going to be linked to Protobuf because, as you know by now, we define our types and endpoints </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">in Protobuf.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we are going to cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">How to choose the right </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">integer type</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Understanding the impact of field tags on the size of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">serialized data</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">How to use field masks to solve the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">over-fetching problem</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Understanding how repeated fields can lead to a bigger payload </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">than expected</span></span></li>
</ul>
<h1 id="_idParaDest-118"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">For this chapter, you will find the relevant code in the folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">chapter6</span></strong><span class="koboSpan" id="kobo.18.1"> in the accompanying GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">repository (</span></span><a href="https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter6"><span class="No-Break"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter6</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.21.1">).</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.22.1">Choosing the right integer type</span></h1>
<p><span class="koboSpan" id="kobo.23.1">Protobuf is </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.24.1">mostly</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.25.1"> performant because of its binary format and because of its representation of integers. </span><span class="koboSpan" id="kobo.25.2">While some types such as strings are serialized “as is” and prepended with the field tag, type, and length, numbers – especially integers – ar</span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.26.1">e generally serialized in way fewer bits than how they are laid out in your </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">computer memory.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">However, you might have noticed that I said “generally serialized.” </span><span class="koboSpan" id="kobo.28.2">This is because if you chose the wrong integer type for your data, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">varint</span></strong><span class="koboSpan" id="kobo.30.1"> encoding algorithm might encode an </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">int32</span></strong><span class="koboSpan" id="kobo.32.1"> into 5 bytes or more, whereas, in memory, it is </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">4 bytes.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Let us see</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.35.1"> an example of a bad choice of integer type. </span><span class="koboSpan" id="kobo.35.2">Let us say</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.36.1"> that we want to encode the value 268,435,456. </span><span class="koboSpan" id="kobo.36.2">We can check how this value would be serialized in memory and with Protobuf by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">unsafe.Sizeof</span></strong><span class="koboSpan" id="kobo.38.1"> function from the Go standard library and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">proto.Marshal</span></strong><span class="koboSpan" id="kobo.40.1"> function provided by Protobuf. </span><span class="koboSpan" id="kobo.40.2">And finally, we are also going to use the well-known </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">Int32Value</span></strong><span class="koboSpan" id="kobo.42.1"> type to wrap the value and be able to serialize it </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">with Protobuf.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Before writing the main function, let us try to make a generic function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">serializedSize</span></strong><span class="koboSpan" id="kobo.46.1">, which will return the size of an integer in memory and the size of the same integer being serialized </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">with Protobuf.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.48.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.49.1">The code presented here is present in the accompanying GitHub repository under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">helpers</span></strong><span class="koboSpan" id="kobo.51.1"> directory. </span><span class="koboSpan" id="kobo.51.2">We thought it would not make sense to mix the TODO API and this kind of code so we </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">separated it.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Let us first add </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the dependencies</span><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.55.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.56.1">
$ go get –u google.golang.org/protobu</span><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.57.1">f
$ go get –u golang.org/x/exp/constraints</span></pre>
<p><span class="koboSpan" id="kobo.58.1">The first one is to have access to the well-known </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">Int32Value</span></strong><span class="koboSpan" id="kobo.60.1"> type and the second one is to have access to predefined type constraints </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">for generics.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">We are going to use generics to accept any kind of integer as data and let us specify a wrapper message to be able to serialize the data with Protobuf. </span><span class="koboSpan" id="kobo.62.2">We will have the </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">following function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.64.1">
func serializedSize[D constraints.Integer, W
  protoreflect.ProtoMes</span><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.65.1">sage](data D, wrapper W) (uintptr,
    int) {
  //...
</span><span class="koboSpan" id="kobo.65.2">}</span></pre>
<p><span class="koboSpan" id="kobo.66.1">Then, we can simply use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">proto.Marshal</span></strong><span class="koboSpan" id="kobo.68.1"> function from the Protobuf library to serialize the</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.69.1"> wrapper and return both the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">unsafe.Sizeof</span></strong><span class="koboSpan" id="kobo.71.1"> and </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.72.1">the length of the </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">serialized data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.74.1">
func serializedSize[D constraints.Integer, W
  protoreflect.ProtoM</span><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.75.1">essage](data D, wrapper W) (uintptr, int) {
  out, err := proto.Marshal(wrapper)
</span><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.76.1">
  if e</span><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.77.1">rr != nil {
    log.Fatal(err)
  }
  return unsafe.Sizeof(data), len(out) - 1
}</span></pre>
<p><span class="koboSpan" id="kobo.78.1">After that, it is simple. </span><span class="koboSpan" id="kobo.78.2">We can just call that function from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">main</span></strong><span class="koboSpan" id="kobo.80.1"> with a variable containing the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">268,435,456</span></strong><span class="koboSpan" id="kobo.82.1"> and an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">Int32Value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
import (
  "fmt"
  "unsafe"
  "google.golang.org/protobuf/proto"
  "google.golang.org/protobuf/reflect/protoreflect"
  "google.golang.org/protobuf/types/known/wrapperspb"
  "golang.org/x/exp/constraints"
)
//...
</span><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.87.1">
func main() {
  var data int32 = 268_435_456
  i3</span><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.88.1">2 := &amp;wrapperspb</span><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.89.1">.Int32Value{
    Value: data,
  }
</span><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.90.1">
  d, w := serializedSize(data, i32)
  fmt.Printf("in memory: %d\npb: %d\n", d, w)
}</span></pre>
<p><span class="koboSpan" id="kobo.91.1">If we run this, we </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.92.1">should get the </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">following res</span><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.94.1">ult:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.95.1">$ go run integers.go</span></strong><span class="koboSpan" id="kobo.96.1">
in memory: 4
pb: 5</span></pre>
<p><span class="koboSpan" id="kobo.97.1">Now, if you</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.98.1"> looked carefully at the code, you might be thinking that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">–1</span></strong><span class="koboSpan" id="kobo.100.1"> after </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">len(out)</span></strong><span class="koboSpan" id="kobo.102.1"> is cheating. </span><span class="koboSpan" id="kobo.102.2">With Protobuf, </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">Int32Value</span></strong><span class="koboSpan" id="kobo.104.1"> is serialized into 6 bytes. </span><span class="koboSpan" id="kobo.104.2">While you are right about the fact that the real serialization size is 6 bytes, the first bytes represent the type and field tag. </span><span class="koboSpan" id="kobo.104.3">So, to keep the comparison of the serialized data fair, we remove the metadata and only compare the </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">number itself.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">You may be thinking that our current TODO API, which uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">uint64</span></strong><span class="koboSpan" id="kobo.108.1"> for IDs, also has this problem, and you w</span><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.109.1">ould be totally right. </span><span class="koboSpan" id="kobo.109.2">You can easily see that by switching </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">int32</span></strong><span class="koboSpan" id="kobo.111.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">uint64</span></strong><span class="koboSpan" id="kobo.113.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Int32Value</span></strong><span class="koboSpan" id="kobo.115.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">UInt64Value</span></strong><span class="koboSpan" id="kobo.117.1">, and setting our data to be equal </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">to 72,057,594,037,927,93</span><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.119.1">6:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
func main() {
  var data uint64 = 72_057_594_037_927_936
  u</span><a id="_idTextAnchor358"/><span class="koboSpan" id="kobo.121.1">i64 := &amp;wrappersp</span><a id="_idTextAnchor359"/><span class="koboSpan" id="kobo.122.1">b.UInt64Value{
    Value: data,
  </span><a id="_idTextAnchor360"/><span class="koboSpan" id="kobo.123.1">}
  d, w := serializedSize(data, ui64)
  fmt.Printf("in memory: %d\npb: %d\n", d, w)
}</span></pre>
<p><span class="koboSpan" id="kobo.124.1">With</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.125.1"> the</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.126.1"> preceding code, we would get the </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">following </span><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.128.1">result:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.129.1">$ go run integers.go</span></strong><span class="koboSpan" id="kobo.130.1">
in memory: 8
pb: 9</span></pre>
<p><span class="koboSpan" id="kobo.131.1">This means that after approximately 72 quadrillion tasks are registered, we will have this problem. </span><span class="koboSpan" id="kobo.131.2">Obviously, for our use case, we are safe using </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">uint64</span></strong><span class="koboSpan" id="kobo.133.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">id</span></strong><span class="koboSpan" id="kobo.135.1"> because to have such a problem we would need every person on the planet to create 9 million tasks (72 quadrillion / 8 billion). </span><span class="koboSpan" id="kobo.135.2">But this might problem might be more significant in other use cases, and we need to be aware of the limitations of </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">our API.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.137.1">An alternative to using integers</span></h2>
<p><span class="koboSpan" id="kobo.138.1">An alternative </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.139.1">that is often cited and even recommended by Google is to use strings for IDs. </span><span class="koboSpan" id="kobo.139.2">They mention that 2^64 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">int64</span></strong><span class="koboSpan" id="kobo.141.1">) is not “as big as it used to be.” </span><span class="koboSpan" id="kobo.141.2">In the context of the company, this is understandable. </span><span class="koboSpan" id="kobo.141.3">They must deal with a lot of data and with bigger numbers than a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">of us.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">However, this is not the only advantage that a string has over a number type. </span><span class="koboSpan" id="kobo.143.2">The biggest advantage is probably the evolution of your API. </span><span class="koboSpan" id="kobo.143.3">If, at some point, you need to store bigger numbers, the only alternative you have is to switch to the string type. </span><span class="koboSpan" id="kobo.143.4">But the problem is that there is no backward and forward compatibility between the number type you used previously and a string. </span><span class="koboSpan" id="kobo.143.5">Thus, you will have to add a new field to your schema, clutter the message definition, and make the developers check whether the ID is set as a string or as a number in case of communication with older/newer versions of </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">an application.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Strings also </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.146.1">provide safety in the fact that these cannot be used for arithmetic operations. </span><span class="koboSpan" id="kobo.146.2">This limits smart dev</span><a id="_idTextAnchor363"/><span class="koboSpan" id="kobo.147.1">elopers, in a good way, to not being able to pull smart tricks with IDs and end up making the numbers overflow. </span><span class="koboSpan" id="kobo.147.2">IDs are effectively treated as globs that nobody should </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">manually handle.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">In conclusion, for some use cases, </span><a id="_idTextAnchor364"/><span class="koboSpan" id="kobo.150.1">it might be a good idea to start directly with strings for IDs. </span><span class="koboSpan" id="kobo.150.2">If you expect to scale or simply deal with numbers that are bigger than the integer limits, a string is the solution. </span><span class="koboSpan" id="kobo.150.3">However, in a lot of case</span><a id="_idTextAnchor365"/><span class="koboSpan" id="kobo.151.1">s, you will probably only need </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">uint64</span></strong><span class="koboSpan" id="kobo.153.1">. </span><span class="koboSpan" id="kobo.153.2">Just be aware of you</span><a id="_idTextAnchor366"/><span class="koboSpan" id="kobo.154.1">r needs and plan for </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">the future.</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor367"/><span class="koboSpan" id="kobo.156.1">Choosing the right field tag</span></h1>
<p><span class="koboSpan" id="kobo.157.1">As you know, field tags</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.158.1"> are serialized together with the actual data to let Protobuf know into which field to deserialize the data. </span><span class="koboSpan" id="kobo.158.2">And as these tags are encoded as </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">varint</span></strong><span class="koboSpan" id="kobo.160.1">, the bigger the tag, the bigger the impact on your serialized data size. </span><span class="koboSpan" id="kobo.160.2">In this section, let us talk about the two considerations that you must make to not let these tags affect your payload </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">too much.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor368"/><span class="koboSpan" id="kobo.162.1">Required/optional</span></h2>
<p><span class="koboSpan" id="kobo.163.1">Having</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.164.1"> big field tags might be fine if you are aware of the trade-off. </span><span class="koboSpan" id="kobo.164.2">One common way of treating big tags is to see them as being used for optional fields. </span><span class="koboSpan" id="kobo.164.3">An optional field means that it is less often populated with data and because Protobuf does not serialize fields that are not populated, the tag itself is not serialized. </span><span class="koboSpan" id="kobo.164.4">However, we will occasionally populate this field and we will </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">incur costs.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">One advantage of such a design is keeping relevant information together without having to create loads of messages to keep the field tags small. </span><span class="koboSpan" id="kobo.166.2">It will make the code easier to read and make the reader aware of the possible fields that they </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">can populate.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">The downside though is that if you are creating an API that is user-facing, you might incur costs too often. </span><span class="koboSpan" id="kobo.168.2">This might be because the user does not understand how to use your API properly or simply because the user has specific needs. </span><span class="koboSpan" id="kobo.168.3">This might also happen in a company setting, but it can be mitigated by senior software engineers or </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">internal documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">Let us see </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.171.1">an example of the downside that big tags bring. </span><span class="koboSpan" id="kobo.171.2">For the sake of an example, let us say that we have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">message (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">helpers/tags.proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
message Tags {
  int32 tag = </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">1</span></strong><span class="koboSpan" id="kobo.177.1">;
  int32 tag2 = </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">16</span></strong><span class="koboSpan" id="kobo.179.1">;
  int32 tag3 = </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">2048</span></strong><span class="koboSpan" id="kobo.181.1">;
  int32 tag4 = </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">262_144</span></strong><span class="koboSpan" id="kobo.183.1">;
  int32 tag5 = </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">33_554_432</span></strong><span class="koboSpan" id="kobo.185.1">;
  int32 tag6 = </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">536_870_911</span></strong><span class="koboSpan" id="kobo.187.1">;
}</span></pre>
<p><span class="koboSpan" id="kobo.188.1">Note that these numbers are not random. </span><span class="koboSpan" id="kobo.188.2">If you remember, during the Protobuf primer, I explained that tags are encoded as </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">varints</span></strong><span class="koboSpan" id="kobo.190.1">. </span><span class="koboSpan" id="kobo.190.2">These numbers are the thresholds for which it takes one more byte to serialize the </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">tag alone.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">Now, with that, we are going to calculate the size of the message into which we incrementally set the value for fields. </span><span class="koboSpan" id="kobo.192.2">We are going to start with an empty object, then we are going to set </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">tag</span></strong><span class="koboSpan" id="kobo.194.1">, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">tag2</span></strong><span class="koboSpan" id="kobo.196.1">, and so on. </span><span class="koboSpan" id="kobo.196.2">Note also that we are going to set the same value for all the fields (1). </span><span class="koboSpan" id="kobo.196.3">This will show us the overhead that it takes to simply serialize </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">the tag.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">helpers/tags.go</span></strong><span class="koboSpan" id="kobo.200.1">, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
package main
import (
  "fmt"
  "log"
  "google.golang.org/protobuf/proto"
  "google.golang.org/protobuf/reflect/protoreflect"
  pb "github.com/PacktPublishing/gRPC-Go-for-Professionals/
    helpers/proto"
)
func serializedSize[M protorefle</span><a id="_idTextAnchor369"/><span class="koboSpan" id="kobo.203.1">ct.ProtoMessage](msg M)</span><a id="_idTextAnchor370"/><span class="koboSpan" id="kobo.204.1"> int
{
  out, err := proto.Mars</span><a id="_idTextAnchor371"/><span class="koboSpan" id="kobo.205.1">hal(msg</span><a id="_idTextAnchor372"/><span class="koboSpan" id="kobo.206.1">)
  if err != nil {
    log.Fatal(err)
  }
  return le</span><a id="_idTextAnchor373"/><span class="koboSpan" id="kobo.207.1">n(out)
}
f</span><a id="_idTextAnchor374"/><span class="koboSpan" id="kobo.208.1">unc main() {
  t :</span><a id="_idTextAnchor375"/><span class="koboSpan" id="kobo.209.1">= &amp;pb.Tags</span><a id="_idTextAnchor376"/><span class="koboSpan" id="kobo.210.1">{}
  tags := []int{1, 16, 2048, 262_144, 33_554_432</span><a id="_idTextAnchor377"/><span class="koboSpan" id="kobo.211.1">, 536_870_911}
  fields := []*int32{&amp;t.Tag, &amp;t.Tag2, &amp;t.Tag3, </span><a id="_idTextAnchor378"/><span class="koboSpan" id="kobo.212.1">&amp;t.Tag4,</span><a id="_idTextAnchor379"/><span class="koboSpan" id="kobo.213.1">
    &amp;t.Tag5, &amp;t.Tag6}
  sz := serializedSize(t)
  fmt.Printf("0 - %d\n",</span><a id="_idTextAnchor380"/><span class="koboSpan" id="kobo.214.1"> sz)
  for i, f := range fields {
    *f = 1
    sz := serializedSize(t)
    fmt.Printf("%d - %d\n", tags[i], sz-(i+1))
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.215.1">We </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.216.1">repurposed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">serializedSize</span></strong><span class="koboSpan" id="kobo.218.1"> we saw earlier. </span><span class="koboSpan" id="kobo.218.2">We set the field by dereferencing the pointer to the field, we calculate the size of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">Tag</span></strong><span class="koboSpan" id="kobo.220.1"> message with the new field set, and we print the result. </span><span class="koboSpan" id="kobo.220.2">This result is a little bit manipulated to show us only the bytes for the tag. </span><span class="koboSpan" id="kobo.220.3">We subtract i+1 from the</span><a id="_idTextAnchor381"/><span class="koboSpan" id="kobo.221.1"> size because i is zero-indexed (so </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">+1</span></strong><span class="koboSpan" id="kobo.223.1">). </span><span class="koboSpan" id="kobo.223.2">So, effectively, we subtract the number of fields already set from the size, which is also the size it takes to serialize the data without the tag (1 byte for </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">value 1).</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">In the end, if we run this, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">following (beautified):</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.227.1">$ go run tags.go</span></strong><span class="koboSpan" id="kobo.228.1">
Tag             Bytes
----            ----
0               0
1               1
16              3
2048            6
262144          10
33554432        15
536870911       20</span></pre>
<p><span class="koboSpan" id="kobo.229.1">This tells us</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.230.1"> that each time we pass a threshold, we get one more byte overhead in our serialized data. </span><span class="koboSpan" id="kobo.230.2">At first, we have an empty message, so we get 0 bytes, then we have a tag of 1, which is serialized into 1 byte, after that a tag of 2 serialized into 2 bytes, and so on. </span><span class="koboSpan" id="kobo.230.3">We can look at the difference between two lines to get the overhead. </span><span class="koboSpan" id="kobo.230.4">The overhead of setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">value</span></strong><span class="koboSpan" id="kobo.232.1"> to a field with tag </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">2048</span></strong><span class="koboSpan" id="kobo.234.1"> instead of setting it to a field with tag </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">16</span></strong><span class="koboSpan" id="kobo.236.1"> is 3 bytes (6 – </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">3 bytes).</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">In conclusion, we need to keep the smaller field tags available for the fields that are the most populated or required. </span><span class="koboSpan" id="kobo.238.2">This is because</span><a id="_idTextAnchor382"/><span class="koboSpan" id="kobo.239.1"> these tags will almost always be serialized, and we want to minimize the impact of the tag serialization. </span><span class="koboSpan" id="kobo.239.2">For optional fields, we might use bigger tags to keep the related fields together, and with that, we should incur non-recurrent </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">payload increases.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor383"/><span class="koboSpan" id="kobo.241.1">Splitting messages</span></h2>
<p><span class="koboSpan" id="kobo.242.1">In general, we </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.243.1">prefer to split messages to keep smaller objects and have fewer fields, and thus smaller tags. </span><span class="koboSpan" id="kobo.243.2">This lets us arrange information into entities and understand what the given information is representing. </span><span class="koboSpan" id="kobo.243.3">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">Task</span></strong><span class="koboSpan" id="kobo.245.1"> message is an example of that. </span><span class="koboSpan" id="kobo.245.2">It groups information and we can reuse that entity in, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">UpdateTasksRequest</span></strong><span class="koboSpan" id="kobo.247.1"> to accept a fully featured </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">Task</span></strong><span class="koboSpan" id="kobo.249.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">a request.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">However, while it is interesting to be able to separate information into entities, this does not come for free. </span><span class="koboSpan" id="kobo.251.2">Your payload gets affected by the use of a user-defined type. </span><span class="koboSpan" id="kobo.251.3">Let us see an example of splitting a message and how it can affect the size of serialized data. </span><span class="koboSpan" id="kobo.251.4">This example shows that there is a size overhead when splitting messages. </span><span class="koboSpan" id="kobo.251.5">To show that, we are going to create a message that contains a name and a wrapper around a name. </span><span class="koboSpan" id="kobo.251.6">This first time we check the size, we will only set the string, and the second time we will only set the wrapper. </span><span class="koboSpan" id="kobo.251.7">Here is what I mean by such </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">a message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
message ComplexName {
  string name = 1;
}
message Split {
  string name = 1;
  ComplexName complex_name = 2;
}</span></pre>
<p><span class="koboSpan" id="kobo.254.1">Right now, let </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.255.1">us not worry about the usefulness of this example. </span><span class="koboSpan" id="kobo.255.2">We are just trying to prove that splitting a message has </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">an overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">Then, we will write a </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">main</span></strong><span class="koboSpan" id="kobo.259.1"> function that simply sets the value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">name</span></strong><span class="koboSpan" id="kobo.261.1"> first, then calculates the size and prints it. </span><span class="koboSpan" id="kobo.261.2">And then, we will clear the name, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">ComplexName.name</span></strong><span class="koboSpan" id="kobo.263.1"> field, calculate the size, and print it. </span><span class="koboSpan" id="kobo.263.2">If there is an overhead, the sizes should be different. </span><span class="koboSpan" id="kobo.263.3">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">helpers/split.go</span></strong><span class="koboSpan" id="kobo.265.1">, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
package main
import (
  "fmt"
  "log"
  "google.golang.org/protobuf/proto"
  "google.golang.org/protobuf/reflect/protoreflect"
  pb "github.com/PacktPublishing/gRPC-Go-for-Professionals
    /helpers/proto"
)
func serializedSize[M protoreflect.ProtoMessage](msg M) int
{
  out, err := proto.Marshal(msg)
  if err != nil {
    log.Fatal(err)
  }
  return len(out)
}
func main() {
  s := &amp;pb.Split{Name: "Packt"}
  sz := serializedSize(s)
  fmt.Printf("With Name: %d\n", sz)
  s.Name = ""
  s.ComplexName = &amp;pb.ComplexName{Name: "Packt"}
  sz = serializedSize(s)
  fmt.Printf("With ComplexName: %d\n", sz)
}</span></pre>
<p><span class="koboSpan" id="kobo.268.1">If we run that, we</span><a id="_idIndexMarker288"/> <span class="No-Break"><span class="koboSpan" id="kobo.269.1">should get:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.270.1">$ go run split.go</span></strong><span class="koboSpan" id="kobo.271.1">
With Name: 7
With ComplexName: 9</span></pre>
<p><span class="koboSpan" id="kobo.272.1">Effectively, these two sizes are different. </span><span class="koboSpan" id="kobo.272.2">But what is the difference? </span><span class="koboSpan" id="kobo.272.3">The difference is that user-defined types are serialized as length-delimited types. </span><span class="koboSpan" id="kobo.272.4">In our case, the simple name would</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.273.1"> be serialized as 0a 05 50 61 63 6b 74. </span><span class="koboSpan" id="kobo.273.2">0a is the wire type for Length-Delimited + tag 1 and the rest are the characters. </span><span class="koboSpan" id="kobo.273.3">But for the complex type, we have 12 07 0a 05 50 61 63 6b 74. </span><span class="koboSpan" id="kobo.273.4">We recognize the last 7 bytes but there are two more in front. </span><span class="koboSpan" id="kobo.273.5">12 is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">Length-Delimited wire type + tag 2</span></strong><span class="koboSpan" id="kobo.275.1"> and 07 is the length of the following bytes. </span></p>
<p><span class="koboSpan" id="kobo.276.1">In conclusion, we once again have a trade-off. </span><span class="koboSpan" id="kobo.276.2">The more tags we have in messages, the more possibility there is for us to incur costs in terms of payload size. </span><span class="koboSpan" id="kobo.276.3">However, the more we try to split messages to keep the tags small, the more we will also incur costs because the data will be serialized as </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">length-delimited data.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor384"/><span class="koboSpan" id="kobo.278.1">Improving UpdateTasksRequest</span></h2>
<p><span class="koboSpan" id="kobo.279.1">To </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.280.1">reflect on what we have learned in the last section, we are going to improve the serialized size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">UpdateTasksRequest</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">This is important because of the context in which this message is used. </span><span class="koboSpan" id="kobo.282.3">This is a message that is sent 0 or more times by the client since it is </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.283.1">used in a client streaming RPC endpoint. </span><span class="koboSpan" id="kobo.283.2">It means that any overhead in serialized data size will be multiplied by the number of times that we send this message over </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">the wire.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.285.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.286.1">The following code is present in the accompanying GitHub repository. </span><span class="koboSpan" id="kobo.286.2">You will find the new Protobuf code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">proto/todo/v2</span></strong><span class="koboSpan" id="kobo.288.1"> folder and the server/client code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.290.1"> will be updated to reflect the change. </span><span class="koboSpan" id="kobo.290.2">Finally, one thing to notice is that we do not provide backward and forward compatibility. </span><span class="koboSpan" id="kobo.290.3">A server in </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">chapter6</span></strong><span class="koboSpan" id="kobo.292.1"> cannot receive a request from a client in </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">chapter5</span></strong><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">More work is needed to make </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">that possible.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">If we look at the current message, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
message Updat</span><a id="_idTextAnchor385"/><span class="koboSpan" id="kobo.299.1">eTasksRequest {
  Task task = 1;
}</span></pre>
<p><span class="koboSpan" id="kobo.300.1">This is describing exactly what we want, but now we know that some extra bytes will be serialized because of the sub-message. </span><span class="koboSpan" id="kobo.300.2">To solve this problem, we can simply copy the fields that we</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.301.1"> let the user change and the ID that describes which task to update. </span><span class="koboSpan" id="kobo.301.2">This will give us </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
message UpdateTasksRequest {
  uint64 id = 1;
  string description = 2;
  bool done = 3;
  google.protobuf.Timestamp due_date = 4;
}</span></pre>
<p><span class="koboSpan" id="kobo.304.1">This is the</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.305.1"> same definition as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">Task</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.307.1"> message.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">Now, you might be thinking that we are repeating ourselves and that it is a waste to do so. </span><span class="koboSpan" id="kobo.308.2">However, there are two important benefits to </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">doing that:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.310.1">We no longer need to incur overhead for the serialization of the user-defined type. </span><span class="koboSpan" id="kobo.310.2">On each request, we save 2 bytes (tag + type </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">and length).</span></span></li>
<li><span class="koboSpan" id="kobo.312.1">We now have more control over the fields that a user might update. </span><span class="koboSpan" id="kobo.312.2">If we did not want the user to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">due_date</span></strong><span class="koboSpan" id="kobo.314.1"> anymore, we would simply remove that from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">UpdateTaskRequest</span></strong><span class="koboSpan" id="kobo.316.1"> message and reserve the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">tag 4.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.318.1">To prove that this is more efficient in terms of serialized data size, we can temporarily modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.320.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">server/impl.go</span></strong><span class="koboSpan" id="kobo.322.1"> a little bit for both </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">chapter5</span></strong><span class="koboSpan" id="kobo.324.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">chapter6</span></strong><span class="koboSpan" id="kobo.326.1">. </span><span class="koboSpan" id="kobo.326.2">To count the size of the payload, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">proto.Marshal</span></strong><span class="koboSpan" id="kobo.328.1"> that we used earlier and sum up the total serialized size. </span><span class="koboSpan" id="kobo.328.2">In the end, we can just print the result on the terminal when we receive </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">an EOF.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">Here is what it looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">chapter6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.334.1">
func (s *server) UpdateTasks(stream
  pb.TodoService_UpdateTasksServer) error {
</span><strong class="bold"><span class="koboSpan" id="kobo.335.1">  totalLengt</span><a id="_idTextAnchor386"/><span class="koboSpan" id="kobo.336.1">h := 0</span></strong><span class="koboSpan" id="kobo.337.1">
  for {
    req, err := stream.Recv()
    if err == io.EOF {
      </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">log.Println("TOTAL: ", totalLength)</span></strong><span class="koboSpan" id="kobo.339.1">
      return stream.SendAndClose(&amp;pb.UpdateTasksR</span><a id="_idTextAnchor387"/><span class="koboSpan" id="kobo.340.1">esponse</span><a id="_idTextAnchor388"/><span class="koboSpan" id="kobo.341.1">{})
    }
    if e</span><a id="_idTextAnchor389"/><span class="koboSpan" id="kobo.342.1">rr != nil {
      re</span><a id="_idTextAnchor390"/><span class="koboSpan" id="kobo.343.1">turn err
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.344.1">out, _ := proto.Marshal(req)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.345.1">    totalLength += len(out)</span></strong><span class="koboSpan" id="kobo.346.1">
    s.d.updateTask(
      req.Id,
      req.Description,
      req.DueDate.AsTime(),
      req.Done,
    )
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.347.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">chapter5</span></strong><span class="koboSpan" id="kobo.349.1">, this leads to 56 bytes being sent over the network as requests, and for </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">chapter6</span></strong><span class="koboSpan" id="kobo.351.1">, we only</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.352.1"> send 50 bytes. </span><span class="koboSpan" id="kobo.352.2">Once again, this looks negligible because we are doing that at a small scale, but </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.353.1">once we receive traffic, it will quickly pile up and impact </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">our costs.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor391"/><span class="koboSpan" id="kobo.355.1">Adopting FieldMasks to reduce the payload</span></h1>
<p><span class="koboSpan" id="kobo.356.1">After improving </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.357.1">our </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">UpdateTasksRequest</span></strong><span class="koboSpan" id="kobo.359.1"> message, we can now start looking at </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">FieldMasks</span></strong><span class="koboSpan" id="kobo.361.1"> to further reduce the payload size, but this time we are going to focus </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">ListTasksResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">First, let us understand </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.366.1">what </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">FieldMasks</span></strong><span class="koboSpan" id="kobo.368.1"> is. </span><span class="koboSpan" id="kobo.368.2">It refers to objects containing a list of paths telling Protobuf which fields to include and telling it implicitly which should not be included. </span><span class="koboSpan" id="kobo.368.3">An example of that could be the following. </span><span class="koboSpan" id="kobo.368.4">Saywe had a message such </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">Task</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.372.1">
message Task {
  uint64 id = 1;
  string description = 2;
  bool done = 3;
  google.protobuf.Timestamp due_date = 4;
}</span></pre>
<p><span class="koboSpan" id="kobo.373.1">And we wanted to select only </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">id</span></strong><span class="koboSpan" id="kobo.375.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">done</span></strong><span class="koboSpan" id="kobo.377.1"> fields, we could have a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">FieldMask</span></strong><span class="koboSpan" id="kobo.379.1"> like </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.381.1">
mask {
  paths: "id"
  paths: "done"
}</span></pre>
<p><span class="koboSpan" id="kobo.382.1">We could then apply</span><a id="_idTextAnchor392"/><span class="koboSpan" id="kobo.383.1"> that mask on an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Task</span></strong><span class="koboSpan" id="kobo.385.1"> and it would keep only the mentioned fields’ value. </span><span class="koboSpan" id="kobo.385.2">This is interesting when we are doing the equivalent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">GET</span></strong><span class="koboSpan" id="kobo.387.1"> and we do not want to fetch too much unnecessary </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">data (over-fetching).</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">Our TODO API </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.390.1">contains one such use case: </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">ListTasks</span></strong><span class="koboSpan" id="kobo.392.1">. </span><span class="koboSpan" id="kobo.392.2">Why? </span><span class="koboSpan" id="kobo.392.3">Because if a user wanted to fetch only part of the information, they would not be able to do so. </span><span class="koboSpan" id="kobo.392.4">Selecting part of the data might be useful for features such as synchronizing tasks from local storage to a backend. </span><span class="koboSpan" id="kobo.392.5">If the backend has IDs 1, 2, and 3 and the local has 1, 2, 3, 4, and 5, we want to be able to calculate the delta of the tasks that we need to upload. </span><span class="koboSpan" id="kobo.392.6">To do this, we would need to list only the IDs as fetching the description, done date, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">due_date</span></strong><span class="koboSpan" id="kobo.394.1"> value would </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">be wasteful.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor393"/><span class="koboSpan" id="kobo.396.1">Improving ListTasksRequest</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">ListTasksResponse</span></strong><span class="koboSpan" id="kobo.398.1"> is a</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.399.1"> server-streaming kind of API. </span><span class="koboSpan" id="kobo.399.2">We send one request and we get 0 or more responses. </span><span class="koboSpan" id="kobo.399.3">This is important to mention because sending a </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">FieldMask</span></strong><span class="koboSpan" id="kobo.401.1"> does not come for free. </span><span class="koboSpan" id="kobo.401.2">We still need to carry bytes on the wire. </span><span class="koboSpan" id="kobo.401.3">In our case, though, it is interesting to use masks </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.402.1">because we can send it once and it will be applied to all the elements returned by </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">The first thing that we need to do is to declare such a </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">FieldMask</span></strong><span class="koboSpan" id="kobo.406.1">. </span><span class="koboSpan" id="kobo.406.2">To do that, we import </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">field_mask.proto</span></strong><span class="koboSpan" id="kobo.408.1"> and add a field </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">ListTasksRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
import "google/protobuf/field_mask.proto";
//...
</span><span class="koboSpan" id="kobo.412.2">message ListTasksRequest {
  google.protobuf.FieldMask mask = 1;
}</span></pre>
<p><span class="koboSpan" id="kobo.413.1">Then, we can go to the server side and apply that mask to all the responses that we send. </span><span class="koboSpan" id="kobo.413.2">This is done with reflection and a little bit of boilerplate. </span><span class="koboSpan" id="kobo.413.3">The first thing that we need to do is to add a dependency in the server to work with slices and specifically </span><a id="_idTextAnchor394"/><span class="koboSpan" id="kobo.414.1">access the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">Contains</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1"> function:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.417.1">$ go get golang.org/x/exp/slices</span></strong></pre>
<p><span class="koboSpan" id="kobo.418.1">After that, we can work with reflection. </span><span class="koboSpan" id="kobo.418.2">We are going to go over all the fields that a given message has and if its name is not present in the mask’s paths, we are going to remove </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">its </span></span><span class="No-Break"><a id="_idIndexMarker301"/></span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">value:</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.421.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.422.1">The following code is a simplistic implementation to filter fields in a message, but this is sufficient for our use case. </span><span class="koboSpan" id="kobo.422.2">In reality, there are more powerful features of </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">FieldMasks</span></strong><span class="koboSpan" id="kobo.424.1"> such as filtering maps, lists, and sub-messages. </span><span class="koboSpan" id="kobo.424.2">Unfortunately, the Go implementation of Protobuf does not provide such utilities as the other implementations do, so we need to rely on writing our own code or using </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">community projects.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
import (
  "google.golang.org/protobuf/proto"
  "google.golang.org/protobuf/reflect/protoreflect"
  "google.golang.org/protobuf/types/known/fieldmaskpb"
  "golang.</span><a id="_idTextAnchor395"/><span class="koboSpan" id="kobo.427.1">org/x/exp/slices"
)
//...
</span><span class="koboSpan" id="kobo.427.2">func Filter(msg proto.Message, mask *field</span><a id="_idTextAnchor396"/><span class="koboSpan" id="kobo.428.1">maskpb.FieldMask) {
  if mask == nil || len(mask.Paths) == 0 {
    return
  }
  rft := msg.ProtoReflect()
  rft.Range(func(fd protoreflect.FieldDescriptor, _
    protoreflect.Value) bool {
    if !slices.Contains(mask.Paths, string(fd.Name())) {
      rft.Clear(fd)
    }
    return true
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.429.1">With </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.430.1">that, we can now basically use </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Filter</span></strong><span class="koboSpan" id="kobo.432.1"> in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">ListTasks</span></strong><span class="koboSpan" id="kobo.434.1"> implementation to filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">Task</span></strong><span class="koboSpan" id="kobo.436.1"> object that will be sent </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">ListTasksResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
func (s *server) ListTasks(req *pb.ListTasksRequest, stream
  pb.TodoService_ListTasksServer) err</span><a id="_idTextAnchor397"/><span class="koboSpan" id="kobo.441.1">or {
  return s.d.getTask</span><a id="_idTextAnchor398"/><span class="koboSpan" id="kobo.442.1">s(func(t interface{}) erro</span><a id="_idTextAnchor399"/><span class="koboSpan" id="kobo.443.1">r {
    task := t.(*pb.Task)</span><a id="_idTextAnchor400"/><span class="koboSpan" id="kobo.444.1">
    Filter(task, req.</span><a id="_idTextAnchor401"/><span class="koboSpan" id="kobo.445.1">Mask</span><a id="_idTextAnchor402"/><span class="koboSpan" id="kobo.446.1">)
    overdue := task.DueDate != nil &amp;&amp; !task.D</span><a id="_idTextAnchor403"/><span class="koboSpan" id="kobo.447.1">one &amp;&amp;
      task</span><a id="_idTextAnchor404"/><span class="koboSpan" id="kobo.448.1">.DueDate.AsTi</span><a id="_idTextAnchor405"/><span class="koboSpan" id="kobo.449.1">me().Before(time.Now().UTC())
    err := stream.Send(&amp;pb.ListTasksResponse{
      Task: task,
      Ove</span><a id="_idTextAnchor406"/><span class="koboSpan" id="kobo.450.1">rdue: overdue,
    })
    return err
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.451.1">Notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">Filter</span></strong><span class="koboSpan" id="kobo.453.1"> is called before calculating </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">Overdue</span></strong><span class="koboSpan" id="kobo.455.1">. </span><span class="koboSpan" id="kobo.455.2">This is because if we do not include </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">due_date</span></strong><span class="koboSpan" id="kobo.457.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">FieldMask</span></strong><span class="koboSpan" id="kobo.459.1">, we assume that the user does not care about the overdue. </span><span class="koboSpan" id="kobo.459.2">In the end, the overdue will be false, not serialized, and thus not sent over the wire. </span></p>
<p><span class="koboSpan" id="kobo.460.1">Then, we </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.461.1">need to see how to use that on the client side. </span><span class="koboSpan" id="kobo.461.2">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">printTasks</span></strong><span class="koboSpan" id="kobo.463.1"> is going to print only IDs. </span><span class="koboSpan" id="kobo.463.2">We are going to receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">FieldMask</span></strong><span class="koboSpan" id="kobo.465.1"> as a parameter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">printTasks</span></strong><span class="koboSpan" id="kobo.467.1"> and add it </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">ListTasksRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
func printTasks(c pb.TodoServiceClient, fm *fieldmaskpb
  .FieldMask) {
  req := &amp;pb.ListTasksRequest{
    Mask: fm,
  }
  //...
</span><span class="koboSpan" id="kobo.471.2">}</span></pre>
<p><span class="koboSpan" id="kobo.472.1">And finally, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">fieldmaskpb.New</span></strong><span class="koboSpan" id="kobo.474.1">, we first c</span><a id="_idTextAnchor407"/><span class="koboSpan" id="kobo.475.1">reate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">FieldMask</span></strong><span class="koboSpan" id="kobo.477.1"> with the path </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">id</span></strong><span class="koboSpan" id="kobo.479.1">. </span><span class="koboSpan" id="kobo.479.2">This function will check that </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">id</span></strong><span class="koboSpan" id="kobo.481.1"> is a valid path in the message that we provide as the first argument. </span><span class="koboSpan" id="kobo.481.2">If there is no error, we can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Mask</span></strong><span class="koboSpan" id="kobo.483.1"> field in o</span><a id="_idTextAnchor408"/><span class="koboSpan" id="kobo.484.1">ur </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">ListTasksRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.486.1"> ins</span><a id="_idTextAnchor409"/><span class="koboSpan" id="kobo.487.1">tance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.488.1">
func main() {
  //...
</span><span class="koboSpan" id="kobo.488.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.489.1">fm, err := fiel</span><a id="_idTextAnchor410"/><span class="koboSpan" id="kobo.490.1">dmaskpb</span><a id="_idTextAnchor411"/><span class="koboSpan" id="kobo.491.1">.New(&amp;pb.Task{}, "id")</span></strong><span class="koboSpan" id="kobo.492.1">
  if err != nil {
    log.Fatalf("unexpected error: %v", err)
  }
  //...
</span><span class="koboSpan" id="kobo.492.2">  fmt.Println("--------LIST-------")
  printTasks(c, </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">fm</span></strong><span class="koboSpan" id="kobo.494.1">)
  fmt.Println("-------------------")
  //...
</span><span class="koboSpan" id="kobo.494.2">}</span></pre>
<p><span class="koboSpan" id="kobo.495.1">If we </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.496.1">run that, we should have the </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.498.1">
--------LIST-------
id:1 overdue:false
id:2 overdue:false
id:3 overdue:false
-------------------</span></pre>
<p><span class="koboSpan" id="kobo.499.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">overdue</span></strong><span class="koboSpan" id="kobo.501.1"> is still printed as </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">false</span></strong><span class="koboSpan" id="kobo.503.1">, but in our case, it can be overlooked because we print overdue in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">printTasks</span></strong><span class="koboSpan" id="kobo.505.1"> function and the default value of overdue (bool) </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">is false..</span></span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor412"/><span class="koboSpan" id="kobo.507.1">Beware the unpacked repeated field</span></h1>
<p><span class="koboSpan" id="kobo.508.1">The last consideration</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.509.1"> is not helpful for our TODO API but is worth ment</span><a id="_idTextAnchor413"/><span class="koboSpan" id="kobo.510.1">ioning. </span><span class="koboSpan" id="kobo.510.2">In Protobuf, we have different ways of encoding repeated fields. </span><span class="koboSpan" id="kobo.510.3">We have packed and unpacked </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">repeated fields.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor414"/><span class="koboSpan" id="kobo.512.1">Packed repeated fields</span></h2>
<p><span class="koboSpan" id="kobo.513.1">To </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.514.1">understand, let us see an example of a packed repeated field. </span><span class="koboSpan" id="kobo.514.2">Let us say that we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">following message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.516.1">
message RepeatedUInt32Values {
  repeated uint32 values = 1;
}</span></pre>
<p><span class="koboSpan" id="kobo.517.1">It is a simple list of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">uint32</span></strong><span class="koboSpan" id="kobo.519.1"> scalar type. </span><span class="koboSpan" id="kobo.519.2">If we serialized this with the values 1, 2, and 3, we would get the </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">following result:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.521.1">$ cat repeated_scalar.txt | protoc --encode=</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.522.1"> RepeatedUInt32Values proto/repeated.proto | hexdump -C</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.523.1">0a 03 01 02 03</span></strong><span class="koboSpan" id="kobo.524.1">
00000005</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">repeated_scalar.txt</span></strong><span class="koboSpan" id="kobo.526.1">  from the </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.527.1">preceding command contains </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.529.1">
values: 1
values: 2
values: 3</span></pre>
<p><span class="koboSpan" id="kobo.530.1">This is an example of a packed repeated field because of how the field wraps multiple values. </span><span class="koboSpan" id="kobo.530.2">You might think that this is normal since this is a list, but we are going to see later that this is not </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">always true.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">To understand what “wraps multiple values” means, we need to take a closer look at the hexadecimal presented by </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">hexdump</span></strong><span class="koboSpan" id="kobo.534.1">. </span><span class="koboSpan" id="kobo.534.2">We have 5 bytes: 0a 03 01 02 03. </span><span class="koboSpan" id="kobo.534.3">As we know, a repeated field is serialized as a length-delimited type. </span><span class="koboSpan" id="kobo.534.4">So 0a is the combination of the type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">varint</span></strong><span class="koboSpan" id="kobo.536.1">) and field tag (1), 03 means that we have three elements in the list, and the rest are the </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">actual values.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor415"/><span class="koboSpan" id="kobo.538.1">Unpacked repeated fields</span></h2>
<p><span class="koboSpan" id="kobo.539.1">However, serialized data </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.540.1">for repeated fields is not always that compact. </span><span class="koboSpan" id="kobo.540.2">Let us look at an example of an unpacked repeated field. </span><span class="koboSpan" id="kobo.540.3">Let us say that we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">packed</span></strong><span class="koboSpan" id="kobo.542.1"> option with the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">false</span></strong><span class="koboSpan" id="kobo.544.1"> for the field </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">values</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.548.1">
message RepeatedUInt32Values {
  repeated uint32 values = 1 [packed = false];
}</span></pre>
<p><span class="koboSpan" id="kobo.549.1">Now, if we run the same command with the same values, we should have the </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">following result:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.551.1">$ cat repeated_scalar.txt | protoc --encode=</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.552.1">RepeatedUInt32Values proto/repeated.proto | hexdump -C</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.553.1">08 01 08 02 08 03</span></strong><span class="koboSpan" id="kobo.554.1">
000</span><a id="_idTextAnchor416"/><span class="koboSpan" id="kobo.555.1">00006</span></pre>
<p><span class="koboSpan" id="kobo.556.1">We can </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.557.1">see that we have a totally different way of serializing the data. </span><span class="koboSpan" id="kobo.557.2">This time, we repeatedly serialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">uint32</span></strong><span class="koboSpan" id="kobo.559.1">. </span><span class="koboSpan" id="kobo.559.2">Here, 08 stands for the type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">varint</span></strong><span class="koboSpan" id="kobo.561.1">) and tag (1), and you can see that it is present three times as we have three values. </span><span class="koboSpan" id="kobo.561.2">If we have more than two values in the repeated field, this is effectively adding a byte per value. </span><span class="koboSpan" id="kobo.561.3">In our case, we serialize the whole as 6 bytes instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">5 previously.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">Now, you might be thinking that you will just not use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">packed</span></strong><span class="koboSpan" id="kobo.565.1"> option and you should always have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">packed</span></strong><span class="koboSpan" id="kobo.567.1"> field. </span><span class="koboSpan" id="kobo.567.2">You would be right for repeated fields acting on scalars but not on more complex types. </span><span class="koboSpan" id="kobo.567.3">For example, strings, bytes, and user-defined types will always be serialized as unpacked and there is no way to </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">avoid that.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">Let us take an example with a user-defined type. </span><span class="koboSpan" id="kobo.569.2">Say we have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">Protobuf code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
message UserDefined {
  uint32 value = 1;
}
message RepeatedUserDefinedValues {
  repeated UserDefined values = 1;
}</span></pre>
<p><span class="koboSpan" id="kobo.572.1">We can now try to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">following command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.574.1">$ cat repeated_ud.txt | protoc --encode=</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.575.1">RepeatedUserDefinedValues proto/repeated.proto | hexdump -C</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.576.1">0a 02 08 01 0a 02 08 02 0a 02 08 03</span></strong><span class="koboSpan" id="kobo.577.1">
0000000c</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">repeated_ud.txt</span></strong><span class="koboSpan" id="kobo.579.1"> from the preceding command contains </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
values: {value: 1}
values: {value: 2}
values: {value: 3}</span></pre>
<p><span class="koboSpan" id="kobo.582.1">We can </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.583.1">see that we now have a combination of both the overhead that we had with sub-messages earlier in the chapter and on top of that our repeated field is unpacked. </span><span class="koboSpan" id="kobo.583.2">We have 0a and 02, which correspond to the sub-message itself, and the 08 + value, which corresponds to the field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">value</span></strong><span class="koboSpan" id="kobo.585.1">. </span><span class="koboSpan" id="kobo.585.2">As you can see, this is now wasting much </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">more bytes.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">Now, as this is impossible to avoid on complex types, it is incorrect to say that we should never u</span><a id="_idTextAnchor417"/><span class="koboSpan" id="kobo.588.1">se repeated fields on such types. </span><span class="koboSpan" id="kobo.588.2">This is a very useful concept, and it should be used with care, and we should be aware of </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">its cost.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor418"/><span class="koboSpan" id="kobo.590.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.591.1">In this chapter, we saw the main considerations that we need to take into account when we design our APIs. </span><span class="koboSpan" id="kobo.591.2">Most of them were related to Protobuf since it is the interface of our API, and it handles serialization/deserialization. </span><span class="koboSpan" id="kobo.591.3">We saw that choosing the right integer type is important and can lead to problems in terms of payload size but also when we want to evolve </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">our API.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">After that, we saw that choosing the r</span><a id="_idTextAnchor419"/><span class="koboSpan" id="kobo.594.1">ight field tag is also important. </span><span class="koboSpan" id="kobo.594.2">This is due to the fact that tags are serialized along with the data</span><a id="_idTextAnchor420"/><span class="koboSpan" id="kobo.595.1"> and that they are serialized as </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">varints</span></strong><span class="koboSpan" id="kobo.597.1">. </span><span class="koboSpan" id="kobo.597.2">So the bigger the tag, the bigger </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">our payload.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">Then, we saw how we can leverage </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">FieldMasks</span></strong><span class="koboSpan" id="kobo.601.1"> to select the data that we need and avoid the over-fetching problem. </span><span class="koboSpan" id="kobo.601.2">While this is a concept that is not that developed in gRPC Go, other implementations use that extensively. </span><span class="koboSpan" id="kobo.601.3">This significantly reduces the payload that we send across </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">the wire.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">And finally, we saw that we need to be careful when using repeated fields in Protobuf. </span><span class="koboSpan" id="kobo.603.2">This is because if we use them on a complex type, we will waste some bytes. </span><span class="koboSpan" id="kobo.603.3">However, repeated fields should not be avoided because of that. </span><span class="koboSpan" id="kobo.603.4">Sometimes they are the right data structure. </span><span class="koboSpan" id="kobo.603.5">In the next chapter, we are going to cover how to make API calls efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">and secure.</span></span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor421"/><span class="koboSpan" id="kobo.605.1">Quiz</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.606.1">Why is it not always more optimal to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">varint</span></strong><span class="koboSpan" id="kobo.608.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">integer types?</span></span><ol><li><span class="koboSpan" id="kobo.610.1">No reason, they are always more optimal than </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">fixed integers</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">varint</span></strong><span class="koboSpan" id="kobo.613.1"> encoding serializes bigger numbers into a bigger amount </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">of bytes</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">varint</span></strong><span class="koboSpan" id="kobo.616.1"> encoding serializes smaller numbers into a bigger amount </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">of bytes</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.618.1">How can we get the number of bytes a message will be </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">serialized into?</span></span><ol><li><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">proto.Marshal + </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">len</span></strong></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">proto.UnMarshal + </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">len</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">len</span></strong></span></li></ol></li>
<li><span class="koboSpan" id="kobo.625.1">What kind of tag should we give to fields that are </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">often populated?</span></span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.627.1">Bigger tags</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.628.1">Smaller tags</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.629.1">What is the main problem of splitting messages to use </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">smaller tags?</span></span><ol><li><span class="koboSpan" id="kobo.631.1">We have overhead because sub-messages are serialized as </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">length-delimited types</span></span></li><li><span class="koboSpan" id="kobo.633.1">No problem – this is the way </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">to go</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.635.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">FieldMask</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">?</span></span><ol><li><span class="koboSpan" id="kobo.639.1">A collection of fields’ paths telling us what data </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">to exclude</span></span></li><li><span class="koboSpan" id="kobo.641.1">A collection of fields’ paths telling us what data </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">to include</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.643.1">When is a repeated field serialized </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">as unpacked?</span></span><ol><li><span class="koboSpan" id="kobo.645.1">When repeated fields are acting on </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">scalar types</span></span></li><li><span class="koboSpan" id="kobo.647.1">Only when we use the packed option with the </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">value </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">false</span></strong></span></li><li><span class="koboSpan" id="kobo.650.1">When repeated fields are acting on </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">complex types</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-132"><a id="_idTextAnchor422"/><span class="koboSpan" id="kobo.652.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.653.1">B</span></li>
<li><span class="koboSpan" id="kobo.654.1">A</span></li>
<li><span class="koboSpan" id="kobo.655.1">B</span></li>
<li><span class="koboSpan" id="kobo.656.1">A</span></li>
<li><span class="koboSpan" id="kobo.657.1">B</span></li>
<li><span class="koboSpan" id="kobo.658.1">C</span></li>
</ol>
</div>
</body></html>