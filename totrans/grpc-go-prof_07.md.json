["```go\n$ kind create cluster --config k8s/kind.yaml\n```", "```go\n$ kind delete cluster\n```", "```go\nfunc Error(c codes.Code, msg string) error\nfunc Errorf(c codes.Code, format string, a ...interface{}) error\n```", "```go\nimport (\n  //...\n  \"google.golang.org/grpc/codes\"\n  \"google.golang.org/grpc/status\"\n}\nfunc (s *server) AddTask(_ context.Context, in *pb.AddTaskRequest)\n(*pb.AddTaskResponse, error) {\n  if len(in.Description) == 0 {\n    return nil, status.Error(\n      codes.InvalidArgument,\n      \"expected a task description, got an empty string\",\n    )\n  }\n  if in.DueDate.AsTime().Before(time.Now().UTC()) {\n    return nil, status.Error(\n      codes.InvalidArgument,\n      \"expected a task due_date that is in the future\",\n    )\n  }\n  //...\n}\n```", "```go\nfunc (s *server) AddTask(_ context.Context, in *pb.AddTaskRequest) (*pb.AddTaskResponse, error) {\n  //...\n  id, err := s.d.addTask(in.Description,\n  in.DueDate.AsTime())\n  if err != nil {\n    return nil, status.Errorf(\n      codes.Internal,\n      \"unexpected error: %s\",\n      err.Error(),\n    )\n  }\n  //...\n}\n```", "```go\nres, err := c.AddTask(context.Background(), req)\nif err != nil {\n  panic(err)\n}\n```", "```go\nimport (\n  //...\n  \"google.golang.org/grpc/codes\"\n  \"google.golang.org/grpc/status\"\n)\nfunc main() {\n  //...\n  fmt.Println(\"-------ERROR-------\")\n  addTask(c, \"\", dueDate)\n  fmt.Println(\"-------------------\")\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n-------ERROR-------\npanic: rpc error: code = InvalidArgument desc = expected a task description, got an empty string\n```", "```go\nfmt.Println(\"-------ERROR-------\")\n// addTask(c, \"\", dueDate)\naddTask(c, \"not empty\", time.Now().Add(-5 * time.Second))\nfmt.Println(\"-------------------\")\n```", "```go\n$ go run ./client 0.0.0.0:50051\n-------ERROR-------\npanic: rpc error: code = InvalidArgument desc = expected a task due_\ndate that is in the future\n```", "```go\n$ go run ./client 0.0.0.0:50051\n-------ERROR-------\npanic: rpc error: code = Internal desc = unexpected error: <AN_ERROR_\nMESSAGE>\n```", "```go\nrpc error: code = InvalidArgument desc = expected a task due_date that\nis in the future\n```", "```go\nInvalidArgument: expected a task due_date that is in the future\n```", "```go\nfunc addTask(c pb.TodoServiceClient, description string, dueDate time.\n  Time) uint64 {\n  //...\n  res, err := c.AddTask(context.Background(), req)\n\n  if err != nil {\n    if s, ok := status.FromError(err); ok {\n      switch s.Code() {\n      case codes.InvalidArgument, codes.Internal:\n        log.Fatalf(\"%s: %s\", s.Code(), s.Message())\n      default:\n        log.Fatal(s)\n      }\n    } else {\n      panic(err)\n    }\n  }\n  //...\n}\n```", "```go\n$ go run ./client 0.0.0.0:50051\n-------ERROR-------\nInvalidArgument: expected a task due_date that is in the future\n```", "```go\nNo dependencies were provided.\nCheck that imports in Go sources match importpath attributes in deps.\n```", "```go\n$ bazel run //:gazelle\n```", "```go\n$ bazel run //server:server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n$ bazel run //client:client 0.0.0.0:50051\n```", "```go\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()\n```", "```go\nfunc printTasks(c pb.TodoServiceClient) {\n  ctx, cancel := context.WithCancel(context.Background())\n  defer cancel()\n  //...\n  stream, err := c.ListTasks(ctx, req)\n  //...\n  for {\n    //...\n    if res.Overdue {\n      log.Printf(\"CANCEL called\")\n      cancel()\n    }\n    fmt.Println(res.Task.String(), \"overdue: \",\n    res.Overdue)\n  }\n}\n```", "```go\nfunc (s *server) ListTasks(req *pb.ListTasksRequest, stream\n  pb.TodoService_ListTasksServer) error {\n  return s.d.getTasks(func(t interface{}) error {\n    //...\n    log.Println(task)\n    overdue := //...\n    err := stream.Send(&pb.ListTasksResponse{\n      //...\n    })\n    return err\n  })\n}\n```", "```go\nfmt.Println(\"-------UPDATE------\")\nupdateTasks(c, []*pb.UpdateTasksRequest{\n  {Id: id1, Description: \"A better name for the task\"},\n  //...\n}...)\nprintTasks(c, nil)\nfmt.Println(\"-------------------\")\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\nCANCEL called.\n```", "```go\nfunc (s *server) ListTasks(req *pb.ListTasksRequest, stream\n  pb.TodoService_ListTasksServer) error {\n  ctx := stream.Context()\n  return s.d.getTasks(func(t interface{}) error {\n    select {\n    case <-ctx.Done():\n      switch ctx.Err() {\n      case context.Canceled:\n        log.Printf(\"request canceled: %s\", ctx.Err())\n      default:\n      }\n      return ctx.Err()\n    /// TODO: replace following case by 'default:' on production APIs.\n    case <-time.After(1 * time.Millisecond):\n    }\n    //...\n  })\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n//...\nCANCEL called\nid:1 description:\"A better name for the task\" due_date:{} overdue:  true\nunexpected error: rpc error: code = Canceled desc = context canceled\n```", "```go\nrequest canceled: context canceled\n```", "```go\nctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond)\ndefer cancel()\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n//...\nunexpected error: rpc error: code = DeadlineExceeded desc = context\n  deadline exceeded\n```", "```go\nfunc (s *server) ListTasks(req *pb.ListTasksRequest, stream\n  pb.TodoService_ListTasksServer) error {\n  ctx := stream.Context()\n  return s.d.getTasks(func(t interface{}) error {\n    select {\n    case <-ctx.Done():\n      switch ctx.Err() {\n      //...\n      case context.DeadlineExceeded:\n        log.Printf(\"request deadline exceeded: %s\",\n        ctx.Err())\n      }\n      return ctx.Err()\n    //...\n  }\n  //...\n}\n```", "```go\nrequest deadline exceeded: context deadline exceeded\n```", "```go\nfunc (s *server) UpdateTasks(stream pb.TodoService_UpdateTasksServer) error {\n  ctx := stream.Context()\n  md, _ := metadata.FromIncomingContext(ctx)\n  //...\n}\n```", "```go\nfunc (s *server) UpdateTasks(stream pb.TodoService_UpdateTasksServer) error {\n  ctx := stream.Context()\n  md, _ := metadata.FromIncomingContext(ctx)\n  if t, ok := md[\"auth_token\"]; ok {\n    switch {\n    case len(t) != 1:\n      return status.Errorf(\n        codes.InvalidArgument,\n        \"auth_token should contain only 1 value\",\n      )\n    case t[0] != \"authd\":\n      return status.Errorf(\n        codes.Unauthenticated,\n        \"incorrect auth_token\",\n      )\n    }\n  } else {\n    return status.Errorf(\n      codes.Unauthenticated,\n      \"failed to get auth_token\",\n    )\n  }\n  //...\n}\n```", "```go\nfunc updateTasks(c pb.TodoServiceClient, reqs ...*pb.\n  UpdateTasksRequest) {\n  ctx := context.Background()\n  ctx = metadata.AppendToOutgoingContext(ctx, \"auth_token\", \"authd\")\n  stream, err := c.UpdateTasks(ctx)\n  //...\n}\n```", "```go\nmetadata.AppendToOutgoingContext(ctx, K1, V1, K2, V2, ...)\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\nunexpected error: rpc error: code = Unauthenticated desc = incorrect\nauth_token\n```", "```go\nunexpected error: rpc error: code = Unauthenticated desc = failed to\nget auth_token\n```", "```go\nctx = metadata.AppendToOutgoingContext(ctx, \"auth_token\", \"authd\", \n\"auth_token\", \"authd\")\n```", "```go\nunexpected error: rpc error: code = InvalidArgument desc = auth_token\nshould contain only 1 value\n```", "```go\nfunc unaryInterceptor(ctx context.Context, req interface{}, info\n*grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error)\n```", "```go\nfunc streamInterceptor(srv interface{}, ss grpc.ServerStream, info\n*grpc.StreamServerInfo, handler grpc.StreamHandler) error\n```", "```go\nimport (\n  \"context\"\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/codes\"\n  \"google.golang.org/grpc/metadata\"\n  \"google.golang.org/grpc/status\"\n)\nconst authTokenKey string = \"auth_token\"\nconst authTokenValue string = \"authd\"\nfunc validateAuthToken(ctx context.Context) error {\n  md, _ := metadata.FromIncomingContext(ctx)\n  if t, ok := md[authTokenKey]; ok {\n    switch {\n    case len(t) != 1:\n      return status.Errorf(\n        codes.InvalidArgument,\n        fmt.Sprintf(\"%s should contain only 1 value\", authTokenKey),\n     )\n    case t[0] != authTokenValue:\n      return status.Errorf(\n        codes.Unauthenticated,\n        fmt.Sprintf(\"incorrect %s\", authTokenKey),\n      )\n    }\n  } else {\n    return status.Errorf(\n      codes.Unauthenticated,\n      fmt.Sprintf(\"failed to get %s\", authTokenKey),\n    )\n  }\n  return nil\n}\n```", "```go\nfunc unaryAuthInterceptor(ctx context.Context, req interface{}, info\n*grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n  if err := validateAuthToken(ctx); err != nil {\n    return nil, err\n  }\n  return handler(ctx, req)\n}\n```", "```go\nfunc streamAuthInterceptor(srv interface{}, ss grpc.ServerStream, info\n*grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n  if err := validateAuthToken(ss.Context()); err != nil {\n    return err\n  }\n  return handler(srv, ss)\n}\n```", "```go\nvar opts []grpc.ServerOption\ns := grpc.NewServer(opts...)\n```", "```go\nopts := []grpc.ServerOption{\n  grpc.UnaryInterceptor(unaryAuthInterceptor),\n  grpc.StreamInterceptor(streamAuthInterceptor),\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n--------ADD--------\nrpc error: code = Unauthenticated desc = failed to get auth_token\nexit status 1\n```", "```go\nfunc unaryInterceptor(ctx context.Context, method string, req\ninterface{}, reply interface{}, cc *grpc.ClientConn, invoker grpc.\nUnaryInvoker, opts ...grpc.CallOption) error\n```", "```go\nfunc streamInterceptor(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error)\n```", "```go\nimport (\n  \"context\"\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/metadata\"\n)\nconst authTokenKey string = \"auth_token\"\nconst authTokenValue string = \"authd\"\nfunc unaryAuthInterceptor(ctx context.Context, method string, req,\n  reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker,\n    opts ...grpc.CallOption) error {\n  ctx = metadata.AppendToOutgoingContext(ctx, authTokenKey,\n      authTokenValue)\n  err := invoker(ctx, method, req, reply, cc, opts...)\n  return err\n}\nfunc streamAuthInterceptor(ctx context.Context, desc *grpc.StreamDesc,\n  cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts     ...grpc.CallOption) (grpc.ClientStream, error) {\n  ctx = metadata.AppendToOutgoingContext(ctx, authTokenKey,      authTokenValue)\n  s, err := streamer(ctx, desc, cc, method, opts...)\n  if err != nil {\n    return nil, err\n  }\n  return s, nil\n}\n```", "```go\nopts := []grpc.DialOption{\n  grpc.WithTransportCredentials(insecure.NewCredentials()),\n}\n```", "```go\nopts := []grpc.DialOption{\n  //...\n  grpc.WithUnaryInterceptor(unaryAuthInterceptor),\n  grpc.WithStreamInterceptor(streamAuthInterceptor),\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\nfunc compressedSize[M protoreflect.ProtoMessage](msg M) (int, int) {\n  var b bytes.Buffer\n  gz := gzip.NewWriter(&b)\n  out, err:= proto.Marshal(msg)\n  if err != nil {\n    log.Fatal(err)\n  }\n  if _, err := gz.Write(out); err != nil {\n    log.Fatal(err)\n  }\n  if err := gz.Close(); err != nil {\n    log.Fatal(err)\n  }\n  return len(out), len(b.Bytes())\n}\n```", "```go\nfunc main() {\n  var data int32 = 268_435_456\n  i32 := &wrapperspb.Int32Value{\n    Value: data,\n  }\n  o, c := compressedSize(i32)\n  fmt.Printf(\"original: %d\\ncompressed: %d\\n\", o, c)\n}\n```", "```go\n$ go run gzip.go\noriginal: 6\ncompressed: 30\n```", "```go\nsyntax = \"proto3\";\npackage todo;\nimport \"google/protobuf/timestamp.proto\";\noption go_package = \"github.com/PacktPublishing/gRPC-Go-for-Professionals/helpers/proto\";\nmessage Task {\n  uint64 id = 1;\n  string description = 2;\n  bool done = 3;\n  google.protobuf.Timestamp due_date = 4;\n}\n```", "```go\n$ protoc --go_out=. \\\n         --go_opt=module=github.com/PacktPublishing/\n                 gRPC-Go-for-Professionals/helpers \\\n         proto/todo.proto\n```", "```go\nfunc main() {\n  task := &pb.Task{\n    Id: 1,\n    Description: \"This is a task\",\n    DueDate: timestamppb.New(time.Now().Add(5 * 24 *\n    time.Hour)),\n  }\n  o, c := compressedSize(task)\n  fmt.Printf(\"original: %d\\ncompressed: %d\\n\", o, c)\n}\n```", "```go\n$ go run gzip.go\noriginal: 32\ncompressed: 57\n```", "```go\ntask := &pb.Task{\n  //...\n  Description: `This is a task that is quite long and requires a lot\n  of work.\n  We are not sure we can finish it even after 5 days.\n  Some planning will be needed and a meeting is required.`,\n  //...\n}\n```", "```go\n$ go run gzip.go\noriginal: 192\ncompressed: 183\n```", "```go\n_ \"google.golang.org/grpc/encoding/gzip\"\n```", "```go\nopts := []grpc.DialOption{\n  //...\n  grpc.WithDefaultCallOptions(grpc.UseCompres\n  sor(gzip.Name))\n}\n```", "```go\nres, err := c.AddTask(context.Background(), req, grpc.UseCompressor(gzip.Name))\n```", "```go\n$ curl https://raw.githubusercontent.com/grpc/grpc-go/master/examples/\ndata/x509/server_cert.pem --output server_cert.pem\n$ curl https://raw.githubusercontent.com/grpc/grpc-go/master/examples/\ndata/x509/server_key.pem --output server_key.pem\n```", "```go\n$ curl https://raw.githubusercontent.com/grpc/grpc-go/master/examples/\ndata/x509/ca_cert.pem --output ca_cert.pem\n```", "```go\nfunc main() {\n  //...\n  creds, err := credentials.NewServerTLSFrom\n  File(\"./certs/server_cert.pem\", \"./certs/server_key.pem\")\n  if err != nil {\n    log.Fatalf(\"failed to create credentials: %v\", err)\n  }\n}\n```", "```go\nopts := []grpc.ServerOption{\n  grpc.Creds(creds),\n  //...\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n--------ADD--------\nrpc error: code = Unavailable desc = connection error: desc = \"error\nreading server preface: EOF\"\n```", "```go\ncreds, err := credentials.NewClientTLSFromFile(\"./certs/ca_cert.pem\",\n  \"x.test.example.com\")\nif err != nil {\n  log.Fatalf(\"failed to load credentials: %v\", err)\n}\n```", "```go\nopts := []grpc.DialOption{\n  grpc.WithTransportCredentials(creds),\n  //grpc.WithTransportCredentials(insecure.NewCredentials())\n  //...\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\nexports_files([\n  \"server_cert.pem\",\n  \"server_key.pem\",\n  \"ca_cert.pem\"\n])\n```", "```go\ngo_library(\n  name = \"server_lib\",\n  //...\n  data = [\n    \"//certs:server_cert.pem\",\n    \"//certs:server_key.pem\",\n  ],\n  //...\n)\n```", "```go\ngo_library(\n  name = \"client_lib\",\n  //...\n  data = [\n    \"//certs:ca_cert.pem\",\n  ],\n  //...\n)\n```", "```go\nfunc unaryLogInterceptor(ctx context.Context, req interface{}, info\n*grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {\n  log.Println(info.FullMethod, \"called\")\n  return handler(ctx, req)\n}\nfunc streamLogInterceptor(srv interface{}, ss grpc.ServerStream, info\n  *grpc.StreamServerInfo, handler grpc.StreamHandler) error {\n  log.Println(info.FullMethod, \"called\")\n  return handler(srv, ss)\n}\n```", "```go\nopts := []grpc.ServerOption{\n  //...\n  grpc.ChainUnaryInterceptor(unaryAuthInterceptor,\n  unaryLogInterceptor),\n  grpc.ChainStreamInterceptor(streamAuthInterceptor,\n  streamLogInterceptor),\n}\n```", "```go\nopts := []grpc.DialOption{\n  //...\n  grpc.WithDefaultServiceConfig(`{\"loadBalancingConfig\":\n  [{\"round_robin\":{}}]}`),\n}\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\n$ go run ./client dns:///$HOSTNAME:50051\n```", "```go\napiVersion: v1\nkind: Service\nmetadata:\n  name: todo-server\nspec:\n  clusterIP: None\nports:\n  - name: grpc\n    port: 50051\n  selector:\n    app: todo-server\n```", "```go\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: todo-server\n  labels:\n    app: todo-server\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: todo-server\n  template:\n    metadata:\n      labels:\n        app: todo-server\n    spec:\n      containers:\n      - name: todo-server\n        image: clementjean/grpc-go-packt-book:server\n        ports:\n        - name: grpc\n          containerPort: 50051\n```", "```go\n$ kubectl apply -f k8s/server.yaml\n```", "```go\n$ kubectl get pods\nNAME                           READY   STATUS\ntodo-server-85cf594fb6-tkqm9   1/1     Running\ntodo-server-85cf594fb6-vff6q   1/1     Running\ntodo-server-85cf594fb6-w4s6l   1/1     Running\n```", "```go\napiVersion: v1\nkind: Pod\nmetadata:\n  name: todo-client\nspec:\n  containers:\n  - name: todo-client\n    image: clementjean/grpc-go-packt-book:client\n  restartPolicy: Never\n```", "```go\n$ kubectl apply -f k8s/client.yaml\n```", "```go\n$ kubectl get pods\nNAME                           READY   STATUS\ntodo-client                    0/1     Completed\n```", "```go\n$ kubectl logs todo-server-85cf594fb6-tkqm9\nlistening at 0.0.0.0:50051\n/todo.v2.TodoService/UpdateTasks called\n/todo.v2.TodoService/ListTasks called\n\n$ kubectl logs todo-server-85cf594fb6-vff6q\nlistening at 0.0.0.0:50051\n/todo.v2.TodoService/DeleteTasks called\n\n$ kubectl logs todo-server-85cf594fb6-w4s6l\nlistening at 0.0.0.0:50051\n/todo.v2.TodoService/AddTask called\n/todo.v2.TodoService/AddTask called\n/todo.v2.TodoService/AddTask called\n/todo.v2.TodoService/ListTasks called\n/todo.v2.TodoService/ListTasks called\n```"]