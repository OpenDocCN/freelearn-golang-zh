<html><head></head><body>
<div id="_idContainer024">
<h1 class="chapter-number" id="_idParaDest-150"><a id="_idTextAnchor605"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-151"><a id="_idTextAnchor606"/><span class="koboSpan" id="kobo.2.1">More Essential Features</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We saw previously that gRPC gives us a lot of important out-of-the-box features that make our job simpler. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we are going to delve deeper into some of the important features that are not included in gRPC but are provided by the community. </span><span class="koboSpan" id="kobo.3.3">They generally build on top of the gRPC features to provide more convenience. </span><span class="koboSpan" id="kobo.3.4">They also provide a way to implement the most common practices to protect and optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">your APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we are going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Validating </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">request messages</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">a middleware</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Authenticating requests</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Tracing </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">API calls</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Applying </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">rate limiting</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Retrying </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">on error</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.18.1">By the end of the chapter, we will have learned what middleware are and what they are used for. </span><span class="koboSpan" id="kobo.18.2">And we are going to do that by learning more about the awesome community projects called </span><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">protoc-gen-validate</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.20.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.21.1">go-grpc-middleware</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor607"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">For this chapter, you will find the relevant code in the folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">chapter8</span></strong><span class="koboSpan" id="kobo.26.1"> in the accompanying GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">repository (</span></span><a href="https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter8"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter8</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">).</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor608"/><span class="koboSpan" id="kobo.30.1">Validating requests</span></h1>
<p><span class="koboSpan" id="kobo.31.1">The first thing</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.32.1"> that we are going to do is reduce the code that checks some properties of the request messages. </span><span class="koboSpan" id="kobo.32.2">We are going to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.34.1"> plugin for </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">protoc</span></strong><span class="koboSpan" id="kobo.36.1">, which helps us generate validation code for certain messages. </span><span class="koboSpan" id="kobo.36.2">This can be useful for the use case when we check the description length and the due date of a task. </span><span class="koboSpan" id="kobo.36.3">We will just call a </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.37.1">generate</span><a id="_idTextAnchor609"/><span class="koboSpan" id="kobo.38.1">d </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">Validate()</span></strong><span class="koboSpan" id="kobo.40.1"> function and it will tell us whether the requirements for the request message </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">are fulfilled.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">The first thing that we are going to do to generate this code is to install the plugin. </span><span class="koboSpan" id="kobo.42.2">This is a plugin maintained by Buf and you can get it </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.44.1">
$ go install github.com/envoyproxy/protoc-gen-validate</span></pre>
<p><span class="koboSpan" id="kobo.45.1">Once we have that, we are now able to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">--validate_out</span></strong><span class="koboSpan" id="kobo.47.1"> option </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">from protoc.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Now, whether we are using protoc manually or with the Buf CLI, we will need to copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">validate.proto</span></strong><span class="koboSpan" id="kobo.51.1"> file from the GitHub repository. </span><span class="koboSpan" id="kobo.51.2">This file can be found here: </span><a href="https://github.com/bufbuild/protoc-gen-validate/blob/main/validate/validate.proto"><span class="koboSpan" id="kobo.52.1">https://github.com/bufbuild/protoc-gen-validate/blob/main/validate/validate.proto</span></a><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">We will copy it into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">proto</span></strong><span class="koboSpan" id="kobo.55.1"> folder under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">validate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.57.1"> directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.58.1">
proto
└── validate
    └── validate.proto</span></pre>
<p><span class="koboSpan" id="kobo.59.1">And now, we can import that file into other proto files and use the validation rules provided as </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">field options.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Let us work with </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">AddTaskRequest</span></strong><span class="koboSpan" id="kobo.63.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">proto/todo/v</span><a id="_idTextAnchor610"/><span class="koboSpan" id="kobo.65.1">2/todo.proto</span></strong><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">Right now, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.68.1">
messag</span><a id="_idTextAnchor611"/><span class="koboSpan" id="kobo.69.1">e AddTaskRequest {
  string description = 1;
  google.protobuf.Timestamp due_date = 2;
}</span></pre>
<p><span class="koboSpan" id="kobo.70.1">As we know, each time we try to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">Task</span></strong><span class="koboSpan" id="kobo.72.1">, on the server side, we will check whether the description is empty or not and whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">due_date</span></strong><span class="koboSpan" id="kobo.74.1"> is greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">time.Now()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.76.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">We are now going to encode this logic into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">proto</span></strong><span class="koboSpan" id="kobo.79.1"> file. </span><span class="koboSpan" id="kobo.79.2">The first thing that we need to do is import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">validate.proto</span></strong><span class="koboSpan" id="kobo.81.1"> file. </span><span class="koboSpan" id="kobo.81.2">Then, we will have access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">validate.rules</span></strong><span class="koboSpan" id="kobo.83.1"> field option, which contains a set of rules for multiple types. </span><span class="koboSpan" id="kobo.83.2">We are going to work on </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">string</span></strong><span class="koboSpan" id="kobo.85.1"> an</span><a id="_idTextAnchor612"/><span class="koboSpan" id="kobo.86.1">d </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">Timestamp</span></strong><span class="koboSpan" id="kobo.88.1"> and we are going to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">min_len</span></strong><span class="koboSpan" id="kobo.90.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">gt_now</span></strong><span class="koboSpan" id="kobo.92.1"> fields. </span><span class="koboSpan" id="kobo.92.2">The first one describes the minimum length that the string should have when we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">Validate</span></strong><span class="koboSpan" id="kobo.94.1"> and the second one tells us that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">Timestamp</span></strong><span class="koboSpan" id="kobo.96.1"> provided should </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.97.1">be in </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">the future:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.99.1">
import "validate/validate.proto";
//...
</span><span class="koboSpan" id="kobo.99.2">message AddTaskRequest {
  string description = 1 [
    </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">(validate.rules).string.min_len = 1</span></strong><span class="koboSpan" id="kobo.101.1">
  ];
  google.protobuf.Timestamp due_date = 2 [
    </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">(validate.rules).timestamp.gt_now = true</span></strong><span class="koboSpan" id="kobo.103.1">
  ];
}</span></pre>
<p><span class="koboSpan" id="kobo.104.1">Now that we have described this logic, we will need to generate code that checks that logic. </span><span class="koboSpan" id="kobo.104.2">Otherwise, these options are worthless. </span><span class="koboSpan" id="kobo.104.3">To generate this code, we are going to do it manually with protoc and then I will show you how to do it with Buf </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">and Bazel.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">As mentioned, with the plugin we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">--validate_out</span></strong><span class="koboSpan" id="kobo.108.1"> option in </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">protoc</span></strong><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">This looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
$ protoc -Iproto --go_out=proto --go_opt=paths=
  source_relative --go-grpc_out=proto --go-grpc_opt=
    paths=source_relative</span><a id="_idTextAnchor613"/><span class="koboSpan" id="kobo.113.1"> --validate_out=
"</span><strong class="bold"><span class="koboSpan" id="kobo.114.1">lang=go</span></strong><span class="koboSpan" id="kobo.115.1">,paths=source_relative:proto" proto/todo/v2/*.proto</span></pre>
<p><span class="koboSpan" id="kobo.116.1">Notice that the command </span><a id="_idTextAnchor614"/><span class="koboSpan" id="kobo.117.1">is similar to what we ran in the past. </span><span class="koboSpan" id="kobo.117.2">We simply added the new option and told it to work on Go code and to generate code based on the proto files in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">v2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.119.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">And now, on top of the Protobuf and gRPC generated code, you should also have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">.pb.validate.go</span></strong><span class="koboSpan" id="kobo.122.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">v2</span></strong><span class="koboSpan" id="kobo.124.1"> folder. </span><span class="koboSpan" id="kobo.124.2">This should look </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
proto/todo/v2
├── todo.pb.go
├── </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">todo.pb.validate.go</span></strong><span class="koboSpan" id="kobo.128.1">
├── todo.proto
└── todo_grpc.pb.go</span></pre>
<p><span class="koboSpan" id="kobo.129.1">Inside the generated</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.130.1"> file, you should be able to see the following function (</span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">among others):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
// Validate checks the field values on Task with the rules
defined in the proto
// definition for this message. </span><span class="koboSpan" id="kobo.132.2">If any rules are violated,
the first error
// encountered is returned, or nil if there are no
violations.
</span><span class="koboSpan" id="kobo.132.3">func (m *Ta</span><a id="_idTextAnchor615"/><span class="koboSpan" id="kobo.133.1">sk) Validate() error {
  return m.validate(false)
}</span></pre>
<p><span class="koboSpan" id="kobo.134.1">This is the function that we are now going to use in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">AddTask</span></strong><span class="koboSpan" id="kobo.136.1"> endpoint on the server side. </span><span class="koboSpan" id="kobo.136.2">Right now, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">following checks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
func (s *server) AddTask(_ context.Context, in
*pb.AddTaskRequest) (*pb.AddTaskResponse, error) {
  if len(in.Description) == 0 {
    return nil, status.Error(
      codes.InvalidArgument,
      "expected a task description, got an empty string",
    )
  }
  if in.DueDate.AsT</span><a id="_idTextAnchor616"/><span class="koboSpan" id="kobo.139.1">ime().Before(time.</span><a id="_idTextAnchor617"/><span class="koboSpan" id="kobo.140.1">Now().UTC()) {
    return nil, status.Error(
      codes.InvalidArgument,
      "expected a task due_date that is in the future",
    )
  }
  //...
</span><span class="koboSpan" id="kobo.140.2">}</span></pre>
<p><span class="koboSpan" id="kobo.141.1">Let us replace that </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.142.1">with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">Validate</span></strong><span class="koboSpan" id="kobo.144.1"> function. </span><span class="koboSpan" id="kobo.144.2">We are simply going to call the function on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">in</span></strong><span class="koboSpan" id="kobo.146.1"> parameter and if it returns any error, we will return the error from the function, otherwise, we will simply continue with </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">our execution:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
func (s *server) AddTask(_ context.Context, in
*pb.AddTaskRequest) (*pb.AddTaskResponse, error) {
</span><a id="_idTextAnchor618"/><span class="koboSpan" id="kobo.149.1">  if err := in.Validat</span><a id="_idTextAnchor619"/><span class="koboSpan" id="kobo.150.1">e(); er</span><a id="_idTextAnchor620"/><span class="koboSpan" id="kobo.151.1">r != nil {
    return nil, err
  }
  //...
</span><span class="koboSpan" id="kobo.151.2">}</span></pre>
<p><span class="koboSpan" id="kobo.152.1">It is as simple as that, and we saved ourselves from writing all the checks manually and trying to keep our error messages consistent across the </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">different endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">We can now go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">main</span></strong><span class="koboSpan" id="kobo.156.1"> client and uncomment the functions, one by one, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">error section:</span></span></p>
<pre class="source-code">
<a id="_idTextAnchor621"/><span class="koboSpan" id="kobo.158.1">func main() {
  //...
</span><span class="koboSpan" id="kobo.158.2">  fmt.Println("-------ERROR-------")
  </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">addTask(c, "", dueDate)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.160.1">  addTask(c, "not empty", time</span><a id="_idTextAnchor622"/><span class="koboSpan" id="kobo.161.1">.Now().Add(-5*time.Second))</span></strong><span class="koboSpan" id="kobo.162.1">
  fmt.Println("-------------------")
}</span></pre>
<p><span class="koboSpan" id="kobo.163.1">We should get </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.164.1">the following error for the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">first </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">addTask</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">:</span></span><a id="_idTextAnchor623"/></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.168.1">$ go run ./client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.169.1">
-------ERROR-------
rpc error: code = Unknown desc = invalid AddTaskRequest
.Description: value length must be at le</span><a id="_idTextAnchor624"/><span class="koboSpan" id="kobo.170.1">ast 1 runes</span></pre>
<p><span class="koboSpan" id="kobo.171.1">And this one for the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">second </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">addTask</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">:</span></span><a id="_idTextAnchor625"/></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.175.1">$ go run ./client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.176.1">
-------ERROR-------
rpc error: code = Unknown desc = invalid AddTaskRequest
.DueDate: value must be greater than now</span></pre>
<p><span class="koboSpan" id="kobo.177.1">Notice that the code error is </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">Unknown</span></strong><span class="koboSpan" id="kobo.179.1">. </span><span class="koboSpan" id="kobo.179.2">As of the time of writing this book, </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.181.1"> does not appear to have a custom error code. </span><span class="koboSpan" id="kobo.181.2">This might appear in </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">v2</span></strong><span class="koboSpan" id="kobo.183.1"> of the plugin. </span><span class="koboSpan" id="kobo.183.2">However, it </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.184.1">provides us with a simple validation code and clean </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">error messages.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor626"/><span class="koboSpan" id="kobo.186.1">Buf</span></h2>
<p><span class="koboSpan" id="kobo.187.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.189.1"> with </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.190.1">the </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.191.1">Buf CLI is</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.192.1"> simple. </span><span class="koboSpan" id="kobo.192.2">We</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.193.1"> will add some configuration in our </span><a id="_idTextAnchor627"/><span class="koboSpan" id="kobo.194.1">YAML files in order to generate the code. </span><span class="koboSpan" id="kobo.194.2">The first thing that we need to add is the dependency on </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.196.1"> in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">buf.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.199.1">
version: v1
#...
</span><span class="koboSpan" id="kobo.199.2">deps:
- buf.build/envoyproxy/protoc-gen-validate</span></pre>
<p><span class="koboSpan" id="kobo.200.1">This tells Buf that we need </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.202.1"> during the generation process. </span><span class="koboSpan" id="kobo.202.2">It will later figure out how to pull the dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">by itself.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">And after that, we need to configure the plugin in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">buf.gen.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
version: v1
plugins:
  #...
</span><span class="koboSpan" id="kobo.207.2">  - plugin: </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">buf.build/bufbuild/validate-go</span></strong><span class="koboSpan" id="kobo.209.1">
    out: proto
    opt: </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">paths=source_relative</span></strong></pre>
<p><span class="koboSpan" id="kobo.211.1">These options are the same as we typed manually earlier. </span><span class="koboSpan" id="kobo.211.2">Now, we can generate as usual by typing the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
$ buf generate proto</span></pre>
<p><span class="koboSpan" id="kobo.214.1">You should now have the same three generated files that we obtained with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">protoc</span></strong><span class="koboSpan" id="kobo.216.1"> command: </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">todo.pb.validate.go</span></strong><span class="koboSpan" id="kobo.218.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">todo_grpc.pb.go</span></strong><span class="koboSpan" id="kobo.220.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">todo.pb.go</span></strong><span class="koboSpan" id="kobo.222.1">. </span><span class="koboSpan" id="kobo.222.2">Note that, in this case, we also generated code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">v1</span></strong><span class="koboSpan" id="kobo.224.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">validate.proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor628"/><span class="koboSpan" id="kobo.228.1">Bazel</span></h2>
<p><span class="koboSpan" id="kobo.229.1">As always, the </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.230.1">first</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.231.1"> thing we </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.232.1">need to do is define the dependency in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">WORKSPACE.bazel</span></strong><span class="koboSpan" id="kobo.234.1"> file. </span><span class="koboSpan" id="kobo.234.2">We are going to fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.236.1"> project from GitHub and load its </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">relevant dependencies:</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.238.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.239.1">The code that follows references a variable</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.240.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">PROTOC_GEN_VALIDATE_VERSION</span></strong><span class="koboSpan" id="kobo.242.1">. </span><span class="koboSpan" id="kobo.242.2">This variable is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">versions.bzl</span></strong><span class="koboSpan" id="kobo.244.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">chapter8</span></strong><span class="koboSpan" id="kobo.246.1"> folder. </span><span class="koboSpan" id="kobo.246.2">We do not include it here to keep the code independent </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">of versions.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
#...
</span><span class="koboSpan" id="kobo.248.2">git_repository(
  name = "com_envoyproxy_protoc_gen_validate",
  tag = </span><strong class="bold"><span class="koboSpan" id="kobo.249.1">PROTOC_GEN_VALIDATE_VERSIO</span></strong><a href="https://github.com/bufbuild/protoc-gen-validate"><strong class="bold"><span class="koboSpan" id="kobo.250.1">N</span></strong><span class="koboSpan" id="kobo.251.1">,</span></a>
<a href="https://github.com/bufbuild/protoc-gen-validate"><span class="koboSpan" id="kobo.252.1">  remote = "https://github.com/bufbuild/protoc-ge</span></a><span class="koboSpan" id="kobo.253.1">n-</span><a href="mailto:load(%22@com_envoyproxy_protoc_gen_validate//bazel:repositories.bzl"><span class="koboSpan" id="kobo.254.1">validate"</span></a>
<a href="mailto:load(%22@com_envoyproxy_protoc_gen_validate//bazel:repositories.bzl"><span class="koboSpan" id="kobo.255.1">)</span></a>
<a href="mailto:load(%22@com_envoyproxy_protoc_gen_validate//bazel:repositories.bzl"/>
<a href="mailto:load(%22@com_envoyproxy_protoc_gen_validate//bazel:repositories.bzl"><span class="koboSpan" id="kobo.256.1">load("@com_envoyproxy_protoc_gen_validate//bazel:</span></a>
<a href="mailto:load(%22@com_envoyproxy_protoc_gen_validate//bazel:repositories.bzl"><span class="koboSpan" id="kobo.257.1">  r</span></a><span class="koboSpan" id="kobo.258.1">epositories.bzl", "pgv_</span><a href="mailto:load(%22@com_envoyproxy_protoc_gen_validate//:dependencies.bzl"><span class="koboSpan" id="kobo.259.1">dependencies")</span></a>
<a href="mailto:load(%22@com_envoyproxy_protoc_gen_validate//:dependencies.bzl"><span class="koboSpan" id="kobo.260.1">load("@com_envoyproxy_protoc_gen_validate//</span></a>
<a href="mailto:load(%22@com_envoyproxy_protoc_gen_validate//:dependencies.bzl"><span class="koboSpan" id="kobo.261.1">  :d</span></a><span class="koboSpan" id="kobo.262.1">ependencies.bzl", "go_third_party")
pgv_dependencies()
# gazelle:repository_macro deps.bzl%go_third_party
go_third_party()</span></pre>
<p><span class="koboSpan" id="kobo.263.1">With that, we now need to update our dependencies in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">deps.bzl</span></strong><span class="koboSpan" id="kobo.265.1"> file. </span><span class="koboSpan" id="kobo.265.2">We can do that by typing the </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">following command</span><a id="_idTextAnchor629"/><span class="koboSpan" id="kobo.267.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
$ bazel run //:gazelle-update-repos</span></pre>
<p><span class="koboSpan" id="kobo.269.1">And finally, we need to generate the code and link it to our existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">todo go_library</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.271.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">proto/todo/v2/BUILD.bazel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">The first thing to</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.275.1"> add is the</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.276.1"> dependency on </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">protoc-gen-validate</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.278.1">validate.proto</span></strong><span class="koboSpan" id="kobo.279.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">v2_proto proto_library</span></strong><span class="koboSpan" id="kobo.281.1">. </span><span class="koboSpan" id="kobo.281.2">This will allow </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">todo.proto</span></strong><span class="koboSpan" id="kobo.283.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">import it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
proto_library(
  name = "v2_proto",
  #…
  deps = [
    #...
</span><span class="koboSpan" id="kobo.285.2">    </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">"@com_envoyproxy_protoc_gen_validate//</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.287.1">      validate:validate_proto</span></strong><span class="koboSpan" id="kobo.288.1">",
  ],
)</span></pre>
<p><span class="koboSpan" id="kobo.289.1">Then, we will replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">v2_go_proto go_proto_library</span></strong><span class="koboSpan" id="kobo.291.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">pgv_go_proto_library</span></strong><span class="koboSpan" id="kobo.293.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.294.1">pgv</span></strong><span class="koboSpan" id="kobo.295.1"> stands</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.296.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.298.1">). </span><span class="koboSpan" id="kobo.298.2">On top of that, we will add the dependency to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.300.1"> library so that the generated code accesses any of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.302.1"> internal code n</span><a id="_idTextAnchor630"/><span class="koboSpan" id="kobo.303.1">eeded </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">to compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
load("@com_envoyproxy_protoc_gen_validate//bazel:pgv_proto_
  library.bzl", "pgv_go_proto_library")
//...
</span><strong class="bold"><span class="koboSpan" id="kobo.306.1">pgv_go_proto_library</span></strong><span class="koboSpan" id="kobo.307.1">(
  name = "</span><strong class="bold"><span class="koboSpan" id="kobo.308.1">v2_go_proto</span></strong><span class="koboSpan" id="kobo.309.1">",
  compilers = ["@io_bazel_rules_go//proto:go_grpc"],
  importpath = "github.com/PacktPublishing/gRPC-Go-for-Professionals/
    proto/to</span><a id="_idTextAnchor631"/><span class="koboSpan" id="kobo.310.1">do/v2",
  proto = ":v2_proto",
  deps = ["</span><strong class="bold"><span class="koboSpan" id="kobo.311.1">@com_envoyproxy_protoc_gen_validate//</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.312.1">    validate:validate_go</span></strong><span class="koboSpan" id="kobo.313.1">"</span><a id="_idTextAnchor632"/><span class="koboSpan" id="kobo.314.1">],
)</span></pre>
<p><span class="koboSpan" id="kobo.315.1">And finally, in order to avoid ambiguous imports for </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">validate/validate.proto</span></strong><span class="koboSpan" id="kobo.317.1"> the next time we run Gazelle, we are going to map the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">validate/validate.proto</span></strong><span class="koboSpan" id="kobo.319.1"> import (in </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">proto/todo/v2/todo.proto</span></strong><span class="koboSpan" id="kobo.321.1">) to </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">@com_envoyproxy_protoc_gen_validate//validate:validate_proto</span></strong><span class="koboSpan" id="kobo.323.1"> (defined</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.324.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.326.1">). </span><span class="koboSpan" id="kobo.326.2">At the top </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.327.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">proto/todo/v2/BUILD.bazel</span></strong><span class="koboSpan" id="kobo.329.1"> file, we can add the following </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Gazelle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
# gazelle:resolve proto validate/validate.proto
  @com_envoyproxy_p</span><a id="_idTextAnchor633"/><a id="_idTextAnchor634"/><span class="koboSpan" id="kobo.333.1">rotoc_gen_validate//validate:
  validate_proto</span></pre>
<p><span class="koboSpan" id="kobo.334.1">Now that we have replaced our old </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">v2_go_proto</span></strong><span class="koboSpan" id="kobo.336.1"> with the new one using </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">pgv_go_proto_library</span></strong><span class="koboSpan" id="kobo.338.1">, the code depending on this library will automatically get access to the generated </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Validate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">We can try running </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">the server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.343.1">$ bazel run //server:server 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.344.1">
listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.345.1">And run the client with the error section </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">code uncomme</span><a id="_idTextAnchor635"/><span class="koboSpan" id="kobo.347.1">nted:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.348.1">$ bazel run //client:client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.349.1">
-------ERROR-------
rpc error: code = Unknown desc = invalid AddTaskRequest
.Description: value length</span><a id="_idTextAnchor636"/><span class="koboSpan" id="kobo.350.1"> must be at least 1 runes</span></pre>
<p><span class="koboSpan" id="kobo.351.1">To conclude, we saw that we can encode validation logic in our proto files and generate validation </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.352.1">code </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.353.1">automatically with </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.355.1">. </span><span class="koboSpan" id="kobo.355.2">This declutters our code and provides consistent error messages across our </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">API endpoints.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor637"/><span class="koboSpan" id="kobo.357.1">Middleware = interceptor</span></h1>
<p><span class="koboSpan" id="kobo.358.1">In the context of gRPC, a middleware</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.359.1"> is an interceptor. </span><span class="koboSpan" id="kobo.359.2">It lies between the code</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.360.1"> registered by the developers and the actual gRPC framework. </span><span class="koboSpan" id="kobo.360.2">When gRPC receives some data from the wire, it will pass this data through the middleware first, and then if it is allowed to go through, the data will arrive in the actual </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">endpoint handler.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">These middleware are generally used in order to secure the endpoints against malicious actors or enforce certain prerequisites. </span><span class="koboSpan" id="kobo.362.2">An example of securing the API is rate-limiting clients. </span><span class="koboSpan" id="kobo.362.3">This is a limit on the number of requests that a client can make in a given timeframe and this is important because it prevents a lot of attacks, such as brute force attacks, DoS and DDoS, and web-scraping. </span><span class="koboSpan" id="kobo.362.4">And to enforce a certain prerequisite, we already saw an example where the client needs to be authenticated before being able to call </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">an endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">Before going to see some of the middleware provided by the community, I want to remind you that we already created middleware in </span><a href="B19664_07.xhtml#_idTextAnchor423"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.365.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.366.1">. </span><span class="koboSpan" id="kobo.366.2">We simply never referred to them as middleware. </span><span class="koboSpan" id="kobo.366.3">In fact, we created two and they are </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
opts := []grpc.ServerOption{
  //...
</span><span class="koboSpan" id="kobo.368.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">grpc.ChainUnaryInterceptor(unaryAuthInterceptor,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.370.1">    unaryLogInterceptor),</span></strong><span class="koboSpan" id="kobo.371.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">grpc.ChainStreamInterceptor(streamAuthInterceptor,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.373.1">    streamLogInterceptor),</span></strong><span class="koboSpan" id="kobo.374.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.375.1">If you remember, these middleware will first check that there is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">auth_token</span></strong><span class="koboSpan" id="kobo.377.1"> header that exists and that its value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">authd</span></strong><span class="koboSpan" id="kobo.379.1">. </span><span class="koboSpan" id="kobo.379.2">And then, if it is the case, it will log the API call on the terminal and continue with the execution of the code we wrote for the </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">API endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">So, to summarize, a </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.382.1">middleware</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.383.1"> is an interceptor that can cut the execution short depending on some conditions and is there to secure the </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">API endpoints.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor638"/><span class="koboSpan" id="kobo.385.1">Authenticating requests</span></h1>
<p><span class="koboSpan" id="kobo.386.1">In this section</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.387.1"> and the following, we are going to simplify the middleware that we currently have. </span><span class="koboSpan" id="kobo.387.2">First, we are going to start by simplifying the authentication process. </span><span class="koboSpan" id="kobo.387.3">We saw in the previous chapter that we can easily create an interceptor for checking an authentication token in headers. </span><span class="koboSpan" id="kobo.387.4">In this section, we are going to take a step further and make it </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">even simpler.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.389.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.390.1">gRPC supports retrying authentication of requests through an RBAC policy without a third-party library. </span><span class="koboSpan" id="kobo.390.2">However, the configuration is quite verbose and not very well documented. </span><span class="koboSpan" id="kobo.390.3">If you are interested in trying it, you can check the following </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">example: </span></span><a href="https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md"><span class="No-Break"><span class="koboSpan" id="kobo.392.1">https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.393.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Previously, when we wrote our interceptors, we needed to create the following function for a </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">unary interceptor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
func unaryAuthIntercepto</span><a id="_idTextAnchor639"/><span class="koboSpan" id="kobo.397.1">r(ctx context.Context, req
  interface{}, info *grpc.UnaryServerInfo, handle</span><a id="_idTextAnchor640"/><span class="koboSpan" id="kobo.398.1">r
    grpc.UnaryHandler) (interface{}, error)</span></pre>
<p><span class="koboSpan" id="kobo.399.1">And another one like the following for the </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">stream interceptor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.401.1">
func</span><a id="_idTextAnchor641"/><span class="koboSpan" id="kobo.402.1"> streamAuthInterceptor(srv interface{}, ss
  grpc.ServerStream, info *grpc.StreamServerInfo, handler
    grpc.StreamHandler) error</span></pre>
<p><span class="koboSpan" id="kobo.403.1">While this gives us a lot of information on the calls, the context, and so on, this also makes our code terse, and we need to think about how to share the common business logic between the stream and </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">unary interceptors.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">With the middleware that we are going to add, we will simply focus on our logic, and we will be able to register the interceptor as easily as before in our gRPC server. </span><span class="koboSpan" id="kobo.405.2">This middleware is the auth middleware in the GitHub repository called </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">go-grpc-middleware</span></strong><span class="koboSpan" id="kobo.407.1"> (</span><a href="https://github.com/grpc-ecosystem/go-grpc-middleware"><span class="koboSpan" id="kobo.408.1">https://github.com/grpc-ecosystem/go-grpc-middleware</span></a><span class="koboSpan" id="kobo.409.1">). </span><span class="koboSpan" id="kobo.409.2">It will let us get rid of the</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.410.1"> complicated authenticator function definitions that we add for the interceptors and will let us register directly using our </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">validateAuthToken</span></strong><span class="koboSpan" id="kobo.412.1"> function in a </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">predefined interceptor.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">To get started, we are going to fetch the dependency in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">server</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
$ go get github.com/grpc-ecosystem/go-grpc-middleware/v2/
  interceptors/auth</span></pre>
<p><span class="koboSpan" id="kobo.418.1">Then, we are going to remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">unaryAuthInterceptor</span></strong><span class="koboSpan" id="kobo.420.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">streamAuthInterceptor</span></strong><span class="koboSpan" id="kobo.422.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">server/interceptors.go</span></strong><span class="koboSpan" id="kobo.424.1"> file. </span><span class="koboSpan" id="kobo.424.2">We do not need them anymore since the new auth middleware will take care of everything </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">And finally, we are going to go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">server/main.go</span></strong><span class="koboSpan" id="kobo.428.1">, where we are going to replace the old interceptor with </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">auth.UnaryServerInterceptor</span></strong><span class="koboSpan" id="kobo.430.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">auth.StreamServerInterceptor</span></strong><span class="koboSpan" id="kobo.432.1">. </span><span class="koboSpan" id="kobo.432.2">These two intercept</span><a id="_idTextAnchor642"/><span class="koboSpan" id="kobo.433.1">ors take an </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">AuthFunc</span></strong><span class="koboSpan" id="kobo.435.1">, which basically represents the authentication logic. </span><span class="koboSpan" id="kobo.435.2">In our case, we will pass to them </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">validateAuthToken</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">AuthFunc</span></strong><span class="koboSpan" id="kobo.441.1"> type looks </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
type AuthFunc func(ctx context.Context) (context.Context,
error)</span></pre>
<p><span class="koboSpan" id="kobo.444.1">So, we need to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">validateAuthToken</span></strong><span class="koboSpan" id="kobo.446.1"> a little bit to return a context and/or an error. </span><span class="koboSpan" id="kobo.446.2">Our</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.447.1"> new function will look </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.449.1">
func validateAuthToken(ctx context.Context)
  </span><strong class="bold"><span class="koboSpan" id="kobo.450.1">(con</span><a id="_idTextAnchor643"/><span class="koboSpan" id="kobo.451.1">text.Context, error)</span></strong><span class="koboSpan" id="kobo.452.1"> {
  md, ok := metadata</span><a id="_idTextAnchor644"/><span class="koboSpan" id="kobo.453.1">.FromIncomingContext(ctx)
  if !ok {
    return </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">nil</span></strong><span class="koboSpan" id="kobo.455.1">, status.</span><a id="_idTextAnchor645"/><span class="koboSpan" id="kobo.456.1">Errorf(/*...*/)
  }
  if t, ok := md["auth_token"]; ok </span><a id="_idTextAnchor646"/><span class="koboSpan" id="kobo.457.1">{
    switch {
    case len(t) != 1:
      return </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">nil</span></strong><span class="koboSpan" id="kobo.459.1">, sta</span><a id="_idTextAnchor647"/><span class="koboSpan" id="kobo.460.1">tus</span><a id="_idTextAnchor648"/><span class="koboSpan" id="kobo.461.1">.Errorf(/*...*/)
    case t[0] != "authd":
      return </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">nil</span></strong><span class="koboSpan" id="kobo.463.1">, status.Errorf(/*...*/)
    }
  } else {
    return </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">nil</span></strong><span class="koboSpan" id="kobo.465.1">, status.Errorf(/*...*/)
  }
  return </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">ctx</span></strong><span class="koboSpan" id="kobo.467.1">, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.468.1">This lets us register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">validateAuthToken</span></strong><span class="koboSpan" id="kobo.470.1"> in the gRPC server. </span><span class="koboSpan" id="kobo.470.2">Our new main function will now be like </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.472.1">
import (
  //...
</span><span class="koboSpan" id="kobo.472.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.473.1">"github.com/grpc-ecosystem/go-grpc-middleware/v2/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.474.1">  </span><a id="_idTextAnchor649"/><span class="koboSpan" id="kobo.475.1">  interceptors/auth</span><a id="_idTextAnchor650"/><span class="koboSpan" id="kobo.476.1">"</span></strong><span class="koboSpan" id="kobo.477.1">
)
func main() {
  //...
</span><span class="koboSpan" id="kobo.477.2">  opts := []grpc.ServerOption{
    //...
</span><span class="koboSpan" id="kobo.477.3">    grpc.ChainUnaryInterceptor
      (</span><strong class="bold"><span class="koboSpan" id="kobo.478.1">auth.UnaryServerInterceptor(validateAuthToken</span></strong><span class="koboSpan" id="kobo.479.1">),
         unaryLogInterceptor),
    grpc.ChainStreamInterceptor(</span><strong class="bold"><span class="koboSpan" id="kobo.480.1">auth</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.481.1">      .StreamServerInterceptor(validateAuthToken)</span></strong><span class="koboSpan" id="kobo.482.1">,
        streamLogInterceptor),
  }
  //...
</span><span class="koboSpan" id="kobo.482.2">}</span></pre>
<p><span class="koboSpan" id="kobo.483.1">Now, we should </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.484.1">be</span><a id="_idTextAnchor651"/><span class="koboSpan" id="kobo.485.1"> able to run </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">the server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.487.1">$ go run ./server 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.488.1">
listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.489.1">We also run </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the client:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.491.1">$ go run ./client 0.0.0.0:50051</span></strong></pre>
<p><span class="koboSpan" id="kobo.492.1">We don’t get any errors and it works similarly to before. </span><span class="koboSpan" id="kobo.492.2">However, to test that the middleware is working properly, we can temporarily modify our interceptor on the client side to add a wrong authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">header (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">client/interceptors.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.496.1">
const authTokenValue string = "</span><strong class="bold"><span class="koboSpan" id="kobo.497.1">notauthd</span></strong><span class="koboSpan" id="kobo.498.1">"</span></pre>
<p><span class="koboSpan" id="kobo.499.1">And if we rerun the client, we should </span><a id="_idTextAnchor652"/><span class="koboSpan" id="kobo.500.1">get the </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">following error:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.502.1">$ go run ./client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.503.1">
--------ADD--------
rpc error: code = Unauthenticated desc = incorrect
  auth_token</span></pre>
<p><span class="koboSpan" id="kobo.504.1">This proves that our</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.505.1"> middleware is working as expected and that we can rely on only </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">validAuthToken</span></strong><span class="koboSpan" id="kobo.507.1"> to do the </span><a id="_idTextAnchor653"/><span class="No-Break"><span class="koboSpan" id="kobo.508.1">authentication checking.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor654"/><span class="koboSpan" id="kobo.509.1">Bazel</span></h2>
<p><span class="koboSpan" id="kobo.510.1">In order to </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.511.1">run that with Bazel, we will need to update our </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.512.1">dependencies and link the new dependency to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">server_lib</span></strong><span class="koboSpan" id="kobo.514.1"> target in </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">server/BUILD.bazel</span></strong><span class="koboSpan" id="kobo.516.1">. </span><span class="koboSpan" id="kobo.516.2">So, we first run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">gazelle-update-repos</span></strong><span class="koboSpan" id="kobo.518.1"> command, which will fetch the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">go-grpc-mi</span><a id="_idTextAnchor655"/><span class="koboSpan" id="kobo.520.1">ddeware</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1"> dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
$ bazel run //:gazelle-update-repos</span></pre>
<p><span class="koboSpan" id="kobo.523.1">And once we have that, we can now let the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">gazelle</span></strong><span class="koboSpan" id="kobo.525.1"> command include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">go-grpc-middleware</span></strong><span class="koboSpan" id="kobo.527.1"> depend</span><a id="_idTextAnchor656"/><span class="koboSpan" id="kobo.528.1">ency to </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">the target:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.530.1">
$ bazel run //:gazelle</span></pre>
<p><span class="koboSpan" id="kobo.531.1">Finally, we will be able to run </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">our server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.533.1">$ bazel run //server:server 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.534.1">
listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.535.1">And the client with the wrong </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">auth</span></strong><span class="koboSpan" id="kobo.537.1"> token should give the </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">following message:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.539.1">$ bazel run //client:client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.540.1">
--------ADD--------
rpc error: code = Unauthenticated desc = incorrect
  auth_token</span></pre>
<p><span class="koboSpan" id="kobo.541.1">To conclude, in this section, we </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.542.1">saw that we can simplify the </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.543.1">authenticator interceptors by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">go-grpc-middleware</span></strong><span class="koboSpan" id="kobo.545.1"> package. </span><span class="koboSpan" id="kobo.545.2">It lets us focus on the actual logic and not on how to write an interceptor that can be registered </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">with gRPC.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor657"/><span class="koboSpan" id="kobo.547.1">Logging API calls</span></h1>
<p><span class="koboSpan" id="kobo.548.1">In this section, let us </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.549.1">simplify the log interceptor. </span><span class="koboSpan" id="kobo.549.2">This will be like what we did in the previous section, but we are going to use another middleware: the </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">logging middleware.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">While this middleware integrates with a lot of different loggers, we are going to use it with the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">log</span></strong><span class="koboSpan" id="kobo.553.1"> package in Golang. </span><span class="koboSpan" id="kobo.553.2">It will then appear easy to integrate with your </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">favorite logger.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.555.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.556.1">The next command is only needed if you did not get the previous dependency on </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">go-grpc-middleware</span></strong><span class="koboSpan" id="kobo.558.1">. </span><span class="koboSpan" id="kobo.558.2">If you followed section by section, you should not </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">need it.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">To get started, let us get the dependency on the middleware. </span><span class="koboSpan" id="kobo.560.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">server</span></strong><span class="koboSpan" id="kobo.562.1"> folder, we are go</span><a id="_idTextAnchor658"/><span class="koboSpan" id="kobo.563.1">ing to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
$ go get github.com/grpc-ecosystem/go-grpc-middleware/v2/
  interceptors/logging</span></pre>
<p><span class="koboSpan" id="kobo.566.1">Now, we can start creating our logger. </span><span class="koboSpan" id="kobo.566.2">We are going to create it by defining a function that returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">loggerFunc</span></strong><span class="koboSpan" id="kobo.568.1">. </span><span class="koboSpan" id="kobo.568.2">This is a function that has the </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">following signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
func(ctx context.Context, lvl logging.Level, msg string,
  fields ...any)</span></pre>
<p><span class="koboSpan" id="kobo.571.1">We already know what the context is, but all the rest is specific to the logger. </span><span class="koboSpan" id="kobo.571.2">The level is a logging level such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">Debu</span><a id="_idTextAnchor659"/><span class="koboSpan" id="kobo.573.1">g</span></strong><span class="koboSpan" id="kobo.574.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">Info</span></strong><span class="koboSpan" id="kobo.576.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">Warnin</span><a id="_idTextAnchor660"/><span class="koboSpan" id="kobo.578.1">g</span></strong><span class="koboSpan" id="kobo.579.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">Error</span></strong><span class="koboSpan" id="kobo.581.1">. </span><span class="koboSpan" id="kobo.581.2">This is generally used in order to filter the logs depending on the level of severity. </span><span class="koboSpan" id="kobo.581.3">Then, the message is simply a message generat</span><a id="_idTextAnchor661"/><span class="koboSpan" id="kobo.582.1">ed by the logger mi</span><a id="_idTextAnchor662"/><span class="koboSpan" id="kobo.583.1">ddleware such a</span><a id="_idTextAnchor663"/><span class="koboSpan" id="kobo.584.1">s </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">":started call"</span></strong><span class="koboSpan" id="kobo.586.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">":finished call"</span></strong><span class="koboSpan" id="kobo.588.1">. </span><span class="koboSpan" id="kobo.588.2">This helps us understand the context of the log. </span><span class="koboSpan" id="kobo.588.3">And finally, the fields are all the other information that we need to print a useful log. </span><span class="koboSpan" id="kobo.588.4">In our case, we are going to use the service name and the method name. </span><span class="koboSpan" id="kobo.588.5">This will let</span><a id="_idTextAnchor664"/><span class="koboSpan" id="kobo.589.1"> us create logs lik</span><a id="_idTextAnchor665"/><span class="koboSpan" id="kobo.590.1">e </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">the </span><a id="_idTextAnchor666"/><span class="koboSpan" id="kobo.592.1">following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
INFO :started call todo.v2.TodoService UpdateTasks</span></pre>
<p><span class="koboSpan" id="kobo.594.1">A thing that is not easy to wrap your mind around is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">fields</span></strong><span class="koboSpan" id="kobo.596.1"> parameter. </span><span class="koboSpan" id="kobo.596.2">This is because th</span><a id="_idTextAnchor667"/><span class="koboSpan" id="kobo.597.1">is is </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.598.1">presented as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">vararg</span></strong><span class="koboSpan" id="kobo.600.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">any</span></strong><span class="koboSpan" id="kobo.602.1">. </span><span class="koboSpan" id="kobo.602.2">In realit</span><a id="_idTextAnchor668"/><span class="koboSpan" id="kobo.603.1">y, we can transform that into a map in order to get a specific field name such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">grpc.service</span></strong><span class="koboSpan" id="kobo.605.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">grpc.method</span></strong><span class="koboSpan" id="kobo.607.1">, … To do that</span><a id="_idTextAnchor669"/><span class="koboSpan" id="kobo.608.1">, we can simply write </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.610.1">
f := make(map[string]any, </span><strong class="bold"><span class="koboSpan" id="kobo.611.1">len(</span><a id="_idTextAnchor670"/><span class="koboSpan" id="kobo.612.1">fields)/2</span></strong><span class="koboSpan" id="kobo.613.1">)
i := </span><strong class="bold"><span class="koboSpan" id="kobo.614.1">logging.Fields(fie</span><a id="_idTextAnchor671"/><span class="koboSpan" id="kobo.615.1">lds).Iterator()</span></strong><span class="koboSpan" id="kobo.616.1">
for i.Next() {
  k, v := i.</span><strong class="bold"><span class="koboSpan" id="kobo.617.1">At</span></strong><span class="koboSpan" id="kobo.618.1">()
  f[k] = v
}</span></pre>
<p><span class="koboSpan" id="kobo.619.1">Notice that we are creating a map of </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">length l</span><a id="_idTextAnchor672"/><span class="koboSpan" id="kobo.621.1">en(fields)/2</span></strong><span class="koboSpan" id="kobo.622.1">. </span><span class="koboSpan" id="kobo.622.2">This is because in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">fields</span></strong><span class="koboSpan" id="kobo.624.1"> parameter, the name of the fields and their value are interleaved. </span><span class="koboSpan" id="kobo.624.2">An ex</span><a id="_idTextAnchor673"/><span class="koboSpan" id="kobo.625.1">ample is </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
grpc.service todo.v2.TodoService    grpc.method ListTasks</span></pre>
<p><span class="koboSpan" id="kobo.628.1">You can print the fields and see the whole thing yourself by expanding </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">vararg</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
log.Println(fields...)</span></pre>
<p><span class="koboSpan" id="kobo.633.1">Now that we have this knowledge, we can proceed to write the logger. </span><span class="koboSpan" id="kobo.633.2">We will create a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">logCalls</span></strong><span class="koboSpan" id="kobo.635.1">, which takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">log.Logger</span></strong><span class="koboSpan" id="kobo.637.1"> (from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">golang</span></strong><span class="koboSpan" id="kobo.639.1"> standard library) as a param and will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">logging.Logger</span></strong><span class="koboSpan" id="kobo.641.1"> (from the logging middleware). </span><span class="koboSpan" id="kobo.641.2">The logic of the logger will be to check the log level, prepend the level of the message to it, and then we will </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.642.1">append the service name and method name to the </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">whole message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.644.1">
import (
  //...
 </span><span class="koboSpan" id="kobo.644.2">"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
)
const grpcService = "grpc.service"
const grpcMethod = "grpc.method"
func logCalls(l *log.Logger) logging.Logger {
  return logging.LoggerFunc(func(_ context.Context, lvl
   logging.Le</span><a id="_idTextAnchor674"/><span class="koboSpan" id="kobo.645.1">vel, msg string, fields ...any) {
    f := make(map[string]any, len(fie</span><a id="_idTextAnchor675"/><span class="koboSpan" id="kobo.646.1">lds)/2)
    i := logging.Fields(fields).It</span><a id="_idTextAnchor676"/><span class="koboSpan" id="kobo.647.1">erator()
    for i.Next() {
      k, v := i.At()
      f[k] = v
    }
    switch lvl {
    case logging</span><a id="_idTextAnchor677"/><span class="koboSpan" id="kobo.648.1">.LevelDebug:
      msg = fmt.Sprintf("DEBUG :%v", msg)
    case loggin</span><a id="_idTextAnchor678"/><span class="koboSpan" id="kobo.649.1">g.LevelInfo:
      msg = fmt.Sprintf("INFO :%v", msg)
    case loggin</span><a id="_idTextAnchor679"/><span class="koboSpan" id="kobo.650.1">g.LevelWarn:
      msg = fmt.Sprintf("WARN :%v", msg)
    case logging</span><a id="_idTextAnchor680"/><span class="koboSpan" id="kobo.651.1">.LevelError:
      msg = fmt.Sprintf</span><a id="_idTextAnchor681"/><span class="koboSpan" id="kobo.652.1">("ERROR :%v", msg)
    default:
      panic(fmt.Sprintf("unknown level %v", lvl))
    }
    l.Println(msg, f[grpcService], f[grpcMethod])
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.653.1">Now, while this method will always be accurate because we can retrieve the keys in the map that was built, this means that we need to build a map each time th</span><a id="_idTextAnchor682"/><span class="koboSpan" id="kobo.654.1">is interceptor is called. </span><span class="koboSpan" id="kobo.654.2">This is not really efficient. </span><span class="koboSpan" id="kobo.654.3">I wanted to show you the full-blown example before showing you the efficient one so that you understand how to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">fields</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.656.1"> parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">To be more efficient, we can take advantage of the fact that our service and method are always situated </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.658.1">at index 5 and 7, respectively. </span><span class="koboSpan" id="kobo.658.2">So, we are going to remove the map creation part, we are going to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">grpcService</span></strong><span class="koboSpan" id="kobo.660.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">grpcMethod</span></strong><span class="koboSpan" id="kobo.662.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">5</span></strong><span class="koboSpan" id="kobo.664.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">7</span></strong><span class="koboSpan" id="kobo.666.1">, and we are going to access the 5th and 7th element </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">of fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.668.1">
const grpcService = </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">5</span></strong><span class="koboSpan" id="kobo.670.1">
const grpcMethod = </span><strong class="bold"><span class="koboSpan" id="kobo.671.1">7</span></strong><span class="koboSpan" id="kobo.672.1">
func logCalls(l *log.Logger) logging.Logger {
  return logging.LoggerFunc(func(_ context.Context, lvl
    logging.Level, msg stri</span><a id="_idTextAnchor683"/><span class="koboSpan" id="kobo.673.1">ng, fields ...any) {
    // ...
</span><span class="koboSpan" id="kobo.673.2">    l.Println(msg, </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">fields[grpcService], fields[grpcMethod]</span></strong><span class="koboSpan" id="kobo.675.1">)
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.676.1">This is much more efficient. </span><span class="koboSpan" id="kobo.676.2">Now, one thing that is worth mentioning is that this is less safe. </span><span class="koboSpan" id="kobo.676.3">We are assuming that all the fields that we receive will always contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">service</span></strong><span class="koboSpan" id="kobo.678.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">method</span></strong><span class="koboSpan" id="kobo.680.1"> at the same index and that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">fields</span></strong><span class="koboSpan" id="kobo.682.1"> array is large enough. </span><span class="koboSpan" id="kobo.682.2">We can safely assume that now, at the time of writing, because these are common fields that are added in this order all the time. </span><span class="koboSpan" id="kobo.682.3">However, if the library changes, you might try to do an out-of-bounds access or get a different piece of information. </span><span class="koboSpan" id="kobo.682.4">Be aware </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">of that.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">The last thing that we need to d</span><a id="_idTextAnchor684"/><span class="koboSpan" id="kobo.685.1">o is register the interceptor. </span><span class="koboSpan" id="kobo.685.2">This is similar to what we did with the authentication interceptor, but the main difference is that now we need to create a logger and pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">logCalls</span></strong><span class="koboSpan" id="kobo.687.1"> function. </span><span class="koboSpan" id="kobo.687.2">We are going to use a golang</span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1"> log.Logger</span></strong><span class="koboSpan" id="kobo.689.1">, which</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.690.1"> prints the date and time before the message. </span><span class="koboSpan" id="kobo.690.2">And finally, we are going to pass the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">logCalls</span></strong><span class="koboSpan" id="kobo.692.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">logging.UnaryServerInterceptor</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.694.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">logging.StreamServerInterceptor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.697.1">
import (
  //...
</span><span class="koboSpan" id="kobo.697.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.698.1">"github.com/grpc-ecosystem/go-grpc-middleware/v2/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.699.1">    interceptors/log</span><a id="_idTextAnchor685"/><span class="koboSpan" id="kobo.700.1">ging"</span></strong><span class="koboSpan" id="kobo.701.1">
)
//...
</span><span class="koboSpan" id="kobo.701.2">func main() {
  //...
</span><span class="koboSpan" id="kobo.701.3">  logger := log.Ne</span><a id="_idTextAnchor686"/><span class="koboSpan" id="kobo.702.1">w(</span><strong class="bold"><span class="koboSpan" id="kobo.703.1">os.Stderr</span></strong><span class="koboSpan" id="kobo.704.1">, "", </span><strong class="bold"><span class="koboSpan" id="kobo.705.1">log.Ldate|log.Ltime</span></strong><span class="koboSpan" id="kobo.706.1">)
  opts := []grpc.ServerOption{
    //...
</span><span class="koboSpan" id="kobo.706.2">    grpc.ChainUnaryInterceptor(
      //...
</span><span class="koboSpan" id="kobo.706.3">      logging.UnaryServerInterceptor(</span><strong class="bold"><span class="koboSpan" id="kobo.707.1">logCalls(logger)</span></strong><span class="koboSpan" id="kobo.708.1">),
    ),
    grpc.ChainStreamInterceptor(
      //...
</span><span class="koboSpan" id="kobo.708.2">      logging.StreamServerInterceptor(</span><strong class="bold"><span class="koboSpan" id="kobo.709.1">logCalls(logger)</span></strong><span class="koboSpan" id="kobo.710.1">),
    ),
  }
  //...
</span><span class="koboSpan" id="kobo.710.2">}</span></pre>
<p><span class="koboSpan" id="kobo.711.1">Afte</span><a id="_idTextAnchor687"/><span class="koboSpan" id="kobo.712.1">r that, we can now run </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">our server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.714.1">$ go run ./server 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.715.1">
listening at 0.0.0</span><a id="_idTextAnchor688"/><span class="koboSpan" id="kobo.716.1">.0:50051</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.717.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.718.1">Before running the client make sure that you replaced the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">authTokenValue</span></strong><span class="koboSpan" id="kobo.720.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">authd</span></strong><span class="koboSpan" id="kobo.722.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">client/interceptors.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.724.1"> file</span></span></p>
<p><span class="koboSpan" id="kobo.725.1">And then run </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">our client:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.727.1">
$ go run ./client 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.728.1">And if we check the terminal in which the server is running, we should have </span><a id="_idTextAnchor689"/><span class="koboSpan" id="kobo.729.1">a bunch of messages</span><a id="_idTextAnchor690"/><span class="koboSpan" id="kobo.730.1"> like </span><a id="_idTextAnchor691"/><span class="No-Break"><span class="koboSpan" id="kobo.731.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.732.1">
INFO :sta</span><a id="_idTextAnchor692"/><span class="koboSpan" id="kobo.733.1">rted call todo.v2.To</span><a id="_idTextAnchor693"/><span class="koboSpan" id="kobo.734.1">doServ</span><a id="_idTextAnchor694"/><span class="koboSpan" id="kobo.735.1">ice ListTasks
INFO :finished call todo.v2.TodoService ListTasks</span></pre>
<p><span class="koboSpan" id="kobo.736.1">To conclude, we saw that, similarly to the authentication middleware, we can simply add a logger to our gRPC server. </span><span class="koboSpan" id="kobo.736.2">We also saw that we can access more information than just the service name and method name by transforming the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">fields varargs</span></strong><span class="koboSpan" id="kobo.738.1"> into a map. </span><span class="koboSpan" id="kobo.738.2">And finally, we</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.739.1"> saw that some of the fields are always at the same place in </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">vararg</span></strong><span class="koboSpan" id="kobo.741.1">, so instead of generating the map for each call, we can directly access the information </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">by index.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor695"/><span class="koboSpan" id="kobo.743.1">Tracing API calls</span></h1>
<p><span class="koboSpan" id="kobo.744.1">On top of logging, which </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.745.1">simply describes the events in a developer-friendly manner, you might need to get metrics that can get aggregated by dashboard tools. </span><span class="koboSpan" id="kobo.745.2">These metrics might include requests per second, distribution of status (</span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">Ok</span></strong><span class="koboSpan" id="kobo.747.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">Internal</span></strong><span class="koboSpan" id="kobo.749.1">, and so on), and many others. </span><span class="koboSpan" id="kobo.749.2">In this section, we are going to instrument our code with OpenTelemetry and Prometheus so that tools such as Grafana can be used to </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">create dashboards.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">The first thing to understand is that we are going to run an HTTP server for Prometheus metrics. </span><span class="koboSpan" id="kobo.751.2">Prometheus exposes the metrics to external tools on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">/metrics</span></strong><span class="koboSpan" id="kobo.753.1"> route so that the tools wanting to query the data get a sense of all the kinds of </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">metrics available.</span></span></p>
<p><span class="koboSpan" id="kobo.755.1">So, to create such a server, we are going to get a dependency on Prometheus’ Go library. </span><span class="koboSpan" id="kobo.755.2">We are going to do that by getting the dependency on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">go-grpc-middleware/providers/prometheus</span></strong><span class="koboSpan" id="kobo.757.1">. </span><span class="koboSpan" id="kobo.757.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">Prometheus Go</span></strong><span class="koboSpan" id="kobo.759.1"> library is a transitive dependency of this one and we still need to be able to register some more interceptors that </span><a id="_idTextAnchor696"/><span class="koboSpan" id="kobo.760.1">are defined in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">Prometheus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.762.1"> provider:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.763.1">
$ go get github.com/grpc-ecosystem/go-grpc-middleware/
  providers/prometheus</span></pre>
<p><span class="koboSpan" id="kobo.764.1">Now, we can create </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.765.1">an HTTP server that will later be used to expose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">/metrics</span></strong><span class="koboSpan" id="kobo.767.1"> route. </span><span class="koboSpan" id="kobo.767.2">We are going to create a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">newMetri</span><a id="_idTextAnchor697"/><span class="koboSpan" id="kobo.769.1">csServer</span></strong><span class="koboSpan" id="kobo.770.1">, which takes the address of where the server </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">is running:</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.772.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.773.1">The code that follows explains every part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">server/main.go</span></strong><span class="koboSpan" id="kobo.775.1"> file. </span><span class="koboSpan" id="kobo.775.2">Displaying the full file here would be overwhelming. </span><span class="koboSpan" id="kobo.775.3">Thus, we will walk through all of its code and you will be able to see the imports and the overall structure in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">main.go</span></strong><span class="koboSpan" id="kobo.777.1">. </span><span class="koboSpan" id="kobo.777.2">Note that, in order to better explain, We are only adding certain elements later in the section. </span><span class="koboSpan" id="kobo.777.3">If you see a part of the code that is not presented yet, read on and you will get an explanation for the piece of code you are </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">looking at.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.779.1">
func newMetricsServer(httpAddr string) *http.Server {
  httpSrv := &amp;http.Server{Addr: httpAddr}
  m := http.NewServeMux()
  httpSrv.Handler = m
  return httpSrv
}</span></pre>
<p><span class="koboSpan" id="kobo.780.1">Now that we have our HTTP server, we will refactor our main and separate the creation of the gRPC server</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.781.1"> into </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">another function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.783.1">
func newGrpcServer(lis net</span><a id="_idTextAnchor698"/><span class="koboSpan" id="kobo.784.1">.Listener) (*grpc.Server, error) {
  creds, err := credentials.NewServerTLSFromFile
    ("./certs/serve</span><a id="_idTextAnchor699"/><span class="koboSpan" id="kobo.785.1">r_cert.</span><a id="_idTextAnchor700"/><span class="koboSpan" id="kobo.786.1">pem", "./certs/server_key.pem")
  if err != nil {
    return nil, err
  }
  logger := log</span><a id="_idTextAnchor701"/><span class="koboSpan" id="kobo.787.1">.New(os.Stderr, "", log.Ldate|log.Ltime)
  o</span><a id="_idTextAnchor702"/><span class="koboSpan" id="kobo.788.1">pts := []grpc.ServerOption{
    //...
</span><span class="koboSpan" id="kobo.788.2">  }
  s := grpc.NewServer(o</span><a id="_idTextAnchor703"/><span class="koboSpan" id="kobo.789.1">pts...)
  pb.R</span><a id="_idTextAnchor704"/><span class="koboSpan" id="kobo.790.1">egisterTodoServiceServer(s, &amp;server{
    d: New(),
  })
  return s, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.791.1">Nothing really changed; we only separated the creation into a function so that we can run two servers in parallel later. </span><span class="koboSpan" id="kobo.791.2">Before working on that though, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">main</span></strong><span class="koboSpan" id="kobo.793.1"> should also include two addresses as parameters. </span><span class="koboSpan" id="kobo.793.2">The first one is for the gRPC server</span><a id="_idTextAnchor705"/><span class="koboSpan" id="kobo.794.1"> and the other is for the </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">HTTP server:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.796.1">
func m</span><a id="_idTextAnchor706"/><span class="koboSpan" id="kobo.797.1">ain() {
  args := os.Args[1:]
  if len(args) != 2 {
    log.Fatalln("usage: server </span><strong class="bold"><span class="koboSpan" id="kobo.798.1">[GRPC_IP_ADDR]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.799.1">      </span></strong><strong class="bold"><span class="koboSpan" id="kobo.800.1">[METRICS_IP_ADDR]"</span></strong><span class="koboSpan" id="kobo.801.1">)
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.802.1">  grpcAddr := args[0]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.803.1">  httpAddr := args[1]</span></strong><span class="koboSpan" id="kobo.804.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.805.1">Now, we can deal with running two servers at once. </span><span class="koboSpan" id="kobo.805.2">We are going to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">errgroup</span></strong><span class="koboSpan" id="kobo.807.1">  (</span><a href="https://pkg.go.dev/golang.org/x/sync/errgroup"><span class="koboSpan" id="kobo.808.1">https://pkg.go.dev/golang.org/x/sync/errgroup</span></a><span class="koboSpan" id="kobo.809.1">) package. </span><span class="koboSpan" id="kobo.809.2">It lets us add multiple goroutines to a group and wait </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">on them.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">The first thing that </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.812.1">we need is to create a context for the group. </span><span class="koboSpan" id="kobo.812.2">We are going to create a cancellable one so that later we can release the </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">servers’</span><a id="_idTextAnchor707"/><span class="koboSpan" id="kobo.814.1"> resources:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.815.1">
ctx := context.Background()
</span><a id="_idTextAnchor708"/><span class="koboSpan" id="kobo.816.1">ctx, cancel := context.WithCancel(ctx)
defer cancel()</span></pre>
<p><span class="koboSpan" id="kobo.817.1">Next, we can start handling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">SIGTERM</span></strong><span class="koboSpan" id="kobo.819.1"> signal. </span><span class="koboSpan" id="kobo.819.2">This is because when we want to exit both servers, we will press </span><em class="italic"><span class="koboSpan" id="kobo.820.1">Ctrl</span></em><span class="koboSpan" id="kobo.821.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.822.1">C</span></em><span class="koboSpan" id="kobo.823.1">. </span><span class="koboSpan" id="kobo.823.2">This will send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">SIGTERM</span></strong><span class="koboSpan" id="kobo.825.1"> signal, and we expect the servers to be closed gracefully. </span><span class="koboSpan" id="kobo.825.2">To handle that, we are going to make a channel that will be r</span><a id="_idTextAnchor709"/><span class="koboSpan" id="kobo.826.1">eleased </span><a id="_idTextAnchor710"/><span class="koboSpan" id="kobo.827.1">when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">SIGTERM</span></strong><span class="koboSpan" id="kobo.829.1"> signal </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">is received:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.831.1">
quit := make(chan os.Signal, 1)
signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
defer signal.Stop(quit)</span></pre>
<p><span class="koboSpan" id="kobo.832.1">After that, we can now create our group of two servers. </span><span class="koboSpan" id="kobo.832.2">We will first create the group from the cancellable context that we created. </span><span class="koboSpan" id="kobo.832.3">And then, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">Go(func() error)</span></strong><span class="koboSpan" id="kobo.834.1"> function to add goroutines to that group. </span><span class="koboSpan" id="kobo.834.2">The first goroutine will handle the serving of the gRPC</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.835.1"> server and the sec</span><a id="_idTextAnchor711"/><span class="koboSpan" id="kobo.836.1">ond goroutine will handle the </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">HTTP one:</span></span><a id="_idTextAnchor712"/></p>
<pre class="source-code"><span class="koboSpan" id="kobo.838.1">
lis, </span><a id="_idTextAnchor713"/><span class="koboSpan" id="kobo.839.1">err := net.Listen("tcp", grpcAddr)
if err != nil {
  log.Fatalf("unexpected error: %v", err)
}
</span><strong class="bold"><span class="koboSpan" id="kobo.840.1">g,</span><a id="_idTextAnchor714"/><span class="koboSpan" id="kobo.841.1"> ctx := errgroup.WithContext(c</span><a id="_idTextAnchor715"/><span class="koboSpan" id="kobo.842.1">tx)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.843.1">grp</span><a id="_idTextAnchor716"/><span class="koboSpan" id="kobo.844.1">cServer, err := newGrpcServer(lis)</span></strong><span class="koboSpan" id="kobo.845.1">
if err != nil {
  log.Fatalf("unexpected error: %v", err)
}
</span><strong class="bold"><span class="koboSpan" id="kobo.846.1">g.Go</span></strong><span class="koboSpan" id="kobo.847.1">(func() error {
  log.Printf("g</span><a id="_idTextAnchor717"/><span class="koboSpan" id="kobo.848.1">RPC server listening at %s\n",</span><a id="_idTextAnchor718"/><span class="koboSpan" id="kobo.849.1"> grpcAd</span><a id="_idTextAnchor719"/><span class="koboSpan" id="kobo.850.1">dr)
  if err := grpcServer.Serve(lis); err != nil {
    log.Printf("</span><a id="_idTextAnchor720"/><span class="koboSpan" id="kobo.851.1">failed to gRPC server: %v\n", err)
    return err
  }
  log.Println("gRPC server shutdown")
  return nil
})
</span><strong class="bold"><span class="koboSpan" id="kobo.852.1">metricsServer := newMetricsServer(httpAddr)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.853.1">g.Go</span></strong><span class="koboSpan" id="kobo.854.1">(func() error {
  log.Printf("metr</span><a id="_idTextAnchor721"/><span class="koboSpan" id="kobo.855.1">ics server listening at %s\n", httpAddr</span><a id="_idTextAnchor722"/><span class="koboSpan" id="kobo.856.1">)
  if </span><a id="_idTextAnchor723"/><span class="koboSpan" id="kobo.857.1">err := </span><a id="_idTextAnchor724"/><span class="koboSpan" id="kobo.858.1">metricsServer.ListenAndServe(); err != nil &amp;&amp;
    err != http.ErrServerClosed {
    log.Printf("fa</span><a id="_idTextAnchor725"/><span class="koboSpan" id="kobo.859.1">iled to serve metrics: %v\n", err)
    return err
  }
  log.Println("metrics server shutdown")
  return nil
})</span></pre>
<p><span class="koboSpan" id="kobo.860.1">Now that we have our group, we can wait on the context to be done or on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">quit</span></strong><span class="koboSpan" id="kobo.862.1"> channel to receive </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">an event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.864.1">
select {
  case &lt;-quit:
    break
  case &lt;-ctx.Done():
    break
}</span></pre>
<p><span class="koboSpan" id="kobo.865.1">Once one of these</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.866.1"> events is received, we are going to initiate the release of resources by making sure that the context is finished (call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">cancel</span></strong><span class="koboSpan" id="kobo.868.1"> function), and finally, we can wait on the group to</span><a id="_idTextAnchor726"/><span class="koboSpan" id="kobo.869.1"> finish all the goroutines that </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">we registered:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.871.1">cancel()</span></strong><span class="koboSpan" id="kobo.872.1">
timeoutCtx, timeoutCancel := context.WithTimeout(
  context.Background(),
  10*time.Second,
)
defer timeoutCancel()
log.Println("shutting down servers, please wait...")
</span><strong class="bold"><span class="koboSpan" id="kobo.873.1">grpcServer.Gracefu</span><a id="_idTextAnchor727"/><span class="koboSpan" id="kobo.874.1">lStop()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.875.1">metricsSe</span><a id="_idTextAnchor728"/><span class="koboSpan" id="kobo.876.1">rver.Sh</span><a id="_idTextAnchor729"/><span class="koboSpan" id="kobo.877.1">utdown(timeoutCtx)</span></strong><span class="koboSpan" id="kobo.878.1">
if err := g.Wait(); err != ni</span><a id="_idTextAnchor730"/><span class="koboSpan" id="kobo.879.1">l {
  log.Fatal(err)
}</span></pre>
<p><span class="koboSpan" id="kobo.880.1">Finally, as this is the ultimate goal of this section, we need to add tracing capabilities. </span><span class="koboSpan" id="kobo.880.2">The metrics server will expose the metrics route and the gRPC server will collect the metrics and add them to the Prometheus registry. </span><span class="koboSpan" id="kobo.880.3">This registry is a collection of collectors. </span><span class="koboSpan" id="kobo.880.4">We register one or more collectors to it, then the registry will collect the different metrics available, and finally, it will expose </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">these metrics.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">Before creating the</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.883.1"> registry, we will first create a collector with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">NewServerMetrics</span></strong><span class="koboSpan" id="kobo.885.1"> function provided in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">go-grpc-middleware/prov</span><a id="_idTextAnchor731"/><span class="koboSpan" id="kobo.887.1">iders/prometheus</span></strong><span class="koboSpan" id="kobo.888.1"> package. </span><span class="koboSpan" id="kobo.888.2">Then, we are going to actually create the registry. </span><span class="koboSpan" id="kobo.888.3">And finally, we are going to register </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">the collector:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.890.1">
srvMetrics := grpcprom.NewServerMetrics(
  grpcprom.WithServerHandlingT</span><a id="_idTextAnchor732"/><span class="koboSpan" id="kobo.891.1">imeHistogram(
</span><strong class="bold"><span class="koboSpan" id="kobo.892.1">    grpcprom.WithHistogramBuckets([]float64{0.001, 0.01,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.893.1">      0.1, 0.3,</span><a id="_idTextAnchor733"/><span class="koboSpan" id="kobo.894.1"> 0.6, 1, 3, 6, 9, 20, 30, 60, 90, 120}),</span></strong><span class="koboSpan" id="kobo.895.1">
  ),
)
reg := prometheus.NewRegistry()
reg.MustRegister(srvMetrics)</span></pre>
<p><span class="koboSpan" id="kobo.896.1">Notice that we passed an option to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">NewServerMetrics</span></strong><span class="koboSpan" id="kobo.898.1">. </span><span class="koboSpan" id="kobo.898.2">This option will let us get buckets into which the calls </span><a id="_idTextAnchor734"/><span class="koboSpan" id="kobo.899.1">will be placed depending on their latency. </span><span class="koboSpan" id="kobo.899.2">This basically tells us how many requests were served in under 0.001 seconds, 0.01 seconds, and so on. </span></p>
<p><span class="koboSpan" id="kobo.900.1">Finally, we are going to pass the re</span><a id="_idTextAnchor735"/><span class="koboSpan" id="kobo.901.1">gistry to the HTTP server so that it knows what metrics are available, and we are going to pass the collector to our gRPC server so that it can push </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.902.1">metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.904.1">
func newMetricsServer(httpAddr string, </span><strong class="bold"><span class="koboSpan" id="kobo.905.1">reg</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.906.1">  *prometheus.Registry)</span></strong><span class="koboSpan" id="kobo.907.1"> *http.Server {
  //...
</span><strong class="bold"><span class="koboSpan" id="kobo.908.1">  m.Handle("/metrics", promhttp.HandlerFor(reg,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.909.1">    promhttp.HandlerOpts{}))</span></strong><span class="koboSpan" id="kobo.910.1">
  //...
</span><span class="koboSpan" id="kobo.910.2">  return httpSrv
}
func newGrpcServer(lis net.Listener, </span><strong class="bold"><span class="koboSpan" id="kobo.911.1">srvMetrics</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.912.1">  *grpcprom.</span><a id="_idTextAnchor736"/><span class="koboSpan" id="kobo.913.1">ServerMetrics)</span></strong><span class="koboSpan" id="kobo.914.1"> (*grpc.Server, error) {
  //...
</span><span class="koboSpan" id="kobo.914.2">  opts := []grpc.ServerOption{
    //...
</span><span class="koboSpan" id="kobo.914.3">    grpc.ChainUnaryInterceptor(
      </span><strong class="bold"><span class="koboSpan" id="kobo.915.1">otelgrpc.UnaryServerInterceptor()</span></strong><span class="koboSpan" id="kobo.916.1">,
</span><strong class="bold"><span class="koboSpan" id="kobo.917.1">      srvMetrics.UnaryServerInterceptor()</span></strong><span class="koboSpan" id="kobo.918.1">,
      //...
</span><span class="koboSpan" id="kobo.918.2">    ),
    grpc.ChainStreamInterceptor(
      </span><strong class="bold"><span class="koboSpan" id="kobo.919.1">otelgrpc.StreamServerInterceptor()</span></strong><span class="koboSpan" id="kobo.920.1">,
</span><strong class="bold"><span class="koboSpan" id="kobo.921.1">      srvMetrics.StreamServerInte</span><a id="_idTextAnchor737"/><span class="koboSpan" id="kobo.922.1">rceptor()</span></strong><span class="koboSpan" id="kobo.923.1">,
      //...
</span><span class="koboSpan" id="kobo.923.2">    ),
  }
  //...
</span><span class="koboSpan" id="kobo.923.3">}
func main() {
  //...
</span><span class="koboSpan" id="kobo.923.4">  grpcServer, err := newGrpcServer(lis, </span><strong class="bold"><span class="koboSpan" id="kobo.924.1">srvMetrics</span></strong><span class="koboSpan" id="kobo.925.1">)
  //...
</span><span class="koboSpan" id="kobo.925.2">  metricsServer := newMetricsServer(httpAddr, </span><strong class="bold"><span class="koboSpan" id="kobo.926.1">reg</span></strong><span class="koboSpan" id="kobo.927.1">)
  //...
</span><span class="koboSpan" id="kobo.927.2">}</span></pre>
<p><span class="koboSpan" id="kobo.928.1">Notice that we are now using </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">opentelemetry</span></strong><span class="koboSpan" id="kobo.930.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">otelgrpc</span></strong><span class="koboSpan" id="kobo.932.1">). </span><span class="koboSpan" id="kobo.932.2">This is a tool that lets us generate all the </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.933.1">metrics from our gRPC server automatically. </span><span class="koboSpan" id="kobo.933.2">Then, Prometheus will pick those with the collector (</span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">srvMetrics</span></strong><span class="koboSpan" id="kobo.935.1">). </span><span class="koboSpan" id="kobo.935.2">And finally, the HTTP server will be able to expose </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">these metrics.</span></span></p>
<p><span class="koboSpan" id="kobo.937.1">To get OpenTelemetry </span><a id="_idTextAnchor738"/><span class="koboSpan" id="kobo.938.1">for gRPC, we simply need to get </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">the dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.940.1">
$ go get go.opentelemetry.io/contrib/instrumentation/
  google.golang.org/grpc/otelg</span><a id="_idTextAnchor739"/><span class="koboSpan" id="kobo.941.1">rpc</span></pre>
<p><span class="koboSpan" id="kobo.942.1">We should now be able to run </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">our server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.944.1">$ go run ./server 0.0.0.0:50051 0.0.0.0:50052</span></strong><span class="koboSpan" id="kobo.945.1">
metrics server listening at 0.0.0.0:50052
gRPC server listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.946.1">Then, we can run o</span><a id="_idTextAnchor740"/><span class="koboSpan" id="kobo.947.1">ur client against the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">0.0.0.0:50051</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.949.1"> address:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.950.1">
$ go run ./client 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.951.1">And after the client calls are all served, we can look at the metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.953.1">
$ curl http://localhost:50052/metrics</span></pre>
<p><span class="koboSpan" id="kobo.954.1">You should now have logs that look like this (simplified to only </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">show </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">AddTask</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">):</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.958.1">grpc_server_handled_total</span></strong><span class="koboSpan" id="kobo.959.1">{grpc</span><a id="_idTextAnchor741"/><span class="koboSpan" id="kobo.960.1">_code=</span><a id="_idTextAnchor742"/><span class="koboSpan" id="kobo.961.1">"OK",grpc_met</span><a id="_idTextAnchor743"/><span class="koboSpan" id="kobo.962.1">hod="
  AddTask",grpc_service="todo.v2.TodoService",grpc_type=
    "unary"} </span><strong class="bold"><span class="koboSpan" id="kobo.963.1">3</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.964.1">grpc_server_handling_seco</span><a id="_idTextAnchor744"/><span class="koboSpan" id="kobo.965.1">nds_bu</span><a id="_idTextAnchor745"/><span class="koboSpan" id="kobo.966.1">cket</span></strong><span class="koboSpan" id="kobo.967.1">{grpc_met</span><a id="_idTextAnchor746"/><span class="koboSpan" id="kobo.968.1">hod="AddTask",
  grpc_service="todo.v2.TodoService",grpc_type="unary",le=
    "</span><strong class="bold"><span class="koboSpan" id="kobo.969.1">0.001</span></strong><span class="koboSpan" id="kobo.970.1">"} </span><strong class="bold"><span class="koboSpan" id="kobo.971.1">3</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.972.1">grpc_server_handling_s</span><a id="_idTextAnchor747"/><span class="koboSpan" id="kobo.973.1">econds</span><a id="_idTextAnchor748"/><span class="koboSpan" id="kobo.974.1">_sum</span></strong><span class="koboSpan" id="kobo.975.1">{grpc_met</span><a id="_idTextAnchor749"/><span class="koboSpan" id="kobo.976.1">hod="AddTask",grpc
  _service="todo.v2.TodoService",grpc_type="unary"}
    </span><strong class="bold"><span class="koboSpan" id="kobo.977.1">0.000119291</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.978.1">grpc_server_msg_rece</span><a id="_idTextAnchor750"/><span class="koboSpan" id="kobo.979.1">ived_t</span><a id="_idTextAnchor751"/><span class="koboSpan" id="kobo.980.1">otal</span></strong><span class="koboSpan" id="kobo.981.1">{grpc_met</span><a id="_idTextAnchor752"/><span class="koboSpan" id="kobo.982.1">hod="AddTask",grpc_
  service="todo.v2.TodoService",grpc_type="unary"} </span><strong class="bold"><span class="koboSpan" id="kobo.983.1">3</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.984.1">grpc_server_msg_</span><a id="_idTextAnchor753"/><span class="koboSpan" id="kobo.985.1">sent_t</span><a id="_idTextAnchor754"/><span class="koboSpan" id="kobo.986.1">otal</span></strong><span class="koboSpan" id="kobo.987.1">{grpc_met</span><a id="_idTextAnchor755"/><span class="koboSpan" id="kobo.988.1">hod="AddTask",grpc_
  service="todo.v2.TodoService",grpc_type="unary"} </span><strong class="bold"><span class="koboSpan" id="kobo.989.1">3</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.990.1">grpc_server_sta</span><a id="_idTextAnchor756"/><span class="koboSpan" id="kobo.991.1">rted_t</span><a id="_idTextAnchor757"/><span class="koboSpan" id="kobo.992.1">otal</span></strong><span class="koboSpan" id="kobo.993.1">{grpc_met</span><a id="_idTextAnchor758"/><span class="koboSpan" id="kobo.994.1">hod="AddTask",grpc_
  service="todo.v2.TodoService",grpc_type="unary"} </span><strong class="bold"><span class="koboSpan" id="kobo.995.1">3</span></strong></pre>
<p><span class="koboSpan" id="kobo.996.1">These metrics mean </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.997.1">that the server received three </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">AddTask</span></strong><span class="koboSpan" id="kobo.999.1">, handled them all in under 0.001 seconds (total: 0.000119291), and returned three responses to </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.1001.1">There is obviously a lot </span><a id="_idTextAnchor759"/><span class="koboSpan" id="kobo.1002.1">more to do wit</span><a id="_idTextAnchor760"/><span class="koboSpan" id="kobo.1003.1">h these metrics. </span><span class="koboSpan" id="kobo.1003.2">However, that would probably be a book in itself. </span><span class="koboSpan" id="kobo.1003.3">If you are interested in this area, I would encourage you to look at how to integrate Prometheus with a tool such as Grafana to create dashboards representing these metrics in a more </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">human-readabl</span><a id="_idTextAnchor761"/><span class="koboSpan" id="kobo.1005.1">e manner.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor762"/><span class="koboSpan" id="kobo.1006.1">Bazel</span></h2>
<p><span class="koboSpan" id="kobo.1007.1">We need to update</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.1008.1"> the dependencies in order to get Prometheus and </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.1009.1">OpenTelemetry to work. </span><span class="koboSpan" id="kobo.1009.2">To do that, we</span><a id="_idTextAnchor763"/><span class="koboSpan" id="kobo.1010.1"> are going to </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">run </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">gazelle-update-repos</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1014.1">
$ bazel run //:gazelle</span><a id="_idTextAnchor764"/><span class="koboSpan" id="kobo.1015.1">-update-repos</span></pre>
<p><span class="koboSpan" id="kobo.1016.1">And then, we are going to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">gazelle</span></strong><span class="koboSpan" id="kobo.1018.1"> in order to automatic</span><a id="_idTextAnchor765"/><span class="koboSpan" id="kobo.1019.1">ally link the dependencies to </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">our code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1021.1">
$ bazel run //:gazelle</span></pre>
<p><span class="koboSpan" id="kobo.1022.1">Finally, we can now run </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">our server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1024.1">$ bazel run //:server:server 0.0.0.0:50051 0.0.0.0:50052</span></strong><span class="koboSpan" id="kobo.1025.1">
metrics server listening at 0.0.0.0:50052
gRPC server listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.1026.1">And then run </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">our client:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1028.1">
$ bazel run //client:client 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.1029.1">In conclusion, we saw how we can get metrics out of our gRPC server by using OpenTelemetry and Prometheus. </span><span class="koboSpan" id="kobo.1029.2">We did that by creating a second</span><a id="_idTextAnchor766"/><span class="koboSpan" id="kobo.1030.1"> server exporting metrics on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">/metrics</span></strong><span class="koboSpan" id="kobo.1032.1"> route, and through the use of a Prometheus registry and collector, we exchanged metrics from the gRPC server to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">HTTP server.</span></span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor767"/><span class="koboSpan" id="kobo.1034.1">Securing APIs with rate limiting</span></h1>
<p><span class="koboSpan" id="kobo.1035.1">For the last </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.1036.1">interceptor </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.1037.1">we are going to add to the server, we are going to use a rate limiter. </span><span class="koboSpan" id="kobo.1037.2">More precisely, we are going to use the implementation of a token bucket rate limiter, which is provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">golang.org/x/time/rate</span></strong><span class="koboSpan" id="kobo.1039.1"> package. </span><span class="koboSpan" id="kobo.1039.2">In this section, we are not going to delve deeply into what rate limiters are or how to build one – that is out of the scope of this book, however, you will see how you can use a rate limiter (a readily implemented or custom one) in the context </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">of gRPC.</span></span></p>
<p><span class="koboSpan" id="kobo.1041.1">The first thing that we n</span><a id="_idTextAnchor768"/><span class="koboSpan" id="kobo.1042.1">eed to do is get the dependency on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">rate limiter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1044.1">
$ go get golang.org/x/time/rate</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.1045.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1046.1">The next command is only needed if you did not get the previous dependency on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">go-grpc-middleware</span></strong><span class="koboSpan" id="kobo.1048.1">. </span><span class="koboSpan" id="kobo.1048.2">If you followed section by section, you should not </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">need it.</span></span></p>
<p><span class="koboSpan" id="kobo.1050.1">The we get the dependency for </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">the interceptor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1052.1">
$ go get github.com/grpc-ecosystem/go-grpc-middleware/v2/
  interceptors/ratelimit</span></pre>
<p><span class="koboSpan" id="kobo.1053.1">Now, we are going to create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">limit.go</span></strong><span class="koboSpan" id="kobo.1055.1">, which will contain our logic and the wrapper around </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">rate.Limiter</span></strong><span class="koboSpan" id="kobo.1057.1">. </span><span class="koboSpan" id="kobo.1057.2">We create such a wrapper because the interceptor that we are going to use later requires the limiter to implement a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">Limit</span></strong><span class="koboSpan" id="kobo.1059.1">, taking </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.1060.1">a context as a parameter and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">rate.Limiter</span></strong><span class="koboSpan" id="kobo.1062.1"> does</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.1063.1"> not have such </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">a function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1065.1">
package main
import (
  "context"
  "fmt"
  "golang.org/x/time/rate"
)
type simpleLimiter str</span><a id="_idTextAnchor769"/><span class="koboSpan" id="kobo.1066.1">uct {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1067.1">limiter *rate.Limiter</span></strong><span class="koboSpan" id="kobo.1068.1">
}
func (l *simpleLimiter) Limit(_ context.Context) error {
  if </span><strong class="bold"><span class="koboSpan" id="kobo.1069.1">!l.limiter.Allow()</span></strong><span class="koboSpan" id="kobo.1070.1"> {
    return fmt.Errorf("reached Rate-Limiting %v", l
      .limiter.Limit())
  }
  return nil
}</span></pre>
<p><span class="koboSpan" id="kobo.1071.1">Notice that we simply check that the rate limiter allows (or not) the call to pass. </span><span class="koboSpan" id="kobo.1071.2">If it does not, we return an error, otherwise, we </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">nil</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1075.1">The last thing to do is to register </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">simpleLimiter</span></strong> <a id="_idTextAnchor770"/><span class="koboSpan" id="kobo.1077.1">in an interceptor. </span><span class="koboSpan" id="kobo.1077.2">We are going to create an instance of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">rate.Limiter</span></strong><span class="koboSpan" id="kobo.1079.1"> with 2 tokens per second (referred to as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">r</span></strong><span class="koboSpan" id="kobo.1081.1">) and a burst</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.1082.1"> size </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.1083.1">of 4 (referred to as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">b</span></strong><span class="koboSpan" id="kobo.1085.1">). </span><span class="koboSpan" id="kobo.1085.2">If you are unclear on what those parameters are, we recommend you read the documentation for </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">Limiter (</span></span><a href="https://pkg.go.dev/golang.org/x/time/rate#Limiter"><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">https://pkg.go.dev/golang.org/x/time/rate#Limiter</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1089.1">
import (
  //...
</span><span class="koboSpan" id="kobo.1089.2">  "github.com/grpc-ecosystem/go-grpc-middleware/v2/
    interceptors/ratelimit"
)
func newGrpcServer(lis net.Listener, srvMetrics
  *grpcprom.ServerMetrics) (*grpc.Server, error) {
  //...
</span><span class="koboSpan" id="kobo.1089.3">  limiter :</span><a id="_idTextAnchor771"/><span class="koboSpan" id="kobo.1090.1">= &amp;simpleLimiter{
    limiter: </span><strong class="bold"><span class="koboSpan" id="kobo.1091.1">rate.NewLimiter(2, 4)</span></strong><span class="koboSpan" id="kobo.1092.1">,
  }
  opts := []grpc.ServerOption{
    //...
</span><span class="koboSpan" id="kobo.1092.2">    grpc.ChainUnaryInterceptor(
      ratelimit.UnaryServerInterceptor(</span><strong class="bold"><span class="koboSpan" id="kobo.1093.1">limiter</span></strong><span class="koboSpan" id="kobo.1094.1">),
      //...
</span><span class="koboSpan" id="kobo.1094.2">    ),
    grpc.ChainStreamInterceptor(
      ratelimit.StreamServerInterceptor(</span><strong class="bold"><span class="koboSpan" id="kobo.1095.1">limiter</span></strong><span class="koboSpan" id="kobo.1096.1">),
      //...
</span><span class="koboSpan" id="kobo.1096.2">    ),
  }
  //...
</span><span class="koboSpan" id="kobo.1096.3">}</span></pre>
<p><span class="koboSpan" id="kobo.1097.1">That is all. </span><span class="koboSpan" id="kobo.1097.2">We now have rate limiting enabled for our API. </span><span class="koboSpan" id="kobo.1097.3">We can now run </span><span class="No-Break"><span class="koboSpan" id="kobo.1098.1">our server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1099.1">$ go run ./server 0.0.0.0:50051 0.0.0.0:50052</span></strong><span class="koboSpan" id="kobo.1100.1">
metrics server listening at 0.0.0.0:50052
gRPC server listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.1101.1">And then we can try</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.1102.1"> to</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.1103.1"> execute more than two calls per second. </span><span class="koboSpan" id="kobo.1103.2">This should not be hard. </span><span class="koboSpan" id="kobo.1103.3">In fact, </span><a id="_idTextAnchor772"/><span class="koboSpan" id="kobo.1104.1">you normally can run your client once and it should fail. </span><span class="koboSpan" id="kobo.1104.2">But in order to be sure that it fails, run the client multiple ti</span><a id="_idTextAnchor773"/><span class="koboSpan" id="kobo.1105.1">mes. </span><span class="koboSpan" id="kobo.1105.2">On Linux </span><a id="_idTextAnchor774"/><span class="koboSpan" id="kobo.1106.1">and Mac, you can run </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1108.1">
$ for i in {1..10}; do go run ./client 0.0.0.0:50051; done</span></pre>
<p><span class="koboSpan" id="kobo.1109.1">And</span><a id="_idTextAnchor775"/><span class="koboSpan" id="kobo.1110.1"> on Win</span><a id="_idTextAnchor776"/><span class="koboSpan" id="kobo.1111.1">dows </span><a id="_idTextAnchor777"/><span class="koboSpan" id="kobo.1112.1">(PowerShell), you can</span><a id="_idTextAnchor778"/> <span class="No-Break"><span class="koboSpan" id="kobo.1113.1">run this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1114.1">
$ foreach ($item in 1..10) { go run ./client 0.0.0.0:50051 }</span></pre>
<p><span class="koboSpan" id="kobo.1115.1">You should see some queries returning responses and then, quickly, you should be able to see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">foll</span><a id="_idTextAnchor779"/><span class="koboSpan" id="kobo.1117.1">owing </span><a id="_idTextAnchor780"/><span class="koboSpan" id="kobo.1118.1">message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1119.1">
rpc error: code = ResourceExhausted desc =
  /todo.v2.TodoService/UpdateTasks is rejected by
    grpc_ratelimit middleware, please retry</span><a id="_idTextAnchor781"/><span class="koboSpan" id="kobo.1120.1"> later. </span><span class="koboSpan" id="kobo.1120.2">reached
      Rate-Limiting 2</span></pre>
<p><span class="koboSpan" id="kobo.1121.1">Obviously, our rate is very low, an</span><a id="_idTextAnchor782"/><span class="koboSpan" id="kobo.1122.1">d it is not practical in production. </span><span class="koboSpan" id="kobo.1122.2">We chose such a low rate in order to show you how to rate limit. </span><span class="koboSpan" id="kobo.1122.3">In production, you will have busi</span><a id="_idTextAnchor783"/><span class="koboSpan" id="kobo.1123.1">ness-specific </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.1124.1">requirements </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.1125.1">that need to be followed. </span><span class="koboSpan" id="kobo.1125.2">You will have to </span><a id="_idTextAnchor784"/><span class="koboSpan" id="kobo.1126.1">adapt the code we have shown to match </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">these requirements.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor785"/><span class="koboSpan" id="kobo.1128.1">Bazel</span></h2>
<p><span class="koboSpan" id="kobo.1129.1">In order to run</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.1130.1"> this example with Bazel, we will</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.1131.1"> need to update the repos and run Gazelle to import the new</span><a id="_idTextAnchor786"/><span class="koboSpan" id="kobo.1132.1"> dependency (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">golang.org/x/time/rate</span></strong><span class="koboSpan" id="kobo.1134.1">)</span><a id="_idTextAnchor787"/><span class="koboSpan" id="kobo.1135.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">our library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1137.1">
$ bazel run //:gazelle-update-repos
$ bazel run //:gazelle</span></pre>
<p><span class="koboSpan" id="kobo.1138.1">After that, you should be able to run the server </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1140.1">
$ bazel run //server:server 0.0.0.0:50051 0.0.0.0:50052</span></pre>
<p><span class="koboSpan" id="kobo.1141.1">To conclude, we saw that we can integrate a rate limiter in our gRPC server. </span><span class="koboSpan" id="kobo.1141.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">go-grpc-middleware</span></strong><span class="koboSpan" id="kobo.1143.1"> interceptor for rate limiting makes it easy to add a readily available implementation or a </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">custom one.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor788"/><span class="koboSpan" id="kobo.1145.1">Retrying calls</span></h1>
<p><span class="koboSpan" id="kobo.1146.1">As of now, we</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.1147.1"> have worked only on the server side. </span><span class="koboSpan" id="kobo.1147.2">Let us now see an important feature on the client side. </span><span class="koboSpan" id="kobo.1147.3">This feature is the retrying of calls that failed depending on the status code. </span><span class="koboSpan" id="kobo.1147.4">This might be interesting for use cases where the network is unreliable. </span><span class="koboSpan" id="kobo.1147.5">If we get an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">Unavailable</span></strong><span class="koboSpan" id="kobo.1149.1"> error code, we will retry with an exponentially bigger wait time. </span><span class="koboSpan" id="kobo.1149.2">This is because we do not want to retry too often and overload the network. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1150.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1151.1">gRPC supports retries without the need for a third-party library. </span><span class="koboSpan" id="kobo.1151.2">However, the configuration is quite verbose and not very well documented. </span><span class="koboSpan" id="kobo.1151.3">If you are interested in trying it, you can check the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">example: </span></span><a href="https://github.com/grpc/grpc-go/blob/master/examples/features/retry/README.md"><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">https://github.com/grpc/grpc-go/blob/master/examples/features/retry/RE</span><span id="_idTextAnchor789"/><span class="koboSpan" id="kobo.1154.1">ADME.md</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1155.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1156.1">Let us get the dependency that we need (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">client</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1158.1"> folder):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1159.1">
$ go get github.com/grpc-ecosystem/go-grpc-middleware/v2/
  interceptors/retry</span></pre>
<p><span class="koboSpan" id="kobo.1160.1">Then, we can define some options for the retry. </span><span class="koboSpan" id="kobo.1160.2">We will define how many times and on which error code we want to retry. </span><span class="koboSpan" id="kobo.1160.3">We want to retry 3 times, with exponential backoff (starting at 100 ms), with the error code </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">being </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">Unavailable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1164.1">
retryOpts := []retry.CallOption{
  retry.</span><strong class="bold"><span class="koboSpan" id="kobo.1165.1">WithMax</span></strong><span class="koboSpan" id="kobo.1166.1">(3),
  retry.</span><strong class="bold"><span class="koboSpan" id="kobo.1167.1">WithBackoff</span></strong><span class="koboSpan" id="kobo.1168.1">(retry.</span><strong class="bold"><span class="koboSpan" id="kobo.1169.1">BackoffExponential</span></strong><span class="koboSpan" id="kobo.1170.1">(100 *
    time.Millisecond)),
  retry.</span><strong class="bold"><span class="koboSpan" id="kobo.1171.1">WithCodes</span></strong><span class="koboSpan" id="kobo.1172.1">(codes.Unavailable),
}</span></pre>
<p><span class="koboSpan" id="kobo.1173.1">And then, we simply</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.1174.1"> pass these options to the interceptors provided by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">retry</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1176.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1177.1">
import (
  //...
</span><span class="koboSpan" id="kobo.1177.2">  "github.com/gr</span><a id="_idTextAnchor790"/><span class="koboSpan" id="kobo.1178.1">pc-ecosystem/go-grpc-middleware/v2/
    interceptors/retry"
)
func main() {
  //...
</span><span class="koboSpan" id="kobo.1178.2">  retryOpts := []retry.CallOption{
    //...
</span><span class="koboSpan" id="kobo.1178.3">  }
  opts := []grpc.DialOption{
    //...
</span><span class="koboSpan" id="kobo.1178.4">    grpc.WithChainUnaryInterceptor(
      </span><strong class="bold"><span class="koboSpan" id="kobo.1179.1">retry.UnaryClientInterceptor(retryOpts...)</span></strong><span class="koboSpan" id="kobo.1180.1">,
      //...
</span><span class="koboSpan" id="kobo.1180.2">    ),
    grpc.WithChainStreamInterceptor(
      </span><strong class="bold"><span class="koboSpan" id="kobo.1181.1">retry.StreamClientInterceptor(retryOpts...)</span></strong><span class="koboSpan" id="kobo.1182.1">,
      //...
</span><span class="koboSpan" id="kobo.1182.2">    ),
    //...
</span><span class="koboSpan" id="kobo.1182.3">  }
  //...
</span><span class="koboSpan" id="kobo.1182.4">}</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.1183.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1184.1">Retrying is not available </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.1185.1">for client streaming. </span><span class="koboSpan" id="kobo.1185.2">If you attempt to retry on such an RPC endpoint, you will get the following error: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">rpc error: code = Unimplemented desc = grpc_retry: cannot retry on ClientStreams, set grpc_retry.Disable()</span></strong><span class="koboSpan" id="kobo.1187.1">. </span><span class="koboSpan" id="kobo.1187.2">As such, it is a bit risky to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">retry.StreamClientInterceptor</span></strong><span class="koboSpan" id="kobo.1189.1"> as presented. </span><span class="koboSpan" id="kobo.1189.2">We just wanted to show you that some streaming could also </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">be retried.</span></span></p>
<p><span class="koboSpan" id="kobo.1191.1">Once we have that, we now have a problem. </span><span class="koboSpan" id="kobo.1191.2">Our API is running locally and there is little chance that we will get an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">Unavailable</span></strong><span class="koboSpan" id="kobo.1193.1"> error. </span><span class="koboSpan" id="kobo.1193.2">So, for the sake of testing and demonstration, we are going to make our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">AddTask</span></strong><span class="koboSpan" id="kobo.1195.1"> directly return such an error temporarily. </span><span class="koboSpan" id="kobo.1195.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">server/impl.go</span></strong><span class="koboSpan" id="kobo.1197.1">, we can comment on the rest of the function and add </span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1199.1">
func (s *server) AddTask(_ context.Context, in
  *pb.AddTaskRequest) (*pb.AddTaskResponse, error) {
  return nil, status.Errorf(
    </span><strong class="bold"><span class="koboSpan" id="kobo.1200.1">codes.Unavailable</span></strong><span class="koboSpan" id="kobo.1201.1">,
    "unexpected error: %s",
    "unavailable",
  )
}</span></pre>
<p><span class="koboSpan" id="kobo.1202.1">And now, we run</span><a id="_idIndexMarker452"/> <span class="No-Break"><span class="koboSpan" id="kobo.1203.1">our server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1204.1">$ go run ./server 0.0.0.0:50051 0.0.0.0:50052</span></strong><span class="koboSpan" id="kobo.1205.1">
metrics server listening at 0.0.0.0:50052
gRPC server listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.1206.1">And then run </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">our client:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1208.1">$ go run ./client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.1209.1">
--------ADD--------
rpc error: code = Unavailable desc = unexpected error:
  unavailable</span></pre>
<p><span class="koboSpan" id="kobo.1210.1">We get one error. </span><span class="koboSpan" id="kobo.1210.2">While this looks like it only did one query, if you look back at your server, you should be able to see </span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1212.1">
INFO </span><strong class="bold"><span class="koboSpan" id="kobo.1213.1">:started </span></strong><span class="koboSpan" id="kobo.1214.1">call todo.v2.TodoService AddTask
WARN :finished call todo.v2.TodoService AddTask
INFO </span><strong class="bold"><span class="koboSpan" id="kobo.1215.1">:started</span></strong><span class="koboSpan" id="kobo.1216.1"> call todo.v2.TodoService AddTask
WARN :finished call todo.v2.TodoService AddTask
INFO </span><strong class="bold"><span class="koboSpan" id="kobo.1217.1">:started</span></strong><span class="koboSpan" id="kobo.1218.1"> call todo.v2.TodoService AddTask
WARN :finished call todo.v2.TodoService AddTask</span></pre>
<p><span class="koboSpan" id="kobo.1219.1">That is effectively </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.1220.1">three requests that </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">were made.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor791"/><span class="koboSpan" id="kobo.1222.1">Bazel</span></h2>
<p><span class="koboSpan" id="kobo.1223.1">As always, you </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.1224.1">will </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.1225.1">need to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">gazelle-update-repos</span></strong><span class="koboSpan" id="kobo.1227.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">gazelle</span></strong><span class="koboSpan" id="kobo.1229.1"> in order to get the new dependencies and link them to </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">your library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1231.1">
$ bazel run //:gazelle-update-repos
$ bazel run //:gazelle</span></pre>
<p><span class="koboSpan" id="kobo.1232.1">And now you should be able to run your </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">client correctly:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1234.1">$ bazel run //client:client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.1235.1">
--------ADD--------
rpc error: code = Unavailable desc = unexpected error:
  unavailable</span></pre>
<p><span class="koboSpan" id="kobo.1236.1">To conclude, we saw in this section that we can retry depending on some conditions, with exponential backoff, and for a certain amount of time. </span><span class="koboSpan" id="kobo.1236.2">Retry is an important feature since the network is often unreliable and we do not want to make the user retry manually each time there is </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">a problem.</span></span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor792"/><span class="koboSpan" id="kobo.1238.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1239.1">In this chapter, we looked at the key features that we can get by using community projects such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.1241.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">go-grpc-middleware</span></strong><span class="koboSpan" id="kobo.1243.1">. </span><span class="koboSpan" id="kobo.1243.2">We saw that we can encode request validation logic in our proto files. </span><span class="koboSpan" id="kobo.1243.3">This makes our code less bloated and provides error message consistency across all the endpoints of </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">our API.</span></span></p>
<p><span class="koboSpan" id="kobo.1245.1">Then, we looked at what middleware are and how to create one. </span><span class="koboSpan" id="kobo.1245.2">We started with refactoring our authentication and logging interceptors. </span><span class="koboSpan" id="kobo.1245.3">We saw that by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">go-grpc-middleware</span></strong><span class="koboSpan" id="kobo.1247.1">, we can focus only on the actual logic of the interceptor and have less boilerplate to </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">deal with.</span></span></p>
<p><span class="koboSpan" id="kobo.1249.1">After that, we saw that we can expose tracing data from our API. </span><span class="koboSpan" id="kobo.1249.2">We used OpenTelemetry and Prometheus to gather the data from the gRPC API and expose it through an </span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">HTTP server.</span></span></p>
<p><span class="koboSpan" id="kobo.1251.1">We then learned how to apply rate limiting on our APIs. </span><span class="koboSpan" id="kobo.1251.2">This is helpful to prevent fraudulent actors or defective clients from overloading our server. </span><span class="koboSpan" id="kobo.1251.3">We used the Token Bucket algorithm and an already existing implementation of a rate limiter to apply limiting to </span><span class="No-Break"><span class="koboSpan" id="kobo.1252.1">our API.</span></span></p>
<p><span class="koboSpan" id="kobo.1253.1">And finally, we also saw that we can use interceptors on the client side by working with retry middleware. </span><span class="koboSpan" id="kobo.1253.2">This lets us retry a call depending on an error code, with a maximum number of retries, and optionally with </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">exponential backoff.</span></span></p>
<p><span class="koboSpan" id="kobo.1255.1">In the next chapter, we will go over the development lifecycle for gRPC APIs, how we can ensure their correctness, how we can debug them, and how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">deploy them.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor793"/><span class="koboSpan" id="kobo.1257.1">Quiz</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1258.1">What is the purpose of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">protoc-gen-validate plugin?</span></span><ol><li><span class="koboSpan" id="kobo.1260.1">Providing checking logic in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1263.1"> file</span></span></li><li><span class="koboSpan" id="kobo.1264.1">Generating </span><span class="No-Break"><span class="koboSpan" id="kobo.1265.1">validation code</span></span></li><li><span class="koboSpan" id="kobo.1266.1">Both </span><span class="No-Break"><span class="koboSpan" id="kobo.1267.1">of them</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1268.1">What is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">go-grpc-middleware</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1270.1">used for?</span></span><ol><li><span class="koboSpan" id="kobo.1271.1">Providing commonly </span><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">used interceptors</span></span></li><li><span class="koboSpan" id="kobo.1273.1">Generating </span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">validation code</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1275.1">Which middleware is used for displaying events as </span><span class="No-Break"><span class="koboSpan" id="kobo.1276.1">human-readable text?</span></span><ol><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">tracing</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">auth</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">logging</span></strong></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1280.1">Which middleware is used to constrain the number of requests made </span><span class="No-Break"><span class="koboSpan" id="kobo.1281.1">per second?</span></span><ol><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">tracing</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">ratelimit</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">auth</span></strong></span></li></ol></li>
</ol>
<h1 id="_idParaDest-168"><a id="_idTextAnchor794"/><span class="koboSpan" id="kobo.1285.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1286.1">C</span></li>
<li><span class="koboSpan" id="kobo.1287.1">A</span></li>
<li><span class="koboSpan" id="kobo.1288.1">C</span></li>
<li><span class="koboSpan" id="kobo.1289.1">B</span></li>
</ol>
<h1 id="_idParaDest-169"><a id="_idTextAnchor795"/><span class="koboSpan" id="kobo.1290.1">Challenges</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.1291.1">Simplify the client logger you created in the last chapter by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1292.1">logging middleware.</span></span></li>
<li><span class="koboSpan" id="kobo.1293.1">Check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.1295.1"> rules (</span><a href="https://github.com/bufbuild/protoc-gen-validate/blob/main/README.md"><span class="koboSpan" id="kobo.1296.1">https://github.com/bufbuild/protoc-gen-validate/blob/main/README.md</span></a><span class="koboSpan" id="kobo.1297.1">) and simplify the error handling that you added in the last </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">chapter’s challenges.</span></span></li>
<li><span class="koboSpan" id="kobo.1299.1">Check the other middleware available in </span><a href="https://github.com/grpc-ecosystem/go-grpc-middleware/tree/v2"><span class="koboSpan" id="kobo.1300.1">https://github.com/grpc-ecosystem/go-grpc-middleware/tree/v2</span></a><span class="koboSpan" id="kobo.1301.1"> and try to implement one. </span><span class="koboSpan" id="kobo.1301.2">An example could be the </span><span class="No-Break"><span class="koboSpan" id="kobo.1302.1">selector middleware.</span></span></li>
<li><span class="koboSpan" id="kobo.1303.1">Create a simple Grafana dashboard based on the metrics the server is exposing. </span><span class="koboSpan" id="kobo.1303.2">An example could be a dashboard that displays the percentage of requests </span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1">that succeeded.</span></span></li>
</ul>
</div>
</body></html>