["```go\n$ go install github.com/envoyproxy/protoc-gen-validate\n```", "```go\nproto\n└── validate\n    └── validate.proto\n```", "```go\nmessage AddTaskRequest {\n  string description = 1;\n  google.protobuf.Timestamp due_date = 2;\n}\n```", "```go\nimport \"validate/validate.proto\";\n//...\nmessage AddTaskRequest {\n  string description = 1 [\n    (validate.rules).string.min_len = 1\n  ];\n  google.protobuf.Timestamp due_date = 2 [\n    (validate.rules).timestamp.gt_now = true\n  ];\n}\n```", "```go\n$ protoc -Iproto --go_out=proto --go_opt=paths=\n  source_relative --go-grpc_out=proto --go-grpc_opt=\n    paths=source_relative --validate_out=\n\"lang=go,paths=source_relative:proto\" proto/todo/v2/*.proto\n```", "```go\nproto/todo/v2\n├── todo.pb.go\n├── todo.pb.validate.go\n├── todo.proto\n└── todo_grpc.pb.go\n```", "```go\n// Validate checks the field values on Task with the rules\ndefined in the proto\n// definition for this message. If any rules are violated,\nthe first error\n// encountered is returned, or nil if there are no\nviolations.\nfunc (m *Task) Validate() error {\n  return m.validate(false)\n}\n```", "```go\nfunc (s *server) AddTask(_ context.Context, in\n*pb.AddTaskRequest) (*pb.AddTaskResponse, error) {\n  if len(in.Description) == 0 {\n    return nil, status.Error(\n      codes.InvalidArgument,\n      \"expected a task description, got an empty string\",\n    )\n  }\n  if in.DueDate.AsTime().Before(time.Now().UTC()) {\n    return nil, status.Error(\n      codes.InvalidArgument,\n      \"expected a task due_date that is in the future\",\n    )\n  }\n  //...\n}\n```", "```go\nfunc (s *server) AddTask(_ context.Context, in\n*pb.AddTaskRequest) (*pb.AddTaskResponse, error) {\n  if err := in.Validate(); err != nil {\n    return nil, err\n  }\n  //...\n}\n```", "```go\nfunc main() {\n  //...\n  fmt.Println(\"-------ERROR-------\")\n  addTask(c, \"\", dueDate)\n  addTask(c, \"not empty\", time.Now().Add(-5*time.Second))\n  fmt.Println(\"-------------------\")\n}\n```", "```go\n$ go run ./client 0.0.0.0:50051\n-------ERROR-------\nrpc error: code = Unknown desc = invalid AddTaskRequest\n.Description: value length must be at least 1 runes\n```", "```go\n$ go run ./client 0.0.0.0:50051\n-------ERROR-------\nrpc error: code = Unknown desc = invalid AddTaskRequest\n.DueDate: value must be greater than now\n```", "```go\nversion: v1\n#...\ndeps:\n- buf.build/envoyproxy/protoc-gen-validate\n```", "```go\nversion: v1\nplugins:\n  #...\n  - plugin: buf.build/bufbuild/validate-go\n    out: proto\n    opt: paths=source_relative\n```", "```go\n$ buf generate proto\n```", "```go\n#...\ngit_repository(\n  name = \"com_envoyproxy_protoc_gen_validate\",\n  tag = PROTOC_GEN_VALIDATE_VERSIO**N**,\n  remote = \"https://github.com/bufbuild/protoc-gen-validate\"\n)\n\nload(\"@com_envoyproxy_protoc_gen_validate//bazel:\n  repositories.bzl\", \"pgv_dependencies\")\nload(\"@com_envoyproxy_protoc_gen_validate//\n  :dependencies.bzl\", \"go_third_party\")\npgv_dependencies()\n# gazelle:repository_macro deps.bzl%go_third_party\ngo_third_party()\n```", "```go\n$ bazel run //:gazelle-update-repos\n```", "```go\nproto_library(\n  name = \"v2_proto\",\n  #…\n  deps = [\n    #...\n    \"@com_envoyproxy_protoc_gen_validate//\n      validate:validate_proto\",\n  ],\n)\n```", "```go\nload(\"@com_envoyproxy_protoc_gen_validate//bazel:pgv_proto_\n  library.bzl\", \"pgv_go_proto_library\")\n//...\npgv_go_proto_library(\n  name = \"v2_go_proto\",\n  compilers = [\"@io_bazel_rules_go//proto:go_grpc\"],\n  importpath = \"github.com/PacktPublishing/gRPC-Go-for-Professionals/\n    proto/todo/v2\",\n  proto = \":v2_proto\",\n  deps = [\"@com_envoyproxy_protoc_gen_validate//\n    validate:validate_go\"],\n)\n```", "```go\n# gazelle:resolve proto validate/validate.proto\n  @com_envoyproxy_protoc_gen_validate//validate:\n  validate_proto\n```", "```go\n$ bazel run //server:server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ bazel run //client:client 0.0.0.0:50051\n-------ERROR-------\nrpc error: code = Unknown desc = invalid AddTaskRequest\n.Description: value length must be at least 1 runes\n```", "```go\nopts := []grpc.ServerOption{\n  //...\n  grpc.ChainUnaryInterceptor(unaryAuthInterceptor,\n    unaryLogInterceptor),\n  grpc.ChainStreamInterceptor(streamAuthInterceptor,\n    streamLogInterceptor),\n}\n```", "```go\nfunc unaryAuthInterceptor(ctx context.Context, req\n  interface{}, info *grpc.UnaryServerInfo, handler\n    grpc.UnaryHandler) (interface{}, error)\n```", "```go\nfunc streamAuthInterceptor(srv interface{}, ss\n  grpc.ServerStream, info *grpc.StreamServerInfo, handler\n    grpc.StreamHandler) error\n```", "```go\n$ go get github.com/grpc-ecosystem/go-grpc-middleware/v2/\n  interceptors/auth\n```", "```go\ntype AuthFunc func(ctx context.Context) (context.Context,\nerror)\n```", "```go\nfunc validateAuthToken(ctx context.Context)\n  (context.Context, error) {\n  md, ok := metadata.FromIncomingContext(ctx)\n  if !ok {\n    return nil, status.Errorf(/*...*/)\n  }\n  if t, ok := md[\"auth_token\"]; ok {\n    switch {\n    case len(t) != 1:\n      return nil, status.Errorf(/*...*/)\n    case t[0] != \"authd\":\n      return nil, status.Errorf(/*...*/)\n    }\n  } else {\n    return nil, status.Errorf(/*...*/)\n  }\n  return ctx, nil\n}\n```", "```go\nimport (\n  //...\n  \"github.com/grpc-ecosystem/go-grpc-middleware/v2/\n    interceptors/auth\"\n)\nfunc main() {\n  //...\n  opts := []grpc.ServerOption{\n    //...\n    grpc.ChainUnaryInterceptor\n      (auth.UnaryServerInterceptor(validateAuthToken),\n         unaryLogInterceptor),\n    grpc.ChainStreamInterceptor(auth\n      .StreamServerInterceptor(validateAuthToken),\n        streamLogInterceptor),\n  }\n  //...\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\nconst authTokenValue string = \"notauthd\"\n```", "```go\n$ go run ./client 0.0.0.0:50051\n--------ADD--------\nrpc error: code = Unauthenticated desc = incorrect\n  auth_token\n```", "```go\n$ bazel run //:gazelle-update-repos\n```", "```go\n$ bazel run //:gazelle\n```", "```go\n$ bazel run //server:server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ bazel run //client:client 0.0.0.0:50051\n--------ADD--------\nrpc error: code = Unauthenticated desc = incorrect\n  auth_token\n```", "```go\n$ go get github.com/grpc-ecosystem/go-grpc-middleware/v2/\n  interceptors/logging\n```", "```go\nfunc(ctx context.Context, lvl logging.Level, msg string,\n  fields ...any)\n```", "```go\nINFO :started call todo.v2.TodoService UpdateTasks\n```", "```go\nf := make(map[string]any, len(fields)/2)\ni := logging.Fields(fields).Iterator()\nfor i.Next() {\n  k, v := i.At()\n  f[k] = v\n}\n```", "```go\ngrpc.service todo.v2.TodoService    grpc.method ListTasks\n```", "```go\nlog.Println(fields...)\n```", "```go\nimport (\n  //...\n \"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging\"\n)\nconst grpcService = \"grpc.service\"\nconst grpcMethod = \"grpc.method\"\nfunc logCalls(l *log.Logger) logging.Logger {\n  return logging.LoggerFunc(func(_ context.Context, lvl\n   logging.Level, msg string, fields ...any) {\n    f := make(map[string]any, len(fields)/2)\n    i := logging.Fields(fields).Iterator()\n    for i.Next() {\n      k, v := i.At()\n      f[k] = v\n    }\n    switch lvl {\n    case logging.LevelDebug:\n      msg = fmt.Sprintf(\"DEBUG :%v\", msg)\n    case logging.LevelInfo:\n      msg = fmt.Sprintf(\"INFO :%v\", msg)\n    case logging.LevelWarn:\n      msg = fmt.Sprintf(\"WARN :%v\", msg)\n    case logging.LevelError:\n      msg = fmt.Sprintf(\"ERROR :%v\", msg)\n    default:\n      panic(fmt.Sprintf(\"unknown level %v\", lvl))\n    }\n    l.Println(msg, f[grpcService], f[grpcMethod])\n  })\n}\n```", "```go\nconst grpcService = 5\nconst grpcMethod = 7\nfunc logCalls(l *log.Logger) logging.Logger {\n  return logging.LoggerFunc(func(_ context.Context, lvl\n    logging.Level, msg string, fields ...any) {\n    // ...\n    l.Println(msg, fields[grpcService], fields[grpcMethod])\n  })\n}\n```", "```go\nimport (\n  //...\n  \"github.com/grpc-ecosystem/go-grpc-middleware/v2/\n    interceptors/logging\"\n)\n//...\nfunc main() {\n  //...\n  logger := log.New(os.Stderr, \"\", log.Ldate|log.Ltime)\n  opts := []grpc.ServerOption{\n    //...\n    grpc.ChainUnaryInterceptor(\n      //...\n      logging.UnaryServerInterceptor(logCalls(logger)),\n    ),\n    grpc.ChainStreamInterceptor(\n      //...\n      logging.StreamServerInterceptor(logCalls(logger)),\n    ),\n  }\n  //...\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051\nlistening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\nINFO :started call todo.v2.TodoService ListTasks\nINFO :finished call todo.v2.TodoService ListTasks\n```", "```go\n$ go get github.com/grpc-ecosystem/go-grpc-middleware/\n  providers/prometheus\n```", "```go\nfunc newMetricsServer(httpAddr string) *http.Server {\n  httpSrv := &http.Server{Addr: httpAddr}\n  m := http.NewServeMux()\n  httpSrv.Handler = m\n  return httpSrv\n}\n```", "```go\nfunc newGrpcServer(lis net.Listener) (*grpc.Server, error) {\n  creds, err := credentials.NewServerTLSFromFile\n    (\"./certs/server_cert.pem\", \"./certs/server_key.pem\")\n  if err != nil {\n    return nil, err\n  }\n  logger := log.New(os.Stderr, \"\", log.Ldate|log.Ltime)\n  opts := []grpc.ServerOption{\n    //...\n  }\n  s := grpc.NewServer(opts...)\n  pb.RegisterTodoServiceServer(s, &server{\n    d: New(),\n  })\n  return s, nil\n}\n```", "```go\nfunc main() {\n  args := os.Args[1:]\n  if len(args) != 2 {\n    log.Fatalln(\"usage: server [GRPC_IP_ADDR]\n[METRICS_IP_ADDR]\")\n  }\n  grpcAddr := args[0]\n  httpAddr := args[1]\n}\n```", "```go\nctx := context.Background()\nctx, cancel := context.WithCancel(ctx)\ndefer cancel()\n```", "```go\nquit := make(chan os.Signal, 1)\nsignal.Notify(quit, os.Interrupt, syscall.SIGTERM)\ndefer signal.Stop(quit)\n```", "```go\nlis, err := net.Listen(\"tcp\", grpcAddr)\nif err != nil {\n  log.Fatalf(\"unexpected error: %v\", err)\n}\ng, ctx := errgroup.WithContext(ctx)\ngrpcServer, err := newGrpcServer(lis)\nif err != nil {\n  log.Fatalf(\"unexpected error: %v\", err)\n}\ng.Go(func() error {\n  log.Printf(\"gRPC server listening at %s\\n\", grpcAddr)\n  if err := grpcServer.Serve(lis); err != nil {\n    log.Printf(\"failed to gRPC server: %v\\n\", err)\n    return err\n  }\n  log.Println(\"gRPC server shutdown\")\n  return nil\n})\nmetricsServer := newMetricsServer(httpAddr)\ng.Go(func() error {\n  log.Printf(\"metrics server listening at %s\\n\", httpAddr)\n  if err := metricsServer.ListenAndServe(); err != nil &&\n    err != http.ErrServerClosed {\n    log.Printf(\"failed to serve metrics: %v\\n\", err)\n    return err\n  }\n  log.Println(\"metrics server shutdown\")\n  return nil\n})\n```", "```go\nselect {\n  case <-quit:\n    break\n  case <-ctx.Done():\n    break\n}\n```", "```go\ncancel()\ntimeoutCtx, timeoutCancel := context.WithTimeout(\n  context.Background(),\n  10*time.Second,\n)\ndefer timeoutCancel()\nlog.Println(\"shutting down servers, please wait...\")\ngrpcServer.GracefulStop()\nmetricsServer.Shutdown(timeoutCtx)\nif err := g.Wait(); err != nil {\n  log.Fatal(err)\n}\n```", "```go\nsrvMetrics := grpcprom.NewServerMetrics(\n  grpcprom.WithServerHandlingTimeHistogram(\n    grpcprom.WithHistogramBuckets([]float64{0.001, 0.01,\n      0.1, 0.3, 0.6, 1, 3, 6, 9, 20, 30, 60, 90, 120}),\n  ),\n)\nreg := prometheus.NewRegistry()\nreg.MustRegister(srvMetrics)\n```", "```go\nfunc newMetricsServer(httpAddr string, reg\n  *prometheus.Registry) *http.Server {\n  //...\n  m.Handle(\"/metrics\", promhttp.HandlerFor(reg,\n    promhttp.HandlerOpts{}))\n  //...\n  return httpSrv\n}\nfunc newGrpcServer(lis net.Listener, srvMetrics\n  *grpcprom.ServerMetrics) (*grpc.Server, error) {\n  //...\n  opts := []grpc.ServerOption{\n    //...\n    grpc.ChainUnaryInterceptor(\n      otelgrpc.UnaryServerInterceptor(),\n      srvMetrics.UnaryServerInterceptor(),\n      //...\n    ),\n    grpc.ChainStreamInterceptor(\n      otelgrpc.StreamServerInterceptor(),\n      srvMetrics.StreamServerInterceptor(),\n      //...\n    ),\n  }\n  //...\n}\nfunc main() {\n  //...\n  grpcServer, err := newGrpcServer(lis, srvMetrics)\n  //...\n  metricsServer := newMetricsServer(httpAddr, reg)\n  //...\n}\n```", "```go\n$ go get go.opentelemetry.io/contrib/instrumentation/\n  google.golang.org/grpc/otelgrpc\n```", "```go\n$ go run ./server 0.0.0.0:50051 0.0.0.0:50052\nmetrics server listening at 0.0.0.0:50052\ngRPC server listening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\n$ curl http://localhost:50052/metrics\n```", "```go\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"\n  AddTask\",grpc_service=\"todo.v2.TodoService\",grpc_type=\n    \"unary\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"AddTask\",\n  grpc_service=\"todo.v2.TodoService\",grpc_type=\"unary\",le=\n    \"0.001\"} 3\ngrpc_server_handling_seconds_sum{grpc_method=\"AddTask\",grpc\n  _service=\"todo.v2.TodoService\",grpc_type=\"unary\"}\n    0.000119291\ngrpc_server_msg_received_total{grpc_method=\"AddTask\",grpc_\n  service=\"todo.v2.TodoService\",grpc_type=\"unary\"} 3\ngrpc_server_msg_sent_total{grpc_method=\"AddTask\",grpc_\n  service=\"todo.v2.TodoService\",grpc_type=\"unary\"} 3\ngrpc_server_started_total{grpc_method=\"AddTask\",grpc_\n  service=\"todo.v2.TodoService\",grpc_type=\"unary\"} 3\n```", "```go\n$ bazel run //:gazelle-update-repos\n```", "```go\n$ bazel run //:gazelle\n```", "```go\n$ bazel run //:server:server 0.0.0.0:50051 0.0.0.0:50052\nmetrics server listening at 0.0.0.0:50052\ngRPC server listening at 0.0.0.0:50051\n```", "```go\n$ bazel run //client:client 0.0.0.0:50051\n```", "```go\n$ go get golang.org/x/time/rate\n```", "```go\n$ go get github.com/grpc-ecosystem/go-grpc-middleware/v2/\n  interceptors/ratelimit\n```", "```go\npackage main\nimport (\n  \"context\"\n  \"fmt\"\n  \"golang.org/x/time/rate\"\n)\ntype simpleLimiter struct {\n  limiter *rate.Limiter\n}\nfunc (l *simpleLimiter) Limit(_ context.Context) error {\n  if !l.limiter.Allow() {\n    return fmt.Errorf(\"reached Rate-Limiting %v\", l\n      .limiter.Limit())\n  }\n  return nil\n}\n```", "```go\nimport (\n  //...\n  \"github.com/grpc-ecosystem/go-grpc-middleware/v2/\n    interceptors/ratelimit\"\n)\nfunc newGrpcServer(lis net.Listener, srvMetrics\n  *grpcprom.ServerMetrics) (*grpc.Server, error) {\n  //...\n  limiter := &simpleLimiter{\n    limiter: rate.NewLimiter(2, 4),\n  }\n  opts := []grpc.ServerOption{\n    //...\n    grpc.ChainUnaryInterceptor(\n      ratelimit.UnaryServerInterceptor(limiter),\n      //...\n    ),\n    grpc.ChainStreamInterceptor(\n      ratelimit.StreamServerInterceptor(limiter),\n      //...\n    ),\n  }\n  //...\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051 0.0.0.0:50052\nmetrics server listening at 0.0.0.0:50052\ngRPC server listening at 0.0.0.0:50051\n```", "```go\n$ for i in {1..10}; do go run ./client 0.0.0.0:50051; done\n```", "```go\n$ foreach ($item in 1..10) { go run ./client 0.0.0.0:50051 }\n```", "```go\nrpc error: code = ResourceExhausted desc =\n  /todo.v2.TodoService/UpdateTasks is rejected by\n    grpc_ratelimit middleware, please retry later. reached\n      Rate-Limiting 2\n```", "```go\n$ bazel run //:gazelle-update-repos\n$ bazel run //:gazelle\n```", "```go\n$ bazel run //server:server 0.0.0.0:50051 0.0.0.0:50052\n```", "```go\n$ go get github.com/grpc-ecosystem/go-grpc-middleware/v2/\n  interceptors/retry\n```", "```go\nretryOpts := []retry.CallOption{\n  retry.WithMax(3),\n  retry.WithBackoff(retry.BackoffExponential(100 *\n    time.Millisecond)),\n  retry.WithCodes(codes.Unavailable),\n}\n```", "```go\nimport (\n  //...\n  \"github.com/grpc-ecosystem/go-grpc-middleware/v2/\n    interceptors/retry\"\n)\nfunc main() {\n  //...\n  retryOpts := []retry.CallOption{\n    //...\n  }\n  opts := []grpc.DialOption{\n    //...\n    grpc.WithChainUnaryInterceptor(\n      retry.UnaryClientInterceptor(retryOpts...),\n      //...\n    ),\n    grpc.WithChainStreamInterceptor(\n      retry.StreamClientInterceptor(retryOpts...),\n      //...\n    ),\n    //...\n  }\n  //...\n}\n```", "```go\nfunc (s *server) AddTask(_ context.Context, in\n  *pb.AddTaskRequest) (*pb.AddTaskResponse, error) {\n  return nil, status.Errorf(\n    codes.Unavailable,\n    \"unexpected error: %s\",\n    \"unavailable\",\n  )\n}\n```", "```go\n$ go run ./server 0.0.0.0:50051 0.0.0.0:50052\nmetrics server listening at 0.0.0.0:50052\ngRPC server listening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n--------ADD--------\nrpc error: code = Unavailable desc = unexpected error:\n  unavailable\n```", "```go\nINFO :started call todo.v2.TodoService AddTask\nWARN :finished call todo.v2.TodoService AddTask\nINFO :started call todo.v2.TodoService AddTask\nWARN :finished call todo.v2.TodoService AddTask\nINFO :started call todo.v2.TodoService AddTask\nWARN :finished call todo.v2.TodoService AddTask\n```", "```go\n$ bazel run //:gazelle-update-repos\n$ bazel run //:gazelle\n```", "```go\n$ bazel run //client:client 0.0.0.0:50051\n--------ADD--------\nrpc error: code = Unavailable desc = unexpected error:\n  unavailable\n```"]