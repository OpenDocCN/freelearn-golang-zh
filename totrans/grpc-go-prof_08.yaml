- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More Essential Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw previously that gRPC gives us a lot of important out-of-the-box features
    that make our job simpler. In this chapter, we are going to delve deeper into
    some of the important features that are not included in gRPC but are provided
    by the community. They generally build on top of the gRPC features to provide
    more convenience. They also provide a way to implement the most common practices
    to protect and optimize your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating request messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrying on error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we will have learned what middleware are and what
    they are used for. And we are going to do that by learning more about the awesome
    community projects called `protoc-gen-validate` and `go-grpc-middleware`.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will find the relevant code in the folder called `chapter8`
    in the accompanying GitHub repository ([https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter8](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter8)).
  prefs: []
  type: TYPE_NORMAL
- en: Validating requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we are going to do is reduce the code that checks some
    properties of the request messages. We are going to use the `protoc-gen-validate`
    plugin for `protoc`, which helps us generate validation code for certain messages.
    This can be useful for the use case when we check the description length and the
    due date of a task. We will just call a generated `Validate()` function and it
    will tell us whether the requirements for the request message are fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we are going to do to generate this code is to install
    the plugin. This is a plugin maintained by Buf and you can get it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once we have that, we are now able to use the `--validate_out` option from protoc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, whether we are using protoc manually or with the Buf CLI, we will need
    to copy the `validate.proto` file from the GitHub repository. This file can be
    found here: [https://github.com/bufbuild/protoc-gen-validate/blob/main/validate/validate.proto](https://github.com/bufbuild/protoc-gen-validate/blob/main/validate/validate.proto).
    We will copy it into our `proto` folder under the `validate` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And now, we can import that file into other proto files and use the validation
    rules provided as field options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us work with `AddTaskRequest` in `proto/todo/v2/todo.proto`. Right now,
    we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we know, each time we try to add a `Task`, on the server side, we will check
    whether the description is empty or not and whether `due_date` is greater than
    `time.Now()` or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to encode this logic into our `proto` file. The first thing
    that we need to do is import the `validate.proto` file. Then, we will have access
    to the `validate.rules` field option, which contains a set of rules for multiple
    types. We are going to work on `string` and `Timestamp` and we are going to use
    the `min_len` and `gt_now` fields. The first one describes the minimum length
    that the string should have when we call `Validate` and the second one tells us
    that the `Timestamp` provided should be in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have described this logic, we will need to generate code that checks
    that logic. Otherwise, these options are worthless. To generate this code, we
    are going to do it manually with protoc and then I will show you how to do it
    with Buf and Bazel.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, with the plugin we can use the `--validate_out` option in `protoc`.
    This looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the command is similar to what we ran in the past. We simply added
    the new option and told it to work on Go code and to generate code based on the
    proto files in the `v2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, on top of the Protobuf and gRPC generated code, you should also have
    a `.pb.validate.go` file in the `v2` folder. This should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the generated file, you should be able to see the following function
    (among others):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the function that we are now going to use in our `AddTask` endpoint
    on the server side. Right now, we have the following checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us replace that with the `Validate` function. We are simply going to call
    the function on the `in` parameter and if it returns any error, we will return
    the error from the function, otherwise, we will simply continue with our execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is as simple as that, and we saved ourselves from writing all the checks
    manually and trying to keep our error messages consistent across the different
    endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now go to the `main` client and uncomment the functions, one by one,
    in the error section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following error for the first `addTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And this one for the second `addTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the code error is `Unknown`. As of the time of writing this book,
    `protoc-gen-validate` does not appear to have a custom error code. This might
    appear in `v2` of the plugin. However, it provides us with a simple validation
    code and clean error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Buf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `protoc-gen-validate` with the Buf CLI is simple. We will add some configuration
    in our YAML files in order to generate the code. The first thing that we need
    to add is the dependency on `protoc-gen-validate` in our `buf.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This tells Buf that we need `protoc-gen-validate` during the generation process.
    It will later figure out how to pull the dependency by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'And after that, we need to configure the plugin in the `buf.gen.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These options are the same as we typed manually earlier. Now, we can generate
    as usual by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have the same three generated files that we obtained with the
    `protoc` command: `todo.pb.validate.go`, `todo_grpc.pb.go`, and `todo.pb.go`.
    Note that, in this case, we also generated code for `v1` and the `validate.proto`.'
  prefs: []
  type: TYPE_NORMAL
- en: Bazel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, the first thing we need to do is define the dependency in our `WORKSPACE.bazel`
    file. We are going to fetch the `protoc-gen-validate` project from GitHub and
    load its relevant dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The code that follows references a variable called `PROTOC_GEN_VALIDATE_VERSION`.
    This variable is defined in the `versions.bzl` file in the `chapter8` folder.
    We do not include it here to keep the code independent of versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we now need to update our dependencies in the `deps.bzl` file. We
    can do that by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we need to generate the code and link it to our existing `todo
    go_library` in `proto/todo/v2/BUILD.bazel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to add is the dependency on `protoc-gen-validate` `validate.proto`
    in `v2_proto proto_library`. This will allow `todo.proto` to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will replace `v2_go_proto go_proto_library` with `pgv_go_proto_library`
    (`protoc-gen-validate` library so that the generated code accesses any of the
    `protoc-gen-validate` internal code needed to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, in order to avoid ambiguous imports for `validate/validate.proto`
    the next time we run Gazelle, we are going to map the `validate/validate.proto`
    import (in `proto/todo/v2/todo.proto`) to `@com_envoyproxy_protoc_gen_validate//validate:validate_proto`
    (defined in `protoc-gen-validate`). At the top of the `proto/todo/v2/BUILD.bazel`
    file, we can add the following `Gazelle` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have replaced our old `v2_go_proto` with the new one using `pgv_go_proto_library`,
    the code depending on this library will automatically get access to the generated
    `Validate` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try running the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And run the client with the error section code uncommented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To conclude, we saw that we can encode validation logic in our proto files and
    generate validation code automatically with `protoc-gen-validate`. This declutters
    our code and provides consistent error messages across our API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware = interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of gRPC, a middleware is an interceptor. It lies between the
    code registered by the developers and the actual gRPC framework. When gRPC receives
    some data from the wire, it will pass this data through the middleware first,
    and then if it is allowed to go through, the data will arrive in the actual endpoint
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: These middleware are generally used in order to secure the endpoints against
    malicious actors or enforce certain prerequisites. An example of securing the
    API is rate-limiting clients. This is a limit on the number of requests that a
    client can make in a given timeframe and this is important because it prevents
    a lot of attacks, such as brute force attacks, DoS and DDoS, and web-scraping.
    And to enforce a certain prerequisite, we already saw an example where the client
    needs to be authenticated before being able to call an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going to see some of the middleware provided by the community, I want
    to remind you that we already created middleware in [*Chapter 7*](B19664_07.xhtml#_idTextAnchor423).
    We simply never referred to them as middleware. In fact, we created two and they
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you remember, these middleware will first check that there is an `auth_token`
    header that exists and that its value is `authd`. And then, if it is the case,
    it will log the API call on the terminal and continue with the execution of the
    code we wrote for the API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: So, to summarize, a middleware is an interceptor that can cut the execution
    short depending on some conditions and is there to secure the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section and the following, we are going to simplify the middleware that
    we currently have. First, we are going to start by simplifying the authentication
    process. We saw in the previous chapter that we can easily create an interceptor
    for checking an authentication token in headers. In this section, we are going
    to take a step further and make it even simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC supports retrying authentication of requests through an RBAC policy without
    a third-party library. However, the configuration is quite verbose and not very
    well documented. If you are interested in trying it, you can check the following
    example: [https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md](https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, when we wrote our interceptors, we needed to create the following
    function for a unary interceptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And another one like the following for the stream interceptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While this gives us a lot of information on the calls, the context, and so on,
    this also makes our code terse, and we need to think about how to share the common
    business logic between the stream and unary interceptors.
  prefs: []
  type: TYPE_NORMAL
- en: With the middleware that we are going to add, we will simply focus on our logic,
    and we will be able to register the interceptor as easily as before in our gRPC
    server. This middleware is the auth middleware in the GitHub repository called
    `go-grpc-middleware` ([https://github.com/grpc-ecosystem/go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)).
    It will let us get rid of the complicated authenticator function definitions that
    we add for the interceptors and will let us register directly using our `validateAuthToken`
    function in a predefined interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we are going to fetch the dependency in our `server` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Then, we are going to remove the `unaryAuthInterceptor` and `streamAuthInterceptor`
    in the `server/interceptors.go` file. We do not need them anymore since the new
    auth middleware will take care of everything for us.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we are going to go to the `server/main.go`, where we are going
    to replace the old interceptor with `auth.UnaryServerInterceptor` and `auth.StreamServerInterceptor`.
    These two interceptors take an `AuthFunc`, which basically represents the authentication
    logic. In our case, we will pass to them our `validateAuthToken`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AuthFunc` type looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we need to change the `validateAuthToken` a little bit to return a context
    and/or an error. Our new function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets us register the `validateAuthToken` in the gRPC server. Our new main
    function will now be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should be able to run the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We also run the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We don’t get any errors and it works similarly to before. However, to test
    that the middleware is working properly, we can temporarily modify our interceptor
    on the client side to add a wrong authentication header (`client/interceptors.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we rerun the client, we should get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This proves that our middleware is working as expected and that we can rely
    on only `validAuthToken` to do the authentication checking.
  prefs: []
  type: TYPE_NORMAL
- en: Bazel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to run that with Bazel, we will need to update our dependencies and
    link the new dependency to the `server_lib` target in `server/BUILD.bazel`. So,
    we first run the `gazelle-update-repos` command, which will fetch the `go-grpc-middeware`
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And once we have that, we can now let the `gazelle` command include the `go-grpc-middleware`
    dependency to the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will be able to run our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And the client with the wrong `auth` token should give the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To conclude, in this section, we saw that we can simplify the authenticator
    interceptors by using the `go-grpc-middleware` package. It lets us focus on the
    actual logic and not on how to write an interceptor that can be registered with
    gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Logging API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let us simplify the log interceptor. This will be like what
    we did in the previous section, but we are going to use another middleware: the
    logging middleware.'
  prefs: []
  type: TYPE_NORMAL
- en: While this middleware integrates with a lot of different loggers, we are going
    to use it with the default `log` package in Golang. It will then appear easy to
    integrate with your favorite logger.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The next command is only needed if you did not get the previous dependency on
    `go-grpc-middleware`. If you followed section by section, you should not need
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let us get the dependency on the middleware. In the `server`
    folder, we are going to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start creating our logger. We are going to create it by defining
    a function that returns a `loggerFunc`. This is a function that has the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We already know what the context is, but all the rest is specific to the logger.
    The level is a logging level such as `Debug`, `Info`, `Warning`, or `Error`. This
    is generally used in order to filter the logs depending on the level of severity.
    Then, the message is simply a message generated by the logger middleware such
    as `":started call"` or `":finished call"`. This helps us understand the context
    of the log. And finally, the fields are all the other information that we need
    to print a useful log. In our case, we are going to use the service name and the
    method name. This will let us create logs like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A thing that is not easy to wrap your mind around is the `fields` parameter.
    This is because this is presented as a `vararg` of `any`. In reality, we can transform
    that into a map in order to get a specific field name such as `grpc.service`,
    `grpc.method`, … To do that, we can simply write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are creating a map of `length len(fields)/2`. This is because
    in the `fields` parameter, the name of the fields and their value are interleaved.
    An example is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can print the fields and see the whole thing yourself by expanding the
    `vararg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this knowledge, we can proceed to write the logger. We will
    create a function called `logCalls`, which takes a `log.Logger` (from the `golang`
    standard library) as a param and will return a `logging.Logger` (from the logging
    middleware). The logic of the logger will be to check the log level, prepend the
    level of the message to it, and then we will append the service name and method
    name to the whole message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, while this method will always be accurate because we can retrieve the keys
    in the map that was built, this means that we need to build a map each time this
    interceptor is called. This is not really efficient. I wanted to show you the
    full-blown example before showing you the efficient one so that you understand
    how to use the `fields` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more efficient, we can take advantage of the fact that our service and
    method are always situated at index 5 and 7, respectively. So, we are going to
    remove the map creation part, we are going to replace `grpcService` and `grpcMethod`
    with `5` and `7`, and we are going to access the 5th and 7th element of fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is much more efficient. Now, one thing that is worth mentioning is that
    this is less safe. We are assuming that all the fields that we receive will always
    contain the `service` and `method` at the same index and that our `fields` array
    is large enough. We can safely assume that now, at the time of writing, because
    these are common fields that are added in this order all the time. However, if
    the library changes, you might try to do an out-of-bounds access or get a different
    piece of information. Be aware of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing that we need to do is register the interceptor. This is similar
    to what we did with the authentication interceptor, but the main difference is
    that now we need to create a logger and pass it to the `logCalls` function. We
    are going to use a golang `log.Logger`, which prints the date and time before
    the message. And finally, we are going to pass the result of `logCalls` to `logging.UnaryServerInterceptor`
    and `logging.StreamServerInterceptor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can now run our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before running the client make sure that you replaced the value of `authTokenValue`
    to `authd` in the `client/interceptors.go` file
  prefs: []
  type: TYPE_NORMAL
- en: 'And then run our client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we check the terminal in which the server is running, we should have
    a bunch of messages like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To conclude, we saw that, similarly to the authentication middleware, we can
    simply add a logger to our gRPC server. We also saw that we can access more information
    than just the service name and method name by transforming the `fields varargs`
    into a map. And finally, we saw that some of the fields are always at the same
    place in `vararg`, so instead of generating the map for each call, we can directly
    access the information by index.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On top of logging, which simply describes the events in a developer-friendly
    manner, you might need to get metrics that can get aggregated by dashboard tools.
    These metrics might include requests per second, distribution of status (`Ok`,
    `Internal`, and so on), and many others. In this section, we are going to instrument
    our code with OpenTelemetry and Prometheus so that tools such as Grafana can be
    used to create dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to understand is that we are going to run an HTTP server for
    Prometheus metrics. Prometheus exposes the metrics to external tools on the `/metrics`
    route so that the tools wanting to query the data get a sense of all the kinds
    of metrics available.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to create such a server, we are going to get a dependency on Prometheus’
    Go library. We are going to do that by getting the dependency on the `go-grpc-middleware/providers/prometheus`.
    The `Prometheus Go` library is a transitive dependency of this one and we still
    need to be able to register some more interceptors that are defined in the `Prometheus`
    provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create an HTTP server that will later be used to expose the `/metrics`
    route. We are going to create a function called `newMetricsServer`, which takes
    the address of where the server is running:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The code that follows explains every part of the `server/main.go` file. Displaying
    the full file here would be overwhelming. Thus, we will walk through all of its
    code and you will be able to see the imports and the overall structure in the
    `main.go`. Note that, in order to better explain, We are only adding certain elements
    later in the section. If you see a part of the code that is not presented yet,
    read on and you will get an explanation for the piece of code you are looking
    at.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our HTTP server, we will refactor our main and separate the
    creation of the gRPC server into another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing really changed; we only separated the creation into a function so that
    we can run two servers in parallel later. Before working on that though, our `main`
    should also include two addresses as parameters. The first one is for the gRPC
    server and the other is for the HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can deal with running two servers at once. We are going to use the `errgroup`
    ([https://pkg.go.dev/golang.org/x/sync/errgroup](https://pkg.go.dev/golang.org/x/sync/errgroup))
    package. It lets us add multiple goroutines to a group and wait on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need is to create a context for the group. We are going
    to create a cancellable one so that later we can release the servers’ resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can start handling the `SIGTERM` signal. This is because when we want
    to exit both servers, we will press *Ctrl* + *C*. This will send the `SIGTERM`
    signal, and we expect the servers to be closed gracefully. To handle that, we
    are going to make a channel that will be released when the `SIGTERM` signal is
    received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can now create our group of two servers. We will first create
    the group from the cancellable context that we created. And then, we will use
    the `Go(func() error)` function to add goroutines to that group. The first goroutine
    will handle the serving of the gRPC server and the second goroutine will handle
    the HTTP one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our group, we can wait on the context to be done or on the
    `quit` channel to receive an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Once one of these events is received, we are going to initiate the release
    of resources by making sure that the context is finished (call the `cancel` function),
    and finally, we can wait on the group to finish all the goroutines that we registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Finally, as this is the ultimate goal of this section, we need to add tracing
    capabilities. The metrics server will expose the metrics route and the gRPC server
    will collect the metrics and add them to the Prometheus registry. This registry
    is a collection of collectors. We register one or more collectors to it, then
    the registry will collect the different metrics available, and finally, it will
    expose these metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the registry, we will first create a collector with the `NewServerMetrics`
    function provided in the `go-grpc-middleware/providers/prometheus` package. Then,
    we are going to actually create the registry. And finally, we are going to register
    the collector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we passed an option to the `NewServerMetrics`. This option will
    let us get buckets into which the calls will be placed depending on their latency.
    This basically tells us how many requests were served in under 0.001 seconds,
    0.01 seconds, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are going to pass the registry to the HTTP server so that it knows
    what metrics are available, and we are going to pass the collector to our gRPC
    server so that it can push metrics to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are now using `opentelemetry` (`otelgrpc`). This is a tool that
    lets us generate all the metrics from our gRPC server automatically. Then, Prometheus
    will pick those with the collector (`srvMetrics`). And finally, the HTTP server
    will be able to expose these metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get OpenTelemetry for gRPC, we simply need to get the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now be able to run our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can run our client against the `0.0.0.0:50051` address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And after the client calls are all served, we can look at the metrics like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have logs that look like this (simplified to only show `AddTask`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'These metrics mean that the server received three `AddTask`, handled them all
    in under 0.001 seconds (total: 0.000119291), and returned three responses to the
    client.'
  prefs: []
  type: TYPE_NORMAL
- en: There is obviously a lot more to do with these metrics. However, that would
    probably be a book in itself. If you are interested in this area, I would encourage
    you to look at how to integrate Prometheus with a tool such as Grafana to create
    dashboards representing these metrics in a more human-readable manner.
  prefs: []
  type: TYPE_NORMAL
- en: Bazel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to update the dependencies in order to get Prometheus and OpenTelemetry
    to work. To do that, we are going to run `gazelle-update-repos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we are going to run `gazelle` in order to automatically link the
    dependencies to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can now run our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And then run our client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, we saw how we can get metrics out of our gRPC server by using
    OpenTelemetry and Prometheus. We did that by creating a second server exporting
    metrics on the `/metrics` route, and through the use of a Prometheus registry
    and collector, we exchanged metrics from the gRPC server to the HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Securing APIs with rate limiting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the last interceptor we are going to add to the server, we are going to
    use a rate limiter. More precisely, we are going to use the implementation of
    a token bucket rate limiter, which is provided by the `golang.org/x/time/rate`
    package. In this section, we are not going to delve deeply into what rate limiters
    are or how to build one – that is out of the scope of this book, however, you
    will see how you can use a rate limiter (a readily implemented or custom one)
    in the context of gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is get the dependency on the rate limiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The next command is only needed if you did not get the previous dependency on
    `go-grpc-middleware`. If you followed section by section, you should not need
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The we get the dependency for the interceptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to create a file called `limit.go`, which will contain our
    logic and the wrapper around `rate.Limiter`. We create such a wrapper because
    the interceptor that we are going to use later requires the limiter to implement
    a function called `Limit`, taking a context as a parameter and `rate.Limiter`
    does not have such a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we simply check that the rate limiter allows (or not) the call to
    pass. If it does not, we return an error, otherwise, we return `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is to register `simpleLimiter` in an interceptor. We are
    going to create an instance of type `rate.Limiter` with 2 tokens per second (referred
    to as `r`) and a burst size of 4 (referred to as `b`). If you are unclear on what
    those parameters are, we recommend you read the documentation for Limiter ([https://pkg.go.dev/golang.org/x/time/rate#Limiter](https://pkg.go.dev/golang.org/x/time/rate#Limiter)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all. We now have rate limiting enabled for our API. We can now run
    our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can try to execute more than two calls per second. This should
    not be hard. In fact, you normally can run your client once and it should fail.
    But in order to be sure that it fails, run the client multiple times. On Linux
    and Mac, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And on Windows (PowerShell), you can run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see some queries returning responses and then, quickly, you should
    be able to see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, our rate is very low, and it is not practical in production. We chose
    such a low rate in order to show you how to rate limit. In production, you will
    have business-specific requirements that need to be followed. You will have to
    adapt the code we have shown to match these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Bazel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to run this example with Bazel, we will need to update the repos and
    run Gazelle to import the new dependency (`golang.org/x/time/rate`) to our library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you should be able to run the server like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: To conclude, we saw that we can integrate a rate limiter in our gRPC server.
    The `go-grpc-middleware` interceptor for rate limiting makes it easy to add a
    readily available implementation or a custom one.
  prefs: []
  type: TYPE_NORMAL
- en: Retrying calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of now, we have worked only on the server side. Let us now see an important
    feature on the client side. This feature is the retrying of calls that failed
    depending on the status code. This might be interesting for use cases where the
    network is unreliable. If we get an `Unavailable` error code, we will retry with
    an exponentially bigger wait time. This is because we do not want to retry too
    often and overload the network.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC supports retries without the need for a third-party library. However,
    the configuration is quite verbose and not very well documented. If you are interested
    in trying it, you can check the following example: [https://github.com/grpc/grpc-go/blob/master/examples/features/retry/README.md](https://github.com/grpc/grpc-go/blob/master/examples/features/retry/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us get the dependency that we need (`client` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can define some options for the retry. We will define how many times
    and on which error code we want to retry. We want to retry 3 times, with exponential
    backoff (starting at 100 ms), with the error code being `Unavailable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we simply pass these options to the interceptors provided by the
    `retry` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrying is not available for client streaming. If you attempt to retry on
    such an RPC endpoint, you will get the following error: `rpc error: code = Unimplemented
    desc = grpc_retry: cannot retry on ClientStreams, set grpc_retry.Disable()`. As
    such, it is a bit risky to add the `retry.StreamClientInterceptor` as presented.
    We just wanted to show you that some streaming could also be retried.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have that, we now have a problem. Our API is running locally and there
    is little chance that we will get an `Unavailable` error. So, for the sake of
    testing and demonstration, we are going to make our `AddTask` directly return
    such an error temporarily. In `server/impl.go`, we can comment on the rest of
    the function and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we run our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'And then run our client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We get one error. While this looks like it only did one query, if you look
    back at your server, you should be able to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: That is effectively three requests that were made.
  prefs: []
  type: TYPE_NORMAL
- en: Bazel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, you will need to run `gazelle-update-repos` and `gazelle` in order
    to get the new dependencies and link them to your library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And now you should be able to run your client correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: To conclude, we saw in this section that we can retry depending on some conditions,
    with exponential backoff, and for a certain amount of time. Retry is an important
    feature since the network is often unreliable and we do not want to make the user
    retry manually each time there is a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the key features that we can get by using community
    projects such as `protoc-gen-validate` or `go-grpc-middleware`. We saw that we
    can encode request validation logic in our proto files. This makes our code less
    bloated and provides error message consistency across all the endpoints of our
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at what middleware are and how to create one. We started with
    refactoring our authentication and logging interceptors. We saw that by using
    `go-grpc-middleware`, we can focus only on the actual logic of the interceptor
    and have less boilerplate to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we saw that we can expose tracing data from our API. We used OpenTelemetry
    and Prometheus to gather the data from the gRPC API and expose it through an HTTP
    server.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how to apply rate limiting on our APIs. This is helpful to prevent
    fraudulent actors or defective clients from overloading our server. We used the
    Token Bucket algorithm and an already existing implementation of a rate limiter
    to apply limiting to our API.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we also saw that we can use interceptors on the client side by
    working with retry middleware. This lets us retry a call depending on an error
    code, with a maximum number of retries, and optionally with exponential backoff.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go over the development lifecycle for gRPC APIs,
    how we can ensure their correctness, how we can debug them, and how we can deploy
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of the protoc-gen-validate plugin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing checking logic in a `.``proto` file
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating validation code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of them
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `go-grpc-middleware` used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing commonly used interceptors
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating validation code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which middleware is used for displaying events as human-readable text?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tracing`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`auth`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`logging`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which middleware is used to constrain the number of requests made per second?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tracing`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ratelimit`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`auth`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simplify the client logger you created in the last chapter by using the logging
    middleware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the `protoc-gen-validate` rules ([https://github.com/bufbuild/protoc-gen-validate/blob/main/README.md](https://github.com/bufbuild/protoc-gen-validate/blob/main/README.md))
    and simplify the error handling that you added in the last chapter’s challenges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the other middleware available in [https://github.com/grpc-ecosystem/go-grpc-middleware/tree/v2](https://github.com/grpc-ecosystem/go-grpc-middleware/tree/v2)
    and try to implement one. An example could be the selector middleware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple Grafana dashboard based on the metrics the server is exposing.
    An example could be a dashboard that displays the percentage of requests that
    succeeded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
