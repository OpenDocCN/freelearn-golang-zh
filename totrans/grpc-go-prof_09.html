<html><head></head><body>
<div id="_idContainer029">
<h1 class="chapter-number" id="_idParaDest-170"><a id="_idTextAnchor796"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-171"><a id="_idTextAnchor797"/><span class="koboSpan" id="kobo.2.1">Production-Grade APIs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Up until now, we’ve focused on the features provided by gRPC and those added by community projects. </span><span class="koboSpan" id="kobo.3.2">That was an important topic but it wasn’t the whole story. </span><span class="koboSpan" id="kobo.3.3">We now need to think about how to test, debug, and deploy our </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">gRPC server.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we are going to see how to unit and load test our services. </span><span class="koboSpan" id="kobo.5.2">Then, we are going to see how we can manually interact with our API to debug it. </span><span class="koboSpan" id="kobo.5.3">Finally, we are going to see how we can containerize and deploy our services. </span><span class="koboSpan" id="kobo.5.4">This chapter is divided into the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">Testing APIs</span></span></li>
<li><span class="koboSpan" id="kobo.8.1">Debugging using </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">server reflection</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Deploying gRPC services </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">on Kubernetes</span></span></li>
</ul>
<h1 id="_idParaDest-172"><a id="_idTextAnchor798"/><span class="koboSpan" id="kobo.12.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.13.1">You can find the code for this chapter in the folder called chapter5 in the companion repo for this book at </span><a href="https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter9"><span class="koboSpan" id="kobo.14.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter9</span></a><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">In this chapter, I will be using three main tools: </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">ghz</span></strong><span class="koboSpan" id="kobo.17.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.18.1">grpcurl</span></strong><span class="koboSpan" id="kobo.19.1">, and Wireshark. </span><span class="koboSpan" id="kobo.19.2">You should already have Wireshark installed from </span><a href="B19664_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.20.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.21.1">, but if this is not the case, you can find it at </span><a href="https://www.wireshark.org/"><span class="koboSpan" id="kobo.22.1">https://www.wireshark.org/</span></a><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">ghz is a tool that will let us load test our API. </span><span class="koboSpan" id="kobo.23.3">You can get it by visiting </span><a href="https://ghz.sh/"><span class="koboSpan" id="kobo.24.1">https://ghz.sh/</span></a><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">Finally, we will use grpcurl to interact with our API from the terminal. </span><span class="koboSpan" id="kobo.25.3">You should be able to get it </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">from </span></span><a href="https://github.com/fullstorydev/grpcurl"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://github.com/fullstorydev/grpcurl</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor799"/><span class="koboSpan" id="kobo.29.1">Testing</span></h1>
<p><span class="koboSpan" id="kobo.30.1">Developing production-grade APIs </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.31.1">begins with writing comprehensive tests to ensure that the business requirements are met while also verifying the API’s consistency and performance. </span><span class="koboSpan" id="kobo.31.2">The first part is mostly handled in unit and integration tests and the second part with </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">load testing.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">In the first part of </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.34.1">this section, we are</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.35.1"> going to focus on unit testing the server. </span><span class="koboSpan" id="kobo.35.2">We are going to do one test per API type to understand how you can introduce more in the future. </span><span class="koboSpan" id="kobo.35.3">In the second part, we are going to introduce ghz, which is a tool for load testing gRPC APIs. </span><span class="koboSpan" id="kobo.35.4">We are going to introduce the different options that the tool has and how to load test an API with credentials, an auth token as a header, and </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">so on.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor800"/><span class="koboSpan" id="kobo.37.1">Unit testing</span></h2>
<p><span class="koboSpan" id="kobo.38.1">As mentioned, we</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.39.1"> are going to focus on unit testing the server. </span><span class="koboSpan" id="kobo.39.2">Before beginning, it is important to know that the tests presented here are not all the possible tests that we could do. </span><span class="koboSpan" id="kobo.39.3">To keep this book readable, I will be presenting how to write unit tests for each API type, and you can find an example of other tests in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">server/impl_test.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.41.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">Before writing any tests, we need to do some setup. </span><span class="koboSpan" id="kobo.42.2">We are going to write some boilerplate for the different tests to share the same server and connection. </span><span class="koboSpan" id="kobo.42.3">This is mostly to avoid creating new servers and connections each time we are running a test. </span><span class="koboSpan" id="kobo.42.4">However, note that these are non-hermetic tests. </span><span class="koboSpan" id="kobo.42.5">This means that an unexpected state could be shared across multiple tests and make the tests flaky. </span><span class="koboSpan" id="kobo.42.6">We are going to introduce ways to deal with this and make sure we clear </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">the states.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">The first thing that we can do is create a fake database. </span><span class="koboSpan" id="kobo.44.2">This is like what we did with </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">inMemoryDb</span></strong><span class="koboSpan" id="kobo.46.1">, and in fact, </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">FakeDb</span></strong><span class="koboSpan" id="kobo.48.1"> is a wrapper around </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">inMemoryDb</span></strong><span class="koboSpan" id="kobo.50.1">, but we are also going to test problems due to connectivity with </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">To do so, we are going to use the same pattern as </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">grpc.ServerOption</span></strong><span class="koboSpan" id="kobo.54.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">grpc.ServerOption</span></strong><span class="koboSpan" id="kobo.56.1"> is a function applying a value to a private struct. </span><span class="koboSpan" id="kobo.56.2">An example of this </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">grpc.Creds</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
f</span><a id="_idTextAnchor801"/><span class="koboSpan" id="kobo.61.1">unc Creds(</span><strong class="bold"><span class="koboSpan" id="kobo.62.1">c</span></strong><span class="koboSpan" id="kobo.63.1"> credentials.TransportCredentials) </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">ServerOption</span></strong><span class="koboSpan" id="kobo.65.1"> {
  return newFuncServerOption(func(o *</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">serverOptions</span></strong><span class="koboSpan" id="kobo.67.1">) {
    </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">o.creds = c</span></strong><span class="koboSpan" id="kobo.69.1">
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.70.1">It returns a function that, once called, will set the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">c</span></strong><span class="koboSpan" id="kobo.72.1"> to </span><a id="_idTextAnchor802"/><span class="koboSpan" id="kobo.73.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">creds</span></strong><span class="koboSpan" id="kobo.75.1"> property in </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">serverOptions</span></strong><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">serverOptions</span></strong><span class="koboSpan" id="kobo.79.1"> is different from </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">ServerOption</span></strong><span class="koboSpan" id="kobo.81.1">. </span><span class="koboSpan" id="kobo.81.2">This is a </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">private struct.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">We are going to create </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.84.1">a function that tells us whether the database is available or not. </span><span class="koboSpan" id="kobo.84.2">Later, we are going to enable the option to return an error if it is not. </span><span class="koboSpan" id="kobo.84.3">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">test_options.go</span></strong><span class="koboSpan" id="kobo.86.1">, we will have </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.88.1">
func IsAvailable(a bool) TestOption {
  return newFuncTestOption(func(o *testOptions) {
    o.isAvailable = a
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.89.1">I’ll leave it up to you to check the rest of the content of </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">test_options.go</span></strong><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">The functions and structs there simply create some utilities and varia</span><a id="_idTextAnchor803"/><span class="koboSpan" id="kobo.92.1">bles in order to be able to write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">IsAvailable</span></strong><span class="koboSpan" id="kobo.94.1"> function and get default values </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">isAvailable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Now, we can create </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">FakeDb</span></strong><span class="koboSpan" id="kobo.100.1">. </span><span class="koboSpan" id="kobo.100.2">As mentioned, this is a wrapper around </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">inMemoryDb</span></strong><span class="koboSpan" id="kobo.102.1">, and it has some options. </span><span class="koboSpan" id="kobo.102.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">fake_db.go</span></strong><span class="koboSpan" id="kobo.104.1">, we can have </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
type FakeDb struct {
  d *inMemoryDb
  opts testOptions
}
func NewFakeDb(opt ...TestOption) *FakeDb</span><a id="_idTextAnchor804"/><span class="koboSpan" id="kobo.107.1"> {
  opts := defaultTestOptions
  fo</span><a id="_idTextAnchor805"/><span class="koboSpan" id="kobo.108.1">r _, o := range opt {
    o.apply(&amp;opts)
  }
  return &amp;FakeDb{
    d: &amp;inMemoryDb{},
    opts: opts,
  }
}
func (db *Fak</span><a id="_idTextAnchor806"/><span class="koboSpan" id="kobo.109.1">eDb) Reset() {
  db.opts = defaultTestOptions
  db.d = &amp;inMemoryDb{}
}</span></pre>
<p><span class="koboSpan" id="kobo.110.1">We can now create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">FakeDb</span></strong><span class="koboSpan" id="kobo.112.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">multiple ways:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
NewFakeDb()
NewFakeDb(IsAvailable(false))</span></pre>
<p><span class="koboSpan" id="kobo.115.1">We also</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.116.1"> override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">inMemoryDb</span></strong><span class="koboSpan" id="kobo.118.1"> functions so that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">FakeDb</span></strong><span class="koboSpan" id="kobo.120.1"> implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">db</span></strong><span class="koboSpan" id="kobo.122.1"> interface and so that we can instantiate a server with this database. </span><span class="koboSpan" id="kobo.122.2">Each function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">FakeDb</span></strong><span class="koboSpan" id="kobo.124.1"> follows the same pattern. </span><span class="koboSpan" id="kobo.124.2">We check whether the database is available or not; if it is not, we return an error, and if it is, we return the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">inMemoryDb</span></strong><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">An example of this is </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">addTask</span></strong><span class="koboSpan" id="kobo.128.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">fake_db.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
func (db *</span><strong class="bold"><span class="koboSpan" id="kobo.133.1">FakeDb</span></strong><span class="koboSpan" id="kobo.134.1">) addTask(description string, dueDate
  time.Time) (uint64, error) {
  if !</span><strong class="bold"><span class="koboSpan" id="kobo.135.1">db.opts.isAvailable</span></strong><span class="koboSpan" id="kobo.136.1"> {
    return 0, fmt.Errorf(
      "couldn't access the database",
    )
  }
  return </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">db.d.addTask</span></strong><span class="koboSpan" id="kobo.138.1">(description, dueDate)
}</span></pre>
<p><span class="koboSpan" id="kobo.139.1">Now that we have that, we can move one step closer to writing an actual unit test. </span><span class="koboSpan" id="kobo.139.2">We now need to create a server. </span><span class="koboSpan" id="kobo.139.3">However, we do not want this serv</span><a id="_idTextAnchor807"/><span class="koboSpan" id="kobo.140.1">er to actually use ports on our computer. </span><span class="koboSpan" id="kobo.140.2">Using an actual port could make our tests flaky because if the port is already in use, the test would directly return an error saying that it could not create the instance of </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">To solve </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.143.1">that, gRPC has a package called </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">bufconn</span></strong><span class="koboSpan" id="kobo.145.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">grpc/test/bufconn</span></strong><span class="koboSpan" id="kobo.147.1">). </span><span class="koboSpan" id="kobo.147.2">It lets us create a buffered connection and thus does not need to use ports. </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">bufconn.Listen</span></strong><span class="koboSpan" id="kobo.149.1"> will create a listener and we will be able to use this listener to server requests. </span><span class="koboSpan" id="kobo.149.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">server_test.go</span></strong><span class="koboSpan" id="kobo.151.1">, we will share the listener and database as global variables. </span><span class="koboSpan" id="kobo.151.2">This will let us dispose of the listener after all tests and add/clear tasks in the database from within a test. </span><span class="koboSpan" id="kobo.151.3">On top of that, we will create a function that returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">net.Conn</span></strong><span class="koboSpan" id="kobo.153.1"> connection so that we can use it within the test to create </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">a client:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
import (
  "context"
  "log"
  "net"
  pb "github.com/PacktPublishing/gRPC-Go-for-Professionals/
    proto/todo/v2"
  "google.golang.org/grpc"
  "google.golang.org/grpc/test/bufconn"
)
const bufSize = 1024 * 1024
var lis *bufconn.Listener
var fakeDb *FakeDb = NewFakeDb()
func init() {
  lis = bufconn.Listen(bufS</span><a id="_idTextAnchor808"/><span class="koboSpan" id="kobo.156.1">ize)
  s := grpc.NewServer()
  var testServer *ser</span><a id="_idTextAnchor809"/><span class="koboSpan" id="kobo.157.1">ver = &amp;server{
    d: </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">fakeDb</span></strong><span class="koboSpan" id="kobo.159.1">,
  }
  pb.</span><strong class="bold"><span class="koboSpan" id="kobo.160.1">RegisterTodoServiceServer</span></strong><span class="koboSpan" id="kobo.161.1">(s, testServer)
  </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">go func()</span></strong><span class="koboSpan" id="kobo.163.1"> {
</span><a id="_idTextAnchor810"/><span class="koboSpan" id="kobo.164.1">    if err := s.Serve</span><a id="_idTextAnchor811"/><span class="koboSpan" id="kobo.165.1">(lis); </span><a id="_idTextAnchor812"/><span class="koboSpan" id="kobo.166.1">err != nil &amp;&amp; err</span><a id="_idTextAnchor813"/><span class="koboSpan" id="kobo.167.1">.Error() !=
        "closed" {
      log.Fatalf("Server exited with error: %v\n", err)
    }
  }()
}
func bufDialer(context.Context, string) (net.Conn, error) {
  return lis.Dial()
}</span></pre>
<p><span class="koboSpan" id="kobo.168.1">The</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.169.1"> first thing to notice is that we are using the Go </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">init()</span></strong><span class="koboSpan" id="kobo.171.1"> function to do this setup before the tests are started. </span><span class="koboSpan" id="kobo.171.2">Then, notice that we create an instance of our server and register the implementation of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">TodoService</span></strong><span class="koboSpan" id="kobo.173.1">. </span><span class="koboSpan" id="kobo.173.2">Finally, the server is serving in a goroutine. </span><span class="koboSpan" id="kobo.173.3">So, we need to make sure that the goroutine </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">is canceled.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">We are almost done </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.176.1">with the boilerplate. </span><span class="koboSpan" id="kobo.176.2">We need to create a client that uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">bufDialer</span></strong><span class="koboSpan" id="kobo.178.1"> function to connect to the server through the buffered connection. </span><span class="koboSpan" id="kobo.178.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">impl_test.go</span></strong><span class="koboSpan" id="kobo.180.1">, we are going to create a function that returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">TodoServiceClient</span></strong><span class="koboSpan" id="kobo.182.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">grpc.ClientConn</span></strong><span class="koboSpan" id="kobo.184.1">. </span><span class="koboSpan" id="kobo.184.2">The first is obviously to call our endpoints but the second one is for us to close the client connection at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">each test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
func newClient(t *testing.T) (*grpc.ClientConn,
  pb.TodoServiceClient) {
  ctx := context.Backgr</span><a id="_idTextAnchor814"/><span class="koboSpan" id="kobo.187.1">ound()
  creds := grpc.WithTransportCredentials
    (</span><strong class="bold"><span class="koboSpan" id="kobo.188.1">insecure.NewCredentials()</span></strong><span class="koboSpan" id="kobo.189.1">)</span><a id="_idTextAnchor815"/><span class="koboSpan" id="kobo.190.1">
  conn, err := grpc.DialContext(ctx, "bufnet",
    grpc.</span><strong class="bold"><span class="koboSpan" id="kobo.191.1">WithContextDialer(bufDialer)</span></strong><span class="koboSpan" id="kobo.192.1">, cred</span><a id="_idTextAnchor816"/><span class="koboSpan" id="kobo.193.1">s)
  i</span><a id="_idTextAnchor817"/><span class="koboSpan" id="kobo.194.1">f err != nil {
    t.Fatalf("failed to dial bufnet: %v", err)
  }
  return conn, pb.</span><strong class="bold"><span class="koboSpan" id="kobo.195.1">NewTodoServiceClient</span></strong><span class="koboSpan" id="kobo.196.1">(conn)
}</span></pre>
<p><span class="koboSpan" id="kobo.197.1">One important thing to understand here is that we are not testing the whole server that we wrote in </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">main.go</span></strong><span class="koboSpan" id="kobo.199.1">. </span><span class="koboSpan" id="kobo.199.2">We are simply testing our endpoints implementation. </span><span class="koboSpan" id="kobo.199.3">This is why we can connect to the server with insecure credentials. </span><span class="koboSpan" id="kobo.199.4">The interceptors, encryption, and so on should be tested in </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">integration tests.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Finally, we can create a small utility function that checks that an error is a grpc error and that it has an </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">expected message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
func errorIs(err error, code codes.Code, msg string) boo</span><a id="_idTextAnchor818"/><span class="koboSpan" id="kobo.204.1">l {
  i</span><a id="_idTextAnchor819"/><span class="koboSpan" id="kobo.205.1">f err != nil {
    if s, ok := status.FromError(err); ok {
      if </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">code == s.Code() &amp;&amp; s.Message() == msg</span></strong><span class="koboSpan" id="kobo.207.1"> {
        return true
      }
    }
  }
  return false
}</span></pre>
<p><span class="koboSpan" id="kobo.208.1">We are now </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.209.1">ready to write some unit tests. </span><span class="koboSpan" id="kobo.209.2">We are going to create a function that will run all the unit tests and dispose of the listener when all the subtests </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">are finished:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
func TestRunAll(t *testing.T) {
}</span></pre>
<p><span class="koboSpan" id="kobo.212.1">We are now able to populate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">TestRunAll</span></strong><span class="koboSpan" id="kobo.214.1"> function with subtests, </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
func TestRunAll(t *testing.T) {
  t.Run("AddTaskTests", func(t *testing.T) {
    //...
</span><span class="koboSpan" id="kobo.216.2">  })
  t.Cleanup(func() {
    </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">lis.Close()</span></strong><span class="koboSpan" id="kobo.218.1">
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.219.1">Let us now write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">testAddTaskEmptyDescription</span></strong><span class="koboSpan" id="kobo.221.1"> function, which checks that we get an error when we send a request with an empty description. </span><span class="koboSpan" id="kobo.221.2">We will create a new instance of a client, create an empty request, send it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">AddTask</span></strong><span class="koboSpan" id="kobo.223.1">, and finally, check that </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.224.1">our error has an unknown code (returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.226.1">) and that the message is </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">invalid AddTaskRequest.Description: value length must be </span><a id="_idTextAnchor820"/><span class="koboSpan" id="kobo.228.1">at least 1 runes</span></strong><span class="koboSpan" id="kobo.229.1"> (also </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">protoc-gen-validate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
const (
  errorInvalidDescription = "invalid AddTaskRequest
    .Description: value length must be </span><a id="_idTextAnchor821"/><span class="koboSpan" id="kobo.234.1">at least 1 runes"
)
func testAddTaskEmptyDescription(t *testing.T)</span><a id="_idTextAnchor822"/><span class="koboSpan" id="kobo.235.1"> {
  conn, c := newClient(t)
  defer conn.Close()
  req := &amp;pb.AddTaskReque</span><a id="_idTextAnchor823"/><span class="koboSpan" id="kobo.236.1">st{}
  _, err := c.AddTask(context.TODO()), req)
  if !errorIs(err, codes.Unknown, errorInvalidDescription) {
    t.Erro</span><a id="_idTextAnchor824"/><span class="koboSpan" id="kobo.237.1">rf(
      "expected Unknown with message \"%s\", got %v",
      errorInvalidDescription, err,
    )
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.238.1">We can then add it to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">TestRunAll</span></strong><span class="koboSpan" id="kobo.240.1"> function, </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
func TestRunAll(t *testing.T) {
  t.Run("AddTaskTests", func(t *testing.T) {
    t.Run("TestAddTaskEmptyDescription",
       testAddTaskEmptyDescription)
  }
  //...
</span><span class="koboSpan" id="kobo.242.2">}</span></pre>
<p><span class="koboSpan" id="kobo.243.1">To run this</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.244.1"> test, we can run the following command in the </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">root folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
$ go test -run</span><a id="_idTextAnchor825"/><span class="koboSpan" id="kobo.247.1"> ^TestRunAll$ ./server
ok</span></pre>
<p><span class="koboSpan" id="kobo.248.1">Now, before moving on to looking at how to test streams, let us see how we can test with an unavailable databa</span><a id="_idTextAnchor826"/><span class="koboSpan" id="kobo.249.1">se. </span><span class="koboSpan" id="kobo.249.2">This is almost the same as what we did in </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">testAddTaskEmptyDescription</span></strong><span class="koboSpan" id="kobo.251.1">, but we are going to override the database. </span><span class="koboSpan" id="kobo.251.2">Finally, we are going to check that we get an internal error and reset the database (to clear </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the options):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
const (
  //...
</span><span class="koboSpan" id="kobo.253.2">  errorNoDatabaseAccess = "unexpected error: couldn't
    access the database"
)
func testAddTaskUnavailableDb(t *testing.T</span><a id="_idTextAnchor827"/><span class="koboSpan" id="kobo.254.1">) {
  conn, c := newClient(t)
  defer conn.Close()
  </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">newDb := NewFakeDb(IsAvailable(false))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.256.1">  *fakeDb = *newDb</span></strong><span class="koboSpan" id="kobo.257.1">
  req := &amp;pb.AddTaskRequest{
    </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">Description: "test",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.259.1">    DueDate: timestamppb.N</span><a id="_idTextAnchor828"/><span class="koboSpan" id="kobo.260.1">ew(time.Now().Add(5 *</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.261.1">        time.Hour))</span><a id="_idTextAnchor829"/><span class="koboSpan" id="kobo.262.1">,</span></strong><span class="koboSpan" id="kobo.263.1">
  }
  _, err := c.AddTask(context.TODO(), req)
  </span><strong class="bold"><span class="koboSpan" id="kobo.264.1">fakeDb.Reset()</span></strong><span class="koboSpan" id="kobo.265.1">
  if !errorIs(err, codes.Internal, errorNoDatabaseAccess) {
    t.Errorf("expected Internal, got %v", err)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.266.1">We can see that it is easy</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.267.1"> to test a database failure. </span><span class="koboSpan" id="kobo.267.2">That is all for unary RPC. </span><span class="koboSpan" id="kobo.267.3">I will let you add </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">testAddTaskUnavailableDb</span></strong><span class="koboSpan" id="kobo.269.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">TestRunAll</span></strong><span class="koboSpan" id="kobo.271.1"> and look at the other tests for </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">AddTasks</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.273.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">impl_test.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">We are now going to test </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">ListTasks</span></strong><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">We will add some tasks to our fake database, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">ListTasks</span></strong><span class="koboSpan" id="kobo.280.1">, make sure that there is no error, and check that </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">ListTasks</span></strong><span class="koboSpan" id="kobo.282.1"> iterated through all </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">the tasks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
func testListTasks(t *testing.</span><a id="_idTextAnchor830"/><span class="koboSpan" id="kobo.285.1">T) {
  conn, c := newClient(t)
  defer conn.Close()
  fake</span><a id="_idTextAnchor831"/><span class="koboSpan" id="kobo.286.1">Db.d.tasks = []*pb.Task{
    {}, {}, {}, // 3 empty tasks
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">expectedRead := len(fakeDb.d.tasks)</span></strong><span class="koboSpan" id="kobo.288.1">
  req := &amp;pb.ListTask</span><a id="_idTextAnchor832"/><span class="koboSpan" id="kobo.289.1">sRequest{}
  count </span><a id="_idTextAnchor833"/><span class="koboSpan" id="kobo.290.1">:= 0
  res, err := c.ListTasks(context.TODO()</span><a id="_idTextAnchor834"/><span class="koboSpan" id="kobo.291.1">, req)
</span><a id="_idTextAnchor835"/><span class="koboSpan" id="kobo.292.1">
  if err != nil {
    t.Errorf("unexpected error: %v", err)
  }
  </span><a id="_idTextAnchor836"/><span class="koboSpan" id="kobo.293.1">for {
    _, err := res.Recv()
    if err == io.EOF {
      break
    }
    if err != nil {
      t.Errorf("error while reading stream: %v", err)
    }
</span><strong class="bold"><span class="koboSpan" id="kobo.294.1">    count</span><a id="_idTextAnchor837"/><span class="koboSpan" id="kobo.295.1">++</span></strong><span class="koboSpan" id="kobo.296.1">
  }
  if count != </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">expectedRead </span></strong><span class="koboSpan" id="kobo.298.1">{
    t.Er</span><a id="_idTextAnchor838"/><span class="koboSpan" id="kobo.299.1">rorf(
      "expected reading %d tasks, read %d",
      expectedRead, count,
    )
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.300.1">There is </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.301.1">nothing new in terms of calling the API. </span><span class="koboSpan" id="kobo.301.2">We already know all of this from when we wrote the client. </span><span class="koboSpan" id="kobo.301.3">However, the main difference here, for this test, is we do not look at the values; we simply assert the time we looped. </span><span class="koboSpan" id="kobo.301.4">Of course, you could create more sophisticated tests out of this, but I wanted to show you a simple test on a server streaming API so that you can build </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">upon it.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">Next, let us test the client streaming API endpoint. </span><span class="koboSpan" id="kobo.303.2">As we are working with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.305.1"> endpoint, we will need to set data in our database. </span><span class="koboSpan" id="kobo.305.2">After </span><a id="_idTextAnchor839"/><span class="koboSpan" id="kobo.306.1">that, we will basically create an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Updat</span><a id="_idTextAnchor840"/><span class="koboSpan" id="kobo.308.1">eTasksRequest</span></strong><span class="koboSpan" id="kobo.309.1"> in order to change all the items in the database, send the requests, and check that all the updates ran </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">without error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
func testUpdateTasks(t *testing</span><a id="_idTextAnchor841"/><span class="koboSpan" id="kobo.312.1">.T) {
  conn, c := newClient(t)
  defer conn.Close()
  fak</span><a id="_idTextAnchor842"/><span class="koboSpan" id="kobo.313.1">eDb.d.tasks = []*pb.Task{
    {Id: 0, Description: "test1"},
    {Id: 1, Description: "test2"},
    {Id: 2, Description: "te</span><a id="_idTextAnchor843"/><span class="koboSpan" id="kobo.314.1">st3"},
  }
</span><a id="_idTextAnchor844"/><span class="koboSpan" id="kobo.315.1">  requests := []*pb.UpdateTasksRequest{
    {Id: 0}, {Id: 1}, {Id: 2},
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.316.1">expectedUpdates</span></strong><span class="koboSpan" id="kobo.317.1"> := len(request</span><a id="_idTextAnchor845"/><span class="koboSpan" id="kobo.318.1">s)
  stream, err := c.UpdateTasks(cont</span><a id="_idTextAnchor846"/><span class="koboSpan" id="kobo.319.1">ext.TODO())
  cou</span><a id="_idTextAnchor847"/><span class="koboSpan" id="kobo.320.1">nt := 0</span><a id="_idTextAnchor848"/><span class="koboSpan" id="kobo.321.1">
  if err != nil {
    t.Errorf("unexpected error: %v", err)
  }
  for _, req := range requ</span><a id="_idTextAnchor849"/><span class="koboSpan" id="kobo.322.1">ests {
    if err := stre</span><a id="_idTextAnchor850"/><span class="koboSpan" id="kobo.323.1">am.Send</span><a id="_idTextAnchor851"/><span class="koboSpan" id="kobo.324.1">(req); err != nil {
      t.Fatal(err)
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">count++</span></strong><span class="koboSpan" id="kobo.326.1">
  }
  _, err = stream.CloseAn</span><a id="_idTextAnchor852"/><span class="koboSpan" id="kobo.327.1">dRecv()</span><a id="_idTextAnchor853"/><span class="koboSpan" id="kobo.328.1">
  if err != nil {
    t.Errorf("unexpected error: %v", e</span><a id="_idTextAnchor854"/><span class="koboSpan" id="kobo.329.1">rr)
  }
  if </span><strong class="bold"><span class="koboSpan" id="kobo.330.1">count != expectedUpdates</span></strong><span class="koboSpan" id="kobo.331.1"> {
    t.E</span><a id="_idTextAnchor855"/><span class="koboSpan" id="kobo.332.1">rrorf(
      "expected updating %d tasks, updated %d",
      expectedUpdates, count,
    )
</span><a id="_idTextAnchor856"/><span class="koboSpan" id="kobo.333.1">  }
}</span></pre>
<p><span class="koboSpan" id="kobo.334.1">This is similar to </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.335.1">the previous test. </span><span class="koboSpan" id="kobo.335.2">We used a counter to check that all updates were “applied.” </span><span class="koboSpan" id="kobo.335.3">In an integration test, you would have to check </span><a id="_idTextAnchor857"/><span class="koboSpan" id="kobo.336.1">that the value actually changed in the database; however, because we are in unit tests and we have an in-memory database, checking the actual values would not </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">mean much.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Finally, we will test the bidirectional streaming API. </span><span class="koboSpan" id="kobo.338.2">This is a little bit more complex in the testing context, but we are going to tackle the problem step by step. </span><span class="koboSpan" id="kobo.338.3">Previously, in the client, when an error happened in a goroutine, we simply ran </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">log.Fatalf</span></strong><span class="koboSpan" id="kobo.340.1"> to exit. </span><span class="koboSpan" id="kobo.340.2">However, here, because we want to keep track of errors and we cannot call </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">t.Fatalf</span></strong><span class="koboSpan" id="kobo.342.1"> in a different goroutine from the one of the tests, we are going to use a channel of </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">struct</span></strong><span class="koboSpan" id="kobo.344.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">countAndError</span></strong><span class="koboSpan" id="kobo.346.1">. </span><span class="koboSpan" id="kobo.346.2">As its name suggests, this is a structure containing a counter and an </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">optional error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
type countAndError struct {
  count int
  err error
}</span></pre>
<p><span class="koboSpan" id="kobo.349.1">This is useful because now, we will be able to wait for the goroutine to finish and get a result of the channel. </span><span class="koboSpan" id="kobo.349.2">First, let us create the function that sends all the requests. </span><span class="koboSpan" id="kobo.349.3">This function is </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.350.1">called </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">sendRequestsOverStream</span></strong><span class="koboSpan" id="kobo.352.1"> and it will be called in a </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">separate goroutine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.354.1">
func sendRequestsOverStream(stream
  pb.TodoService_DeleteTasksClient, requests
    []*pb.DeleteTasksRequest, </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">waitc chan countAndError</span></strong><span class="koboSpan" id="kobo.356.1">) {
  for _, req := range re</span><a id="_idTextAnchor858"/><span class="koboSpan" id="kobo.357.1">quests {
    if err := st</span><a id="_idTextAnchor859"/><span class="koboSpan" id="kobo.358.1">ream.Se</span><a id="_idTextAnchor860"/><span class="koboSpan" id="kobo.359.1">nd(req); err != nil {
      </span><strong class="bold"><span class="koboSpan" id="kobo.360.1">waitc &lt;</span><a id="_idTextAnchor861"/><span class="koboSpan" id="kobo.361.1">- countAndError{err: err}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.362.1">      close(waitc)</span></strong><span class="koboSpan" id="kobo.363.1">
      return
</span><a id="_idTextAnchor862"/><span class="koboSpan" id="kobo.364.1">    }
  }
  if err := stre</span><a id="_idTextAnchor863"/><span class="koboSpan" id="kobo.365.1">am.Clos</span><a id="_idTextAnchor864"/><span class="koboSpan" id="kobo.366.1">eSend(); err != nil {
    </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">waitc &lt;</span><a id="_idTextAnchor865"/><span class="koboSpan" id="kobo.368.1">- countAndError{err: err}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.369.1">    close(waitc)</span></strong><span class="koboSpan" id="kobo.370.1">
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.371.1">If an error occurs, we will close the waiting channel with an error set in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">countAndError</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1"> structure.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">Then, we can create the function that reads responses. </span><span class="koboSpan" id="kobo.374.2">This function is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">readResponsesOverStream</span></strong><span class="koboSpan" id="kobo.376.1"> and will also be called in a </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">separate goroutine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
func readResponsesOverStream(stream
  pb.TodoService_DeleteTasksClient, waitc chan
    cou</span><a id="_idTextAnchor866"/><span class="koboSpan" id="kobo.379.1">ntAndError) {
  count := 0
</span><a id="_idTextAnchor867"/><span class="koboSpan" id="kobo.380.1">
  for {
    _, err := stream.Recv()
    if err == io.EOF {
      brea</span><a id="_idTextAnchor868"/><span class="koboSpan" id="kobo.381.1">k
    }</span><a id="_idTextAnchor869"/><span class="koboSpan" id="kobo.382.1">
    if err != nil {
</span><strong class="bold"><span class="koboSpan" id="kobo.383.1">      waitc &lt;</span><a id="_idTextAnchor870"/><span class="koboSpan" id="kobo.384.1">- countAndError{err: err}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.385.1">      close(waitc)</span></strong><span class="koboSpan" id="kobo.386.1">
      return
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">count++</span></strong><span class="koboSpan" id="kobo.388.1">
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.389.1">  waitc &lt;- countAndError{count: count}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.390.1">  clos</span><a id="_idTextAnchor871"/><span class="koboSpan" id="kobo.391.1">e(waitc)</span></strong><span class="koboSpan" id="kobo.392.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.393.1">This time, if </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.394.1">everything goes well, the channel will get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">countAndError</span></strong><span class="koboSpan" id="kobo.396.1"> with a count set. </span><span class="koboSpan" id="kobo.396.2">This count is the same as what we did in previous tests. </span><span class="koboSpan" id="kobo.396.3">It checks the number of responses that were collected </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">without error.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">Now that we have</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.399.1"> these two functions, we are ready to write the actual test for our bidirectional strea</span><a id="_idTextAnchor872"/><span class="koboSpan" id="kobo.400.1">ming API. </span><span class="koboSpan" id="kobo.400.2">This is similar to what we did for </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">ListTasks</span></strong><span class="koboSpan" id="kobo.402.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.404.1">; however, this time, we launch two goroutines, wait for the result, and check that we have no error and a count equal to the number </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">of requests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
func testDeleteTasks(t *tes</span><a id="_idTextAnchor873"/><span class="koboSpan" id="kobo.407.1">ting.T) {
  conn, c := newClient(t)
  defer conn.Close()
  fakeDb.d.tasks = []*pb.Task{
    {Id: 1}, {Id: 2}, {Id: 3},
  }
  expectedRead := len(fakeDb.d.t</span><a id="_idTextAnchor874"/><span class="koboSpan" id="kobo.408.1">asks)
  waitc := make(chan</span><a id="_idTextAnchor875"/><span class="koboSpan" id="kobo.409.1"> countAndErr</span><a id="_idTextAnchor876"/><span class="koboSpan" id="kobo.410.1">or)
  requests := []*pb.DeleteTasksRequest{
    {Id: 1}, {Id: 2}, {Id: 3</span><a id="_idTextAnchor877"/><span class="koboSpan" id="kobo.411.1">},
  }
  stream, err := c.DeleteTasks(cont</span><a id="_idTextAnchor878"/><span class="koboSpan" id="kobo.412.1">ext.TOD</span><a id="_idTextAnchor879"/><span class="koboSpan" id="kobo.413.1">O())
  if err != nil {
    t.Errorf("unexpected error: %v", err)
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.414.1">go sendRequestsOverStream(stream, requests, waitc)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.415.1">  go readResponsesOverStream(stream, waitc)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.416.1">  countAndError := &lt;-waitc</span></strong><span class="koboSpan" id="kobo.417.1">
  if cou</span><a id="_idTextAnchor880"/><span class="koboSpan" id="kobo.418.1">ntAndError.err != nil {
    t.Errorf("expected error: %v", countAndError.err)
  }
  if countAndError.count != expectedRead {
    t.Errorf(
      "expected reading %d responses, read %d",
      expectedRead, countAndError.count,
    )
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.419.1">With that, we</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.420.1"> have finally finished testing all the different types of gRPC APIs. </span><span class="koboSpan" id="kobo.420.2">Once again, there are more tests that can be done, and other examples are available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">impl_test.go</span></strong><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">I strongl</span><a id="_idTextAnchor881"/><span class="koboSpan" id="kobo.423.1">y encourage you to take a look there so you can get </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">more ideas.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">After adding all these tests to </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">TestRunAll</span></strong><span class="koboSpan" id="kobo.427.1">, you should be able to run them </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
$ go te</span><a id="_idTextAnchor882"/><span class="koboSpan" id="kobo.430.1">st -run ^TestRunAll$ ./server
ok</span></pre>
<p><span class="koboSpan" id="kobo.431.1">If you want a more detailed output of what test ran, you can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">–v</span></strong><span class="koboSpan" id="kobo.433.1"> option. </span><span class="koboSpan" id="kobo.433.2">This will return something like </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
$ go test -run ^TestRunAll$ -v ./server
--- PASS: TestRunAll
    --- PASS: TestRunAll/AddTaskTests
        --- PASS: TestRunAll/AddTaskTests/
          </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">TestAddTaskUnavailableDb</span></strong><span class="koboSpan" id="kobo.437.1">
        --- PASS:</span><a id="_idTextAnchor883"/><span class="koboSpan" id="kobo.438.1">
//...
</span><span class="koboSpan" id="kobo.438.2">PASS</span></pre>
<h3><span class="koboSpan" id="kobo.439.1">Bazel</span></h3>
<p><span class="koboSpan" id="kobo.440.1">In order to run tests </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.441.1">with Bazel, you can run Gazelle to generate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">//</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">server:server_test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1"> t</span><a id="_idTextAnchor884"/><span class="koboSpan" id="kobo.445.1">arget:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.446.1">
$ bazel run //:gazelle</span></pre>
<p><span class="koboSpan" id="kobo.447.1">You will then </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.448.1">have the target available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">server/BUILD.bazel</span></strong><span class="koboSpan" id="kobo.450.1">, and you should be able to run </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.452.1">$ bazel run //server:server_test</span></strong><span class="koboSpan" id="kobo.453.1">
PASS</span></pre>
<p><span class="koboSpan" id="kobo.454.1">If you want to get a more verbose output for your tests, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">–test_arg</span></strong><span class="koboSpan" id="kobo.456.1"> option and set it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">-test.v</span></strong><span class="koboSpan" id="kobo.458.1">. </span><span class="koboSpan" id="kobo.458.2">It will return something like </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.460.1">$ bazel run //server:server_test --test_arg=-test.v</span></strong><span class="koboSpan" id="kobo.461.1">
--- PASS: TestRunAll
    --- PASS: TestRunAll/AddTaskTests
        --- PASS: TestRunAll/AddTaskTests/
          </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">TestAddTaskUnavailableDb</span></strong><span class="koboSpan" id="kobo.463.1">
        --- PASS:
//...
</span><span class="koboSpan" id="kobo.463.2">PASS</span></pre>
<p><span class="koboSpan" id="kobo.464.1">To conclude, we saw how to test unary, server streaming, client streaming, and bidirectional streaming APIs. </span><span class="koboSpan" id="kobo.464.2">We saw that we do not need to use a port on the machine running the</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.465.1"> test when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">bufconn</span></strong><span class="koboSpan" id="kobo.467.1">. </span><span class="koboSpan" id="kobo.467.2">This makes our tests less reliant on the environment it runs on. </span><span class="koboSpan" id="kobo.467.3">Finally, we also saw </span><a id="_idTextAnchor885"/><span class="koboSpan" id="kobo.468.1">that we can use</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.469.1"> fakes in order to test our system dependencies. </span><span class="koboSpan" id="kobo.469.2">This is a bit out of the scope of this book, but it was important to me to show you that you can write normal tests even if you are </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">using gRPC</span><a id="_idTextAnchor886"/><span class="koboSpan" id="kobo.471.1">.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor887"/><span class="koboSpan" id="kobo.472.1">Load testing</span></h2>
<p><span class="koboSpan" id="kobo.473.1">Another important step</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.474.1"> when testing your services is to make sure that they are efficient and can handle a specific load. </span><span class="koboSpan" id="kobo.474.2">For this, we use load-testing tools that will concurrently send requests to our service. </span><span class="koboSpan" id="kobo.474.3">ghz is a tool that does just that. </span><span class="koboSpan" id="kobo.474.4">In this section, we are going to see how to use the tool and some opti</span><a id="_idTextAnchor888"/><span class="koboSpan" id="kobo.475.1">ons that we need to set in order to test </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">our API.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">ghz is a tool that is highly configurable. </span><span class="koboSpan" id="kobo.477.2">Run the following command to see and understand </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">the output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">
$ ghz --help</span></pre>
<p><span class="koboSpan" id="kobo.480.1">Obviously, we are not</span><a id="_idTextAnchor889"/><span class="koboSpan" id="kobo.481.1"> going to use all these options but we will examine the most common ones and the ones that we need to use in some specific cases. </span><span class="koboSpan" id="kobo.481.2">Let us start by trying to make a </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">simple call.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.483.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.484.1">In order to run the following load test, you will need to deactivate the rate-limiting middleware in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">server/main.go</span></strong><span class="koboSpan" id="kobo.486.1"> file. </span><span class="koboSpan" id="kobo.486.2">You can do so by commenting </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">ratelimit.UnaryServerInterceptor</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.488.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">ratelimit.StreamServerInterceptor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">We fir</span><a id="_idTextAnchor890"/><span class="koboSpan" id="kobo.492.1">st run </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">our server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.494.1">$ go run ./server 0.0.0.0:50051 0.0.0.0:50052</span></strong><span class="koboSpan" id="kobo.495.1">
metrics server listening at 0.0.0.0:50052
gRPC server listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.496.1">The first four options that we are going to talk about are the most common ones. </span><span class="koboSpan" id="kobo.496.2">We need to be able to name the service and method that we want to call (</span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">--call</span></strong><span class="koboSpan" id="kobo.498.1">), indicate in which proto</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.499.1"> file the service is defined (</span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">--proto</span></strong><span class="koboSpan" id="kobo.501.1">) and where to find the imports (</span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">--import_paths</span></strong><span class="koboSpan" id="kobo.503.1">), and finally, specify the data to be sent as a request. </span><span class="koboSpan" id="kobo.503.2">In our case, a basic command, run from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">chapter9</span></strong><span class="koboSpan" id="kobo.505.1"> folder, will look </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
$ ghz --proto ./proto/todo/v2/todo.proto \
      --import-paths=proto               \
      --call todo.v2.TodoService.AddTask \
      --data '{"description":"task"}'    \
      0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.508.1">However, if you try to run this command, you will end up having an error message like </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
connection error: desc = "transport: authentication
handshake failed: </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">tls</span></strong><span class="koboSpan" id="kobo.512.1">: failed to verify certificate: x509:
"test-server1" certificate is not standards compliant"</span></pre>
<p><span class="koboSpan" id="kobo.513.1">As you can surely guess from the message, this is because we set up our server to only accept secure connections. </span><span class="koboSpan" id="kobo.513.2">To solve this problem, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">--cacert</span></strong><span class="koboSpan" id="kobo.515.1"> option, which lets us specify a path to where the CA certificate is. </span><span class="koboSpan" id="kobo.515.2">If you remember, this is exactly what we did in the code for our client. </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">ghz</span></strong><span class="koboSpan" id="kobo.517.1"> also needs </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">that information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.519.1">
$ ghz #... </span><span class="koboSpan" id="kobo.519.2">\
      --cacert ./certs/ca_cert.pem \
      0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.520.1">If you run this command, you will get the same error as previously. </span><span class="koboSpan" id="kobo.520.2">This is because a certificate has a domain name associated with it. </span><span class="koboSpan" id="kobo.520.3">This means that only requests from a certain domain name will be accepted. </span><span class="koboSpan" id="kobo.520.4">However, because we are working from localhost, this simply does not meet that requirement and fails. </span><span class="koboSpan" id="kobo.520.5">To solve that, we are going to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">--cname</span></strong><span class="koboSpan" id="kobo.522.1"> option to override the domain name from which we are sending to comply with </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">the certificate:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
$ ghz #... </span><span class="koboSpan" id="kobo.524.2">\
      --cacert ./certs/ca_cert.pem \
      --cname "check.test.example.com" \
      0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.525.1">Here, we </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.526.1">used </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">check.test.example.com</span></strong><span class="koboSpan" id="kobo.528.1"> because the generated certificate that we downloaded from </span><a href="https://github.com/grpc/grpc-go/tree/master/examples/data/x509"><span class="koboSpan" id="kobo.529.1">https://github.com/grpc/grpc-go/tree/master/examples/data/x509</span></a><span class="koboSpan" id="kobo.530.1"> was generated with the DNS name </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">*.test.example.com</span></strong><span class="koboSpan" id="kobo.532.1"> (see </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">openssl.cnf</span></strong><span class="koboSpan" id="kobo.534.1">). </span><span class="koboSpan" id="kobo.534.2">Also, note that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">--cacert</span></strong><span class="koboSpan" id="kobo.536.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">--cname</span></strong><span class="koboSpan" id="kobo.538.1"> are only useful for self-signed certificates. </span><span class="koboSpan" id="kobo.538.2">In general, except for specific cases, these certificates are used for testing and </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">non-production environments.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">Now, if you run the previous command, you should get the </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">following error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.542.1">
Unauthenticated desc = failed to get auth_token</span></pre>
<p><span class="koboSpan" id="kobo.543.1">That should ring a bell. </span><span class="koboSpan" id="kobo.543.2">This is the error we are sending in our auth interceptor when a client does not pro</span><a id="_idTextAnchor891"/><span class="koboSpan" id="kobo.544.1">vide </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">auth_token</span></strong><span class="koboSpan" id="kobo.546.1"> metadata. </span><span class="koboSpan" id="kobo.546.2">In order to send that metadata, we are going to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">--metadata</span></strong><span class="koboSpan" id="kobo.548.1"> option, which takes a JSON string for keys </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">and values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.550.1">
ghz #... </span><span class="koboSpan" id="kobo.550.2">\
    --metadata '{"auth_token":"authd"}' \
    0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.551.1">After running with all these options, we should be able to run our first load test (the results might be different </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">for you):</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.553.1">$ ghz --proto ./proto/todo/v2/todo.proto \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.554.1">      --import-paths=proto                \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.555.1">      --call todo.v2.TodoService.AddTask  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.556.1">\</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.557.1">      --data '{"description":"task"}'     \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.558.1">      --cacert ./certs/ca_cert.pem        \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.559.1">     --cname "check.test.example.com"    \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.560.1">      --metadata '{"auth_token":"authd"}' \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.561.1">      0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.562.1">
Summary:
  </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">Count:    200</span></strong><span class="koboSpan" id="kobo.564.1">
  Total:    22.89 ms
  Slowest:    16.70 ms
  Fastest:    0.20 ms
  Average:    4.60 ms
  Requests/sec:    8736.44
Response time histogram:
  0.204  [1]   |
</span><strong class="bold"><span class="koboSpan" id="kobo.565.1">  1.854  [111]</span></strong><span class="koboSpan" id="kobo.566.1"> |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.504  [38]  |∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  5.153  [0]   |
  6.803  [0]   |
  8.453  [0]   |
  10.103 [0]   |
  11.753 [0]   |
  </span><strong class="bold"><span class="koboSpan" id="kobo.567.1">13.403 [2]</span></strong><span class="koboSpan" id="kobo.568.1">   |∎
  </span><strong class="bold"><span class="koboSpan" id="kobo.569.1">15.053 [26]</span></strong><span class="koboSpan" id="kobo.570.1">  |∎∎∎∎∎∎∎∎∎
</span><strong class="bold"><span class="koboSpan" id="kobo.571.1">  16.703 [22]</span></strong><span class="koboSpan" id="kobo.572.1">  |∎∎∎∎∎∎∎∎
Latency distribution:
  10 % in 0.33 ms
  25 % in 0.78 ms
  50 % in 1.75 ms
  </span><strong class="bold"><span class="koboSpan" id="kobo.573.1">75 % in 2.39 ms</span></strong><span class="koboSpan" id="kobo.574.1">
  90 % in 15.12 ms
  95 % in 15.31 ms
  99 % in 16.48 ms
Status code distribution:
  [OK]   </span><strong class="bold"><span class="koboSpan" id="kobo.575.1">200 responses</span></strong></pre>
<p><span class="koboSpan" id="kobo.576.1">There is a lot</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.577.1"> to say and to look at in this summary. </span><span class="koboSpan" id="kobo.577.2">However, let us focus on some interesting points. </span><span class="koboSpan" id="kobo.577.3">The first one is the number of requests made. </span><span class="koboSpan" id="kobo.577.4">We can see that we made 200 of them in this test. </span><span class="koboSpan" id="kobo.577.5">This is the default number of requests. </span><span class="koboSpan" id="kobo.577.6">We can change that by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">--total</span></strong><span class="koboSpan" id="kobo.579.1"> option a</span><a id="_idTextAnchor892"/><span class="koboSpan" id="kobo.580.1">nd setting another number (</span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">e.g., 500).</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">Then, in the response time histogram, we can see that 111 out of 200 requests were executed in ~2.29 ms. </span><span class="koboSpan" id="kobo.582.2">Another interesting thing to see here is that we have some commands (50) running in more than 13 ms. </span><span class="koboSpan" id="kobo.582.3">If we were in production, we might wa</span><a id="_idTextAnchor893"/><span class="koboSpan" id="kobo.583.1">nt to dig deeper into this in order to find the cause of these “high” execution times. </span><span class="koboSpan" id="kobo.583.2">This depends a lot on the use case and requirem</span><a id="_idTextAnchor894"/><span class="koboSpan" id="kobo.584.1">ents. </span><span class="koboSpan" id="kobo.584.2">In our case, this is almost certainly due to the inefficient “database” that we use, or more precisely, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">append</span></strong><span class="koboSpan" id="kobo.586.1"> that we repeatedly call </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">inMemoryDb.addTask</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.590.1">After that, we have the distribution of our execution time. </span><span class="koboSpan" id="kobo.590.2">We can see that 75% of our requests execute in under 2.39 ms. </span><span class="koboSpan" id="kobo.590.3">In fact, this is a similar information as presented previously. </span><span class="koboSpan" id="kobo.590.4">If we take the number of requests under 3.504 ms, add them up, and calculate the percentage, we get (1 + 111 + 38) * 100 / 200 = </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">75%.</span></span></p>
<p><span class="koboSpan" id="kobo.592.1">Then, we have the status code distribution. </span><span class="koboSpan" id="kobo.592.2">In our case, all 200 requests succeeded. </span><span class="koboSpan" id="kobo.592.3">However, in a production scenario, you might have something that looks more like this (from the </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">ghz documentation):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.594.1">
Status code distribution:
  [Unavailable] 3 responses
  [PermissionDenied] 3 responses
  [OK] 186 responses
  [Internal] 8 responses</span></pre>
<p><span class="koboSpan" id="kobo.595.1">Finally, one last</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.596.1"> thing that we cannot see here (because we do not have any) is the error distribution. </span><span class="koboSpan" id="kobo.596.2">This is the distribution of the error messages. </span><span class="koboSpan" id="kobo.596.3">Once again, in production, you might have something like the following (from the </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">ghz documentation):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
Error distribution:
[8] rpc error: code = Internal desc = Internal error.
</span><span class="koboSpan" id="kobo.598.2">[3] rpc error: code = PermissionDenied desc = Permission
  denied.
</span><span class="koboSpan" id="kobo.598.3">[3] rpc error: code = Unavailable desc = Service unavailable.</span></pre>
<p><span class="koboSpan" id="kobo.599.1">There is obviously a lot more that we could do with this tool. </span><span class="koboSpan" id="kobo.599.2">As mentioned, it is highly configurable, and it is even possible to link the results in Grafana (</span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">https://ghz.sh/docs/extras</span></strong><span class="koboSpan" id="kobo.601.1">) for visualization. </span><span class="koboSpan" id="kobo.601.2">However, this is out of the scope of this book. </span><span class="koboSpan" id="kobo.601.3">I will leave it up to you to try the different options and call ghz on our other API endpoints to see how </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">they perform.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">To conclude, we saw how can load test our service with ghz. </span><span class="koboSpan" id="kobo.603.2">We only saw how to use it for our unary API, but it is also useful for testing all the other streaming APIs. </span><span class="koboSpan" id="kobo.603.3">After executing the ghz command, we saw that we can get information about latency, error codes, error message distribution, and the fastest and slowest running times. </span><span class="koboSpan" id="kobo.603.4">All of this is useful, but it is important to understand that it can be even more powerful when linked with visualization tools such </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">as Grafana.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor895"/><span class="koboSpan" id="kobo.605.1">Debugging</span></h1>
<p><span class="koboSpan" id="kobo.606.1">No matter </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.607.1">how well we unit test our services, we are humans and humans make mistakes. </span><span class="koboSpan" id="kobo.607.2">At some point, we are going to need to debug a service. </span><span class="koboSpan" id="kobo.607.3">In this section, we are going to see how to approach debugging. </span><span class="koboSpan" id="kobo.607.4">We are first going to</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.608.1"> enable server reflection, which will let us call our service simply from the command line. </span><span class="koboSpan" id="kobo.608.2">After that, we will use Wireshark to inspect data on the wire. </span><span class="koboSpan" id="kobo.608.3">Finally, because the error might not always come directly from our</span><a id="_idTextAnchor896"/><span class="koboSpan" id="kobo.609.1"> code, we will see how we can take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">gRPC logs.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor897"/><span class="koboSpan" id="kobo.611.1">Server reflection</span></h2>
<p><span class="koboSpan" id="kobo.612.1">Server reflection</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.613.1"> is an interesting </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.614.1">feature when it comes to exposing the API to external clients. </span><span class="koboSpan" id="kobo.614.2">This is because it lets the server describe itself. </span><span class="koboSpan" id="kobo.614.3">In other words, the server knows all the services registered a</span><a id="_idTextAnchor898"/><span class="koboSpan" id="kobo.615.1">nd the message definition. </span><span class="koboSpan" id="kobo.615.2">If a client asks for more information, the server, through reflection, can list all the services, messages, and so on. </span><span class="koboSpan" id="kobo.615.3">With that, the client does not even need to have a copy of the proto file. </span><span class="koboSpan" id="kobo.615.4">Now, this is not only useful for exposing the API to external clients. </span><span class="koboSpan" id="kobo.615.5">It is also useful for manual testing/debugging. </span><span class="koboSpan" id="kobo.615.6">It lets developers/testers focus only on debugging the API and not getting the whole environment to work (copy the proto files, and </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">so on).</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">Enabling</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.618.1"> server reflection is an easy thing in gRPC Go. </span><span class="koboSpan" id="kobo.618.2">We only need two lines of code: an </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">import</span></strong><span class="koboSpan" id="kobo.620.1"> statement and a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">reflection.Register</span></strong><span class="koboSpan" id="kobo.622.1"> function to register the reflection service on our server. </span><span class="koboSpan" id="kobo.622.2">It looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">this (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">server/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
import (
  //...
</span><span class="koboSpan" id="kobo.626.2">  "google.golang.org/grpc/reflection"
)
func newGrpcServer(lis net.Listener, srvMetrics
  *grpcprom.ServerMetrics) (</span><a id="_idTextAnchor899"/><span class="koboSpan" id="kobo.627.1">*grpc.Server, error) {
  //...
</span><span class="koboSpan" id="kobo.627.2">  s := grpc.NewServer(opts...)
  pb.RegisterTodoServiceServer(/*…*/)
  </span><strong class="bold"><span class="koboSpan" id="kobo.628.1">reflection.Register(s)</span></strong><span class="koboSpan" id="kobo.629.1">
  return s, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.630.1">However, even</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.631.1"> though this is enough to expose information, we will need to get a client that contacts the server and understand the information it is getting. </span><span class="koboSpan" id="kobo.631.2">There are multiple such tools out there.</span><a href="https://github.com/fullstorydev/grpcurl"><span class="koboSpan" id="kobo.632.1"> The most popular one is </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">grpcurl</span></strong><span class="koboSpan" id="kobo.634.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">https</span></strong></a><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">://github.com/fullstorydev/grpcurl</span></strong><span class="koboSpan" id="kobo.637.1">). </span><span class="koboSpan" id="kobo.637.2">If yo</span><a id="_idTextAnchor900"/><span class="koboSpan" id="kobo.638.1">u are familiar with cURL, this is basically a similar tool, but one that understands the gRPC protocol. </span><span class="koboSpan" id="kobo.638.2">Even though we are going to use this tool to explore server reflection, know that it can also make other normal requests. </span><span class="koboSpan" id="kobo.638.3">If you are interested in such a tool, the repository’s README is full of examples of how to use it for </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">other tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">Let us try to create a simple command with </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">grpcurl</span></strong><span class="koboSpan" id="kobo.642.1"> first. </span><span class="koboSpan" id="kobo.642.2">We </span><a id="_idTextAnchor901"/><span class="koboSpan" id="kobo.643.1">are going to use options that are similar to the ones we used in ghz. </span><span class="koboSpan" id="kobo.643.2">We are going to use the CA certificate and override the domain name with </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">–cacert</span></strong><span class="koboSpan" id="kobo.645.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">-authority</span></strong><span class="koboSpan" id="kobo.647.1">. </span><span class="koboSpan" id="kobo.647.2">Then, we are going to add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">auth_token</span></strong><span class="koboSpan" id="kobo.649.1"> header for reflection with </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">-reflect-header</span></strong><span class="koboSpan" id="kobo.651.1">, and f</span><a id="_idTextAnchor902"/><span class="koboSpan" id="kobo.652.1">inally, we will use the list verb in order to list the services present on </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">the server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.654.1">$ grpcurl  -cacert ./certs/ca_cert.pem \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.655.1">           -authority "check.test.example.com" \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.656.1">           -reflect-header 'auth_token: authd' \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.657.1">           0.0.0.0:50051 list</span></strong></pre>
<p><span class="koboSpan" id="kobo.658.1">Once we run this command, we</span><a id="_idTextAnchor903"/><span class="koboSpan" id="kobo.659.1"> should get the </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
grpc.re</span><a id="_idTextAnchor904"/><span class="koboSpan" id="kobo.662.1">flection.v1alpha.ServerReflection
todo.v2.TodoService</span></pre>
<p><span class="koboSpan" id="kobo.663.1">We can see </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.664.1">that we have both our </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">TodoService</span></strong><span class="koboSpan" id="kobo.666.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">ServerReflection</span></strong><span class="koboSpan" id="kobo.668.1"> service that we registered earlier. </span><span class="koboSpan" id="kobo.668.2">With that, we can describe a service to get all the RPC endpoints it contains. </span><span class="koboSpan" id="kobo.668.3">We do that with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">describe</span></strong><span class="koboSpan" id="kobo.670.1"> verb followed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">service name:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.672.1">
$ grpcurl  -cacert ./certs/ca_cert.pem \
           -authority "check.test.example.com" \
           -reflect-header 'auth_token: authd' </span><a id="_idTextAnchor905"/><span class="koboSpan" id="kobo.673.1">\
           0.0.0.0:50051 </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">describe todo.v2.TodoService</span></strong></pre>
<p><span class="koboSpan" id="kobo.675.1">Running this command will s</span><a id="_idTextAnchor906"/><span class="koboSpan" id="kobo.676.1">how th</span><a id="_idTextAnchor907"/><span class="koboSpan" id="kobo.677.1">e definition of </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">the service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.679.1">
todo.v2.TodoService is a service:
s</span><a id="_idTextAnchor908"/><span class="koboSpan" id="kobo.680.1">ervice TodoService {
  rpc AddTask ( .todo.v2.AddTaskRequest ) returns (
    .todo.v2.Ad</span><a id="_idTextAnchor909"/><span class="koboSpan" id="kobo.681.1">dTaskResponse );</span><a id="_idTextAnchor910"/><span class="koboSpan" id="kobo.682.1">
  rpc DeleteTasks ( stream .todo.v2.DeleteTasksRequest )
    returns ( stream .todo.v2.DeleteTasksResponse );
  rpc ListTasks ( .todo.v2.ListTasksRequest ) returns (
    stream .todo.v2.ListTasksResponse );
  rpc UpdateTasks ( stream .todo.v2.UpdateTasksRequest )
    returns ( .todo.v2.Upd</span><a id="_idTextAnchor911"/><span class="koboSpan" id="kobo.683.1">ateTasksResponse );
}</span></pre>
<p><span class="koboSpan" id="kobo.684.1">We can also take a look at the message content by replacing the service’s name after </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">describe</span></strong><span class="koboSpan" id="kobo.686.1"> with the name message. </span><span class="koboSpan" id="kobo.686.2">An example for </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">AddTaskRequest</span></strong><span class="koboSpan" id="kobo.688.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.690.1">$ grpcurl -cacert ./certs/ca_cert.pem \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.691.1">          -authority "check.test.example.com" \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.692.1">          -reflect-header 'auth_token: authd' \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.693.1">          0.0.0.0:50051 describe todo.v2.AddTaskRequest</span></strong><span class="koboSpan" id="kobo.694.1">
todo.v2.AddTaskRequest is a message:
message AddTaskRequest {
  string description = 1 [(.validate.rules) = {
    string:&lt;min_len:1&gt; }];
  .google.protobuf.Timestamp due_date = 2
    [(.validate.rules) = { timestamp:&lt;gt_now:true&gt; }];
}</span></pre>
<p><span class="koboSpan" id="kobo.695.1">Now, as we</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.696.1"> are talking about debugging in this section, we want to be able to call these RPC endpoints and test them with different data. </span><span class="koboSpan" id="kobo.696.2">This is easy because we do not even need to have the proto file with us. </span><span class="koboSpan" id="kobo.696.3">The server reflection will help </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">grpcurl</span></strong><span class="koboSpan" id="kobo.698.1"> figure everything out for us. </span><span class="koboSpan" id="kobo.698.2">Let us call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">AddTask</span></strong><span class="koboSpan" id="kobo.700.1"> endpoint with an </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">invalid request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.702.1">
$ grpcurl -cacert ./certs/ca_cert.pem \
               -authority "check.test.example.com" \
               -rpc-header 'auth_token: authd' \
               -reflect-header 'auth_token: authd' \
               -d '' \
               -use-reflection \
               0.0.0.0:50051 todo.v2.TodoService.AddTask</span></pre>
<p><span class="koboSpan" id="kobo.703.1">Notice that we use other options here. </span><span class="koboSpan" id="kobo.703.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">-d</span></strong><span class="koboSpan" id="kobo.705.1"> option to set the data that we want to send as </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">AddTaskRequest</span></strong><span class="koboSpan" id="kobo.707.1">. </span><span class="koboSpan" id="kobo.707.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">–use-reflection</span></strong><span class="koboSpan" id="kobo.709.1"> option so that </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">grpcurl</span></strong><span class="koboSpan" id="kobo.711.1"> can verify that the data is valid (we are going to see that soon) and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">–rpc-header</span></strong><span class="koboSpan" id="kobo.713.1"> on top of </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">–reflect-header</span></strong><span class="koboSpan" id="kobo.715.1"> because </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">–reflect-header</span></strong><span class="koboSpan" id="kobo.717.1"> only sends the header to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">ServerReflection</span></strong><span class="koboSpan" id="kobo.719.1"> service, and we also need to send the header </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">TodoService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">As expected, the previous command returns the </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">following error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.725.1">
ERROR:
  Code: Unknown
  Message: invalid AddTaskRequest.Description: </span><strong class="bold"><span class="koboSpan" id="kobo.726.1">v</span><a id="_idTextAnchor912"/><span class="koboSpan" id="kobo.727.1">alue length</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.728.1">    must be at least 1 runes</span></strong></pre>
<p><span class="koboSpan" id="kobo.729.1">Now, as</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.730.1"> mentioned, grpcurl does not let us execute commands without adding guardrails. </span><span class="koboSpan" id="kobo.730.2">The use of reflection is useful here because it does not let us send data that cannot be deserialized in the request message. </span><span class="koboSpan" id="kobo.730.3">An example is </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.732.1">$ grpcurl #... </span><span class="koboSpan" id="kobo.732.2">\</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.733.1">               -d '{"notexisting": true}' \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.734.1">               0.0.0.0:50051 todo.v2.TodoService.AddTask</span></strong><span class="koboSpan" id="kobo.735.1">
Error invoking method "todo.v2.TodoService.AddTask": error</span><a id="_idTextAnchor913"/><span class="koboSpan" id="kobo.736.1">
gett</span><a id="_idTextAnchor914"/><span class="koboSpan" id="kobo.737.1">ing request data: message type todo.v2.AddTaskRequest
has </span><strong class="bold"><span class="koboSpan" id="kobo.738.1">no known field named notexisting</span></strong></pre>
<p><span class="koboSpan" id="kobo.739.1">Finally, as we also have a non-unary RPC endpoint that we would want to test, we can use an interactive terminal. </span><span class="koboSpan" id="kobo.739.2">This will let us send and receive multiple messages. </span><span class="koboSpan" id="kobo.739.3">To do that, we will set the data to </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">@</span></strong><span class="koboSpan" id="kobo.741.1"> and end the command with </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">&lt;&lt;EOF</span></strong><span class="koboSpan" id="kobo.743.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">EOF</span></strong><span class="koboSpan" id="kobo.745.1"> stands for end of file (you can use any suffix really). </span><span class="koboSpan" id="kobo.745.2">This will let us type data interactively, and when we are finished, we write </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">EOF</span></strong><span class="koboSpan" id="kobo.747.1"> to let </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">grpcurl know.</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">Let us start by adding two new tasks to </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">our server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.751.1">$ grpcurl #… \</span></strong><span class="koboSpan" id="kobo.752.1">
          -d '{"description": "a task!"}' \
          0.0.0.0:50051 todo.v2.TodoService.AddTask
</span><strong class="bold"><span class="koboSpan" id="kobo.753.1">$ grpcurl #…</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.754.1">\</span></strong><span class="koboSpan" id="kobo.755.1">
          -d '{"description": "another ta</span><a id="_idTextAnchor915"/><span class="koboSpan" id="kobo.756.1">sk!"}'</span><a id="_idTextAnchor916"/><span class="koboSpan" id="kobo.757.1"> \
          0.0.0.0:50051 todo.v2.TodoService.AddTask</span></pre>
<p><span class="koboSpan" id="kobo.758.1">Then, we</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.759.1"> can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">ListTasks</span></strong><span class="koboSpan" id="kobo.761.1"> to show </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">the tasks:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.763.1">$ grpcurl #... </span><span class="koboSpan" id="kobo.763.2">\</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.764.1">               -d '' \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.765.1">               0.0.0.0:50051 todo.v2.TodoService.ListTasks</span></strong><span class="koboSpan" id="kobo.766.1">
{
  "task": {
    "id": "1",
    "description": "a task!",
    "dueDate": "1970-01-01T00:00:00Z"
  },
  "overdue": true
}
{
  "task": {
    "id": "2",
    "description": "another task!",
    "dueDate": "1970-01-01T00:00:00Z"
  },
  "overdue": true
}</span></pre>
<p><span class="koboSpan" id="kobo.767.1">Can you spot any bugs here? </span><span class="koboSpan" id="kobo.767.2">If not, do not worry; we are going to come back to </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">it shortly.</span></span></p>
<p><span class="koboSpan" id="kobo.769.1">Then, to</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.770.1"> call our client streaming API (</span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">UpdateTasks</span></strong><span class="koboSpan" id="kobo.772.1">), we can use the following command on Linux/Mac (press </span><em class="italic"><span class="koboSpan" id="kobo.773.1">Enter</span></em><span class="koboSpan" id="kobo.774.1"> after the </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">last </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">EOF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.778.1">
$ grpcurl #… \
          -d @ \
          0.0.0.0:50051</span><a id="_idTextAnchor917"/><span class="koboSpan" id="kobo.779.1"> todo.v2.TodoService.UpdateTasks </span><strong class="bold"><span class="koboSpan" id="kobo.780.1">&lt;&lt;EOF</span></strong><span class="koboSpan" id="kobo.781.1">
{ </span><a id="_idTextAnchor918"/><span class="koboSpan" id="kobo.782.1">"id"</span><a id="_idTextAnchor919"/><span class="koboSpan" id="kobo.783.1">: 1, "description": "a better task!" </span><span class="koboSpan" id="kobo.783.2">}
{ "id": </span><a id="_idTextAnchor920"/><span class="koboSpan" id="kobo.784.1">2, "description": "another better task!" </span><span class="koboSpan" id="kobo.784.2">}
</span><strong class="bold"><span class="koboSpan" id="kobo.785.1">EOF</span></strong></pre>
<p><span class="koboSpan" id="kobo.786.1">Windows (PowerShell) users should use </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.788.1">
$ $Messages = @"
{ "id": 1, "description": "new description" }
{ "id": 2, "description": "new description" }
"@
$ grpcurl #… \
          -d $Messages \
           0.0.0.0:50051 todo.v2.TodoService.UpdateTasks</span></pre>
<p><span class="koboSpan" id="kobo.789.1">After that, another call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">ListTasks</span></strong><span class="koboSpan" id="kobo.791.1"> should show the data with the </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">new descriptions.</span></span></p>
<p><span class="koboSpan" id="kobo.793.1">Now, while executing these functions, you might have noticed a bug. </span><span class="koboSpan" id="kobo.793.2">If you did not, there is nothing to worry about; we are going to solve the problem together. </span><span class="koboSpan" id="kobo.793.3">The problem is that we can send an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">DueDate</span></strong><span class="koboSpan" id="kobo.795.1">, which then gets transformed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">0</span></strong><span class="koboSpan" id="kobo.797.1"> value in Unix Time (</span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">1970-01-01</span></strong><span class="koboSpan" id="kobo.799.1">). </span><span class="koboSpan" id="kobo.799.2">This bug comes from the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">protoc-gen-validate</span></strong><span class="koboSpan" id="kobo.801.1"> checks </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">DueDate</span></strong><span class="koboSpan" id="kobo.803.1"> only if it </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">is set.</span></span></p>
<p><span class="koboSpan" id="kobo.805.1">To solve</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.806.1"> that, we can add another validation rule for </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">due_date</span></strong><span class="koboSpan" id="kobo.808.1"> to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">todo.proto</span></strong><span class="koboSpan" id="kobo.810.1"> file. </span><span class="koboSpan" id="kobo.810.2">This rule is </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">required</span></strong><span class="koboSpan" id="kobo.812.1">. </span><span class="koboSpan" id="kobo.812.2">It will make it impossible for the field to not be set. </span><span class="koboSpan" id="kobo.812.3">You might argue that a task does not need a due date, but we could make a different endpoint for </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">Adding Notes</span></strong><span class="koboSpan" id="kobo.814.1"> and say that </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">Tasks</span></strong><span class="koboSpan" id="kobo.816.1"> should have a due date, but </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">Note</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">due_date</span></strong><span class="koboSpan" id="kobo.821.1"> will now be defined </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">as such:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.823.1">
google.protobuf.Timestamp due_date = 2 [
  (validate.rules).timestamp.gt_now = true,
  (validate.rules).timestamp.required = true
];</span></pre>
<p><span class="koboSpan" id="kobo.824.1">We can rerun the generation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">validate</span></strong><span class="koboSpan" id="kobo.826.1"> plugin (</span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">chapter9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.830.1">
$ protoc -Iproto --validate_out="lang=go,
paths=source_relative:proto" proto/todo/v2/*.proto</span></pre>
<p><span class="koboSpan" id="kobo.831.1">Then, we shu</span><a id="_idTextAnchor921"/><span class="koboSpan" id="kobo.832.1">t our server down and </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">relaunch it:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.834.1">$ go run ./server 0.0.0.0:50051 0.0.0.0:50052</span></strong><span class="koboSpan" id="kobo.835.1">
metrics server listening at 0.0.0.0:50052
gRPC server listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.836.1">If we rerun one of the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">AddTask</span></strong><span class="koboSpan" id="kobo.838.1"> commands, it </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">should fail:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.840.1">$ grpcurl #… \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.841.1">          -d '{"description": "a task!</span><a id="_idTextAnchor922"/><span class="koboSpan" id="kobo.842.1">"}' </span></strong><strong class="bold"><span class="koboSpan" id="kobo.843.1">\</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.844.1">          0.0.0.0:50051 todo.v2.TodoService.AddTask</span></strong><span class="koboSpan" id="kobo.845.1">
ERROR:
  Code: Unknown
  Message: invalid AddTaskRequest.DueDate: value is
    required</span></pre>
<p><span class="koboSpan" id="kobo.846.1">We solved a bug! </span><span class="koboSpan" id="kobo.846.2">How great </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">is that?</span></span></p>
<p><span class="koboSpan" id="kobo.848.1">If you want</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.849.1"> to now send a request with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">due_data</span></strong><span class="koboSpan" id="kobo.851.1"> value you will have to specify a date in </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">RFC3339</span></strong><span class="koboSpan" id="kobo.853.1"> format as a string. </span><span class="koboSpan" id="kobo.853.2">An example using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">due_date</span></strong><span class="koboSpan" id="kobo.855.1"> value of 500 years from the day of writing this is </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.857.1">$ </span></strong><span class="koboSpan" id="kobo.858.1">ghz #… \
    -d '{"description":"task", "due_date": "</span><strong class="bold"><span class="koboSpan" id="kobo.859.1">2523-06-01T14</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.860.1">    :</span><a id="_idTextAnchor923"/><span class="koboSpan" id="kobo.861.1">18:25+00:00</span></strong><span class="koboSpan" id="kobo.862.1">"}' \
    0.0.0.0:50051</span></pre>
<h3><span class="koboSpan" id="kobo.863.1">Bazel</span></h3>
<p><span class="koboSpan" id="kobo.864.1">In order to run</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.865.1"> the server </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.866.1">with Bazel, you will have to update the dependencies. </span><span class="koboSpan" id="kobo.866.2">You can run Gazelle to </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">update </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">//server:server</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.870.1">
$ bazel run //:gazelle</span></pre>
<p><span class="koboSpan" id="kobo.871.1">Then, you will be able to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">server normally:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.873.1">
$ bazel run //server:server 0.0.0.0:50051 0.0.0.0:50052</span></pre>
<p><span class="koboSpan" id="kobo.874.1">To conclude, we</span><a id="_idTextAnchor924"/><span class="koboSpan" id="kobo.875.1"> saw that we can turn server reflection on in order to get information and interact with a server for debugging purposes. </span><span class="koboSpan" id="kobo.875.2">We saw that we can list services and describe both services and messages. </span><span class="koboSpan" id="kobo.875.3">We also saw that we can call unary RPC endpoints, and finally, we saw that we can also call streaming APIs with </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">interactive terminals.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor925"/><span class="koboSpan" id="kobo.877.1">Using Wireshark</span></h2>
<p><span class="koboSpan" id="kobo.878.1">Sometimes, we</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.879.1"> need to be able to inspect the data that is going through the wire. </span><span class="koboSpan" id="kobo.879.2">This lets us get a sense of how heavy the</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.880.1"> payloads are, know if we execute too many requests, and so on. </span><span class="koboSpan" id="kobo.880.2">In this section, we are going to see how we can use Wireshark to analyze payload</span><a id="_idTextAnchor926"/><span class="koboSpan" id="kobo.881.1">s </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">and requests.</span></span></p>
<p><span class="koboSpan" id="kobo.883.1">The first thing that we need in order to get access to readable information is to disable the encryption via TLS that we enabled in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">Chapter 7</span></strong></span><span class="koboSpan" id="kobo.885.1">. </span><span class="koboSpan" id="kobo.885.2">Note that this should be fine because we are in development mode, but you will need to make sure that encryption is on when you push back </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.887.1">To disable the encryption, we are going to create a switch variable. </span><span class="koboSpan" id="kobo.887.2">With this variable, the TLS will be disabled by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">ENABLE_TLS</span></strong><span class="koboSpan" id="kobo.889.1"> environment variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">false</span></strong><span class="koboSpan" id="kobo.891.1">. </span><span class="koboSpan" id="kobo.891.2">Obviously, as we want to make TLS the default, we are going to check whether the environment variable value is different from </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">false</span></strong><span class="koboSpan" id="kobo.893.1">, so that if there is a typo in the value or the value is not set, TLS will </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">be enabled.</span></span></p>
<p><span class="koboSpan" id="kobo.895.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">server/main.go</span></strong><span class="koboSpan" id="kobo.897.1">, we can have </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.899.1">
func newGrpcServer(lis net.Listener, srvMetrics
  *grpcprom.ServerMetrics) (*grpc.Server, error) {
  var credsOpt grpc.Serve</span><a id="_idTextAnchor927"/><span class="koboSpan" id="kobo.900.1">rOption
  enableTls := </span><strong class="bold"><span class="koboSpan" id="kobo.901.1">os.Getenv("ENABLE_TL</span><a id="_idTextAnchor928"/><span class="koboSpan" id="kobo.902.1">S") != "false"</span></strong><span class="koboSpan" id="kobo.903.1">
  if enableTls {
    creds, err := credentials.NewServerTLSFromFile(
      "./certs/server</span><a id="_idTextAnchor929"/><span class="koboSpan" id="kobo.904.1">_cert.p</span><a id="_idTextAnchor930"/><span class="koboSpan" id="kobo.905.1">em", "./certs/server_key.pem")
    if err != nil {
      return nil, err
    }
  </span><a id="_idTextAnchor931"/><span class="koboSpan" id="kobo.906.1">  </span><strong class="bold"><span class="koboSpan" id="kobo.907.1">credsOpt = grpc.Creds(creds)</span></strong><span class="koboSpan" id="kobo.908.1">
  }
  //...
</span><span class="koboSpan" id="kobo.908.2">  opts :=</span><a id="_idTextAnchor932"/><span class="koboSpan" id="kobo.909.1"> []grpc.ServerOpt</span><a id="_idTextAnchor933"/><span class="koboSpan" id="kobo.910.1">ion{/*…*/}
  if credsOpt != nil {
    opts = append(opts, credsOpt)
  }
  //...
</span><span class="koboSpan" id="kobo.910.2">}</span></pre>
<p><span class="koboSpan" id="kobo.911.1">We </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.912.1">now</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.913.1"> need to do something simi</span><a id="_idTextAnchor934"/><span class="koboSpan" id="kobo.914.1">lar on the client </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">side (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">client/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.918.1">
func main() {
  //...
</span><span class="koboSpan" id="kobo.918.2">  var credsOpt grpc.DialOption
  enableTls := </span><strong class="bold"><span class="koboSpan" id="kobo.919.1">os.Getenv("ENABLE</span><a id="_idTextAnchor935"/><span class="koboSpan" id="kobo.920.1">_TLS") != "false"</span></strong><span class="koboSpan" id="kobo.921.1">
  if enableTls {
    creds, err := credentials.NewClientTLSFromFile
      ("./ce</span><a id="_idTextAnchor936"/><span class="koboSpan" id="kobo.922.1">rts/ca_</span><a id="_idTextAnchor937"/><span class="koboSpan" id="kobo.923.1">cert.pem", "x.test.example.com")
    if err != nil {
      log.Fatalf("failed to load credentials: %v", err)
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.924.1">credsOpt = grpc.WithTransportCredentials(creds)</span></strong><span class="koboSpan" id="kobo.925.1">
  } else {
    </span><strong class="bold"><span class="koboSpan" id="kobo.926.1">credsOpt = grpc.WithTransportCredentials</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.927.1">      (insecure.NewCredentials())</span></strong><span class="koboSpan" id="kobo.928.1">
  }
  //...
</span><span class="koboSpan" id="kobo.928.2">  opts := []grpc.DialOption{
    credsOpt,
    //...
</span><span class="koboSpan" id="kobo.928.3">  }
  //...
</span><span class="koboSpan" id="kobo.928.4">}</span></pre>
<p><span class="koboSpan" id="kobo.929.1">With that, we </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.930.1">can now enable/disable TLS easily. </span><span class="koboSpan" id="kobo.930.2">To run the server on Linux or Mac and without TLS, we c</span><a id="_idTextAnchor938"/><span class="koboSpan" id="kobo.931.1">an now run </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">the</span></span><span class="No-Break"><a id="_idIndexMarker504"/></span><span class="No-Break"><span class="koboSpan" id="kobo.933.1"> following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.934.1">$ ENABLE_TLS=false go run ./server 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.935.1">
0.0.0.0:50052</span></pre>
<p><span class="koboSpan" id="kobo.936.1">For Windows (PowerShell), we can </span><a id="_idTextAnchor939"/><span class="koboSpan" id="kobo.937.1">run </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.939.1">$ $env:ENABLE_TLS='false'; go run ./server 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.940.1">
0.0.0.0:50052; $env:ENABLE_TLS=$null</span></pre>
<p><span class="koboSpan" id="kobo.941.1">Similarly, for the client, we can run </span><a id="_idTextAnchor940"/><span class="koboSpan" id="kobo.942.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">following (Linux/Mac):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.944.1">
$ ENABLE_TLS=false go run ./client 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.945.1">For Windows (PowerShell), we can </span><a id="_idTextAnchor941"/><span class="koboSpan" id="kobo.946.1">run </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.948.1">
$ $env:ENABLE_TLS='false'; go run ./client 0.0.0.0:50051;
$env:ENABLE_TLS=$null</span></pre>
<p><span class="koboSpan" id="kobo.949.1">We are now ready to start inspecting the data sent over the wire. </span><span class="koboSpan" id="kobo.949.2">In Wireshark, we will first check the network interface on which we want to intercept </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">the payloads:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.951.1"><img alt="Figure 9.1 – ﻿Selecting the network interface" src="image/B19664_09_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.952.1">Figure 9.1 – Selecting the network interface</span></p>
<p><span class="koboSpan" id="kobo.953.1">The</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.954.1"> loopback </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.955.1">interface is the one that we are working on: localhost. </span><span class="koboSpan" id="kobo.955.2">By double-clicking on it, we will enter the recording interface. </span><span class="koboSpan" id="kobo.955.3">But before doing that, we want to tell Wireshark where to find our proto files. </span><span class="koboSpan" id="kobo.955.4">Without them, it will show you only the field tags and the value. </span><span class="koboSpan" id="kobo.955.5">It would be better if we could ha</span><a id="_idTextAnchor942"/><span class="koboSpan" id="kobo.956.1">ve the field </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">names too.</span></span></p>
<p><span class="koboSpan" id="kobo.958.1">To do that, we will go to </span><strong class="bold"><span class="koboSpan" id="kobo.959.1">Settings</span></strong><span class="koboSpan" id="kobo.960.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">Preferences</span></strong><span class="koboSpan" id="kobo.962.1"> for Mac) | </span><strong class="bold"><span class="koboSpan" id="kobo.963.1">Protocols</span></strong><span class="koboSpan" id="kobo.964.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.965.1">Protobuf</span></strong><span class="koboSpan" id="kobo.966.1">, and select a path for the Protobuf search. </span><span class="koboSpan" id="kobo.966.2">In our case, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">chapter9/proto</span></strong><span class="koboSpan" id="kobo.968.1"> folder and the folder needed to access the Well-Known Types. </span><span class="koboSpan" id="kobo.968.2">The last path depends on how you installed </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">protoc</span></strong><span class="koboSpan" id="kobo.970.1">. </span><span class="koboSpan" id="kobo.970.2">Here are the most </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">common paths:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.972.1">If installed through GitHub releases and you moved the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">include</span></strong><span class="koboSpan" id="kobo.974.1"> folder to </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">/usr/local</span></strong><span class="koboSpan" id="kobo.976.1">, then the second path </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">/usr/local/include</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.980.1">If installed through </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">brew</span></strong><span class="koboSpan" id="kobo.982.1">, you should be able to get the path on which protobuf is installed with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">brew --prefix protobuf</span></strong><span class="koboSpan" id="kobo.984.1"> command. </span><span class="koboSpan" id="kobo.984.2">This will give you a path; simply append </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">/include</span></strong><span class="koboSpan" id="kobo.986.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">the path.</span></span></li>
<li><span class="koboSpan" id="kobo.988.1">If installed</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.989.1"> through Chocolatey, you should run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">choco list --local-only --exact protoc --trace</span></strong><span class="koboSpan" id="kobo.991.1"> command. </span><span class="koboSpan" id="kobo.991.2">This will list a path finishing with </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">.files</span></strong><span class="koboSpan" id="kobo.993.1">. </span><span class="koboSpan" id="kobo.993.2">Open the path in a tool</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.994.1"> such as Notepad, find a path contain</span><a id="_idTextAnchor943"/><span class="koboSpan" id="kobo.995.1">ing </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">include/google/protobuf</span></strong><span class="koboSpan" id="kobo.997.1">, and select it up until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">include</span></strong><span class="koboSpan" id="kobo.999.1"> folder – for </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">example, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">C:\ProgramData\chocolatey\lib\protoc\tools\include</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">.</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.1003.1"><img alt="Figure 9.2 – ﻿Adding path to proto files" src="image/B19664_09_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1004.1">Figure 9.2 – Adding path to proto files</span></p>
<p><span class="koboSpan" id="kobo.1005.1">Once this is done, we can go back to our loopback interface and double-click on it. </span><span class="koboSpan" id="kobo.1005.2">We should now have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">recording interface.</span></span></p>
<p><span class="koboSpan" id="kobo.1007.1">We will then </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.1008.1">enter a filter to only show the requests on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">50051</span></strong><span class="koboSpan" id="kobo.1010.1"> and only the requests related to gRPC and Protobuf. </span><span class="koboSpan" id="kobo.1010.2">Make </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.1011.1">sure you click on the arrow just next to the filter area; otherwise, you will get all the requests made on </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">the interface.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.1013.1"><img alt="Figure 9.3 – Entering a filter" src="image/B19664_09_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1014.1">Figure 9.3 – Entering a filter</span></p>
<p><span class="koboSpan" id="kobo.1015.1">After that, we can go ahead and run the server and the client. </span><span class="koboSpan" id="kobo.1015.2">Once the client is done executing, you will have some logs appearing in Wireshark. </span><span class="koboSpan" id="kobo.1015.3">This should look like </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.1017.1"><img alt="Figure 9.4 – Logs appearing in Wireshark" src="image/B19664_09_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1018.1">Figure 9.4 – Logs appearing in Wireshark</span></p>
<p><span class="koboSpan" id="kobo.1019.1">We can now understand what was sent over the network. </span><span class="koboSpan" id="kobo.1019.2">If we are looking at the payloads, will should be looking at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">DATA (GRPC) (PROTOBUF)</span></strong><span class="koboSpan" id="kobo.1021.1"> frames. </span><span class="koboSpan" id="kobo.1021.2">An example is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">DATA</span></strong><span class="koboSpan" id="kobo.1023.1"> frame </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">AddTask</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1027.1">
Protocol Buffers: /todo.v2.TodoService/AddTask,request
    Message: </span><strong class="bold"><span class="koboSpan" id="kobo.1028.1">todo.v2.AddTaskRequest</span></strong><span class="koboSpan" id="kobo.1029.1">
        Field(1): </span><strong class="bold"><span class="koboSpan" id="kobo.1030.1">description</span></strong><span class="koboSpan" id="kobo.1031.1"> = This is another task
          (string)
        Field(2): </span><strong class="bold"><span class="koboSpan" id="kobo.1032.1">due_date</span></strong><span class="koboSpan" id="kobo.1033.1"> = 2023-06-01T17:06:20
          .531406+0800 (message)
            Message: </span><strong class="bold"><span class="koboSpan" id="kobo.1034.1">google.protobuf.Timestamp</span></strong><span class="koboSpan" id="kobo.1035.1">
                Field(1): </span><strong class="bold"><span class="koboSpan" id="kobo.1036.1">seconds</span></strong><span class="koboSpan" id="kobo.1037.1"> = 1685610380 (int64)
                Field(2): </span><strong class="bold"><span class="koboSpan" id="kobo.1038.1">nanos</span></strong><span class="koboSpan" id="kobo.1039.1"> = 531406000 (int32)
                [Message Value: 2023-06-01T17:06:
                  20.531406+0800]</span></pre>
<p><span class="koboSpan" id="kobo.1040.1">Finally, if we are looking at gRPC-related recordings, we can take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">HEADERS</span></strong><span class="koboSpan" id="kobo.1042.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">DATA (GRPC)</span></strong><span class="koboSpan" id="kobo.1044.1"> frame. </span><span class="koboSpan" id="kobo.1044.2">These can tell you when half-closes and trailers are sent and their size. </span><span class="koboSpan" id="kobo.1044.3">An </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.1045.1">example of a half-close</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.1046.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">ListTasks</span></strong><span class="koboSpan" id="kobo.1048.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1050.1">
HyperText Transfer Protocol 2
    Stream: </span><strong class="bold"><span class="koboSpan" id="kobo.1051.1">DATA</span></strong><span class="koboSpan" id="kobo.1052.1">, Stream ID: 7, Length 45
</span><strong class="bold"><span class="koboSpan" id="kobo.1053.1">        Length: 45</span></strong><span class="koboSpan" id="kobo.1054.1">
        Type: DATA (0)
        Flags: 0x00
            0000 .00. </span><span class="koboSpan" id="kobo.1054.2">= Unused: 0x00
            .... </span><span class="koboSpan" id="kobo.1054.3">0... </span><span class="koboSpan" id="kobo.1054.4">= Padded: False
            .... </span><span class="koboSpan" id="kobo.1054.5">...0 = </span><strong class="bold"><span class="koboSpan" id="kobo.1055.1">End Stream: False</span></strong><span class="koboSpan" id="kobo.1056.1">
        0... </span><span class="koboSpan" id="kobo.1056.2">.... </span><span class="koboSpan" id="kobo.1056.3">.... </span><span class="koboSpan" id="kobo.1056.4">.... </span><span class="koboSpan" id="kobo.1056.5">.... </span><span class="koboSpan" id="kobo.1056.6">.... </span><span class="koboSpan" id="kobo.1056.7">... </span><span class="koboSpan" id="kobo.1056.8">= Reserved: 0x0
        .000 0000 0000 0000 0000 0000 0000 0111 = Stream
          Identifier: 7
        [Pad Length: 0]
        DATA payload (45 bytes)</span></pre>
<p><span class="koboSpan" id="kobo.1057.1">An example trailer for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">DeleteTasks</span></strong><span class="koboSpan" id="kobo.1059.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1061.1">
HyperText Transfer Protocol 2
    Stream: </span><strong class="bold"><span class="koboSpan" id="kobo.1062.1">HEADERS</span></strong><span class="koboSpan" id="kobo.1063.1">, Stream ID: 13, Length 2
        Length: 2
        Type: HEADERS (1)
      </span><a id="_idTextAnchor944"/><span class="koboSpan" id="kobo.1064.1">  Flags: 0x05, </span><strong class="bold"><span class="koboSpan" id="kobo.1065.1">End Headers, End S</span><a id="_idTextAnchor945"/><span class="koboSpan" id="kobo.1066.1">tream</span></strong><span class="koboSpan" id="kobo.1067.1">
            00.0 ..0. </span><span class="koboSpan" id="kobo.1067.2">= Unused: 0x00
            ..0. </span><span class="koboSpan" id="kobo.1067.3">.... </span><span class="koboSpan" id="kobo.1067.4">= Priority: False
</span><a id="_idTextAnchor946"/><span class="koboSpan" id="kobo.1068.1">            .... </span><span class="koboSpan" id="kobo.1068.2">0... </span><span class="koboSpan" id="kobo.1068.3">= Padded: False
            .... </span><span class="koboSpan" id="kobo.1068.4">.1.. </span><span class="koboSpan" id="kobo.1068.5">= </span><strong class="bold"><span class="koboSpan" id="kobo.1069.1">End Headers: True</span></strong><span class="koboSpan" id="kobo.1070.1">
            .... </span><span class="koboSpan" id="kobo.1070.2">...1 = </span><strong class="bold"><span class="koboSpan" id="kobo.1071.1">End Stream: True</span></strong><span class="koboSpan" id="kobo.1072.1">
        0... </span><span class="koboSpan" id="kobo.1072.2">.... </span><span class="koboSpan" id="kobo.1072.3">.... </span><span class="koboSpan" id="kobo.1072.4">.... </span><span class="koboSpan" id="kobo.1072.5">.... </span><span class="koboSpan" id="kobo.1072.6">.. </span><span class="koboSpan" id="kobo.1072.7">.... </span><span class="koboSpan" id="kobo.1072.8">= Reserved: 0x0
        .000 0000 0000 0000 0000 0000 0000 1101 = Stream
           Identifier: 13
        [Pad Length: 0]
        Header Block Fragment: bfbe
        [</span><strong class="bold"><span class="koboSpan" id="kobo.1073.1">Header Length: 40</span></strong><span class="koboSpan" id="kobo.1074.1">]
        [Header Count: 2]
        Header: </span><strong class="bold"><span class="koboSpan" id="kobo.1075.1">grpc-status: 0</span></strong><span class="koboSpan" id="kobo.1076.1">
        Header: </span><strong class="bold"><span class="koboSpan" id="kobo.1077.1">grpc-message</span></strong><span class="koboSpan" id="kobo.1078.1">:</span></pre>
<p><span class="koboSpan" id="kobo.1079.1">For the sake </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.1080.1">of keeping this book readable, we will have to end this section here. </span><span class="koboSpan" id="kobo.1080.2">However, there is a lot more to look at</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.1081.1"> and discover. </span><span class="koboSpan" id="kobo.1081.2">We saw that we can use Wireshark to intercept messages over the wire. </span><span class="koboSpan" id="kobo.1081.3">We made a switch variable to be able to disable TLS temporarily to not read encrypted data. </span><span class="koboSpan" id="kobo.1081.4">We loaded protobuf messages into Wireshark to let it know how to deserialize messages. </span><span class="koboSpan" id="kobo.1081.5">Finally, we saw that we can look at messages, as well as lower-level parts of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">HTTP2 protocol.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor947"/><span class="koboSpan" id="kobo.1083.1">Turning gRPC logs on</span></h2>
<p><span class="koboSpan" id="kobo.1084.1">Finally, if you </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.1085.1">are ready to go to an even lower level than Wireshark to debug gRPC applications, gRPC provides two important environment variables to get logs from </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">the framework.</span></span></p>
<p><span class="koboSpan" id="kobo.1087.1">The first environment variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">GRPC_GO_LOG_SEVERITY_LEVEL</span></strong><span class="koboSpan" id="kobo.1089.1">. </span><span class="koboSpan" id="kobo.1089.2">It will give you the logs written by gRPC depending on certain severity levels (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">debug</span></strong><span class="koboSpan" id="kobo.1091.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">info</span></strong><span class="koboSpan" id="kobo.1093.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">error</span></strong><span class="koboSpan" id="kobo.1095.1">). </span><span class="koboSpan" id="kobo.1095.2">To enable this, you can simply execute your binary or Go command with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">GRPC_GO_LOG_SEVERITY_LEVEL</span></strong><span class="koboSpan" id="kobo.1097.1"> set in front of it. </span><span class="koboSpan" id="kobo.1097.2">We did something similar with our custom </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">ENABLE_TLS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1"> variable.</span></span></p>
<p><span class="koboSpan" id="kobo.1100.1">An example of running </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">GRPC_GO_LOG_SEVERITY_LEVEL</span></strong><span class="koboSpan" id="kobo.1102.1"> set with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">info</span></strong><span class="koboSpan" id="kobo.1104.1"> while spinning up the server and closing it is as follows (</span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">for Linux/Mac):</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1106.1">$ GRPC_GO_LOG_SEVERITY_LEVEL=info go run ./server</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1107.1">  0.0.0.0:50051 0.0.0.0:50052</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1108.1">INFO: [core] [Server #1] Server created</span></strong><span class="koboSpan" id="kobo.1109.1">
metrics server listening at 0.0.0.0:50052
gRPC server listening at 0.0.0.0:50051
</span><strong class="bold"><span class="koboSpan" id="kobo.1110.1">INFO: [core] [Server #1 ListenSocket #2] ListenSocket</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1111.1">created</span></strong><span class="koboSpan" id="kobo.1112.1">
shutting down servers, please wait...
</span><strong class="bold"><span class="koboSpan" id="kobo.1113.1">INFO: [core] [Server #1 ListenSocket #2] ListenSocket</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1114.1">deleted</span></strong><span class="koboSpan" id="kobo.1115.1">
gRPC server shutdown
metrics server shutdown</span></pre>
<p><span class="koboSpan" id="kobo.1116.1">For Windows (PowerShell), we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">th</span><a id="_idTextAnchor948"/><span class="koboSpan" id="kobo.1118.1">e following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1119.1">
$ $env:GRPC_GO_LOG_SEVERITY_LEVEL='info'; go run ./server
  0.0.0.0:50051 0.0.0.0:50052;
  $env:GRPC_GO_LOG_SEVERITY_LEVEL=$null</span></pre>
<p><span class="koboSpan" id="kobo.1120.1">On top of the severity level, you can also set the verbosity of those logs with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">GRPC_GO_LOG_VERBOSITY_LEVEL</span></strong><span class="koboSpan" id="kobo.1122.1">, which takes a number between 2 and 99, where the </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.1123.1">bigger the number, the more verbose it will be. </span><span class="koboSpan" id="kobo.1123.2">This will not be in a short-term runtime like the one we have right now. </span><span class="koboSpan" id="kobo.1123.3">This will be more useful on long-term runs, which we normally have for servers. </span><span class="koboSpan" id="kobo.1123.4">To enable it, we add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">GRPC_GO_LOG_VERBOSITY_LEVEL</span></strong><span class="koboSpan" id="kobo.1125.1"> just after </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">GRPC_GO_LOG_SEVERITY_LEVEL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1128.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1129.1">
$ GRPC_GO_LO</span><a id="_idTextAnchor949"/><span class="koboSpan" id="kobo.1130.1">G_SEVERITY_LEVEL=info GRPC_GO_LOG
  _VERBOSITY_LEVEL=99 go run ./server 0.0.0.0:50051
    0.0.0.0:50052</span></pre>
<p><span class="koboSpan" id="kobo.1131.1">Finally, I know that I said there are two important environment variables but there is another that deserves a mention. </span><span class="koboSpan" id="kobo.1131.2">This one is important if you are planning to parse logs. </span><span class="koboSpan" id="kobo.1131.3">You can set the formatter for the logs. </span><span class="koboSpan" id="kobo.1131.4">As of right now, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1133.1">
INFO: [core] [Server #1] Server created</span></pre>
<p><span class="koboSpan" id="kobo.1134.1">But we can set the formatter to JSON in order to get </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1136.1">
{"message":"[core] [Server #1] Server created\n",
  "severity":"INFO"}</span></pre>
<p><span class="koboSpan" id="kobo.1137.1">You will now be able to deserialize the JSON and implement all the kinds of tools you need to monitor and </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">report errors.</span></span></p>
<p><span class="koboSpan" id="kobo.1139.1">To conclude, in this brief section, we saw that we can get information for code that we do not write: the gRPC framework. </span><span class="koboSpan" id="kobo.1139.2">I am aware that the examples presented in this section are superfici</span><a id="_idTextAnchor950"/><span class="koboSpan" id="kobo.1140.1">al, but generally, these flags are set when something goes really wrong or if you are involved in the development of gRPC Go itself. </span><span class="koboSpan" id="kobo.1140.2">I still think it is important to know about their existence and I encourage you to try getting more interesting messages out </span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.1142.1">There are as many ways to debug as there are requirements and settings. </span><span class="koboSpan" id="kobo.1142.2">As such, we cannot cover everything here, but at least you have the basic skills and tools to get started with hacking. </span><span class="koboSpan" id="kobo.1142.3">In this section, we saw that we can enable server reflection to get information from the server and interact with it with grpcurl. </span><span class="koboSpan" id="kobo.1142.4">We also saw that we can intercept messages with Wireshark to get a sense of the requests made and their size. </span><span class="koboSpan" id="kobo.1142.5">Finally, we saw that we can turn on a certain flag to get logs from gRPC. </span><span class="koboSpan" id="kobo.1142.6">Before going on to the next section, I </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.1143.1">wanted to mention that there is another tool that you might find useful and that we did not cover here. </span><span class="koboSpan" id="kobo.1143.2">This tool is called Channelz (</span><a href="https://grpc.io/blog/a-short-introduction-to-channelz/"><span class="koboSpan" id="kobo.1144.1">https://grpc.io/blog/a-short-introduction-to-channelz/</span></a><span class="koboSpan" id="kobo.1145.1">). </span><span class="koboSpan" id="kobo.1145.2">It</span><a id="_idTextAnchor951"/><span class="koboSpan" id="kobo.1146.1">s purpose is to debug networking issues. </span><span class="koboSpan" id="kobo.1146.2">You might want to take a look </span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">at it.</span></span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor952"/><span class="koboSpan" id="kobo.1148.1">Deploying</span></h1>
<p><span class="koboSpan" id="kobo.1149.1">Another crucial step of production-grade APIs </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.1150.1">is deploying the</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.1151.1"> services online. </span><span class="koboSpan" id="kobo.1151.2">In this section, we will see how we can create a Docker image for gRPC Go, deploy it to Kubernetes, and finally deploy the Envoy proxy to let clients make requests from outside the cluster to a server </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">inside it.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor953"/><span class="koboSpan" id="kobo.1153.1">Docker</span></h2>
<p><span class="koboSpan" id="kobo.1154.1">This first </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.1155.1">step</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.1156.1"> in deploying is often containerizing your application with Docker. </span><span class="koboSpan" id="kobo.1156.2">If we did not do so, we would have to deal with errors depending on the server architecture, tools not being available on it, and so on. </span><span class="koboSpan" id="kobo.1156.3">By containerizing our application, we can build our image once and run it everywhere where Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">is available.</span></span></p>
<p><span class="koboSpan" id="kobo.1158.1">We are going to focus on containerizing our server. </span><span class="koboSpan" id="kobo.1158.2">This makes much more sense than working on the client because we will later deploy our gRPC server as microservices in Kubernetes and we will make the client, which is outside, make requests </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">to them.</span></span></p>
<p><span class="koboSpan" id="kobo.1160.1">The first thing that we can think about is what all the steps needed to build our application are. </span><span class="koboSpan" id="kobo.1160.2">We ran it quite a few times, but we need to remember all the tools that we set up in the first place. </span><span class="koboSpan" id="kobo.1160.3">This includes </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1162.1">protoc to compile our </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">proto files</span></span></li>
<li><span class="koboSpan" id="kobo.1164.1">Proto Go, gRPC, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">validate</span></strong><span class="koboSpan" id="kobo.1166.1"> plugin to generate Go code out of </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">proto files</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1168.1">Obviously, Golang</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1169.1">Let us start with getting protoc. </span><span class="koboSpan" id="kobo.1169.2">For that, we are going to create a first stage based on Alpine, which will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">wget</span></strong><span class="koboSpan" id="kobo.1171.1"> to get the protoc ZIP file and unzip it inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">/usr/local</span></strong><span class="koboSpan" id="kobo.1173.1">. </span><span class="koboSpan" id="kobo.1173.2">If you are</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.1174.1"> impatient, you can find the </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.1175.1">whole Dockerfile in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">server/Dockerfile</span></strong><span class="koboSpan" id="kobo.1177.1">, but we are going to explain it step </span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">by step:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1179.1">
FROM </span><strong class="bold"><span class="koboSpan" id="kobo.1180.1">--platform=$BUILDPLATFORM</span></strong><span class="koboSpan" id="kobo.1181.1"> alpine as protoc
ARG </span><strong class="bold"><span class="koboSpan" id="kobo.1182.1">BUILDPLATFORM TARGETOS TARGETARCH</span></strong><span class="koboSpan" id="kobo.1183.1">
RUN export </span><strong class="bold"><span class="koboSpan" id="kobo.1184.1">PROTOC_VERSION=23.0</span></strong><span class="koboSpan" id="kobo.1185.1"> \
    &amp;&amp; export PROTOC_ARCH=$(uname -m | </span><strong class="bold"><span class="koboSpan" id="kobo.1186.1">sed</span></strong><span class="koboSpan" id="kobo.1187.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1188.1">s/aarch64/aarch_64/</span></strong><span class="koboSpan" id="kobo.1189.1">) \
    &amp;&amp; export PROTOC_OS=$(echo $TARGETOS | sed
      </span><strong class="bold"><span class="koboSpan" id="kobo.1190.1">s/darwin/linux/</span></strong><span class="koboSpan" id="kobo.1191.1">) \
    &amp;&amp; export PROTOC_ZIP=protoc-$PROTOC_VERSION-$PROTOC_OS-
      $PROTOC_ARCH.zip \
    &amp;&amp; echo "downloading: " https://github.com/
    protocolbuffers/protobuf/releases/download/
    v$PROTOC_VERSION/$PROTOC_ZIP \
    &amp;&amp; wget https://github.com/protocolbuffers/protobuf/
    releases/download/v$PROTOC_VERSION/$PROTOC_ZIP \
    &amp;&amp; </span><strong class="bold"><span class="koboSpan" id="kobo.1192.1">unzip -o $PROTOC_ZIP -d /usr/local bin/protoc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1193.1">    'include/*'</span></strong><span class="koboSpan" id="kobo.1194.1"> \
    &amp;&amp; rm -f $PROTOC_ZIP</span></pre>
<p><span class="koboSpan" id="kobo.1195.1">There are quite a few things happening here. </span><span class="koboSpan" id="kobo.1195.2">First notice that we are using the Docker BuildKit engine. </span><span class="koboSpan" id="kobo.1195.3">This lets us use defined variables such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">BUILDPLATFORM</span></strong><span class="koboSpan" id="kobo.1197.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">TARGETOS</span></strong><span class="koboSpan" id="kobo.1199.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">TARGETARCH</span></strong><span class="koboSpan" id="kobo.1201.1">. </span><span class="koboSpan" id="kobo.1201.2">We do that because even though we are containerizing our application to avoid dealing with architecture, running a container with the same architecture as the host (virtualization) is much more efficient than emulation. </span><span class="koboSpan" id="kobo.1201.3">Furthermore, as you can see, we need to specify the architecture and OS in the URL to </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">download protoc.</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">Then, we</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.1204.1"> define some variables that are important</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.1205.1"> for building up the download URL. </span><span class="koboSpan" id="kobo.1205.2">We set the version of protoc (here, 23.0). </span><span class="koboSpan" id="kobo.1205.3">Then, we set the architecture we want to work on. </span><span class="koboSpan" id="kobo.1205.4">This is based on the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">uname –m</span></strong><span class="koboSpan" id="kobo.1207.1">, which gives information about the machine. </span><span class="koboSpan" id="kobo.1207.2">Notice that we use a little trick to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">aarch64</span></strong><span class="koboSpan" id="kobo.1209.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">aarch_64</span></strong><span class="koboSpan" id="kobo.1211.1">. </span><span class="koboSpan" id="kobo.1211.2">This is because if you take a look at the releases on the Protobuf repository (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">https://github.com/protocolbuffers/protobuf/releases</span></strong><span class="koboSpan" id="kobo.1213.1">), they use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">aarch_64</span></strong><span class="koboSpan" id="kobo.1215.1"> in their </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">ZIP filenames.</span></span></p>
<p><span class="koboSpan" id="kobo.1217.1">After that, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">TARGETOS</span></strong><span class="koboSpan" id="kobo.1219.1"> variable to define which OS we want to deal with. </span><span class="koboSpan" id="kobo.1219.2">Notice, once again, the similar trick to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">darwin</span></strong><span class="koboSpan" id="kobo.1221.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">linux</span></strong><span class="koboSpan" id="kobo.1223.1">. </span><span class="koboSpan" id="kobo.1223.2">This is simply because protoc does not have a binary specific to macOS. </span><span class="koboSpan" id="kobo.1223.3">You can simply use a </span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">Linux one.</span></span></p>
<p><span class="koboSpan" id="kobo.1225.1">Then, we do the actual downloading of the file by concatenating all the variables that we defined previously, and we unzip the file into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">/usr/local</span></strong><span class="koboSpan" id="kobo.1227.1">. </span><span class="koboSpan" id="kobo.1227.2">Notice that we are extracting both the protoc binary (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">/bin/protoc</span></strong><span class="koboSpan" id="kobo.1229.1">) and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">/include</span></strong><span class="koboSpan" id="kobo.1231.1"> folder because the first one is the compiler that we are going to use and the second one is all the files needed to include </span><span class="No-Break"><span class="koboSpan" id="kobo.1232.1">Well-Known Types.</span></span></p>
<p><span class="koboSpan" id="kobo.1233.1">Now that this is done, we can create another stage for building the application with Go. </span><span class="koboSpan" id="kobo.1233.2">Here, we are going to copy protoc from the previous stage, download the protoc plugins, compile the proto files, and compile the Go project. </span><span class="koboSpan" id="kobo.1233.3">We are going to use an Alpine-based image </span><span class="No-Break"><span class="koboSpan" id="kobo.1234.1">for that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1235.1">
FROM --platform=$BUILDPLATFORM golang:1.20-alpine as build
</span><strong class="bold"><span class="koboSpan" id="kobo.1236.1">ARG BUILDPLATFORM TARGETOS TARGETARCH</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1237.1">COPY --from=protoc /usr/local/bin/protoc /usr/local/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1238.1">bin/protoc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1239.1">COPY --from=protoc /usr/local/include/google /usr/local/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1240.1">include/google</span></strong><span class="koboSpan" id="kobo.1241.1">
RUN go install google.golang.org/protobuf/cmd/protoc-gen-
go@latest
RUN go install google.golang.org/grpc/cmd/protoc-gen-go-
grpc@latest
RUN go install githu</span><a id="_idTextAnchor954"/><span class="koboSpan" id="kobo.1242.1">b.com/e</span><a id="_idTextAnchor955"/><span class="koboSpan" id="kobo.1243.1">nvoyproxy/protoc-gen-
validate@latest
WORKDIR /go/src/proto
COPY ./proto .
</span><span class="koboSpan" id="kobo.1243.2">RUN protoc –I. </span><span class="koboSpan" id="kobo.1243.3">\
    --go_out=. </span><span class="koboSpan" id="kobo.1243.4">\
    --go_opt=paths=source_relative \
    --go-grpc_out=. </span><span class="koboSpan" id="kobo.1243.5">\
    --go-grpc_opt=paths=source_relat</span><a id="_idTextAnchor956"/><span class="koboSpan" id="kobo.1244.1">ive \
    --validate_out="lang=g</span><a id="_idTextAnchor957"/><span class="koboSpan" id="kobo.1245.1">o,paths</span><a id="_idTextAnchor958"/><span class="koboSpan" id="kobo.1246.1">=source_relative:." </span><span class="koboSpan" id="kobo.1246.2">\
    **/*.proto
WORKDIR /go/src/server
COPY ./server .
</span><span class="koboSpan" id="kobo.1246.3">RUN go mod download
RUN CGO_ENABLED=0 </span><strong class="bold"><span class="koboSpan" id="kobo.1247.1">GOOS=$TARGETOS GOARCH=$TARGETARCH</span></strong><span class="koboSpan" id="kobo.1248.1"> go
  build -ldflags="</span><strong class="bold"><span class="koboSpan" id="kobo.1249.1">-s -w</span></strong><span class="koboSpan" id="kobo.1250.1">" -o /go/bin/server</span></pre>
<p><span class="koboSpan" id="kobo.1251.1">At this point, none of this should be confusing. </span><span class="koboSpan" id="kobo.1251.2">This is exactly what we have done earlier in the book. </span><span class="koboSpan" id="kobo.1251.3">However, I want to mention some non-trivial things that are happening here. </span><span class="koboSpan" id="kobo.1251.4">We are once again taking BuildKit-defined parameters. </span><span class="koboSpan" id="kobo.1251.5">This lets us use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">GOOS</span></strong><span class="koboSpan" id="kobo.1253.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">GOARCH</span></strong><span class="koboSpan" id="kobo.1255.1"> environment variables to build a Go binary for this </span><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">specific setting.</span></span></p>
<p><span class="koboSpan" id="kobo.1257.1">Also, notice</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.1258.1"> that we are copying both protoc and </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.1259.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">include</span></strong><span class="koboSpan" id="kobo.1261.1"> folder. </span><span class="koboSpan" id="kobo.1261.2">As mentioned, the second one is the directory containing Well-Known Types and we use some of them in our proto files, so this </span><span class="No-Break"><span class="koboSpan" id="kobo.1262.1">is necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.1263.1">Finally, I am using two linker flags. </span><span class="koboSpan" id="kobo.1263.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">-s</span></strong><span class="koboSpan" id="kobo.1265.1"> flag is here to disable the generation of the Go symbol table. </span><span class="koboSpan" id="kobo.1265.2">While I will not dive into what this means, this is sometimes used when creating smaller binaries to remove some information that should not impact the runtime capabilities. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">-w</span></strong><span class="koboSpan" id="kobo.1267.1"> removes debug information. </span><span class="koboSpan" id="kobo.1267.2">As these are not needed for production, we can just get rid </span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.1269.1">Finally, we will build our last stage, which will be based on a scratch image. </span><span class="koboSpan" id="kobo.1269.2">This is an image that does not h</span><a id="_idTextAnchor959"/><span class="koboSpan" id="kobo.1270.1">ave any OS and that we use for hosting binaries and making ou</span><a id="_idTextAnchor960"/><span class="koboSpan" id="kobo.1271.1">r images really small. </span><span class="koboSpan" id="kobo.1271.2">In there, we will copy our c</span><a id="_idTextAnchor961"/><span class="koboSpan" id="kobo.1272.1">ertificates into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">certs</span></strong><span class="koboSpan" id="kobo.1274.1"> directory, copy the binary we created with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">go build</span></strong><span class="koboSpan" id="kobo.1276.1">, and launch the application with the parameters that we </span><span class="No-Break"><span class="koboSpan" id="kobo.1277.1">usually set:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1278.1">
FROM scratch
COPY ./certs/server_cert.pem ./certs/server_cert.pem
COPY ./certs/server_key.pem ./certs/server_key.pem
COPY </span><strong class="bold"><span class="koboSpan" id="kobo.1279.1">--from=build /go/bin/server /</span></strong><span class="koboSpan" id="kobo.1280.1">
EXPOSE 50051 50052
CMD [</span><strong class="bold"><span class="koboSpan" id="kobo.1281.1">"/server", "0.0.0.0:50051", "0.0.0.0:50052"</span></strong><span class="koboSpan" id="kobo.1282.1">]</span></pre>
<p><span class="koboSpan" id="kobo.1283.1">With that, we are ready to build our first image of the server. </span><span class="koboSpan" id="kobo.1283.2">The first thing that we can create is a Docker Builder. </span><span class="koboSpan" id="kobo.1283.3">As described in the Docker documentation: “Builder inst</span><a id="_idTextAnchor962"/><span class="koboSpan" id="kobo.1284.1">ances are isolated environments where builds can be invoked.” </span><span class="koboSpan" id="kobo.1284.2">This is basically an environment that we need to launch the build of our images. </span><span class="koboSpan" id="kobo.1284.3">To create that, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">following command:</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1286.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1287.1">You need to make sure that Docker is running. </span><span class="koboSpan" id="kobo.1287.2">This is as simple as making sure that Docker Desktop is running. </span><span class="koboSpan" id="kobo.1287.3">Finally, you might need to prepend all the following Docker commands with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">sudo</span></strong><span class="koboSpan" id="kobo.1289.1"> if you are on Linux/Mac and you did not create a Docker group and add your user </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">to it.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1291.1">
$ docker buildx create --name </span><strong class="bold"><span class="koboSpan" id="kobo.1292.1">mybuild</span></strong><span class="koboSpan" id="kobo.1293.1"> --driver=</span><strong class="bold"><span class="koboSpan" id="kobo.1294.1">docker-</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1295.1">  container</span></strong></pre>
<p><span class="koboSpan" id="kobo.1296.1">Notice that </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.1297.1">we give this build environment the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">mybuild</span></strong><span class="koboSpan" id="kobo.1299.1"> and that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">docker-container</span></strong><span class="koboSpan" id="kobo.1301.1"> driver. </span><span class="koboSpan" id="kobo.1301.2">This driver</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.1302.1"> will let us generate multi-platform images. </span><span class="koboSpan" id="kobo.1302.2">We are going to see </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">that later.</span></span></p>
<p><span class="koboSpan" id="kobo.1304.1">Once we have executed the command, we will be able to use this Builder in another Docker command: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">docker buildx build</span></strong><span class="koboSpan" id="kobo.1306.1">. </span><span class="koboSpan" id="kobo.1306.2">With this command, we are going to generate the image. </span><span class="koboSpan" id="kobo.1306.3">We will give it a tag (a name), specify where to find the Dockerfile, specify the architecture we want to build on, and load the image into Docker. </span><span class="koboSpan" id="kobo.1306.4">To build an image for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">arm64</span></strong><span class="koboSpan" id="kobo.1308.1"> (you can try </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">amd64</span></strong><span class="koboSpan" id="kobo.1310.1">), we run the following (</span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">chapter9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1313.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1314.1">
$ docker buildx build \
  --tag clementjean/grpc-go-packt-book:server \
  --file s</span><a id="_idTextAnchor963"/><span class="koboSpan" id="kobo.1315.1">erver/Dockerfile \
  --platform linux/arm64 \
  --builder mybuild \
  --load .</span></pre>
<p><span class="koboSpan" id="kobo.1316.1">After everything is built, we should be able to see the image by executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1317.1">following command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1318.1">$ docker image ls</span></strong><span class="koboSpan" id="kobo.1319.1">
REPOSITORY                       TAG      SIZE
clementjean/grpc-go-packt-book   server   10.9MB</span></pre>
<p><span class="koboSpan" id="kobo.1320.1">Finally, let us try to run the server image and make requests to it. </span><span class="koboSpan" id="kobo.1320.2">We are going to run the image we just</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.1321.1"> created and expose the ports we used for the server (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">50051</span></strong><span class="koboSpan" id="kobo.1323.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">50052</span></strong><span class="koboSpan" id="kobo.1325.1">) to the same ports on </span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">the host:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1327.1">$ docker run -p 50051:50051 -p 50052:50052</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1328.1">  clementjean/grpc-go-packt-book:server</span></strong><span class="koboSpan" id="kobo.1329.1">
metrics server listening at 0.0.0.0:50052
gRPC server listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.1330.1">Now, if we run our client</span><a id="_idTextAnchor964"/><span class="koboSpan" id="kobo.1331.1"> normally, we should be able to get all the logs we </span><span class="No-Break"><span class="koboSpan" id="kobo.1332.1">had previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1333.1">
$ go run ./client 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.1334.1">To conclude, we</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.1335.1"> saw that we can create slim images around our gRPC applications. </span><span class="koboSpan" id="kobo.1335.2">We used a multi-stage Dockerfile in which we first downloaded protoc and the Protobuf Well-Known Types. </span><span class="koboSpan" id="kobo.1335.3">We then downloaded all the Golang dependencies and built a binary, and finally, we copied the binary into a scratch image to create a thin wrapper </span><span class="No-Break"><span class="koboSpan" id="kobo.1336.1">around it.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor965"/><span class="koboSpan" id="kobo.1337.1">Kubernetes</span></h2>
<p><span class="koboSpan" id="kobo.1338.1">Now that </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.1339.1">we have our server image, we</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.1340.1"> can deploy multiple instances of our service and we will have created our to-do microservice. </span><span class="koboSpan" id="kobo.1340.2">In this section, we are going to focus mostly on how to deploy our gRPC service. </span><span class="koboSpan" id="kobo.1340.3">This means that we are going to write a Kubernetes configuration. </span><span class="koboSpan" id="kobo.1340.4">If you are not familiar with Kubernetes, there is nothing to be afraid of. </span><span class="koboSpan" id="kobo.1340.5">Our configuration is simple and I will explain all </span><span class="No-Break"><span class="koboSpan" id="kobo.1341.1">the blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.1342.1">The first thing that we need to think about is how our service will be accessed. </span><span class="koboSpan" id="kobo.1342.2">We have two major ways of exposing our services: making them accessible only from inside the cluster or accessible from outside the cluster. </span><span class="koboSpan" id="kobo.1342.3">In most cases, we do not want our services to be accessed directly. </span><span class="koboSpan" id="kobo.1342.4">We want to go through a proxy that will redirect and load balance the requests to multiple instances of </span><span class="No-Break"><span class="koboSpan" id="kobo.1343.1">our service.</span></span></p>
<p><span class="koboSpan" id="kobo.1344.1">As such, we will </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.1345.1">create a Kubernetes Service, which will itself assign a DNS A record for all the instances of our service. </span><span class="koboSpan" id="kobo.1345.2">This basically means that each of our services will have its own internal address in the cluster. </span><span class="koboSpan" id="kobo.1345.3">This will let our proxy resolve all the addresses and load balance across all </span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.1347.1">Such a</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.1348.1"> service is called a headless service. </span><span class="koboSpan" id="kobo.1348.2">In Kubernetes, this is a service with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">clusterIp</span></strong><span class="koboSpan" id="kobo.1350.1"> property set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">None</span></strong><span class="koboSpan" id="kobo.1352.1">. </span><span class="koboSpan" id="kobo.1352.2">Here is the service </span><span class="No-Break"><span class="koboSpan" id="kobo.1353.1">definition (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">k8s/server.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1355.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1356.1">
apiVersion: v1
kind: Service
metadata:
  name: todo-server
spec:
  clusterIP: None
  ports:
  - name: </span><strong class="bold"><span class="koboSpan" id="kobo.1357.1">grpc</span></strong><span class="koboSpan" id="kobo.1358.1">
    port: </span><strong class="bold"><span class="koboSpan" id="kobo.1359.1">50051</span></strong><span class="koboSpan" id="kobo.1360.1">
  selector:
    app: </span><strong class="bold"><span class="koboSpan" id="kobo.1361.1">todo-server</span></strong></pre>
<p><span class="koboSpan" id="kobo.1362.1">Note that we create a port called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">grpc</span></strong><span class="koboSpan" id="kobo.1364.1"> with the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">50051</span></strong><span class="koboSpan" id="kobo.1366.1">. </span><span class="koboSpan" id="kobo.1366.2">This is because we want to be able to access all the services on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">50051</span></strong><span class="koboSpan" id="kobo.1368.1">. </span><span class="koboSpan" id="kobo.1368.2">Then, notice that we are creating a selecto</span><a id="_idTextAnchor966"/><span class="koboSpan" id="kobo.1369.1">r to specify which app this service will handle. </span><span class="koboSpan" id="kobo.1369.2">In our case, we call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">todo-server</span></strong><span class="koboSpan" id="kobo.1371.1"> and this will be the name for </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">our deployments.</span></span></p>
<p><span class="koboSpan" id="kobo.1373.1">Now, we can think about creating instances of our service. </span><span class="koboSpan" id="kobo.1373.2">We are going to do that with a Kubernetes Deployment. </span><span class="koboSpan" id="kobo.1373.3">This will let us specify how many instances we want, which image to use, and which container </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.1374.1">port to use. </span><span class="koboSpan" id="kobo.1374.2">This</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.1375.1"> looks like the </span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">following (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">k8s/server.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1379.1">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: </span><strong class="bold"><span class="koboSpan" id="kobo.1380.1">todo-server</span></strong><span class="koboSpan" id="kobo.1381.1">
  labels:
    app: </span><strong class="bold"><span class="koboSpan" id="kobo.1382.1">todo-server</span></strong><span class="koboSpan" id="kobo.1383.1">
spec:
  replicas: </span><strong class="bold"><span class="koboSpan" id="kobo.1384.1">3</span></strong><span class="koboSpan" id="kobo.1385.1">
  selector:
    matchLabels:
      app: </span><strong class="bold"><span class="koboSpan" id="kobo.1386.1">todo-server</span></strong><span class="koboSpan" id="kobo.1387.1">
  template:
    metadata:
      labels:
        app: </span><strong class="bold"><span class="koboSpan" id="kobo.1388.1">todo-server</span></strong><span class="koboSpan" id="kobo.1389.1">
    spec:
      containers:
      - name: </span><strong class="bold"><span class="koboSpan" id="kobo.1390.1">todo-server</span></strong><span class="koboSpan" id="kobo.1391.1">
        image: </span><strong class="bold"><span class="koboSpan" id="kobo.1392.1">clementjean/grpc-go-packt-book:server</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1393.1">        imagePullPolicy: Always</span></strong><span class="koboSpan" id="kobo.1394.1">
        ports:
        - </span><strong class="bold"><span class="koboSpan" id="kobo.1395.1">name: grpc</span></strong><span class="koboSpan" id="kobo.1396.1">
          </span><strong class="bold"><span class="koboSpan" id="kobo.1397.1">containerPort: 50051</span></strong></pre>
<p><span class="koboSpan" id="kobo.1398.1">Here, we specify that the name of the Pods will match </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">todo-server</span></strong><span class="koboSpan" id="kobo.1400.1">. </span><span class="koboSpan" id="kobo.1400.2">This makes them be handled by the service. </span><span class="koboSpan" id="kobo.1400.3">We</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.1401.1"> then specify that we want to use the image that we created earlier. </span><span class="koboSpan" id="kobo.1401.2">However, notice here that we are setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">imagePullPolicy</span></strong><span class="koboSpan" id="kobo.1403.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">Always</span></strong><span class="koboSpan" id="kobo.1405.1">. </span><span class="koboSpan" id="kobo.1405.2">This means that each time we create the Pods, they will pull a new image from the image registry. </span><span class="koboSpan" id="kobo.1405.3">This makes sure that we always get the newest image on the registry. </span><span class="koboSpan" id="kobo.1405.4">However, note that this might be inefficient if the images do not change often and if you have local copies of the images that are not outdated. </span><span class="koboSpan" id="kobo.1405.5">I would recommend you check, depending on your Kubernetes environment, what to use as a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">imagePullPolicy</span></strong><span class="koboSpan" id="kobo.1407.1">. </span><span class="koboSpan" id="kobo.1407.2">Finally, we use port </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">50051</span></strong><span class="koboSpan" id="kobo.1409.1">. </span><span class="koboSpan" id="kobo.1409.2">There is nothing more to it than specifying on which port our service is exposing </span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">the API.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1411.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1412.1">For the remainder of this chapter, I expect that you already have a Kubernetes cluster. </span><span class="koboSpan" id="kobo.1412.2">If you have one in the cloud, this is perfect and you can continue. </span><span class="koboSpan" id="kobo.1412.3">If you do not have one, you can refer to Kind (</span><a href="https://kind.sigs.k8s.io/"><span class="koboSpan" id="kobo.1413.1">https://kind.sigs.k8s.io/</span></a><span class="koboSpan" id="kobo.1414.1">), and once installed, you can create a simple cluster with the configuration provided in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">k8s/kind.yaml</span></strong><span class="koboSpan" id="kobo.1416.1">. </span><span class="koboSpan" id="kobo.1416.2">Simply run </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">kind create cluster --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">config k8s/kind.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1419.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1420.1">With that, we</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.1421.1"> can now deploy our three services. </span><span class="koboSpan" id="kobo.1421.2">We will run the following command from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1422.1">chapter9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1423.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1424.1">
$ kubectl apply -f k8s/server.yaml</span></pre>
<p><span class="koboSpan" id="kobo.1425.1">We are going to execute the following command to look at the Pod </span><span class="No-Break"><span class="koboSpan" id="kobo.1426.1">being created:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1427.1">$ kubectl get pods</span></strong><span class="koboSpan" id="kobo.1428.1">
NAME                           READY   STATUS
</span><strong class="bold"><span class="koboSpan" id="kobo.1429.1">todo-server-7d874bfbdb-2cqjn   </span></strong><span class="koboSpan" id="kobo.1430.1">1/1     </span><strong class="bold"><span class="koboSpan" id="kobo.1431.1">Running</span></strong><span class="koboSpan" id="kobo.1432.1">
todo-server-7d874bfbdb-gzfch   1/1     </span><strong class="bold"><span class="koboSpan" id="kobo.1433.1">Running</span></strong><span class="koboSpan" id="kobo.1434.1">
todo-server-7d874bfbdb-hkmtp   1/1     </span><strong class="bold"><span class="koboSpan" id="kobo.1435.1">Running</span></strong></pre>
<p><span class="koboSpan" id="kobo.1436.1">Now, since we do not have a proxy, we will simply use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">port-forward</span></strong><span class="koboSpan" id="kobo.1438.1"> command from Kubernetes to access one server and see whether it works. </span><span class="koboSpan" id="kobo.1438.2">This is purely for testing purposes, and we are going to see later how to hide the services behind a proxy. </span><span class="koboSpan" id="kobo.1438.3">So, we run </span><span class="No-Break"><span class="koboSpan" id="kobo.1439.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1440.1">$ kubectl port-forward pod/</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1441.1">todo-server</span><a id="_idTextAnchor967"/><span class="koboSpan" id="kobo.1442.1">-7d874bfbdb-2cqjn</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1443.1">50051</span></strong><span class="koboSpan" id="kobo.1444.1">
Forwarding from 127.0.0.1:50051 -&gt; 50051
Forwarding from [::1]:50051 -&gt; 5</span><a id="_idTextAnchor968"/><span class="koboSpan" id="kobo.1445.1">0051</span></pre>
<p><span class="koboSpan" id="kobo.1446.1">Then, we</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.1447.1"> should be able to use our </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.1448.1">client normally </span><span class="No-Break"><span class="koboSpan" id="kobo.1449.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">localhost:50051</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1451.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1452.1">
$ go run ./client 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.1453.1">To conclude, we saw that we can use a headless service to create a DNS A record for each of the Pods in the Deployment. </span><span class="koboSpan" id="kobo.1453.2">We then deployed three Pods and saw that we can test whether they are working or not by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1454.1">port-forward</span></strong><span class="koboSpan" id="kobo.1455.1"> command </span><span class="No-Break"><span class="koboSpan" id="kobo.1456.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">kubectl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor969"/><span class="koboSpan" id="kobo.1459.1">Envoy proxy</span></h2>
<p><span class="koboSpan" id="kobo.1460.1">Now that </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.1461.1">we have our microservices created, we need to add a proxy that will balance the load between all of them. </span><span class="koboSpan" id="kobo.1461.2">This proxy is Envoy. </span><span class="koboSpan" id="kobo.1461.3">This is one of </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.1462.1">the few proxies that can interact with gRPC services. </span><span class="koboSpan" id="kobo.1462.2">We are going to see how to set up Envoy to redirect traffic to our services, load balance with the round robin algorithm, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1463.1">enable TLS.</span></span></p>
<p><span class="koboSpan" id="kobo.1464.1">Let us first </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.1465.1">focus on writing a listener. </span><span class="koboSpan" id="kobo.1465.2">This is an entity that specifies the address and port on which to listen and defines</span><a id="_idTextAnchor970"/><span class="koboSpan" id="kobo.1466.1"> some </span><a id="_idTextAnchor971"/><span class="koboSpan" id="kobo.1467.1">filters. </span><span class="koboSpan" id="kobo.1467.2">These filters, at least in our case, will let us route the requests for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1468.1">todo.v2.TodoService</span></strong><span class="koboSpan" id="kobo.1469.1"> to an Envoy cluster. </span><span class="koboSpan" id="kobo.1469.2">A cluster is the entity that will let us define the actual endpoints and shows us how to load balance. </span><span class="koboSpan" id="kobo.1469.3">We can first write our </span><span class="No-Break"><span class="koboSpan" id="kobo.1470.1">listener (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">envoy/envoy.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1472.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1473.1">
node:
  id: todo-envoy-proxy
  cluster: grpc_cluster
static_resources:
  listeners:
  - name: listener_grpc
    address:
      socket_address:
        </span><strong class="bold"><span class="koboSpan" id="kobo.1474.1">address: 0.0.0.0</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1475.1">        port_value: 50051</span></strong><span class="koboSpan" id="kobo.1476.1">
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions
          .filters.network.http_connection_manager.
</span><span class="koboSpan" id="kobo.1476.2">           v3.HttpConnectionManager
          stat_prefix: listener_http
          http_filters:
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions
               .filters.http.router.v3.Router
          route_config:
            name: route
            virtual_hosts:
            - name: vh
              </span><a id="_idTextAnchor972"/><strong class="bold"><span class="koboSpan" id="kobo.1477.1">domain</span><a id="_idTextAnchor973"/><span class="koboSpan" id="kobo.1478.1">s: ["*"]</span></strong><span class="koboSpan" id="kobo.1479.1">
              routes:
              - match:
                  prefix: </span><strong class="bold"><span class="koboSpan" id="kobo.1480.1">/todo.v2.TodoService</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1481.1">                  grpc: {}</span></strong><span class="koboSpan" id="kobo.1482.1">
                route:
                  cluster: </span><strong class="bold"><span class="koboSpan" id="kobo.1483.1">grpc_cluster</span></strong></pre>
<p><span class="koboSpan" id="kobo.1484.1">The </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.1485.1">most important things to note are that we</span><a id="_idTextAnchor974"/><span class="koboSpan" id="kobo.1486.1"> defin</span><a id="_idTextAnchor975"/><span class="koboSpan" id="kobo.1487.1">ed a route matching all the gRPC requests from any domain names and matching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">/todo.v2.TodoService</span></strong><span class="koboSpan" id="kobo.1489.1"> prefix. </span><span class="koboSpan" id="kobo.1489.2">Then, all these requests will be redirected </span><span class="No-Break"><span class="koboSpan" id="kobo.1490.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1491.1">grpc_cluster</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1492.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1493.1">After that, let us </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.1494.1">define our cluster. </span><span class="koboSpan" id="kobo.1494.2">We are going to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1495.1">STRICT_DNS</span></strong><span class="koboSpan" id="kobo.1496.1"> resolution to detect all the gRPC services by DNS A record. </span><span class="koboSpan" id="kobo.1496.2">Then, we will specify that we are only accepting HTTP/2 requests. </span><span class="koboSpan" id="kobo.1496.3">This is because, as you know, gRPC is based on HTTP/2. </span><span class="koboSpan" id="kobo.1496.4">After that, we will set the load balancing policy to use round robin. </span><span class="koboSpan" id="kobo.1496.5">Finally, we will specify the address and port of </span><span class="No-Break"><span class="koboSpan" id="kobo.1497.1">the endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1498.1">
clusters:
- name: grpc_cluster
  type: </span><strong class="bold"><span class="koboSpan" id="kobo.1499.1">STRICT_DNS</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1500.1">  http2_protocol_options</span></strong><span class="koboSpan" id="kobo.1501.1">: {}
  lb_policy: round_robin
  load_assignment:
    cluster_name: grpc_cluster
    endpoints:
    - lb_endpoints:
      - endpoint:
        address:
          socket_address:
            </span><strong class="bold"><span class="koboSpan" id="kobo.1502.1">address: "todo-server.default.svc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1503.1">              </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1504.1">.cluster.local"</span></strong><span class="koboSpan" id="kobo.1505.1">
            port_value: </span><strong class="bold"><span class="koboSpan" id="kobo.1506.1">50051</span></strong></pre>
<p><span class="koboSpan" id="kobo.1507.1">Notice that we use the address </span><a id="_idTextAnchor976"/><span class="koboSpan" id="kobo.1508.1">generated by Kubernetes. </span><span class="koboSpan" id="kobo.1508.2">This is of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1509.1">form </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">$SERVICE_NAME-$NAMESPACE-svc-cluster.local</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1511.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1512.1">In order to</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.1513.1"> test our configuration, we</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.1514.1"> can run everything locally first. </span><span class="koboSpan" id="kobo.1514.2">We will temporarily make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1515.1">listener_0</span></strong><span class="koboSpan" id="kobo.1516.1"> port equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1517.1">50050</span></strong><span class="koboSpan" id="kobo.1518.1"> so that it does not conflict with our </span><span class="No-Break"><span class="koboSpan" id="kobo.1519.1">server port:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1520.1">
static_resources:
  listeners:
  - name: listener_grpc
    address:
      socket_address:
        address: 0.0.0.0
        port_value: </span><strong class="bold"><span class="koboSpan" id="kobo.1521.1">50050</span></strong></pre>
<p><span class="koboSpan" id="kobo.1522.1">We will also have to set the endpoint address to localhost to access the server </span><span class="No-Break"><span class="koboSpan" id="kobo.1523.1">running locally:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1524.1">
- endpoint:
  address:
    socket_</span><a id="_idTextAnchor977"/><span class="koboSpan" id="kobo.1525.1">address:
      address: </span><strong class="bold"><span class="koboSpan" id="kobo.1526.1">0.0.0.0</span></strong><span class="koboSpan" id="kobo.1527.1">
      port_value: 50051</span></pre>
<p><span class="koboSpan" id="kobo.1528.1">Then, we will run </span><span class="No-Break"><span class="koboSpan" id="kobo.1529.1">our server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1530.1">$ go run ./server 0.0.0.0:50051 0.0.0.0:50052</span></strong><span class="koboSpan" id="kobo.1531.1">
metrics server listening at 0.0.0.0:50052
gRPC server listening at 0.0.0.0:50051</span></pre>
<p><span class="koboSpan" id="kobo.1532.1">We can now run our envoy instance </span><span class="No-Break"><span class="koboSpan" id="kobo.1533.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1534.1">func-e</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1535.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1536.1">
$ fun</span><a id="_idTextAnchor978"/><span class="koboSpan" id="kobo.1537.1">c-e run -c envoy/envoy.yaml</span></pre>
<p><span class="koboSpan" id="kobo.1538.1">Finally, we can run our client on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.1539.1">50050</span></strong><span class="koboSpan" id="kobo.1540.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1541.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1542.1">50051</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1543.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1544.1">$ go run ./client 0.0.0.0:50050</span></strong><span class="koboSpan" id="kobo.1545.1">
--------ADD--------
2023/06/04 11:36:45 rpc error: code = Unavailable desc =
last connection error: connection error: desc = "transport:
authentication handshake failed: tls: first record does not
look like a </span><strong class="bold"><span class="koboSpan" id="kobo.1546.1">TLS</span></strong><span class="koboSpan" id="kobo.1547.1"> handshake"</span></pre>
<p><span class="koboSpan" id="kobo.1548.1">As </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.1549.1">you can guess, this is because Envoy </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.1550.1">is somehow breaking the TLS connection between the server and the client. </span><span class="koboSpan" id="kobo.1550.2">To solve that, we are going to specify that the upstream of our cluster uses TLS and that the downstream of our listener also </span><span class="No-Break"><span class="koboSpan" id="kobo.1551.1">uses TLS.</span></span></p>
<p><span class="koboSpan" id="kobo.1552.1">In the filters, we will tell Envoy where to find our </span><span class="No-Break"><span class="koboSpan" id="kobo.1553.1">self-signed certificates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1554.1">
#...
</span><span class="koboSpan" id="kobo.1554.2">filter_chains:
- filters:
  #...
</span><span class="koboSpan" id="kobo.1554.3">  transport_socket:
  name: </span><strong class="bold"><span class="koboSpan" id="kobo.1555.1">envoy.transport_sockets.tls</span></strong><span class="koboSpan" id="kobo.1556.1">
  typed_config:
    "@type": type.googleapis.com/envoy.extensions
      .transport_sockets.tls.v3.</span><strong class="bold"><span class="koboSpan" id="kobo.1557.1">DownstreamTlsContext</span></strong><span class="koboSpan" id="kobo.1558.1">
      common_tls_context:
        tls_certificates:
          - certificate_chain:
              filename: </span><strong class="bold"><span class="koboSpan" id="kobo.1559.1">/etc/envoy/certs/server_cert.pem</span></strong><span class="koboSpan" id="kobo.1560.1">
      </span><a id="_idTextAnchor979"/><span class="koboSpan" id="kobo.1561.1">      private_key:
              filename: </span><strong class="bold"><span class="koboSpan" id="kobo.1562.1">/etc/envoy/certs/server_key.pem</span></strong></pre>
<p><span class="koboSpan" id="kobo.1563.1">Note that this is probably not what you would do in production. </span><span class="koboSpan" id="kobo.1563.2">You would use a tool such as Let’s Encrypt</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.1564.1"> to automatically generate your certificates and </span><span class="No-Break"><span class="koboSpan" id="kobo.1565.1">link them.</span></span></p>
<p><span class="koboSpan" id="kobo.1566.1">Now, we will tell the cluster that the upstream is also </span><span class="No-Break"><span class="koboSpan" id="kobo.1567.1">using TLS:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1568.1">
clusters:
- name: grpc_cluster
  #...
</span><span class="koboSpan" id="kobo.1568.2">  transport_socket:
    name: </span><strong class="bold"><span class="koboSpan" id="kobo.1569.1">envoy.transport_sockets.tls</span></strong><span class="koboSpan" id="kobo.1570.1">
    typed_config:
      "@type": type.googleapis.com/envoy.extensions
        .transport_sockets.tls.v3.</span><strong class="bold"><span class="koboSpan" id="kobo.1571.1">UpstreamTlsContext</span></strong></pre>
<p><span class="koboSpan" id="kobo.1572.1">Obviously, this is not </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.1573.1">going to work directly. </span><span class="koboSpan" id="kobo.1573.2">On our local computer, we do not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1574.1">/etc/envoy/certs/server_cert.pem</span></strong><span class="koboSpan" id="kobo.1575.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1576.1">/etc/envoy/certs/server_key.pem</span></strong><span class="koboSpan" id="kobo.1577.1"> files. </span><span class="koboSpan" id="kobo.1577.2">But we have them in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1578.1">chapter9</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1579.1">certs</span></strong><span class="koboSpan" id="kobo.1580.1"> folder. </span><span class="koboSpan" id="kobo.1580.2">We will replace </span><span class="No-Break"><span class="koboSpan" id="kobo.1581.1">them temporarily:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1582.1">
- certificate_chain:
    filename: .</span><strong class="bold"><span class="koboSpan" id="kobo.1583.1">/certs/server_cert.pem</span></strong><span class="koboSpan" id="kobo.1584.1">
  private_key:
    filename: .</span><strong class="bold"><span class="koboSpan" id="kobo.1585.1">/certs/server_key.pem</span></strong></pre>
<p><span class="koboSpan" id="kobo.1586.1">Let us now kill the previous instance of Envoy and </span><span class="No-Break"><span class="koboSpan" id="kobo.1587.1">rerun it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1588.1">
$ func-e run -c envoy/envoy</span><a id="_idTextAnchor980"/><span class="koboSpan" id="kobo.1589.1">.yaml</span></pre>
<p><span class="koboSpan" id="kobo.1590.1">Finally, we should be able to run our client and receive responses from </span><span class="No-Break"><span class="koboSpan" id="kobo.1591.1">our server:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1592.1">
$ go run ./client 0.0.0.0:</span><strong class="bold"><span class="koboSpan" id="kobo.1593.1">50050</span></strong></pre>
<p><span class="koboSpan" id="kobo.1594.1">We are now </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.1595.1">certain that our requests go through Envoy and are redirected to our gRPC server. </span><span class="koboSpan" id="kobo.1595.2">The next step will be reverting all the temporary changes that we made for testing (listener port to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1596.1">50051</span></strong><span class="koboSpan" id="kobo.1597.1">, endpoint address to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1598.1">todo-server.default.svc.cluster.local</span></strong><span class="koboSpan" id="kobo.1599.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">certs</span></strong><span class="koboSpan" id="kobo.1601.1"> path to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">/etc/envoy</span></strong><span class="koboSpan" id="kobo.1603.1">) and creating a Docker image that we will use for deploying Envoy in our </span><span class="No-Break"><span class="koboSpan" id="kobo.1604.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.1605.1">To build </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.1606.1">such an image, we will copy the certificates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1607.1">/etc/envoy/certs</span></strong><span class="koboSpan" id="kobo.1608.1"> (once again, this is not recommended in production) and the configuration (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1609.1">envoy.yaml</span></strong><span class="koboSpan" id="kobo.1610.1">) to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1611.1">/etc/envoy</span></strong><span class="koboSpan" id="kobo.1612.1">. </span><span class="koboSpan" id="kobo.1612.2">Finally, this image will run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1613.1">envoy</span></strong><span class="koboSpan" id="kobo.1614.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1615.1">--config-path</span></strong><span class="koboSpan" id="kobo.1616.1"> flag, which will point to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">/etc/envoy/envoy.yaml</span></strong><span class="koboSpan" id="kobo.1618.1"> path. </span><span class="koboSpan" id="kobo.1618.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1619.1">envoy/Dockerfile</span></strong><span class="koboSpan" id="kobo.1620.1">, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1621.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1622.1">
FROM envoyproxy/envoy-distroless:v1.26-latest
COPY ./envoy/envoy.yaml /etc/envoy/envoy.yaml
COPY ./certs/server_cert.pem /etc/envoy/certs/
server_cert.pem
COPY ./certs/server_key.pem /etc/envoy/certs/server_key.pem
EXPOSE 50051
CMD ["--config-path", "/etc/envoy/envoy.yaml"]</span></pre>
<p><span class="koboSpan" id="kobo.1623.1">We can now build the image for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1624.1">arm64</span></strong><span class="koboSpan" id="kobo.1625.1"> (you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1626.1">amd64</span></strong><span class="koboSpan" id="kobo.1627.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.1628.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1629.1">
$ docker buildx build \
    --tag clementjean/grpc-go-packt-book:envoy-proxy \
    --file ./envoy/Dockerfile \
    --platform linux/arm64 \
    --builder mybuild \
    --load .</span></pre>
<p><span class="koboSpan" id="kobo.1630.1">That is it! </span><span class="koboSpan" id="kobo.1630.2">We are ready to deploy Envoy in front of our TODO microservices. </span><span class="koboSpan" id="kobo.1630.3">We need a headless service for Envoy. </span><span class="koboSpan" id="kobo.1630.4">This is for the same reasons that we had when creating a headless service for our microservices. </span><span class="koboSpan" id="kobo.1630.5">In production, there will potentially be more than one instance of Envoy</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.1631.1"> and you need to make sure they are all addressable. </span><span class="koboSpan" id="kobo.1631.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">envoy/service.yaml</span></strong><span class="koboSpan" id="kobo.1633.1">, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1634.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1635.1">
apiVersion: v1
kind: Service
metadata:
  name: todo-envoy
spec:
  </span><strong class="bold"><span class="koboSpan" id="kobo.1636.1">clusterIP: None</span></strong><span class="koboSpan" id="kobo.1637.1">
  ports:
  - name: grpc
    port: 50051
  selector:
    app: todo-envoy</span></pre>
<p><span class="koboSpan" id="kobo.1638.1">Then we </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.1639.1">need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1640.1">Deployment</span></strong><span class="koboSpan" id="kobo.1641.1">. </span><span class="koboSpan" id="kobo.1641.2">This time, as we are in a development setting, we will deploy only one Pod for Envoy. </span><span class="koboSpan" id="kobo.1641.3">All the rest of the configuration is similar to what we did with our gRPC server. </span><span class="koboSpan" id="kobo.1641.4">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1642.1">envoy/deployment.yaml</span></strong><span class="koboSpan" id="kobo.1643.1">, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1644.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1645.1">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: todo-envoy
  labels:
    app: todo-envoy
spec:
  </span><strong class="bold"><span class="koboSpan" id="kobo.1646.1">replicas: 1</span></strong><span class="koboSpan" id="kobo.1647.1">
  selector:
    matchLabels:
      app: todo-envoy
  template:
    metadata:
      labels:
        app: todo-envoy
    spec:
      containers:
      - name: todo-envoy
        image: clementjean/grpc-go-packt-book:envoy-proxy
        </span><strong class="bold"><span class="koboSpan" id="kobo.1648.1">imagePullPolicy: Always</span></strong><span class="koboSpan" id="kobo.1649.1">
        ports:
          - name: grpc
            containerPort: 50051</span></pre>
<p><span class="koboSpan" id="kobo.1650.1">We can</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.1651.1"> now run all of this. </span><span class="koboSpan" id="kobo.1651.2">I am assuming</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.1652.1"> that you did not tear down the previous step that we did for deploying microservices. </span><span class="koboSpan" id="kobo.1652.2">Right now, you should have </span><span class="No-Break"><span class="koboSpan" id="kobo.1653.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1654.1">$ kubectl get pods</span></strong><span class="koboSpan" id="kobo.1655.1">
NAME                           READY   STATUS
</span><strong class="bold"><span class="koboSpan" id="kobo.1656.1">todo-server-7d874bfbdb-2cqjn</span></strong><span class="koboSpan" id="kobo.1657.1">   1/1     </span><strong class="bold"><span class="koboSpan" id="kobo.1658.1">Running</span></strong><span class="koboSpan" id="kobo.1659.1">
todo-server-7d874bfbdb-gzfch   1/1     </span><strong class="bold"><span class="koboSpan" id="kobo.1660.1">Running</span></strong><span class="koboSpan" id="kobo.1661.1">
todo-server-7d874bfbdb-hkmtp   1/1     </span><strong class="bold"><span class="koboSpan" id="kobo.1662.1">Running</span></strong></pre>
<p><span class="koboSpan" id="kobo.1663.1">So, now we can first add the service and then the deployment </span><span class="No-Break"><span class="koboSpan" id="kobo.1664.1">for Envoy:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1665.1">$ kubectl apply -f envoy/service.yaml</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1666.1">$ kubectl apply -f envoy/deployment.yaml</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1667.1">$ kubectl get pods</span></strong><span class="koboSpan" id="kobo.1668.1">
NAME                           READY   STATUS
</span><strong class="bold"><span class="koboSpan" id="kobo.1669.1">todo-envoy-64db4dcb9c-s2726</span></strong><span class="koboSpan" id="kobo.1670.1">    1/1     </span><strong class="bold"><span class="koboSpan" id="kobo.1671.1">Running</span></strong><span class="koboSpan" id="kobo.1672.1">
todo-server-7d874bfbdb-2cqjn   1/1     Running
todo-server-7d874bfbdb-gzfch   1/1     Running
todo-server-7d874bfbdb-hkmtp   1/1     Running</span></pre>
<p><span class="koboSpan" id="kobo.1673.1">Finally, before</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.1674.1"> running the client, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1675.1">port-forward</span></strong><span class="koboSpan" id="kobo.1676.1"> command to forward Envoy’s port </span><strong class="source-inline"><span class="koboSpan" id="kobo.1677.1">50051</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1678.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1679.1">localhost:50051</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1680.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1681.1">$ kubectl port-forw</span><a id="_idTextAnchor981"/><span class="koboSpan" id="kobo.1682.1">ard pod/todo-envoy-64db4dcb9c-s2726</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1683.1">  50051</span></strong><span class="koboSpan" id="kobo.1684.1">
Forwarding from 127.0.0.1:50051 -&gt; 50051
Forwarding</span><a id="_idTextAnchor982"/><span class="koboSpan" id="kobo.1685.1"> from [::1]:50051 -&gt; 50051</span></pre>
<p><span class="koboSpan" id="kobo.1686.1">We can then run</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.1687.1"> the client and we should be able to get </span><span class="No-Break"><span class="koboSpan" id="kobo.1688.1">some results:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1689.1">$ go run ./client 0.0.0.0:50051</span></strong><span class="koboSpan" id="kobo.1690.1">
//...
</span><span class="koboSpan" id="kobo.1690.2">error while receiving: rpc error: code = Internal desc =
unexpected error: task with id 1 not found</span></pre>
<p><span class="koboSpan" id="kobo.1691.1">Notice that because of the load balancing and the fact that we do not use a real database, the Pods are not able to find tasks that are stored in other Pods’ memory. </span><span class="koboSpan" id="kobo.1691.2">This is normal in our case, but in production, you would be relying on a shared database and these problems would </span><span class="No-Break"><span class="koboSpan" id="kobo.1692.1">not arise.</span></span></p>
<p><span class="koboSpan" id="kobo.1693.1">To conclude, we saw that we can instantiate Envoy in front of our services to redirect requests with a certain load-balancing policy. </span><span class="koboSpan" id="kobo.1693.2">This time, contrary to the load balancing we saw in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1694.1">chapter7</span></strong><span class="koboSpan" id="kobo.1695.1">, the client does not actually know any addresses for the servers. </span><span class="koboSpan" id="kobo.1695.2">It connects to Envoy and Envoy</span><a id="_idTextAnchor983"/><span class="koboSpan" id="kobo.1696.1"> is redirecting requests and responses. </span><span class="koboSpan" id="kobo.1696.2">We obviously did not cover all the possible configurations for Envoy and I would recommend that you check out other features, such as rate limiting </span><span class="No-Break"><span class="koboSpan" id="kobo.1697.1">and authentication.</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor984"/><span class="koboSpan" id="kobo.1698.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1699.1">In this chapter, we covered unit and load testing. </span><span class="koboSpan" id="kobo.1699.2">We saw that we can find bugs and performance issues by extensively testing different parts of our system. </span><span class="koboSpan" id="kobo.1699.3">Then, we saw how to debug our application when we found a bug. </span><span class="koboSpan" id="kobo.1699.4">We used server reflection and grpcurl to interact with our API from the terminal. </span><span class="koboSpan" id="kobo.1699.5">Finally, we saw how we can containerize our services and deploy them on Kubernetes. </span><span class="koboSpan" id="kobo.1699.6">We saw that we can create headless services to expose our microservices with a DNS A record per gRPC server, and we saw that we can put Envoy in front of them to do load balancing, rate limiting, authentication, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1700.1">so on.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor985"/><span class="koboSpan" id="kobo.1701.1">Quiz</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1702.1">What tool is useful for </span><span class="No-Break"><span class="koboSpan" id="kobo.1703.1">load testing?</span></span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.1704.1">Wireshark</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1705.1">grpcurl</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1706.1">ghz</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1707.1">In Wireshark, what information can you </span><span class="No-Break"><span class="koboSpan" id="kobo.1708.1">look at?</span></span><ol><li><span class="koboSpan" id="kobo.1709.1">gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.1710.1">HTTP/2 frames</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1711.1">Protobuf messages</span></span></li><li><span class="koboSpan" id="kobo.1712.1">All </span><span class="No-Break"><span class="koboSpan" id="kobo.1713.1">of them</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.1714.1">What is Envoy </span><span class="No-Break"><span class="koboSpan" id="kobo.1715.1">used for?</span></span><ol><li><span class="koboSpan" id="kobo.1716.1">Redirecting requests </span><span class="No-Break"><span class="koboSpan" id="kobo.1717.1">and responses</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1718.1">Logging</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1719.1">Exposing metrics</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1720.1">Load balancing</span></span></li><li><span class="koboSpan" id="kobo.1721.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.1722.1">and D</span></span></li><li><span class="koboSpan" id="kobo.1723.1">B </span><span class="No-Break"><span class="koboSpan" id="kobo.1724.1">and C</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-186"><a id="_idTextAnchor986"/><span class="koboSpan" id="kobo.1725.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1726.1">C</span></li>
<li><span class="koboSpan" id="kobo.1727.1">C</span></li>
<li><span class="koboSpan" id="kobo.1728.1">E</span></li>
</ol>
<h1 id="_idParaDest-187"><a id="_idTextAnchor987"/><span class="koboSpan" id="kobo.1729.1">Challenges</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.1730.1">Add support for a real database. </span><span class="koboSpan" id="kobo.1730.2">You should be able to do so by implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1731.1">db</span></strong><span class="koboSpan" id="kobo.1732.1"> interface and creating an instance of your struct in the registered </span><span class="No-Break"><span class="koboSpan" id="kobo.1733.1">server instance.</span></span></li>
<li><span class="koboSpan" id="kobo.1734.1">Expose the Prometheus metrics in your Kubernetes cluster. </span><span class="koboSpan" id="kobo.1734.2">You can take a look at </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1735.1">prometheus-operator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1736.1"> (</span></span><a href="https://github.com/prometheus-operator/prometheus-operator"><span class="No-Break"><span class="koboSpan" id="kobo.1737.1">https://github.com/prometheus-operator/prometheus-operator</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1738.1">).</span></span></li>
</ul>
</div>
<div class="Content" id="_idContainer030">
<h1 id="_idParaDest-188"><a id="_idTextAnchor988"/><span class="koboSpan" id="kobo.1739.1">Epilogue</span></h1>
<p><span class="koboSpan" id="kobo.1740.1">As we reach the end of this book on building gRPC microservices in Golang, I hope you have found gRPC Go interesting and useful, and that you are willing to try it on your next project. </span><span class="koboSpan" id="kobo.1740.2">This book is the book I wish I had when I started learning this awesome technology and I hope this helped you in </span><span class="No-Break"><span class="koboSpan" id="kobo.1741.1">any way.</span></span></p>
<p><span class="koboSpan" id="kobo.1742.1">Throughout this book, we both explored some elements of theory and some practical implementations of gRPC services. </span><span class="koboSpan" id="kobo.1742.2">From learning the networking concepts to the pure implementation and tool that we can use, passing by learning useful considerations when designing an API, you learned the most important skills that you will need for your career as </span><span class="No-Break"><span class="koboSpan" id="kobo.1743.1">backend engineer.</span></span></p>
<p><span class="koboSpan" id="kobo.1744.1">To conclude this book, I would like to invite you to stay up to date with all the topics related to gRPC and Protobuf. </span><span class="koboSpan" id="kobo.1744.2">You can do that by following GitHub Topics, read some blog post or simply getting involved in some open source project. </span><span class="koboSpan" id="kobo.1744.3">This is a fascinating area of backend engineering that needs more attention, more help by building tools, and more people to form communities all around </span><span class="No-Break"><span class="koboSpan" id="kobo.1745.1">the world.</span></span></p>
<p><span class="koboSpan" id="kobo.1746.1">Thank you for accompanying me on this journey to make production-grade gRPC APIs. </span><span class="koboSpan" id="kobo.1746.2">I wish you the very best in your future endeavors. </span><span class="koboSpan" id="kobo.1746.3">May you create innovative and effective APIs. </span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.1747.1">Happy engineering!</span></span></p>
</div>
</body></html>