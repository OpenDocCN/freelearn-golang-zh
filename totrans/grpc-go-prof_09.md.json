["```go\nfunc Creds(c credentials.TransportCredentials) ServerOption {\n  return newFuncServerOption(func(o *serverOptions) {\n    o.creds = c\n  })\n}\n```", "```go\nfunc IsAvailable(a bool) TestOption {\n  return newFuncTestOption(func(o *testOptions) {\n    o.isAvailable = a\n  })\n}\n```", "```go\ntype FakeDb struct {\n  d *inMemoryDb\n  opts testOptions\n}\nfunc NewFakeDb(opt ...TestOption) *FakeDb {\n  opts := defaultTestOptions\n  for _, o := range opt {\n    o.apply(&opts)\n  }\n  return &FakeDb{\n    d: &inMemoryDb{},\n    opts: opts,\n  }\n}\nfunc (db *FakeDb) Reset() {\n  db.opts = defaultTestOptions\n  db.d = &inMemoryDb{}\n}\n```", "```go\nNewFakeDb()\nNewFakeDb(IsAvailable(false))\n```", "```go\nfunc (db *FakeDb) addTask(description string, dueDate\n  time.Time) (uint64, error) {\n  if !db.opts.isAvailable {\n    return 0, fmt.Errorf(\n      \"couldn't access the database\",\n    )\n  }\n  return db.d.addTask(description, dueDate)\n}\n```", "```go\nimport (\n  \"context\"\n  \"log\"\n  \"net\"\n  pb \"github.com/PacktPublishing/gRPC-Go-for-Professionals/\n    proto/todo/v2\"\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/test/bufconn\"\n)\nconst bufSize = 1024 * 1024\nvar lis *bufconn.Listener\nvar fakeDb *FakeDb = NewFakeDb()\nfunc init() {\n  lis = bufconn.Listen(bufSize)\n  s := grpc.NewServer()\n  var testServer *server = &server{\n    d: fakeDb,\n  }\n  pb.RegisterTodoServiceServer(s, testServer)\n  go func() {\n    if err := s.Serve(lis); err != nil && err.Error() !=\n        \"closed\" {\n      log.Fatalf(\"Server exited with error: %v\\n\", err)\n    }\n  }()\n}\nfunc bufDialer(context.Context, string) (net.Conn, error) {\n  return lis.Dial()\n}\n```", "```go\nfunc newClient(t *testing.T) (*grpc.ClientConn,\n  pb.TodoServiceClient) {\n  ctx := context.Background()\n  creds := grpc.WithTransportCredentials\n    (insecure.NewCredentials())\n  conn, err := grpc.DialContext(ctx, \"bufnet\",\n    grpc.WithContextDialer(bufDialer), creds)\n  if err != nil {\n    t.Fatalf(\"failed to dial bufnet: %v\", err)\n  }\n  return conn, pb.NewTodoServiceClient(conn)\n}\n```", "```go\nfunc errorIs(err error, code codes.Code, msg string) bool {\n  if err != nil {\n    if s, ok := status.FromError(err); ok {\n      if code == s.Code() && s.Message() == msg {\n        return true\n      }\n    }\n  }\n  return false\n}\n```", "```go\nfunc TestRunAll(t *testing.T) {\n}\n```", "```go\nfunc TestRunAll(t *testing.T) {\n  t.Run(\"AddTaskTests\", func(t *testing.T) {\n    //...\n  })\n  t.Cleanup(func() {\n    lis.Close()\n  })\n}\n```", "```go\nconst (\n  errorInvalidDescription = \"invalid AddTaskRequest\n    .Description: value length must be at least 1 runes\"\n)\nfunc testAddTaskEmptyDescription(t *testing.T) {\n  conn, c := newClient(t)\n  defer conn.Close()\n  req := &pb.AddTaskRequest{}\n  _, err := c.AddTask(context.TODO()), req)\n  if !errorIs(err, codes.Unknown, errorInvalidDescription) {\n    t.Errorf(\n      \"expected Unknown with message \\\"%s\\\", got %v\",\n      errorInvalidDescription, err,\n    )\n  }\n}\n```", "```go\nfunc TestRunAll(t *testing.T) {\n  t.Run(\"AddTaskTests\", func(t *testing.T) {\n    t.Run(\"TestAddTaskEmptyDescription\",\n       testAddTaskEmptyDescription)\n  }\n  //...\n}\n```", "```go\n$ go test -run ^TestRunAll$ ./server\nok\n```", "```go\nconst (\n  //...\n  errorNoDatabaseAccess = \"unexpected error: couldn't\n    access the database\"\n)\nfunc testAddTaskUnavailableDb(t *testing.T) {\n  conn, c := newClient(t)\n  defer conn.Close()\n  newDb := NewFakeDb(IsAvailable(false))\n  *fakeDb = *newDb\n  req := &pb.AddTaskRequest{\n    Description: \"test\",\n    DueDate: timestamppb.New(time.Now().Add(5 *\n        time.Hour)),\n  }\n  _, err := c.AddTask(context.TODO(), req)\n  fakeDb.Reset()\n  if !errorIs(err, codes.Internal, errorNoDatabaseAccess) {\n    t.Errorf(\"expected Internal, got %v\", err)\n  }\n}\n```", "```go\nfunc testListTasks(t *testing.T) {\n  conn, c := newClient(t)\n  defer conn.Close()\n  fakeDb.d.tasks = []*pb.Task{\n    {}, {}, {}, // 3 empty tasks\n  }\n  expectedRead := len(fakeDb.d.tasks)\n  req := &pb.ListTasksRequest{}\n  count := 0\n  res, err := c.ListTasks(context.TODO(), req)\n\n  if err != nil {\n    t.Errorf(\"unexpected error: %v\", err)\n  }\n  for {\n    _, err := res.Recv()\n    if err == io.EOF {\n      break\n    }\n    if err != nil {\n      t.Errorf(\"error while reading stream: %v\", err)\n    }\n    count++\n  }\n  if count != expectedRead {\n    t.Errorf(\n      \"expected reading %d tasks, read %d\",\n      expectedRead, count,\n    )\n  }\n}\n```", "```go\nfunc testUpdateTasks(t *testing.T) {\n  conn, c := newClient(t)\n  defer conn.Close()\n  fakeDb.d.tasks = []*pb.Task{\n    {Id: 0, Description: \"test1\"},\n    {Id: 1, Description: \"test2\"},\n    {Id: 2, Description: \"test3\"},\n  }\n  requests := []*pb.UpdateTasksRequest{\n    {Id: 0}, {Id: 1}, {Id: 2},\n  }\n  expectedUpdates := len(requests)\n  stream, err := c.UpdateTasks(context.TODO())\n  count := 0\n  if err != nil {\n    t.Errorf(\"unexpected error: %v\", err)\n  }\n  for _, req := range requests {\n    if err := stream.Send(req); err != nil {\n      t.Fatal(err)\n    }\n    count++\n  }\n  _, err = stream.CloseAndRecv()\n  if err != nil {\n    t.Errorf(\"unexpected error: %v\", err)\n  }\n  if count != expectedUpdates {\n    t.Errorf(\n      \"expected updating %d tasks, updated %d\",\n      expectedUpdates, count,\n    )\n  }\n}\n```", "```go\ntype countAndError struct {\n  count int\n  err error\n}\n```", "```go\nfunc sendRequestsOverStream(stream\n  pb.TodoService_DeleteTasksClient, requests\n    []*pb.DeleteTasksRequest, waitc chan countAndError) {\n  for _, req := range requests {\n    if err := stream.Send(req); err != nil {\n      waitc <- countAndError{err: err}\n      close(waitc)\n      return\n    }\n  }\n  if err := stream.CloseSend(); err != nil {\n    waitc <- countAndError{err: err}\n    close(waitc)\n  }\n}\n```", "```go\nfunc readResponsesOverStream(stream\n  pb.TodoService_DeleteTasksClient, waitc chan\n    countAndError) {\n  count := 0\n\n  for {\n    _, err := stream.Recv()\n    if err == io.EOF {\n      break\n    }\n    if err != nil {\n      waitc <- countAndError{err: err}\n      close(waitc)\n      return\n    }\n    count++\n  }\n  waitc <- countAndError{count: count}\n  close(waitc)\n}\n```", "```go\nfunc testDeleteTasks(t *testing.T) {\n  conn, c := newClient(t)\n  defer conn.Close()\n  fakeDb.d.tasks = []*pb.Task{\n    {Id: 1}, {Id: 2}, {Id: 3},\n  }\n  expectedRead := len(fakeDb.d.tasks)\n  waitc := make(chan countAndError)\n  requests := []*pb.DeleteTasksRequest{\n    {Id: 1}, {Id: 2}, {Id: 3},\n  }\n  stream, err := c.DeleteTasks(context.TODO())\n  if err != nil {\n    t.Errorf(\"unexpected error: %v\", err)\n  }\n  go sendRequestsOverStream(stream, requests, waitc)\n  go readResponsesOverStream(stream, waitc)\n  countAndError := <-waitc\n  if countAndError.err != nil {\n    t.Errorf(\"expected error: %v\", countAndError.err)\n  }\n  if countAndError.count != expectedRead {\n    t.Errorf(\n      \"expected reading %d responses, read %d\",\n      expectedRead, countAndError.count,\n    )\n  }\n}\n```", "```go\n$ go test -run ^TestRunAll$ ./server\nok\n```", "```go\n$ go test -run ^TestRunAll$ -v ./server\n--- PASS: TestRunAll\n    --- PASS: TestRunAll/AddTaskTests\n        --- PASS: TestRunAll/AddTaskTests/\n          TestAddTaskUnavailableDb\n        --- PASS:\n//...\nPASS\n```", "```go\n$ bazel run //:gazelle\n```", "```go\n$ bazel run //server:server_test\nPASS\n```", "```go\n$ bazel run //server:server_test --test_arg=-test.v\n--- PASS: TestRunAll\n    --- PASS: TestRunAll/AddTaskTests\n        --- PASS: TestRunAll/AddTaskTests/\n          TestAddTaskUnavailableDb\n        --- PASS:\n//...\nPASS\n```", "```go\n$ ghz --help\n```", "```go\n$ go run ./server 0.0.0.0:50051 0.0.0.0:50052\nmetrics server listening at 0.0.0.0:50052\ngRPC server listening at 0.0.0.0:50051\n```", "```go\n$ ghz --proto ./proto/todo/v2/todo.proto \\\n      --import-paths=proto               \\\n      --call todo.v2.TodoService.AddTask \\\n      --data '{\"description\":\"task\"}'    \\\n      0.0.0.0:50051\n```", "```go\nconnection error: desc = \"transport: authentication\nhandshake failed: tls: failed to verify certificate: x509:\n\"test-server1\" certificate is not standards compliant\"\n```", "```go\n$ ghz #... \\\n      --cacert ./certs/ca_cert.pem \\\n      0.0.0.0:50051\n```", "```go\n$ ghz #... \\\n      --cacert ./certs/ca_cert.pem \\\n      --cname \"check.test.example.com\" \\\n      0.0.0.0:50051\n```", "```go\nUnauthenticated desc = failed to get auth_token\n```", "```go\nghz #... \\\n    --metadata '{\"auth_token\":\"authd\"}' \\\n    0.0.0.0:50051\n```", "```go\n$ ghz --proto ./proto/todo/v2/todo.proto \\\n      --import-paths=proto                \\\n      --call todo.v2.TodoService.AddTask  \\\n      --data '{\"description\":\"task\"}'     \\\n      --cacert ./certs/ca_cert.pem        \\\n     --cname \"check.test.example.com\"    \\\n      --metadata '{\"auth_token\":\"authd\"}' \\\n      0.0.0.0:50051\nSummary:\n  Count:    200\n  Total:    22.89 ms\n  Slowest:    16.70 ms\n  Fastest:    0.20 ms\n  Average:    4.60 ms\n  Requests/sec:    8736.44\nResponse time histogram:\n  0.204  [1]   |\n  1.854  [111] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎\n  3.504  [38]  |∎∎∎∎∎∎∎∎∎∎∎∎∎∎\n  5.153  [0]   |\n  6.803  [0]   |\n  8.453  [0]   |\n  10.103 [0]   |\n  11.753 [0]   |\n  13.403 [2]   |∎\n  15.053 [26]  |∎∎∎∎∎∎∎∎∎\n  16.703 [22]  |∎∎∎∎∎∎∎∎\nLatency distribution:\n  10 % in 0.33 ms\n  25 % in 0.78 ms\n  50 % in 1.75 ms\n  75 % in 2.39 ms\n  90 % in 15.12 ms\n  95 % in 15.31 ms\n  99 % in 16.48 ms\nStatus code distribution:\n  [OK]   200 responses\n```", "```go\nStatus code distribution:\n  [Unavailable] 3 responses\n  [PermissionDenied] 3 responses\n  [OK] 186 responses\n  [Internal] 8 responses\n```", "```go\nError distribution:\n[8] rpc error: code = Internal desc = Internal error.\n[3] rpc error: code = PermissionDenied desc = Permission\n  denied.\n[3] rpc error: code = Unavailable desc = Service unavailable.\n```", "```go\nimport (\n  //...\n  \"google.golang.org/grpc/reflection\"\n)\nfunc newGrpcServer(lis net.Listener, srvMetrics\n  *grpcprom.ServerMetrics) (*grpc.Server, error) {\n  //...\n  s := grpc.NewServer(opts...)\n  pb.RegisterTodoServiceServer(/*…*/)\n  reflection.Register(s)\n  return s, nil\n}\n```", "```go\n$ grpcurl  -cacert ./certs/ca_cert.pem \\\n           -authority \"check.test.example.com\" \\\n           -reflect-header 'auth_token: authd' \\\n           0.0.0.0:50051 list\n```", "```go\ngrpc.reflection.v1alpha.ServerReflection\ntodo.v2.TodoService\n```", "```go\n$ grpcurl  -cacert ./certs/ca_cert.pem \\\n           -authority \"check.test.example.com\" \\\n           -reflect-header 'auth_token: authd' \\\n           0.0.0.0:50051 describe todo.v2.TodoService\n```", "```go\ntodo.v2.TodoService is a service:\nservice TodoService {\n  rpc AddTask ( .todo.v2.AddTaskRequest ) returns (\n    .todo.v2.AddTaskResponse );\n  rpc DeleteTasks ( stream .todo.v2.DeleteTasksRequest )\n    returns ( stream .todo.v2.DeleteTasksResponse );\n  rpc ListTasks ( .todo.v2.ListTasksRequest ) returns (\n    stream .todo.v2.ListTasksResponse );\n  rpc UpdateTasks ( stream .todo.v2.UpdateTasksRequest )\n    returns ( .todo.v2.UpdateTasksResponse );\n}\n```", "```go\n$ grpcurl -cacert ./certs/ca_cert.pem \\\n          -authority \"check.test.example.com\" \\\n          -reflect-header 'auth_token: authd' \\\n          0.0.0.0:50051 describe todo.v2.AddTaskRequest\ntodo.v2.AddTaskRequest is a message:\nmessage AddTaskRequest {\n  string description = 1 [(.validate.rules) = {\n    string:<min_len:1> }];\n  .google.protobuf.Timestamp due_date = 2\n    [(.validate.rules) = { timestamp:<gt_now:true> }];\n}\n```", "```go\n$ grpcurl -cacert ./certs/ca_cert.pem \\\n               -authority \"check.test.example.com\" \\\n               -rpc-header 'auth_token: authd' \\\n               -reflect-header 'auth_token: authd' \\\n               -d '' \\\n               -use-reflection \\\n               0.0.0.0:50051 todo.v2.TodoService.AddTask\n```", "```go\nERROR:\n  Code: Unknown\n  Message: invalid AddTaskRequest.Description: value length\n    must be at least 1 runes\n```", "```go\n$ grpcurl #... \\\n               -d '{\"notexisting\": true}' \\\n               0.0.0.0:50051 todo.v2.TodoService.AddTask\nError invoking method \"todo.v2.TodoService.AddTask\": error\ngetting request data: message type todo.v2.AddTaskRequest\nhas no known field named notexisting\n```", "```go\n$ grpcurl #… \\\n          -d '{\"description\": \"a task!\"}' \\\n          0.0.0.0:50051 todo.v2.TodoService.AddTask\n$ grpcurl #… \\\n          -d '{\"description\": \"another task!\"}' \\\n          0.0.0.0:50051 todo.v2.TodoService.AddTask\n```", "```go\n$ grpcurl #... \\\n               -d '' \\\n               0.0.0.0:50051 todo.v2.TodoService.ListTasks\n{\n  \"task\": {\n    \"id\": \"1\",\n    \"description\": \"a task!\",\n    \"dueDate\": \"1970-01-01T00:00:00Z\"\n  },\n  \"overdue\": true\n}\n{\n  \"task\": {\n    \"id\": \"2\",\n    \"description\": \"another task!\",\n    \"dueDate\": \"1970-01-01T00:00:00Z\"\n  },\n  \"overdue\": true\n}\n```", "```go\n$ grpcurl #… \\\n          -d @ \\\n          0.0.0.0:50051 todo.v2.TodoService.UpdateTasks <<EOF\n{ \"id\": 1, \"description\": \"a better task!\" }\n{ \"id\": 2, \"description\": \"another better task!\" }\nEOF\n```", "```go\n$ $Messages = @\"\n{ \"id\": 1, \"description\": \"new description\" }\n{ \"id\": 2, \"description\": \"new description\" }\n\"@\n$ grpcurl #… \\\n          -d $Messages \\\n           0.0.0.0:50051 todo.v2.TodoService.UpdateTasks\n```", "```go\ngoogle.protobuf.Timestamp due_date = 2 [\n  (validate.rules).timestamp.gt_now = true,\n  (validate.rules).timestamp.required = true\n];\n```", "```go\n$ protoc -Iproto --validate_out=\"lang=go,\npaths=source_relative:proto\" proto/todo/v2/*.proto\n```", "```go\n$ go run ./server 0.0.0.0:50051 0.0.0.0:50052\nmetrics server listening at 0.0.0.0:50052\ngRPC server listening at 0.0.0.0:50051\n```", "```go\n$ grpcurl #… \\\n-d '{\"description\": \"a task!\"}' \\\n          0.0.0.0:50051 todo.v2.TodoService.AddTask\nERROR:\n  Code: Unknown\n  Message: invalid AddTaskRequest.DueDate: value is\n    required\n```", "```go\n$ ghz #… \\\n    -d '{\"description\":\"task\", \"due_date\": \"2523-06-01T14\n    :18:25+00:00\"}' \\\n    0.0.0.0:50051\n```", "```go\n$ bazel run //:gazelle\n```", "```go\n$ bazel run //server:server 0.0.0.0:50051 0.0.0.0:50052\n```", "```go\nfunc newGrpcServer(lis net.Listener, srvMetrics\n  *grpcprom.ServerMetrics) (*grpc.Server, error) {\n  var credsOpt grpc.ServerOption\n  enableTls := os.Getenv(\"ENABLE_TLS\") != \"false\"\n  if enableTls {\n    creds, err := credentials.NewServerTLSFromFile(\n      \"./certs/server_cert.pem\", \"./certs/server_key.pem\")\n    if err != nil {\n      return nil, err\n    }\n    credsOpt = grpc.Creds(creds)\n  }\n  //...\n  opts := []grpc.ServerOption{/*…*/}\n  if credsOpt != nil {\n    opts = append(opts, credsOpt)\n  }\n  //...\n}\n```", "```go\nfunc main() {\n  //...\n  var credsOpt grpc.DialOption\n  enableTls := os.Getenv(\"ENABLE_TLS\") != \"false\"\n  if enableTls {\n    creds, err := credentials.NewClientTLSFromFile\n      (\"./certs/ca_cert.pem\", \"x.test.example.com\")\n    if err != nil {\n      log.Fatalf(\"failed to load credentials: %v\", err)\n    }\n    credsOpt = grpc.WithTransportCredentials(creds)\n  } else {\n    credsOpt = grpc.WithTransportCredentials\n      (insecure.NewCredentials())\n  }\n  //...\n  opts := []grpc.DialOption{\n    credsOpt,\n    //...\n  }\n  //...\n}\n```", "```go\n$ ENABLE_TLS=false go run ./server 0.0.0.0:50051\n0.0.0.0:50052\n```", "```go\n$ $env:ENABLE_TLS='false'; go run ./server 0.0.0.0:50051\n0.0.0.0:50052; $env:ENABLE_TLS=$null\n```", "```go\n$ ENABLE_TLS=false go run ./client 0.0.0.0:50051\n```", "```go\n$ $env:ENABLE_TLS='false'; go run ./client 0.0.0.0:50051;\n$env:ENABLE_TLS=$null\n```", "```go\nProtocol Buffers: /todo.v2.TodoService/AddTask,request\n    Message: todo.v2.AddTaskRequest\n        Field(1): description = This is another task\n          (string)\n        Field(2): due_date = 2023-06-01T17:06:20\n          .531406+0800 (message)\n            Message: google.protobuf.Timestamp\n                Field(1): seconds = 1685610380 (int64)\n                Field(2): nanos = 531406000 (int32)\n                [Message Value: 2023-06-01T17:06:\n                  20.531406+0800]\n```", "```go\nHyperText Transfer Protocol 2\n    Stream: DATA, Stream ID: 7, Length 45\n        Length: 45\n        Type: DATA (0)\n        Flags: 0x00\n            0000 .00\\. = Unused: 0x00\n            .... 0... = Padded: False\n            .... ...0 = End Stream: False\n        0... .... .... .... .... .... ... = Reserved: 0x0\n        .000 0000 0000 0000 0000 0000 0000 0111 = Stream\n          Identifier: 7\n        [Pad Length: 0]\n        DATA payload (45 bytes)\n```", "```go\nHyperText Transfer Protocol 2\n    Stream: HEADERS, Stream ID: 13, Length 2\n        Length: 2\n        Type: HEADERS (1)\n        Flags: 0x05, End Headers, End Stream\n            00.0 ..0\\. = Unused: 0x00\n            ..0\\. .... = Priority: False\n            .... 0... = Padded: False\n            .... .1.. = End Headers: True\n            .... ...1 = End Stream: True\n        0... .... .... .... .... .. .... = Reserved: 0x0\n        .000 0000 0000 0000 0000 0000 0000 1101 = Stream\n           Identifier: 13\n        [Pad Length: 0]\n        Header Block Fragment: bfbe\n        [Header Length: 40]\n        [Header Count: 2]\n        Header: grpc-status: 0\n        Header: grpc-message:\n```", "```go\n$ GRPC_GO_LOG_SEVERITY_LEVEL=info go run ./server\n  0.0.0.0:50051 0.0.0.0:50052\nINFO: [core] [Server #1] Server created\nmetrics server listening at 0.0.0.0:50052\ngRPC server listening at 0.0.0.0:50051\nINFO: [core] [Server #1 ListenSocket #2] ListenSocket\ncreated\nshutting down servers, please wait...\nINFO: [core] [Server #1 ListenSocket #2] ListenSocket\ndeleted\ngRPC server shutdown\nmetrics server shutdown\n```", "```go\n$ $env:GRPC_GO_LOG_SEVERITY_LEVEL='info'; go run ./server\n  0.0.0.0:50051 0.0.0.0:50052;\n  $env:GRPC_GO_LOG_SEVERITY_LEVEL=$null\n```", "```go\n$ GRPC_GO_LOG_SEVERITY_LEVEL=info GRPC_GO_LOG\n  _VERBOSITY_LEVEL=99 go run ./server 0.0.0.0:50051\n    0.0.0.0:50052\n```", "```go\nINFO: [core] [Server #1] Server created\n```", "```go\n{\"message\":\"[core] [Server #1] Server created\\n\",\n  \"severity\":\"INFO\"}\n```", "```go\nFROM --platform=$BUILDPLATFORM alpine as protoc\nARG BUILDPLATFORM TARGETOS TARGETARCH\nRUN export PROTOC_VERSION=23.0 \\\n    && export PROTOC_ARCH=$(uname -m | sed\n      s/aarch64/aarch_64/) \\\n    && export PROTOC_OS=$(echo $TARGETOS | sed\n      s/darwin/linux/) \\\n    && export PROTOC_ZIP=protoc-$PROTOC_VERSION-$PROTOC_OS-\n      $PROTOC_ARCH.zip \\\n    && echo \"downloading: \" https://github.com/\n    protocolbuffers/protobuf/releases/download/\n    v$PROTOC_VERSION/$PROTOC_ZIP \\\n    && wget https://github.com/protocolbuffers/protobuf/\n    releases/download/v$PROTOC_VERSION/$PROTOC_ZIP \\\n    && unzip -o $PROTOC_ZIP -d /usr/local bin/protoc\n    'include/*' \\\n    && rm -f $PROTOC_ZIP\n```", "```go\nFROM --platform=$BUILDPLATFORM golang:1.20-alpine as build\nARG BUILDPLATFORM TARGETOS TARGETARCH\nCOPY --from=protoc /usr/local/bin/protoc /usr/local/\nbin/protoc\nCOPY --from=protoc /usr/local/include/google /usr/local/\ninclude/google\nRUN go install google.golang.org/protobuf/cmd/protoc-gen-\ngo@latest\nRUN go install google.golang.org/grpc/cmd/protoc-gen-go-\ngrpc@latest\nRUN go install github.com/envoyproxy/protoc-gen-\nvalidate@latest\nWORKDIR /go/src/proto\nCOPY ./proto .\nRUN protoc –I. \\\n    --go_out=. \\\n    --go_opt=paths=source_relative \\\n    --go-grpc_out=. \\\n    --go-grpc_opt=paths=source_relative \\\n    --validate_out=\"lang=go,paths=source_relative:.\" \\\n    **/*.proto\nWORKDIR /go/src/server\nCOPY ./server .\nRUN go mod download\nRUN CGO_ENABLED=0 GOOS=$TARGETOS GOARCH=$TARGETARCH go\n  build -ldflags=\"-s -w\" -o /go/bin/server\n```", "```go\nFROM scratch\nCOPY ./certs/server_cert.pem ./certs/server_cert.pem\nCOPY ./certs/server_key.pem ./certs/server_key.pem\nCOPY --from=build /go/bin/server /\nEXPOSE 50051 50052\nCMD [\"/server\", \"0.0.0.0:50051\", \"0.0.0.0:50052\"]\n```", "```go\n$ docker buildx create --name mybuild --driver=docker-\n  container\n```", "```go\n$ docker buildx build \\\n  --tag clementjean/grpc-go-packt-book:server \\\n  --file server/Dockerfile \\\n  --platform linux/arm64 \\\n  --builder mybuild \\\n  --load .\n```", "```go\n$ docker image ls\nREPOSITORY                       TAG      SIZE\nclementjean/grpc-go-packt-book   server   10.9MB\n```", "```go\n$ docker run -p 50051:50051 -p 50052:50052\n  clementjean/grpc-go-packt-book:server\nmetrics server listening at 0.0.0.0:50052\ngRPC server listening at 0.0.0.0:50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\napiVersion: v1\nkind: Service\nmetadata:\n  name: todo-server\nspec:\n  clusterIP: None\n  ports:\n  - name: grpc\n    port: 50051\n  selector:\n    app: todo-server\n```", "```go\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: todo-server\n  labels:\n    app: todo-server\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: todo-server\n  template:\n    metadata:\n      labels:\n        app: todo-server\n    spec:\n      containers:\n      - name: todo-server\n        image: clementjean/grpc-go-packt-book:server\n        imagePullPolicy: Always\n        ports:\n        - name: grpc\n          containerPort: 50051\n```", "```go\n$ kubectl apply -f k8s/server.yaml\n```", "```go\n$ kubectl get pods\nNAME                           READY   STATUS\ntodo-server-7d874bfbdb-2cqjn   1/1     Running\ntodo-server-7d874bfbdb-gzfch   1/1     Running\ntodo-server-7d874bfbdb-hkmtp   1/1     Running\n```", "```go\n$ kubectl port-forward pod/todo-server-7d874bfbdb-2cqjn\n50051\nForwarding from 127.0.0.1:50051 -> 50051\nForwarding from [::1]:50051 -> 50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n```", "```go\nnode:\n  id: todo-envoy-proxy\n  cluster: grpc_cluster\nstatic_resources:\n  listeners:\n  - name: listener_grpc\n    address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 50051\n    filter_chains:\n    - filters:\n      - name: envoy.filters.network.http_connection_manager\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions\n          .filters.network.http_connection_manager.\n           v3.HttpConnectionManager\n          stat_prefix: listener_http\n          http_filters:\n          - name: envoy.filters.http.router\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions\n               .filters.http.router.v3.Router\n          route_config:\n            name: route\n            virtual_hosts:\n            - name: vh\n              domains: [\"*\"]\n              routes:\n              - match:\n                  prefix: /todo.v2.TodoService\n                  grpc: {}\n                route:\n                  cluster: grpc_cluster\n```", "```go\nclusters:\n- name: grpc_cluster\n  type: STRICT_DNS\n  http2_protocol_options: {}\n  lb_policy: round_robin\n  load_assignment:\n    cluster_name: grpc_cluster\n    endpoints:\n    - lb_endpoints:\n      - endpoint:\n        address:\n          socket_address:\n            address: \"todo-server.default.svc\n.cluster.local\"\n            port_value: 50051\n```", "```go\nstatic_resources:\n  listeners:\n  - name: listener_grpc\n    address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 50050\n```", "```go\n- endpoint:\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 50051\n```", "```go\n$ go run ./server 0.0.0.0:50051 0.0.0.0:50052\nmetrics server listening at 0.0.0.0:50052\ngRPC server listening at 0.0.0.0:50051\n```", "```go\n$ func-e run -c envoy/envoy.yaml\n```", "```go\n$ go run ./client 0.0.0.0:50050\n--------ADD--------\n2023/06/04 11:36:45 rpc error: code = Unavailable desc =\nlast connection error: connection error: desc = \"transport:\nauthentication handshake failed: tls: first record does not\nlook like a TLS handshake\"\n```", "```go\n#...\nfilter_chains:\n- filters:\n  #...\n  transport_socket:\n  name: envoy.transport_sockets.tls\n  typed_config:\n    \"@type\": type.googleapis.com/envoy.extensions\n      .transport_sockets.tls.v3.DownstreamTlsContext\n      common_tls_context:\n        tls_certificates:\n          - certificate_chain:\n              filename: /etc/envoy/certs/server_cert.pem\n            private_key:\n              filename: /etc/envoy/certs/server_key.pem\n```", "```go\nclusters:\n- name: grpc_cluster\n  #...\n  transport_socket:\n    name: envoy.transport_sockets.tls\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.extensions\n        .transport_sockets.tls.v3.UpstreamTlsContext\n```", "```go\n- certificate_chain:\n    filename: ./certs/server_cert.pem\n  private_key:\n    filename: ./certs/server_key.pem\n```", "```go\n$ func-e run -c envoy/envoy.yaml\n```", "```go\n$ go run ./client 0.0.0.0:50050\n```", "```go\nFROM envoyproxy/envoy-distroless:v1.26-latest\nCOPY ./envoy/envoy.yaml /etc/envoy/envoy.yaml\nCOPY ./certs/server_cert.pem /etc/envoy/certs/\nserver_cert.pem\nCOPY ./certs/server_key.pem /etc/envoy/certs/server_key.pem\nEXPOSE 50051\nCMD [\"--config-path\", \"/etc/envoy/envoy.yaml\"]\n```", "```go\n$ docker buildx build \\\n    --tag clementjean/grpc-go-packt-book:envoy-proxy \\\n    --file ./envoy/Dockerfile \\\n    --platform linux/arm64 \\\n    --builder mybuild \\\n    --load .\n```", "```go\napiVersion: v1\nkind: Service\nmetadata:\n  name: todo-envoy\nspec:\n  clusterIP: None\n  ports:\n  - name: grpc\n    port: 50051\n  selector:\n    app: todo-envoy\n```", "```go\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: todo-envoy\n  labels:\n    app: todo-envoy\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: todo-envoy\n  template:\n    metadata:\n      labels:\n        app: todo-envoy\n    spec:\n      containers:\n      - name: todo-envoy\n        image: clementjean/grpc-go-packt-book:envoy-proxy\n        imagePullPolicy: Always\n        ports:\n          - name: grpc\n            containerPort: 50051\n```", "```go\n$ kubectl get pods\nNAME                           READY   STATUS\ntodo-server-7d874bfbdb-2cqjn   1/1     Running\ntodo-server-7d874bfbdb-gzfch   1/1     Running\ntodo-server-7d874bfbdb-hkmtp   1/1     Running\n```", "```go\n$ kubectl apply -f envoy/service.yaml\n$ kubectl apply -f envoy/deployment.yaml\n$ kubectl get pods\nNAME                           READY   STATUS\ntodo-envoy-64db4dcb9c-s2726    1/1     Running\ntodo-server-7d874bfbdb-2cqjn   1/1     Running\ntodo-server-7d874bfbdb-gzfch   1/1     Running\ntodo-server-7d874bfbdb-hkmtp   1/1     Running\n```", "```go\n$ kubectl port-forward pod/todo-envoy-64db4dcb9c-s2726\n  50051\nForwarding from 127.0.0.1:50051 -> 50051\nForwarding from [::1]:50051 -> 50051\n```", "```go\n$ go run ./client 0.0.0.0:50051\n//...\nerror while receiving: rpc error: code = Internal desc =\nunexpected error: task with id 1 not found\n```"]