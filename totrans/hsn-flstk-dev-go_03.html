<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building Blocks of the Go Language</h1>
                </header>
            
            <article>
                
<p>Welcome to the first chapter of our journey, where we will learn about full stack development in Go. This chapter is dedicated to readers who are not yet familiar with Go. If you are already proficient in the Go language, you can skip this chapter. We'll cover the basic building blocks that form the foundation of the Go language, which will be covered in a brief but practical manner. Then, we'll show you the Go syntax for basic programming constructs like functions and loops. We'll also cover some concepts that are specific to Go like slice, <kbd>panic</kbd>, and <kbd>defer</kbd>. This chapter assumes that you have some familiarity with programming concepts in general (like variables, functions, loops, and conditional statements). This chapter also assumes that you have some familiarity with Terminals, and command lines, as well as the concept of environmental variables.</p>
<p>A very good resource to learn about the Go language from scratch can be found at <a href="http://tour.golang.org" target="_blank">tour.golang.org</a>.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Basic concepts—packages, variables, data types, and pointers</li>
<li>Functions and closures</li>
<li>Conditional statements and loops</li>
<li><kbd>panic</kbd>, <kbd>recover</kbd>, and <kbd>defer</kbd></li>
<li>Go data structures</li>
<li>Go interfaces</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To follow along with this chapter, you can do either of the following:</p>
<ul>
<li>Go to <a href="http://play.golang.org">play.golang.org</a>, which will allow you to run or test your code online</li>
<li>Download the Go programming language, along with a compatible IDE</li>
</ul>
<p>If you haven't downloaded Go yet, you can download the Go language by going to <a href="https://golang.org/dl/">https://golang.org/dl/</a>, downloading the Go flavor for your operating system, and then installing it.</p>
<p>For the local IDE, I prefer Visual Studio Code (<a href="https://code.visualstudio.com">https://code.visualstudio.com</a>), along with its popular Go plugin (<a href="https://code.visualstudio.com/docs/languages/go">https://code.visualstudio.com/docs/languages/go</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Go's playground</h1>
                </header>
            
            <article>
                
<p>The Go playground is a fairly popular website, which allows the Go community to test Go code samples online. The website can be found at <a href="http://play.golang.org" target="_blank">play.golang.org</a>. Whenever you would like to quickly test a simple piece of Go code, visit the website and run your code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Go's workspace</h1>
                </header>
            
            <article>
                
<p>For you to write Go code on your computer, you need to set up a Go workspace. A Go workspace is a folder where you will write your Go code. Setting up a Go workspace is relatively simple. Here is what you will need to do:</p>
<ol>
<li>First, make sure that you have Go installed. As we mentioned earlier, you can download and install Go by going to <a href="https://golang.org/dl/" target="_blank">https://golang.org/dl/</a>.</li>
<li>After installing Go, create a new folder in your computer for Go's workspace. Mine is called <kbd>GoProjects</kbd>.</li>
<li>Inside your Go workspace folder, you will have to create three main folders: <kbd>src</kbd>, <kbd>pkg</kbd>, and <kbd>bin</kbd>. It is very important to create folders with these exact names inside your Go workspace folder. Here is why these three folders are important:
<ul>
<li>The <kbd>src</kbd> folder will host all of your code files. Whenever you decide to start a new program, you will simply go to the <kbd>src</kbd> folder and create a new folder with your new program name.</li>
<li>The <kbd>pkg</kbd> folder typically hosts the compiled package files of your code.</li>
<li>The <kbd>bin</kbd> folder typically hosts the binary files that are produced by your Go programs.</li>
</ul>
</li>
</ol>
<ol start="4">
<li>You will need to set two environmental variables:
<ul>
<li>The first environmental variable is called <kbd>GoRoot</kbd>, and will include the path to your Go install. <kbd>GoRoot</kbd> should typically be taken care of by the Go installer. However, if it's missing, or you would like to move your Go installation to a different place, then you need to set <kbd>GoRoot</kbd>.</li>
<li>The second environmental variable is called <kbd>GoPath</kbd>. <kbd>GoPath</kbd> includes the path to your Go workspace folder. By default, if not set, <kbd>GoPath</kbd> is assumed to either to be at <kbd>$HOME/go</kbd> on Unix systems or <kbd>%USERPROFILE%\go</kbd> on Windows. There is an entire GitHub page which covers setting up <kbd>GoPath</kbd> in different operating systems, which can be found at <a href="https://github.com/golang/go/wiki/SettingGOPATH" target="_blank">https://github.com/golang/go/wiki/SettingGOPATH</a>.</li>
</ul>
</li>
</ol>
<p>Once your Go environment is set up, you can use the Go tool, which is installed alongside the Go language so that you can compile and run your Go programs.</p>
<p>We'll take a look at some of the basic building blocks of the Go language in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Packages, variables, data types, and pointers</h1>
                </header>
            
            <article>
                
<p>Packages, variables, data types, and pointers represent the most basic building blocks of the Go language. In this section, we'll cover them one by one from a practical point of view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Packages</h1>
                </header>
            
            <article>
                
<p>Any Go program consists of one or more packages. Each package is basically a folder, which contains one or more Go files. Every single Go code file you write must belong to a package. Package folders are found inside the <kbd>src</kbd> folder of your Go workspace.</p>
<p>When you write Go code, you declare your package name at the very top of your Go file. Here is what this looks like in code:</p>
<pre>package mypackage</pre>
<p>Here, <kbd>mypackage</kbd> is the name of the package that my Go file belongs to. It's idiomatic in Go to have your package name in lower case letters. It is usually preferable to name your package folder the same as your package name. So, when you create a new package, simply create a new folder with your package name, and then create your package files inside that folder.</p>
<p>To import an external package and use it in your own package, you need to use the <kbd>import</kbd> keyword. For example, a popular package in Go's standard library is the <kbd>fmt</kbd> package, which allows you to write data to the standard output (that is, write to your console screen). Let's assume we want to use the <kbd>fmt</kbd> package from within our package. Here is what the code would look like:</p>
<pre>package mypackage <br/> import "fmt"</pre>
<p>Some package folders can exist inside folders of other packages. For example, the folder that contains the <kbd>rand</kbd> package in Go, which is used to generate random numbers, exists inside the folder that contains the <kbd>math</kbd> package in Go. To import a package like that, you need to use the following syntax:</p>
<pre>import "math/rand"</pre>
<p>Now, what if we would like to import multiple packages at once? It's easy—the syntax will end up looking like this:</p>
<pre class="mce-root">import (<br/> "fmt"<br/> "math/rand"<br/> )</pre>
<p>Go does not allow you to import a package and then not use it to ensure that your code is clean and concise. However, there are some cases (which we'll cover later in this book) where you will want to load a package, but not use it directly. This can be accomplished by appending an underscore before the package name in the import statement. Here is what this would look like:</p>
<div>
<pre>import (<br/> "database/sql"<br/> _ "github.com/go-sql-driver/mysql"<br/>)</pre></div>
<p class="mce-root">The most famous package name is <kbd>main</kbd>. Your main package is the first package that runs in your Go program.</p>
<p class="mce-root">To compile a Go program, you will need to navigate to the folder where your <kbd>main</kbd> package lives in the console, and then type the following command:</p>
<pre><strong>go install</strong></pre>
<p>This command will compile your Go program and then place the resulting binary in the <kbd>bin</kbd> folder of your workspace.</p>
<p>Alternatively, you can run the following command:</p>
<pre><strong>go build</strong></pre>
<p>This command will compile and then deploy the resulting binary in the current folder.</p>
<p>If you would like to specify an output path and a filename, you can run the following command:</p>
<pre><strong>go build -o ./output/myexecutable.exe</strong></pre>
<p>This will compile your code and then package it in an executable called <kbd>myexecutable.exe</kbd> at the specified output folder. If your operating system is not Windows, you can ignore the <kbd>exe</kbd> extension in the preceding example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables and data types</h1>
                </header>
            
            <article>
                
<p>A variable is another basic building block of the Go language. In Go, to declare a variable, you can simply use the <kbd>var</kbd> keyword. Here is what this looks like:</p>
<pre>var s string</pre>
<p>Obviously, <kbd>string</kbd> is the data type. Let's say we would like to declare more than one variable of type string on the same statement. Here is what this would look like:</p>
<pre>var s1,s2,s3 string</pre>
<p>To initialize a variable with an initial value, Go offers a number of options. One option is to initialize the variable while also specifying the variable type. Here is what this looks like:</p>
<pre>var s1,s2,s3 string = "first-string", "second-string", "third-string"</pre>
<p>Another option is to initialize the variables without specifying the data type. Here is what this would look like:</p>
<pre>var s1,s2,s3 = "first-string", "second-string", "third-string"</pre>
<p>We can then mix data types with the following syntax:</p>
<pre>var s,i,f = "mystring",12,14.53</pre>
<p>A popular way to declare and initialize multiple variables at once is as follows:</p>
<pre>var (<br/> s = "mystring"<br/> i = 12<br/> f = 14.53<br/> )</pre>
<p>If you are declaring and initializing your variable inside a function, you don't need to even use the <kbd>var</kbd> keyword. Instead, you can use <kbd>:=</kbd>. This is called <strong>type inference</strong>, since you infer the variable type from the provided value. Here is how we would declare and initialize the <kbd>s</kbd>, <kbd>i</kbd>, and <kbd>f</kbd> variables with type inference:</p>
<pre>s := "mystring"<br/><br/>i := 12<br/><br/>f:=14.53</pre>
<p>The <kbd>var</kbd> keyword, however, gives you more control since it allows you to explicitly specify the data type you would like to use for your variable.</p>
<p>Now, let's discuss data types. Go has a standard set of data types that are very similar to data types you'd find in any other statically typed programming language. Here is a summary of Go's standard data types:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignLeft CDPAlign"><strong>Data type(s)</strong></td>
<td class="CDPAlignLeft CDPAlign"><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>bool</kbd></td>
<td>A Boolean (either true or false).</td>
</tr>
<tr>
<td><kbd>string</kbd></td>
<td>A <kbd>string</kbd> is a collection of <kbd>byte</kbd> and can hold any characters. Strings are read only (immutable), so whenever you need to add or remove characters from a string, you are in effect creating a new string.</td>
</tr>
<tr>
<td>
<p><kbd>int</kbd>, <kbd>int8</kbd>, <kbd>int16</kbd>, <kbd>int32</kbd>, and <kbd>int64</kbd></p>
</td>
<td>Signed integer types. They represent non-decimal numbers that can be either positive or negative. As you can probably tell from the type names, you can explicitly specify the number of bits that it can allow. If you go with the <kbd>int</kbd> type, it will pick the number of bits that correspond to your environment. For most modern CPU architectures, it will pick 64 bits, unless you are working with a smaller CPU or older environment. For smaller CPUs or older environments, the choice becomes 32 bits.</td>
</tr>
<tr>
<td>
<p><kbd>uint</kbd>, <kbd>uint8</kbd>, <kbd>uint16</kbd>, <kbd>uint32</kbd>, <kbd>uint64</kbd>, and <kbd>uintptr</kbd></p>
</td>
<td>Unsigned integer types. <span>They represent non-decimal numbers, which can only be positive. Except for the signage, they are similar to their signed</span> brethren. The <kbd>uintptr</kbd> type is an unsigned integer type that is large enough to hold a memory address.</td>
</tr>
<tr>
<td><kbd>byte</kbd></td>
<td>An alias for <kbd>uint8</kbd>, it holds 8 bits, which basically represents a byte of memory.</td>
</tr>
<tr>
<td><kbd>rune</kbd></td>
<td>An alias for <kbd>int32</kbd>, it is typically used to represent a Unicode character.</td>
</tr>
<tr>
<td>
<p><kbd>float32</kbd> and <kbd>float64</kbd></p>
</td>
<td>Simply decimal numbers. For smaller decimal numbers, use the <kbd>float32</kbd> type, as it only allows 32 bits of data. For larger decimal numbers, use the <kbd>float64</kbd> type, as it only allows 64 bits of data.</td>
</tr>
<tr>
<td>
<p><kbd>complex64</kbd> and <kbd>complex128</kbd></p>
</td>
<td>
<p class="mce-root">Complex numbers. Those data types are useful for programs where serious math is needed. The first type, <kbd>complex64</kbd>, is a complex number where the real part is a 32-bit float, and the imaginary part is a 32-bit float. The second type, <kbd>complex128</kbd>, is a complex number where the real part is a 64-bit float, while the imaginary part is a 64-bit float.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Variables that are declared without an explicit initial values get assigned what is known as <strong>zero values</strong>. Here is a table for zero values:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Type(s)</strong></td>
<td><strong>Zero value</strong></td>
</tr>
<tr>
<td>Numeric types</td>
<td><kbd>0</kbd></td>
</tr>
<tr>
<td>Boolean types</td>
<td><kbd>false</kbd></td>
</tr>
<tr>
<td>String type</td>
<td><kbd>""</kbd></td>
</tr>
<tr>
<td>Pointers</td>
<td><kbd>nil</kbd></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pointers</h1>
                </header>
            
            <article>
                
<p>The concept of pointers is simple—a <strong>pointer</strong> is a language type that represents the memory locations of your values. Pointers in Go are used everywhere, and that's because they give the programmer a lot of power over the code. For example, having access to your value in memory allows you to change the original value from different parts of your code without the need to copy your value around.</p>
<p>In Go, to create a pointer, you just append <kbd>*</kbd> in front of the data type of your value. For example, here is a pointer to an <kbd>int</kbd> value:</p>
<pre class="mce-root">var iptr *int</pre>
<p>As we mentioned in the previous section, the zero value of a pointer is <kbd>nil</kbd>. The behavior of <kbd>nil</kbd> is similar to <kbd>null</kbd> in languages like Java, that is, if you try to use a <kbd>nil</kbd> pointer, an error will get thrown.</p>
<p>Now, let's assume we have a value of type <kbd>int</kbd> called <kbd>x</kbd>:</p>
<pre class="mce-root">var x int = 5</pre>
<p>We also want a pointer to point to the address of <kbd>x</kbd> for later use:</p>
<pre>var xptr = &amp;x</pre>
<p>The <kbd>&amp;</kbd> operand here means that we want the address of <kbd>x</kbd>. Whenever you append the <kbd>&amp;</kbd> operand before a variable, it basically means that we want to the address of that variable.</p>
<p>What if we have a pointer, and we want to retrieve the value that it points to? This operation is called <strong>de-referencing</strong>, and here is how we can do it:</p>
<pre>y := *xptr</pre>
<p>In the preceding code, we de-referenced the pointer <kbd>xptr</kbd> to obtain the value that it points to, and then we stored a copy of the value in a new variable called <kbd>y</kbd>.</p>
<p>What if we want to change the value that the pointer points to? We can still use de-referencing for that, and here is what this would look like:</p>
<pre>*xptr = 4</pre>
<p>Perfect! With this, you should have enough knowledge to use Go pointers in your code.</p>
<p>If you already have experience in pointers from a different programming language like C or C++, you are probably familiar with the concept of pointer arithmetic. This is when you perform arithmetic operations (like addition or subtraction) on pointers to go to different memory addresses. By default, Go does not support pointer arithmetic on vanilla pointers like the ones we described in this section. However, there is a package called <kbd>unsafe</kbd> that allows you to do so. The <kbd>unsafe</kbd> package is only there to give you the power, should you need it. However, it is highly recommended that you don't use it unless you absolutely have to.</p>
<p>Now, let's explore functions and closures in Go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions and closures</h1>
                </header>
            
            <article>
                
<p>It's time to talk about functions and closures, so sit tight and enjoy the journey. Functions are considered one of the key building blocks in any programming language, as they allow you to define actions in your code.</p>
<p>Let's discuss the basics of functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions – the basics</h1>
                </header>
            
            <article>
                
<p>Here is how you write a function in Go:</p>
<pre><span>func main(){<br/></span><span>//do something<br/></span><span>}</span></pre>
<p>The <kbd>main</kbd> function is almost always the first function that gets executed in your Go program. The <kbd>main</kbd> function needs to live inside the <kbd>main</kbd> package, since <kbd>main</kbd> is the entry point package for your Go program.</p>
<p>Here is what a function with arguments would look like:</p>
<pre>func add(a int, b int){<br/>//a+b<br/>}</pre>
<p>Since the <kbd>a</kbd> and <kbd>b</kbd> arguments from the preceding code are of the same type, we can also do this:</p>
<pre>func add(a,b int){<br/>//a+b<br/>}</pre>
<p>Now, let's say we want to return a value from our function. Here is what this would look like:</p>
<pre>func add(a,b int)int{<br/>return a+b<br/>}</pre>
<p>Go also allows multiple returns, so you can do this:</p>
<pre>func addSubtract(a,b int)(int,int){<br/>return a+b,a-b<br/>}</pre>
<p>In Go, there is a concept known as <em>named returns</em>, which basically means that you can name your return values in the function header. Here is what this looks like:</p>
<pre>func addSubtract(a,b int)(add,sub int){<br/>add = a+b<br/>sub = a-b<br/>return<br/>}</pre>
<p>Functions are also first-class citizens in the Go language, which means that you can assign a function to a variable and use it as a value. Here is an example:</p>
<pre>var adder = func(a,b int)int{<br/>return a+b<br/>}<br/>var subtractor = func(a,b int) int{<br/>return a-b<br/>}<br/>var addResult = adder(3,2)<br/>var subResult = subtractor(3,2)</pre>
<p>Because of this, you can also pass functions as arguments to other functions:</p>
<pre>func execute(op func(int,int)int, a,b int) int{<br/>return op(a,b)<br/>}</pre>
<p>Here is an example of us making use of the <kbd>execute</kbd> function we defined previously:</p>
<pre>var adder = func(a, b int) int {<br/>    return a + b<br/>}<br/>execute(adder,3,2)</pre>
<p>Go also supports the concept of variadic functions. A <strong>variadic function</strong> is a function that can take an unspecified number of arguments. Here is an example of an <kbd>adder</kbd> function that takes an unspecified number of <kbd>int</kbd> arguments and then adds them:</p>
<pre>func infiniteAdder(inputs ...int) (sum int) {<br/>  for _, v := range inputs {<br/>    sum += v<br/>  }<br/>  return<br/>}</pre>
<p>The preceding function takes any number of <kbd>int</kbd> arguments and then sums them all. We'll cover the <kbd>for..range</kbd> syntax here later in this chapter, under the <em>Conditional statements and loops</em> section. We can then call our new function using the following syntax:</p>
<pre>infiniteAdder(1,2,2,2) // 1 + 2 + 2 + 2</pre>
<p class="mce-root">We'll look at how functions can be accessed from other packages in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions – accessing functions from other packages</h1>
                </header>
            
            <article>
                
<p>Earlier in this chapter, we covered the concept of packages, and the fact that a Go program is composed of a number of connected packages. So, how do we really connect packages? We connect packages by having the ability to call functions and retrieve types from other packages. But then comes the question, how do we expose a function to other packages?</p>
<p>In Go, there are no <kbd>private</kbd> or <kbd>public</kbd> keywords like in most other statically typed programming languages. If you want your function to be <kbd>public</kbd>, all you need to do is start your function name with an upper case letter. In Go, that is known as making your function <strong>exported</strong>. If, on the other hand, your function starts with a lower case letter, then your function is considered <strong>unexpected</strong>.</p>
<p>To absorb the preceding two paragraphs, let's go through some code. Here is a package called <kbd>adder</kbd>, which contains a single function called <kbd>Add</kbd>:</p>
<pre>package adder<br/><br/>func Add(a,b int)int {<br/>  return a+b<br/>}</pre>
<p>Now, let's say we want to call <kbd>Add</kbd> from a different package. Here is what we'd do:</p>
<pre>package main<br/><br/>//get the adder package<br/>import "adder"<br/><br/>func main() {<br/>  result := adder.Add(4, 3)<br/>  //do something with result<br/>}</pre>
<p>In the preceding code, we called the exported function <kbd>Add</kbd> from our main package, at our <kbd>main</kbd> function. We did two things:</p>
<ul>
<li>Used the <kbd>import</kbd> keyword to load the <kbd>adder</kbd> package</li>
<li>In the main function, we called <kbd>adder.Add(..)</kbd></li>
</ul>
<p>As demoed, to call an exported function, you need to use the following syntax:</p>
<pre>&lt;package name&gt;.&lt;exported function name&gt;</pre>
<p>If in the <kbd>adder</kbd> package we had named our function <kbd>add</kbd> instead of <kbd>Add</kbd>, the preceding code would not have worked. This is because when the function starts with a lower case letter it would be considered unexpected, which in effect means that it will be invisible to other packages.</p>
<p>Let's see a couple of examples from Go's standard package.</p>
<p>A very popular package from the Go standard packages is the <kbd>fmt</kbd> <span>package.</span> The <kbd>fmt</kbd> package can write to the standard output of your environment. It can also format strings and scan data from the standard input, among other things. Here is a simple but very commonly used code snippet:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>)<br/><br/>func main() {<br/>  fmt.Println("Hello Go world!!")<br/>}</pre>
<p>In the preceding code, we called a function called <kbd>Println</kbd>, which lives inside the <kbd>fmt</kbd> package. The <kbd>Println</kbd> function will take your string message and print it on the standard output. The output of the preceding program is as follows:</p>
<pre><strong>Hello Go world!!</strong></pre>
<p>Another popular package in the world of Go is <kbd>math/rand</kbd>, which we can use to generate random numbers. As we mentioned in the <em>Packages </em><span>section</span>, earlier in this chapter, the reason why the package name is not just <kbd>rand</kbd> is simply because the <kbd>rand</kbd> package folder exists underneath the folder of the <kbd>math</kbd> package. So, even though <kbd>rand</kbd> is more of a sub-package, we just use the package name when we need to call exported functions that belong to it. Here is a simple example:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>  "math/rand"<br/>)<br/><br/>func main() {<br/>  fmt.Println("Let's generate a random int", rand.Intn(10))<br/>}</pre>
<p>In the preceding code, we imported two packages—the <kbd>fmt</kbd> package and the <kbd>math/rand</kbd> package. We then invoked two functions from each of the packages. We first invoked the <kbd>Println</kbd> function, which belongs to the <kbd>fmt</kbd> package, to output a string to the standard output. Then, we invoked the <kbd>Intn</kbd> function, which belongs to the <kbd>math/rand</kbd> package, to generate a random number between zero and nine.</p>
<p>Now, let's take a look at what constitutes closures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Closures</h1>
                </header>
            
            <article>
                
<p>A function can also be a closure. A <strong>closure</strong> is a function value that's bound to variables outside its body. This means that a closure can access and change values on those variables. It is hard to understand closures without an example. Here is another flavor of the adder function, which returns a closure:</p>
<pre>func adder() func(int) int {<br/>  sum := 0<br/>  return func(x int) int {<br/>    sum += x<br/>    return sum<br/>  }<br/>}</pre>
<p>The closure in the preceding example has access to the <kbd>sum</kbd> variable, which means that it will remember the current value of the <kbd>sum</kbd> variable, and will also be able to change the value of the <kbd>sum</kbd> variable. Again, this is best explained with another example:</p>
<pre><br/>func adder() func(int) int {<br/>  sum := 0<br/>  return func(x int) int {<br/>    sum += x<br/>    return sum<br/>  }<br/>}<br/><br/>func main() {<br/>  // when we call "adder()",it returns the closure<br/>  sumClosure := adder() // the value of the sum variable is 0<br/>  sumClosure(1) //now the value of the sum variable is 0+1 = 1<br/>  sumClosure(2) //now the value of the sum variable is 1+2=3<br/> //Use the value received from the closure somehow<br/>}</pre>
<p class="mce-root">We have covered the basics of Go. In the following section, we'll move on and discuss Go data structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Go data structures</h1>
                </header>
            
            <article>
                
<p>In this section, we'll discuss more key concepts of the Go language. It's time to explore the foundational data structures that we need to build non-trivial programs in the Go language.</p>
<p>In the following sections, we'll discuss the various Go data structures, including arrays, slices, maps, Go structs, and methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arrays</h1>
                </header>
            
            <article>
                
<p>An array is a common data structure that exists in any programming language. In Go, an array is a collection of values with the same data type, and a pre-defined size.</p>
<p>Here is how to declare an array in Go:</p>
<pre>var myarray [3]int</pre>
<p>The preceding array is of type <kbd>int</kbd> and of size <kbd>3</kbd>.</p>
<p>We can then initialize the array like this:</p>
<pre>myarray = [3]int{1,2,3}</pre>
<p>Or, we can do this:</p>
<pre>//As per the array declaration, it has only 3 items of type int<br/><br/>myarray[0] = 1 //value at index 0<br/>myarray[1] = 2 //value at index 1<br/>myarray[2] = 3 //value at index 2</pre>
<p>Alternatively, similarly to other variables, we can declare and initialize the array on the same line, like this:</p>
<pre>var myarray = [3]int{1,2,3}</pre>
<p>Or, if we are declaring and initializing the array inside a function, we can use the <kbd>:=</kbd> notation:</p>
<pre>myarray := [3]int{1,2,3}</pre>
<p>Go provides a built-in function called <kbd>len()</kbd>, which returns the size/length of your array. For example, let's say we run the following code:</p>
<pre>n := len(myarray)<br/>fmt.Println(n)</pre>
<p>The output will simply be <kbd>3</kbd>, since the size of <kbd>myarray</kbd> is <kbd>3</kbd>.</p>
<p>Go also allows you to capture subarrays of your main array. To do that, you need to follow the following syntax:</p>
<pre>array[&lt;index1&gt;:&lt;index2&gt;+1]</pre>
<p>For example, let's say I declare a new array that looks like this:</p>
<pre>myarray := [5]int{1,2,3,4,5}</pre>
<p>I can obtain a subarray from index two of my array till index three using the following syntax:</p>
<pre>myarray[2:4]</pre>
<p>The output of the preceding code will be as follows:</p>
<pre>[3 4]</pre>
<p>The two indexes that were passed to the preceding syntax were <kbd>2</kbd> to indicate that we would like to start from index two, and then <kbd>4</kbd> to indicate that we would like to stop at index four (<em>3+1=4</em>).</p>
<p>Inside the square brackets of the preceding syntax, you can also leave either side empty. Let's say you leave the left-hand side empty, like this:</p>
<pre>myarray[:4]</pre>
<p>This indicates that you want a subarray from index zero until index three.</p>
<p>However, let's say you leave the right-hand side empty, like this:</p>
<pre>myarray[2:]</pre>
<p>This indicates that the subarray will start from index two until the end of your original array.</p>
<p>Let's say you do something like this:</p>
<pre>mySubArray := myarray[2:4]</pre>
<p><kbd>mySubArray</kbd> is not merely a copy of a subpart of <kbd>myarray</kbd>. In fact, both arrays will point to the same memory. Let's elaborate by using an example. Here is a simple program:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>)<br/><br/>func main() {<br/>  myarray := [5]int{1,2,3,4,5}<br/>  mySubArray := myarray[2:4]<br/>  mySubArray[0] = 2<br/>  fmt.Println(myarray)<br/>}</pre>
<p>This program output <kbd>myarray</kbd>, but it does so after we change a value in <kbd>mySubArray</kbd>. As you can see in the preceding code, the original values in <kbd>myarray</kbd> were <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, <kbd>4</kbd>, and <kbd>5</kbd>. However, because we changed the value at index <kbd>0</kbd> of <kbd>mySubArray</kbd>, which is index <kbd>2</kbd> of <kbd>myarray</kbd>, the output will end up being as follows:</p>
<pre><span class="stdout">[1 2 2 4 5]</span></pre>
<p>Perfect! We now have a solid idea about how to make use of arrays in Go. Let's move on to slices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Slices</h1>
                </header>
            
            <article>
                
<p>There is a very obvious limitation in Go's array data structure—you must specify the size whenever you declare a new array. In real life, there are numerous scenarios where we will not know the number of elements to expect beforehand. Almost every modern programming language comes with its own data structure to address this requirement. In Go, this special data structure is called a <strong>slice</strong>.</p>
<p>From a practical point of view, you can think of slices as simply dynamic arrays. From a syntax point of view, slices look very similar to arrays, except that you don't need to specify the size. Here is an example:</p>
<pre>var mySlice []int</pre>
<p>As you can see, slice declarations are very similar to array declarations, except for the fact that you don't need to specify the number of elements on a slice.</p>
<p>Here is us initializing the preceding slide with some initial values:</p>
<pre>mySlice = []int{1,2,3,4,5}</pre>
<p>Let's declare and then initialize this with some initial values in one go:</p>
<pre>var mySlice = []int{1,2,3,4,5}</pre>
<p>Since slices can grow in size, we are also allowed to initialize an empty slice:</p>
<pre>var mySlice = []int{}</pre>
<p>If you would like to set an initial number of elements in your slice without having to write the initial values by hand, you can utilize a built-in function called <kbd>make</kbd>:</p>
<pre>var mySlice = make([]int,5)</pre>
<p>The preceding code will declare and initialize an <kbd>int</kbd> slice with an initial length of <kbd>5</kbd> elements.</p>
<p>To write efficient Go code that can benefit from slices, you need to first understand how slices work internally.</p>
<p>A slice can simply be considered as a pointer to a part of an array. A slice holds three main pieces of information:</p>
<ul>
<li>A pointer to the first element of the subarray that the slice points to.</li>
<li>The length of the subarray that's exposed to the slice.</li>
<li>The capacity, which is the remaining number of items available in the original array. The capacity is always either equal to the length or greater.</li>
</ul>
<p>This sounds too theoretical, so let's utilize the power of code and some visualization to provide a practical explanation about how slices really work.</p>
<p>Let's assume we created a new slice:</p>
<pre>var mySlice = []int{1,2,3,4,5}</pre>
<p>Internally, the new slice we created points to an array with the <kbd>5</kbd> initial values that we set:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0e483bc4-58e4-4123-bc9d-a01fc27008ff.jpg" style="width:41.83em;height:20.00em;"/></div>
<p>As you can see from the preceding diagram, <kbd>mySlice</kbd> held three pieces of information:</p>
<ul>
<li>The first is a pointer to the array underneath, which holds the data</li>
<li>The second is the length of the slice, which is <kbd>5</kbd> in this case</li>
<li>The third is the full capacity of the slice, which is also <kbd>5</kbd> in this case</li>
</ul>
<p>The preceding diagram, however, doesn't really clarify how the capacity of the slice can be different from its length. To uncover the practical differences between length and capacity, we'll need to dig a bit deeper.</p>
<p>Let's say we decided to extract a subslice from the original slice:</p>
<pre>var subSlice = mySlice[2:4]</pre>
<p>Reslicing <kbd>mySlice</kbd> will not produce a new, smaller copy of the array underneath. Instead, the preceding line of code will produce the following slice:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7baa87c2-4aad-4fc8-b066-00dbc46c87b8.jpg" style="width:43.67em;height:21.17em;"/></div>
<p>Since <kbd>subSlice</kbd> includes the elements at index two and index three of <kbd>mySlice</kbd>, the length of <kbd>subSlice</kbd> is two (remember that an array index starts at zero, which is why index two is the third element and not the second). The capacity is different, however, and that is because the original array has three elements left, starting from index two, so the capacity is three and not two, even though the length is two.</p>
<p>So, in other words, the length of <kbd>subSlice</kbd> is two because <kbd>subSlice</kbd> only cares about two elements. However, the capacity is three because there are three elements left in the original array, starting from index two, which is the index that the <kbd>subSlice</kbd> array pointer points to.</p>
<p>There is a built-in function called <kbd>cap</kbd>, which we can use to get the capacity of a slice:</p>
<pre>cap(subSlice) //this will return 3</pre>
<p>The built-in function called <kbd>len</kbd> that we use for arrays works with slices as well, since it will give you the length of the slice:</p>
<pre>len(subSlice) //this will return 2</pre>
<p>You might be wondering by now, why should I care about the differences between length and capacity? I can just use the length and ignore the capacity altogether, since the capacity only gives you information about a hidden internal array.</p>
<p>The answer is very simple—<strong>memory utilization</strong>. What if <kbd>mySlice</kbd> had 100,000 elements instead of just five? This means that the internal array would have had <span>100,000 elements as well. This huge internal array will exist in our program's memory as long as we use any sub-slices extracted from <kbd>mySlice</kbd>, even if the sub-slices we use only care about two elements.</span></p>
<p>To avoid that kind of memory bloat, we need to explicitly copy the fewer elements we care about into a new slice. By doing this, once we stop using the original large slice, Go's garbage collector will realize that the huge array is not needed anymore and will clean it up.</p>
<p>So, how do we achieve that? This can be done through a built-in function called <kbd>copy</kbd>:</p>
<pre>  //let's assume this is a huge slice<br/>  var myBigSlice = []int{1,2,3,4,5,6}<br/>  //now here is a new slice that is smaller<br/>  var mySubSlice = make([]int,2)<br/>  //we copy two elements from myBigSlice to mySubSlice<br/>  copy(mySubSlice,myBigSlice[2:4])</pre>
<p>Perfect! With this, you should have a fairly practical understanding about slice internals and how to avoid memory bloats in slices.</p>
<p>We keep saying that slices are like dynamic arrays, but we haven't seen how to actually grow the slice yet. Go offers a simple built-in function called <kbd>append</kbd>, which is used to add values to a slice. If you reach the end of your slice capacity, the <kbd>append</kbd> function will create a new slice with a bigger internal array to hold your expanding data. <kbd>append</kbd> is a variadic function, so it can take any number of arguments. Here is what this looks like:</p>
<pre>var mySlice = []int{1,2} //our slice holds 1 and 2<br/>mySlice = append(mySlice,3,4,5) //now our slice holds 1,2,3,4,5</pre>
<p>One last important thing to mention is the built-in function called <kbd>make</kbd>. We already covered the <kbd>make</kbd> function earlier and how it can be used to initialize a slice:</p>
<pre>//Initialize a slice with length of 3<br/>var mySlice = make([]int,3)</pre>
<p>The argument <kbd>3</kbd> in the preceding code represents the slice's length. What we haven't mentioned yet though is the fact that <kbd>make</kbd> can also be used to specify the capacity of the slice. This can be achieved by using the following code:</p>
<pre>//initialize a slice with length of 3 and capacity of 5<br/>var mySlice = make([]int,3,5)</pre>
<p>If we don't provide the capacity to the <kbd>make()</kbd> function, the length argument value becomes the capacity as well, so in other words, we get the following:</p>
<pre class="mce-root">//Initialize a slice with length of 3, and capacity of 3<br/>var mySlice = make([]int,3)</pre>
<p>Now, it's time to talk about maps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maps</h1>
                </header>
            
            <article>
                
<p>HashMaps are very popular, and extremely important data structures in any programming language. A <strong>map</strong> is a collection of key value pairs, where you use the key to obtain the value that corresponds to it. Using maps greatly speeds up your software due to the fact that with a map, retrieving a value through a key is a very quick operation.</p>
<p>In Go, you can declare a map like this:</p>
<pre>var myMap map[int]string</pre>
<p>The preceding code declares a map where the keys are of type <kbd>int</kbd>, and the values are of type <kbd>string</kbd>.</p>
<p>You can initialize a map using the <kbd>make</kbd> function:</p>
<pre>myMap = make(map[int]string)</pre>
<p>You can't use a map before you initialize it, otherwise an error will be thrown. Here is another way to initialize a map:</p>
<pre>myMap = map[int]string{}</pre>
<p>What if you want to initialize the map with some values? You can do this:</p>
<pre>myMap = map[int]string{1: "first", 2: "Second", 3: "third"}</pre>
<p>To add values to an existing map, you can do this:</p>
<pre>myMap[4] = "fourth"</pre>
<p>To obtain a value from a map, you can do the following:</p>
<pre>//x will hold the value in "myMap" that corresponds to key 4<br/>var x = myMap[4]</pre>
<p class="mce-root"/>
<p>You can also check if a key exists in a map by using the following syntax, assuming that your code is inside a function block:</p>
<pre>//If the key 5 is not in "myMap", then "ok" will be false<br/>//Otherwise, "ok" will be true, and "x" will be the value<br/>x,ok := myMap[5]</pre>
<p>You can delete a value from a map by using the built-in <kbd>delete</kbd> function:</p>
<pre>//delete key of value 4<br/>delete(myMap,4)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Struct</h1>
                </header>
            
            <article>
                
<p>A struct in Go is a data structure that is composed of fields, where each field has a type. Here is what a Go struct looks like:</p>
<pre>type myStruct struct{<br/>    intField int<br/>    stringField string<br/>    sliceField []int<br/>}</pre>
<p>The preceding code creates a <kbd>struct</kbd> type that is called <kbd>myStruct</kbd>, which contains three fields:</p>
<ul>
<li><kbd>intField</kbd> of type <kbd>int</kbd></li>
<li><kbd>stringField</kbd> of type <kbd>string</kbd></li>
<li><kbd>sliceField</kbd> of type <kbd>[]int</kbd></li>
</ul>
<p>You can then initialize and use that <kbd>struct</kbd> type in your code:</p>
<pre>var s = myStruct{<br/>intField: 3,<br/>stringField: "three",<br/>sliceField : []int{1,2,3},<br/>}</pre>
<p>The preceding method of initialization is also known as <strong>struct literals</strong>. There is a shorter version of it that looks like this:</p>
<pre>var s = myStruct{3,"three",[]int{1,2,3}}</pre>
<p>You can also use what is known as <em>dot notation</em>, which looks as follows:</p>
<pre>var s = myStruct{}<br/>s.intField = 3<br/>s.stringField = "three"<br/>s.sliceField= []int{1,2,3}</pre>
<p>You can obtain a pointer to a <kbd>struct</kbd> by doing this:</p>
<pre>var sPtr = &amp;myStruct{<br/>intField:3,<br/>stringField:"three",<br/>sliceField: []int{1,2,3},<br/>}</pre>
<p>A dot notation can be used with a Go struct pointer, since Go will understand what needs to be done without the need to do any pointer de-referencing:</p>
<pre>var s = &amp;myStruct{}<br/>s.intField = 3<br/>s.stringField = "three"<br/>s.sliceField= []int{1,2,3}</pre>
<p>If the Go struct field names start with lower case letters, they will not be visible to external packages. If you want your struct or its fields to be visible to other packages, start the struct and/or field name with upper case letters.</p>
<p>Now, let's talk about Go methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Methods</h1>
                </header>
            
            <article>
                
<p>A method is basically a function that you attach to a type. For example, let's assume we have a <kbd>struct</kbd> type called <kbd>Person</kbd>:</p>
<pre>type Person struct{<br/>    name string<br/>    age int<br/>}</pre>
<p>Go allows us to attach a method to that type like this:</p>
<pre>func (p Person) GetName()string{<br/>  return p.name<br/>}</pre>
<p>The part between the <kbd>func</kbd> keyword and the function name, <kbd>GetName()</kbd>, is known as the <strong>receiver</strong> of the method.</p>
<p>Let's say we declare a value of type <kbd>Person</kbd>, like this:</p>
<pre>var p = Person{<br/>name: "Jason",<br/>age: 29,<br/>}</pre>
<p>Now, we can invoke the <kbd>GetName</kbd> method of value <kbd>p</kbd>, as follows:</p>
<pre>p.GetName()</pre>
<p>Let's create another method called <kbd>GetAge()</kbd>, which returns the <kbd>age</kbd> of the attached <kbd>person</kbd>. Here is the code to do so:</p>
<pre>func (p Person) GetAge()int{<br/>  return p.age<br/>}</pre>
<p>Now, we'll see what type embedding is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type embedding</h1>
                </header>
            
            <article>
                
<p>But what if you would like a struct to inherit the methods of another struct? The closest feature that the Go language offers to the concept of inheritance is known as <em>type embedding</em>. This feature is best explained through an example. Let's go back to the <kbd>Person</kbd> <kbd>struct</kbd> type:</p>
<pre>type Person struct{<br/>    name string<br/>    age int<br/>}<br/><br/>func (p Person) GetName()string{<br/>  return p.name<br/>}<br/><br/>func (p Person) GetAge()int{<br/>  return p.age<br/>}</pre>
<p>Now, let's say that we would like to create a new <kbd>struct</kbd> type called <kbd>Student</kbd>, which has all the properties and methods of <kbd>Person</kbd>, plus some more:</p>
<pre>type Student struct{<br/>    <strong>Person</strong><br/>    studentId int<br/>}<br/><br/>func (s Student) GetStudentID()int{<br/>    return s.studentId<br/>}</pre>
<p>Notice that in the preceding code, we included the type <kbd>Person</kbd> inside the struct definition of type <kbd>Student</kbd>, without specifying a field name. This will effectively make the <kbd>Student</kbd> type inherit all the exported methods and fields of the <kbd>Person</kbd> <kbd>struct</kbd> type. In other words, we can access the methods and fields of <kbd>Person</kbd> directly from an object of type <kbd>Student</kbd>:</p>
<pre>s := Student{}<br/>//This code is valid, because the method GetAge() belongs to the embedded type 'Person':<br/>s.GetAge()<br/>s.GetName()</pre>
<p>In Go, when a type gets embedded inside another type, the exported methods and fields of the embedded type are said to be <em>promoted</em> to the parent or embedding type.</p>
<p>Let's explore how to build interfaces in Go in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interfaces</h1>
                </header>
            
            <article>
                
<p>After covering methods, we must cover interfaces, which make use of methods to produce efficient and scalable code in the Go language.</p>
<p>An interface can be very simply described as a Go type that hosts a collection of methods.</p>
<p>Here is a simple example:</p>
<pre>type MyInterface interface{<br/>    GetName()string<br/>    GetAge()int<br/>}</pre>
<p>The preceding interface defines two methods—<kbd>GetName()</kbd> and <kbd>GetAge()</kbd>.</p>
<p>Earlier, we attached two methods with the same signature to a type called <kbd>Person</kbd>:</p>
<pre>type Person struct{<br/>    name string<br/>    age int<br/>}<br/>func (p Person) GetName()string{<br/>  return p.name<br/>}<br/>func (p Person) GetAge()int{<br/>  return p.age<br/>}</pre>
<p>In Go, an interface can be implemented by other types, like Go structs. When a Go type implements an interface, a value of the interface type can then hold that Go type data. We'll see what that means very shortly.</p>
<p>A very special feature in Go is the fact that for a type to implement or <em>inherit</em> an interface, the type only needs to implement the methods of said interface.</p>
<p>In other words, the <kbd>Person</kbd> struct type from the preceding piece of code implements the <kbd>myInterface</kbd> interface type. This is due to the fact that the <kbd>Person</kbd> type implements <kbd>GetName()</kbd> and <kbd>GetAge()</kbd>, which are the same methods that were defined by <kbd>myInterface</kbd>.</p>
<p>So, what does it mean when <kbd>Person</kbd> implements <kbd>MyInterface</kbd>?</p>
<p>It means that we can do something like this:</p>
<pre>var myInterfaceValue MyInterface<br/>var p = Person{}<br/>p.name = "Jack"<br/>p.age = 39<br/>// some code<br/>myInterfaceValue = p<br/>myInterfaceValue.GetName() //returns: Jack<br/>myInterfaceValue.GetAge() //returns: 39</pre>
<p>We can also do this:</p>
<pre>func main(){<br/>    p := Person{"Alice",26}<br/>    printNameAndAge(p)<br/>}<br/><br/>func PrintNameAndAge(i MyInterface){<br/>    fmt.Println(i.GetName(),i.GetAge())<br/>}</pre>
<p>Interfaces are used quite a bit in APIs and in scalable software. They allow you to build software with flexible functionality. Here is a trivial example of how it helps you build flexible software.</p>
<p>Let's say we want to create a new person type that appends a title to the name:</p>
<pre>type PersonWithTitle {<br/>    name string<br/>    title string<br/>    age int<br/>}<br/><br/>func (p PersonWithTitle) GetName()string{<br/>   //This code returns &lt;title&gt; &lt;space&gt; &lt;name&gt;<br/>    return p.title + " " + p.name<br/>}<br/><br/>func (p PersonWithTitle) GetAge() int{<br/>    return p.age<br/>}<br/><br/></pre>
<p>The preceding type also implements <kbd>MyInterface</kbd>, which means we can do this:</p>
<pre>func main(){<br/>    pt := PersonWithTitle{"Alice","Dr.",26}<br/>    printNameAndAge(pt)<br/>}<br/><br/>func PrintNameAndAge(i MyInterface){<br/>    fmt.Println(i.GetName(),i.GetAge())<br/>}</pre>
<p>The <kbd>PrintNameAndAge()</kbd> function signature will not need to change, since it relies on the interface instead of the concrete type. However, the behavior will differ a bit since we changed the concrete <kbd>struct</kbd> type from <kbd>Person</kbd> to <kbd>PersonWithTitle</kbd>. This ability allows you to write flexible APIs and packages that don't need to change whenever you need to add more concrete types to your code.</p>
<p>There are cases where you might want to get back the concrete type value from an interface value. Go includes a feature called <strong>type assertion</strong> that can be used for just that. Here is the most useful form of type assertion:</p>
<pre>person, ok := myInterfaceValue.(Person)</pre>
<p>The preceding code assumes that we are inside a function block. If <kbd>myInterfaceValue</kbd> does not hold a value of type <kbd>Person</kbd>, the preceding code will return an empty struct for the first return, and false for the second return. Therefore, <kbd>ok</kbd> will be false, whereas <kbd>Person</kbd> will be empty.</p>
<p>On the other hand, if <kbd>myInterfaceValue</kbd> holds a value of type <kbd>Person</kbd>, then <kbd>ok</kbd> will become true, and the <kbd>Person</kbd> variable will hold the data that's retrieved from <kbd>myInterfaceValue</kbd>.</p>
<p>Now, let's explore how to add logic to our code, by covering conditional statements and loops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conditional statements and loops</h1>
                </header>
            
            <article>
                
<p>In Go, there are two keywords for conditional statements—<kbd>if</kbd>, and <kbd>switch</kbd>. Let's take a practical look at each one of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The if statement</h1>
                </header>
            
            <article>
                
<p>The <kbd>if</kbd> statement looks like this:</p>
<pre>if &lt;condition&gt;{<br/>}</pre>
<p>So, let's assume we want to compare whether a value, <kbd><span><span>x</span></span></kbd>, is equal to <kbd>10</kbd>. Here is what the syntax would look like:</p>
<pre>if x == 10{<br/>}</pre>
<p>In Go, you can also execute some initialization in your <kbd>if</kbd> statement. Here is what this syntax would look like:</p>
<pre>if x := getX(); x == 5{<br/>}</pre>
<p>Like other programming languages, an <kbd>if</kbd> statement is never complete without an <kbd>else</kbd> clause. Here is what an <kbd>if else</kbd> looks like in Go:</p>
<pre>if x==5{<br/>}else{<br/>}</pre>
<p>How about an <kbd>else</kbd> clause with a condition?</p>
<pre>if x == 5{<br/>}else if x &gt;10{<br/>} else {<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The switch statement</h1>
                </header>
            
            <article>
                
<p>Now, let's look at the <kbd>switch</kbd> statement. Here is what it looks like:</p>
<pre>switch x {<br/>    case 5:<br/>      fmt.Println("5")<br/>    case 6:<br/>      fmt.Println("6")<br/><br/>default:<br/><br/>  fmt.Println("default case")<br/>}</pre>
<p>If you haven't noticed already, there is no <kbd>break</kbd> keyword. In Go, each case breaks automatically, and doesn't need to be told to do so.</p>
<p>Similar to <kbd>if</kbd> statements, you can do an initialization in your <kbd>switch</kbd> statement:</p>
<pre>switch x := getX();x {<br/>    case 5:<br/>      fmt.Println("5")<br/>    case 6:<br/>      fmt.Println("6")<br/><br/>default:<br/><br/>  fmt.Println("default case")<br/>}</pre>
<p>In Go, a <kbd>switch</kbd> statement can act like a group of <kbd>if else</kbd>. This gives you the ability to write long <kbd>if else</kbd> chains with much nicer code:</p>
<pre>switch{<br/>case x == 5:<br/>//do something<br/>case x &gt; 10:<br/>// do something else<br/>default:<br/>//default case<br/>}</pre>
<p>In some scenarios, you want your switch cases not to break automatically, and instead fall through to the next case. For this, you can use the <kbd>fallthrough</kbd> keyword:</p>
<pre>switch{<br/>case x &gt; 5:<br/>//do something<br/>fallthrough<br/>case x &gt; 10:<br/>// do something else. If x is greater than 10, then the first case will execute first, then this case will follow<br/>default:<br/>//default case<br/>}</pre>
<p class="mce-root">Following conditional statements, let's take a look at loops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loops</h1>
                </header>
            
            <article>
                
<p>In Go, there is a single keyword that you can use when you want to write a loop—<kbd>for</kbd>. There are no other keywords to indicate a loop in Go.</p>
<p>Let's look at the following code. Let's say we want to loop from <kbd>1</kbd> to <kbd>10</kbd>; here is how this is done:</p>
<pre>for i:=1;i&lt;=10;i++{<br/>//do something with i<br/>}</pre>
<p>As in other languages, your <kbd>for</kbd> statement needs to include the following:</p>
<ul>
<li>An initial value (<kbd>i:=1</kbd>) in your code—this is optional</li>
<li>A condition to indicate whether to keep iterating or not (<kbd>i&lt;=10</kbd>)</li>
<li>The value of the next iteration (<kbd>i++</kbd>)</li>
</ul>
<p>What if we have a slice or an array and we want to iterate over it in a loop? Go comes to the rescue with the concept of <kbd>for .. range</kbd>. Let's assume we have a slice called <kbd>myslice</kbd> and that we want to iterate over it. Here is what the code would look like:</p>
<pre>myslice := []string{"one","two","three","four"}<br/>for i,item := range myslice{<br/>//do something with i and item<br/>}</pre>
<p>In the preceding piece of code, <kbd>i</kbd> represents the index of the current iteration. For example, if we are at the second item of <kbd>myslice</kbd>, then the value of <kbd>i</kbd> will be equal to <span><span>1 (because the index starts at 0)</span></span>. The <kbd>item</kbd> variable, on the other hand, represents the value of the slice item at the current iteration. For example, if we are at the third item of the slice, then we are at item value <kbd>three</kbd>.</p>
<p>There are cases where we don't care about the index. For this, we can use the following syntax:</p>
<pre>for _,item := range myslice{<br/>//do something with item<br/>}</pre>
<p>What about if we only care about the index? For that, we can do this:</p>
<pre>for i := range myslice{<br/>//do something with item<br/>}</pre>
<p>Someone might ask, why would I need only the index and not the items of the slice themselves? The answer is simple—when you obtain the item from the <kbd>for..range</kbd> statement, you only obtain a copy of the item, which means that you won't be able to change the original item that lives in the slice should the need arise. However, when you obtain the index, this gives you the power to change the item inside the slice. There are cases where you would need to change the values inside a slice while you are iterating over it. This is when you use the index. Here is a trivial example:</p>
<pre>myslice := []string{"one","two","three","four"}<br/>  for i := range myslice {<br/>     myslice[i] = "other"<br/>  }<br/>  fmt.Println(myslice)<br/>  //output is: other other other other</pre>
<p>But what about the <kbd>while</kbd> loop? If you come from any programming language other than Go, you must be fully aware of the concept of the <kbd>while</kbd> loop. As we mentioned earlier, in Go, all loops make use of the <kbd>for</kbd> keyword, so in other words, <kbd>for</kbd> is Go's <kbd>while</kbd> as well. Here is an example:</p>
<pre>for i&gt;5{<br/>//do something<br/>}</pre>
<p>As in other programming languages, Go supports the <kbd>break</kbd> and <kbd>continue</kbd> keywords. The <kbd>break</kbd> keyword inside a loop would cause the loop to break, even if it is not done. The <kbd>continue</kbd> keyword, on the other hand, will force a loop to jump to the next iteration.</p>
<p>Now, we'll talk about  <kbd>panic</kbd>, <kbd>recover</kbd>, and <kbd>defer</kbd></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Panics, recovers, and defers</h1>
                </header>
            
            <article>
                
<p>In Go, there is a special built-in function called <kbd>panic</kbd>. When you invoke <kbd>panic</kbd> in your code, your program is interrupted, and a panic message is returned. If a <kbd>panic</kbd> gets triggered and you don't capture it in time, your program will stop execution and will exit, so be very careful when you use a <kbd>panic</kbd>. Here is a code example:</p>
<pre>func panicTest(p bool) {<br/>  if p {<br/>    panic("panic requested")<br/>  }<br/>}</pre>
<p>In the preceding example, we wrote a function that checks a flag, <kbd><span><span>p</span></span></kbd>. If <kbd>p</kbd> is true, then we throw a panic. The argument to the <kbd>panic</kbd> function is the message that wants the panic to return. Here is a more complete program that you can run in Go's playground (<a href="http://play.golang.org">http://play.golang.org</a>):</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>  panicTest(true)<br/>  fmt.Println("hello world")<br/>}<br/><br/>func panicTest(p bool) {<br/>  if p {<br/>    panic("panic requested")<br/>  }<br/>}</pre>
<p>When I executed that code from the main function in Go's playground (<a href="http://play.golang.org">http://play.golang.org</a>), I got the following error:</p>
<pre class=""><span class="stdout">panic: panic requested

goroutine 1 [running]:
main.panicTest(0x128701, 0xee7e0)
  /tmp/sandbox420149193/main.go:12 +0x60
main.main()
  /tmp/sandbox420149193/main.go:6 +0x20<br/></span></pre>
<p>The panic caused the program to be terminated, which is why <kbd>hello world</kbd> was never printed. Instead, we got the panic message.</p>
<p>So, now that we understand how panics work, an obvious question arises—how do we capture a <kbd>panic</kbd> and prevent it from killing our program?</p>
<p>Before we answer that question, we first need to introduce the concept of <kbd>defer</kbd>. The <kbd>defer</kbd> keyword can be used to indicate that a piece of code must only be executed after the surrounding function returns. As always, this will make much more sense after we look at a code example:</p>
<pre>func printEnding(message string) {<br/>  fmt.Println(message)<br/>}<br/><br/>func doSomething() {<br/>  //In here we use the keyword "defer"<br/>  //This will call printEnding() right after doSomething()<br/><br/>  defer printEnding("doSomething() just ended")<br/><br/>  //In here, we just print values from 0 to 5<br/>  for i := 0; i &lt;= 5; i++ {<br/>    fmt.Println(i)<br/>  }<br/>}</pre>
<p>In the preceding code, when we made use of <kbd>defer</kbd>, we effectively asked for the <kbd>printEnding()</kbd> function to be executed right after  <kbd>doSomething()</kbd> finishes its execution.</p>
<p class="mce-root"/>
<p>The <kbd>defer</kbd> statement basically pushes a function call to a list, and the list of saved calls is executed after the surrounding function returns. <kbd>Defer</kbd> is most commonly used to clean up resources, like closing a file handler, for example.</p>
<p>Here is the full version of the preceding program:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>)<br/><br/>func main() {<br/>  doSomething()<br/>}<br/><br/>func printEnding(message string) {<br/>  fmt.Println(message)<br/>}<br/><br/>func doSomething() {<br/>  defer printEnding("doSomething() just ended")<br/>  for i := 0; i &lt;= 5; i++ {<br/>    fmt.Println(i)<br/>  }<br/>}</pre>
<p>And here is the output of that program:</p>
<pre class=""><span class="stdout">0
1
2
3
4
5
doSomething() just ended</span></pre>
<p>Now, what if we put <kbd>defer</kbd> <span>multiple</span> times in our function?</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>)<br/><br/>func main() {<br/>  doSomething()<br/>}<br/><br/>func printEnding(message string) {<br/>  fmt.Println(message)<br/>}<br/><br/>func doSomething() {<br/>  defer printEnding("doSomething() just ended 2")<br/>  defer printEnding("doSomething() just ended")<br/>  for i := 0; i &lt;= 5; i++ {<br/>    fmt.Println(i)<br/>  }<br/>}</pre>
<p>The <kbd>defer</kbd> statements typically enter a stack data structure, which means they execute based on the first-in-last-out rule. So, this basically means that the first <kbd>defer</kbd> statement in the code will execute last, while the next one will execute right before it and so on. To paint a clearer picture, let's look at the program's output:</p>
<pre class=""><span class="stdout">0
1
2
3
4
5
doSomething() just ended
doSomething() just ended 2</span></pre>
<p>Perfect! We are now ready to answer our earlier question—how can we capture and handle a <kbd>panic</kbd> before it terminates our program? We now know about <kbd>defer</kbd> and how it ensures that a piece of code of our choosing gets executed right after the surrounding function exits. So, defers can definitely be used to insert a piece of code after a <kbd>panic</kbd> occurs, but are defers enough? The answer is no—there is a built-in function known as <kbd>recover()</kbd> that we can use to capture a <kbd>panic</kbd> and return the panic's message.</p>
<p>Again, a code snippet is worth a thousand words:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>  panicTest(true)<br/>  fmt.Println("hello world")<br/>}<br/><br/>func checkPanic() {<br/>  if r := recover(); r != nil {<br/>    fmt.Println("A Panic was captured, message:", r)<br/>  }<br/>}<br/><br/>func panicTest(p bool) {<br/>  // in here we use a combination of defer and recover<br/>  defer checkPanic()<br/>  if p {<br/>    panic("panic requested")<br/>  }<br/>}</pre>
<p>The preceding code will produce the following output:</p>
<pre class=""><span class="stdout">A Panic was captured, message: panic requested
hello world</span></pre>
<p>As you can see, we utilized a combination of <kbd>defer</kbd> and the <kbd>recover()</kbd> function to capture the <kbd>panic</kbd> to prevent it from terminating our program. If no <kbd>panic</kbd> occurred, the <kbd>recover()</kbd> function will return <kbd>nil</kbd>. Otherwise, the <kbd>recover()</kbd> function will return the error value of the <kbd>panic</kbd>. If we use <kbd>recover()</kbd> alone, it won't be effective without being combined with <kbd>defer</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter took you on a practical learning journey of the building blocks of the Go language. We covered all of the fundamental features of Go that you are likely to see in any Go program. As we progress, you will see the building blocks that we covered in this chapter being utilized again and again.</p>
<p>In the next chapter, we'll cover one of the most beloved features of the Go language by diving into how to handle concurrency in Go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is <kbd>GoPath</kbd> used for?</li>
<li>How do you write a <kbd>while</kbd> loop in Go?</li>
<li>What are named results?</li>
<li>What is the difference between a function and a method?</li>
<li>What is type assertion?</li>
</ol>
<ol start="6">
<li>What is <kbd>defer</kbd> used for?</li>
<li>What is a <kbd>panic</kbd> in Go?</li>
<li>How do we recover from a <kbd>panic</kbd>?</li>
<li>What is the difference between an array and a slice in Go?</li>
<li>What is an interface?</li>
<li>What is a struct?</li>
<li>What is a map?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>For more information on what was covered in this chapter you can go through the following links:</p>
<ul>
<li><strong>Go website</strong>: <a href="http://golang.org">golang.org</a></li>
<li><strong>Installing Go</strong>: <a href="https://golang.org/doc/install">https://golang.org/doc/install</a></li>
<li><strong>Go standard packages</strong>: <a href="https://golang.org/pkg/">https://golang.org/pkg/</a></li>
<li><strong>How to Write Go Code</strong>: <a href="https://golang.org/doc/code.html">https://golang.org/doc/code.html</a></li>
<li><span><strong>Go tour</strong>: <a href="http://tour.golang.org">tour.golang.org</a></span></li>
<li><strong>Slices internals</strong>: <a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a></li>
<li><strong>Effective Go</strong>: <a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a></li>
<li><strong>Composition with Go</strong>: <a href="https://www.ardanlabs.com/blog/2015/09/composition-with-go.html">https://www.ardanlabs.com/blog/2015/09/composition-with-go.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>