["```go\npackage mypackage\n```", "```go\npackage mypackage \n import \"fmt\"\n```", "```go\nimport \"math/rand\"\n```", "```go\nimport (\n \"fmt\"\n \"math/rand\"\n )\n```", "```go\nimport (\n \"database/sql\"\n _ \"github.com/go-sql-driver/mysql\"\n)\n```", "```go\ngo install\n```", "```go\ngo build\n```", "```go\ngo build -o ./output/myexecutable.exe\n```", "```go\nvar s string\n```", "```go\nvar s1,s2,s3 string\n```", "```go\nvar s1,s2,s3 string = \"first-string\", \"second-string\", \"third-string\"\n```", "```go\nvar s1,s2,s3 = \"first-string\", \"second-string\", \"third-string\"\n```", "```go\nvar s,i,f = \"mystring\",12,14.53\n```", "```go\nvar (\n s = \"mystring\"\n i = 12\n f = 14.53\n )\n```", "```go\ns := \"mystring\"\n\ni := 12\n\nf:=14.53\n```", "```go\nvar iptr *int\n```", "```go\nvar x int = 5\n```", "```go\nvar xptr = &x\n```", "```go\ny := *xptr\n```", "```go\n*xptr = 4\n```", "```go\nfunc main(){\n//do something\n}\n```", "```go\nfunc add(a int, b int){\n//a+b\n}\n```", "```go\nfunc add(a,b int){\n//a+b\n}\n```", "```go\nfunc add(a,b int)int{\nreturn a+b\n}\n```", "```go\nfunc addSubtract(a,b int)(int,int){\nreturn a+b,a-b\n}\n```", "```go\nfunc addSubtract(a,b int)(add,sub int){\nadd = a+b\nsub = a-b\nreturn\n}\n```", "```go\nvar adder = func(a,b int)int{\nreturn a+b\n}\nvar subtractor = func(a,b int) int{\nreturn a-b\n}\nvar addResult = adder(3,2)\nvar subResult = subtractor(3,2)\n```", "```go\nfunc execute(op func(int,int)int, a,b int) int{\nreturn op(a,b)\n}\n```", "```go\nvar adder = func(a, b int) int {\n    return a + b\n}\nexecute(adder,3,2)\n```", "```go\nfunc infiniteAdder(inputs ...int) (sum int) {\n  for _, v := range inputs {\n    sum += v\n  }\n  return\n}\n```", "```go\ninfiniteAdder(1,2,2,2) // 1 + 2 + 2 + 2\n```", "```go\npackage adder\n\nfunc Add(a,b int)int {\n  return a+b\n}\n```", "```go\npackage main\n\n//get the adder package\nimport \"adder\"\n\nfunc main() {\n  result := adder.Add(4, 3)\n  //do something with result\n}\n```", "```go\n<package name>.<exported function name>\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n)\n\nfunc main() {\n  fmt.Println(\"Hello Go world!!\")\n}\n```", "```go\nHello Go world!!\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n  \"math/rand\"\n)\n\nfunc main() {\n  fmt.Println(\"Let's generate a random int\", rand.Intn(10))\n}\n```", "```go\nfunc adder() func(int) int {\n  sum := 0\n  return func(x int) int {\n    sum += x\n    return sum\n  }\n}\n```", "```go\n\nfunc adder() func(int) int {\n  sum := 0\n  return func(x int) int {\n    sum += x\n    return sum\n  }\n}\n\nfunc main() {\n  // when we call \"adder()\",it returns the closure\n  sumClosure := adder() // the value of the sum variable is 0\n  sumClosure(1) //now the value of the sum variable is 0+1 = 1\n  sumClosure(2) //now the value of the sum variable is 1+2=3\n //Use the value received from the closure somehow\n}\n```", "```go\nvar myarray [3]int\n```", "```go\nmyarray = [3]int{1,2,3}\n```", "```go\n//As per the array declaration, it has only 3 items of type int\n\nmyarray[0] = 1 //value at index 0\nmyarray[1] = 2 //value at index 1\nmyarray[2] = 3 //value at index 2\n```", "```go\nvar myarray = [3]int{1,2,3}\n```", "```go\nmyarray := [3]int{1,2,3}\n```", "```go\nn := len(myarray)\nfmt.Println(n)\n```", "```go\narray[<index1>:<index2>+1]\n```", "```go\nmyarray := [5]int{1,2,3,4,5}\n```", "```go\nmyarray[2:4]\n```", "```go\n[3 4]\n```", "```go\nmyarray[:4]\n```", "```go\nmyarray[2:]\n```", "```go\nmySubArray := myarray[2:4]\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n)\n\nfunc main() {\n  myarray := [5]int{1,2,3,4,5}\n  mySubArray := myarray[2:4]\n  mySubArray[0] = 2\n  fmt.Println(myarray)\n}\n```", "```go\n[1 2 2 4 5]\n```", "```go\nvar mySlice []int\n```", "```go\nmySlice = []int{1,2,3,4,5}\n```", "```go\nvar mySlice = []int{1,2,3,4,5}\n```", "```go\nvar mySlice = []int{}\n```", "```go\nvar mySlice = make([]int,5)\n```", "```go\nvar mySlice = []int{1,2,3,4,5}\n```", "```go\nvar subSlice = mySlice[2:4]\n```", "```go\ncap(subSlice) //this will return 3\n```", "```go\nlen(subSlice) //this will return 2\n```", "```go\n  //let's assume this is a huge slice\n  var myBigSlice = []int{1,2,3,4,5,6}\n  //now here is a new slice that is smaller\n  var mySubSlice = make([]int,2)\n  //we copy two elements from myBigSlice to mySubSlice\n  copy(mySubSlice,myBigSlice[2:4])\n```", "```go\nvar mySlice = []int{1,2} //our slice holds 1 and 2\nmySlice = append(mySlice,3,4,5) //now our slice holds 1,2,3,4,5\n```", "```go\n//Initialize a slice with length of 3\nvar mySlice = make([]int,3)\n```", "```go\n//initialize a slice with length of 3 and capacity of 5\nvar mySlice = make([]int,3,5)\n```", "```go\n//Initialize a slice with length of 3, and capacity of 3\nvar mySlice = make([]int,3)\n```", "```go\nvar myMap map[int]string\n```", "```go\nmyMap = make(map[int]string)\n```", "```go\nmyMap = map[int]string{}\n```", "```go\nmyMap = map[int]string{1: \"first\", 2: \"Second\", 3: \"third\"}\n```", "```go\nmyMap[4] = \"fourth\"\n```", "```go\n//x will hold the value in \"myMap\" that corresponds to key 4\nvar x = myMap[4]\n```", "```go\n//If the key 5 is not in \"myMap\", then \"ok\" will be false\n//Otherwise, \"ok\" will be true, and \"x\" will be the value\nx,ok := myMap[5]\n```", "```go\n//delete key of value 4\ndelete(myMap,4)\n```", "```go\ntype myStruct struct{\n    intField int\n    stringField string\n    sliceField []int\n}\n```", "```go\nvar s = myStruct{\nintField: 3,\nstringField: \"three\",\nsliceField : []int{1,2,3},\n}\n```", "```go\nvar s = myStruct{3,\"three\",[]int{1,2,3}}\n```", "```go\nvar s = myStruct{}\ns.intField = 3\ns.stringField = \"three\"\ns.sliceField= []int{1,2,3}\n```", "```go\nvar sPtr = &myStruct{\nintField:3,\nstringField:\"three\",\nsliceField: []int{1,2,3},\n}\n```", "```go\nvar s = &myStruct{}\ns.intField = 3\ns.stringField = \"three\"\ns.sliceField= []int{1,2,3}\n```", "```go\ntype Person struct{\n    name string\n    age int\n}\n```", "```go\nfunc (p Person) GetName()string{\n  return p.name\n}\n```", "```go\nvar p = Person{\nname: \"Jason\",\nage: 29,\n}\n```", "```go\np.GetName()\n```", "```go\nfunc (p Person) GetAge()int{\n  return p.age\n}\n```", "```go\ntype Person struct{\n    name string\n    age int\n}\n\nfunc (p Person) GetName()string{\n  return p.name\n}\n\nfunc (p Person) GetAge()int{\n  return p.age\n}\n```", "```go\ntype Student struct{\n    Person\n    studentId int\n}\n\nfunc (s Student) GetStudentID()int{\n    return s.studentId\n}\n```", "```go\ns := Student{}\n//This code is valid, because the method GetAge() belongs to the embedded type 'Person':\ns.GetAge()\ns.GetName()\n```", "```go\ntype MyInterface interface{\n    GetName()string\n    GetAge()int\n}\n```", "```go\ntype Person struct{\n    name string\n    age int\n}\nfunc (p Person) GetName()string{\n  return p.name\n}\nfunc (p Person) GetAge()int{\n  return p.age\n}\n```", "```go\nvar myInterfaceValue MyInterface\nvar p = Person{}\np.name = \"Jack\"\np.age = 39\n// some code\nmyInterfaceValue = p\nmyInterfaceValue.GetName() //returns: Jack\nmyInterfaceValue.GetAge() //returns: 39\n```", "```go\nfunc main(){\n    p := Person{\"Alice\",26}\n    printNameAndAge(p)\n}\n\nfunc PrintNameAndAge(i MyInterface){\n    fmt.Println(i.GetName(),i.GetAge())\n}\n```", "```go\ntype PersonWithTitle {\n    name string\n    title string\n    age int\n}\n\nfunc (p PersonWithTitle) GetName()string{\n   //This code returns <title> <space> <name>\n    return p.title + \" \" + p.name\n}\n\nfunc (p PersonWithTitle) GetAge() int{\n    return p.age\n}\n\n```", "```go\nfunc main(){\n    pt := PersonWithTitle{\"Alice\",\"Dr.\",26}\n    printNameAndAge(pt)\n}\n\nfunc PrintNameAndAge(i MyInterface){\n    fmt.Println(i.GetName(),i.GetAge())\n}\n```", "```go\nperson, ok := myInterfaceValue.(Person)\n```", "```go\nif <condition>{\n}\n```", "```go\nif x == 10{\n}\n```", "```go\nif x := getX(); x == 5{\n}\n```", "```go\nif x==5{\n}else{\n}\n```", "```go\nif x == 5{\n}else if x >10{\n} else {\n}\n```", "```go\nswitch x {\n    case 5:\n      fmt.Println(\"5\")\n    case 6:\n      fmt.Println(\"6\")\n\ndefault:\n\n  fmt.Println(\"default case\")\n}\n```", "```go\nswitch x := getX();x {\n    case 5:\n      fmt.Println(\"5\")\n    case 6:\n      fmt.Println(\"6\")\n\ndefault:\n\n  fmt.Println(\"default case\")\n}\n```", "```go\nswitch{\ncase x == 5:\n//do something\ncase x > 10:\n// do something else\ndefault:\n//default case\n}\n```", "```go\nswitch{\ncase x > 5:\n//do something\nfallthrough\ncase x > 10:\n// do something else. If x is greater than 10, then the first case will execute first, then this case will follow\ndefault:\n//default case\n}\n```", "```go\nfor i:=1;i<=10;i++{\n//do something with i\n}\n```", "```go\nmyslice := []string{\"one\",\"two\",\"three\",\"four\"}\nfor i,item := range myslice{\n//do something with i and item\n}\n```", "```go\nfor _,item := range myslice{\n//do something with item\n}\n```", "```go\nfor i := range myslice{\n//do something with item\n}\n```", "```go\nmyslice := []string{\"one\",\"two\",\"three\",\"four\"}\n  for i := range myslice {\n     myslice[i] = \"other\"\n  }\n  fmt.Println(myslice)\n  //output is: other other other other\n```", "```go\nfor i>5{\n//do something\n}\n```", "```go\nfunc panicTest(p bool) {\n  if p {\n    panic(\"panic requested\")\n  }\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n  panicTest(true)\n  fmt.Println(\"hello world\")\n}\n\nfunc panicTest(p bool) {\n  if p {\n    panic(\"panic requested\")\n  }\n}\n```", "```go\npanic: panic requested\n\ngoroutine 1 [running]:\nmain.panicTest(0x128701, 0xee7e0)\n  /tmp/sandbox420149193/main.go:12 +0x60\nmain.main()\n  /tmp/sandbox420149193/main.go:6 +0x20\n\n```", "```go\nfunc printEnding(message string) {\n  fmt.Println(message)\n}\n\nfunc doSomething() {\n  //In here we use the keyword \"defer\"\n  //This will call printEnding() right after doSomething()\n\n  defer printEnding(\"doSomething() just ended\")\n\n  //In here, we just print values from 0 to 5\n  for i := 0; i <= 5; i++ {\n    fmt.Println(i)\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n)\n\nfunc main() {\n  doSomething()\n}\n\nfunc printEnding(message string) {\n  fmt.Println(message)\n}\n\nfunc doSomething() {\n  defer printEnding(\"doSomething() just ended\")\n  for i := 0; i <= 5; i++ {\n    fmt.Println(i)\n  }\n}\n```", "```go\n0\n1\n2\n3\n4\n5\ndoSomething() just ended\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n)\n\nfunc main() {\n  doSomething()\n}\n\nfunc printEnding(message string) {\n  fmt.Println(message)\n}\n\nfunc doSomething() {\n  defer printEnding(\"doSomething() just ended 2\")\n  defer printEnding(\"doSomething() just ended\")\n  for i := 0; i <= 5; i++ {\n    fmt.Println(i)\n  }\n}\n```", "```go\n0\n1\n2\n3\n4\n5\ndoSomething() just ended\ndoSomething() just ended 2\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n  panicTest(true)\n  fmt.Println(\"hello world\")\n}\n\nfunc checkPanic() {\n  if r := recover(); r != nil {\n    fmt.Println(\"A Panic was captured, message:\", r)\n  }\n}\n\nfunc panicTest(p bool) {\n  // in here we use a combination of defer and recover\n  defer checkPanic()\n  if p {\n    panic(\"panic requested\")\n  }\n}\n```", "```go\nA Panic was captured, message: panic requested\nhello world\n```"]