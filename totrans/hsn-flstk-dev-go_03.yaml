- en: Building Blocks of the Go Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the first chapter of our journey, where we will learn about full
    stack development in Go. This chapter is dedicated to readers who are not yet
    familiar with Go. If you are already proficient in the Go language, you can skip
    this chapter. We'll cover the basic building blocks that form the foundation of
    the Go language, which will be covered in a brief but practical manner. Then,
    we'll show you the Go syntax for basic programming constructs like functions and
    loops. We'll also cover some concepts that are specific to Go like slice, `panic`,
    and `defer`. This chapter assumes that you have some familiarity with programming
    concepts in general (like variables, functions, loops, and conditional statements).
    This chapter also assumes that you have some familiarity with Terminals, and command
    lines, as well as the concept of environmental variables.
  prefs: []
  type: TYPE_NORMAL
- en: A very good resource to learn about the Go language from scratch can be found
    at [tour.golang.org](http://tour.golang.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic concepts—packages, variables, data types, and pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional statements and loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`panic`, `recover`, and `defer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you can do either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [play.golang.org](http://play.golang.org), which will allow you to run
    or test your code online
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the Go programming language, along with a compatible IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven't downloaded Go yet, you can download the Go language by going
    to [https://golang.org/dl/](https://golang.org/dl/), downloading the Go flavor
    for your operating system, and then installing it.
  prefs: []
  type: TYPE_NORMAL
- en: For the local IDE, I prefer Visual Studio Code ([https://code.visualstudio.com](https://code.visualstudio.com)),
    along with its popular Go plugin ([https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go)).
  prefs: []
  type: TYPE_NORMAL
- en: Go's playground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go playground is a fairly popular website, which allows the Go community
    to test Go code samples online. The website can be found at [play.golang.org](http://play.golang.org).
    Whenever you would like to quickly test a simple piece of Go code, visit the website
    and run your code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Go's workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For you to write Go code on your computer, you need to set up a Go workspace.
    A Go workspace is a folder where you will write your Go code. Setting up a Go
    workspace is relatively simple. Here is what you will need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you have Go installed. As we mentioned earlier, you can
    download and install Go by going to [https://golang.org/dl/](https://golang.org/dl/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After installing Go, create a new folder in your computer for Go's workspace.
    Mine is called `GoProjects`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside your Go workspace folder, you will have to create three main folders:
    `src`, `pkg`, and `bin`. It is very important to create folders with these exact
    names inside your Go workspace folder. Here is why these three folders are important:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `src` folder will host all of your code files. Whenever you decide to start
    a new program, you will simply go to the `src` folder and create a new folder
    with your new program name.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pkg` folder typically hosts the compiled package files of your code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bin` folder typically hosts the binary files that are produced by your
    Go programs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need to set two environmental variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first environmental variable is called `GoRoot`, and will include the path
    to your Go install. `GoRoot` should typically be taken care of by the Go installer.
    However, if it's missing, or you would like to move your Go installation to a
    different place, then you need to set `GoRoot`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second environmental variable is called `GoPath`. `GoPath` includes the
    path to your Go workspace folder. By default, if not set, `GoPath` is assumed
    to either to be at `$HOME/go` on Unix systems or `%USERPROFILE%\go` on Windows.
    There is an entire GitHub page which covers setting up `GoPath` in different operating
    systems, which can be found at [https://github.com/golang/go/wiki/SettingGOPATH](https://github.com/golang/go/wiki/SettingGOPATH).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once your Go environment is set up, you can use the Go tool, which is installed
    alongside the Go language so that you can compile and run your Go programs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a look at some of the basic building blocks of the Go language in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Packages, variables, data types, and pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages, variables, data types, and pointers represent the most basic building
    blocks of the Go language. In this section, we'll cover them one by one from a
    practical point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any Go program consists of one or more packages. Each package is basically a
    folder, which contains one or more Go files. Every single Go code file you write
    must belong to a package. Package folders are found inside the `src` folder of
    your Go workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you write Go code, you declare your package name at the very top of your
    Go file. Here is what this looks like in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `mypackage` is the name of the package that my Go file belongs to. It's
    idiomatic in Go to have your package name in lower case letters. It is usually
    preferable to name your package folder the same as your package name. So, when
    you create a new package, simply create a new folder with your package name, and
    then create your package files inside that folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import an external package and use it in your own package, you need to use
    the `import` keyword. For example, a popular package in Go''s standard library
    is the `fmt` package, which allows you to write data to the standard output (that
    is, write to your console screen). Let''s assume we want to use the `fmt` package
    from within our package. Here is what the code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Some package folders can exist inside folders of other packages. For example,
    the folder that contains the `rand` package in Go, which is used to generate random
    numbers, exists inside the folder that contains the `math` package in Go. To import
    a package like that, you need to use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what if we would like to import multiple packages at once? It''s easy—the
    syntax will end up looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Go does not allow you to import a package and then not use it to ensure that
    your code is clean and concise. However, there are some cases (which we''ll cover
    later in this book) where you will want to load a package, but not use it directly.
    This can be accomplished by appending an underscore before the package name in
    the import statement. Here is what this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The most famous package name is `main`. Your main package is the first package
    that runs in your Go program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile a Go program, you will need to navigate to the folder where your
    `main` package lives in the console, and then type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command will compile your Go program and then place the resulting binary
    in the `bin` folder of your workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command will compile and then deploy the resulting binary in the current
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to specify an output path and a filename, you can run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will compile your code and then package it in an executable called `myexecutable.exe`
    at the specified output folder. If your operating system is not Windows, you can
    ignore the `exe` extension in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable is another basic building block of the Go language. In Go, to declare
    a variable, you can simply use the `var` keyword. Here is what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, `string` is the data type. Let''s say we would like to declare more
    than one variable of type string on the same statement. Here is what this would
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize a variable with an initial value, Go offers a number of options.
    One option is to initialize the variable while also specifying the variable type.
    Here is what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to initialize the variables without specifying the data type.
    Here is what this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then mix data types with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A popular way to declare and initialize multiple variables at once is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are declaring and initializing your variable inside a function, you
    don''t need to even use the `var` keyword. Instead, you can use `:=`. This is
    called **type inference**, since you infer the variable type from the provided
    value. Here is how we would declare and initialize the `s`, `i`, and `f` variables
    with type inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `var` keyword, however, gives you more control since it allows you to explicitly
    specify the data type you would like to use for your variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s discuss data types. Go has a standard set of data types that are
    very similar to data types you''d find in any other statically typed programming
    language. Here is a summary of Go''s standard data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type(s)** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | A Boolean (either true or false). |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | A `string` is a collection of `byte` and can hold any characters.
    Strings are read only (immutable), so whenever you need to add or remove characters
    from a string, you are in effect creating a new string. |'
  prefs: []
  type: TYPE_TB
- en: '| `int`, `int8`, `int16`, `int32`, and `int64` | Signed integer types. They
    represent non-decimal numbers that can be either positive or negative. As you
    can probably tell from the type names, you can explicitly specify the number of
    bits that it can allow. If you go with the `int` type, it will pick the number
    of bits that correspond to your environment. For most modern CPU architectures,
    it will pick 64 bits, unless you are working with a smaller CPU or older environment.
    For smaller CPUs or older environments, the choice becomes 32 bits. |'
  prefs: []
  type: TYPE_TB
- en: '| `uint`, `uint8`, `uint16`, `uint32`, `uint64`, and `uintptr` | Unsigned integer
    types. They represent non-decimal numbers, which can only be positive. Except
    for the signage, they are similar to their signed brethren. The `uintptr` type
    is an unsigned integer type that is large enough to hold a memory address. |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | An alias for `uint8`, it holds 8 bits, which basically represents
    a byte of memory. |'
  prefs: []
  type: TYPE_TB
- en: '| `rune` | An alias for `int32`, it is typically used to represent a Unicode
    character. |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` and `float64` | Simply decimal numbers. For smaller decimal numbers,
    use the `float32` type, as it only allows 32 bits of data. For larger decimal
    numbers, use the `float64` type, as it only allows 64 bits of data. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64` and `complex128` | Complex numbers. Those data types are useful
    for programs where serious math is needed. The first type, `complex64`, is a complex
    number where the real part is a 32-bit float, and the imaginary part is a 32-bit
    float. The second type, `complex128`, is a complex number where the real part
    is a 64-bit float, while the imaginary part is a 64-bit float. |'
  prefs: []
  type: TYPE_TB
- en: 'Variables that are declared without an explicit initial values get assigned
    what is known as **zero values**. Here is a table for zero values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type(s)** | **Zero value** |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric types | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean types | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| String type | `""` |'
  prefs: []
  type: TYPE_TB
- en: '| Pointers | `nil` |'
  prefs: []
  type: TYPE_TB
- en: Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of pointers is simple—a **pointer** is a language type that represents
    the memory locations of your values. Pointers in Go are used everywhere, and that's
    because they give the programmer a lot of power over the code. For example, having
    access to your value in memory allows you to change the original value from different
    parts of your code without the need to copy your value around.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, to create a pointer, you just append `*` in front of the data type of
    your value. For example, here is a pointer to an `int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned in the previous section, the zero value of a pointer is `nil`.
    The behavior of `nil` is similar to `null` in languages like Java, that is, if
    you try to use a `nil` pointer, an error will get thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s assume we have a value of type `int` called `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want a pointer to point to the address of `x` for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `&` operand here means that we want the address of `x`. Whenever you append
    the `&` operand before a variable, it basically means that we want to the address
    of that variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we have a pointer, and we want to retrieve the value that it points
    to? This operation is called **de-referencing**, and here is how we can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we de-referenced the pointer `xptr` to obtain the value
    that it points to, and then we stored a copy of the value in a new variable called
    `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to change the value that the pointer points to? We can still
    use de-referencing for that, and here is what this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! With this, you should have enough knowledge to use Go pointers in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have experience in pointers from a different programming language
    like C or C++, you are probably familiar with the concept of pointer arithmetic.
    This is when you perform arithmetic operations (like addition or subtraction)
    on pointers to go to different memory addresses. By default, Go does not support
    pointer arithmetic on vanilla pointers like the ones we described in this section.
    However, there is a package called `unsafe` that allows you to do so. The `unsafe`
    package is only there to give you the power, should you need it. However, it is
    highly recommended that you don't use it unless you absolutely have to.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore functions and closures in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to talk about functions and closures, so sit tight and enjoy the journey.
    Functions are considered one of the key building blocks in any programming language,
    as they allow you to define actions in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the basics of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions – the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how you write a function in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function is almost always the first function that gets executed in
    your Go program. The `main` function needs to live inside the `main` package,
    since `main` is the entry point package for your Go program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what a function with arguments would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `a` and `b` arguments from the preceding code are of the same type,
    we can also do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we want to return a value from our function. Here is what this
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Go also allows multiple returns, so you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In Go, there is a concept known as *named returns*, which basically means that
    you can name your return values in the function header. Here is what this looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions are also first-class citizens in the Go language, which means that
    you can assign a function to a variable and use it as a value. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this, you can also pass functions as arguments to other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of us making use of the `execute` function we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Go also supports the concept of variadic functions. A **variadic function**
    is a function that can take an unspecified number of arguments. Here is an example
    of an `adder` function that takes an unspecified number of `int` arguments and
    then adds them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function takes any number of `int` arguments and then sums them
    all. We''ll cover the `for..range` syntax here later in this chapter, under the
    *Conditional statements and loops* section. We can then call our new function
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We'll look at how functions can be accessed from other packages in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Functions – accessing functions from other packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we covered the concept of packages, and the fact that
    a Go program is composed of a number of connected packages. So, how do we really
    connect packages? We connect packages by having the ability to call functions
    and retrieve types from other packages. But then comes the question, how do we
    expose a function to other packages?
  prefs: []
  type: TYPE_NORMAL
- en: In Go, there are no `private` or `public` keywords like in most other statically
    typed programming languages. If you want your function to be `public`, all you
    need to do is start your function name with an upper case letter. In Go, that
    is known as making your function **exported**. If, on the other hand, your function
    starts with a lower case letter, then your function is considered **unexpected**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To absorb the preceding two paragraphs, let''s go through some code. Here is
    a package called `adder`, which contains a single function called `Add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we want to call `Add` from a different package. Here is what
    we''d do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we called the exported function `Add` from our main
    package, at our `main` function. We did two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Used the `import` keyword to load the `adder` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the main function, we called `adder.Add(..)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As demoed, to call an exported function, you need to use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If in the `adder` package we had named our function `add` instead of `Add`,
    the preceding code would not have worked. This is because when the function starts
    with a lower case letter it would be considered unexpected, which in effect means
    that it will be invisible to other packages.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a couple of examples from Go's standard package.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very popular package from the Go standard packages is the `fmt` package.
    The `fmt` package can write to the standard output of your environment. It can
    also format strings and scan data from the standard input, among other things.
    Here is a simple but very commonly used code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we called a function called `Println`, which lives inside
    the `fmt` package. The `Println` function will take your string message and print
    it on the standard output. The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Another popular package in the world of Go is `math/rand`, which we can use
    to generate random numbers. As we mentioned in the *Packages *section, earlier
    in this chapter, the reason why the package name is not just `rand` is simply
    because the `rand` package folder exists underneath the folder of the `math` package.
    So, even though `rand` is more of a sub-package, we just use the package name
    when we need to call exported functions that belong to it. Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we imported two packages—the `fmt` package and the `math/rand`
    package. We then invoked two functions from each of the packages. We first invoked
    the `Println` function, which belongs to the `fmt` package, to output a string
    to the standard output. Then, we invoked the `Intn` function, which belongs to
    the `math/rand` package, to generate a random number between zero and nine.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at what constitutes closures.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function can also be a closure. A **closure** is a function value that''s
    bound to variables outside its body. This means that a closure can access and
    change values on those variables. It is hard to understand closures without an
    example. Here is another flavor of the adder function, which returns a closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The closure in the preceding example has access to the `sum` variable, which
    means that it will remember the current value of the `sum` variable, and will
    also be able to change the value of the `sum` variable. Again, this is best explained
    with another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have covered the basics of Go. In the following section, we'll move on and
    discuss Go data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Go data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll discuss more key concepts of the Go language. It's time
    to explore the foundational data structures that we need to build non-trivial
    programs in the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll discuss the various Go data structures, including
    arrays, slices, maps, Go structs, and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is a common data structure that exists in any programming language.
    In Go, an array is a collection of values with the same data type, and a pre-defined
    size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to declare an array in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding array is of type `int` and of size `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then initialize the array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, similarly to other variables, we can declare and initialize
    the array on the same line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if we are declaring and initializing the array inside a function, we can
    use the `:=` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Go provides a built-in function called `len()`, which returns the size/length
    of your array. For example, let''s say we run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The output will simply be `3`, since the size of `myarray` is `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also allows you to capture subarrays of your main array. To do that, you
    need to follow the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s say I declare a new array that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'I can obtain a subarray from index two of my array till index three using the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The two indexes that were passed to the preceding syntax were `2` to indicate
    that we would like to start from index two, and then `4` to indicate that we would
    like to stop at index four (*3+1=4*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the square brackets of the preceding syntax, you can also leave either
    side empty. Let''s say you leave the left-hand side empty, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that you want a subarray from index zero until index three.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s say you leave the right-hand side empty, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the subarray will start from index two until the end of
    your original array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`mySubArray` is not merely a copy of a subpart of `myarray`. In fact, both
    arrays will point to the same memory. Let''s elaborate by using an example. Here
    is a simple program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This program output `myarray`, but it does so after we change a value in `mySubArray`.
    As you can see in the preceding code, the original values in `myarray` were `1`,
    `2`, `3`, `4`, and `5`. However, because we changed the value at index `0` of
    `mySubArray`, which is index `2` of `myarray`, the output will end up being as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! We now have a solid idea about how to make use of arrays in Go. Let's
    move on to slices.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a very obvious limitation in Go's array data structure—you must specify
    the size whenever you declare a new array. In real life, there are numerous scenarios
    where we will not know the number of elements to expect beforehand. Almost every
    modern programming language comes with its own data structure to address this
    requirement. In Go, this special data structure is called a **slice**.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a practical point of view, you can think of slices as simply dynamic arrays.
    From a syntax point of view, slices look very similar to arrays, except that you
    don''t need to specify the size. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, slice declarations are very similar to array declarations, except
    for the fact that you don't need to specify the number of elements on a slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is us initializing the preceding slide with some initial values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare and then initialize this with some initial values in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Since slices can grow in size, we are also allowed to initialize an empty slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to set an initial number of elements in your slice without
    having to write the initial values by hand, you can utilize a built-in function
    called `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will declare and initialize an `int` slice with an initial
    length of `5` elements.
  prefs: []
  type: TYPE_NORMAL
- en: To write efficient Go code that can benefit from slices, you need to first understand
    how slices work internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slice can simply be considered as a pointer to a part of an array. A slice
    holds three main pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the first element of the subarray that the slice points to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the subarray that's exposed to the slice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capacity, which is the remaining number of items available in the original
    array. The capacity is always either equal to the length or greater.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sounds too theoretical, so let's utilize the power of code and some visualization
    to provide a practical explanation about how slices really work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we created a new slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, the new slice we created points to an array with the `5` initial
    values that we set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e483bc4-58e4-4123-bc9d-a01fc27008ff.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding diagram, `mySlice` held three pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is a pointer to the array underneath, which holds the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the length of the slice, which is `5` in this case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third is the full capacity of the slice, which is also `5` in this case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding diagram, however, doesn't really clarify how the capacity of the
    slice can be different from its length. To uncover the practical differences between
    length and capacity, we'll need to dig a bit deeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we decided to extract a subslice from the original slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Reslicing `mySlice` will not produce a new, smaller copy of the array underneath.
    Instead, the preceding line of code will produce the following slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7baa87c2-4aad-4fc8-b066-00dbc46c87b8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since `subSlice` includes the elements at index two and index three of `mySlice`,
    the length of `subSlice` is two (remember that an array index starts at zero,
    which is why index two is the third element and not the second). The capacity
    is different, however, and that is because the original array has three elements
    left, starting from index two, so the capacity is three and not two, even though
    the length is two.
  prefs: []
  type: TYPE_NORMAL
- en: So, in other words, the length of `subSlice` is two because `subSlice` only
    cares about two elements. However, the capacity is three because there are three
    elements left in the original array, starting from index two, which is the index
    that the `subSlice` array pointer points to.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in function called `cap`, which we can use to get the capacity
    of a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in function called `len` that we use for arrays works with slices
    as well, since it will give you the length of the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering by now, why should I care about the differences between
    length and capacity? I can just use the length and ignore the capacity altogether,
    since the capacity only gives you information about a hidden internal array.
  prefs: []
  type: TYPE_NORMAL
- en: The answer is very simple—**memory utilization**. What if `mySlice` had 100,000
    elements instead of just five? This means that the internal array would have had
    100,000 elements as well. This huge internal array will exist in our program's
    memory as long as we use any sub-slices extracted from `mySlice`, even if the
    sub-slices we use only care about two elements.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid that kind of memory bloat, we need to explicitly copy the fewer elements
    we care about into a new slice. By doing this, once we stop using the original
    large slice, Go's garbage collector will realize that the huge array is not needed
    anymore and will clean it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we achieve that? This can be done through a built-in function called
    `copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! With this, you should have a fairly practical understanding about slice
    internals and how to avoid memory bloats in slices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We keep saying that slices are like dynamic arrays, but we haven''t seen how
    to actually grow the slice yet. Go offers a simple built-in function called `append`,
    which is used to add values to a slice. If you reach the end of your slice capacity,
    the `append` function will create a new slice with a bigger internal array to
    hold your expanding data. `append` is a variadic function, so it can take any
    number of arguments. Here is what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'One last important thing to mention is the built-in function called `make`.
    We already covered the `make` function earlier and how it can be used to initialize
    a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument `3` in the preceding code represents the slice''s length. What
    we haven''t mentioned yet though is the fact that `make` can also be used to specify
    the capacity of the slice. This can be achieved by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t provide the capacity to the `make()` function, the length argument
    value becomes the capacity as well, so in other words, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to talk about maps.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HashMaps are very popular, and extremely important data structures in any programming
    language. A **map** is a collection of key value pairs, where you use the key
    to obtain the value that corresponds to it. Using maps greatly speeds up your
    software due to the fact that with a map, retrieving a value through a key is
    a very quick operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, you can declare a map like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares a map where the keys are of type `int`, and the
    values are of type `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can initialize a map using the `make` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You can''t use a map before you initialize it, otherwise an error will be thrown.
    Here is another way to initialize a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you want to initialize the map with some values? You can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To add values to an existing map, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain a value from a map, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check if a key exists in a map by using the following syntax,
    assuming that your code is inside a function block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You can delete a value from a map by using the built-in `delete` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A struct in Go is a data structure that is composed of fields, where each field
    has a type. Here is what a Go struct looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a `struct` type that is called `myStruct`, which
    contains three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`intField` of type `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stringField` of type `string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sliceField` of type `[]int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can then initialize and use that `struct` type in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method of initialization is also known as **struct literals**.
    There is a shorter version of it that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use what is known as *dot notation*, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You can obtain a pointer to a `struct` by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'A dot notation can be used with a Go struct pointer, since Go will understand
    what needs to be done without the need to do any pointer de-referencing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If the Go struct field names start with lower case letters, they will not be
    visible to external packages. If you want your struct or its fields to be visible
    to other packages, start the struct and/or field name with upper case letters.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk about Go methods.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A method is basically a function that you attach to a type. For example, let''s
    assume we have a `struct` type called `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Go allows us to attach a method to that type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The part between the `func` keyword and the function name, `GetName()`, is known
    as the **receiver** of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we declare a value of type `Person`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can invoke the `GetName` method of value `p`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another method called `GetAge()`, which returns the `age` of
    the attached `person`. Here is the code to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll see what type embedding is.
  prefs: []
  type: TYPE_NORMAL
- en: Type embedding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But what if you would like a struct to inherit the methods of another struct?
    The closest feature that the Go language offers to the concept of inheritance
    is known as *type embedding*. This feature is best explained through an example.
    Let''s go back to the `Person` `struct` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that we would like to create a new `struct` type called `Student`,
    which has all the properties and methods of `Person`, plus some more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in the preceding code, we included the type `Person` inside the
    struct definition of type `Student`, without specifying a field name. This will
    effectively make the `Student` type inherit all the exported methods and fields
    of the `Person` `struct` type. In other words, we can access the methods and fields
    of `Person` directly from an object of type `Student`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: In Go, when a type gets embedded inside another type, the exported methods and
    fields of the embedded type are said to be *promoted* to the parent or embedding
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how to build interfaces in Go in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After covering methods, we must cover interfaces, which make use of methods
    to produce efficient and scalable code in the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: An interface can be very simply described as a Go type that hosts a collection
    of methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The preceding interface defines two methods—`GetName()` and `GetAge()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we attached two methods with the same signature to a type called `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In Go, an interface can be implemented by other types, like Go structs. When
    a Go type implements an interface, a value of the interface type can then hold
    that Go type data. We'll see what that means very shortly.
  prefs: []
  type: TYPE_NORMAL
- en: A very special feature in Go is the fact that for a type to implement or *inherit*
    an interface, the type only needs to implement the methods of said interface.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the `Person` struct type from the preceding piece of code implements
    the `myInterface` interface type. This is due to the fact that the `Person` type
    implements `GetName()` and `GetAge()`, which are the same methods that were defined
    by `myInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does it mean when `Person` implements `MyInterface`?
  prefs: []
  type: TYPE_NORMAL
- en: 'It means that we can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces are used quite a bit in APIs and in scalable software. They allow
    you to build software with flexible functionality. Here is a trivial example of
    how it helps you build flexible software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to create a new person type that appends a title to the
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding type also implements `MyInterface`, which means we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The `PrintNameAndAge()` function signature will not need to change, since it
    relies on the interface instead of the concrete type. However, the behavior will
    differ a bit since we changed the concrete `struct` type from `Person` to `PersonWithTitle`.
    This ability allows you to write flexible APIs and packages that don't need to
    change whenever you need to add more concrete types to your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are cases where you might want to get back the concrete type value from
    an interface value. Go includes a feature called **type assertion** that can be
    used for just that. Here is the most useful form of type assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code assumes that we are inside a function block. If `myInterfaceValue`
    does not hold a value of type `Person`, the preceding code will return an empty
    struct for the first return, and false for the second return. Therefore, `ok`
    will be false, whereas `Person` will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if `myInterfaceValue` holds a value of type `Person`, then
    `ok` will become true, and the `Person` variable will hold the data that's retrieved
    from `myInterfaceValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how to add logic to our code, by covering conditional statements
    and loops.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements and loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, there are two keywords for conditional statements—`if`, and `switch`.
    Let's take a practical look at each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if` statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s assume we want to compare whether a value, `x`, is equal to `10`.
    Here is what the syntax would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'In Go, you can also execute some initialization in your `if` statement. Here
    is what this syntax would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Like other programming languages, an `if` statement is never complete without
    an `else` clause. Here is what an `if else` looks like in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: How about an `else` clause with a condition?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `switch` statement. Here is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: If you haven't noticed already, there is no `break` keyword. In Go, each case
    breaks automatically, and doesn't need to be told to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `if` statements, you can do an initialization in your `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'In Go, a `switch` statement can act like a group of `if else`. This gives you
    the ability to write long `if else` chains with much nicer code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'In some scenarios, you want your switch cases not to break automatically, and
    instead fall through to the next case. For this, you can use the `fallthrough`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Following conditional statements, let's take a look at loops.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, there is a single keyword that you can use when you want to write a loop—`for`.
    There are no other keywords to indicate a loop in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code. Let''s say we want to loop from `1` to `10`;
    here is how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'As in other languages, your `for` statement needs to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An initial value (`i:=1`) in your code—this is optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A condition to indicate whether to keep iterating or not (`i<=10`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the next iteration (`i++`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What if we have a slice or an array and we want to iterate over it in a loop?
    Go comes to the rescue with the concept of `for .. range`. Let''s assume we have
    a slice called `myslice` and that we want to iterate over it. Here is what the
    code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding piece of code, `i` represents the index of the current iteration.
    For example, if we are at the second item of `myslice`, then the value of `i`
    will be equal to 1 (because the index starts at 0). The `item` variable, on the
    other hand, represents the value of the slice item at the current iteration. For
    example, if we are at the third item of the slice, then we are at item value `three`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are cases where we don''t care about the index. For this, we can use
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'What about if we only care about the index? For that, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Someone might ask, why would I need only the index and not the items of the
    slice themselves? The answer is simple—when you obtain the item from the `for..range`
    statement, you only obtain a copy of the item, which means that you won''t be
    able to change the original item that lives in the slice should the need arise.
    However, when you obtain the index, this gives you the power to change the item
    inside the slice. There are cases where you would need to change the values inside
    a slice while you are iterating over it. This is when you use the index. Here
    is a trivial example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'But what about the `while` loop? If you come from any programming language
    other than Go, you must be fully aware of the concept of the `while` loop. As
    we mentioned earlier, in Go, all loops make use of the `for` keyword, so in other
    words, `for` is Go''s `while` as well. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: As in other programming languages, Go supports the `break` and `continue` keywords.
    The `break` keyword inside a loop would cause the loop to break, even if it is
    not done. The `continue` keyword, on the other hand, will force a loop to jump
    to the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll talk about  `panic`, `recover`, and `defer`
  prefs: []
  type: TYPE_NORMAL
- en: Panics, recovers, and defers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Go, there is a special built-in function called `panic`. When you invoke
    `panic` in your code, your program is interrupted, and a panic message is returned.
    If a `panic` gets triggered and you don''t capture it in time, your program will
    stop execution and will exit, so be very careful when you use a `panic`. Here
    is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we wrote a function that checks a flag, `p`. If `p`
    is true, then we throw a panic. The argument to the `panic` function is the message
    that wants the panic to return. Here is a more complete program that you can run
    in Go''s playground ([http://play.golang.org](http://play.golang.org)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'When I executed that code from the main function in Go''s playground ([http://play.golang.org](http://play.golang.org)),
    I got the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The panic caused the program to be terminated, which is why `hello world` was
    never printed. Instead, we got the panic message.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we understand how panics work, an obvious question arises—how do
    we capture a `panic` and prevent it from killing our program?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we answer that question, we first need to introduce the concept of `defer`.
    The `defer` keyword can be used to indicate that a piece of code must only be
    executed after the surrounding function returns. As always, this will make much
    more sense after we look at a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, when we made use of `defer`, we effectively asked for
    the `printEnding()` function to be executed right after  `doSomething()` finishes
    its execution.
  prefs: []
  type: TYPE_NORMAL
- en: The `defer` statement basically pushes a function call to a list, and the list
    of saved calls is executed after the surrounding function returns. `Defer` is
    most commonly used to clean up resources, like closing a file handler, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full version of the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output of that program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Now, what if we put `defer` multiple times in our function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The `defer` statements typically enter a stack data structure, which means
    they execute based on the first-in-last-out rule. So, this basically means that
    the first `defer` statement in the code will execute last, while the next one
    will execute right before it and so on. To paint a clearer picture, let''s look
    at the program''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! We are now ready to answer our earlier question—how can we capture
    and handle a `panic` before it terminates our program? We now know about `defer`
    and how it ensures that a piece of code of our choosing gets executed right after
    the surrounding function exits. So, defers can definitely be used to insert a
    piece of code after a `panic` occurs, but are defers enough? The answer is no—there
    is a built-in function known as `recover()` that we can use to capture a `panic`
    and return the panic's message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, a code snippet is worth a thousand words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we utilized a combination of `defer` and the `recover()` function
    to capture the `panic` to prevent it from terminating our program. If no `panic`
    occurred, the `recover()` function will return `nil`. Otherwise, the `recover()`
    function will return the error value of the `panic`. If we use `recover()` alone,
    it won't be effective without being combined with `defer`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took you on a practical learning journey of the building blocks
    of the Go language. We covered all of the fundamental features of Go that you
    are likely to see in any Go program. As we progress, you will see the building
    blocks that we covered in this chapter being utilized again and again.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover one of the most beloved features of the Go
    language by diving into how to handle concurrency in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is `GoPath` used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you write a `while` loop in Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are named results?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a function and a method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is type assertion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `defer` used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a `panic` in Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we recover from a `panic`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between an array and a slice in Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a struct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a map?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on what was covered in this chapter you can go through
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Go website**: [golang.org](http://golang.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installing Go**: [https://golang.org/doc/install](https://golang.org/doc/install)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Go standard packages**: [https://golang.org/pkg/](https://golang.org/pkg/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to Write Go Code**: [https://golang.org/doc/code.html](https://golang.org/doc/code.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Go tour**: [tour.golang.org](http://tour.golang.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slices internals**: [https://blog.golang.org/go-slices-usage-and-internals](https://blog.golang.org/go-slices-usage-and-internals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effective Go**: [https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition with Go**: [https://www.ardanlabs.com/blog/2015/09/composition-with-go.html](https://www.ardanlabs.com/blog/2015/09/composition-with-go.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
