<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Go Concurrency</h1>
                </header>
            
            <article>
                
<p class="mce-root">Welcome to the second chapter of our journey to learn about full stack development in Go. In this chapter, we'll continue on our path to understanding the foundations of the Go language, by covering the important topic of <strong>concurrency</strong> in the Go language. Go arguably possesses one of the most effective and easy-to-use concurrency features of the languages in its class. Many developers who switch to Go do so because of Go's concurrency. This chapter assumes some basic knowledge of programming and the concept of threads. In a similar way to the previous chapter, we'll mainly focus on the most important and foundational concepts.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>What is concurrency?</li>
<li>Goroutines</li>
<li>Go channels</li>
<li><kbd>select</kbd> statements</li>
<li>The <kbd>sync</kbd> package</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is concurrency?</h1>
                </header>
            
            <article>
                
<p>So, what is concurrency? The term is used quite a bit in the software industry, even though not all developers understand its meaning. In this section, we'll attempt to uncover the practical meaning of concurrency from the point of view of the Go language, and why it is useful to you.</p>
<p>In Go, <strong>concurrency</strong> means the ability of your program to cut itself into smaller pieces, then the ability to run the different independent pieces at different times, with the goal of executing all the tasks as quickly as possible based on the amount of resources available.</p>
<p class="mce-root"/>
<p>The preceding definition might appear (for some people) as though we are defining threads. However, the concept of concurrency is more general than the concept of threads. Let's first briefly define threads if you are not very familiar with the concept.</p>
<p>A thread is a feature that the OS gives you that allows you to run pieces of your program in parallel. Let's say that your program is composed of two main parts, <strong>Part 1</strong> and <strong>Part 2</strong>, and you write your code such that <strong>Part 1</strong> runs on <strong>Thread One</strong>, and <strong>Part 2</strong> runs on <strong>Thread Two</strong>. In this case, both parts of your program will run parallel to each other at the same time; the following diagram illustrates how this will look:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/114aae99-ca1b-4dff-b569-5ef8128f1cb8.png" style="width:37.50em;height:14.67em;"/></p>
<p>That all sounds good; however, there is a gap in modern software between the number of truly independent threads and the number of concurrent pieces of software that your program needs to execute. In modern pieces of software, you might need thousands of pieces of your program to run independently at the same time, even though your OS might be supplying only four threads!</p>
<p>Concurrency is very important in modern software, due to the need to execute independent pieces of code as fast as possible without disturbing the overall flow of the program. Let's take the simple example of a web server; a web server typically accepts requests from a web client, such as a web browser. Let's say that a request is accepted from Jack, who lives somewhere in Europe, while another request comes at the same time to the web server from Chin, who lives in Asia. You wouldn't want your program to delay Chin's request because of the fact that Jack's request arrived at the same time. Their requests should be processed at the same time and as independently as possible. This is simply why concurrency is an indispensable feature in modern production software.</p>
<p>In Go and other modern programming languages, this gap is addressed by essentially cutting your program into numerous small and independent pieces, and then <em>multiplexing</em> those pieces among the available threads. This becomes much clearer with a visual representation.</p>
<p>Let's say we have a piece of software that is composed of 10 different pieces that we would like to run concurrently, even though we only have two real OS threads. Go has the ability to take those 10 different pieces, schedule when will be the best time to run each piece, and then distribute them among the available threads based on some very clever algorithms. Here's a simple view of how this can look:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4d304ce4-7941-4501-9595-5a517ab65c61.png" style="width:33.50em;height:19.00em;"/></p>
<p>The 10 pieces of your program will feel like they are running at the same time, even though, in reality, they were cleverly distributed to make them finish their tasks as soon as possible based on the available resources. Go takes care of all the complexity of scheduling and distributing the 10 pieces of code on the available threads, while providing you with a very clean API that hides away all the complexities of the algorithms involved. This allows you to focus on writing powerful software to serve your needs, without worrying about the low-level concepts such as managing threads, low-level resource allocation, and scheduling.</p>
<p>Let's take a look at goroutines in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Goroutines</h1>
                </header>
            
            <article>
                
<p>It's now time to dig deeper into the clean API that Go provides in order to write concurrent software with ease.</p>
<p>A goroutine is simply defined as a <em>light-weight thread </em>that you can use in your program; it's not a real thread. In Go, when you define a piece of code as a new goroutine, you basically tell the Go runtime that you would like this piece of code to run concurrently with other goroutines.</p>
<p>Every function in Go lives in some goroutine. For example, the main function that we discussed in the previous chapter, <span>w</span>hich is usually the entry point function for your program, runs on what is known as the <strong>main goroutine</strong>.</p>
<p>So, how do you create a new goroutine? You just append the <kbd>go</kbd> keyword before the function that you would like to run concurrently. The syntax is quite simple:</p>
<pre>go somefunction()</pre>
<p>Here, <kbd>somefunction()</kbd> is the piece of code that you would like to run concurrently. Whenever you create a new goroutine, it will get scheduled to run concurrently, and will not block your current goroutine.</p>
<p>Here is a trivial, but more complete piece of code to help us understand the concept of goroutines:</p>
<pre>package main<br/><br/>import (<br/> "fmt"<br/> "time"<br/>)<br/><br/>func runSomeLoop(n int) {<br/> for i := 0; i &lt; n; i++ {<br/> fmt.Println("Printing:", i)<br/> }<br/>}<br/>func main() {<br/> go runSomeLoop(10)<br/> //block the main goroutine for 2 seconds<br/> time.Sleep(2 * time.Second)<br/> fmt.Println("Hello, playground")<br/>}</pre>
<p>The preceding code is a simple program that runs a function called <kbd>runSomeLoop()</kbd> on a new goroutine. This means that <kbd>runSomeLoop()</kbd> will run concurrently to the <kbd>main()</kbd> function. In the program, we made use of a function called <kbd>Sleep()</kbd>, which exists in the <kbd>time</kbd> package. This function will block the main goroutine in order to give <kbd>runSomeLoop()</kbd> a chance to run and finish. If we don't block the main goroutine in this example, the main goroutine will likely finish, and then exit the program before <kbd>runSomeLoop()</kbd> gets a chance to fully run. There are cases when This is a byproduct of the fact that goroutines are concurrent, which is why invoking a new goroutine does not block your current goroutine. </p>
<p>Here's how the output of the program will look:</p>
<pre class=""><strong><span class="stdout">Printing: 0 <br/>Printing: 1 <br/>Printing: 2 <br/>Printing: 3 <br/>Printing: 4 <br/>Printing: 5 <br/>Printing: 6 <br/>Printing: 7 <br/>Printing: 8 <br/>Printing: 9 <br/></span><span class="stdout">Hello, playground</span></strong></pre>
<p>This shows us that the <kbd>runSomeLoop()</kbd> goroutine managed to run at the same time when the main goroutine was sleeping. When the main goroutine woke up, it printed <kbd>Hello, playground</kbd> before it exited.</p>
<p>So, what if we removed the <kbd>time.Sleep()</kbd> function that blocked the main goroutine? Take a look at the following code block:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>)<br/><br/>func runSomeLoop(n int) {<br/>  for i := 0; i &lt; n; i++ {<br/>    fmt.Println("Printing:", i)<br/>  }<br/>}<br/>func main() {<br/>  go runSomeLoop(10)<br/>  fmt.Println("Hello, playground")<br/>}</pre>
<p>You will get the following result:</p>
<pre class=""><strong><span class="stdout">Hello, playground</span></strong></pre>
<p>You can see that <kbd>runSomeLoop()</kbd> didn't get the chance to run before the main goroutine exited.</p>
<p>Goroutines are very light from a memory and resources point of view; a production Go program will typically run hundreds and thousands of goroutines. The ability to produce goroutines with such simple API is arguably one of the most powerful features of the Go language, according to many of Go's users.</p>
<p>Let's take a look at Go channels in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Go channels</h1>
                </header>
            
            <article>
                
<p>An important question can now be addressed; what if we need to share a piece of data between two different goroutines?</p>
<p>In programs that make use of multiple threads, the common approach to share data between different threads is to lock<em> </em>the variables that are shared between the threads. This is typically known as the <strong>sharing memory</strong> <strong>approach</strong><em>. </em>The following diagram demonstrates how two threads will share memory, by sharing a variable called <strong>X</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/524ce7ed-936e-4d65-8c8b-eccea56bf082.png" style="width:28.92em;height:18.75em;"/></p>
<p>In Go, there is a very popular motto:</p>
<div class="packt_quote">"Do not communicate by sharing memory; instead, share memory by communicating."</div>
<p>What does that mean? It simply means that Go does not typically prefer sharing memory (<span>there are exceptions, however</span>) between threads through the lock approach. Instead, Go prefers to communicate<em> </em>the data from one goroutine to another. This <em>communicate </em>part is achieved through the Go channels. The following diagram demonstrates how this looks visually:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/656112ab-0e58-4b26-8b6d-a7bc5d7180ca.png" style="width:41.92em;height:16.25em;"/></p>
<p>Let's take a look at regular and buffered channels in the next sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Regular channels</h1>
                </header>
            
            <article>
                
<p>To declare a channel in Go, you simply use the <kbd>make</kbd> keyword, as follows:</p>
<pre>myChannel := make(chan int)</pre>
<p>In the preceding code, we created and initialized a channel called <kbd>myChannel</kbd> that can hold <kbd>int</kbd> values. This channel can then be used to send an <kbd>int</kbd> value from one goroutine to another.</p>
<p>Here is how to receive a value from a channel:</p>
<pre>//myIntValue will host the value received from the channel<br/>myIntValue := &lt;-myChannel</pre>
<p>Here is how to send a value to a channel:</p>
<pre>myChannel &lt;- 4</pre>
<p> </p>
<p>Whenever you execute a send or a receive operation on a regular Go channel, your goroutine will block until the value is fully sent or received. This simply means that if you send a value via a channel but there is no other goroutine waiting for it on the other end, your goroutine will block. On the other hand, if you are attempting to receive a value via a channel but there is no other goroutine sending it on the other end, your goroutine will block. This behavior ensures that your code is synchronized, your values are fresh and up to date, and avoids the numerous problems that you can typically face in other programming languages when you use locks.</p>
<p>Let's take a look at a complete program showcasing two goroutines communicating, in order to learn more about Go channels:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>  "time"<br/>)<br/><br/>func runLoopSend(n int, ch chan int) {<br/>  for i := 0; i &lt; n; i++ {<br/>    ch &lt;- i<br/>  }<br/>  close(ch)<br/>}<br/><br/>func runLoopReceive(ch chan int) {<br/>  for {<br/>    i, ok := &lt;-ch<br/>    if !ok {<br/>      break<br/>    }<br/>    fmt.Println("Received value:", i)<br/>  }<br/>}<br/><br/>func main() {<br/>  myChannel := make(chan int)<br/>  go runLoopSend(10, myChannel)<br/>  go runLoopReceive(myChannel)<br/>  time.Sleep(2 * time.Second)<br/>}</pre>
<p class="mce-root"/>
<p>In the preceding code, we created a channel called <kbd>myChannel</kbd>, which we then pass to two goroutines: <kbd>runLoopSend()</kbd> and <kbd>runLoopReceive()</kbd>. The <kbd>runLoopSend()</kbd> function will keep sending values to this channel, whereas the <kbd>runLoopReceive()</kbd> function will keep receiving values from this channel.</p>
<p>The preceding code will provide the following output:</p>
<pre class=""><strong><span class="stdout">Received value: 0
Received value: 1
Received value: 2
Received value: 3
Received value: 4
Received value: 5
Received value: 6
Received value: 7
Received value: 8
Received value: 9
</span></strong></pre>
<p>Let's first focus on <kbd>runLoopSend()</kbd> because there is a new concept that we are showcasing here. Take a look at the following code line:</p>
<pre>close(ch)</pre>
<p>This syntax can be used to close a channel. Once a channel is closed, you cannot send data to it anymore, otherwise, a panic will occur.</p>
<p>Now, let's take a look at <kbd>runLoopReceive</kbd>, particularly at this following line:</p>
<pre>i, ok := &lt;-ch</pre>
<p>The preceding line is a special syntax to inspect whether a channel is closed. If the channel is not closed, the value of <kbd>ok</kbd> will be true, while <kbd>i</kbd> will get the value getting sent via the channel. On the other hand, if the channel is closed, <kbd>ok</kbd> will be false. In the <kbd>runLoopReceive</kbd> goroutine, we break out of the <kbd>for</kbd> loop if <kbd>ok</kbd> is false.</p>
<p>There is actually another, more elegant way to write this <kbd>for</kbd> loop:</p>
<pre>  for {<br/>    i, ok := &lt;-ch<br/>    if !ok {<br/>      break<br/>    }<br/>    fmt.Println("Received value:", i)<br/>  }</pre>
<p><span> </span></p>
<p><span>We can replace the preceding code w</span>ith the following code:</p>
<pre>  for i := range ch {<br/>    fmt.Println("Received value:", i)<br/>  }</pre>
<p>The <kbd>for..range</kbd> syntax is allowed on channels as it allows you to keep receiving data from a channel until the channel gets closed. </p>
<p>The output of the program will simply be as follows:</p>
<pre class=""><strong><span class="stdout">Received value: 0
Received value: 1
Received value: 2
Received value: 3
Received value: 4
Received value: 5
Received value: 6
Received value: 7
Received value: 8
Received value: 9</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Buffered channels</h1>
                </header>
            
            <article>
                
<p>A buffered channel is a special type of channel that holds a buffer that contains a number of items. Unlike a regular channel, a buffered channel doesn't block unless the following takes place:</p>
<ul>
<li>Its buffer is empty and we are trying to receive a value from the channel.</li>
<li>Its buffer is full and we are trying to send a value to the channel.</li>
</ul>
<p>To declare a buffered channel, we use the following syntax:</p>
<pre>myBufferedChannel := make(chan int,10)</pre>
<p>The preceding syntax creates a buffered channel that can hold 10 <kbd>int</kbd> <span>values.</span></p>
<p>To send a value to the buffered channel, we use the same syntax as with regular channels. Each send operation adds one item to the buffer, as follows:</p>
<pre>myBufferedChannel &lt;- 10</pre>
<p>To receive a value from a buffered channel, we utilize the same syntax as well. Each receive operation removes one item from the buffer, as follows:</p>
<pre>x := &lt;-myBufferedChannel</pre>
<p class="mce-root">Let's take a look at the <kbd>select</kbd> statement construct in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The select statement</h1>
                </header>
            
            <article>
                
<p>The <kbd>select</kbd> statement is an important construct in Go. It allows you to control multiple channels at the same time. With <kbd>select</kbd>, you can send or receive values to different channels, and then execute code based on the channel that unblocks the first.</p>
<p>This will be best explained by an example; let's take a look at the following piece of code:</p>
<pre>    select {<br/>        case i := &lt;-ch:<br/>          fmt.Println("Received value:", i)<br/>        case &lt;-time.After(1 * time.Second):<br/>          fmt.Println("timed out")<br/>    }</pre>
<p>In the preceding example, we utilized the <kbd>select</kbd> statement to exercise control over two different channels. The first channel is called <kbd>ch</kbd>, which we attempted to receive a value from. In comparison, the second channel is produced from the <kbd>time.After()</kbd> function. The <kbd>time.After()</kbd> function is very popular in Go, and especially in <kbd>select</kbd> statements. The function generates a channel that only receives a value after the specified timeout, in effect producing a blocking channel for a predefined period of time. You can use <kbd>time.After()</kbd> in your code with the <kbd>select</kbd> statement in cases where you would want to timeout a receive or a send operation on another channel.</p>
<p>Here is another example of sending a <kbd>select</kbd> statement with a timeout channel, but this time it's a combination of receive and send operations:</p>
<pre>    select {<br/>        case i := &lt;-ch1:<br/>          fmt.Println("Received value on channel ch1:", i)<br/>        case ch2 &lt;- 10:<br/>          fmt.Println("Sent value of 10 to channel ch2")<br/>        case &lt;-time.After(1 * time.Second):<br/>          fmt.Println("timed out")<br/>    }</pre>
<p>The preceding code will synchronize between three channels: <kbd>ch1</kbd>, <kbd>ch2</kbd>, and the <kbd>time.After()</kbd> channel.  The <kbd>select</kbd> statement will wait on those three channels and then, depending on whichever channel finishes first, the appropriate <kbd>select</kbd> case will be executed.</p>
<p>The <kbd>select</kbd> statement also supports the <kbd>default</kbd> case. The <kbd>default</kbd> case will execute immediately if none of the channels are ready; here is an example:</p>
<pre>    select {<br/>        case i := &lt;-ch1:<br/>          fmt.Println("Received value on channel ch1:", i)<br/>        case ch2 &lt;- 10:<br/>          fmt.Println("Sent value of 10 to channel ch2")<br/>        default:<br/>          fmt.Println("No channel is ready")<br/>    }</pre>
<p>In the preceding code, if both <kbd>ch1</kbd> and <kbd>ch2</kbd> are blocked by <kbd>time</kbd>, the <kbd>select</kbd> statement is executed, and then the <kbd>default</kbd> case will trigger.</p>
<p>If multiple channels finish at the same time while being controlled by a <kbd>select</kbd> statement, the channel case to be executed is picked at random.</p>
<p>Let's take a look at the sync package in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The sync package</h1>
                </header>
            
            <article>
                
<p>The last topic we will cover in this chapter is the <kbd>sync</kbd> package. The <kbd>sync</kbd> package is what you will use when you absolutely need to create a lock-in Go. Even though we mentioned that Go prefers the use of channels to communicate data between goroutines, there are cases where a lock or a <strong>mutual exclusion object</strong> (<strong>mutex</strong><span>) </span>is unavoidable. An example of a scenario where locks are utilized in Go's standard package is the <kbd>http</kbd> package, where a lock is used to protect the set of listeners to a particular <kbd>http</kbd> server object. This set of listeners can be accessed from numerous goroutines so that they get protected by a mutex.</p>
<p>The word <em>mutex,</em> in the world of computer programming, refers to an object that allows multiple threads to access the same resource (such as shared memory). Mutex is <span>so </span>named because it allows only one thread to access data at one time. </p>
<p>The workflow of a mutex in a piece of software typically works as follows:</p>
<ol>
<li>A thread acquires the mutex</li>
<li>No other threads can acquire the mutex as long as one thread has it</li>
<li>The thread that acquired the mutex can access some resources without any disturbance from the other threads</li>
<li>When its tasks are done, the thread that acquired the mutex releases the mutex so that other threads can compete for it again</li>
</ol>
<p>In Go, you make use of goroutines and not full threads. So, when you use mutexes in Go, they will manage the resource access between goroutines.</p>
<p>Let's take a look at the simple mutex, read-write mutex and wait groups in the next sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The simple mutex</h1>
                </header>
            
            <article>
                
<p>In Go, a simple lock is a pointer to a mutex <kbd>struct</kbd> type, which belongs to the <kbd>sync</kbd> package. We can create a mutex as follows:</p>
<pre>var myMutex = &amp;sync.Mutex{}</pre>
<p>Let's assume that we have a map called <kbd>myMap</kbd> of the <kbd>map[int]int</kbd> <span>type </span>that we'd like to protect from the concurrent access of multiple goroutines:</p>
<pre>myMutex.Lock()<br/>myMap[1] = 100<br/>myMutex.Unlock()</pre>
<p>If we ensure that all goroutines that need to edit <kbd>myMap</kbd> have access to <kbd>myMutex</kbd>, we can protect <kbd>myMap</kbd> against multiple goroutines changing it at the same time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The read-write mutex</h1>
                </header>
            
            <article>
                
<p>Go also supports a read-write lock. A read-write lock differentiates between read and write operations. So, whenever you only perform concurrent read operations, the goroutines won't block. However, whenever you perform a write operation, all other reads and writes get blocked until the write lock is released. As always, this is best explained with an example, such as the following code:</p>
<pre>var myRWMutex = &amp;sync.RWMutex{}</pre>
<p>A read-write lock in Go is represented by a pointer to a Go struct of the <kbd>sync.RWMutex</kbd> <span>type,</span> which is what we initialized in the preceding code snippet.</p>
<p>To perform a read operation, we make use of the <kbd>RLock()</kbd> and <kbd>RUnlock()</kbd> methods of the Go struct:</p>
<pre>myRWMutex.RLock()<br/>fmt.Println(myMap[1])<br/>myRWMutex.RUnlock()</pre>
<p>To perform a write operation, we make use of the <kbd>Lock()</kbd> and <kbd>Unlock()</kbd> methods:</p>
<pre>myRWMutex.Lock()<br/>myMap[2] = 200<br/>myRWMutex.Unlock()</pre>
<p>The <kbd>*sync.RWMutex</kbd> type can be found all over the place in Go's standard package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wait groups</h1>
                </header>
            
            <article>
                
<p>The concept of wait groups is very important for building production level software in Go; it allows you to wait for multiple goroutines to finish before you proceed with the rest of your code.</p>
<p>To fully grasp the benefit of wait groups, let's go back to an earlier code sample:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>  "time"<br/>)<br/><br/>func runLoopSend(n int, ch chan int) {<br/>  for i := 0; i &lt; n; i++ {<br/>    ch &lt;- i<br/>  }<br/>  close(ch)<br/>}<br/><br/>func runLoopReceive(ch chan int) {<br/>  for {<br/>    i, ok := &lt;-ch<br/>    if !ok {<br/>      break<br/>    }<br/>    fmt.Println("Received value:", i)<br/>  }<br/>}<br/><br/>func main() {<br/>  myChannel := make(chan int)<br/>  go runLoopSend(10, myChannel)<br/>  go runLoopReceive(myChannel)<br/>  time.Sleep(2 * time.Second)<br/>}</pre>
<p>In the preceding code, we had to make the main goroutine sleep for two seconds in order to wait for the other two goroutines to finish. However, what if the other goroutines took more than two seconds? It was never guaranteed that this simple sleep would produce the result that we are seeking. Instead, we could have done the following:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>  "sync"<br/>)<br/><br/>// Create a global waitgroup:<br/>var wg = &amp;sync.WaitGroup{}<br/><br/>func main() {<br/>  myChannel := make(chan int)<br/>  //Increment the wait group internal counter by 2<br/>  wg.Add(2)<br/>  go runLoopSend(10, myChannel)<br/>  go runLoopReceive(myChannel)<br/>  //Wait till the wait group counter is 0<br/>  wg.Wait()<br/>}<br/><br/>func runLoopSend(n int, ch chan int) {<br/>  //Ensure that the wait group counter decrements by one after //our function exits<br/>  defer wg.Done()<br/>  for i := 0; i &lt; n; i++ {<br/>    ch &lt;- i<br/>  }<br/>  close(ch)<br/>}<br/><br/>func runLoopReceive(ch chan int) {<br/>  //Ensure that the wait group counter decrements after our  //function exits<br/>  defer wg.Done()<br/>  for {<br/>    i, ok := &lt;-ch<br/>    if !ok {<br/>      break<br/>    }<br/>    fmt.Println("Received value:", i)<br/>  }<br/>}</pre>
<p>A <kbd>WaitGroup</kbd> <kbd>struct</kbd> type in Go is a type that keeps an internal counter; as long as the internal counter is not <kbd>0</kbd>, the wait group will block your goroutine. In the preceding code, we created a global pointer variable to <kbd>WaitGroup</kbd>; we called it <kbd>wg</kbd>. This variable will be visible to all of our functions in this simple program. Before we triggered the two goroutines, we incremented the wait group internal counter by <kbd>2</kbd> using the <kbd>wg.Add(2)</kbd> method. After that, we proceeded to create our two goroutines. For each of the goroutines we added the following code:</p>
<pre>defer wg.Done()</pre>
<p>This uses a combination of <kbd>defer</kbd> and the <kbd>wg.Done()</kbd> method in order to ensure that whenever the goroutine function finishes execution, <kbd>wg.Done()</kbd> gets called. The <kbd>wg.Done()</kbd> method will decrement the internal wait group counter by one.</p>
<p>Finally, at the end of our main goroutine, we call <kbd>wg.Wait()</kbd>, which will block the current goroutine until the internal counter of the wait group is zero. This will, in turn, force the main goroutine to wait until all the goroutines in our program finish executing.</p>
<p>The final output to the preceding code is as follows:</p>
<pre><strong>Received value: 0</strong><br/><strong>Received value: 1</strong><br/><strong>Received value: 2</strong><br/><strong>Received value: 3</strong><br/><strong>Received value: 4</strong><br/><strong>Received value: 5</strong><br/><strong>Received value: 6</strong><br/><strong>Received value: 7</strong><br/><strong>Received value: 8</strong><br/><strong>Received value: 9</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered some key concepts in the world of production-level Go programming. We covered concurrency from a practical point of view, then we dove into some of the APIs that Go provides to allow you to write efficient concurrent software with minimal complexity.</p>
<p>In the next chapter, we'll start switch topics from Go to frontend programming by covering the building blocks of the popular React framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is concurrency?</li>
<li>What is a thread?</li>
<li>How is the concept of concurrency different from parallel threading?</li>
<li>What is a goroutine?</li>
<li>What does <em>share memory by communicating</em> mean?</li>
<li>What is a Go channel?</li>
<li>What is the difference between a regular Go channel and a buffered Go channel?</li>
<li>When should you use a <kbd>select</kbd> statement?</li>
<li>What is the difference between <kbd>sync.Mutex</kbd> and <kbd>sync.RWMutex</kbd>?</li>
<li>When should you use wait groups?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>For more information, you can go through the following links:</p>
<ul>
<li><strong>Concurrency in Golang</strong>: <a href="http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/" target="_blank">http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/</a></li>
<li><strong>Concurrency is not parallelism</strong>: <a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank">https://blog.golang.org/concurrency-is-not-parallelism</a></li>
<li><strong>Package</strong> <kbd>sync</kbd>: <a href="https://golang.org/pkg/sync/" target="_blank">https://golang.org/pkg/sync/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>