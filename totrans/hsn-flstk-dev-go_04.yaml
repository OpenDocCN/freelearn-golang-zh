- en: Go Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the second chapter of our journey to learn about full stack development
    in Go. In this chapter, we'll continue on our path to understanding the foundations
    of the Go language, by covering the important topic of **concurrency** in the
    Go language. Go arguably possesses one of the most effective and easy-to-use concurrency
    features of the languages in its class. Many developers who switch to Go do so
    because of Go's concurrency. This chapter assumes some basic knowledge of programming and
    the concept of threads. In a similar way to the previous chapter, we'll mainly
    focus on the most important and foundational concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is concurrency?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sync` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is concurrency?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is concurrency? The term is used quite a bit in the software industry,
    even though not all developers understand its meaning. In this section, we'll
    attempt to uncover the practical meaning of concurrency from the point of view
    of the Go language, and why it is useful to you.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, **concurrency** means the ability of your program to cut itself into
    smaller pieces, then the ability to run the different independent pieces at different
    times, with the goal of executing all the tasks as quickly as possible based on
    the amount of resources available.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding definition might appear (for some people) as though we are defining
    threads. However, the concept of concurrency is more general than the concept
    of threads. Let's first briefly define threads if you are not very familiar with
    the concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'A thread is a feature that the OS gives you that allows you to run pieces of
    your program in parallel. Let''s say that your program is composed of two main
    parts, **Part 1** and **Part 2**, and you write your code such that **Part 1**
    runs on **Thread One**, and **Part 2** runs on **Thread Two**. In this case, both
    parts of your program will run parallel to each other at the same time; the following
    diagram illustrates how this will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/114aae99-ca1b-4dff-b569-5ef8128f1cb8.png)'
  prefs: []
  type: TYPE_IMG
- en: That all sounds good; however, there is a gap in modern software between the
    number of truly independent threads and the number of concurrent pieces of software
    that your program needs to execute. In modern pieces of software, you might need
    thousands of pieces of your program to run independently at the same time, even
    though your OS might be supplying only four threads!
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is very important in modern software, due to the need to execute
    independent pieces of code as fast as possible without disturbing the overall
    flow of the program. Let's take the simple example of a web server; a web server
    typically accepts requests from a web client, such as a web browser. Let's say
    that a request is accepted from Jack, who lives somewhere in Europe, while another
    request comes at the same time to the web server from Chin, who lives in Asia.
    You wouldn't want your program to delay Chin's request because of the fact that
    Jack's request arrived at the same time. Their requests should be processed at
    the same time and as independently as possible. This is simply why concurrency
    is an indispensable feature in modern production software.
  prefs: []
  type: TYPE_NORMAL
- en: In Go and other modern programming languages, this gap is addressed by essentially
    cutting your program into numerous small and independent pieces, and then *multiplexing*
    those pieces among the available threads. This becomes much clearer with a visual
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a piece of software that is composed of 10 different pieces
    that we would like to run concurrently, even though we only have two real OS threads.
    Go has the ability to take those 10 different pieces, schedule when will be the
    best time to run each piece, and then distribute them among the available threads
    based on some very clever algorithms. Here''s a simple view of how this can look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d304ce4-7941-4501-9595-5a517ab65c61.png)'
  prefs: []
  type: TYPE_IMG
- en: The 10 pieces of your program will feel like they are running at the same time,
    even though, in reality, they were cleverly distributed to make them finish their
    tasks as soon as possible based on the available resources. Go takes care of all
    the complexity of scheduling and distributing the 10 pieces of code on the available
    threads, while providing you with a very clean API that hides away all the complexities
    of the algorithms involved. This allows you to focus on writing powerful software
    to serve your needs, without worrying about the low-level concepts such as managing
    threads, low-level resource allocation, and scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at goroutines in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to dig deeper into the clean API that Go provides in order to
    write concurrent software with ease.
  prefs: []
  type: TYPE_NORMAL
- en: A goroutine is simply defined as a *light-weight thread *that you can use in
    your program; it's not a real thread. In Go, when you define a piece of code as
    a new goroutine, you basically tell the Go runtime that you would like this piece
    of code to run concurrently with other goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Every function in Go lives in some goroutine. For example, the main function
    that we discussed in the previous chapter, which is usually the entry point function
    for your program, runs on what is known as the **main goroutine**.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do you create a new goroutine? You just append the `go` keyword before
    the function that you would like to run concurrently. The syntax is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `somefunction()` is the piece of code that you would like to run concurrently.
    Whenever you create a new goroutine, it will get scheduled to run concurrently,
    and will not block your current goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a trivial, but more complete piece of code to help us understand the
    concept of goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a simple program that runs a function called `runSomeLoop()`
    on a new goroutine. This means that `runSomeLoop()` will run concurrently to the
    `main()` function. In the program, we made use of a function called `Sleep()`,
    which exists in the `time` package. This function will block the main goroutine
    in order to give `runSomeLoop()` a chance to run and finish. If we don't block
    the main goroutine in this example, the main goroutine will likely finish, and
    then exit the program before `runSomeLoop()` gets a chance to fully run. There
    are cases when This is a byproduct of the fact that goroutines are concurrent,
    which is why invoking a new goroutine does not block your current goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the output of the program will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that the `runSomeLoop()` goroutine managed to run at the same
    time when the main goroutine was sleeping. When the main goroutine woke up, it
    printed `Hello, playground` before it exited.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what if we removed the `time.Sleep()` function that blocked the main goroutine?
    Take a look at the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `runSomeLoop()` didn't get the chance to run before the main
    goroutine exited.
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines are very light from a memory and resources point of view; a production
    Go program will typically run hundreds and thousands of goroutines. The ability
    to produce goroutines with such simple API is arguably one of the most powerful
    features of the Go language, according to many of Go's users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at Go channels in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Go channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important question can now be addressed; what if we need to share a piece
    of data between two different goroutines?
  prefs: []
  type: TYPE_NORMAL
- en: 'In programs that make use of multiple threads, the common approach to share
    data between different threads is to lockthe variables that are shared between
    the threads. This is typically known as the **sharing memory** **approach***. *The
    following diagram demonstrates how two threads will share memory, by sharing a
    variable called **X**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/524ce7ed-936e-4d65-8c8b-eccea56bf082.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Go, there is a very popular motto:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Do not communicate by sharing memory; instead, share memory by communicating."'
  prefs: []
  type: TYPE_NORMAL
- en: 'What does that mean? It simply means that Go does not typically prefer sharing
    memory (there are exceptions, however) between threads through the lock approach.
    Instead, Go prefers to communicatethe data from one goroutine to another. This
    *communicate *part is achieved through the Go channels. The following diagram
    demonstrates how this looks visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/656112ab-0e58-4b26-8b6d-a7bc5d7180ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at regular and buffered channels in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Regular channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To declare a channel in Go, you simply use the `make` keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created and initialized a channel called `myChannel` that
    can hold `int` values. This channel can then be used to send an `int` value from
    one goroutine to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to receive a value from a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how to send a value to a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you execute a send or a receive operation on a regular Go channel,
    your goroutine will block until the value is fully sent or received. This simply
    means that if you send a value via a channel but there is no other goroutine waiting
    for it on the other end, your goroutine will block. On the other hand, if you
    are attempting to receive a value via a channel but there is no other goroutine
    sending it on the other end, your goroutine will block. This behavior ensures
    that your code is synchronized, your values are fresh and up to date, and avoids
    the numerous problems that you can typically face in other programming languages
    when you use locks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a complete program showcasing two goroutines communicating,
    in order to learn more about Go channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a channel called `myChannel`, which we then
    pass to two goroutines: `runLoopSend()` and `runLoopReceive()`. The `runLoopSend()`
    function will keep sending values to this channel, whereas the `runLoopReceive()`
    function will keep receiving values from this channel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first focus on `runLoopSend()` because there is a new concept that we
    are showcasing here. Take a look at the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This syntax can be used to close a channel. Once a channel is closed, you cannot
    send data to it anymore, otherwise, a panic will occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at `runLoopReceive`, particularly at this following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line is a special syntax to inspect whether a channel is closed.
    If the channel is not closed, the value of `ok` will be true, while `i` will get
    the value getting sent via the channel. On the other hand, if the channel is closed,
    `ok` will be false. In the `runLoopReceive` goroutine, we break out of the `for`
    loop if `ok` is false.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is actually another, more elegant way to write this `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace the preceding code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `for..range` syntax is allowed on channels as it allows you to keep receiving
    data from a channel until the channel gets closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the program will simply be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Buffered channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A buffered channel is a special type of channel that holds a buffer that contains
    a number of items. Unlike a regular channel, a buffered channel doesn''t block
    unless the following takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: Its buffer is empty and we are trying to receive a value from the channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its buffer is full and we are trying to send a value to the channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To declare a buffered channel, we use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax creates a buffered channel that can hold 10 `int` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send a value to the buffered channel, we use the same syntax as with regular
    channels. Each send operation adds one item to the buffer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To receive a value from a buffered channel, we utilize the same syntax as well.
    Each receive operation removes one item from the buffer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the `select` statement construct in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The select statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `select` statement is an important construct in Go. It allows you to control
    multiple channels at the same time. With `select`, you can send or receive values
    to different channels, and then execute code based on the channel that unblocks
    the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be best explained by an example; let''s take a look at the following
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we utilized the `select` statement to exercise control
    over two different channels. The first channel is called `ch`, which we attempted
    to receive a value from. In comparison, the second channel is produced from the
    `time.After()` function. The `time.After()` function is very popular in Go, and
    especially in `select` statements. The function generates a channel that only
    receives a value after the specified timeout, in effect producing a blocking channel
    for a predefined period of time. You can use `time.After()` in your code with
    the `select` statement in cases where you would want to timeout a receive or a
    send operation on another channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of sending a `select` statement with a timeout channel,
    but this time it''s a combination of receive and send operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will synchronize between three channels: `ch1`, `ch2`, and
    the `time.After()` channel.  The `select` statement will wait on those three channels and
    then, depending on whichever channel finishes first, the appropriate `select`
    case will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `select` statement also supports the `default` case. The `default` case
    will execute immediately if none of the channels are ready; here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, if both `ch1` and `ch2` are blocked by `time`, the `select`
    statement is executed, and then the `default` case will trigger.
  prefs: []
  type: TYPE_NORMAL
- en: If multiple channels finish at the same time while being controlled by a `select`
    statement, the channel case to be executed is picked at random.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the sync package in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The sync package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last topic we will cover in this chapter is the `sync` package. The `sync`
    package is what you will use when you absolutely need to create a lock-in Go.
    Even though we mentioned that Go prefers the use of channels to communicate data
    between goroutines, there are cases where a lock or a **mutual exclusion object**
    (**mutex**) is unavoidable. An example of a scenario where locks are utilized
    in Go's standard package is the `http` package, where a lock is used to protect
    the set of listeners to a particular `http` server object. This set of listeners
    can be accessed from numerous goroutines so that they get protected by a mutex.
  prefs: []
  type: TYPE_NORMAL
- en: The word *mutex,* in the world of computer programming, refers to an object
    that allows multiple threads to access the same resource (such as shared memory).
    Mutex is so named because it allows only one thread to access data at one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow of a mutex in a piece of software typically works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A thread acquires the mutex
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No other threads can acquire the mutex as long as one thread has it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The thread that acquired the mutex can access some resources without any disturbance
    from the other threads
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When its tasks are done, the thread that acquired the mutex releases the mutex
    so that other threads can compete for it again
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Go, you make use of goroutines and not full threads. So, when you use mutexes
    in Go, they will manage the resource access between goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the simple mutex, read-write mutex and wait groups in the
    next sections.
  prefs: []
  type: TYPE_NORMAL
- en: The simple mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Go, a simple lock is a pointer to a mutex `struct` type, which belongs to
    the `sync` package. We can create a mutex as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that we have a map called `myMap` of the `map[int]int` type that
    we''d like to protect from the concurrent access of multiple goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we ensure that all goroutines that need to edit `myMap` have access to `myMutex`,
    we can protect `myMap` against multiple goroutines changing it at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The read-write mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go also supports a read-write lock. A read-write lock differentiates between
    read and write operations. So, whenever you only perform concurrent read operations,
    the goroutines won''t block. However, whenever you perform a write operation,
    all other reads and writes get blocked until the write lock is released. As always,
    this is best explained with an example, such as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A read-write lock in Go is represented by a pointer to a Go struct of the `sync.RWMutex` type,
    which is what we initialized in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a read operation, we make use of the `RLock()` and `RUnlock()` methods
    of the Go struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform a write operation, we make use of the `Lock()` and `Unlock()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `*sync.RWMutex` type can be found all over the place in Go's standard package.
  prefs: []
  type: TYPE_NORMAL
- en: Wait groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of wait groups is very important for building production level software
    in Go; it allows you to wait for multiple goroutines to finish before you proceed
    with the rest of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully grasp the benefit of wait groups, let''s go back to an earlier code
    sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we had to make the main goroutine sleep for two seconds
    in order to wait for the other two goroutines to finish. However, what if the
    other goroutines took more than two seconds? It was never guaranteed that this
    simple sleep would produce the result that we are seeking. Instead, we could have
    done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A `WaitGroup` `struct` type in Go is a type that keeps an internal counter;
    as long as the internal counter is not `0`, the wait group will block your goroutine.
    In the preceding code, we created a global pointer variable to `WaitGroup`; we
    called it `wg`. This variable will be visible to all of our functions in this
    simple program. Before we triggered the two goroutines, we incremented the wait
    group internal counter by `2` using the `wg.Add(2)` method. After that, we proceeded
    to create our two goroutines. For each of the goroutines we added the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This uses a combination of `defer` and the `wg.Done()` method in order to ensure
    that whenever the goroutine function finishes execution, `wg.Done()` gets called.
    The `wg.Done()` method will decrement the internal wait group counter by one.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end of our main goroutine, we call `wg.Wait()`, which will block
    the current goroutine until the internal counter of the wait group is zero. This
    will, in turn, force the main goroutine to wait until all the goroutines in our
    program finish executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final output to the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some key concepts in the world of production-level
    Go programming. We covered concurrency from a practical point of view, then we
    dove into some of the APIs that Go provides to allow you to write efficient concurrent
    software with minimal complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll start switch topics from Go to frontend programming
    by covering the building blocks of the popular React framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is concurrency?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the concept of concurrency different from parallel threading?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a goroutine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does *share memory by communicating* mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Go channel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a regular Go channel and a buffered Go channel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use a `select` statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `sync.Mutex` and `sync.RWMutex`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use wait groups?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can go through the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency in Golang**: [http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/](http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency is not parallelism**: [https://blog.golang.org/concurrency-is-not-parallelism](https://blog.golang.org/concurrency-is-not-parallelism)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package** `sync`: [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
