<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">RESTful Web APIs in Go with the Gin Framework</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we explored how to build an engaging frontend for our application, by utilizing the popular React framework.</p>
<p>It's now time to cover how to build efficient backend code in the Go programming language to work with our frontend. In this chapter, we'll make use of the super-fast Gin framework to build some of the APIs needed for the project of this book (that is, the GoMusic store).</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>RESTful APIs</li>
<li>The Gin framework</li>
<li>Models and bindings</li>
<li>HTTP handlers</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter06">https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter06</a>.</p>
<p> </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RESTful APIs</h1>
                </header>
            
            <article>
                
<p>Any backend software system needs a set of APIs to communicate with the frontend. Full stack software is simply composed of a frontend component from one side that exchanges messages with a backend component from the other side. One of the most popular types of APIs used in full stack software are RESTful APIs.</p>
<p>Let's cover an overview of RESTful APIs in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview</h1>
                </header>
            
            <article>
                
<p><strong>RESTful APIs</strong> can simply be defined as a set of rules used to build web services where you retrieve or manipulate resources. A <strong>resource</strong> is typically a kind of document—it could be an HTML document (such as a web page), a JSON document (for pure information sharing), or some other type of document.<span> </span><strong>JSON</strong> stands for <strong>JavaScript Object Notation</strong>; this is because it basically refers to how you would write the object in JavaScript<span>. It's very popular and is widely used. </span></p>
<p>For the majority of RESTful APIs, HTTP is utilized as the communication layer for the API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8e8502d2-6914-4386-aab4-e79bc82d31ef.png" style="width:36.83em;height:27.83em;"/></p>
<p>The topic can be very lengthy; however, there are a few simple facts and concepts that you need to know in order to properly write RESTful APIs. In the next few sections, we will provide an overview of the key building blocks behind RESTful APIs.</p>
<p>We'll take a look at the client-server architecture, URLs and the HTTP methods in the next sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The client-server architecture</h1>
                </header>
            
            <article>
                
<p>RESTful APIs rely on the client-server architecture. This simply means that for RESTful APIs, you need two main components—a client and a server. A client sends an HTTP request to a server, and the server replies with an HTTP response to the client. A single server typically handles numerous clients at the same time:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7a341150-ee64-46c8-9b63-c47e26eb7134.png" style="width:44.08em;height:16.58em;"/></p>
<p>The preceding diagram can be explained with the help of following points:</p>
<ul>
<li>The client is the component that initiates the API request. A client either asks for a resource from a server, or sends a resource to a server.</li>
<li>The server is the component that receives requests and then processes them. A server either sends a resource to a client when requested to do so, or adds/modifies a resource when a client requests this to happen.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URLs</h1>
                </header>
            
            <article>
                
<p>A URL can simply be defined as the address for a particular RESTful API resource.</p>
<p>When a client sends a request to a server, the client sends the request to a URL address that is being watched by the server. Any RESTful API interaction involves a client sending a message to a URL address.</p>
<p>In order to form an understanding about what a URL consists of, let's take <kbd>http://www.example.com/user?id=1</kbd> as <span>an example.</span></p>
<p>The preceding URL consists of three main components that we need to be aware of, as follows:</p>
<ol>
<li><strong>The server location</strong>: This is basically the combination of the protocol and the server domain name, <kbd>http://www.example.com/</kbd>.</li>
<li><strong>The relative URL path</strong>: This is the relative URL address from the server address, <kbd>/user</kbd>.</li>
<li><strong>The query</strong>: This is a query used to identify what resources we seek, such as <kbd>?id=1</kbd>.</li>
</ol>
<p>The first two components exist in the vast majority of RESTful API interactions, whereas the third component is used for more specialized API calls. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP methods</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, clients send requests to servers. The requests can be used to retrieve resources from servers, or manipulate resources hosted by servers. However, how can we tell what a particular request wants? This is where HTTP methods are used. An HTTP method is basically how an HTTP request from a client reveals its intention to a server.</p>
<p>There are numerous method types that can be supported by HTTP requests; however, since this book is all about practicality, we'll discuss three of the most commonly used request methods in the world of RESTful APIs:</p>
<ul>
<li><strong>The</strong> <kbd>GET</kbd> <strong>request method</strong>: A <kbd>GET</kbd> HTTP request method is used when a client's intention is to retrieve a resource from the server. Whenever you open a web browser such as Google Chrome, and then type in <kbd>www.google.com</kbd>, your web browser acts as an HTTP client that sends a <kbd>GET</kbd> HTTP request to the <a href="http://google.com">www.google.com</a> URL. Google servers then receive your client's request and respond with Google's main page, which is simply an HTML document that is then translated by your web browser to look pretty.</li>
<li><strong>The</strong> <kbd>POST</kbd> <strong>request method</strong>: A <kbd>POST</kbd> HTTP request method is used when the client's intention is to send data to the server. When a client sends a <kbd>POST</kbd> request, it must also include the data that the server is supposed to receive in the message body of the request. The URL address of the request identifies the resource that we are either adding or changing with the new data being sent. There is another HTTP method called <kbd>PUT</kbd>, which can be used to add or replace resource. However, we'll be using <kbd>POST</kbd> in our code.</li>
<li><strong>The</strong> <kbd>DELETE</kbd> <strong>request method</strong>: A <kbd>DELETE</kbd> HTTP request method is used when the client's intention is to delete a resource from the server. The URL of the request will identify the resource that we want to delete.</li>
</ul>
<p class="mce-root">Now that we covered REST APIs, it's time to explore the Gin framework, which is how we'll build a REST API in our Go code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Gin framework</h1>
                </header>
            
            <article>
                
<p class="mce-root">Gin is a very popular Go open source framework that is mainly used to build ultra-high performance RESTful APIs. The project can be found at <a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a>. Gin is not only fast, but it also enjoys a simple and fun-to-use API that makes building production-level RESTful APIs a breeze. </p>
<p>In this section, we will learn how to build a web RESTful API through the Gin framework, by starting the implementation of the backend code that is needed to support our GoMusic store.</p>
<p>Let's take a look at models and the database layer in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Models and the database layer</h1>
                </header>
            
            <article>
                
<p class="mce-root">Our backend obviously needs a database to store all the data that our RESTful API is supposed to expose. Let's call the database interaction code our <em>database layer</em>. In the world of backend software systems, careful and thoughtful design needs to be applied when writing the database layer. This is because the database layer is vital for almost all of the major functionalities in backend systems.</p>
<p>Let's get into the details of models in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Models</h1>
                </header>
            
            <article>
                
<p>The first step to building a well-designed database layer is to build models for the data. <strong>Data models</strong> can simply be described as data structures that represent the information that we retrieve from the database and use in our APIs. This is best explained by an example.</p>
<p>In our GoMusic application, since it's simply an online store that sells products, we can identify the distinct models that our application needs to support, as follows:</p>
<ul>
<li>A product</li>
<li>A customer</li>
<li>A customer order</li>
</ul>
<p class="mce-root">Let's start writing some code; in your project root folder, you need to create a new folder called <kbd>backend</kbd><span>.</span><span> Underneath this, create a folder called</span> <kbd>src</kbd><span>, then</span> underneath<span> the <kbd>src</kbd> folder, create a folder called</span> <kbd>models</kbd><span>. Now, inside the</span> <kbd>models</kbd> <span>folder, create a new file called</span> <kbd>models.go</kbd><span>. This is where we'll write our models. The first thing we need to do is to define a package, as follows:</span></p>
<pre>package models</pre>
<p>Next, let's write our <kbd>Product</kbd> data structure, as follows:</p>
<pre>type Product struct{<br/>  Image string `json:"img"`<br/>  ImagAlt string `json:"imgalt"`<br/>  Price float64 `json:"price"`<br/>  Promotion float64 `json:"promotion"`<br/>  ProductName string `json:"productname"`<br/>  Description string `json:"desc"`<br/>}</pre>
<p>You might be wondering about the strange <kbd>`json:"..."`</kbd> syntax inside our Go struct; this syntax is known as <strong>struct tags</strong>. In our case, the struct tags are used to indicate how the field in question will look in a JSON document. JSON is a very popular data serialization format that is typically used to share data in RESTful APIs. The preceding Go struct will look like the following code snippet in a JSON format:</p>
<pre>{<br/>     "img": "/path/to/img.jpeg",<br/>     "imgalt": "image alt",<br/>     "price": 100,<br/>     "promotion":80,<br/>     "productname": "guitar",<br/>     "desc": "A black guitar with with amazing sounds!!"<br/>}</pre>
<p>From the preceding JSON data block, you can tell how easy it is to represent data in JSON.</p>
<p>If we don't use JSON structure fields in our Go struct, Go will make some default assumptions when converting our Go struct field names to JSON field names. For example, all uppercase first letters in the Go struct fields will convert to lowercase first letters in the JSON document. It is typically preferred to use JSON struct tags in order to be in full control of what the JSON document will look like.</p>
<p>Perfect; now, let's write our <kbd>Customer</kbd> data structure, as follows:</p>
<pre>type Customer struct {<br/>  FirstName string `json:"firstname"`<br/>  LastName string `json:"lastname"`<br/>  Email string `json:"email"`<br/>  LoggedIn bool `json:"loggedin"`<br/>}</pre>
<p>Next, let's write our <kbd>Order</kbd> data structure, as follows:</p>
<pre>type Order struct{<br/>  Product<br/>  Customer<br/>  CustomerID int `json:"customer_id"`<br/>  ProductID int `json:"product_id"`<br/>  Price float64 `json:"sell_price"`<br/>  PurchaseDate time.Time `json:"purchase_date"`<br/>}</pre>
<p>The preceding data structure makes use of a Go feature known as <em>embedding</em>. Embedding in our example here simply means that we include all the fields of a different Go struct in the current Go struct. We embedded the <kbd>Product</kbd> and <kbd>Customer</kbd> Go structs in the <kbd>Order</kbd> Go struct. This means that all the product and customer Go struct fields, such as <kbd>img</kbd> and <kbd>firstname</kbd>, are now part of the <kbd>Order</kbd> struct.</p>
<p>Let's take a look at the database layer interface in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The database layer interface</h1>
                </header>
            
            <article>
                
<p>Another major part of well-designed database layers is the database layer interface. In order to fully appreciate the need for a database interface layer, let's imagine a quick scenario. Let's say you build your backend to use database <em>X</em>, and all your code relies on direct calls to database <em>X</em>. Now, what happens if database <em>X</em> turns out to be very expensive and you find a much cheaper and more maintainable database that you can use in your code? Let's call the new database, database <em>Y</em>. You now have to revisit every single piece of your code that did queries to database <em>X</em> and change it, which may affect much more code than just your database layer. </p>
<p>So, what do we do? We simply create an interface that defines all the behaviors that we expect from the database layer. All our code outside the database layer should only use methods provided by this interface and nothing else. Now, if we want to move from database <em>X</em> to database <em>Y</em>, we can simply write a new database layer that can communicate with database <em>Y</em> and still support our existing database layer interface. By doing this, we ensure that the vast majority of our existing code outside of the database layer will stay the same and behave as expected. </p>
<p>Our next step is to write the database layer interface for our GoMusic application. To do so, we have to first identify the behaviors we seek from our database layer, as follows:</p>
<ul>
<li>Get a list of all products</li>
<li>Get a list of all promotions</li>
<li>Get a customer by the customer's first and last name</li>
<li>Get a customer by the customer's <kbd>id</kbd></li>
<li>Get a product by the product's <kbd>id</kbd></li>
<li>Add a user to the database</li>
<li>Mark a user in the database as signed in</li>
<li>Mark a user in the database as signed out</li>
<li>Get a list of customer orders by the customer's <kbd>id</kbd></li>
</ul>
<p>Inside the <kbd>backend/src</kbd> folder, let's create a new folder called <kbd>dblayer</kbd>. Inside this folder, we'll create a new file called <kbd>dblayer.go</kbd>. This is where we'll write our database layer interface. We start our code by declaring the package name and importing the models package, as follows:</p>
<pre>package dblayer<br/><br/>import (<br/>  "github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/Chapter06/backend/src/models"<br/>)</pre>
<p>Next, we write our interface, which encapsulates all the behavior points we covered in this section, as follows:</p>
<pre>type DBLayer interface{<br/>  GetAllProducts() ([]models.Product, error)<br/>  GetPromos() ([]models.Product, error)<br/>  GetCustomerByName(string, string) (models.Customer, error)<br/>  GetCustomerByID(int) (models.Customer, error)<br/>  GetProduct(uint) (models.Product, error)<br/>  AddUser(models.Customer) (models.Customer, error)<br/>  SignInUser(username, password string) (models.Customer, error)<br/>  SignOutUserById(int) error<br/>  GetCustomerOrdersByID(int) ([]models.Order, error)<br/>}</pre>
<p>In the next chapter, we'll dive back into the database layer to continue its implementation. But for now, let's focus on our REST API layer and its implementation using the Gin framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing RESTful APIs using the Gin framework</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, the backend code for a full stack application such as GoMusic needs to interact with the frontend component through RESTful APIs. This simply means that a major component of our backend code is the RESTful API layer. This layer is what we'll discuss from this point on until the end of the chapter. </p>
<p>Before we start writing code, we need to first agree on our requirements. The first step of any well-designed RESTful API backend is to first figure out the different interactions between the frontend component and the backend component. </p>
<p class="mce-root"/>
<p>Here is what our RESTful API needs to do:</p>
<ol start="1">
<li>Our backend needs to provide a list of available products to the frontend.</li>
<li>Our backend needs to provide a list of available promotions to the frontend.</li>
<li>Our frontend needs to send user information to our backend in order to sign in existing users, or add new users.</li>
<li>Our frontend needs to send user sign out requests to the backend.</li>
<li>Our backend needs to provide a list of existing orders belonging to a specific user.</li>
<li>Our frontend needs to send credit card token information to the backend in order to process a charge.</li>
</ol>
<p>By looking at the preceding points, we can guess which HTTP methods to use for each one:</p>
<ul>
<li>For the first, second, and fifth points, we use a <kbd>GET</kbd> HTTP request, since the server only needs to provide resources (in our case, these are JSON documents) as responses to client requests.</li>
<li>For the third, fourth, and sixth points, we use the <kbd>POST</kbd> HTTP request, since the server will be expected to add or manipulate resources based on a client request.</li>
</ul>
<p class="mce-root">Let's take a look at how we can define routes in the next section. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining routes</h1>
                </header>
            
            <article>
                
<p>The next step to implement a RESTful API is to define the different URLs that correspond to the different API actions we need to happen. This is also known as defining routes, since the URLs are the routes to our API resources.</p>
<p>We'll go through the RESTful API interactions one by one and define their routes. But first, let's start by creating a new file for our RESTful API.</p>
<p>In the <kbd>backend/src</kbd> folder, create a new folder called <kbd>rest</kbd>. Inside the <kbd>rest</kbd> folder, create a file called <kbd>rest.go</kbd>. This is where we start using the Gin framework. In your favorite Terminal, type the following command in order to deploy and install the Gin framework to your development environment:</p>
<pre><strong>go get -u github.com/gin-gonic/gin</strong></pre>
<p class="mce-root"/>
<p>In the <kbd>rest.go</kbd> file, start by declaring the package name and importing the Gin framework, as follows:</p>
<pre>package rest<br/><br/>import (<br/>  "github.com/gin-gonic/gin"<br/>)</pre>
<p>Then, declare the function that will act as the entry point for our RESTful API. This is where we define the HTTP routes for our RESTful API:</p>
<pre>func RunAPI(address string) error{<br/>}</pre>
<p>The preceding method takes one argument that will host the address of our RESTful API server. </p>
<p>In order to make use of Gin, we first need to obtain a <strong>Gin engine</strong>. A Gin engine is the object type that gives us access to assign HTTP methods to URLs to action: </p>
<pre>func RunAPI(address string) error{<br/>    r := gin.Default()<br/>}</pre>
<p>Next, we need to start mapping HTTP methods to URLs to action. For that, we need to make use of the Gin engine object that we just created. The following code block is a simple example of where we use the Gin engine to accept a <kbd>GET</kbd> request coming to the relative URL, <kbd>/relativepath/to/url</kbd>:</p>
<pre>func RunAPI(address string) error{<br/>    r := gin.Default()<br/><strong>    r.GET("/relativepath/to/url", func(c *gin.Context) {</strong><br/><strong>      //take action</strong><br/><strong>    })</strong><br/>}</pre>
<p class="mce-root">The anonymous function in the preceding code, <kbd>func(c *gin.Context){}</kbd>, is where we define the action that we want to be performed when we receive an incoming client request that satisfies our conditions (the <kbd>/relativepath/to/url</kbd> relative path, and the <kbd>GET</kbd> HTTP method).</p>
<p class="mce-root">The <kbd>*gin.Context</kbd> type is provided to us by the Gin framework. It supplies us with all the tools that we need to not only explore the incoming request, but also to take action and provide the appropriate response. We will discuss the <kbd>*gin.Context</kbd><span> type in more detail in the next section, but for now, let's focus on building the routes. Let's revisit the list of API interactions and write some code to represent each interaction:</span></p>
<ol>
<li>Our backend needs to provide a list of available products to the frontend using a <kbd>GET</kbd> request:</li>
</ol>
<pre style="padding-left: 60px">//get products<br/>  r.GET("/products",func(c *gin.Context) {<br/>      //return a list of all products to the client<br/>    }<br/> )</pre>
<ol start="2">
<li>Our backend needs to provide a list of available promotions to the frontend using a <kbd>GET</kbd> request:</li>
</ol>
<pre style="padding-left: 60px">//get promos<br/>  r.GET("/promos",func(c *gin.Context) {<br/>      //return a list of all promotions to the client<br/>    } <br/>  )</pre>
<ol start="3">
<li>Our frontend needs to send user information to our backend in order to sign in existing users or to add new users using a <kbd>POST</kbd> request:</li>
</ol>
<pre style="padding-left: 60px">//post user sign in<br/>  r.POST("/users/signin", func(c *gin.Context) {<br/>      //sign in a user<br/>    } <br/>  )<br/>//add user<br/>r.POST("/users",func(c *gin.Context){<br/>        //add a user<br/>    }<br/>)</pre>
<ol start="4">
<li>Our frontend needs to send user sign out requests to the backend using a <kbd>POST</kbd> request:</li>
</ol>
<pre style="padding-left: 60px">//post user sign out<br/> /*<br/>  In the path below, our relative url needs to include the user id<br/>  Since the id will differ based on the user, the Gin framework allows us to include a wildcard. In Gin, the wildcard will take the form ':id' to indicate that we are expecting a parameter here with the name 'id'<br/>*/<br/>  r.POST("/user/:id/signout",func(c *gin.Context) {<br/>      //sign out a user with the provided id<br/>    } <br/>  )</pre>
<ol start="5">
<li>Our backend needs to provide a list of existing orders belonging to a specific user using a <kbd>GET</kbd> request:</li>
</ol>
<pre style="padding-left: 60px">//get user orders<br/>  r.GET("/user/:id/orders", func(c *gin.Context) {<br/>      //get all orders belonging to the provided user id<br/>    } <br/>  )</pre>
<ol start="6">
<li>Our frontend needs to send credit card token information to the backend in order to process a charge:</li>
</ol>
<pre style="padding-left: 60px">//post purchase charge<br/>  r.POST("/users/charge", func(c *gin.Context) {<br/>      //charge credit card for user<br/>    } <br/>  )</pre>
<p class="mce-root">Let's see how to build an HTTP handler in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating handlers</h1>
                </header>
            
            <article>
                
<p>The next logical step in building our RESTful API is to define the actions that we need to perform when we receive client requests. This is also known as <strong>building handlers</strong>. So, let's start.</p>
<p>In the <kbd>backend/src/rest</kbd> folder, create a new file called <kbd>handler.go</kbd>. In this file, we'll write the code that is needed to handle the actions that correspond to the different API requests that our server is expected to receive.</p>
<p>As always, the first thing we need to do is to declare the package and import the external packages that we need to use, as follows:</p>
<pre>package rest<br/><br/>import (<br/>  "fmt"<br/>  "log"<br/>  "net/http"<br/>  "strconv"<br/><br/>  "github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/Chapter06/backend/src/dblayer"<br/>  "github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/Chapter06/backend/src/models"<br/>  "github.com/gin-gonic/gin"<br/>)</pre>
<p>In order to write clean code that allows extensibility, let's write an interface that represents all the methods that a handler needs to support, as follows:</p>
<pre> type HandlerInterface interface {<br/>  GetProducts(c *gin.Context)<br/>  GetPromos(c *gin.Context)<br/>  AddUser(c *gin.Context)<br/>  SignIn(c *gin.Context)<br/>  SignOut(c *gin.Context)<br/>  GetOrders(c *gin.Context)<br/>  Charge(c *gin.Context)<br/>}</pre>
<p>Next, let's create a <kbd>struct</kbd> type and call it <kbd>Handler</kbd>; this will host all our <kbd>Handler</kbd> methods. <kbd>Handler</kbd> will need access to the database layer interface, since all our <kbd>Handler</kbd> methods will need to either retrieve or change data:</p>
<pre>type Handler struct{<br/>    db dblayer.DBLayer<br/>}</pre>
<p>To follow good design principles, we should create a constructor for <kbd>Handler</kbd>. We'll just create a simple constructor for now, as follows:</p>
<pre>func NewHandler() (*Handler, error) {<br/>  //This creates a new pointer to the Handler object<br/>  return new(Handler), nil<br/>}</pre>
<p>The preceding constructor will need to evolve in the future in order to initialize the database layer. However, let's focus on the <kbd>Handler</kbd> method for now. </p>
<p>In the next few sections, let's focus on what our API needs to do point by point, and then create the corresponding handlers. Each one of the few section will represent an API functionality we need to implement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a full list of available products</h1>
                </header>
            
            <article>
                
<p>First, let's create a method called <kbd>GetProducts</kbd> that takes the <kbd>*gin.Context</kbd> type as an argument:</p>
<pre>func (h *Handler) GetProducts(c *gin.Context) {<br/>}</pre>
<p>Next, we need to ensure that our database interface is initialized and not <kbd>nil</kbd>, then we use the database layer interface in order to obtain the list of products:</p>
<pre>func (h *Handler) GetProducts(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>  products, err := h.db.GetAllProducts()<br/>}</pre>
<p>Now, what happens if the call returns an error? We need to return a JSON document to the client with the error. The response to the client also needs to include an HTTP status code that indicates that the request failed. An HTTP status code is a way to report that an error happened in HTTP communication. This is where we start using the <kbd>*gin.Context</kbd> type, which includes a method called <kbd>JSON()</kbd> that we can use to return JSON documents:</p>
<pre>func (h *Handler) GetProducts(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>  products, err := h.db.GetAllProducts()<br/>  if err != nil {<br/><strong>    /*</strong><br/><strong>        First argument is the http status code, whereas the second argument is the body of the request</strong><br/><strong>    */</strong><br/><strong>    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})</strong><br/>    return<br/>  }<br/>}</pre>
<p>Finally, if there is no error, then we return the list of products we retrieved from the database. Since we defined JSON struct tags in our data models, our data models will get converted to the JSON document formats that we defined:</p>
<pre>func (h *Handler) GetProducts(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>  products, err := h.db.GetAllProducts()<br/>  if err != nil {<br/>    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/><strong>  c.JSON(http.StatusOK, products)</strong><br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a list of promotions</h1>
                </header>
            
            <article>
                
<p>This handler will be very similar to the <kbd>GetProducts</kbd> handler, except that it will use a different database call to retrieve the list of promotions instead of the list of products:</p>
<pre>func (h *Handler) GetPromos(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/><strong>  promos, err := h.db.GetPromos()</strong><br/>  if err != nil {<br/>    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/><strong> c.JSON(http.StatusOK, promos)</strong><br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sign in new users or add new users</h1>
                </header>
            
            <article>
                
<p class="mce-root">The method that we'll create in this section, handles a <kbd>POST</kbd> request; here, we expect to receive a JSON document from the client that we need to decode before we can process the request. Let's assume that our client sends a JSON document that represents the customer. The code to decode the JSON object will look like the following code block:</p>
<pre>func (h *Handler) SignIn(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>  var customer models.Customer<br/><strong>  err := c.ShouldBindJSON(&amp;customer)</strong><br/>}</pre>
<p>The <kbd>c.ShouldBindJSON(...)</kbd> method is provided to us by the <kbd>*gin.Context</kbd> type. Its main purpose is to extract JSON documents from our HTTP request body, and then parse it to the provided argument. In our case, the provided argument was a variable of type <kbd>*models.Customer</kbd>, which is our customer/user data model.  </p>
<p>The rest of our <kbd>SignIn</kbd> method is simple—if no errors occur from decoding the JSON document to the data model, we call the <kbd>SignInUser</kbd> database layer method to sign in or add the customer to the database:</p>
<pre>func (h *Handler) SignIn(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>  var customer models.Customer<br/>  err := c.ShouldBindJSON(&amp;customer)<br/>  if err != nil {<br/>    c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/>  customer,err = h.db.SignInUser(customer)<br/>  if err != nil {<br/>    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/>  c.JSON(http.StatusOK, customer)<br/>}</pre>
<p>To add a user, the logic will be very similar, except that we add a user instead of signing someone in:</p>
<pre><br/>func (h *Handler) AddUser(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>  var customer models.Customer<br/>  err := c.ShouldBindJSON(&amp;customer)<br/>  if err != nil {<br/>    c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/>  customer,err = h.db.AddUser(customer)<br/>  if err != nil {<br/>    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/>  c.JSON(http.StatusOK, customer)<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sign out requests</h1>
                </header>
            
            <article>
                
<p>For this handler, we expect a URL with a parameter, such as <kbd>/user/:id/signout</kbd><span>. Here is what the handler needs to do:</span></p>
<ol>
<li>Extract the parameter that is the <span>ID</span> of the user we are signing out. This can be done by calling a method named <kbd>Param()</kbd>, which belongs to the <kbd>*gin.Context</kbd> type; the following code block demonstrates how this will look: </li>
</ol>
<pre style="padding-left: 60px">func (h *Handler) SignOut(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>  p := c.Param("id")<br/>  // p is of type string, we need to convert it to an integer type<br/>  id,err := strconv.Atoi(p)<br/>  if err != nil {<br/>    c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/>}</pre>
<ol start="2">
<li>Next, we need to call the <kbd>SignOutUserById</kbd> database layer method in order to mark the user as having signed out in the database:</li>
</ol>
<pre style="padding-left: 60px">func (h *Handler) SignOut(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>  p := c.Param("id")<br/>  id, err := strconv.Atoi(p)<br/>  if err != nil {<br/>    c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/><br/>  err = h.db.SignOutUserById(id)<br/>  if err != nil {<br/>    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting orders for a specific user</h1>
                </header>
            
            <article>
                
<p>We expect a URL with a parameter here as well, such as <kbd>/user/:id/orders</kbd><span>. The <kbd>:id</kbd> parameter represents the ID of the user whose orders we are trying to retrieve. The code will look like this:</span></p>
<pre>func (h *Handler) GetOrders(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>  // get id parameter<br/>  p := c.Param("id")<br/>  // convert the string 'p' to integer 'id'<br/>  id, err := strconv.Atoi(p)<br/>  if err != nil {<br/>    c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/>  // call the database layer method to get orders from id<br/>  orders, err := h.db.GetCustomerOrdersByID(id)<br/>  if err != nil {<br/>    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})<br/>    return<br/>  }<br/>  c.JSON(http.StatusOK, orders)<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Charging a credit card</h1>
                </header>
            
            <article>
                
<p>This handler involves more functionality than just reading requests and calling the database. This is because we'll need to interact with Stripe's API to charge a customer's credit card. We will be covering this method more details in the next chapter. For now, let's create an empty handler to use in our code, as follows:</p>
<pre>func (h *Handler) Charge(c *gin.Context) {<br/>  if h.db == nil {<br/>    return<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting it all together</h1>
                </header>
            
            <article>
                
<p>After creating our handlers, let's go back to <kbd>./backend/src/rest/rest.go</kbd>. Instead of mapping our routes to empty handlers, let's map our routes to the handlers that we created in the previous section:</p>
<pre>func RunAPI(address string) error {<br/>  //Get gin's default engine<br/>  r := gin.Default()<br/>  //Define a handler<br/>  h, _ := NewHandler()<br/>  //get products<br/>  r.GET("/products", h.GetProducts)<br/>  //get promos<br/>  r.GET("/promos", h.GetPromos)<br/>  //post user sign in<br/>  r.POST("/users/signin", h.SignIn)<br/>  //add a user<br/>  r.POST("/users",h.AddUser)<br/>  //post user sign out<br/>  r.POST("/user/:id/signout", h.SignOut)<br/>  //get user orders<br/>  r.GET("/user/:id/orders", h.GetOrders)<br/>  //post purchase charge<br/>  r.POST("/users/charge", h.Charge)<br/>  //run the server<br/>  return r.Run(address)<br/>}</pre>
<p>Observe the last line in our function: <kbd>r.Run(address)</kbd>. We must call this method after we finish defining our API routes and handlers, so that our RESTful API server starts listening to incoming requests from HTTP clients. </p>
<p>Since a number of our routes start with <kbd>/user/</kbd> and <kbd>/users</kbd>, the preceding code can be refactored further using a method called <kbd>Group()</kbd>:</p>
<pre>func RunAPI(address string,h HandlerInterface) error {<br/>  //Get gin's default engine<br/>  r := gin.Default()<br/>  //get products<br/>  r.GET("/products", h.GetProducts)<br/>  //get promos<br/>  r.GET("/promos", h.GetPromos)<br/>  /*<br/>    //post user sign in<br/>    r.POST("/user/signin", h.SignIn)<br/>    //post user sign out<br/>    r.POST("/user/:id/signout", h.SignOut)<br/>    //get user orders<br/>    r.GET("/user/:id/orders", h.GetOrders)<br/>    //post purchase charge<br/>    r.POST("/user/charge", h.Charge)<br/>  */<br/><br/>  userGroup := r.Group("/user")<br/>  {<br/>    userGroup.POST("/:id/signout", h.SignOut)<br/>    userGroup.GET("/:id/orders", h.GetOrders)<br/>  }<br/><br/>  usersGroup := r.Group("/users")<br/>  {<br/>    usersGroup.POST("/charge", h.Charge)<br/>    usersGroup.POST("/signin", h.SignIn)<br/>    usersGroup.POST("", h.AddUser)<br/>  }<br/><br/>  return r.Run(address)<br/>}</pre>
<p>The <span><span>preceding</span></span> technique is sometimes known as <em>grouping routes. </em>This is when we group HTTP routes, that share part of their relative URLs, into a common code block.</p>
<p>To make our code cleaner, let's rename the preceding function to <kbd>RunAPIWithHandler()</kbd>, because the <kbd>handler</kbd> can be passed to it as an argument:</p>
<pre>func RunAPIWithHandler(address string,h HandlerInterface) error{<br/>    //our code<br/>}</pre>
<p>Then, let's create a function with the old name <kbd>RunAPI()</kbd> that represents the default state of <kbd>RunAPIWithHandler()</kbd>. This is when we use the default implementation for our <kbd>HandlerInterface</kbd>:</p>
<pre>func RunAPI(address string) error {<br/>  h, err := NewHandler()<br/>  if err != nil {<br/>    return err<br/>  }<br/>  return RunAPIWithHandler(address, h)<br/>}</pre>
<p>Now, in our <kbd>main.go</kbd> file, which should live in the <kbd>backend/src</kbd> folder of our project, we can simply call <kbd>RunAPI()</kbd>, as follows:</p>
<pre>func main() {<br/>  log.Println("Main log....")<br/>  log.Fatal(rest.RunAPI("127.0.0.1:8000"))<br/>}</pre>
<p>But what about connecting our React frontend with the newly created backend? That's simple; in our React application <kbd>root</kbd> folder, there is a file called <kbd>package.json</kbd>. In the <span><kbd>package.json</kbd></span> file, we will need to add the following field:</p>
<pre>"proxy": "http://127.0.0.1:8000/"</pre>
<p>This field will forward any frontend requests to the address specified as the proxy. If our web server listens on <kbd>127.0.0.1:8000</kbd>, which is represented by the <kbd>address</kbd> argument in our <kbd>RunAPI()</kbd> function, then our web server will receive the incoming requests from our frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started with an overview about RESTful APIs. From there we dove into practical topics such as data modeling, defining routes, grouping routes, and creating handlers. We covered the knowledge necessary to write functional web APIs in Go.</p>
<p>We also got our first exposure to the powerful Gin framework, which is very popular for writing production-level RESTful APIs.</p>
<p>In the next chapter, we'll dive deeper into backend web APIs. More advanced topics will be covered like ORMs and security. We will also revisit our application's frontend, and discuss how it connects to the backend that we built.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is Gin?</li>
<li>What is HTTP?</li>
<li>What is a RESTful API?</li>
<li>What is a URL?</li>
<li>What is a handler?</li>
<li>What is JSON?</li>
<li>What is the <kbd>Param()</kbd> method used for?</li>
<li>What is the <kbd>c.JSON()</kbd> method used for?</li>
<li>What is the <kbd>Group()</kbd> method used for?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>For more information, you can go through the following links:</p>
<ul>
<li><strong>Gin: </strong><a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></li>
<li><strong>Representational state transfer</strong>:<a href="https://stackoverflow.com/a/29648972"> https://stackoverflow.com/a/29648972</a></li>
</ul>


            </article>

            
        </section>
    </body></html>