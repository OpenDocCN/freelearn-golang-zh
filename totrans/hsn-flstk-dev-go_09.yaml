- en: RESTful Web APIs in Go with the Gin Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we explored how to build an engaging frontend for
    our application, by utilizing the popular React framework.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to cover how to build efficient backend code in the Go programming
    language to work with our frontend. In this chapter, we'll make use of the super-fast
    Gin framework to build some of the APIs needed for the project of this book (that
    is, the GoMusic store).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Gin framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models and bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any backend software system needs a set of APIs to communicate with the frontend.
    Full stack software is simply composed of a frontend component from one side that
    exchanges messages with a backend component from the other side. One of the most
    popular types of APIs used in full stack software are RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's cover an overview of RESTful APIs in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**RESTful APIs** can simply be defined as a set of rules used to build web
    services where you retrieve or manipulate resources. A **resource** is typically
    a kind of document—it could be an HTML document (such as a web page), a JSON document
    (for pure information sharing), or some other type of document. **JSON** stands
    for **JavaScript Object Notation**; this is because it basically refers to how
    you would write the object in JavaScript. It''s very popular and is widely used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the majority of RESTful APIs, HTTP is utilized as the communication layer
    for the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e8502d2-6914-4386-aab4-e79bc82d31ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The topic can be very lengthy; however, there are a few simple facts and concepts
    that you need to know in order to properly write RESTful APIs. In the next few
    sections, we will provide an overview of the key building blocks behind RESTful
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a look at the client-server architecture, URLs and the HTTP methods
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: The client-server architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RESTful APIs rely on the client-server architecture. This simply means that
    for RESTful APIs, you need two main components—a client and a server. A client
    sends an HTTP request to a server, and the server replies with an HTTP response
    to the client. A single server typically handles numerous clients at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a341150-ee64-46c8-9b63-c47e26eb7134.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram can be explained with the help of following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The client is the component that initiates the API request. A client either
    asks for a resource from a server, or sends a resource to a server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server is the component that receives requests and then processes them.
    A server either sends a resource to a client when requested to do so, or adds/modifies
    a resource when a client requests this to happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A URL can simply be defined as the address for a particular RESTful API resource.
  prefs: []
  type: TYPE_NORMAL
- en: When a client sends a request to a server, the client sends the request to a
    URL address that is being watched by the server. Any RESTful API interaction involves
    a client sending a message to a URL address.
  prefs: []
  type: TYPE_NORMAL
- en: In order to form an understanding about what a URL consists of, let's take `http://www.example.com/user?id=1` as an
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding URL consists of three main components that we need to be aware
    of, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The server location**: This is basically the combination of the protocol
    and the server domain name, `http://www.example.com/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The relative URL path**: This is the relative URL address from the server
    address, `/user`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The query**: This is a query used to identify what resources we seek, such
    as `?id=1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first two components exist in the vast majority of RESTful API interactions,
    whereas the third component is used for more specialized API calls.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, clients send requests to servers. The requests can be
    used to retrieve resources from servers, or manipulate resources hosted by servers.
    However, how can we tell what a particular request wants? This is where HTTP methods
    are used. An HTTP method is basically how an HTTP request from a client reveals
    its intention to a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous method types that can be supported by HTTP requests; however,
    since this book is all about practicality, we''ll discuss three of the most commonly
    used request methods in the world of RESTful APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The** `GET` **request method**: A `GET` HTTP request method is used when
    a client''s intention is to retrieve a resource from the server. Whenever you
    open a web browser such as Google Chrome, and then type in `www.google.com`, your
    web browser acts as an HTTP client that sends a `GET` HTTP request to the [www.google.com](http://google.com)
    URL. Google servers then receive your client''s request and respond with Google''s
    main page, which is simply an HTML document that is then translated by your web
    browser to look pretty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `POST` **request method**: A `POST` HTTP request method is used when
    the client''s intention is to send data to the server. When a client sends a `POST`
    request, it must also include the data that the server is supposed to receive
    in the message body of the request. The URL address of the request identifies
    the resource that we are either adding or changing with the new data being sent.
    There is another HTTP method called `PUT`, which can be used to add or replace
    resource. However, we''ll be using `POST` in our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `DELETE` **request method**: A `DELETE` HTTP request method is used
    when the client''s intention is to delete a resource from the server. The URL
    of the request will identify the resource that we want to delete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we covered REST APIs, it's time to explore the Gin framework, which
    is how we'll build a REST API in our Go code.
  prefs: []
  type: TYPE_NORMAL
- en: The Gin framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gin is a very popular Go open source framework that is mainly used to build
    ultra-high performance RESTful APIs. The project can be found at [https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin).
    Gin is not only fast, but it also enjoys a simple and fun-to-use API that makes
    building production-level RESTful APIs a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to build a web RESTful API through the Gin
    framework, by starting the implementation of the backend code that is needed to
    support our GoMusic store.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at models and the database layer in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Models and the database layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our backend obviously needs a database to store all the data that our RESTful
    API is supposed to expose. Let's call the database interaction code our *database
    layer*. In the world of backend software systems, careful and thoughtful design
    needs to be applied when writing the database layer. This is because the database
    layer is vital for almost all of the major functionalities in backend systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into the details of models in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to building a well-designed database layer is to build models
    for the data. **Data models** can simply be described as data structures that
    represent the information that we retrieve from the database and use in our APIs.
    This is best explained by an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our GoMusic application, since it''s simply an online store that sells products,
    we can identify the distinct models that our application needs to support, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A customer order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start writing some code; in your project root folder, you need to create
    a new folder called `backend`. Underneath this, create a folder called `src`,
    then underneath the `src` folder, create a folder called `models`. Now, inside
    the `models` folder, create a new file called `models.go`. This is where we''ll
    write our models. The first thing we need to do is to define a package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s write our `Product` data structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering about the strange `` `json:"..."` `` syntax inside our
    Go struct; this syntax is known as **struct tags**. In our case, the struct tags
    are used to indicate how the field in question will look in a JSON document. JSON
    is a very popular data serialization format that is typically used to share data
    in RESTful APIs. The preceding Go struct will look like the following code snippet
    in a JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding JSON data block, you can tell how easy it is to represent
    data in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't use JSON structure fields in our Go struct, Go will make some default
    assumptions when converting our Go struct field names to JSON field names. For
    example, all uppercase first letters in the Go struct fields will convert to lowercase
    first letters in the JSON document. It is typically preferred to use JSON struct
    tags in order to be in full control of what the JSON document will look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perfect; now, let''s write our `Customer` data structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s write our `Order` data structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding data structure makes use of a Go feature known as *embedding*.
    Embedding in our example here simply means that we include all the fields of a
    different Go struct in the current Go struct. We embedded the `Product` and `Customer`
    Go structs in the `Order` Go struct. This means that all the product and customer
    Go struct fields, such as `img` and `firstname`, are now part of the `Order` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the database layer interface in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The database layer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another major part of well-designed database layers is the database layer interface.
    In order to fully appreciate the need for a database interface layer, let's imagine
    a quick scenario. Let's say you build your backend to use database *X*, and all
    your code relies on direct calls to database *X*. Now, what happens if database
    *X* turns out to be very expensive and you find a much cheaper and more maintainable
    database that you can use in your code? Let's call the new database, database
    *Y*. You now have to revisit every single piece of your code that did queries
    to database *X* and change it, which may affect much more code than just your
    database layer.
  prefs: []
  type: TYPE_NORMAL
- en: So, what do we do? We simply create an interface that defines all the behaviors
    that we expect from the database layer. All our code outside the database layer
    should only use methods provided by this interface and nothing else. Now, if we
    want to move from database *X* to database *Y*, we can simply write a new database
    layer that can communicate with database *Y* and still support our existing database
    layer interface. By doing this, we ensure that the vast majority of our existing
    code outside of the database layer will stay the same and behave as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to write the database layer interface for our GoMusic application.
    To do so, we have to first identify the behaviors we seek from our database layer,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of all products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a list of all promotions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a customer by the customer's first and last name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a customer by the customer's `id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a product by the product's `id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a user to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark a user in the database as signed in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark a user in the database as signed out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a list of customer orders by the customer's `id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the `backend/src` folder, let''s create a new folder called `dblayer`.
    Inside this folder, we''ll create a new file called `dblayer.go`. This is where
    we''ll write our database layer interface. We start our code by declaring the
    package name and importing the models package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we write our interface, which encapsulates all the behavior points we
    covered in this section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the next chapter, we'll dive back into the database layer to continue its
    implementation. But for now, let's focus on our REST API layer and its implementation
    using the Gin framework.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing RESTful APIs using the Gin framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the backend code for a full stack application such as
    GoMusic needs to interact with the frontend component through RESTful APIs. This
    simply means that a major component of our backend code is the RESTful API layer.
    This layer is what we'll discuss from this point on until the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing code, we need to first agree on our requirements. The
    first step of any well-designed RESTful API backend is to first figure out the
    different interactions between the frontend component and the backend component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what our RESTful API needs to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Our backend needs to provide a list of available products to the frontend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our backend needs to provide a list of available promotions to the frontend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our frontend needs to send user information to our backend in order to sign
    in existing users, or add new users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our frontend needs to send user sign out requests to the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our backend needs to provide a list of existing orders belonging to a specific
    user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our frontend needs to send credit card token information to the backend in order
    to process a charge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By looking at the preceding points, we can guess which HTTP methods to use
    for each one:'
  prefs: []
  type: TYPE_NORMAL
- en: For the first, second, and fifth points, we use a `GET` HTTP request, since
    the server only needs to provide resources (in our case, these are JSON documents)
    as responses to client requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the third, fourth, and sixth points, we use the `POST` HTTP request, since
    the server will be expected to add or manipulate resources based on a client request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at how we can define routes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step to implement a RESTful API is to define the different URLs that
    correspond to the different API actions we need to happen. This is also known
    as defining routes, since the URLs are the routes to our API resources.
  prefs: []
  type: TYPE_NORMAL
- en: We'll go through the RESTful API interactions one by one and define their routes.
    But first, let's start by creating a new file for our RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `backend/src` folder, create a new folder called `rest`. Inside the
    `rest` folder, create a file called `rest.go`. This is where we start using the
    Gin framework. In your favorite Terminal, type the following command in order
    to deploy and install the Gin framework to your development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `rest.go` file, start by declaring the package name and importing the
    Gin framework, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, declare the function that will act as the entry point for our RESTful
    API. This is where we define the HTTP routes for our RESTful API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method takes one argument that will host the address of our RESTful
    API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make use of Gin, we first need to obtain a **Gin engine**. A Gin
    engine is the object type that gives us access to assign HTTP methods to URLs
    to action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to start mapping HTTP methods to URLs to action. For that, we
    need to make use of the Gin engine object that we just created. The following
    code block is a simple example of where we use the Gin engine to accept a `GET`
    request coming to the relative URL, `/relativepath/to/url`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The anonymous function in the preceding code, `func(c *gin.Context){}`, is where
    we define the action that we want to be performed when we receive an incoming
    client request that satisfies our conditions (the `/relativepath/to/url` relative
    path, and the `GET` HTTP method).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*gin.Context` type is provided to us by the Gin framework. It supplies
    us with all the tools that we need to not only explore the incoming request, but
    also to take action and provide the appropriate response. We will discuss the `*gin.Context` type
    in more detail in the next section, but for now, let''s focus on building the
    routes. Let''s revisit the list of API interactions and write some code to represent
    each interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our backend needs to provide a list of available products to the frontend using
    a `GET` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our backend needs to provide a list of available promotions to the frontend
    using a `GET` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our frontend needs to send user information to our backend in order to sign
    in existing users or to add new users using a `POST` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our frontend needs to send user sign out requests to the backend using a `POST`
    request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our backend needs to provide a list of existing orders belonging to a specific
    user using a `GET` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our frontend needs to send credit card token information to the backend in
    order to process a charge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how to build an HTTP handler in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next logical step in building our RESTful API is to define the actions that
    we need to perform when we receive client requests. This is also known as **building
    handlers**. So, let's start.
  prefs: []
  type: TYPE_NORMAL
- en: In the `backend/src/rest` folder, create a new file called `handler.go`. In
    this file, we'll write the code that is needed to handle the actions that correspond
    to the different API requests that our server is expected to receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, the first thing we need to do is to declare the package and import
    the external packages that we need to use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to write clean code that allows extensibility, let''s write an interface
    that represents all the methods that a handler needs to support, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a `struct` type and call it `Handler`; this will host all
    our `Handler` methods. `Handler` will need access to the database layer interface,
    since all our `Handler` methods will need to either retrieve or change data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To follow good design principles, we should create a constructor for `Handler`.
    We''ll just create a simple constructor for now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding constructor will need to evolve in the future in order to initialize
    the database layer. However, let's focus on the `Handler` method for now.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, let's focus on what our API needs to do point by point,
    and then create the corresponding handlers. Each one of the few section will represent
    an API functionality we need to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a full list of available products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a method called `GetProducts` that takes the `*gin.Context`
    type as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to ensure that our database interface is initialized and not
    `nil`, then we use the database layer interface in order to obtain the list of
    products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what happens if the call returns an error? We need to return a JSON document
    to the client with the error. The response to the client also needs to include
    an HTTP status code that indicates that the request failed. An HTTP status code
    is a way to report that an error happened in HTTP communication. This is where
    we start using the `*gin.Context` type, which includes a method called `JSON()`
    that we can use to return JSON documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if there is no error, then we return the list of products we retrieved
    from the database. Since we defined JSON struct tags in our data models, our data
    models will get converted to the JSON document formats that we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Getting a list of promotions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This handler will be very similar to the `GetProducts` handler, except that
    it will use a different database call to retrieve the list of promotions instead
    of the list of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Sign in new users or add new users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The method that we''ll create in this section, handles a `POST` request; here,
    we expect to receive a JSON document from the client that we need to decode before
    we can process the request. Let''s assume that our client sends a JSON document
    that represents the customer. The code to decode the JSON object will look like
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `c.ShouldBindJSON(...)` method is provided to us by the `*gin.Context` type.
    Its main purpose is to extract JSON documents from our HTTP request body, and
    then parse it to the provided argument. In our case, the provided argument was
    a variable of type `*models.Customer`, which is our customer/user data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of our `SignIn` method is simple—if no errors occur from decoding
    the JSON document to the data model, we call the `SignInUser` database layer method
    to sign in or add the customer to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a user, the logic will be very similar, except that we add a user instead
    of signing someone in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sign out requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this handler, we expect a URL with a parameter, such as `/user/:id/signout`.
    Here is what the handler needs to do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the parameter that is the ID of the user we are signing out. This can
    be done by calling a method named `Param()`, which belongs to the `*gin.Context`
    type; the following code block demonstrates how this will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to call the `SignOutUserById` database layer method in order
    to mark the user as having signed out in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Getting orders for a specific user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We expect a URL with a parameter here as well, such as `/user/:id/orders`.
    The `:id` parameter represents the ID of the user whose orders we are trying to
    retrieve. The code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Charging a credit card
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This handler involves more functionality than just reading requests and calling
    the database. This is because we''ll need to interact with Stripe''s API to charge
    a customer''s credit card. We will be covering this method more details in the
    next chapter. For now, let''s create an empty handler to use in our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating our handlers, let''s go back to `./backend/src/rest/rest.go`.
    Instead of mapping our routes to empty handlers, let''s map our routes to the
    handlers that we created in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the last line in our function: `r.Run(address)`. We must call this
    method after we finish defining our API routes and handlers, so that our RESTful
    API server starts listening to incoming requests from HTTP clients.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a number of our routes start with `/user/` and `/users`, the preceding
    code can be refactored further using a method called `Group()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding technique is sometimes known as *grouping routes. *This is when
    we group HTTP routes, that share part of their relative URLs, into a common code
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our code cleaner, let''s rename the preceding function to `RunAPIWithHandler()`,
    because the `handler` can be passed to it as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create a function with the old name `RunAPI()` that represents
    the default state of `RunAPIWithHandler()`. This is when we use the default implementation
    for our `HandlerInterface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our `main.go` file, which should live in the `backend/src` folder of
    our project, we can simply call `RunAPI()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'But what about connecting our React frontend with the newly created backend?
    That''s simple; in our React application `root` folder, there is a file called
    `package.json`. In the `package.json` file, we will need to add the following
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This field will forward any frontend requests to the address specified as the
    proxy. If our web server listens on `127.0.0.1:8000`, which is represented by
    the `address` argument in our `RunAPI()` function, then our web server will receive
    the incoming requests from our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with an overview about RESTful APIs. From there
    we dove into practical topics such as data modeling, defining routes, grouping
    routes, and creating handlers. We covered the knowledge necessary to write functional
    web APIs in Go.
  prefs: []
  type: TYPE_NORMAL
- en: We also got our first exposure to the powerful Gin framework, which is very
    popular for writing production-level RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive deeper into backend web APIs. More advanced
    topics will be covered like ORMs and security. We will also revisit our application's
    frontend, and discuss how it connects to the backend that we built.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Gin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is HTTP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a RESTful API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a URL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a handler?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is JSON?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `Param()` method used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `c.JSON()` method used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `Group()` method used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can go through the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gin: **[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Representational state transfer**:[ https://stackoverflow.com/a/29648972](https://stackoverflow.com/a/29648972)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
