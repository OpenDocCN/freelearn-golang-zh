- en: RESTful Web APIs in Go with the Gin Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gin 框架在 Go 中构建 RESTful Web API
- en: In the previous chapters, we explored how to build an engaging frontend for
    our application, by utilizing the popular React framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了如何利用流行的 React 框架构建我们应用程序的引人入胜的前端。
- en: It's now time to cover how to build efficient backend code in the Go programming
    language to work with our frontend. In this chapter, we'll make use of the super-fast
    Gin framework to build some of the APIs needed for the project of this book (that
    is, the GoMusic store).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍如何在 Go 编程语言中构建高效的后端代码，以便与我们的前端一起工作。在本章中，我们将使用超快的 Gin 框架构建本书项目（即 GoMusic
    商店）所需的某些 API。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: RESTful APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API
- en: The Gin framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gin 框架
- en: Models and bindings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型和绑定
- en: HTTP handlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 处理器
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter06).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter06)。
- en: RESTful APIs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API
- en: Any backend software system needs a set of APIs to communicate with the frontend.
    Full stack software is simply composed of a frontend component from one side that
    exchanges messages with a backend component from the other side. One of the most
    popular types of APIs used in full stack software are RESTful APIs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后端软件系统都需要一组 API 来与前端通信。全栈软件简单地说是由一侧的前端组件和另一侧的后端组件交换消息组成的。全栈软件中最流行的 API 类型之一是
    RESTful API。
- en: Let's cover an overview of RESTful APIs in the next section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中概述 RESTful API。
- en: Overview
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: '**RESTful APIs** can simply be defined as a set of rules used to build web
    services where you retrieve or manipulate resources. A **resource** is typically
    a kind of document—it could be an HTML document (such as a web page), a JSON document
    (for pure information sharing), or some other type of document. **JSON** stands
    for **JavaScript Object Notation**; this is because it basically refers to how
    you would write the object in JavaScript. It''s very popular and is widely used.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**RESTful API** 可以简单地定义为用于构建 Web 服务的一组规则，其中你可以检索或操作资源。**资源**通常是一种文档——它可能是一个
    HTML 文档（例如网页），一个 JSON 文档（用于纯信息共享），或其它类型的文档。**JSON** 代表 **JavaScript 对象表示法**；这是因为它基本上指的是你如何在
    JavaScript 中编写对象。它非常流行并且被广泛使用。'
- en: 'For the majority of RESTful APIs, HTTP is utilized as the communication layer
    for the API:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数 RESTful API，HTTP 被用作 API 的通信层：
- en: '![](img/8e8502d2-6914-4386-aab4-e79bc82d31ef.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e8502d2-6914-4386-aab4-e79bc82d31ef.png)'
- en: The topic can be very lengthy; however, there are a few simple facts and concepts
    that you need to know in order to properly write RESTful APIs. In the next few
    sections, we will provide an overview of the key building blocks behind RESTful
    APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题可能非常冗长；然而，有一些简单的事实和概念你需要了解，以便正确地编写 RESTful API。在接下来的几节中，我们将概述 RESTful API
    背后的关键构建块。
- en: We'll take a look at the client-server architecture, URLs and the HTTP methods
    in the next sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨客户端-服务器架构、URL 和 HTTP 方法。
- en: The client-server architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: 'RESTful APIs rely on the client-server architecture. This simply means that
    for RESTful APIs, you need two main components—a client and a server. A client
    sends an HTTP request to a server, and the server replies with an HTTP response
    to the client. A single server typically handles numerous clients at the same
    time:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 依赖于客户端-服务器架构。这仅仅意味着对于 RESTful API，你需要两个主要组件——客户端和服务器。客户端向服务器发送 HTTP
    请求，服务器向客户端回复 HTTP 响应。单个服务器通常同时处理多个客户端：
- en: '![](img/7a341150-ee64-46c8-9b63-c47e26eb7134.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a341150-ee64-46c8-9b63-c47e26eb7134.png)'
- en: 'The preceding diagram can be explained with the help of following points:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点可以帮助解释前面的图表：
- en: The client is the component that initiates the API request. A client either
    asks for a resource from a server, or sends a resource to a server.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端是发起 API 请求的组件。客户端要么从服务器请求资源，要么向服务器发送资源。
- en: The server is the component that receives requests and then processes them.
    A server either sends a resource to a client when requested to do so, or adds/modifies
    a resource when a client requests this to happen.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器是接收请求并对其进行处理的组件。服务器在客户端请求时发送资源，或者在客户端请求这样做时添加/修改资源。
- en: URLs
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URLs
- en: A URL can simply be defined as the address for a particular RESTful API resource.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: URL可以简单地定义为特定RESTful API资源的地址。
- en: When a client sends a request to a server, the client sends the request to a
    URL address that is being watched by the server. Any RESTful API interaction involves
    a client sending a message to a URL address.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向服务器发送请求时，客户端会将请求发送到服务器正在监视的URL地址。任何RESTful API交互都涉及客户端向URL地址发送消息。
- en: In order to form an understanding about what a URL consists of, let's take `http://www.example.com/user?id=1` as an
    example.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解URL由什么组成，让我们以`http://www.example.com/user?id=1`为例。
- en: 'The preceding URL consists of three main components that we need to be aware
    of, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的URL包含三个主要组成部分，我们需要注意如下：
- en: '**The server location**: This is basically the combination of the protocol
    and the server domain name, `http://www.example.com/`.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器位置**：这基本上是协议和服务器域名的组合，`http://www.example.com/`。'
- en: '**The relative URL path**: This is the relative URL address from the server
    address, `/user`.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**相对URL路径**：这是从服务器地址开始的相对URL地址，`/user`。'
- en: '**The query**: This is a query used to identify what resources we seek, such
    as `?id=1`.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查询**：这是一个用于识别我们寻求哪些资源的查询，例如`?id=1`。'
- en: The first two components exist in the vast majority of RESTful API interactions,
    whereas the third component is used for more specialized API calls.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个组件存在于绝大多数RESTful API交互中，而第三个组件用于更专业的API调用。
- en: HTTP methods
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP方法
- en: As mentioned earlier, clients send requests to servers. The requests can be
    used to retrieve resources from servers, or manipulate resources hosted by servers.
    However, how can we tell what a particular request wants? This is where HTTP methods
    are used. An HTTP method is basically how an HTTP request from a client reveals
    its intention to a server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，客户端向服务器发送请求。请求可以用来从服务器检索资源，或者操作由服务器托管的资源。然而，我们如何判断特定请求的意图？这就是HTTP方法发挥作用的地方。HTTP方法基本上是客户端如何向服务器表明其意图。
- en: 'There are numerous method types that can be supported by HTTP requests; however,
    since this book is all about practicality, we''ll discuss three of the most commonly
    used request methods in the world of RESTful APIs:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求可以支持多种方法类型；然而，由于本书主要关注实用性，我们将讨论在RESTful API领域中最为常用的三种请求方法：
- en: '**The** `GET` **request method**: A `GET` HTTP request method is used when
    a client''s intention is to retrieve a resource from the server. Whenever you
    open a web browser such as Google Chrome, and then type in `www.google.com`, your
    web browser acts as an HTTP client that sends a `GET` HTTP request to the [www.google.com](http://google.com)
    URL. Google servers then receive your client''s request and respond with Google''s
    main page, which is simply an HTML document that is then translated by your web
    browser to look pretty.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET请求方法**：当客户端的意图是从服务器检索资源时，使用`GET` HTTP请求方法。每次你打开一个网络浏览器，例如Google Chrome，并输入`www.google.com`时，你的网络浏览器就充当一个HTTP客户端，向`www.google.com`
    URL发送一个`GET` HTTP请求。然后，Google服务器接收你的客户端请求，并响应Google的主页，这是一个简单的HTML文档，然后由你的网络浏览器翻译成漂亮的界面。'
- en: '**The** `POST` **request method**: A `POST` HTTP request method is used when
    the client''s intention is to send data to the server. When a client sends a `POST`
    request, it must also include the data that the server is supposed to receive
    in the message body of the request. The URL address of the request identifies
    the resource that we are either adding or changing with the new data being sent.
    There is another HTTP method called `PUT`, which can be used to add or replace
    resource. However, we''ll be using `POST` in our code.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST请求方法**：当客户端的意图是向服务器发送数据时，使用`POST` HTTP请求方法。当客户端发送`POST`请求时，它还必须在请求的消息体中包含服务器应该接收的数据。请求的URL地址标识了我们要添加或更改的资源。还有一个名为`PUT`的HTTP方法，可以用来添加或替换资源。然而，在我们的代码中我们将使用`POST`。'
- en: '**The** `DELETE` **request method**: A `DELETE` HTTP request method is used
    when the client''s intention is to delete a resource from the server. The URL
    of the request will identify the resource that we want to delete.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**请求方法：当客户端的意图是从服务器删除资源时，会使用**删除** HTTP 请求方法。请求的 URL 将标识我们想要删除的资源。'
- en: Now that we covered REST APIs, it's time to explore the Gin framework, which
    is how we'll build a REST API in our Go code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 REST API，是时候探索 Gin 框架了，这是我们将在 Go 代码中构建 REST API 的方式。
- en: The Gin framework
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gin 框架
- en: Gin is a very popular Go open source framework that is mainly used to build
    ultra-high performance RESTful APIs. The project can be found at [https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin).
    Gin is not only fast, but it also enjoys a simple and fun-to-use API that makes
    building production-level RESTful APIs a breeze.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Gin 是一个非常流行的 Go 开源框架，主要用于构建超高性能的 RESTful API。该项目可以在 [https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)
    找到。Gin 不仅速度快，而且拥有简单、易于使用的 API，这使得构建生产级别的 RESTful API 变得轻而易举。
- en: In this section, we will learn how to build a web RESTful API through the Gin
    framework, by starting the implementation of the backend code that is needed to
    support our GoMusic store.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何通过 Gin 框架构建一个 Web RESTful API，通过开始实现支持我们的 GoMusic 商店的必要后端代码。
- en: Let's take a look at models and the database layer in the next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的模型和数据库层。
- en: Models and the database layer
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型和数据库层
- en: Our backend obviously needs a database to store all the data that our RESTful
    API is supposed to expose. Let's call the database interaction code our *database
    layer*. In the world of backend software systems, careful and thoughtful design
    needs to be applied when writing the database layer. This is because the database
    layer is vital for almost all of the major functionalities in backend systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端显然需要一个数据库来存储我们的 RESTful API 应该公开的所有数据。让我们把数据库交互代码称为我们的**数据库层**。在后端软件系统的世界中，编写数据库层时需要谨慎和周到的设计。这是因为数据库层对于后端系统中的几乎所有主要功能都是至关重要的。
- en: Let's get into the details of models in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中详细了解模型。
- en: Models
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: The first step to building a well-designed database layer is to build models
    for the data. **Data models** can simply be described as data structures that
    represent the information that we retrieve from the database and use in our APIs.
    This is best explained by an example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 构建良好设计的数据库层的第一步是为数据构建模型。**数据模型**可以简单地描述为表示我们从数据库检索并用于我们的 API 的信息的数据结构。这最好通过一个例子来解释。
- en: 'In our GoMusic application, since it''s simply an online store that sells products,
    we can identify the distinct models that our application needs to support, as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 GoMusic 应用程序中，因为它只是一个简单的在线商店，出售产品，我们可以确定我们的应用程序需要支持的不同模型，如下所示：
- en: A product
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个产品
- en: A customer
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个客户
- en: A customer order
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个客户订单
- en: 'Let''s start writing some code; in your project root folder, you need to create
    a new folder called `backend`. Underneath this, create a folder called `src`,
    then underneath the `src` folder, create a folder called `models`. Now, inside
    the `models` folder, create a new file called `models.go`. This is where we''ll
    write our models. The first thing we need to do is to define a package, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一些代码；在你的项目根目录下，你需要创建一个名为 `backend` 的新文件夹。在这个文件夹下面，创建一个名为 `src` 的文件夹，然后在
    `src` 文件夹下面，创建一个名为 `models` 的文件夹。现在，在 `models` 文件夹中，创建一个名为 `models.go` 的新文件。这就是我们将编写我们的模型的地方。我们首先需要做的是定义一个包，如下所示：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let''s write our `Product` data structure, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写我们的 `Product` 数据结构，如下所示：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You might be wondering about the strange `` `json:"..."` `` syntax inside our
    Go struct; this syntax is known as **struct tags**. In our case, the struct tags
    are used to indicate how the field in question will look in a JSON document. JSON
    is a very popular data serialization format that is typically used to share data
    in RESTful APIs. The preceding Go struct will look like the following code snippet
    in a JSON format:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对我们的 Go 结构体中奇怪的 `` `json:"..."` `` 语法感到困惑；这种语法被称为**结构体标签**。在我们的例子中，结构体标签用于指示相关字段在
    JSON 文档中的外观。JSON 是一个非常流行的数据序列化格式，通常用于在 RESTful API 中共享数据。前面的 Go 结构体在 JSON 格式下将看起来像以下代码片段：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the preceding JSON data block, you can tell how easy it is to represent
    data in JSON.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的 JSON 数据块中，你可以看出在 JSON 中表示数据是多么容易。
- en: If we don't use JSON structure fields in our Go struct, Go will make some default
    assumptions when converting our Go struct field names to JSON field names. For
    example, all uppercase first letters in the Go struct fields will convert to lowercase
    first letters in the JSON document. It is typically preferred to use JSON struct
    tags in order to be in full control of what the JSON document will look like.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的 Go 结构体中不使用 JSON 结构字段，Go 在将我们的 Go 结构体字段名转换为 JSON 字段名时会做出一些默认假设。例如，Go 结构体字段中的所有大写首字母将转换为
    JSON 文档中的小写首字母。通常，使用 JSON 结构体标签是为了完全控制 JSON 文档的外观。
- en: 'Perfect; now, let''s write our `Customer` data structure, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完美；现在，让我们编写我们的`Customer`数据结构，如下所示：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let''s write our `Order` data structure, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写我们的`Order`数据结构，如下所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding data structure makes use of a Go feature known as *embedding*.
    Embedding in our example here simply means that we include all the fields of a
    different Go struct in the current Go struct. We embedded the `Product` and `Customer`
    Go structs in the `Order` Go struct. This means that all the product and customer
    Go struct fields, such as `img` and `firstname`, are now part of the `Order` struct.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数据结构使用了 Go 的一项特性，称为*嵌入*。在我们的例子中，嵌入简单意味着我们在当前 Go 结构体中包含了另一个 Go 结构体的所有字段。我们在`Order`
    Go 结构体中嵌入了`Product`和`Customer` Go 结构体。这意味着所有产品客户 Go 结构体字段，如`img`和`firstname`，现在都是`Order`结构体的一部分。
- en: Let's take a look at the database layer interface in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的数据库层接口。
- en: The database layer interface
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库层接口
- en: Another major part of well-designed database layers is the database layer interface.
    In order to fully appreciate the need for a database interface layer, let's imagine
    a quick scenario. Let's say you build your backend to use database *X*, and all
    your code relies on direct calls to database *X*. Now, what happens if database
    *X* turns out to be very expensive and you find a much cheaper and more maintainable
    database that you can use in your code? Let's call the new database, database
    *Y*. You now have to revisit every single piece of your code that did queries
    to database *X* and change it, which may affect much more code than just your
    database layer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的数据库层的另一个重要部分是数据库层接口。为了完全理解数据库接口层的必要性，让我们想象一个快速场景。假设你构建的后端使用数据库 *X*，并且所有代码都依赖于对数据库
    *X* 的直接调用。现在，如果数据库 *X* 证明非常昂贵，而你发现了一个更便宜、更易于维护的数据库可以在代码中使用，我们可以将这个新数据库称为数据库 *Y*。你现在必须重新审视所有查询数据库
    *X* 的代码，并进行更改，这可能会影响比数据库层更多的代码。
- en: So, what do we do? We simply create an interface that defines all the behaviors
    that we expect from the database layer. All our code outside the database layer
    should only use methods provided by this interface and nothing else. Now, if we
    want to move from database *X* to database *Y*, we can simply write a new database
    layer that can communicate with database *Y* and still support our existing database
    layer interface. By doing this, we ensure that the vast majority of our existing
    code outside of the database layer will stay the same and behave as expected.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该怎么做呢？我们只需创建一个接口，定义我们从数据库层期望的所有行为。数据库层之外的所有代码应该只使用此接口提供的方法，而不使用其他任何方法。现在，如果我们想从数据库
    *X* 迁移到数据库 *Y*，我们可以简单地编写一个新的数据库层，它可以与数据库 *Y* 通信，同时仍然支持现有的数据库层接口。通过这样做，我们确保数据库层之外的大量现有代码将保持不变，并按预期运行。
- en: 'Our next step is to write the database layer interface for our GoMusic application.
    To do so, we have to first identify the behaviors we seek from our database layer,
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是编写 GoMusic 应用的数据库层接口。为此，我们必须首先确定我们希望从数据库层获得的行为，如下所示：
- en: Get a list of all products
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有产品的列表
- en: Get a list of all promotions
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有促销活动的列表
- en: Get a customer by the customer's first and last name
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过客户的首名和姓氏获取客户信息
- en: Get a customer by the customer's `id`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过客户的`id`获取客户信息
- en: Get a product by the product's `id`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过产品的`id`获取产品信息
- en: Add a user to the database
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户添加到数据库中
- en: Mark a user in the database as signed in
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中将用户标记为已登录
- en: Mark a user in the database as signed out
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中将用户标记为已注销
- en: Get a list of customer orders by the customer's `id`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过客户的`id`获取客户订单列表
- en: 'Inside the `backend/src` folder, let''s create a new folder called `dblayer`.
    Inside this folder, we''ll create a new file called `dblayer.go`. This is where
    we''ll write our database layer interface. We start our code by declaring the
    package name and importing the models package, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`backend/src`文件夹内，让我们创建一个名为`dblayer`的新文件夹。在这个文件夹内，我们将创建一个名为`dblayer.go`的新文件。这是我们编写数据库层接口的地方。我们通过声明包名和导入模型包开始我们的代码，如下所示：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we write our interface, which encapsulates all the behavior points we
    covered in this section, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写我们的接口，它封装了本节中涵盖的所有行为点，如下所示：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the next chapter, we'll dive back into the database layer to continue its
    implementation. But for now, let's focus on our REST API layer and its implementation
    using the Gin framework.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到数据库层继续其实现。但到目前为止，让我们专注于我们的REST API层及其使用Gin框架的实现。
- en: Implementing RESTful APIs using the Gin framework
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gin框架实现RESTful API
- en: As mentioned earlier, the backend code for a full stack application such as
    GoMusic needs to interact with the frontend component through RESTful APIs. This
    simply means that a major component of our backend code is the RESTful API layer.
    This layer is what we'll discuss from this point on until the end of the chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GoMusic这样的全栈应用程序的后端代码需要通过RESTful API与前端组件交互。这仅仅意味着我们后端代码的一个主要部分是RESTful
    API层。从现在起，我们将讨论这个层，直到本章结束。
- en: Before we start writing code, we need to first agree on our requirements. The
    first step of any well-designed RESTful API backend is to first figure out the
    different interactions between the frontend component and the backend component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，我们首先需要就我们的需求达成一致。任何精心设计的RESTful API后端的第一步是首先弄清楚前端组件和后端组件之间的不同交互。
- en: 'Here is what our RESTful API needs to do:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的RESTful API需要做的事情：
- en: Our backend needs to provide a list of available products to the frontend.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的后端需要向前端提供一个可用的产品列表。
- en: Our backend needs to provide a list of available promotions to the frontend.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的后端需要向前端提供一个可用的促销列表。
- en: Our frontend needs to send user information to our backend in order to sign
    in existing users, or add new users.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的前端需要将用户信息发送到我们的后端，以便登录现有用户或添加新用户。
- en: Our frontend needs to send user sign out requests to the backend.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的前端需要将用户注销请求发送到后端。
- en: Our backend needs to provide a list of existing orders belonging to a specific
    user.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的后端需要提供一个特定用户的现有订单列表。
- en: Our frontend needs to send credit card token information to the backend in order
    to process a charge.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的前端需要将信用卡令牌信息发送到后端以处理收费。
- en: 'By looking at the preceding points, we can guess which HTTP methods to use
    for each one:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的点，我们可以猜测每个点应使用哪种HTTP方法：
- en: For the first, second, and fifth points, we use a `GET` HTTP request, since
    the server only needs to provide resources (in our case, these are JSON documents)
    as responses to client requests.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一、第二和第五点，我们使用`GET` HTTP请求，因为服务器只需要提供资源（在我们的例子中，这些是JSON文档）作为对客户端请求的响应。
- en: For the third, fourth, and sixth points, we use the `POST` HTTP request, since
    the server will be expected to add or manipulate resources based on a client request.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第三、第四和第六点，我们使用`POST` HTTP请求，因为服务器预计将根据客户端请求添加或操作资源。
- en: Let's take a look at how we can define routes in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在下一节中定义路由。
- en: Defining routes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义路由
- en: The next step to implement a RESTful API is to define the different URLs that
    correspond to the different API actions we need to happen. This is also known
    as defining routes, since the URLs are the routes to our API resources.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现RESTful API的下一步是定义对应于我们需要发生的不同API动作的不同URL。这也被称为定义路由，因为URL是我们API资源的路由。
- en: We'll go through the RESTful API interactions one by one and define their routes.
    But first, let's start by creating a new file for our RESTful API.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一通过RESTful API交互并定义它们的路由。但首先，让我们为我们的RESTful API创建一个新文件。
- en: 'In the `backend/src` folder, create a new folder called `rest`. Inside the
    `rest` folder, create a file called `rest.go`. This is where we start using the
    Gin framework. In your favorite Terminal, type the following command in order
    to deploy and install the Gin framework to your development environment:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`backend/src`文件夹中，创建一个名为`rest`的新文件夹。在`rest`文件夹内，创建一个名为`rest.go`的文件。这是我们开始使用Gin框架的地方。在你的终端中，输入以下命令以部署和安装Gin框架到你的开发环境：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `rest.go` file, start by declaring the package name and importing the
    Gin framework, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rest.go`文件中，首先声明包名并导入Gin框架，如下所示：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, declare the function that will act as the entry point for our RESTful
    API. This is where we define the HTTP routes for our RESTful API:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，声明一个作为我们RESTful API入口点的函数。这是我们定义RESTful API的HTTP路由的地方：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding method takes one argument that will host the address of our RESTful
    API server.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法接受一个参数，该参数将托管我们的RESTful API服务器的地址。
- en: 'In order to make use of Gin, we first need to obtain a **Gin engine**. A Gin
    engine is the object type that gives us access to assign HTTP methods to URLs
    to action:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Gin，我们首先需要获取一个**Gin引擎**。Gin引擎是对象类型，它为我们提供了将HTTP方法分配给URL以执行操作的能力：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to start mapping HTTP methods to URLs to action. For that, we
    need to make use of the Gin engine object that we just created. The following
    code block is a simple example of where we use the Gin engine to accept a `GET`
    request coming to the relative URL, `/relativepath/to/url`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要开始将HTTP方法映射到URL以执行操作。为此，我们需要使用我们刚刚创建的Gin引擎对象。以下代码块是一个简单的示例，展示了我们如何使用Gin引擎接受一个到达相对URL
    `/relativepath/to/url` 的`GET`请求：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The anonymous function in the preceding code, `func(c *gin.Context){}`, is where
    we define the action that we want to be performed when we receive an incoming
    client request that satisfies our conditions (the `/relativepath/to/url` relative
    path, and the `GET` HTTP method).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，匿名函数`func(c *gin.Context){}`是我们定义当收到满足我们条件（`/relativepath/to/url`相对路径和`GET`
    HTTP方法）的客户端请求时想要执行的操作的地方。
- en: 'The `*gin.Context` type is provided to us by the Gin framework. It supplies
    us with all the tools that we need to not only explore the incoming request, but
    also to take action and provide the appropriate response. We will discuss the `*gin.Context` type
    in more detail in the next section, but for now, let''s focus on building the
    routes. Let''s revisit the list of API interactions and write some code to represent
    each interaction:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`*gin.Context`类型是由Gin框架提供的。它为我们提供了所有工具，不仅可以帮助我们探索传入的请求，还可以采取行动并提供适当的响应。我们将在下一节中更详细地讨论`*gin.Context`类型，但现在，让我们专注于构建路由。让我们回顾一下API交互列表，并编写一些代码来表示每个交互：'
- en: 'Our backend needs to provide a list of available products to the frontend using
    a `GET` request:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的后端需要通过一个`GET`请求向前端提供一个可用的产品列表：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our backend needs to provide a list of available promotions to the frontend
    using a `GET` request:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的后端需要通过一个`GET`请求向前端提供一个可用的促销列表：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our frontend needs to send user information to our backend in order to sign
    in existing users or to add new users using a `POST` request:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的前端需要通过一个`POST`请求将用户信息发送到我们的后端，以便登录现有用户或添加新用户：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our frontend needs to send user sign out requests to the backend using a `POST`
    request:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的前端需要通过一个`POST`请求将用户注销请求发送到后端：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our backend needs to provide a list of existing orders belonging to a specific
    user using a `GET` request:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的后端需要通过一个`GET`请求提供一个特定用户的现有订单列表：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our frontend needs to send credit card token information to the backend in
    order to process a charge:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的前端需要将信用卡令牌信息发送到后端以处理一笔交易：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's see how to build an HTTP handler in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在下一节中构建一个HTTP处理器。
- en: Creating handlers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建处理器
- en: The next logical step in building our RESTful API is to define the actions that
    we need to perform when we receive client requests. This is also known as **building
    handlers**. So, let's start.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的RESTful API的下一步逻辑步骤中，我们需要定义当收到客户端请求时需要执行的操作。这也被称为**构建处理器**。所以，让我们开始吧。
- en: In the `backend/src/rest` folder, create a new file called `handler.go`. In
    this file, we'll write the code that is needed to handle the actions that correspond
    to the different API requests that our server is expected to receive.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`backend/src/rest`文件夹中，创建一个名为`handler.go`的新文件。在这个文件中，我们将编写处理服务器预期接收的不同API请求所需操作所需的代码。
- en: 'As always, the first thing we need to do is to declare the package and import
    the external packages that we need to use, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们首先需要做的是声明包并导入我们需要的外部包，如下所示：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to write clean code that allows extensibility, let''s write an interface
    that represents all the methods that a handler needs to support, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写可扩展的干净代码，让我们编写一个表示处理器需要支持的所有方法的接口，如下所示：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let''s create a `struct` type and call it `Handler`; this will host all
    our `Handler` methods. `Handler` will need access to the database layer interface,
    since all our `Handler` methods will need to either retrieve or change data:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为`Handler`的结构体类型；这将包含我们所有的`Handler`方法。`Handler`需要访问数据库层接口，因为我们的所有`Handler`方法都需要检索或更改数据：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To follow good design principles, we should create a constructor for `Handler`.
    We''ll just create a simple constructor for now, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循良好的设计原则，我们应该为`Handler`创建一个构造函数。我们现在将创建一个简单的构造函数，如下所示：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding constructor will need to evolve in the future in order to initialize
    the database layer. However, let's focus on the `Handler` method for now.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的构造函数将需要在将来进化以初始化数据库层。然而，让我们现在专注于`Handler`方法。
- en: In the next few sections, let's focus on what our API needs to do point by point,
    and then create the corresponding handlers. Each one of the few section will represent
    an API functionality we need to implement.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个部分中，让我们逐点关注我们的API需要做什么，然后创建相应的处理程序。每个小节将代表我们需要实现的API功能。
- en: Getting a full list of available products
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有可用产品的完整列表
- en: 'First, let''s create a method called `GetProducts` that takes the `*gin.Context`
    type as an argument:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`GetProducts`的方法，它接受`*gin.Context`类型作为参数：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we need to ensure that our database interface is initialized and not
    `nil`, then we use the database layer interface in order to obtain the list of
    products:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保我们的数据库接口已初始化且不是`nil`，然后我们使用数据库层接口来获取产品列表：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, what happens if the call returns an error? We need to return a JSON document
    to the client with the error. The response to the client also needs to include
    an HTTP status code that indicates that the request failed. An HTTP status code
    is a way to report that an error happened in HTTP communication. This is where
    we start using the `*gin.Context` type, which includes a method called `JSON()`
    that we can use to return JSON documents:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果调用返回错误会发生什么？我们需要返回一个包含错误的JSON文档给客户端。客户端的响应还需要包括一个HTTP状态码，以指示请求失败。HTTP状态码是一种在HTTP通信中报告错误的方式。这就是我们开始使用`*gin.Context`类型的地方，它包括一个名为`JSON()`的方法，我们可以使用它来返回JSON文档：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, if there is no error, then we return the list of products we retrieved
    from the database. Since we defined JSON struct tags in our data models, our data
    models will get converted to the JSON document formats that we defined:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果没有错误，我们将返回从数据库检索到的产品列表。由于我们在数据模型中定义了JSON结构标签，我们的数据模型将转换为定义的JSON文档格式：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Getting a list of promotions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取促销列表
- en: 'This handler will be very similar to the `GetProducts` handler, except that
    it will use a different database call to retrieve the list of promotions instead
    of the list of products:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序将与`GetProducts`处理程序非常相似，但它将使用不同的数据库调用来检索促销列表，而不是产品列表：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Sign in new users or add new users
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录新用户或添加新用户
- en: 'The method that we''ll create in this section, handles a `POST` request; here,
    we expect to receive a JSON document from the client that we need to decode before
    we can process the request. Let''s assume that our client sends a JSON document
    that represents the customer. The code to decode the JSON object will look like
    the following code block:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中创建的方法处理一个`POST`请求；在这里，我们期望从客户端接收一个JSON文档，在我们处理请求之前需要对其进行解码。让我们假设客户端发送了一个表示客户的JSON文档。解码JSON对象的代码将类似于以下代码块：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `c.ShouldBindJSON(...)` method is provided to us by the `*gin.Context` type.
    Its main purpose is to extract JSON documents from our HTTP request body, and
    then parse it to the provided argument. In our case, the provided argument was
    a variable of type `*models.Customer`, which is our customer/user data model.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`c.ShouldBindJSON(...)`方法是由`*gin.Context`类型提供的。其主要目的是从我们的HTTP请求体中提取JSON文档，然后将其解析到提供的参数中。在我们的例子中，提供的参数是一个类型为`*models.Customer`的变量，这是我们的客户/用户数据模型。'
- en: 'The rest of our `SignIn` method is simple—if no errors occur from decoding
    the JSON document to the data model, we call the `SignInUser` database layer method
    to sign in or add the customer to the database:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`SignIn`方法的其余部分很简单——如果没有错误从JSON文档解码到数据模型，我们调用`SignInUser`数据库层方法来登录或把客户添加到数据库中：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To add a user, the logic will be very similar, except that we add a user instead
    of signing someone in:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加用户，逻辑将非常相似，只是我们添加用户而不是登录某人：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sign out requests
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登出请求
- en: 'For this handler, we expect a URL with a parameter, such as `/user/:id/signout`.
    Here is what the handler needs to do:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此处理程序，我们期望一个带有参数的 URL，例如 `/user/:id/signout`。以下是处理程序需要执行的操作：
- en: 'Extract the parameter that is the ID of the user we are signing out. This can
    be done by calling a method named `Param()`, which belongs to the `*gin.Context`
    type; the following code block demonstrates how this will look:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取代表我们要注销的用户 ID 的参数。这可以通过调用一个名为 `Param()` 的方法来实现，该方法属于 `*gin.Context` 类型；以下代码块演示了这将如何显示：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we need to call the `SignOutUserById` database layer method in order
    to mark the user as having signed out in the database:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要调用 `SignOutUserById` 数据库层方法，以便在数据库中标记用户已注销：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Getting orders for a specific user
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取特定用户的订单
- en: 'We expect a URL with a parameter here as well, such as `/user/:id/orders`.
    The `:id` parameter represents the ID of the user whose orders we are trying to
    retrieve. The code will look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也期望这里有一个带有参数的 URL，例如 `/user/:id/orders`。`:id` 参数代表我们试图检索订单的用户 ID。代码将如下所示：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Charging a credit card
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收费信用卡
- en: 'This handler involves more functionality than just reading requests and calling
    the database. This is because we''ll need to interact with Stripe''s API to charge
    a customer''s credit card. We will be covering this method more details in the
    next chapter. For now, let''s create an empty handler to use in our code, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序涉及的功能不仅限于读取请求和调用数据库。这是因为我们需要与 Stripe 的 API 交互，以向客户的信用卡收费。我们将在下一章中更详细地介绍此方法。现在，让我们创建一个空处理程序，如下所示，以便在我们的代码中使用：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Putting it all together
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: 'After creating our handlers, let''s go back to `./backend/src/rest/rest.go`.
    Instead of mapping our routes to empty handlers, let''s map our routes to the
    handlers that we created in the previous section:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的处理程序后，让我们回到 `./backend/src/rest/rest.go`。而不是将我们的路由映射到空处理程序，让我们将我们的路由映射到上一节中创建的处理程序：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Observe the last line in our function: `r.Run(address)`. We must call this
    method after we finish defining our API routes and handlers, so that our RESTful
    API server starts listening to incoming requests from HTTP clients.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们函数中的最后一行：`r.Run(address)`。我们必须在定义完我们的 API 路由和处理程序后调用此方法，以便我们的 RESTful API
    服务器开始监听来自 HTTP 客户端的传入请求。
- en: 'Since a number of our routes start with `/user/` and `/users`, the preceding
    code can be refactored further using a method called `Group()`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的一些路由以 `/user/` 和 `/users` 开头，前面的代码可以使用名为 `Group()` 的方法进一步重构：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding technique is sometimes known as *grouping routes. *This is when
    we group HTTP routes, that share part of their relative URLs, into a common code
    block.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上述技术有时被称为 *分组路由*。这是当我们将具有部分相对 URL 相同的 HTTP 路由组合到一个公共代码块中时。
- en: 'To make our code cleaner, let''s rename the preceding function to `RunAPIWithHandler()`,
    because the `handler` can be passed to it as an argument:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码更简洁，让我们将前面的函数重命名为 `RunAPIWithHandler()`，因为 `handler` 可以作为参数传递给它：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, let''s create a function with the old name `RunAPI()` that represents
    the default state of `RunAPIWithHandler()`. This is when we use the default implementation
    for our `HandlerInterface`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个具有旧名称 `RunAPI()` 的函数，它代表 `RunAPIWithHandler()` 的默认状态。这是当我们为我们的 `HandlerInterface`
    使用默认实现时：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, in our `main.go` file, which should live in the `backend/src` folder of
    our project, we can simply call `RunAPI()`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `main.go` 文件中，它应该位于我们的项目 `backend/src` 文件夹中，我们可以简单地调用 `RunAPI()`，如下所示：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But what about connecting our React frontend with the newly created backend?
    That''s simple; in our React application `root` folder, there is a file called
    `package.json`. In the `package.json` file, we will need to add the following
    field:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何将我们的 React 前端与新建的后端连接呢？这很简单；在我们的 React 应用 `root` 文件夹中，有一个名为 `package.json`
    的文件。在 `package.json` 文件中，我们需要添加以下字段：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This field will forward any frontend requests to the address specified as the
    proxy. If our web server listens on `127.0.0.1:8000`, which is represented by
    the `address` argument in our `RunAPI()` function, then our web server will receive
    the incoming requests from our frontend.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段将转发任何前端请求到作为代理指定的地址。如果我们的 Web 服务器监听 `127.0.0.1:8000`，这在我们的 `RunAPI()` 函数中由
    `address` 参数表示，那么我们的 Web 服务器将接收来自前端的前入请求。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with an overview about RESTful APIs. From there
    we dove into practical topics such as data modeling, defining routes, grouping
    routes, and creating handlers. We covered the knowledge necessary to write functional
    web APIs in Go.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从RESTful API的概述开始。然后我们深入到实际主题，如数据建模、定义路由、分组路由和创建处理器。我们涵盖了编写功能性的Go Web
    API所需的知识。
- en: We also got our first exposure to the powerful Gin framework, which is very
    popular for writing production-level RESTful APIs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也首次接触到了强大的Gin框架，它非常流行于编写生产级别的RESTful API。
- en: In the next chapter, we'll dive deeper into backend web APIs. More advanced
    topics will be covered like ORMs and security. We will also revisit our application's
    frontend, and discuss how it connects to the backend that we built.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨后端Web API。我们将涵盖更高级的主题，如ORM和安全性。我们还将回顾我们的应用程序的前端，并讨论它如何连接到我们构建的后端。
- en: Questions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Gin?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Gin？
- en: What is HTTP?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是HTTP？
- en: What is a RESTful API?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是RESTful API？
- en: What is a URL?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是URL？
- en: What is a handler?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是处理器？
- en: What is JSON?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是JSON？
- en: What is the `Param()` method used for?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Param()`方法用于什么？'
- en: What is the `c.JSON()` method used for?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`c.JSON()`方法用于什么？'
- en: What is the `Group()` method used for?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Group()`方法用于什么？'
- en: Further reading
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can go through the following links:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，您可以查看以下链接：
- en: '**Gin: **[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**琴酒：**[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)'
- en: '**Representational state transfer**:[ https://stackoverflow.com/a/29648972](https://stackoverflow.com/a/29648972)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表征状态转移**：[ https://stackoverflow.com/a/29648972](https://stackoverflow.com/a/29648972)'
