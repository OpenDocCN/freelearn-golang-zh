["```go\ntype DBLayer interface {\n  GetAllProducts() ([]models.Product, error)\n  GetPromos() ([]models.Product, error)\n  GetCustomerByName(string, string) (models.Customer, error)\n  GetCustomerByID(int) (models.Customer, error)\n  GetProduct(int) (models.Product, error)\n  AddUser(models.Customer) (models.Customer, error)\n  SignInUser(username, password string) (models.Customer, error)\n  SignOutUserById(int) error\n  GetCustomerOrdersByID(int) ([]models.Order, error)\n}\n```", "```go\ngo get -u github.com/jinzhu/gorm\n```", "```go\ntype Customer struct {\n  gorm.Model\n  Name string `json:\"name\"`\n  FirstName string `gorm:\"column:firstname\" json:\"firstname\"`\n  LastName string `gorm:\"column:lastname\" json:\"lastname\"`\n  Email string `gorm:\"column:email\" json:\"email\"`\n  Pass string `json:\"password\"`\n  LoggedIn bool `gorm:\"column:loggedin\" json:\"loggedin\"`\n  Orders []Order `json:\"orders\"`\n}\n```", "```go\nfunc (Customer) TableName() string {\n  return \"customers\"\n}\n```", "```go\ntype Product struct {\n  gorm.Model\n  Image string `json:\"img\"`\n  ImagAlt string `json:\"imgalt\" gorm:\"column:imgalt\"`\n  Price float64 `json:\"price\"`\n  Promotion float64 `json:\"promotion\"` //sql.NullFloat64\n  PoructName string `gorm:\"column:productname\" json:\"productname\"`\n  Description string\n}\n\nfunc (Product) TableName() string {\n  return \"products\"\n}\n\ntype Order struct {\n  gorm.Model\n  Product\n  Customer\n  CustomerID int `gorm:\"column:customer_id\"`\n  ProductID int `gorm:\"column:product_id\"`\n  Price float64 `gorm:\"column:price\" json:\"sell_price\"`\n  PurchaseDate time.Time `gorm:\"column:purchase_date\" json:\"purchase_date\"`\n}\n\nfunc (Order) TableName() string {\n  return \"orders\"\n}\n```", "```go\ntype DBLayer interface {\n  GetAllProducts() ([]models.Product, error)\n  GetPromos() ([]models.Product, error)\n  GetCustomerByName(string, string) (models.Customer, error)\n  GetCustomerByID(int) (models.Customer, error)\n  GetProduct(int) (models.Product, error)\n  AddUser(models.Customer) (models.Customer, error)\n  SignInUser(username, password string) (models.Customer, error)\n  SignOutUserById(int) error\n  GetCustomerOrdersByID(int) ([]models.Order, error)\n}\n```", "```go\nimport (\n    _ \"github.com/go-sql-driver/mysql\"\n    \"github.com/jinzhu/gorm\"\n)\n```", "```go\ngo get github.com/go-sql-driver/mysql\n```", "```go\ntype DBORM struct {\n  *gorm.DB\n}\n```", "```go\nfunc NewORM(dbname, con string) (*DBORM, error) {\n  db, err := gorm.Open(dbname, con)\n  return &DBORM{\n    DB: db,\n  }, err\n}\n```", "```go\nfunc (db *DBORM) GetAllProducts() (products []models.Product, err error) {\n  return products, db.Find(&products).Error\n}\n```", "```go\nfunc (db *DBORM) GetPromos() (products []models.Product, err error) {\n  return products, db.Where(\"promotion IS NOT NULL\").Find(&products).Error\n}\n```", "```go\nselect * from products where promotion IS NOT NULL\n```", "```go\nfunc (db *DBORM) GetCustomerByName(firstname string, lastname string) (customer models.Customer, err error) {\n  return customer, db.Where(&models.Customer{FirstName: firstname, LastName: lastname}).Find(&customer).Error\n}\n```", "```go\nselect * from customers where firstname='..' and lastname='..'\n```", "```go\nfunc (db *DBORM) GetCustomerByID(id int) (customer models.Customer, err error) {\n  return customer, db.First(&customer, id).Error\n}\n```", "```go\nfunc (db *DBORM) GetProduct(id int) (product models.Product, error error) {\n  return product, db.First(&product, id).Error\n}\n```", "```go\nfunc (db *DBORM) AddUser(customer models.Customer) (models.Customer, error) {\n  //we will cover the hashpassword function later\n  hashPassword(&customer.Pass)\n  customer.LoggedIn = true\n  return customer, db.Create(&customer).Error\n}\n\n```", "```go\nfunc (db *DBORM) SignInUser(email, pass string) (customer models.Customer, err error) {\n  //Verify the password, we'll cover this function later\n  if !checkPassword(pass) {\n    return customer, errors.New(\"Invalid password\")\n  }\n  //Obtain a *gorm.DB object representing our customer's row\n  result := db.Table(\"Customers\").Where(&models.Customer{Email: email})\n  //update the loggedin field\n  err = result.Update(\"loggedin\", 1).Error\n  if err != nil {\n    return customer, err\n  }\n  //return the new customer row\n  return customer, result.Find(&customer).Error\n}\n```", "```go\nfunc (db *DBORM) SignOutUserById(id int) error {\n //Create a customer Go struct with the provided if\n  customer := models.Customer{\n    Model: gorm.Model{\n      ID: uint(id),\n    },\n  }\n //Update the customer row to reflect the fact that the customer is not logged in\n  return db.Table(\"Customers\").Where(&customer).Update(\"loggedin\", 0).Error\n}\n```", "```go\nfunc (db *DBORM) GetCustomerOrdersByID(id int) (orders []models.Order, err error) {\n    return orders, db.Table(\"orders\").Select(\"*\")\n                .Joins(\"join customers on customers.id = customer_id\")\n                .Joins(\"join products on products.id = product_id\")\n                .Where(\"customer_id=?\", id).Scan(&orders).Error \n\n}\n```", "```go\nSELECT * FROM `orders` join customers on customers.id = customer_id join products on products.id = product_id WHERE (customer_id='1')\n```", "```go\nr.GET(\"/products\", h.GetProducts)\n```", "```go\nfunc (h *Handler) GetProducts(c *gin.Context) {\n  if h.db == nil {\n    return\n  }\n  products, err := h.db.GetAllProducts()\n  if err != nil {\n    c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n    return\n  }\n  c.JSON(http.StatusOK, products)\n}\n```", "```go\n[GIN] 2018/12/29 - 13:33:19 |?[97;42m 200 ?[0m| 2.7849836s | 127.0.0.1 |?[97;44m GET ?[0m /products\n[GIN] 2018/12/29 - 13:33:19 |?[97;42m 200 ?[0m| 65.82ms | 127.0.0.1 |?[97;44m GET ?[0m /img/redguitar.jpeg\n[GIN] 2018/12/29 - 13:33:19 |?[97;42m 200 ?[0m| 65.82ms | 127.0.0.1 |?[97;44m GET ?[0m /img/drums.jpg\n[GIN] 2018/12/29 - 13:33:19 |?[97;42m 200 ?[0m| 67.4312ms | 127.0.0.1 |?[97;44m GET ?[0m /img/strings.png\n[GIN] 2018/12/29 - 13:33:19 |?[97;42m 200 ?[0m| 9.4939ms | 127.0.0.1 |?[97;44m GET ?[0m /img/flute.jpeg\n[GIN] 2018/12/29 - 13:33:19 |?[97;42m 200 ?[0m| 9.9734ms | 127.0.0.1 |?[97;44m GET ?[0m /img/saxophone.jpeg\n[GIN] 2018/12/29 - 13:33:19 |?[97;42m 200 ?[0m| 18.3846ms | 127.0.0.1 |?[97;44m GET ?[0m /img/blackguitar.jpeg\n```", "```go\nfunc MyCustomMiddleware() gin.HandlerFunc {\n  return func(c *gin.Context) {\n    //The code that is to be executed before our request gets handled, starts here\n\n    // Set example variable\n    c.Set(\"v\", \"123\")\n    //We can then retrieve the variable later via c.Get(\"v\")\n\n   // Now we our request gets handled\n    c.Next()\n\n    // This code gets executed after the handler gets handled\n\n    // Access the status we are sending\n    status := c.Writer.Status()\n    // Do something with the status\n  }\n}\n```", "```go\nfunc MyCustomLogger() gin.HandlerFunc {\n     return func(c *gin.Context) {\n         fmt.Println(\"************************************\")\n         c.Next()\n         fmt.Println(\"************************************\")\n     }\n}\n```", "```go\nfunc RunAPIWithHandler(address string, h HandlerInterface) error {\n  //Get gin's default engine\n  r := gin.Default()\n  r.Use(MyCustomLogger())\n  /*\n    The rest of our code\n    */\n}\n```", "```go\nr := gin.New()\nr.Use(MyCustomLogger())\n```", "```go\n r := gin.New()\n r.Use(MyCustomLogger1(),MyCustomLogger2(),MyCustomLogger3())\n```", "```go\n//Get gin's default engine\n  r := gin.Default()\n  /*\n    Our code\n  */\n //Start listening to incoming HTTP requests...\n r.Run(address)\n```", "```go\nr.RunTLS(address, \"cert.pem\", \"key.pem\")\n```", "```go\ngo run %GOROOT%/src/crypto/tls/generate_cert.go --host=127.0.0.1\n```", "```go\n -ca\n whether this cert should be its own Certificate Authority\n -duration duration\n Duration that certificate is valid for (default 8760h0m0s)\n -ecdsa-curve string\n ECDSA curve to use to generate a key. Valid values are P224, P256 (recommended), P384, P521\n -host string\n Comma-separated hostnames and IPs to generate a certificate for\n -rsa-bits int\n Size of RSA key to generate. Ignored if --ecdsa-curve is set (default 2048)\n -start-date string\n Creation date formatted as Jan 1 15:04:05 2011\n```", "```go\nset HTTPS=true&&npm start\n```", "```go\nvar ErrINVALIDPASSWORD = errors.New(\"Invalid password\")\n```", "```go\nfunc hashPassword(s *string) error {\n  if s == nil {\n    return errors.New(\"Reference provided for hashing password is nil\")\n  }\n\n  //convert password string to byte slice so that we can use it with the bcrypt package\n  sBytes := []byte(*s)\n\n  //Obtain hashed password via the GenerateFromPassword() method\n  hashedBytes, err := bcrypt.GenerateFromPassword(sBytes, bcrypt.DefaultCost)\n  if err != nil {\n    return err\n  }\n\n  //update password string with the hashed version\n  *s = string(hashedBytes[:])\n  return nil\n}\n```", "```go\ngo get golang.org/x/crypto/bcrypt\n```", "```go\nfunc (db *DBORM) AddUser(customer models.Customer) (models.Customer, error) {\n  //pass received password by reference so that we can change it to its hashed version\n  hashPassword(&customer.Pass)\n  customer.LoggedIn = true\n  err := db.Create(&customer).Error\n  customer.Pass = \"\"\n  return customer, err\n}\n```", "```go\nfunc checkPassword(existingHash, incomingPass string) bool {\n  //this method will return an error if the hash does not match the provided password string\n  return bcrypt.CompareHashAndPassword([]byte(existingHash), []byte(incomingPass)) == nil\n}\n```", "```go\nfunc (db *DBORM) SignInUser(email, pass string) (customer models.Customer, err error) {\n  //Obtain a *gorm.DB object representing our customer's row\n  result := db.Table(\"Customers\").Where(&models.Customer{Email: email})\n  //Retrieve the data for the customer with the passed email\n  err = result.First(&customer).Error\n  if err != nil {\n    return customer, err\n  }\n  //Compare the saved hashed password with the password provided by the user trying to sign in\n  if !checkPassword(customer.Pass, pass) {\n    //If failed, returns an error\n    return customer, ErrINVALIDPASSWORD\n  }\n  //set customer pass to empty because we don't need to share this information again\n  customer.Pass = \"\"\n  //update the loggedin field\n  err = result.Update(\"loggedin\", 1).Error\n  if err != nil {\n    return customer, err\n  }\n  //return the new customer row\n  return customer, result.Find(&customer).Error\n}\n```", "```go\nfunc (h *Handler) SignIn(c *gin.Context) {\n  if h.db == nil {\n    return\n  }\n  var customer models.Customer\n  err := c.ShouldBindJSON(&customer)\n  if err != nil {\n    c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n    return\n  }\n  customer, err = h.db.SignInUser(customer.Email, customer.Pass)\n  if err != nil {\n    //if the error is invalid password, return forbidden http error\n    if err == dblayer.ErrINVALIDPASSWORD {\n c.JSON(http.StatusForbidden, gin.H{\"error\": err.Error()})\n return\n }\n    c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n    return\n  }\n  c.JSON(http.StatusOK, customer)\n}\n```", "```go\nlet { token } = await this.props.stripe.createToken({ name: this.state.name });\n```", "```go\n    async handleSubmit(event) {\n        event.preventDefault();\n        let id = \"\";\n       //If we are not using a pre-saved card, connect with stripe to obtain a card token\n        if (!this.state.useExisting) {\n           //Create the token via Stripe's API\n            let { token } = await this.props.stripe.createToken({ name: this.state.name });\n            if (token == null) {\n                console.log(\"invalid token\");\n                this.setState({ status: FAILEDSTATE });\n                return;\n            }\n            id = token.id;\n        }\n        //Create the request, then send it to the back-end\n        let response = await fetch(\"/users/charge\", {\n method: \"POST\",\n headers: { \"Content-Type\": \"application/json\" },\n body: JSON.stringify({\n token: id,\n customer_id: this.props.user,\n product_id: this.props.productid,\n sell_price: this.props.price,\n rememberCard: this.state.remember !== undefined,\n useExisting: this.state.useExisting\n })\n });\n        //If response is ok, consider the operation a success\n        if (response.ok) {\n            console.log(\"Purchase Complete!\");\n            this.setState({ status: SUCCESSSTATE });\n        } else {\n            this.setState({ status: FAILEDSTATE });\n        }\n    }\n```", "```go\nfunc (h *Handler) Charge(c *gin.Context) {\n  if h.db == nil {\n    c.JSON(http.StatusInternalServerError, gin.H{\"error\": \"server database error\"})\n    return\n  }\n}\n```", "```go\nrequest := struct {\n    models.Order\n    Remember bool `json:\"rememberCard\"`\n    UseExisting bool `json:\"useExisting\"`\n    Token string `json:\"token\"`\n  }{}\n```", "```go\nerr := c.ShouldBindJSON(&request)\n  //If an error occurred during parsing, report it then return\n  if err != nil {\n    c.JSON(http.StatusBadRequest, request)\n    return\n  }\n```", "```go\nstripe.Key = \"sk_test_4eC39HqLyjWDarjtT1zdp7dc\"\n```", "```go\n  chargeP := &stripe.ChargeParams{\n    //the price we obtained from the incoming request:\n    Amount: stripe.Int64(int64(request.Price)),\n    //the currency:\n    Currency: stripe.String(\"usd\"),\n    //the description:\n    Description: stripe.String(\"GoMusic charge...\"),\n  }\n```", "```go\nstripeCustomerID:=\"\"\n```", "```go\nif request.UseExisting {\n    //use existing\n    log.Println(\"Getting credit card id...\")\n    //This is a new method which retrieve the stripe customer id from the database \n    stripeCustomerID, err = h.db.GetCreditCardCID(request.CustomerID)\n    if err != nil {\n      log.Println(err)\n      c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n      return\n    }\n  } \n```", "```go\n...else {\n        cp := &stripe.CustomerParams{}\n        cp.SetSource(request.Token)\n        customer, err := customer.New(cp)\n        if err != nil {\n             c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n            return\n        }\n        stripeCustomerID = customer.ID\n```", "```go\nif request.Remember {\n      //save the stripe customer id, and link it to the actual customer id in our database\n      err = h.db.SaveCreditCardForCustomer(request.CustomerID, stripeCustomerID)\n      if err != nil {\n        c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n        return\n      }\n    }\n```", "```go\n  /*\n    we should check if the customer already ordered the same item or not but for simplicity, let's assume it's a new order\n*/\n\n  //Assign the stipe customer id to the *stripe.ChargeParams object:\n  chargeP.Customer = stripe.String(stripeCustomerID)\n\n  //Charge the credit card\n  _, err = charge.New(chargeP)\n  if err != nil {\n    c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n    return\n  }\n```", "```go\n err = h.db.AddOrder(request.Order)\n  if err != nil {\n    c.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n  }\n```", "```go\ntype DBLayer interface {\n  GetAllProducts() ([]models.Product, error)\n  GetPromos() ([]models.Product, error)\n  GetCustomerByName(string, string) (models.Customer, error)\n  GetCustomerByID(int) (models.Customer, error)\n  GetProduct(int) (models.Product, error)\n  AddUser(models.Customer) (models.Customer, error)\n  SignInUser(username, password string) (models.Customer, error)\n  SignOutUserById(int) error\n  GetCustomerOrdersByID(int) ([]models.Order, error)\n AddOrder(models.Order) error\n GetCreditCardCID(int) (string, error)\n SaveCreditCardForCustomer(int, string) error\n}\n```", "```go\n//Add the order to the orders table\nfunc (db *DBORM) AddOrder(order models.Order) error {\n  return db.Create(&order).Error\n}\n\n//Get the id representing the credit card from the database\nfunc (db *DBORM) GetCreditCardCID(id int) (string, error) {\n  cusomterWithCCID := struct {\n    models.Customer\n    CCID string `gorm:\"column:cc_customerid\"`\n  }{}\n  return cusomterWithCCID.CCID, db.First(&cusomterWithCCID, id).Error\n}\n\n//Save the credit card information for the customer\nfunc (db *DBORM) SaveCreditCardForCustomer(id int, ccid string) error {\n  result := db.Table(\"customers\").Where(\"id=?\", id)\n  return result.Update(\"cc_customerid\", ccid).Error\n}\n```", "```go\nfunc NewHandler(db,constring string) (HandlerInterface, error) {\n  db, err := dblayer.NewORM(db, constring)\n  if err != nil {\n    return nil, err\n  }\n  return &Handler{\n    db: db,\n  }, nil\n}\n```", "```go\n\"proxy\": \"http://127.0.0.1:8000/\",\n```", "```go\nfetch(this.props.location) //send http request to a location. The location here is /products\n            .then(res => res.json())\n            .then((result) => {\n                this.setState({\n                    orders: result\n                });\n            });\n```", "```go\nnpm install js-cookie --save\n```", "```go\ncookie.set(\"user\", userdata);\n```", "```go\nconst user = cookie.getJSON(\"user\");\n```", "```go\ncookie.set(\"user\",{loggedin:false});\n```", "```go\ngo get github.com/gin-contrib/static\n```", "```go\nimport (\n  \"fmt\" \n \"github.com/gin-contrib/static\"\n  \"github.com/gin-gonic/gin\"\n)\n```", "```go\n//remove this line: r.Static(\"/img\", \"../public/img\")\n//This assumes the React app 'build' folder exists in the relative path '../public'\nr.Use(static.ServeRoot(\"/\", \"../public/build\"))\n```"]