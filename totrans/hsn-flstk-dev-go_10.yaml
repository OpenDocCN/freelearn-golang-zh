- en: Advanced Web Go Applications with Gin and React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll continue building our GoMusic web application. This chapter
    will cover some advanced concepts, as it will add to what we built in the previous
    chapter before it dives deeper into how to build advanced backend software. We
    will cover some important and practical topics such as database layers for connecting
    our application to a production database, **object-relational mapping** (**ORM**)
    for simplifying our database layer code, middleware for adding functionality on
    top of our Web API handlers, authentication to secure our web application, and
    credit card charging. We will also revisit the frontend of our GoMusic application
    in order to cover how our frontend would connect to our backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Database layers and ORMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security, authentication, and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credit card charging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxying React applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorizing and authenticating from React applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will revisit the frontend layer of our application, in order to
    evolve our existing React application to utilize the new backend features.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we recommend that you have the following software installed:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code editor or an IDE such as VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: npm and Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowledge of the following topics is required:'
  prefs: []
  type: TYPE_NORMAL
- en: Go ([Chapter 2](d638558d-2461-4bc9-b51b-317307ed899b.xhtml), *Building Blocks
    of the Go Language, *and [Chapter 3](72d04e99-a5af-4af9-b51a-54c4c750871f.xhtml),
    *Go Concurrency*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React ([Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend with
    React.js*, and [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building
    a Frontend for GoMusic*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some familiarity with relational databases and MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found in this book's GitHub repository at [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: The database layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we started writing our database layer. As a reminder,
    our database layer was hosted in the `backend\src\dblayer` folder. Our first step
    was to write the database layer interface, which defined all of the functionality
    that we expect from the database layer. This is what the database layer interface
    looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to implement these methods to get some solid functionality in our
    database layer.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start implementing this functionality, we first need to get a database
    ready.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A database is one of the key pieces of the backend of any application. This
    is where the backend layer can persist and retrieve data.
  prefs: []
  type: TYPE_NORMAL
- en: A relational database can simply be described as a database that stores data
    in a number of tables and then establishes relationships between those tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'When configuring a database, there are three things we need to define:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A database name**: In our case, it will be called GoMusic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table names**: In our case, for simplicity, we''ll go with three tables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A** `customer` **table**: This table is where we''ll store our app user''s
    information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An** `orders` **table**: This table should map the customers to the products
    they bought'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A** `products` **table**: This table will host a list of the available products
    for GoMusic'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexes and relationships between the tables**: In our case, the orders table
    will point to both the `customer` and `products` tables. Both tables will need
    an `id` index. Indexes are used to make queries more efficient and faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL is a well-known relational database, and we will be using it in this book.
    MySQL is a very popular open source database engine and is being used in numerous
    projects, both large and small.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how our architecture looks like with a database serving data for our
    application''s backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bc5864d-cde9-4dba-9c61-0eaa5ae5819a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's set up MySQL for our application in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start creating databases and tables, we first need to install MySQL.
    There are Enterprise Editions as well as Community Editions of MySQL. The Community
    Edition of MySQL is what we would use in a project like ours. This is because
    the Community Editions are free and can be used for learning and exploration projects.
    To install the MySQL Community Edition Server, you need to download it from the
    following link: [https://dev.mysql.com/downloads/](https://dev.mysql.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have installed MySQL, we need to install client tools to make use of
    the database. MySQL usually comes with a tool called MySQL Workbench, which is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/203e2f14-59f5-431b-9122-8a77a1b66a20.png)'
  prefs: []
  type: TYPE_IMG
- en: The MySQL Workbench tool page
  prefs: []
  type: TYPE_NORMAL
- en: You can use the tools in MySQL Workbench to create MySQL databases, tables,
    indexes, and relationships. Let's go through the tables, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The customer table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, this is the table where we will store our app user''s
    information. Here is how the `customer` table will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da5fe63a-7c80-4faa-be1a-2ebfb3d966ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The table consists of the following ten columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the unique ID for each customer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`firstname`: This is the first name of the customer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lastname`: This is the last name of the customer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`email`: This is the customer''s email.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pass`: This is the password for the customer. This field must be stored in
    a hashed form.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cc_customerid`: This is an ID that represents the credit card of the customer.
    We''ll cover this field later in this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loggedin`: This flag specifies whether the user is logged in or not.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`created_at`: This field specifies the date when the customer was added.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`updated_at`: This field specifies the last time the row/customer was updated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`deleted_at`: This field specifies the last time the row was deleted.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This table will support two indexes. As mentioned earlier, indexes are used
    to make queries more efficient and faster. This is done by identifying the columns,
    which we expect will be used as search keys in our queries. Indexes can also be
    used to identify fields that are unique and must not be duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8297973c-dc3e-4853-b28f-e125fc233358.png)'
  prefs: []
  type: TYPE_IMG
- en: The primary key is the customer `id` field; it's a unique identification number
    per customer. The unique key is the `email` field. We can't have two or more customers
    with the same email address.
  prefs: []
  type: TYPE_NORMAL
- en: The orders table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `orders` table, which will host a list of the available
    products for GoMusic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f275965-fcde-4ae6-b04c-1ad0506f4f0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This table consists of the following eight columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The unique ID of the order'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`customer_id`: The ID of the customer making the order'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`product_id`: The ID of the product the customer bought'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`price`: The price of the purchase'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`purchase_date`: The date of the purchase'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`created_at`: The date/time the row was created'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`updated_at`: The updated date/time when the row was last updated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`deleted_at`: The date/time when the row was deleted, if any'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This table will support one index, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1faac61c-5197-4e75-a3f7-5f9c0b3a76b8.png)'
  prefs: []
  type: TYPE_IMG
- en: The index is simply the unique ID index. Each order will have its own unique
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: The products table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the `products` table. This table will map the customers
    to the products they bought:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4b3595d-b303-4faf-bf1d-21851bdd7094.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The table consists of the following 10 columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The unique ID of the product'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`image`: The relative location of the product image'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`imgalt`: The alternative name for the image'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`description`: The product description'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`productname`: The name of the product'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`price`: The original price of the product'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`promotion`: The promotional price of the product'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`created_at`: The time when the row was created'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`updated_at`: The time when the row was last updated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`deleted_at`: The time when the row was deleted, if any'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This table supports just one index, that is, our unique product `id` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3280387c-db16-41ab-8198-7b3010d94b44.png)'
  prefs: []
  type: TYPE_IMG
- en: With this, we should have a good enough database to empower our application.
    Our database is relatively simple, but it is sufficient to showcase the concepts
    that we need to cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered what our database will look like, it's time to cover
    how to design the code that interacts with our database.
  prefs: []
  type: TYPE_NORMAL
- en: ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To design the code that interacts with our database, we will utilize an approach
    known as *ORM *. ORMs allow you to interact with databases using object-oriented
    paradigms. ORMs generate code that represent database tables as code objects,
    and represents queries as methods in your favorite programming language.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Go language, we will need to create Go structs to represent
    each of our tables. We already started writing our models in the previous chapter,
    that is, `product`, `customer`, and `order`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue to write the code, let's first discuss the **Go object-relational
    mapping** (**GORM**), which is the Go open source package, that offers support
    for ORMs.
  prefs: []
  type: TYPE_NORMAL
- en: GORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most popular Go ORM packages is the GORM package, which can be found
    at [http://gorm.io/](http://gorm.io/). GORM offers some mature functionality that
    makes writing backend database layers a breeze. Let''s continue writing our database
    layer by utilizing ORM, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to retrieve the GORM package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, we need to evolve our models so that they can be used properly by GORM.
  prefs: []
  type: TYPE_NORMAL
- en: An ORM needs model objects to accurately reflect the database table columns
    that are expected to be read and/or manipulated by the ORM library. The ORM can also make
    use of some meta information, for example, the last time a row was updated, deleted,
    or created, to ensure proper synchronization between the database and your application
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of GORM, there is a data type called `gorm.Model`, which is simply
    a Go struct that hosts fields representing the row `id` field, the `created_at`
    time, the `updated_at` time, and the `deleted_at` time. It is recommended to embed
    `gorm.Model` in Go structs that represent your data. In the case of the `customers`
    table, the Go struct would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code also shows plenty of `struct tags`. The `gorm` struct tags
    in the preceding example are used to identify the column names that correspond
    to the field names. So, for instance, the struct field, `FirstName`, is represented
    by a column called `firstname`. This is identified by the line `gorm:"column:firstname"`.
  prefs: []
  type: TYPE_NORMAL
- en: We also make use of the `json` `struct` tag in the preceding code to identify
    what the field will look like in the JSON format. In theory, we don't always need
    to assign `struct` tags for every single field; however, I find it more practical
    to do so to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can GORM recognize the fact that the `Customer` Go struct corresponds
    to the `customers` table in our database? Usually, GORM changes the first letter
    of our Go struct name to lowercase, and then it adds an ''*s''* at the end, which
    will convert `Customer` into `customers`. However, GORM also empowers us to explicitly
    declare the table name that corresponds to the Go struct. This can be done through
    a method whose signature is `TableName()string`. So, in other words, we can explicitly
    specify our table name using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now, inside our `backend\src\models\models.go` file, which sits inside
    our project folder, let''s evolve the data models for the `products` and `orders`
    tables, similarly to what we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement of database layer in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the database layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have to implement the functionality of our database layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we designed a database layer interface that defined
    all of the database operations we are expected to need. This is what it looked
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In our project folder, let's create a new file called `orm.go` in the same folder
    as `dblayer`. The file will exist in the `{our_project_folder}/backend/src/dblayer`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The GORM package relies on plugins to connect to the different databases that
    GORM supports. Plugins are Go packages that need to be imported silently in the
    package where GORM is being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import a plugin package silently in Go, along with the GORM package, we
    can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our plugin is the `github.com/go-sql-driver/mysql` package. If you don''t already
    have it installed in your machine, you will need to retrieve it using the `go
    get` command from your favorite Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll need to create a Go `struct` type, which will implement our `DBLayer`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Go struct will host a data type called `*gorm.DB`. The `*gorm.DB` type
    is our entry point for using GORM''s functionality. Here is what the code will
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We need to create a constructor for our new type. The constructor will initialize
    our embedded `*gorm.DB` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain an initialized `*gorm.DB` type, we need to use a function called
    `gorm.Open()`. This function takes two arguments—our database type name, which
    in our case is `mysql`, and our connection string. A connection string basically
    contains information regarding how to connect to the specific database that we
    are trying to access. To make our constructor flexible, we won''t hardcode the
    database name or the connection string. Instead, we''ll allow this information
    to be passed to the constructor. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It's finally time to start implementing the methods of the `DBLayer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by making use of GORM helpful methods, which will spare us from
    having to write explicit queries. The first method to implement is `GetAllProducts().`
    This method simply returns a list of all products, which is the equivalent of
    a `select *` SQL statement. This can be achieved using GORM''s `db.Find()` method,
    which belongs to the `*gorm.DB` type. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see how using an ORM like GORM can produce extremely efficient code.
    The single line of code in the preceding method executed a `select * from products` query
    at the `products` table and then returned all of the results. The `Find()` method
    was able to detect that we seek the products table because we supplied it with
    an argument of type `[]models.Product`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write the `GetPromos()` method, which returns a list of products where
    the promotion field is not null.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is simply a select statement with a `where` clause. GORM allows you to
    achieve this by using a method called `Where()`, combined with the `Find()` method
    we covered earlier. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is simple and efficient. The preceding method simply executed the
    equivalent of the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Where()` method can also take a Go struct value, which represents the
    condition in our query. We''ll see that in our next `DBLayer` method, which is
    `GetCustomerByName`. This method takes the first and last names of a customer
    and then returns the customer''s information. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is very similar to the `GetPromos()` method, except that the `Where()`
    method is fed a Go struct value with the first and last names instead of a string
    `where` clause. The equivalent of the following query was executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will implement `GetCustomerByID()`, which will retrieve a customer
    by using their ID in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, instead of using a combination of `Where` and `Find`, we will use
    a method called `First`, which can get the first result that corresponds to a
    certain condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will implement a method to get a product by ID, which is very similar
    to `GetCustomerByID()`, except this time the result is a product and not a customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have been writing methods that execute queries and retrieve results.
    But now, it's time to start writing methods that add or update rows.
  prefs: []
  type: TYPE_NORMAL
- en: Our next method is `AddUser()`, which basically adds a new user to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method will also hash the user''s password (which we will cover later
    in the *Security* section), and will set the user as logged in. GORM provides
    a very handy method called `Create()` so that we can add rows to our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to implement the `SignInUser` method, which basically updates
    the `loggedin` field in a row representing a specific customer in our customers
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SignInUser` method will identify the user that just logged in based on
    their email. We will then verify the user''s password. If the password is correct,
    then we update the database. Here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code covers many of the methods we covered before, except in
    two places:'
  prefs: []
  type: TYPE_NORMAL
- en: '`result := db.Table("Customers").Where(&models.Customer{Email: email})`: This
    is how we can obtain an object representing the row that we are interested in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result.Update("loggedin", 1)`: This is how we update our row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SignOutUserById()` method is used to sign out users using their IDs. This
    will follow the same techniques that we have covered so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we implement the `GetCustomerOrdersByID()` method to get customer
    orders by `customer_id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a bit different than the previous methods. This is because
    we need to execute a couple of joins to produce the results we seek. We need to
    join three tables: the `orders` table, the `customers` table, and the `products`
    table. From the `customers` table, we only want customers with IDs that correspond
    to the provided customer''s ID. For the `products` table, we only want products
    where the product ID corresponds to the product ID of the current order. Luckily,
    the GORM package provides a method called `Joins`, which can be used to join tables.
    The preceding code will translate into the following query (assuming that we have
    a `customer_id` of value `''1''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And with that, our database layer is almost done. Let's take a look at what
    is middleware in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware is an important and fun topic in the world of modern web applications.
    The word *middleware* can mean many things in the software development industry.
    However, for the purpose of this book, we only care about one definition for it.
    **Middleware** can simply be defined as code that can run between the time you
    receive an HTTP request and the time your handler code gets executed on that request.
    This is best explained through an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the RESTful API that we built for our GoMusic application, let''s pick on
    one of our API endpoints—the `/products` relative URL. Here was the code that
    was used to assign this relative URL to an action or a function handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here was the code of the `GetProducts` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Here is the workflow for this API resource:'
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP `GET` request is received at the `/products` relative URL address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GetProducts()` method gets executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our web API middleware is simply some code that we can inject between *steps
    1* and *2* or even beyond. Technically, the middleware is simply an HTTP handler
    function that wraps our own handler function. In other words, it's a function
    that will encapsulate the `GetProducts()` method, which will allow you to insert
    functionality before and after your method.
  prefs: []
  type: TYPE_NORMAL
- en: The Gin web framework comes preloaded with two pieces of middleware by default.
    The framework also allows you to define your own custom middleware when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two default middlewares that get injected into the Gin web server are **logger
    middleware** and **recovery middleware**. The logger middleware simply logs the
    API activity throughout the life of your application. If you run a Go web application
    that''s powered by Gin in a Terminal of your choice, you will see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is basically Gin's logging middleware in action.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Gin's recovery middleware ensures that your application is
    recovered from panics and writes the HTTP error code `500` in the response when
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous open source middleware options available for Gin. One list
    of supported middleware can be found at [https://github.com/gin-gonic/contrib](https://github.com/gin-gonic/contrib).
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to write a custom middleware in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Custom middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, Gin allows you to author your own middleware so that
    you can embed some functionality in your web app. Writing custom middleware in
    Gin is relatively simple, as we can see in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to write the actual code for the middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, a web API middleware is simply an HTTP handler function
    that encapsulates other HTTP handler functions. Here is what the code would look
    like for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a very simple middleware that would print `************************************`
    before and after the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add this middleware to our Gin engine. This can be done
    in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to keep Gin''s default middleware, but then add `MyCustomLogger()`,
    we can do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, we want to ignore Gin''s default middleware and only
    enable our custom middleware, we can use the following code path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we''d like to enable more than one middleware, we just add them as an argument
    to the `Use()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll discuss how to secure our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a very important topic when it comes to deploying web applications
    to production. This topic is massive and can take chapters to cover, if not books.
    Since the purpose of this book is to cover practical hands-on topics and be to
    the point, we will cover the most vital nuggets of knowledge that are needed to
    build a secure web application.
  prefs: []
  type: TYPE_NORMAL
- en: Secure web applications primarily rely on encrypting the data between the web
    client (browser) and the web server. In other words, they rely on encrypting the
    data between the frontend and the backend.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, HTTP is the protocol that's utilized between web clients
    and web servers. HTTP can be secured through a protocol that is known as **TLS**
    (**Transport Layer Security**).The combination of HTTP and TLS is commonly known
    as **HTTPS**.
  prefs: []
  type: TYPE_NORMAL
- en: There is another protocol known as SSL, which was also utilized to secure HTTP.
    However, TLS is newer and more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss the code, let's first cover some important background knowledge
    about HTTPS and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Certificates and private keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTPS works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Trust is established between the web client and the web server. This happens
    through a handshake and through certificates and private keys. We will cover this
    in more detail later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The web client and the web server agree on an encryption key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The web client and the web server will encrypt their communication using the
    encryption key they agreed on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establishing trust between the client and the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The certificates and private keys we mentioned in *step 1* of the *Certificates
    and private keys *section are an entirely different matter. To understand them,
    you first have to understand the concept of public key encryption or asymmetric
    cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: A **public key** is used to encrypt data, and it can be shared safely with other
    parties. However, the public key can't decrypt data. A different key is required
    to decrypt the data. This key is known as the **private key**, and it must not
    be shared. The public key can be used by any person to encrypt data. However,
    only the person with the private key that corresponds to the public key can decrypt
    the data back to its original human-readable form. The public and private keys
    are generated using complex computational algorithms. Utilizing a combination
    of public and private keys is known as asymmetrical cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1 *of the *Certificates and private keys *section, asymmetrical cryptography
    is utilized between a web client and web server to agree on a shared encryption
    key (also known as a shared secret or session key), which is then used in symmetrical
    cryptography (*steps 2* and 3). A handshake occurs between the web client and
    web server, where the client indicates its intent to start a secure communication
    session with the server. Typically, this entails agreeing on some mathematical
    details on how the encryption occurs. The server then replies with a *digital
    certificate*.
  prefs: []
  type: TYPE_NORMAL
- en: A digital certificate (or a public key certificate) is an electronic document
    that proves the ownership of a public key.
  prefs: []
  type: TYPE_NORMAL
- en: A digital certificate is a digital document that gets issued by a trusted third-party
    entity. The document contains a public encryption key, the server name that the
    key belongs to, and the name of the trusted third-party entity, who verifies that
    the information is correct and that the public key belongs to the expected key
    owner (also called the issuer of the certificate).
  prefs: []
  type: TYPE_NORMAL
- en: The trusted third-party entity that issues the certificate is known as a **certificate
    authority** (**CA**). There are multiple known CAs who issue a certificate and
    verify identities for businesses and organizations. Most CAs charge fees for their
    service; some are now free, such as Let's Encrypt ([https://letsencrypt.org/](https://letsencrypt.org/)).
    For larger organizations or government bodies, they issue their own certificates;
    this process is known as self-signing, and hence their certificates are known
    as **self-signed certificates**. Certificates can have expiry dates by which the
    certificates will need to be renewed; this is for extra protection in case the
    entity that owned the certificate in the past has changed.
  prefs: []
  type: TYPE_NORMAL
- en: A web client typically contains a list of CAs that it knows of. So, when the
    client attempts to connect to a web server, the web server responds with a digital
    certificate. The web client looks for the issuer of the certificate and compares
    the issuer with the list of CAs that it knows of. If the web client knows and
    trusts the certificate issuer, then it will continue with the connection to that
    server and use the public key in the certificate. The public key that's obtained
    from the server will then be used to encrypt communications to securely negotiate
    a shared encryption key (or session key or shared secret) to then be used in symmetrical
    cryptography communications between the web client and web server.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of algorithms that can be used to generate this session key,
    but they are beyond the scope of this chapter. What we need to know is that, once
    a session key is agreed on, the initial handshake between the web client and web
    server will conclude, allowing the actual communication session to proceed securely
    under the protection of the shared session key.
  prefs: []
  type: TYPE_NORMAL
- en: For our web server to support HTTPS, it needs a certificate and a private key
    to establish the initial HTTPS handshake, as outlined in *step 1 *of the* Certificates
    and private keys *section.
  prefs: []
  type: TYPE_NORMAL
- en: Agreeing on, and using an encryption key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An encryption key is a piece of code that relies on some complex math to encrypt
    a piece of data. Encrypting a piece of data simply means taking a piece of data
    in human-readable form and then transforming it into a form that is not readable
    by humans, and hence protects your data. Another key is then required to decrypt
    this unreadable data back to a human-readable form.
  prefs: []
  type: TYPE_NORMAL
- en: The type of encryption key used in *steps 2* and *3* in the preceding section
    is sometimes known as a **symmetric cipher**. This simply means that the same
    key is utilized by both the client and the server to encrypt and decrypt data
    between them. This is also known as **symmetrical cryptography**.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, this key will be invisible to you during development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we will take a look at how to support HTTPS in Gin.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting HTTPS in Gin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we obtained some valuable knowledge about how HTTPS
    actually works. But how do we support it in our code? It''s actually fairly simple.
    In the previous chapter, we utilized the following piece of code to establish
    an HTTP web server that''s empowered by Gin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to apply a single change in the preceding code to support HTTPS instead
    of HTTP. Here, we are going to use a method called `RunTLS()`. This method needs
    three main arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTPS address that we would like our backend web service to listen to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The certificate file (covered in the previous section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The private key file (covered in the previous section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what the code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: But how do we generate a certificate file and a private key? Obviously, if this
    is a learning or a weekend project, we wouldn't need to obtain a fully legitimate
    certificate from a CA.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we use what is known as a self-signed certificate. When you use
    such a certificate, it obviously won't be trusted by your web browser, because
    the certificate won't belong to the list of well-known CAs. For testing purposes,
    you will either need to configure your browser to trust the certificate or just
    ignore the warning and proceed.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we generate a self-signed certificate?
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to do this. Most people rely on the OpenSSL ([https://www.openssl.org/](https://www.openssl.org/))
    tool to generate test self-signed certificates. However, because we are using
    Go, we can make use of a tool that's provided by the Go language in the standard
    library instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your project folder, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple tool that's provided by Go in the `tls` package folder. You
    can use it to generate certificates. Here, `%GOROOT%` represents your Go root
    environmental variable. If you were to run this command in Linux, you would need
    to use `$GOROOT` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will generate a certificate for the `127.0.0.1` host
    (the loopback localhost). This tool has more flags/options that you can configure,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The command will generate the certificate and the private key files and will
    place them in your current folder. You can then copy them wherever you would like
    and just reference them from your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get your React application to support HTTPS mode while testing, you will
    need to run the following command when you start your React application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at Password hashing in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Password hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very important security measure is known as password hashing. Password
    hashing is an approach that's used to protect the passwords of user accounts that
    are handled by our application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take our GoMusic application as an example—we have a `customers` table,
    which hosts customer's usernames and passwords. So, should we store a customer's
    passwords in plain text? The answer is a loud and resounding *no*!
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we do instead? How do we protect our customers'' passwords and, at
    the same time, verify their passwords when they log in? This is where password
    hashing comes into the picture. It consists of two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: When saving a new customer password, hash the password and then save the hash.
    Hashing can simply be defined as one-way encryption—you can encrypt the password,
    but you can never decrypt it back. Hashing functions rely on complex math to achieve
    that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it's time to verify an existing customer's password, hash the password
    provided in the sign-in request, then compare the hash of the new incoming password
    with the saved hash of the original password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Password hashing protect your customers' passwords because it ensures that no
    malicious hacker would be able to access them, even if they hack into your database.
  prefs: []
  type: TYPE_NORMAL
- en: But what about protecting the password while it's en route from the web client
    to our web server? This is where HTTPS comes in. The password that's sent from
    the client will be fully encrypted until it reaches our backend web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start implementing some password hashing in our code. The first
    step is to go to our database layer and implement the logic to:'
  prefs: []
  type: TYPE_NORMAL
- en: Hash new user's passwords before saving it to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an existing user signs in, compare the provided password with the saved
    hashed password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next sections we will take a look at how to implement password hashing
    and verifying incoming passwords
  prefs: []
  type: TYPE_NORMAL
- en: Implementing password hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our database layer, we will define a new type for invalid password errors.
    In our `dblayer.go` file, we will add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `orm.go` file, we''ll add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code makes use of a package called `bcrypt`, which is very popular
    when it comes to hashing passwords. `bcrypt` stands for a popular password hashing
    function that was designed in the late 1990s. `bcrypt` is the default password
    hashing function in the OpenBSD operating system, and it enjoys support in numerous
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: The package also provides methods to compare hashed passwords with their human-readable
    counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the package is not yet installed in your environment, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We already came across the `hashPassword()` method in the `AddUser()` method,
    which will hash the password and then save it to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `HashPassword ()` method to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will perform the password hashing part. Before we return
    the customer object, we need to set the password to empty because this information
    doesn't need to be shared again for security purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's write the code that will compare the saved hashed passwords with
    passwords that are provided by users who are attempting to log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need another method from the `bcrypt` package to compare our saved
    hash with the incoming password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add code to the `SignInUser` method so that we can retrieve
    the hashed passwords of customers who are trying to sign in. Then, we can compare
    passwords. If the passwords don''t match, we return an error. If they do, we continue
    to log the user in by setting the logged-in flag to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, there is a tiny change we need to add to our HTTP web handler to handle
    failed logins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the `handlers.go` file and edit the `SignIn` method a bit.
    The edited parts of the code are shown in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at credit card handling in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Credit card handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already implemented the credit card logic at the frontend in [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml),
    *Building a Frontend for GoMusic*. It's now time to implement the backend part
    of our credit card handling.
  prefs: []
  type: TYPE_NORMAL
- en: For credit card processing at the frontend, we made use of the Stripe API ([https://stripe.com/docs/api](https://stripe.com/docs/api)).
    In a product environment, you would need to create an account with Stripe and
    obtain an API key to use for your application. For testing purposes, however,
    we can make use of testing API keys and test credit card numbers, which Stripe
    happily provides for developers to build productive apps that are capable of processing
    credit cards. To learn more about testing credit card numbers and testing tokens
    that are provided by Stripe, take a look at [https://stripe.com/docs/testing](https://stripe.com/docs/testing).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our frontend code, we made use of the following Stripe API code to create
    a token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We also made use of a very popular framework known as *Stripe elements*, which
    will collect all of our credit card information and then merge it with the create
    token request so that we get a token that represents the credit card that we are
    trying to process.
  prefs: []
  type: TYPE_NORMAL
- en: We then send this token down to the backend so that it can be processed and/or
    saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To process credit card payments, there are some key pieces of information that
    we need:'
  prefs: []
  type: TYPE_NORMAL
- en: The credit card token that's provided by the Stripe API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ID of the customer making the purchase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ID of the product the customer is trying to buy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The selling price of the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the card should be remembered for future use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether to use a pre-saved card or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I changed the frontend code so that it can collect this information and pass
    it to the HTTP request that''s bound to our backend. Here''s the part of the frontend
    code that will create and submit our request. The following code is in the `creditcards.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code makes use of the `fetch()` method in order to send a `POST`
    request to the backend. The `POST` request will contain a JSON message which will
    host all the data that our backend needs to process the request.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we'll take a look at how the backend of credit card handling
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Credit card handling at the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the Stripe API to process credit card transactions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an object of the `*stripe.CustomerParams` type, which can then take the
    credit card token that's provided by the frontend. The credit card token is ingested
    using a method called `SetToken()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an object of the `*stripe.Customer` type, which takes the object of the `stripe.CustomerParams` type
    as input. This is done through the `customer.New()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an object of the `*stripe.ChargeParams` type, which takes information
    about our transaction, such as the amount, the currency, and the description of
    the purchase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `*stripe.ChargeParams` object must also receive a field, which represents
    the Stripe customer ID. This is provided by the `*stripe.Customer` object we covered
    in *step 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that the Stripe customer ID is different to the actual customer ID
    that references the customer in our database.
  prefs: []
  type: TYPE_NORMAL
- en: If we would like to save this credit card and use it later, we can simply store
    the Stripe customer ID string for later use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we can charge the credit card by calling `charge.New()`, which takes
    the `*stripe.ChargeParams` object as an input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the preceding steps sound too difficult to follow, don't worry. Once we start
    looking at the code, it will become clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of our code will live inside the `charge` handler method, which is inside
    the `handler.go` file. Here is the current state of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The method doesn''t do anything yet. Here is what we need it to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the transaction information using the incoming HTTP request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request requires that we use an existing saved card, then we need to
    retrieve the saved customer Stripe ID and charge the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request requires that we remember the currently provided credit card
    information, then we save it to the database before we charge the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to create a type that can accept the data we are receiving from
    the frontend. Here is what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declared the Go struct and initialized it in the same
    piece of code. This is a quick way to create and use `struct` types on the fly
    in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to parse the incoming JSON payload into the `request` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to start writing some Stripe code. The first thing we need
    to do is declare the stripe API key—we''ll just use a test API key in this case.
    However, in a production environment, you''ll need to use your own Stripe key
    and protect it very well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a `*stripe.ChargeParams` object, which we covered in
    *step 3* at the beginning of this section. Here is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we initialize the stripe customer ID string. This is the important field,
    which was covered in *step 4* at the beginning of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if the incoming request expects us to use an existing card, we would retrieve
    the saved Stripe customer ID from the database and then use it. The following
    code uses a new database method that retrieves the Stripe customer ID from the
    database. We will implement this method later in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we can create a `*stripe.CustomerParams` object, which is used to
    create a `*stripe.Customer` object. This provides us with the Stripe customer
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are asked to remember the card, we simply store the Stripe customer ID
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we attempt to charge the credit card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the order to our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: And that's it for the `charge()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still some work remaining. The newly added code to the `charge()`
    handler made use of several database methods, which we have not created yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetCreditCardCID()`: Retrieves a saved Stripe customer ID from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SaveCreditCardForCustomer()`: Saves the stripe customer ID to our database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddOrder()`: Adds an order to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to add these three methods to the database layer interface in our `dblayer.go`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the three methods to our concrete implementation of the `DBLayer` interface.
    This is done in the `orm.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to go back to our `handler.go` file, and modify our `handler` constructor,
    such that it can connect to our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! And with that, the backend code for our GoMusic app is 99% complete,
    let's revisit our frontend code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the frontend code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last deep dive we did in terms of the frontend code was in [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building
    a Frontend for GoMusic*. [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*, and [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building
    a Frontend for GoMusic*, served to build solid and practical foundational knowledge
    about how to construct a working React app, which can be used as the frontend
    to our backend Go application.
  prefs: []
  type: TYPE_NORMAL
- en: These two chapters covered about 85% of GoMusic's frontend. However, they did
    not cover all of the JavaScript code that's needed to glue together the different
    React components that we built in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml),
    *Frontend with React.js, *and [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml),
    *Building a Frontend for GoMusic*. In this section, we will provide an overview
    of the overall frontend architectures and fill some of the gaps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at the application structure of the
    frontend of our application.
  prefs: []
  type: TYPE_NORMAL
- en: The app structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our frontend component is divided into the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.js`: The entry point to our React application, which calls the `App`
    component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.js`: The main component of our React application. It combines all of the
    other components to form our app. The `App` component hosted in the `App.js` file
    takes care of some important central tasks such as the signing in or the signing
    out of a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modalwindows.js`: This is responsible for all of the modal windows in our
    application. This includes the sign in, the new user registration, and the buy
    modal window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Navigation.js`: This is responsible for the navigational menu in our React
    application, which is how we move from one screen to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`creditcards.js`: This is responsible for the frontend side processing of credit
    cards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`productcards.js`: This is responsible for showing the list of product cards.
    This includes normal product cards and promotions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orders.js`: This shows a list of customer''s orders when a customer is signed
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`about.js`: This shows the About page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll see how to interconnect our frontend and backend in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions between the frontend and the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend with React.js*,
    we relied on a JSON file that contained some mock data to empower and run our
    frontend app without needing an actual working backend to be present. Now, we
    need to replace all of the code where we relied on the JSON sample data file and
    send full HTTP requests to the backend instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our React app to route the requests to our backend, we first need to add
    a field called `proxy` to the `package.json` file of our React application. The
    proxy field needs to point to the backend API address. In our case, the backend
    component of our application listens on local port `8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `package.json` file will exist in the main folder of your React app. This
    file is used by `node` package managers to figure our global settings, scripts,
    and dependencies for your `node` app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we send a request to the backend, we make use of the powerful `fetch()`
    method. This method can send HTTP requests to a relative URL. Here is an example
    of a request to fetch customer''s orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the next section we will explore how to make use of cookies in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our application doesn't rely anymore on a global sample data file to answer
    important questions such as whether a user is currently signed in or not, what
    the user's information is, and so on. The frontend application now makes use of
    browser cookies for this. A simple definition for browser cookies is that they
    are small pieces of information that get stored in the user's device using the
    web browser. This information can then be simply retrieved from the cookie when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The frontend code makes use of cookies to easily save and retrieve the user''s
    information to populate different screens and React components that need this
    information. This is done using the `js-cookie` JavaScript package. This package
    can be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of setting a cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of retrieving data from a cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Cookies are used to also check whether a user is currently signed in or signed
    out. Sign out handling code has been added to the React application since the
    code we covered in [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building
    a Frontend for GoMusic*, to handle the change of state that occurs when a user
    signs out. When a user signs out, we remove the information of the existing user
    from the cookie and just retain the fact that no one is logged in. Here is the
    code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For more context on how we use cookies in our React application, and how to
    handle user sign out, have a look at the App react component of our application
    at:[ https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/blob/master/Chapter07/Frontend/src/App.js](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/blob/master/Chapter07/Frontend/src/App.js)
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how to deploy our frontend application to a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the frontend application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you are done with the frontend code, it will need to be transformed into
    a form that can be shared and copied to production server environments, without
    needing to reinstall all the Node.js tools and dependencies that were needed in
    the development process.
  prefs: []
  type: TYPE_NORMAL
- en: The React framework comes to the rescue here. When we created our React application
    in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend with React.js*,
    and [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building a Frontend
    for GoMusic*, we used a tool called `create-react-app` to create our application
    and set up the toolchain. The tool supports some scripts that we can use to run
    and build our React application. We already mentioned the `npm start` command,
    which was used to run our React app in development mode, so that we can run our
    code and debug in real time as we are developing the application.
  prefs: []
  type: TYPE_NORMAL
- en: There is a script that is vital for getting our React app ready for production
    use and is called `build`. To run this script, we simply type the `npm run build`
    command from the main folder of our React app. This command will compile our entire
    application to some static files, which we can then serve directly from our Go
    app. The output of the build script goes to a folder called `build`, which gets
    created in our React app root folder.
  prefs: []
  type: TYPE_NORMAL
- en: Let's call this folder the React `build` folder. We can then copy this `build`
    folder anywhere and get our Go app to utilize it to serve the GoMusic app frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the steps that we need to follow in our Go code to be able to serve
    the React output `build` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import a Gin middleware called `static`, which we can do by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to go to our `rest.go` file, which hosted our HTTP route definitions.
    This file can be found in `backend\src\rest.go`. Inside `rest.go`, we will import
    the Gin static middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `RunAPIWithHandler` function, which includes all of our HTTP route
    definitions, we will replace the code that''s used to serve our `img` folder with
    code that serves all static files from the `build` folder that was generated by
    the React app. Here is what this will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The first argument of the `static.ServeRoot()` function is the relative HTTP
    root URL for our web application, while the second argument is basically the location
    of the React build folder.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to move the `img` folder, which included all of the images
    of our musical instruments, so that it is inside the `build` folder. Now, the
    `build` folder has all of the assets for our web application.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need to do. Now, we can just build our Go app into a single executable
    file by either using the `go build` or the `go install` command. Then, we can
    copy our executable web application along with the React build folder to wherever
    we would like to deploy our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered a lot of ground. In this chapter, we learned how to design
    and implement database layers for our backend services. We learned about the concept
    of web API middleware and how to make use of it. We also took a deep dive into
    some practical security concepts such as TLS and password hashing. We then learned
    how to process credit cards in our backend services through the powerful Stripe
    API. With this knowledge under your belt, you now have what it takes to build
    modern production web applications in Go.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to test our application by writing unit
    tests, and how to measure it's performance, by running benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is middleware?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Stripe customer ID?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an ORM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is GORM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we write a join query using GORM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is TLS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by password hashing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `bcrypt`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stripe API**: **[https://stripe.com/docs/api](https://stripe.com/docs/api)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GORM**: [http://gorm.io/](http://gorm.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package `bcrypt`**: [https://godoc.org/golang.org/x/crypto/bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport layer security: **[https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
