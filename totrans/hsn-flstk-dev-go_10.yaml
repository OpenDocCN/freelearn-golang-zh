- en: Advanced Web Go Applications with Gin and React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gin和React的高级Web Go应用程序
- en: In this chapter, we'll continue building our GoMusic web application. This chapter
    will cover some advanced concepts, as it will add to what we built in the previous
    chapter before it dives deeper into how to build advanced backend software. We
    will cover some important and practical topics such as database layers for connecting
    our application to a production database, **object-relational mapping** (**ORM**)
    for simplifying our database layer code, middleware for adding functionality on
    top of our Web API handlers, authentication to secure our web application, and
    credit card charging. We will also revisit the frontend of our GoMusic application
    in order to cover how our frontend would connect to our backend.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续构建我们的GoMusic Web应用程序。本章将涵盖一些高级概念，因为它将在深入探讨如何构建高级后端软件之前，增加我们在上一章中构建的内容。我们将涵盖一些重要且实用的主题，例如数据库层将我们的应用程序连接到生产数据库，**对象关系映射**（ORM）简化我们的数据库层代码，中间件在Web
    API处理器上添加功能，认证以保护我们的Web应用程序，以及信用卡收费。我们还将回顾GoMusic应用程序的前端，以了解我们的前端如何连接到后端。
- en: 'Specifically, we''ll cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将涵盖以下主题：
- en: Database layers and ORMs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库层和ORM
- en: Middleware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件
- en: Security, authentication, and authorization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性、认证和授权
- en: Credit card charging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用卡收费
- en: Proxying React applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理React应用程序
- en: Authorizing and authenticating from React applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从React应用程序中进行授权和认证
- en: This chapter will revisit the frontend layer of our application, in order to
    evolve our existing React application to utilize the new backend features.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重新审视我们应用程序的前端层，以便将现有的React应用程序升级以利用新的后端功能。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we recommend that you have the following software installed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们建议您安装以下软件：
- en: The Go language
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言
- en: A code editor or an IDE such as VS Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编辑器或IDE，如VS Code
- en: npm and Node.js
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm和Node.js
- en: React
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React
- en: 'Knowledge of the following topics is required:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要了解以下主题：
- en: Go ([Chapter 2](d638558d-2461-4bc9-b51b-317307ed899b.xhtml), *Building Blocks
    of the Go Language, *and [Chapter 3](72d04e99-a5af-4af9-b51a-54c4c750871f.xhtml),
    *Go Concurrency*)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go ([第2章](d638558d-2461-4bc9-b51b-317307ed899b.xhtml)，*Go语言构建块*，和[第3章](72d04e99-a5af-4af9-b51a-54c4c750871f.xhtml)，*Go并发*)
- en: JavaScript
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: React ([Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend with
    React.js*, and [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building
    a Frontend for GoMusic*)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React ([第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，*使用React.js进行前端开发*，和[第5章](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml)，*为GoMusic构建前端*)
- en: Some familiarity with relational databases and MySQL
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对关系型数据库和MySQL有一定的了解
- en: The code for this chapter can be found in this book's GitHub repository at [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter07).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter07)。
- en: The database layer
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库层
- en: 'In the previous chapter, we started writing our database layer. As a reminder,
    our database layer was hosted in the `backend\src\dblayer` folder. Our first step
    was to write the database layer interface, which defined all of the functionality
    that we expect from the database layer. This is what the database layer interface
    looked like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始编写我们的数据库层。作为提醒，我们的数据库层托管在`backend\src\dblayer`文件夹中。我们的第一步是编写数据库层接口，它定义了我们期望从数据库层获得的所有功能。数据库层接口看起来是这样的：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we need to implement these methods to get some solid functionality in our
    database layer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现这些方法，以便在我们的数据库层中获得一些稳定的功能。
- en: Before we start implementing this functionality, we first need to get a database
    ready.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现此功能之前，我们首先需要准备一个数据库。
- en: Relational databases
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: A database is one of the key pieces of the backend of any application. This
    is where the backend layer can persist and retrieve data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是任何应用程序后端的关键组成部分。这是后端层可以持久化和检索数据的地方。
- en: A relational database can simply be described as a database that stores data
    in a number of tables and then establishes relationships between those tables.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库可以简单地描述为存储数据在多个表中，然后在这些表之间建立关系的数据库。
- en: 'When configuring a database, there are three things we need to define:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置数据库时，我们需要定义三件事：
- en: '**A database name**: In our case, it will be called GoMusic.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库名称**：在我们的案例中，它将被称为 GoMusic。'
- en: '**Table names**: In our case, for simplicity, we''ll go with three tables:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表名称**：在我们的案例中，为了简单起见，我们将使用三个表：'
- en: '**A** `customer` **table**: This table is where we''ll store our app user''s
    information'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个** `customer` **表**：此表是我们存储应用程序用户信息的地方'
- en: '**An** `orders` **table**: This table should map the customers to the products
    they bought'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个** `orders` **表**：此表应将客户映射到他们购买的产品'
- en: '**A** `products` **table**: This table will host a list of the available products
    for GoMusic'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个** `products` **表**：此表将包含 GoMusic 可用产品的列表'
- en: '**Indexes and relationships between the tables**: In our case, the orders table
    will point to both the `customer` and `products` tables. Both tables will need
    an `id` index. Indexes are used to make queries more efficient and faster.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引和表之间的关系**：在我们的案例中，订单表将指向 `customer` 和 `products` 表。两个表都需要一个 `id` 索引。索引用于使查询更高效和更快。'
- en: MySQL is a well-known relational database, and we will be using it in this book.
    MySQL is a very popular open source database engine and is being used in numerous
    projects, both large and small.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 是一个知名的数据库，我们将在这本书中使用它。MySQL 是一个非常流行的开源数据库引擎，被用于众多大小项目。
- en: 'Here is how our architecture looks like with a database serving data for our
    application''s backend:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的架构图，其中数据库为应用程序的后端提供数据：
- en: '![](img/6bc5864d-cde9-4dba-9c61-0eaa5ae5819a.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bc5864d-cde9-4dba-9c61-0eaa5ae5819a.png)'
- en: Let's set up MySQL for our application in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为我们的应用程序设置 MySQL。
- en: Setting up
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: Before we start creating databases and tables, we first need to install MySQL.
    There are Enterprise Editions as well as Community Editions of MySQL. The Community
    Edition of MySQL is what we would use in a project like ours. This is because
    the Community Editions are free and can be used for learning and exploration projects.
    To install the MySQL Community Edition Server, you need to download it from the
    following link: [https://dev.mysql.com/downloads/](https://dev.mysql.com/downloads/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建数据库和表之前，我们首先需要安装 MySQL。MySQL 有企业版和社区版。MySQL 的社区版是我们将在类似我们的项目中使用的版本。这是因为社区版是免费的，可以用于学习和探索项目。要安装
    MySQL 社区版服务器，您需要从以下链接下载它：[https://dev.mysql.com/downloads/](https://dev.mysql.com/downloads/)。
- en: 'Once we have installed MySQL, we need to install client tools to make use of
    the database. MySQL usually comes with a tool called MySQL Workbench, which is
    shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了 MySQL，我们需要安装客户端工具来使用数据库。MySQL 通常附带一个名为 MySQL Workbench 的工具，如下面的截图所示：
- en: '![](img/203e2f14-59f5-431b-9122-8a77a1b66a20.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/203e2f14-59f5-431b-9122-8a77a1b66a20.png)'
- en: The MySQL Workbench tool page
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Workbench 工具页面
- en: You can use the tools in MySQL Workbench to create MySQL databases, tables,
    indexes, and relationships. Let's go through the tables, one by one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 MySQL Workbench 中的工具创建 MySQL 数据库、表、索引和关系。让我们逐个查看这些表。
- en: The customer table
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户表
- en: 'As we mentioned earlier, this is the table where we will store our app user''s
    information. Here is how the `customer` table will look like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这是我们将存储我们的应用程序用户信息的表。以下是 `customer` 表的样式：
- en: '![](img/da5fe63a-7c80-4faa-be1a-2ebfb3d966ee.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da5fe63a-7c80-4faa-be1a-2ebfb3d966ee.png)'
- en: 'The table consists of the following ten columns:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表由以下十个列组成：
- en: '`id`: This is the unique ID for each customer.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`id`: 这是每个客户的唯一 ID。'
- en: '`firstname`: This is the first name of the customer.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`firstname`: 这是客户的姓名。'
- en: '`lastname`: This is the last name of the customer.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lastname`: 这是客户的姓氏。'
- en: '`email`: This is the customer''s email.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`email`: 这是客户的电子邮件。'
- en: '`pass`: This is the password for the customer. This field must be stored in
    a hashed form.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pass`: 这是客户的密码。此字段必须以散列形式存储。'
- en: '`cc_customerid`: This is an ID that represents the credit card of the customer.
    We''ll cover this field later in this chapter.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cc_customerid`: 这是一个代表客户信用卡的 ID。我们将在本章后面介绍此字段。'
- en: '`loggedin`: This flag specifies whether the user is logged in or not.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loggedin`: 此标志指定用户是否已登录。'
- en: '`created_at`: This field specifies the date when the customer was added.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`created_at`: 此字段指定了客户被添加的日期。'
- en: '`updated_at`: This field specifies the last time the row/customer was updated.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`updated_at`: 此字段指定了行/客户最后更新时间。'
- en: '`deleted_at`: This field specifies the last time the row was deleted.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`deleted_at`: 此字段指定了行最后被删除的时间。'
- en: This table will support two indexes. As mentioned earlier, indexes are used
    to make queries more efficient and faster. This is done by identifying the columns,
    which we expect will be used as search keys in our queries. Indexes can also be
    used to identify fields that are unique and must not be duplicated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此表将支持两个索引。如前所述，索引用于使查询更高效和更快。这是通过识别我们预期将用作查询搜索键的列来实现的。索引还可以用于识别唯一且不得重复的字段。
- en: '![](img/8297973c-dc3e-4853-b28f-e125fc233358.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8297973c-dc3e-4853-b28f-e125fc233358.png)'
- en: The primary key is the customer `id` field; it's a unique identification number
    per customer. The unique key is the `email` field. We can't have two or more customers
    with the same email address.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 主键是客户`id`字段；它是对每个客户的唯一识别号。唯一键是`email`字段。我们不能有两个或更多具有相同电子邮件地址的客户。
- en: The orders table
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单表
- en: 'Now, let''s look at the `orders` table, which will host a list of the available
    products for GoMusic:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`orders`表，它将托管GoMusic可用的产品列表：
- en: '![](img/9f275965-fcde-4ae6-b04c-1ad0506f4f0a.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f275965-fcde-4ae6-b04c-1ad0506f4f0a.png)'
- en: 'This table consists of the following eight columns:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此表由以下8列组成：
- en: '`id`: The unique ID of the order'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`id`: 订单的唯一ID'
- en: '`customer_id`: The ID of the customer making the order'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`customer_id`: 下订单的客户的ID'
- en: '`product_id`: The ID of the product the customer bought'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`product_id`: 客户购买产品的ID'
- en: '`price`: The price of the purchase'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`price`: 购买价格'
- en: '`purchase_date`: The date of the purchase'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`purchase_date`: 购买日期'
- en: '`created_at`: The date/time the row was created'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`created_at`: 行创建的日期/时间'
- en: '`updated_at`: The updated date/time when the row was last updated'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`updated_at`: 行最后更新的日期/时间'
- en: '`deleted_at`: The date/time when the row was deleted, if any'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`deleted_at`: 如果有的话，行被删除的日期/时间'
- en: 'This table will support one index, as shown in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此表将支持一个索引，如下面的截图所示：
- en: '![](img/1faac61c-5197-4e75-a3f7-5f9c0b3a76b8.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1faac61c-5197-4e75-a3f7-5f9c0b3a76b8.png)'
- en: The index is simply the unique ID index. Each order will have its own unique
    ID.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 索引仅仅是唯一ID索引。每个订单都将有自己的唯一ID。
- en: The products table
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品表
- en: 'Finally, let''s look at the `products` table. This table will map the customers
    to the products they bought:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`products`表。此表将映射客户及其购买的产品：
- en: '![](img/f4b3595d-b303-4faf-bf1d-21851bdd7094.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4b3595d-b303-4faf-bf1d-21851bdd7094.png)'
- en: 'The table consists of the following 10 columns:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该表由以下10列组成：
- en: '`id`: The unique ID of the product'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`id`: 产品的唯一ID'
- en: '`image`: The relative location of the product image'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`image`: 产品图像的相对位置'
- en: '`imgalt`: The alternative name for the image'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`imgalt`: 图像的替代名称'
- en: '`description`: The product description'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`description`: 产品描述'
- en: '`productname`: The name of the product'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`productname`: 产品名称'
- en: '`price`: The original price of the product'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`price`: 产品的原始价格'
- en: '`promotion`: The promotional price of the product'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`promotion`: 产品的促销价格'
- en: '`created_at`: The time when the row was created'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`created_at`: 行创建的时间'
- en: '`updated_at`: The time when the row was last updated'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`updated_at`: 行最后更新时间'
- en: '`deleted_at`: The time when the row was deleted, if any'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`deleted_at`: 如果有的话，行被删除的时间'
- en: 'This table supports just one index, that is, our unique product `id` field:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此表仅支持一个索引，即我们的唯一产品`id`字段：
- en: '![](img/3280387c-db16-41ab-8198-7b3010d94b44.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3280387c-db16-41ab-8198-7b3010d94b44.png)'
- en: With this, we should have a good enough database to empower our application.
    Our database is relatively simple, but it is sufficient to showcase the concepts
    that we need to cover in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们应该有一个足够好的数据库来支持我们的应用程序。我们的数据库相对简单，但它足以展示我们在本章需要涵盖的概念。
- en: Now that we have covered what our database will look like, it's time to cover
    how to design the code that interacts with our database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们的数据库将是什么样子，是时候讨论如何设计与我们的数据库交互的代码了。
- en: ORM
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ORM
- en: To design the code that interacts with our database, we will utilize an approach
    known as *ORM *. ORMs allow you to interact with databases using object-oriented
    paradigms. ORMs generate code that represent database tables as code objects,
    and represents queries as methods in your favorite programming language.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计与我们的数据库交互的代码，我们将利用一种称为*ORM*的方法。ORM允许您使用面向对象范式与数据库交互。ORM生成代表数据库表作为代码对象的代码，并将查询表示为您的首选编程语言中的方法。
- en: In the case of the Go language, we will need to create Go structs to represent
    each of our tables. We already started writing our models in the previous chapter,
    that is, `product`, `customer`, and `order`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言的情况下，我们需要创建Go结构体来表示每个表。我们已经在上一章中开始编写我们的模型，即`product`、`customer`和`order`。
- en: Before we continue to write the code, let's first discuss the **Go object-relational
    mapping** (**GORM**), which is the Go open source package, that offers support
    for ORMs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续编写代码之前，让我们首先讨论一下**Go对象关系映射**（**GORM**），这是一个Go开源包，提供了ORM的支持。
- en: GORM
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GORM
- en: 'One of the most popular Go ORM packages is the GORM package, which can be found
    at [http://gorm.io/](http://gorm.io/). GORM offers some mature functionality that
    makes writing backend database layers a breeze. Let''s continue writing our database
    layer by utilizing ORM, step by step:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的Go ORM包之一是GORM包，可以在[http://gorm.io/](http://gorm.io/)找到。GORM提供了一些成熟的功能，使得编写后端数据库层变得轻而易举。让我们通过利用ORM，一步一步地继续编写我们的数据库层：
- en: 'First, we need to retrieve the GORM package:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检索GORM包：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, we need to evolve our models so that they can be used properly by GORM.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要演进我们的模型，以便它们可以被GORM正确使用。
- en: An ORM needs model objects to accurately reflect the database table columns
    that are expected to be read and/or manipulated by the ORM library. The ORM can also make
    use of some meta information, for example, the last time a row was updated, deleted,
    or created, to ensure proper synchronization between the database and your application
    at runtime.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ORM需要模型对象来准确反映ORM库预期读取和/或操作的数据库表列。ORM还可以使用一些元信息，例如，行最后一次更新、删除或创建的时间，以确保在运行时数据库和应用程序之间正确同步。
- en: 'In the case of GORM, there is a data type called `gorm.Model`, which is simply
    a Go struct that hosts fields representing the row `id` field, the `created_at`
    time, the `updated_at` time, and the `deleted_at` time. It is recommended to embed
    `gorm.Model` in Go structs that represent your data. In the case of the `customers`
    table, the Go struct would look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在GORM的情况下，有一个名为`gorm.Model`的数据类型，它只是一个Go结构体，包含表示行`id`字段、`created_at`时间、`updated_at`时间和`deleted_at`时间的字段。建议将`gorm.Model`嵌入表示你数据的Go结构体中。对于`customers`表，Go结构体看起来会是这样：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code also shows plenty of `struct tags`. The `gorm` struct tags
    in the preceding example are used to identify the column names that correspond
    to the field names. So, for instance, the struct field, `FirstName`, is represented
    by a column called `firstname`. This is identified by the line `gorm:"column:firstname"`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码还展示了大量的`struct tags`。前述示例中的`gorm`结构体标签用于标识与字段名称对应的列名。例如，结构体字段`FirstName`由名为`firstname`的列表示。这是通过`gorm:"column:firstname"`这一行来标识的。
- en: We also make use of the `json` `struct` tag in the preceding code to identify
    what the field will look like in the JSON format. In theory, we don't always need
    to assign `struct` tags for every single field; however, I find it more practical
    to do so to avoid confusion.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了前述代码中的`json` `struct`标签来标识字段在JSON格式中的样子。理论上，我们并不总是需要为每个字段分配`struct`标签；然而，我发现这样做更实用，可以避免混淆。
- en: 'But how can GORM recognize the fact that the `Customer` Go struct corresponds
    to the `customers` table in our database? Usually, GORM changes the first letter
    of our Go struct name to lowercase, and then it adds an ''*s''* at the end, which
    will convert `Customer` into `customers`. However, GORM also empowers us to explicitly
    declare the table name that corresponds to the Go struct. This can be done through
    a method whose signature is `TableName()string`. So, in other words, we can explicitly
    specify our table name using the following method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但GORM是如何识别`Customer` Go结构体对应我们数据库中的`customers`表的？通常，GORM会将我们的Go结构体名称的第一个字母转换为小写，然后在末尾添加一个'*s*'，这样就将`Customer`转换成了`customers`。然而，GORM也赋予我们显式声明与Go结构体对应的表名的权力。这可以通过一个方法实现，其签名是`TableName()string`。换句话说，我们可以使用以下方法显式指定我们的表名：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Great! Now, inside our `backend\src\models\models.go` file, which sits inside
    our project folder, let''s evolve the data models for the `products` and `orders`
    tables, similarly to what we did previously:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，在我们的项目文件夹内的`backend\src\models\models.go`文件中，让我们像之前做的那样，逐步演进`products`和`orders`表的数据模型：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's implement of database layer in the next section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中实现数据库层。
- en: Implementing the database layer
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据库层
- en: Now, we have to implement the functionality of our database layer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须实现数据库层的功能。
- en: 'In the previous chapter, we designed a database layer interface that defined
    all of the database operations we are expected to need. This is what it looked
    like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设计了一个数据库层接口，该接口定义了我们预期需要的所有数据库操作。它看起来是这样的：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our project folder, let's create a new file called `orm.go` in the same folder
    as `dblayer`. The file will exist in the `{our_project_folder}/backend/src/dblayer`
    folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目文件夹中，让我们在 `dblayer` 同一文件夹中创建一个名为 `orm.go` 的新文件。该文件将位于 `{our_project_folder}/backend/src/dblayer`
    文件夹中。
- en: The GORM package relies on plugins to connect to the different databases that
    GORM supports. Plugins are Go packages that need to be imported silently in the
    package where GORM is being used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: GORM 包依赖于插件来连接 GORM 支持的不同数据库。插件是需要在 GORM 被使用的包中静默导入的 Go 包。
- en: 'To import a plugin package silently in Go, along with the GORM package, we
    can use the following syntax:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Go 中静默导入插件包，包括 GORM 包，我们可以使用以下语法：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our plugin is the `github.com/go-sql-driver/mysql` package. If you don''t already
    have it installed in your machine, you will need to retrieve it using the `go
    get` command from your favorite Terminal:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插件是 `github.com/go-sql-driver/mysql` 包。如果你还没有在你的机器上安装它，你需要使用你最喜欢的终端中的 `go
    get` 命令来检索它：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we'll need to create a Go `struct` type, which will implement our `DBLayer`
    interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个 Go `struct` 类型，该类型将实现我们的 `DBLayer` 接口。
- en: 'Our Go struct will host a data type called `*gorm.DB`. The `*gorm.DB` type
    is our entry point for using GORM''s functionality. Here is what the code will
    look like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Go 结构体将托管一个名为 `*gorm.DB` 的数据类型。`*gorm.DB` 类型是我们使用 GORM 功能的入口点。以下是代码的样子：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need to create a constructor for our new type. The constructor will initialize
    our embedded `*gorm.DB` type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的新类型创建一个构造函数。构造函数将初始化我们嵌入的 `*gorm.DB` 类型。
- en: 'To obtain an initialized `*gorm.DB` type, we need to use a function called
    `gorm.Open()`. This function takes two arguments—our database type name, which
    in our case is `mysql`, and our connection string. A connection string basically
    contains information regarding how to connect to the specific database that we
    are trying to access. To make our constructor flexible, we won''t hardcode the
    database name or the connection string. Instead, we''ll allow this information
    to be passed to the constructor. Here is the code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取初始化的 `*gorm.DB` 类型，我们需要使用一个名为 `gorm.Open()` 的函数。这个函数接受两个参数——我们的数据库类型名称，在我们的例子中是
    `mysql`，以及我们的连接字符串。连接字符串基本上包含有关如何连接我们试图访问的特定数据库的信息。为了使我们的构造函数灵活，我们不会硬编码数据库名称或连接字符串。相反，我们将允许这些信息传递给构造函数。以下是代码：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's finally time to start implementing the methods of the `DBLayer` interface.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始实现 `DBLayer` 接口的方法了。
- en: 'We''ll start by making use of GORM helpful methods, which will spare us from
    having to write explicit queries. The first method to implement is `GetAllProducts().`
    This method simply returns a list of all products, which is the equivalent of
    a `select *` SQL statement. This can be achieved using GORM''s `db.Find()` method,
    which belongs to the `*gorm.DB` type. Here is the code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先利用 GORM 的有用方法，这将使我们免于编写显式的查询。要实现的第一种方法是 `GetAllProducts()`。该方法简单地返回所有产品的列表，这相当于一个
    `select *` SQL 语句。这可以通过使用 GORM 的 `db.Find()` 方法实现，该方法属于 `*gorm.DB` 类型。以下是代码：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see how using an ORM like GORM can produce extremely efficient code.
    The single line of code in the preceding method executed a `select * from products` query
    at the `products` table and then returned all of the results. The `Find()` method
    was able to detect that we seek the products table because we supplied it with
    an argument of type `[]models.Product`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到使用像 GORM 这样的 ORM 可以产生极其高效的代码。前面方法中的单行代码在 `products` 表上执行了一个 `select * from
    products` 查询，然后返回了所有结果。`Find()` 方法能够检测我们寻求产品表，因为我们向它提供了一个类型为 `[]models.Product`
    的参数。
- en: Next, we write the `GetPromos()` method, which returns a list of products where
    the promotion field is not null.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写 `GetPromos()` 方法，该方法返回一个促销字段不为空的产品的列表。
- en: 'This is simply a select statement with a `where` clause. GORM allows you to
    achieve this by using a method called `Where()`, combined with the `Find()` method
    we covered earlier. Here is the code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个带有 `where` 子句的选择语句。GORM 允许你通过使用一个名为 `Where()` 的方法，结合我们之前提到的 `Find()` 方法来实现这一点。以下是代码：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Again, this is simple and efficient. The preceding method simply executed the
    equivalent of the following query:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这很简单且高效。前面的方法只是简单地执行了以下查询的等效操作：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Where()` method can also take a Go struct value, which represents the
    condition in our query. We''ll see that in our next `DBLayer` method, which is
    `GetCustomerByName`. This method takes the first and last names of a customer
    and then returns the customer''s information. Here is the code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where()` 方法也可以接受一个 Go 结构体值，它代表查询中的条件。我们将在下一个 `DBLayer` 方法中看到这一点，即 `GetCustomerByName`
    方法。此方法接受客户的姓和名，然后返回客户信息。以下是代码：'
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method is very similar to the `GetPromos()` method, except that the `Where()`
    method is fed a Go struct value with the first and last names instead of a string
    `where` clause. The equivalent of the following query was executed:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与 `GetPromos()` 方法非常相似，只是 `Where()` 方法接收一个包含姓和名的 Go 结构体值，而不是字符串 `where` 子句。以下查询的等效操作被执行：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we will implement `GetCustomerByID()`, which will retrieve a customer
    by using their ID in the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `GetCustomerByID()` 方法，它将通过在数据库中使用客户的 ID 来检索客户。
- en: 'This time, instead of using a combination of `Where` and `Find`, we will use
    a method called `First`, which can get the first result that corresponds to a
    certain condition:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不再使用 `Where` 和 `Find` 的组合，而是将使用一个名为 `First` 的方法，它可以获取符合特定条件的第一条结果：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we will implement a method to get a product by ID, which is very similar
    to `GetCustomerByID()`, except this time the result is a product and not a customer:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个通过 ID 获取产品的方法，这与 `GetCustomerByID()` 非常相似，但这次结果是产品而不是客户：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So far, we have been writing methods that execute queries and retrieve results.
    But now, it's time to start writing methods that add or update rows.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在编写执行查询和检索结果的方法。但现在，是时候开始编写添加或更新行的方法了。
- en: Our next method is `AddUser()`, which basically adds a new user to the database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个方法是 `AddUser()`，它基本上是将新用户添加到数据库中。
- en: 'This method will also hash the user''s password (which we will cover later
    in the *Security* section), and will set the user as logged in. GORM provides
    a very handy method called `Create()` so that we can add rows to our database:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法还将对用户的密码进行散列（我们将在后面的 *安全* 部分介绍），并将用户设置为已登录。GORM 提供了一个非常方便的方法 `Create()`，这样我们就可以将行添加到我们的数据库中：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we need to implement the `SignInUser` method, which basically updates
    the `loggedin` field in a row representing a specific customer in our customers
    table.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现 `SignInUser` 方法，它基本上更新了我们客户表中代表特定客户的行中的 `loggedin` 字段。
- en: 'The `SignInUser` method will identify the user that just logged in based on
    their email. We will then verify the user''s password. If the password is correct,
    then we update the database. Here is what the code will look like:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignInUser` 方法将根据用户的电子邮件识别刚刚登录的用户。然后我们将验证用户的密码。如果密码正确，我们将更新数据库。以下是代码的示例：'
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code covers many of the methods we covered before, except in
    two places:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码涵盖了之前介绍过的许多方法，但有两个地方除外：
- en: '`result := db.Table("Customers").Where(&models.Customer{Email: email})`: This
    is how we can obtain an object representing the row that we are interested in'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result := db.Table("Customers").Where(&models.Customer{Email: email})`：这是我们获取我们感兴趣的行所表示的对象的方法'
- en: '`result.Update("loggedin", 1)`: This is how we update our row'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result.Update("loggedin", 1)`：这是我们更新我们行的方法'
- en: 'The `SignOutUserById()` method is used to sign out users using their IDs. This
    will follow the same techniques that we have covered so far:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignOutUserById()` 方法用于通过用户 ID 注销用户。这将遵循我们之前介绍过的相同技术：'
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we implement the `GetCustomerOrdersByID()` method to get customer
    orders by `customer_id`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现 `GetCustomerOrdersByID()` 方法，通过 `customer_id` 获取客户订单：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code is a bit different than the previous methods. This is because
    we need to execute a couple of joins to produce the results we seek. We need to
    join three tables: the `orders` table, the `customers` table, and the `products`
    table. From the `customers` table, we only want customers with IDs that correspond
    to the provided customer''s ID. For the `products` table, we only want products
    where the product ID corresponds to the product ID of the current order. Luckily,
    the GORM package provides a method called `Joins`, which can be used to join tables.
    The preceding code will translate into the following query (assuming that we have
    a `customer_id` of value `''1''`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与之前的方法略有不同。这是因为我们需要执行几个连接来生成我们所需的结果。我们需要连接三个表：`orders`表、`customers`表和`products`表。从`customers`表，我们只想获取与提供的客户
    ID 对应的客户。对于`products`表，我们只想获取产品 ID 与当前订单的产品 ID 相对应的产品。幸运的是，GORM 包提供了一个名为`Joins`的方法，可以用来连接表。上述代码将转换为以下查询（假设我们有一个值为`'1'`的`customer_id`）：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And with that, our database layer is almost done. Let's take a look at what
    is middleware in the next section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的数据库层几乎就完成了。让我们在下一节看看什么是中间件。
- en: Middleware
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: Middleware is an important and fun topic in the world of modern web applications.
    The word *middleware* can mean many things in the software development industry.
    However, for the purpose of this book, we only care about one definition for it.
    **Middleware** can simply be defined as code that can run between the time you
    receive an HTTP request and the time your handler code gets executed on that request.
    This is best explained through an example.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是现代网络应用世界中的一个重要且有趣的话题。在软件开发行业中，*中间件*这个词可以意味着很多不同的东西。然而，为了这本书的目的，我们只关心一个定义。**中间件**可以简单地定义为在收到
    HTTP 请求和你的处理代码执行该请求之间运行的代码。这最好通过一个例子来解释。
- en: 'In the RESTful API that we built for our GoMusic application, let''s pick on
    one of our API endpoints—the `/products` relative URL. Here was the code that
    was used to assign this relative URL to an action or a function handler:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为 GoMusic 应用程序构建的 RESTful API 中，让我们挑选我们的一个 API 端点——`/products` 相对 URL。以下是用于将此相对
    URL 分配给动作或函数处理器的代码：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here was the code of the `GetProducts` handler:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`GetProducts`处理器的代码：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So far, so good. Here is the workflow for this API resource:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。以下是此 API 资源的流程：
- en: An HTTP `GET` request is received at the `/products` relative URL address.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/products`相对 URL 地址收到一个 HTTP `GET` 请求。
- en: The `GetProducts()` method gets executed.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetProducts()`方法将被执行。'
- en: Our web API middleware is simply some code that we can inject between *steps
    1* and *2* or even beyond. Technically, the middleware is simply an HTTP handler
    function that wraps our own handler function. In other words, it's a function
    that will encapsulate the `GetProducts()` method, which will allow you to insert
    functionality before and after your method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Web API 中间件只是我们可以在*步骤 1*和*步骤 2*之间，甚至更远的地方注入的一些代码。技术上讲，中间件只是一个包装我们自己的处理函数的
    HTTP 处理函数。换句话说，它是一个将封装`GetProducts()`方法的函数，这将允许你在你的方法前后插入功能。
- en: The Gin web framework comes preloaded with two pieces of middleware by default.
    The framework also allows you to define your own custom middleware when needed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Gin 网络框架默认预加载了两件中间件。框架还允许你在需要时定义自己的自定义中间件。
- en: 'The two default middlewares that get injected into the Gin web server are **logger
    middleware** and **recovery middleware**. The logger middleware simply logs the
    API activity throughout the life of your application. If you run a Go web application
    that''s powered by Gin in a Terminal of your choice, you will see something like
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Gin 网络服务器中注入的两个默认中间件是**日志中间件**和**恢复中间件**。日志中间件简单地记录了应用程序生命周期中的 API 活动。如果你在所选的终端中运行由
    Gin 驱动的 Go 网络应用程序，你会看到类似以下的内容：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is basically Gin's logging middleware in action.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是 Gin 的日志中间件在起作用。
- en: On the other hand, Gin's recovery middleware ensures that your application is
    recovered from panics and writes the HTTP error code `500` in the response when
    necessary.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Gin 的恢复中间件确保在必要时从恐慌中恢复应用程序，并在响应中写入 HTTP 错误代码`500`。
- en: There are numerous open source middleware options available for Gin. One list
    of supported middleware can be found at [https://github.com/gin-gonic/contrib](https://github.com/gin-gonic/contrib).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Gin，有许多开源的中间件选项可供选择。一份支持的中间件列表可以在[https://github.com/gin-gonic/contrib](https://github.com/gin-gonic/contrib)找到。
- en: Let's see how to write a custom middleware in the next section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何编写自定义中间件。
- en: Custom middleware
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义中间件
- en: As we mentioned earlier, Gin allows you to author your own middleware so that
    you can embed some functionality in your web app. Writing custom middleware in
    Gin is relatively simple, as we can see in the following steps.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Gin 允许你编写自己的中间件，以便你可以在你的 Web 应用程序中嵌入一些功能。在 Gin 中编写自定义中间件相对简单，正如我们可以在以下步骤中看到的那样。
- en: The first step is to write the actual code for the middleware.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写中间件的实际代码。
- en: 'As we mentioned earlier, a web API middleware is simply an HTTP handler function
    that encapsulates other HTTP handler functions. Here is what the code would look
    like for this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Web API 中间件简单来说就是一个封装其他 HTTP 处理函数的 HTTP 处理函数。以下是这个代码的示例：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s write a very simple middleware that would print `************************************`
    before and after the request:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个非常简单的中间件，它会在请求前后打印 `************************************`：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next step is to add this middleware to our Gin engine. This can be done
    in two ways:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将此中间件添加到我们的 Gin 引擎中。这可以通过两种方式完成：
- en: 'If we want to keep Gin''s default middleware, but then add `MyCustomLogger()`,
    we can do the following:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想保留 Gin 的默认中间件，但同时又想添加 `MyCustomLogger()`，我们可以这样做：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If, on the other hand, we want to ignore Gin''s default middleware and only
    enable our custom middleware, we can use the following code path:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想忽略 Gin 的默认中间件，只启用我们的自定义中间件，我们可以使用以下代码路径：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we''d like to enable more than one middleware, we just add them as an argument
    to the `Use()` method, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想启用多个中间件，我们只需将它们作为 `Use()` 方法的参数添加，如下所示：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the next section, we'll discuss how to secure our web application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何确保我们的 Web 应用程序的安全。
- en: Security
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is a very important topic when it comes to deploying web applications
    to production. This topic is massive and can take chapters to cover, if not books.
    Since the purpose of this book is to cover practical hands-on topics and be to
    the point, we will cover the most vital nuggets of knowledge that are needed to
    build a secure web application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将 Web 应用程序部署到生产环境时，安全性是一个非常重要的话题。这个话题非常庞大，可能需要章节甚至书籍来涵盖。由于本书的目的是涵盖实用的动手操作主题，并且要简洁明了，我们将涵盖构建安全
    Web 应用程序所需的最关键的知识点。
- en: Secure web applications primarily rely on encrypting the data between the web
    client (browser) and the web server. In other words, they rely on encrypting the
    data between the frontend and the backend.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的 Web 应用程序主要依赖于加密客户端（浏览器）和服务器之间的数据。换句话说，它们依赖于加密前端和后端之间的数据。
- en: As we mentioned earlier, HTTP is the protocol that's utilized between web clients
    and web servers. HTTP can be secured through a protocol that is known as **TLS**
    (**Transport Layer Security**).The combination of HTTP and TLS is commonly known
    as **HTTPS**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，HTTP 是客户端和服务器之间使用的协议。HTTP 可以通过一个名为 **TLS**（**传输层安全性**）的协议来保护。HTTP 和
    TLS 的组合通常被称为 **HTTPS**。
- en: There is another protocol known as SSL, which was also utilized to secure HTTP.
    However, TLS is newer and more secure.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为 SSL 的协议，它也被用来保护 HTTP。然而，TLS 更新且更安全。
- en: Before we discuss the code, let's first cover some important background knowledge
    about HTTPS and how it works.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论代码之前，让我们首先了解一些关于 HTTPS 以及它是如何工作的背景知识。
- en: Certificates and private keys
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书和私钥
- en: 'HTTPS works as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 的工作原理如下：
- en: Trust is established between the web client and the web server. This happens
    through a handshake and through certificates and private keys. We will cover this
    in more detail later.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端和服务器之间通过握手以及证书和私钥建立信任。我们将在稍后详细讨论这一点。
- en: The web client and the web server agree on an encryption key.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端和服务器商定一个加密密钥。
- en: The web client and the web server will encrypt their communication using the
    encryption key they agreed on.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端和服务器将使用他们商定的加密密钥加密他们的通信。
- en: Establishing trust between the client and the server
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端和服务器之间建立信任
- en: The certificates and private keys we mentioned in *step 1* of the *Certificates
    and private keys *section are an entirely different matter. To understand them,
    you first have to understand the concept of public key encryption or asymmetric
    cryptography.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *证书和私钥* 部分的 *步骤 1* 中提到的证书和私钥是另一回事。要理解它们，你首先必须理解公钥加密或非对称加密的概念。
- en: A **public key** is used to encrypt data, and it can be shared safely with other
    parties. However, the public key can't decrypt data. A different key is required
    to decrypt the data. This key is known as the **private key**, and it must not
    be shared. The public key can be used by any person to encrypt data. However,
    only the person with the private key that corresponds to the public key can decrypt
    the data back to its original human-readable form. The public and private keys
    are generated using complex computational algorithms. Utilizing a combination
    of public and private keys is known as asymmetrical cryptography.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**公钥**用于加密数据，并且可以安全地与其他方共享。然而，公钥不能解密数据。需要不同的密钥来解密数据。这个密钥被称为**私钥**，并且不能共享。任何人都可以使用公钥加密数据。然而，只有拥有与公钥相对应的私钥的人才能将数据解密回原始的可读形式。公钥和私钥是使用复杂的计算算法生成的。利用公钥和私钥的组合被称为非对称加密。'
- en: In *step 1 *of the *Certificates and private keys *section, asymmetrical cryptography
    is utilized between a web client and web server to agree on a shared encryption
    key (also known as a shared secret or session key), which is then used in symmetrical
    cryptography (*steps 2* and 3). A handshake occurs between the web client and
    web server, where the client indicates its intent to start a secure communication
    session with the server. Typically, this entails agreeing on some mathematical
    details on how the encryption occurs. The server then replies with a *digital
    certificate*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在“证书和私钥”部分的*步骤1*中，在Web客户端和Web服务器之间使用非对称加密来协商一个共享的加密密钥（也称为共享秘密或会话密钥），然后用于对称加密（*步骤2*和*步骤3）。Web客户端和Web服务器之间发生握手，客户端表明其意图与服务器开始一个安全的通信会话。通常，这包括就加密方式的一些数学细节达成一致。然后服务器回复一个*数字证书*。
- en: A digital certificate (or a public key certificate) is an electronic document
    that proves the ownership of a public key.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 数字证书（或公钥证书）是证明公钥所有权的电子文档。
- en: A digital certificate is a digital document that gets issued by a trusted third-party
    entity. The document contains a public encryption key, the server name that the
    key belongs to, and the name of the trusted third-party entity, who verifies that
    the information is correct and that the public key belongs to the expected key
    owner (also called the issuer of the certificate).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 数字证书是由可信第三方实体签发的数字文档。文档包含一个公钥加密密钥、密钥所属的服务器名称以及验证信息正确性和公钥属于预期的密钥所有者（也称为证书的签发者）的可信第三方实体名称。
- en: The trusted third-party entity that issues the certificate is known as a **certificate
    authority** (**CA**). There are multiple known CAs who issue a certificate and
    verify identities for businesses and organizations. Most CAs charge fees for their
    service; some are now free, such as Let's Encrypt ([https://letsencrypt.org/](https://letsencrypt.org/)).
    For larger organizations or government bodies, they issue their own certificates;
    this process is known as self-signing, and hence their certificates are known
    as **self-signed certificates**. Certificates can have expiry dates by which the
    certificates will need to be renewed; this is for extra protection in case the
    entity that owned the certificate in the past has changed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 发出证书的可信第三方实体被称为**证书颁发机构**（**CA**）。有多个已知的CA负责颁发证书并验证企业和组织的身份。大多数CA会对其服务收费；现在有一些是免费的，例如Let's
    Encrypt ([https://letsencrypt.org/](https://letsencrypt.org/))。对于较大的组织或政府机构，它们会颁发自己的证书；这个过程被称为自签名，因此它们的证书被称为**自签名证书**。证书可能有到期日期，届时证书需要更新；这是为了在之前拥有证书的实体发生变化时提供额外的保护。
- en: A web client typically contains a list of CAs that it knows of. So, when the
    client attempts to connect to a web server, the web server responds with a digital
    certificate. The web client looks for the issuer of the certificate and compares
    the issuer with the list of CAs that it knows of. If the web client knows and
    trusts the certificate issuer, then it will continue with the connection to that
    server and use the public key in the certificate. The public key that's obtained
    from the server will then be used to encrypt communications to securely negotiate
    a shared encryption key (or session key or shared secret) to then be used in symmetrical
    cryptography communications between the web client and web server.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络客户端通常包含它所知道的CA列表。因此，当客户端尝试连接到网络服务器时，网络服务器会响应一个数字证书。网络客户端会查找证书的发行者，并将发行者与它所知道的CA列表进行比较。如果网络客户端知道并信任证书发行者，那么它将继续与该服务器建立连接，并使用证书中的公钥。从服务器获得的公钥然后将被用来加密通信，以安全地协商一个共享的加密密钥（或会话密钥或共享密钥），然后用于网络客户端和网络服务器之间的对称加密通信。
- en: There are a number of algorithms that can be used to generate this session key,
    but they are beyond the scope of this chapter. What we need to know is that, once
    a session key is agreed on, the initial handshake between the web client and web
    server will conclude, allowing the actual communication session to proceed securely
    under the protection of the shared session key.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种算法可以用来生成这个会话密钥，但它们超出了本章的范围。我们需要知道的是，一旦会话密钥达成一致，网络客户端和服务器之间的初始握手将结束，从而允许在共享会话密钥的保护下安全地进行实际的通信会话。
- en: For our web server to support HTTPS, it needs a certificate and a private key
    to establish the initial HTTPS handshake, as outlined in *step 1 *of the* Certificates
    and private keys *section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的网络服务器支持HTTPS，它需要一个证书和一个私钥来建立初始的HTTPS握手，正如*证书和私钥*部分中*步骤 1*所述。
- en: Agreeing on, and using an encryption key
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 达成一致并使用加密密钥
- en: An encryption key is a piece of code that relies on some complex math to encrypt
    a piece of data. Encrypting a piece of data simply means taking a piece of data
    in human-readable form and then transforming it into a form that is not readable
    by humans, and hence protects your data. Another key is then required to decrypt
    this unreadable data back to a human-readable form.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 加密密钥是一段代码，它依赖于一些复杂的数学来加密数据。加密数据简单来说就是将人类可读的数据转换成人类无法阅读的形式，从而保护你的数据。然后还需要另一个密钥来将这个不可读的数据转换回人类可读的形式。
- en: The type of encryption key used in *steps 2* and *3* in the preceding section
    is sometimes known as a **symmetric cipher**. This simply means that the same
    key is utilized by both the client and the server to encrypt and decrypt data
    between them. This is also known as **symmetrical cryptography**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中的*步骤 2*和*步骤 3*中使用的加密密钥有时被称为**对称加密算法**。这仅仅意味着客户端和服务器使用相同的密钥来加密和解密它们之间的数据。这也被称为**对称加密**。
- en: Most of the time, this key will be invisible to you during development.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，这个密钥在开发过程中对你来说是不可见的。
- en: In the next section we will take a look at how to support HTTPS in Gin.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在Gin中支持HTTPS。
- en: Supporting HTTPS in Gin
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Gin中支持HTTPS
- en: 'In the previous section, we obtained some valuable knowledge about how HTTPS
    actually works. But how do we support it in our code? It''s actually fairly simple.
    In the previous chapter, we utilized the following piece of code to establish
    an HTTP web server that''s empowered by Gin:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们获得了一些关于HTTPS实际工作原理的有价值知识。但我们如何在代码中支持它呢？实际上相当简单。在上一章中，我们使用了以下代码片段来建立一个由Gin支持的HTTP网络服务器：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need to apply a single change in the preceding code to support HTTPS instead
    of HTTP. Here, we are going to use a method called `RunTLS()`. This method needs
    three main arguments:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在之前的代码中进行一个更改以支持HTTPS而不是HTTP。在这里，我们将使用一个名为`RunTLS()`的方法。这个方法需要三个主要参数：
- en: The HTTPS address that we would like our backend web service to listen to
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望我们的后端网络服务监听的HTTPS地址
- en: The certificate file (covered in the previous section)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （上一节中提到的）证书文件
- en: The private key file (covered in the previous section)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （上一节中提到的）私钥文件
- en: 'Here is what the code would look like:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的示例：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: But how do we generate a certificate file and a private key? Obviously, if this
    is a learning or a weekend project, we wouldn't need to obtain a fully legitimate
    certificate from a CA.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何生成一个证书文件和私钥？显然，如果这是一个学习项目或周末项目，我们就不需要从CA获取一个完全合法的证书。
- en: In this case, we use what is known as a self-signed certificate. When you use
    such a certificate, it obviously won't be trusted by your web browser, because
    the certificate won't belong to the list of well-known CAs. For testing purposes,
    you will either need to configure your browser to trust the certificate or just
    ignore the warning and proceed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用所谓的自签名证书。当你使用这样的证书时，显然你的网络浏览器不会信任它，因为证书不会属于知名CA列表。出于测试目的，你可能需要配置你的浏览器以信任该证书，或者只是忽略警告并继续。
- en: But how do we generate a self-signed certificate?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何生成一个自签名证书呢？
- en: There are multiple ways to do this. Most people rely on the OpenSSL ([https://www.openssl.org/](https://www.openssl.org/))
    tool to generate test self-signed certificates. However, because we are using
    Go, we can make use of a tool that's provided by the Go language in the standard
    library instead.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以做到这一点。大多数人依赖于OpenSSL ([https://www.openssl.org/](https://www.openssl.org/))
    工具来生成测试自签名证书。然而，因为我们使用Go，我们可以利用Go语言标准库中提供的一个工具。
- en: 'In your project folder, simply run the following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目文件夹中，只需运行以下命令：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a simple tool that's provided by Go in the `tls` package folder. You
    can use it to generate certificates. Here, `%GOROOT%` represents your Go root
    environmental variable. If you were to run this command in Linux, you would need
    to use `$GOROOT` instead.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Go在`tls`包文件夹中提供的简单工具。你可以使用它来生成证书。在这里，`%GOROOT%`代表你的Go根环境变量。如果你在Linux上运行此命令，你需要使用`$GOROOT`代替。
- en: 'The preceding command will generate a certificate for the `127.0.0.1` host
    (the loopback localhost). This tool has more flags/options that you can configure,
    such as the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将为`127.0.0.1`主机（环回本地主机）生成一个证书。这个工具有更多的标志/选项，你可以进行配置，例如以下内容：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The command will generate the certificate and the private key files and will
    place them in your current folder. You can then copy them wherever you would like
    and just reference them from your code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将生成证书和私钥文件，并将它们放置在你的当前文件夹中。然后你可以将它们复制到任何你想要的地方，并在你的代码中引用它们。
- en: 'To get your React application to support HTTPS mode while testing, you will
    need to run the following command when you start your React application:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要在测试时让你的React应用程序支持HTTPS模式，你需要在启动React应用程序时运行以下命令：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's take a look at Password hashing in the next section.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看密码散列。
- en: Password hashing
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码散列
- en: Another very important security measure is known as password hashing. Password
    hashing is an approach that's used to protect the passwords of user accounts that
    are handled by our application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的安全措施被称为密码散列。密码散列是一种用于保护我们应用程序处理的用户账户密码的方法。
- en: Let's take our GoMusic application as an example—we have a `customers` table,
    which hosts customer's usernames and passwords. So, should we store a customer's
    passwords in plain text? The answer is a loud and resounding *no*!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的GoMusic应用程序为例——我们有一个`customers`表，其中包含客户的用户名和密码。那么，我们应该将客户的密码以纯文本形式存储吗？答案是响亮而坚定的*不*！
- en: 'What do we do instead? How do we protect our customers'' passwords and, at
    the same time, verify their passwords when they log in? This is where password
    hashing comes into the picture. It consists of two simple steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该怎么做呢？我们如何保护客户的密码，同时在用户登录时验证他们的密码？这就是密码散列发挥作用的地方。它包括两个简单的步骤：
- en: When saving a new customer password, hash the password and then save the hash.
    Hashing can simply be defined as one-way encryption—you can encrypt the password,
    but you can never decrypt it back. Hashing functions rely on complex math to achieve
    that.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当保存新客户的密码时，对密码进行散列然后保存散列。散列可以简单地定义为单向加密——你可以加密密码，但永远无法解密它。散列函数依赖于复杂的数学来实现这一点。
- en: When it's time to verify an existing customer's password, hash the password
    provided in the sign-in request, then compare the hash of the new incoming password
    with the saved hash of the original password.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当需要验证现有客户的密码时，对登录请求中提供的密码进行散列，然后将新传入密码的散列与原始密码保存的散列进行比较。
- en: Password hashing protect your customers' passwords because it ensures that no
    malicious hacker would be able to access them, even if they hack into your database.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希可以保护客户的密码，因为它确保即使恶意黑客入侵您的数据库，也无法访问它们。
- en: But what about protecting the password while it's en route from the web client
    to our web server? This is where HTTPS comes in. The password that's sent from
    the client will be fully encrypted until it reaches our backend web server.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在密码从网络客户端传输到我们的网络服务器的过程中如何保护密码呢？这就是 HTTPS 发挥作用的地方。从客户端发送的密码将在到达我们的后端网络服务器之前完全加密。
- en: 'Now, let''s start implementing some password hashing in our code. The first
    step is to go to our database layer and implement the logic to:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始在我们的代码中实现一些密码哈希。第一步是进入我们的数据库层并实现以下逻辑：
- en: Hash new user's passwords before saving it to the database
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将新用户的密码保存到数据库之前进行哈希处理
- en: When an existing user signs in, compare the provided password with the saved
    hashed password
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当现有用户登录时，比较提供的密码与保存的哈希密码
- en: In the next sections we will take a look at how to implement password hashing
    and verifying incoming passwords
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨如何实现密码哈希和验证传入的密码。
- en: Implementing password hashing
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现密码哈希
- en: 'In our database layer, we will define a new type for invalid password errors.
    In our `dblayer.go` file, we will add the following line:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据库层中，我们将为无效密码错误定义一个新的类型。在我们的 `dblayer.go` 文件中，我们将添加以下行：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, in our `orm.go` file, we''ll add the following function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的 `orm.go` 文件中，我们将添加以下函数：
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding code makes use of a package called `bcrypt`, which is very popular
    when it comes to hashing passwords. `bcrypt` stands for a popular password hashing
    function that was designed in the late 1990s. `bcrypt` is the default password
    hashing function in the OpenBSD operating system, and it enjoys support in numerous
    programming languages.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了名为 `bcrypt` 的包，这在密码哈希方面非常受欢迎。`bcrypt` 代表一个在1990年代末设计的流行密码哈希函数。`bcrypt`
    是 OpenBSD 操作系统的默认密码哈希函数，并在多种编程语言中得到支持。
- en: The package also provides methods to compare hashed passwords with their human-readable
    counterparts.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该包还提供了比较哈希密码与其可读版本的方法。
- en: 'If the package is not yet installed in your environment, run the following
    command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该包尚未安装到您的环境中，请运行以下命令：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We already came across the `hashPassword()` method in the `AddUser()` method,
    which will hash the password and then save it to the database.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `AddUser()` 方法中遇到了 `hashPassword()` 方法，它将哈希密码并将其保存到数据库中。
- en: 'Add the following `HashPassword ()` method to your code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 `HashPassword ()` 方法添加到您的代码中：
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code will perform the password hashing part. Before we return
    the customer object, we need to set the password to empty because this information
    doesn't need to be shared again for security purposes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将执行密码哈希部分。在我们返回客户对象之前，我们需要将密码设置为空，因为出于安全原因，此信息不需要再次共享。
- en: Comparing the password
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较密码
- en: Now, let's write the code that will compare the saved hashed passwords with
    passwords that are provided by users who are attempting to log in.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写将保存的哈希密码与尝试登录的用户提供的密码进行比较的代码。
- en: 'We just need another method from the `bcrypt` package to compare our saved
    hash with the incoming password:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要 `bcrypt` 包中的另一个方法来比较我们保存的哈希与传入的密码：
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we need to add code to the `SignInUser` method so that we can retrieve
    the hashed passwords of customers who are trying to sign in. Then, we can compare
    passwords. If the passwords don''t match, we return an error. If they do, we continue
    to log the user in by setting the logged-in flag to `true`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向 `SignInUser` 方法添加代码，以便我们可以检索尝试登录的客户的哈希密码。然后，我们可以比较密码。如果密码不匹配，我们返回一个错误。如果它们匹配，我们继续通过将登录标志设置为
    `true` 来记录用户的登录：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, there is a tiny change we need to add to our HTTP web handler to handle
    failed logins.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的 HTTP 网络处理程序中添加一个微小的更改来处理失败的登录。
- en: 'Let''s go back to the `handlers.go` file and edit the `SignIn` method a bit.
    The edited parts of the code are shown in bold:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `handlers.go` 文件并稍微编辑一下 `SignIn` 方法。代码的编辑部分以粗体显示：
- en: '[PRE41]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's take a look at credit card handling in the next section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的信用卡处理。
- en: Credit card handling
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信用卡处理
- en: We already implemented the credit card logic at the frontend in [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml),
    *Building a Frontend for GoMusic*. It's now time to implement the backend part
    of our credit card handling.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 5 章](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml) 中实现了前端信用卡逻辑，即构建 GoMusic
    的前端。现在是时候实现信用卡处理的后端部分了。
- en: For credit card processing at the frontend, we made use of the Stripe API ([https://stripe.com/docs/api](https://stripe.com/docs/api)).
    In a product environment, you would need to create an account with Stripe and
    obtain an API key to use for your application. For testing purposes, however,
    we can make use of testing API keys and test credit card numbers, which Stripe
    happily provides for developers to build productive apps that are capable of processing
    credit cards. To learn more about testing credit card numbers and testing tokens
    that are provided by Stripe, take a look at [https://stripe.com/docs/testing](https://stripe.com/docs/testing).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端信用卡处理，我们使用了 Stripe API ([https://stripe.com/docs/api](https://stripe.com/docs/api))。在产品环境中，您需要创建一个
    Stripe 账户并获取一个 API 密钥来用于您的应用程序。然而，出于测试目的，我们可以使用测试 API 密钥和测试信用卡号码，Stripe 高兴地为开发者提供这些，以便构建能够处理信用卡的生产力应用程序。要了解更多关于测试信用卡号码和
    Stripe 提供的测试令牌的信息，请查看 [https://stripe.com/docs/testing](https://stripe.com/docs/testing)。
- en: 'In our frontend code, we made use of the following Stripe API code to create
    a token:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的前端代码中，我们使用了以下 Stripe API 代码来创建一个令牌：
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We also made use of a very popular framework known as *Stripe elements*, which
    will collect all of our credit card information and then merge it with the create
    token request so that we get a token that represents the credit card that we are
    trying to process.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个非常流行的框架，称为 *Stripe elements*，它将收集我们所有的信用卡信息，并将其与创建令牌请求合并，以便我们得到一个代表我们试图处理的信用卡的令牌。
- en: We then send this token down to the backend so that it can be processed and/or
    saved.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将此令牌发送到后端，以便它可以进行处理和/或保存。
- en: 'To process credit card payments, there are some key pieces of information that
    we need:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理信用卡支付，我们需要一些关键信息：
- en: The credit card token that's provided by the Stripe API
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Stripe API 提供的信用卡令牌
- en: The ID of the customer making the purchase
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行购买的客户 ID
- en: The ID of the product the customer is trying to buy
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户试图购买的产品 ID
- en: The selling price of the product
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品售价
- en: Whether the card should be remembered for future use
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应该记住卡片以供将来使用
- en: Whether to use a pre-saved card or not
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否使用预存卡片
- en: 'I changed the frontend code so that it can collect this information and pass
    it to the HTTP request that''s bound to our backend. Here''s the part of the frontend
    code that will create and submit our request. The following code is in the `creditcards.js`
    file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我修改了前端代码，使其能够收集这些信息并将其传递给绑定到我们后端的 HTTP 请求。以下是前端代码中创建和提交我们请求的部分。以下代码位于 `creditcards.js`
    文件中：
- en: '[PRE43]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding code makes use of the `fetch()` method in order to send a `POST`
    request to the backend. The `POST` request will contain a JSON message which will
    host all the data that our backend needs to process the request.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了 `fetch()` 方法来向后端发送 `POST` 请求。该 `POST` 请求将包含一个 JSON 消息，其中包含我们后端需要处理请求的所有数据。
- en: In the next section we'll take a look at how the backend of credit card handling
    works.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨信用卡处理的后端是如何工作的。
- en: Credit card handling at the backend
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端信用卡处理
- en: 'We can use the Stripe API to process credit card transactions as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Stripe API 按以下方式处理信用卡交易：
- en: Create an object of the `*stripe.CustomerParams` type, which can then take the
    credit card token that's provided by the frontend. The credit card token is ingested
    using a method called `SetToken()`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `*stripe.CustomerParams` 类型的对象，然后它可以接受前端提供的信用卡令牌。信用卡令牌是通过名为 `SetToken()`
    的方法摄取的。
- en: Create an object of the `*stripe.Customer` type, which takes the object of the `stripe.CustomerParams` type
    as input. This is done through the `customer.New()` function.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `*stripe.Customer` 类型的对象，它将 `stripe.CustomerParams` 类型的对象作为输入。这是通过 `customer.New()`
    函数完成的。
- en: Create an object of the `*stripe.ChargeParams` type, which takes information
    about our transaction, such as the amount, the currency, and the description of
    the purchase.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `*stripe.ChargeParams` 类型的对象，它包含有关我们交易的信息，例如金额、货币和购买描述。
- en: The `*stripe.ChargeParams` object must also receive a field, which represents
    the Stripe customer ID. This is provided by the `*stripe.Customer` object we covered
    in *step 2*.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*stripe.ChargeParams` 对象还必须接收一个字段，该字段代表 Stripe 客户端 ID。这由我们在 *步骤 2* 中提到的 `*stripe.Customer`
    对象提供。'
- en: Remember that the Stripe customer ID is different to the actual customer ID
    that references the customer in our database.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Stripe 客户端 ID 与我们数据库中引用客户的实际客户 ID 是不同的。
- en: If we would like to save this credit card and use it later, we can simply store
    the Stripe customer ID string for later use.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想保存这张信用卡并在以后使用，我们可以简单地存储 Stripe 客户端 ID 字符串以供以后使用。
- en: Finally, we can charge the credit card by calling `charge.New()`, which takes
    the `*stripe.ChargeParams` object as an input.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过调用 `charge.New()` 来对信用卡进行扣款，该函数需要一个 `*stripe.ChargeParams` 对象作为输入。
- en: If the preceding steps sound too difficult to follow, don't worry. Once we start
    looking at the code, it will become clearer.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的步骤听起来太难理解，不要担心。一旦我们开始查看代码，它就会变得清晰起来。
- en: 'Most of our code will live inside the `charge` handler method, which is inside
    the `handler.go` file. Here is the current state of the method:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分代码将位于 `charge` 处理方法中，该方法位于 `handler.go` 文件内。以下是该方法的当前状态：
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The method doesn''t do anything yet. Here is what we need it to do:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法目前还没有做任何事情。这是我们希望它执行的操作：
- en: Obtain the transaction information using the incoming HTTP request.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用传入的 HTTP 请求获取交易信息。
- en: If the request requires that we use an existing saved card, then we need to
    retrieve the saved customer Stripe ID and charge the card.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求要求我们使用现有的已保存卡，那么我们需要检索保存的客户 Stripe ID 并对卡进行扣款。
- en: If the request requires that we remember the currently provided credit card
    information, then we save it to the database before we charge the card.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求要求我们在扣款之前记住当前提供的信用卡信息，那么我们将在扣款之前将其保存到数据库中。
- en: 'First, we need to create a type that can accept the data we are receiving from
    the frontend. Here is what this looks like:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个类型，它可以接受我们从前端接收到的数据。下面是这个类型的示例：
- en: '[PRE45]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding code, we declared the Go struct and initialized it in the same
    piece of code. This is a quick way to create and use `struct` types on the fly
    in Go.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了 Go 结构体并在同一代码块中初始化它。这是在 Go 中快速创建和使用 `struct` 类型的快捷方式。
- en: 'Next, we need to parse the incoming JSON payload into the `request` variable:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将传入的 JSON 有效负载解析到 `request` 变量中：
- en: '[PRE46]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, it''s time to start writing some Stripe code. The first thing we need
    to do is declare the stripe API key—we''ll just use a test API key in this case.
    However, in a production environment, you''ll need to use your own Stripe key
    and protect it very well:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始编写一些 Stripe 代码了。首先，我们需要声明 stripe API 密钥——在这种情况下，我们将使用一个测试 API 密钥。然而，在生产环境中，您需要使用自己的
    Stripe 密钥，并且要非常小心地保护它：
- en: '[PRE47]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we need to create a `*stripe.ChargeParams` object, which we covered in
    *step 3* at the beginning of this section. Here is what it looks like:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个 `*stripe.ChargeParams` 对象，我们在本节开头 *步骤 3* 中已经介绍过。下面是这个对象的示例：
- en: '[PRE48]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we initialize the stripe customer ID string. This is the important field,
    which was covered in *step 4* at the beginning of this section:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化 Stripe 客户端 ID 字符串。这是本节开头 *步骤 4* 中提到的关键字段：
- en: '[PRE49]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, if the incoming request expects us to use an existing card, we would retrieve
    the saved Stripe customer ID from the database and then use it. The following
    code uses a new database method that retrieves the Stripe customer ID from the
    database. We will implement this method later in this section:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果传入的请求要求我们使用现有的卡，我们将从数据库中检索保存的 Stripe 客户端 ID 并使用它。以下代码使用了一个新的数据库方法，该方法从数据库中检索
    Stripe 客户端 ID。我们将在本节的后面实现此方法：
- en: '[PRE50]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Otherwise, we can create a `*stripe.CustomerParams` object, which is used to
    create a `*stripe.Customer` object. This provides us with the Stripe customer
    ID:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们可以创建一个 `*stripe.CustomerParams` 对象，该对象用于创建 `*stripe.Customer` 对象。这为我们提供了
    Stripe 客户端 ID：
- en: '[PRE51]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we are asked to remember the card, we simply store the Stripe customer ID
    in the database:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要求我们记住这张卡，我们只需将 Stripe 客户端 ID 存储到数据库中：
- en: '[PRE52]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we attempt to charge the credit card:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试对信用卡进行扣款：
- en: '[PRE53]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we add the order to our database:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将订单添加到我们的数据库中：
- en: '[PRE54]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: And that's it for the `charge()` method.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，`charge()` 方法就完成了。
- en: 'There is still some work remaining. The newly added code to the `charge()`
    handler made use of several database methods, which we have not created yet:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还有一些工作要做。添加到 `charge()` 处理器的代码使用了几个我们尚未创建的数据库方法：
- en: '`GetCreditCardCID()`: Retrieves a saved Stripe customer ID from the database'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCreditCardCID()`: 从数据库检索保存的Stripe客户ID'
- en: '`SaveCreditCardForCustomer()`: Saves the stripe customer ID to our database'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SaveCreditCardForCustomer()`: 将stripe客户ID保存到我们的数据库'
- en: '`AddOrder()`: Adds an order to the database'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddOrder()`: 向数据库添加订单'
- en: 'We need to add these three methods to the database layer interface in our `dblayer.go`
    file:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的`dblayer.go`文件中数据库层接口中添加这三个方法：
- en: '[PRE55]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We add the three methods to our concrete implementation of the `DBLayer` interface.
    This is done in the `orm.go` file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将三个方法添加到我们`DBLayer`接口的具体实现中。这是在`orm.go`文件中完成的：
- en: '[PRE56]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We now need to go back to our `handler.go` file, and modify our `handler` constructor,
    such that it can connect to our database:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要回到我们的`handler.go`文件，并修改我们的`handler`构造函数，使其能够连接到我们的数据库：
- en: '[PRE57]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Perfect! And with that, the backend code for our GoMusic app is 99% complete,
    let's revisit our frontend code in the next section.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！有了这个，我们的GoMusic应用程序的后端代码已经完成了99%，让我们在下一节中重新审视我们的前端代码。
- en: Revisiting the frontend code
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视前端代码
- en: The last deep dive we did in terms of the frontend code was in [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building
    a Frontend for GoMusic*. [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*, and [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building
    a Frontend for GoMusic*, served to build solid and practical foundational knowledge
    about how to construct a working React app, which can be used as the frontend
    to our backend Go application.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端代码方面，我们最后深入探讨的是[第5章](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml)，*为GoMusic构建前端*。[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，*使用React.js的前端*和[第5章](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml)，*为GoMusic构建前端*，旨在构建关于如何构建可工作的React应用程序的坚实和实用的基础知识，这可以用作我们后端Go应用程序的前端。
- en: These two chapters covered about 85% of GoMusic's frontend. However, they did
    not cover all of the JavaScript code that's needed to glue together the different
    React components that we built in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml),
    *Frontend with React.js, *and [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml),
    *Building a Frontend for GoMusic*. In this section, we will provide an overview
    of the overall frontend architectures and fill some of the gaps.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个章节涵盖了GoMusic前端大约85%的内容。然而，它们并没有涵盖所有必要的JavaScript代码，这些代码用于将我们在[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，*使用React.js的前端*和[第5章](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml)，*为GoMusic构建前端*中构建的不同React组件粘合在一起。在本节中，我们将概述整体前端架构，并填补一些空白。
- en: In the next section, we will take a look at the application structure of the
    frontend of our application.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看我们应用程序前端的应用结构。
- en: The app structure
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序结构
- en: 'Our frontend component is divided into the following files:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前端组件分为以下文件：
- en: '`index.js`: The entry point to our React application, which calls the `App`
    component.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.js`: 我们React应用程序的入口点，它调用`App`组件。'
- en: '`App.js`: The main component of our React application. It combines all of the
    other components to form our app. The `App` component hosted in the `App.js` file
    takes care of some important central tasks such as the signing in or the signing
    out of a user.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.js`: 我们React应用程序的主要组件。它将所有其他组件组合成我们的应用程序。在`App.js`文件中托管的`App`组件负责一些重要的中心任务，例如用户的登录或登出。'
- en: '`modalwindows.js`: This is responsible for all of the modal windows in our
    application. This includes the sign in, the new user registration, and the buy
    modal window.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modalwindows.js`: 这负责我们应用程序中的所有模态窗口。这包括登录、新用户注册和购买模态窗口。'
- en: '`Navigation.js`: This is responsible for the navigational menu in our React
    application, which is how we move from one screen to another.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Navigation.js`: 这负责我们React应用程序中的导航菜单，这是我们如何从一个屏幕移动到另一个屏幕的方式。'
- en: '`creditcards.js`: This is responsible for the frontend side processing of credit
    cards.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`creditcards.js`: 这负责处理信用卡的前端部分。'
- en: '`productcards.js`: This is responsible for showing the list of product cards.
    This includes normal product cards and promotions.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productcards.js`: 这负责显示产品卡片列表。这包括普通产品卡片和促销。'
- en: '`orders.js`: This shows a list of customer''s orders when a customer is signed
    in.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orders.js`: 当用户登录时，这显示客户订单列表。'
- en: '`about.js`: This shows the About page.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about.js`: 这显示关于页面。'
- en: We'll see how to interconnect our frontend and backend in the next section.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何将我们的前端和后端相互连接。
- en: Interactions between the frontend and the backend
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端和后端之间的交互
- en: In [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend with React.js*,
    we relied on a JSON file that contained some mock data to empower and run our
    frontend app without needing an actual working backend to be present. Now, we
    need to replace all of the code where we relied on the JSON sample data file and
    send full HTTP requests to the backend instead.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，*使用React.js的前端*中，我们依赖于包含一些模拟数据的JSON文件来授权和运行我们的前端应用程序，而无需实际工作的后端。现在，我们需要替换所有依赖于JSON样本数据文件的代码，并改为向后端发送完整的HTTP请求。
- en: 'For our React app to route the requests to our backend, we first need to add
    a field called `proxy` to the `package.json` file of our React application. The
    proxy field needs to point to the backend API address. In our case, the backend
    component of our application listens on local port `8000`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的React应用程序将请求路由到我们的后端，我们首先需要将一个名为`proxy`的字段添加到我们的React应用程序的`package.json`文件中。代理字段需要指向后端API地址。在我们的例子中，我们的应用程序的后端组件监听本地端口`8000`：
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `package.json` file will exist in the main folder of your React app. This
    file is used by `node` package managers to figure our global settings, scripts,
    and dependencies for your `node` app.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件将存在于你的React应用程序的主文件夹中。此文件由`node`包管理器用于确定你的`node`应用程序的全局设置、脚本和依赖项。'
- en: 'Whenever we send a request to the backend, we make use of the powerful `fetch()`
    method. This method can send HTTP requests to a relative URL. Here is an example
    of a request to fetch customer''s orders:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们向后端发送请求时，我们都会使用强大的`fetch()`方法。此方法可以向相对URL发送HTTP请求。以下是一个获取客户订单请求的示例：
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the next section we will explore how to make use of cookies in our application.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在我们的应用程序中使用Cookies。
- en: Using cookies
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cookies
- en: Since our application doesn't rely anymore on a global sample data file to answer
    important questions such as whether a user is currently signed in or not, what
    the user's information is, and so on. The frontend application now makes use of
    browser cookies for this. A simple definition for browser cookies is that they
    are small pieces of information that get stored in the user's device using the
    web browser. This information can then be simply retrieved from the cookie when
    needed.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序不再依赖于全局样本数据文件来回答诸如用户是否当前已登录等重要问题，以及用户信息是什么等问题，因此前端应用程序现在使用浏览器Cookies来完成这些。浏览器Cookies的简单定义是，它们是使用网络浏览器存储在用户设备上的小块信息。这些信息可以在需要时简单地从Cookies中检索。
- en: 'The frontend code makes use of cookies to easily save and retrieve the user''s
    information to populate different screens and React components that need this
    information. This is done using the `js-cookie` JavaScript package. This package
    can be installed with the following command:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 前端代码利用Cookies轻松保存和检索用户信息，以便填充需要这些信息的不同屏幕和React组件。这是通过使用`js-cookie` JavaScript包来实现的。可以使用以下命令安装此包：
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here is an example of setting a cookie:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个设置Cookies的示例：
- en: '[PRE61]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here is an example of retrieving data from a cookie:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Cookies中检索数据的示例：
- en: '[PRE62]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Cookies are used to also check whether a user is currently signed in or signed
    out. Sign out handling code has been added to the React application since the
    code we covered in [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building
    a Frontend for GoMusic*, to handle the change of state that occurs when a user
    signs out. When a user signs out, we remove the information of the existing user
    from the cookie and just retain the fact that no one is logged in. Here is the
    code to do this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies也用于检查用户是否当前已登录或已登出。自我们在[第5章](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml)，*为GoMusic构建前端*中覆盖的代码以来，已添加了处理用户登出时发生的状态变化的登出处理代码。当用户登出时，我们从Cookies中删除现有用户的信息，只保留没有人登录的事实。以下是执行此操作的代码：
- en: '[PRE63]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For more context on how we use cookies in our React application, and how to
    handle user sign out, have a look at the App react component of our application
    at:[ https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/blob/master/Chapter07/Frontend/src/App.js](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/blob/master/Chapter07/Frontend/src/App.js)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们如何在React应用程序中使用Cookies以及如何处理用户登出，请查看我们应用程序的App React组件：[https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/blob/master/Chapter07/Frontend/src/App.js](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/blob/master/Chapter07/Frontend/src/App.js)
- en: Now, let's explore how to deploy our frontend application to a production environment.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何将我们的前端应用程序部署到生产环境中。
- en: Deploying the frontend application
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署前端应用程序
- en: Once you are done with the frontend code, it will need to be transformed into
    a form that can be shared and copied to production server environments, without
    needing to reinstall all the Node.js tools and dependencies that were needed in
    the development process.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了前端代码，它需要转换成一个可以在不需要重新安装开发过程中所需的 Node.js 工具和依赖项的情况下共享和复制到生产服务器环境中的形式。
- en: The React framework comes to the rescue here. When we created our React application
    in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend with React.js*,
    and [Chapter 5](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml), *Building a Frontend
    for GoMusic*, we used a tool called `create-react-app` to create our application
    and set up the toolchain. The tool supports some scripts that we can use to run
    and build our React application. We already mentioned the `npm start` command,
    which was used to run our React app in development mode, so that we can run our
    code and debug in real time as we are developing the application.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [第 4 章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)、“使用 React.js 的前端”和
    [第 5 章](2047c922-b48b-4b36-afb5-a155031c60ea.xhtml)、“为 GoMusic 构建前端”中创建 React
    应用程序时，我们使用了一个名为 `create-react-app` 的工具来创建我们的应用程序并设置工具链。该工具支持一些我们可以用来运行和构建 React
    应用程序的脚本。我们之前已经提到了 `npm start` 命令，该命令用于以开发模式运行我们的 React 应用程序，这样我们就可以在开发应用程序的同时实时运行和调试我们的代码。
- en: There is a script that is vital for getting our React app ready for production
    use and is called `build`. To run this script, we simply type the `npm run build`
    command from the main folder of our React app. This command will compile our entire
    application to some static files, which we can then serve directly from our Go
    app. The output of the build script goes to a folder called `build`, which gets
    created in our React app root folder.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个对于使我们的 React 应用程序准备好生产使用至关重要的脚本，它被称为 `build`。要运行此脚本，我们只需从 React 应用程序的主文件夹中输入
    `npm run build` 命令。此命令将编译我们的整个应用程序到一些静态文件中，然后我们可以直接从我们的 Go 应用程序中提供这些文件。构建脚本的输出将进入一个名为
    `build` 的文件夹，该文件夹将创建在我们的 React 应用程序根文件夹中。
- en: Let's call this folder the React `build` folder. We can then copy this `build`
    folder anywhere and get our Go app to utilize it to serve the GoMusic app frontend.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个文件夹称为 React 的 `build` 文件夹。然后我们可以将这个 `build` 文件夹复制到任何地方，并让我们的 Go 应用程序利用它来提供
    GoMusic 应用程序的前端。
- en: Here are the steps that we need to follow in our Go code to be able to serve
    the React output `build` folder.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要在我们的 Go 代码中遵循的步骤，以便能够提供 React 输出 `build` 文件夹。
- en: 'First, we need to import a Gin middleware called `static`, which we can do by
    executing the following command:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入一个名为 `static` 的 Gin 中间件，我们可以通过执行以下命令来完成：
- en: '[PRE64]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We will need to go to our `rest.go` file, which hosted our HTTP route definitions.
    This file can be found in `backend\src\rest.go`. Inside `rest.go`, we will import
    the Gin static middleware:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进入我们的 `rest.go` 文件，该文件托管了我们的 HTTP 路由定义。这个文件可以在 `backend\src\rest.go` 中找到。在
    `rest.go` 内部，我们将导入 Gin 静态中间件：
- en: '[PRE65]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Inside the `RunAPIWithHandler` function, which includes all of our HTTP route
    definitions, we will replace the code that''s used to serve our `img` folder with
    code that serves all static files from the `build` folder that was generated by
    the React app. Here is what this will look like:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含所有 HTTP 路由定义的 `RunAPIWithHandler` 函数内部，我们将用从 React 应用程序生成的 `build` 文件夹中提供所有静态文件的代码替换用于提供我们的
    `img` 文件夹的代码。这将看起来像这样：
- en: '[PRE66]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The first argument of the `static.ServeRoot()` function is the relative HTTP
    root URL for our web application, while the second argument is basically the location
    of the React build folder.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`static.ServeRoot()` 函数的第一个参数是我们 Web 应用程序的相对 HTTP 根 URL，而第二个参数基本上是 React 构建文件夹的位置。'
- en: We will also need to move the `img` folder, which included all of the images
    of our musical instruments, so that it is inside the `build` folder. Now, the
    `build` folder has all of the assets for our web application.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将包含我们所有乐器图片的 `img` 文件夹移动到 `build` 文件夹内部。现在，`build` 文件夹包含了我们 Web 应用程序的所有资产。
- en: That's all we need to do. Now, we can just build our Go app into a single executable
    file by either using the `go build` or the `go install` command. Then, we can
    copy our executable web application along with the React build folder to wherever
    we would like to deploy our web application.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的全部。现在，我们可以通过使用 `go build` 或 `go install` 命令将我们的 Go 应用程序构建成一个单独的可执行文件。然后，我们可以将我们的可执行
    web 应用程序以及 React 构建文件夹复制到我们想要部署 web 应用程序的地方。
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered a lot of ground. In this chapter, we learned how to design
    and implement database layers for our backend services. We learned about the concept
    of web API middleware and how to make use of it. We also took a deep dive into
    some practical security concepts such as TLS and password hashing. We then learned
    how to process credit cards in our backend services through the powerful Stripe
    API. With this knowledge under your belt, you now have what it takes to build
    modern production web applications in Go.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。在本章中，我们学习了如何为我们的后端服务设计并实现数据库层。我们了解了网络 API 中间件的概念以及如何利用它。我们还深入探讨了诸如
    TLS 和密码散列等实际安全概念。然后，我们学习了如何通过强大的 Stripe API 在后端服务中处理信用卡。有了这些知识，你现在具备了构建现代生产级 Go
    网络应用程序的能力。
- en: In the next chapter, we will cover how to test our application by writing unit
    tests, and how to measure it's performance, by running benchmarks.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何通过编写单元测试来测试我们的应用程序，以及如何通过运行基准测试来衡量其性能。
- en: Questions
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is middleware?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件是什么？
- en: What is a Stripe customer ID?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Stripe 客户端 ID？
- en: What is an ORM?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是对象关系映射（ORM）？
- en: What is GORM?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 GORM？
- en: How can we write a join query using GORM?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用 GORM 编写连接查询？
- en: What is TLS?
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 TLS？
- en: What is meant by password hashing?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码散列的含义是什么？
- en: What is `bcrypt`?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `bcrypt`？
- en: Further reading
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Stripe API**: **[https://stripe.com/docs/api](https://stripe.com/docs/api)**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stripe API**：**[https://stripe.com/docs/api](https://stripe.com/docs/api)**'
- en: '**GORM**: [http://gorm.io/](http://gorm.io/)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GORM**：[http://gorm.io/](http://gorm.io/)'
- en: '**Package `bcrypt`**: [https://godoc.org/golang.org/x/crypto/bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包 `bcrypt`**：[https://godoc.org/golang.org/x/crypto/bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt)'
- en: '**Transport layer security: **[https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/)'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层安全性：**[https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/)'
