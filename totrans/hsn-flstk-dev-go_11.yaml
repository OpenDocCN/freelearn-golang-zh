- en: Testing and Benchmarking Your Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is of vital importance in production software environments. Applications
    not only need to be tested for functionality, but they also need to be benchmarked
    and profiled so that we can examine the performance of our applications. This
    chapter will provide a wide and practical exposure about how to properly test
    and benchmark your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking types in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found in this book's GitHub repository at [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the building blocks of the testing process in any piece of software is
    known as **unit testing**. Unit testing is a very popular concept in virtually
    any programming language, and there are numerous software frameworks and language
    extensions that allow you to perform unit testing as efficiently as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of unit testing is to test each unit or component of your software
    separately. A unit can simply be defined as the smallest testable piece of your
    software.
  prefs: []
  type: TYPE_NORMAL
- en: The Go language comes equipped with a testing package, as well as some Go commands
    to make the process of unit testing easier. The package can be found at [https://golang.org/pkg/testing/](https://golang.org/pkg/testing/).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll dive a bit deeper into how to build unit tests in the
    Go language. However, before we start writing unit tests in Go, we first need
    to cover the concept of mocking.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of mocking is very popular in the field of unit testing software.
    It''s best described via an example. Let''s say we would like to unit test one
    of the HTTP handler functions of the GoMusic application. The `GetProducts()`
    method is a good method to showcase our example, since the purpose of this method
    was to return a list of all of the products that are available for sale in our
    GoMusic store. Here is what the code for `GetProducts()` looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method simply retrieves all of the products from our database and then
    returns the results as a HTTP response. This method utilized the `h.db.GetAllProducts()`
    method to retrieve the data from our database.
  prefs: []
  type: TYPE_NORMAL
- en: So, when it's time to perform a unit test for `GetProducts()`, we should be
    able to test the functionality of the method without needing a real database.
    Furthermore, we should also be able to inject some error scenarios, where we make
    `h.db.GetAllProducts()` fail, and then ensure that `GetProducts()` reacts as expected.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering, why is it important to be able to test a method such
    as `GetProducts()` without needing a real database? The answer is simple—unit
    testing is only concerned with the unit you are currently testing, which is the
    `GetProducts()` method, not your database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Mock object types can be defined as object types that you can use to *mock*
    or fake a certain behavior. In other words, in the case of the `h.db.GetAllProducts()`
    method, instead of using an object type that connects to a real database, we can
    use a mock type that does not connect to a real database but can give us the results
    we need to perform the unit testing of the `GetProducts()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back down memory lane and remember how `h.db.GetAllProducts()` was
    built. The database part of this piece of code was simply an interface called
    `DBLayer`, which we used to describe all the behavior we would need from a database
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the `DBLayer` interface looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To create a mock type for our database layer, we just need to create a concrete
    type that will implement `DBLayer` but won't connect to a real database.
  prefs: []
  type: TYPE_NORMAL
- en: The mock object will need to return some simulated data, which we use for our
    testing. We can simply store this data in slices or maps inside our mock object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what mocking is, let's create our mock db type.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mock db type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside our `backend/src/dblayer` folder, let''s add a new file called `mockdblayer.go`.
    Inside this new file, let''s create a type called `MockDBLayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MockDBLayer` type hosts four types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`err`: This is an error type that we can set at will whenever we need to simulate
    an error scenario. We''ll look at how to use it when it''s time to write our unit
    tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`products`: This is where we store our mock list of products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customers`: This is where we store our mock list of customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orders`: This is where we store our mock list of orders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s write a constructor for our mock type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor takes three arguments: a list of `products`, a list of `customers`,
    and a list of `orders`. This gives other developers the opportunity to define
    their own data for testing, which is good for flexibility. However, other developers
    should be able to initialize the `MockDBLayer` type with some mock data pre-loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function has some data hardcoded inside it, which then gets fed
    to the `MockDBLayer` constructor. This allows developers to make use of the `MockDBLayer`
    type so that they can use it right away without first needing to come up with
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to offer methods to expose the data that''s being used by the
    `MockDBLayer` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a method that will allow us to be in full control of the errors
    that are returned by the methods of `MockDBLayer`. This is important because during
    our unit tests, it''s likely we''ll need to test how the code will behave if an
    error occurs. We''ll revisit this concept when we work on our unit test. For now,
    let''s write a method that allows us to set errors that are returned by our mock
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to implement the `DBLayer` interface methods. Let''s start
    with the `GetAllProducts()` method. This is what it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to check is whether the `MockDBLayer` type returns an
    error or not. If it needs to return an error, then we just return the error. Otherwise,
    we return the list of products we saved in our mock type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the `GetPromos()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first checked whether we should return an error, like
    we did previously. We then looped through the list of products and picked the
    products that have promotions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s explore the `GetProduct(id)` method. This method should be able
    to retrieve a product based on the `id` that''s provided. This is what it looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As with the other methods, we first need to check whether we need to return
    an error, and if so, we return the error and exit the method. Otherwise, we retrieve
    the piece of data that's being queried by this method. In the case of `GetProduct(id)`,
    we loop through the products list and then return the product with the requested
    `id`. This loop could have been replaced by a simple map retrieval if we were
    to store our products in a map instead of a list. In a production environment,
    you will need to decide how you would like your data to be represented in your
    mock objects (maps and/or slices). In this case, I decided to go with a slice
    for simplicity. In a more complex mock object, you might want to store data in
    slices for methods that return all the data, as well as in maps for methods that
    return specific items.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code for the mock object will continue to implement the `DBLayer`
    interface methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the method to get a customer by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the method to get a customer by their ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code to add a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code to sign in a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code to sign out a user by ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code to get customer orders by ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code to add an order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following methods are just place holders for the credit card handling
    logic. The unit tests that we''ll explore in this chapter won''t cover credit
    card handling, so to simplify things; let''s just leave them as place holders
    for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that there are some third-party open source projects
    in the Go language that can help with the creation and utilization of mock objects.
    However, in this chapter, we have built our own.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created a mock db type, let's cover unit testing in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to explore unit testing in Go and make use of the `MockDBLayer`
    type that we built in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The first step for writing unit tests in Go is to create a new file in the same
    folder as the package you would like to test. The filename has to end with `_test.go`.
    In our case, since we seek to test the `GetProducts()` method in the `rest` package,
    we'll create a new file in the same folder and call it `handler_test.go`.
  prefs: []
  type: TYPE_NORMAL
- en: This file will only build and execute when you run unit tests, but not during
    regular builds. You may be wondering, how would I run unit tests in Go? The answer
    is simple—you utilize the `go test` command! Whenever you run `go test`, only
    the files that end with `_test.go` will build and run.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running the `go test` command from a different folder than the folder
    of the package that you would like to test, then you can just point to the package
    that you would like to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we want to run the unit tests for our `rest` package, the command
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s dive further into the `handler_test.go` file. The first thing we
    need to do is declare the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to write a function that will represent our unit test. In Go,
    you need to follow some specific rules to ensure that your function gets executed
    as part of the unit testing that''s produced by the `go test` command:'
  prefs: []
  type: TYPE_NORMAL
- en: Your function has to start with the word `Test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first letter after `Test` has to be in upper case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function needs to take the `*testing.T` type as an argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `*testing.T` type provides some important methods that will help us signify
    whether a test has failed or passed. The type also provides some logging features
    that we can use. We'll see the `*testing.T` type in action shortly, when we start
    writing our test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, by following the preceding three rules, we''ll create a new function called `TestHandler_GetProducts` to
    host the unit testing code for the `GetProducts()` method in our HTTP handler. Here
    is what the function will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do is enable the test mode of the Gin framework.
    The testing mode of the Gin framework prevents too much logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s initialize our `mockdbLayer` type. We will use the constructor
    that included some hardcoded data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `GetProducts()` method we are seeking to test in this section is an HTTP
    handler function, which is expected to return a list of products that are available
    from the GoMusic store. As we covered in the previous chapters, an HTTP handler
    function can be defined as an action that gets executed when an HTTP request is
    sent to a specific relative URL. The HTTP handler will process the HTTP request
    and return a response via HTTP as well.
  prefs: []
  type: TYPE_NORMAL
- en: In our unit test, we'll need to test not only the functionality of `GetProducts()`
    as a method, but also how it reacts to HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to define the relative URL that will activate the HTTP handler
    function for that. Let''s call it `/products` and make it a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We'll see how we can make use of that constant in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we'll cover an important concept known as table-drive development.
  prefs: []
  type: TYPE_NORMAL
- en: Table-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a typical practical unit test, we seek to test a certain function or method
    to see how it will react to certain inputs and error conditions. This means that
    the code of the unit test would need to call the function or method we are trying
    to test multiple times, and with different inputs and error conditions. Instead
    of writing large interconnection `if` statements to make the calls with different
    inputs, we can instead follow a very popular design pattern known as **table-driven
    development**.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind test-driven development is simple—we will use an array of Go
    structs or a map to represent our tests. The struct array or map will contain
    information about the inputs and error conditions that we want to pass to the
    function/method being tested. We will then loop through the array of Go structs
    and call the method/function to be tested with the current inputs and error conditions.
    This approach will produce a number of sub-tests under the main unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our unit test, we''ll use an array of Go structs to represent our different
    subtests. Here is what the array will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call the preceding code our `test` table. Here is what the Go struct
    fields will represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is the name of the subtest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inErr`: This is the input error. We will inject this error into the mock db
    layer type and monitor how the `GetProducts()` method will behave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outStatusCode`: This is the expected HTTP status code that is produced from
    calling the `GetProducts()` HTTP handler. If the HTTP status code that''s returned
    from calling `GetProducts()` as an HTTP handler does not match this value, then
    the unit test fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectedRespBody`: This is the expected HTTP response body that''s returned
    from calling the `GetProducts()` HTTP handler. If the returned HTTP body does
    not match this value, then the unit test fails. This field is of the `interface{}` type
    because it can either be a slice of products or an error message. The `interface{}`
    type in Go can represent any other data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The beauty of the table-driven testing design pattern is the fact that it's
    very flexible; you can simply add more fields to test more conditions.
  prefs: []
  type: TYPE_NORMAL
- en: There are two expected HTTP response bodies that can be produced from the `GetProducts()`
    HTTP handler—we either get some list of products, or we get an error message.
    The error message takes the following format: `{error:"the error message"}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start running our subtests from our test table, let''s define a `struct`
    type to represent the error message so that we can use it in our testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define our list of subtests. For simplicity, we''ll pick two
    different scenarios to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined two different subtests:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is called `getproductsnoerrors`. It represents a straight execution
    scenario where no errors occurred and everything worked fine. We inject no errors
    to the mock db layer type, so we expect no errors to return from the `GetProducts()`
    method. We expect an HTTP response status of `OK`, and we expect to get a list
    of the product data that's stored in mock db layer as the HTTP response body.
    The reason why we expect to get a list of the product data stored in the mock
    db layer as our output is because of the fact that the mock db type will be the
    database layer for our `GetProducts()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is called `getproductswitherror`. It represents an execution
    scenario where an error has occurred. We inject an error called `"get products
    error"` into the mock db layer type. This error will be expected to be returned
    as the HTTP response body of the `GetProducts()` handler function call. The HTTP
    status code that's expected will be `StatusInternalServerError`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder of our unit test code will loop through the test table and execute
    our tests. The `*testing.T` type, which got passed as an argument to our unit
    test function, provides methods that we can use to define subtests within our
    unit test, which we can then run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to define a subtest within our unit test, we must utilize the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument is the name of the subtest, whereas the second argument
    is a function that represents the subtest we would like to run. In our case, we''ll
    need to loop through our `test` table and call `t.Run()` for each subtest. Here
    is what this will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s focus on the code to run for our subtests. The first thing we need
    to do is inject an error into the mock type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a test HTTP request to represent the HTTP request which
    will be received by our `GetProducts()` HTTP handler. Again, Go comes to the rescue
    with a standard package called `httptest`. This package empowers you to create
    special data types that allow you to test HTTP-related functionality. One of the
    functions provided by `httptest` is a function called `NewRequest()`, which returns
    an HTTP request type that we can use for our testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The function takes three arguments: the type of HTTP method, the relative URL
    where the HTTP request is expected to get sent, and the body of the request, if
    any.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the `GetProducts()` HTTP `handler` method, it's expecting an
    HTTP `GET` request that targets the `/products` relative URL. We have already
    stored the `/products` value in the `productsURL` constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `httptest` package also provides a data type called `ResponseRecorder`,
    which can be used to capture the HTTP response of an HTTP handler function call.
    The `ResponseRecorder` data type implements Go''s `http.ResponseWriter` interface,
    which enables the `ResponseRecorder` to be injected in any code that makes use
    of `http.ResponseWriter`. We''ll need to obtain a value of this data type so that
    we can use it in our testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to create an instance of the Gin framework engine to use
    it in our test. This is because the `GetProducts()` method that we are trying
    to test is an HTTP handler function for a Gin engine router, so it needs a `*gin.Context`
    type as its input. Here is what the function signature looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, the Gin framework comes prepared with a function called `CreateTestContext()`
    for the exact purpose of creating an instance of a Gin context and an instance
    of a Gin engine to use for testing. The `CreateTestContext()` function takes an
    `http.ResponseWriter` interface as input, which means that we can pass our `httptest.ResponseRecorder`
    as the input, since it implements the `http.ResponseWriter` interface as input.
    Here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned earlier, the `CreateTestContext()` function returns two values:
    a Gin context instance and a Gin engine instance. In our case, we will not make
    use of the Gin context instance, which is why we didn''t receive the value for
    it in the preceding code. The reason why we won''t make use of the Gin context
    instance is because I prefer to use the Gin engine instance for my testing, as
    it allows me to test the full workflow of an HTTP request being served.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll make use of the Gin engine instance to map our `GetProducts()`
    method to the `productsURL` relative URL address via an HTTP `GET` request. Here
    is what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to get our Gin engine to serve the HTTP request, and then pass
    the HTTP response to our `ResponseRecorder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will, in effect, send our test HTTP request to the `GetProducts()` handler
    method, since the test request targets `productsURL`. The `GetProducts()` handler
    method will then process the request and send an HTTP response via `w`, which
    is our `ResponseRecorder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to test how `GetProducts()` processed the HTTP request. The
    first thing we need to do is extract the HTTP response from `w`. This is done
    via the `Result()` method in the `ResponseRecorder` object type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to test the HTTP status code of the result. If it''s not equal
    to the expected HTTP status code, then we fail the test case and we log why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the `*testing.T` type comes equipped with a
    method called `Errorf`, which can be used to log a message and then fail the test.
    If we wanted to log a message without failing the test, we can use a method called
    `Logf`. If we want to fail a test right away, we can call a method called `Fail`.
    The `t.Errorf` method is the combination of `t.Logf`, followed by `t.Fail`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to capture the HTTP body of the response so that we''re able
    to compare it to the expected HTTP response body for this subtest. There are two
    scenarios to consider: either an error was injected into our subtest, which means
    an error message is expected as the result, or there was no error injected, which
    means a list of products is the expected HTTP response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is compare the expected HTTP response body with
    the actual HTTP response body that we received. To do the comparison, we need
    to make use of a very handy function that is present in Go''s `reflect` package.
    This function is called `reflect.DeepEqual()`, and it helps us to fully compare
    two values and identify whether they are clones of each other. If the two values
    are not equal, then we log an error and fail the test. Here is what the code will
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, our unit test is completed! Let''s have a look at what the overall
    testing code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s worth mentioning that Go gives you the power to run your subtests in
    parallel to each other. You can invoke this behavior by calling `t.Parallel()`
    inside your subtests. Here is what this will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: However, when you run concurrent subtests, you must make sure that any data
    types they share won't change state or behavior in parallel, otherwise your test
    results will not be reliable. For example, in our code, we use a single mock db
    layer type object, which was initialized outside of the subtests. This means that
    whenever we change the error state of the mock db layer inside a subtest, it might
    have affected other subtests running in parallel and made use of the mock db layer
    object at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'What remains in this section is to run our unit test and witness the results.
    As we mentioned earlier, you can either run the `go test` command from inside
    the folder that hosts the package you seek to test, or you can use the `go test
    <your_package_path>` command from outside your package folder. If the unit test
    passes, you will see an output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The default output shows you the full name of the package that was tested and
    the time it took to run the test(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see more information, you can run `go test -v`. This is what
    this command will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `-v` flag shows verbose output—it will show you the name of the unit test
    being run, as well as the names of the subtests within the unit test as they run.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at benchmarking in the next section
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another key topic in the world of testing software is benchmarking. **Benchmarking**
    is the practice of measuring the performance of your code. The Go `testing` package
    offers you the ability to perform strong benchmarking on your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by targeting a piece of code and showcase how to benchmark it
    using Go. A good function to benchmark is the `hashpassword()` function, which
    is utilized by our database layer. This function can be found in the `backend/src/dblayer/orm.go`
    file. It takes a reference to a string as an argument, and then it uses a `bcrypt`
    hash to hash the string. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Let's say that we would like to test the performance of this function. How do
    we begin?
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a new file. The filename should end with `_test.go`.
    The file needs to exist in the same folder as the `dblayer` package, which hosts
    the function we seek to test. Let's call the file `orm_test.go`.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, files whose names end with `_test.go` will not be part
    of the regular build process. Instead, they activate when we run tests via the
    `go test` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside the file, we''ll start by declaring the Go package that the file
    belongs to, which is `dblayer`. Then, we need to import the testing package that
    we will use in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to write the code to benchmark the `hashpassword()` function.
    To write benchmark functions in Go, we need to follow these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The function name has to start with the word `Benchmark`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first letter after the word `Benchmark` needs to be in upper case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function takes `*testing.B` as an argument. The `*testing.B` type provides
    methods that facilitate benchmarking our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we follow those three rules, we''ll build our benchmark function with the
    following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll initialize a string to be hashed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To utilize an object of type `*testing.B` to benchmark a piece of code, we
    need to run the targeted piece of code `b.N` times. `N` is simply a field in the
    `*testing.B` type, which adjusts its value until the targeted code can be reliably
    measured. This is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will run `hashPassword()` as many times as it takes to benchmark
    it. To run the benchmark, we can use the `go test` command in combination with
    a `-bench` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-bench` flag needs to be provided as a regex expression to indicate the
    benchmark functions that we would like to run. If we would like to run everything
    that''s available, we can use `.` to indicate all. Otherwise, if we only want
    to run benchmarks that include the term `HashPassword`, we can modify the command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The output simply states that the `hashPassword` function was run 20 times,
    and that it had a speed of about 69,609,530 nanoseconds per loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we only initialized a string right before running our benchmark,
    which is a very straightforward and easy operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if your initialization is much more complex and takes some time to
    complete, it''s advised that you run `b.ResetTimer()` after you finish your initialization
    and before you perform your benchmarking. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*testing.B` type also comes with an extra method called `RunParallel()`,
    which can test performance in a parallel setting. This works in concert with a
    flag known as `go test -cpu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered a key skill that any software developer should have, which
    is proper software testing in production. We focused on the features that are
    offered by the Go language to enable the testing of Go code.
  prefs: []
  type: TYPE_NORMAL
- en: We started by covering how to build mock types and why they are important when
    it comes to software testing. We then covered how to perform unit testing in Go
    and how to benchmark your software.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore the concept of Isomorphic Go programming,
    by covering the GopherJS framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the definition of a mock type? Why is it useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the testing package in Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `*testing.T` type used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `*testing.B` type used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `*testing.T.Run()` method used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `*testing.T.Parallel()` method used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by benchmarking?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `*testing.B.ResetTimer()` method used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can go through the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Go testing package**: [https://golang.org/pkg/testing/](https://golang.org/pkg/testing/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
