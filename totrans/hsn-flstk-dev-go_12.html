<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to Isomorphic Go with GopherJS</h1>
                </header>
            
            <article>
                
<p>So far, we have covered how to write our frontend using JavaScript. However, if you prefer to use Go in the frontend, there is an option for that. This option is known as GopherJS, which is a popular Go package combined with a set of commands with only one purpose: to compile (also known as <strong>transpiling</strong>) Go code to JavaScript. Once Go code is compiled to JavaScript, the code could be utilized in the frontend component similarly to JavaScript. An application that relies on the same programming language for the frontend and the backend is known as an <strong>isomorphic application</strong>.</p>
<p>Like any other software-design approach, writing isomorphic applications has its own pros and cons. The chief advantage is the convenience and speed of development that comes with using a single programming language that you are really good at for most of your code. The main disadvantage is the difficulty of troubleshooting non-trivial issues, since you will have to dive into the generated JavaScript code. </p>
<p>This chapter is an introduction to isomorphic web development. We will cover some of the key building blocks of GopherJS, and how you can make use of it to write code that can interact with both web browsers and Node.js modules. We will also cover how to write a simple React application powered by GopherJS, and some open source projects.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>GopherJS fundamentals</li>
<li>GopherJS with React</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To follow along with this chapter, you will need the following tools:</p>
<ul>
<li>The Go language installed (<a href="https://golang.org/doc/install">https://golang.org/doc/install</a>)</li>
<li>Node.js and npm (<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>)</li>
<li>A code editor, such as VS Code (<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>)</li>
</ul>
<p>The chapter assumes familiarity with JavaScript, HTML, React, and Go.</p>
<p>If you are not yet familiar with React, please have a look at <a href="72d04e99-a5af-4af9-b51a-54c4c750871f.xhtml">Chapter 3</a>, <em>Go Concurrency,</em> and <a href="e875a3eb-c517-4246-8233-cc681f6c3356.xhtml"/><a href="e875a3eb-c517-4246-8233-cc681f6c3356.xhtml">Chapter 4</a>, <em>Frontend with React.js</em>.</p>
<p><span>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go">https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GopherJS fundamentals</h1>
                </header>
            
            <article>
                
<p class="mce-root">GopherJS is a set of tools, data types, and Go packages that allows you to compile Go code to JavaScript. Compiling the code of one programming language to another is also known as <strong>transpiling</strong>. GopherJS is very useful for Go developers who are not very proficient in JavaScript, because it allows you to write code in Go that can be integrated with JavaScript modules. This means that you can write code in Go that empowers the frontend of your application, or can be integrated with Node.js modules, offering you the flexibility of JavaScript combined with the power of Go.</p>
<p>GopherJS is a very a powerful piece of software that is used in numerous applications. However, in order to effectively utilize GopherJS, you need to understand its building blocks. The first step is to retrieve the package using the <kbd>go get</kbd> command:</p>
<pre><strong>go get -u github.com/gopherjs/gopherjs</strong></pre>
<p>Also, to be able to run some of GopherJS commands, we need to install the <kbd>source-map-support</kbd> node module:</p>
<pre><strong>npm install --global source-map-support</strong></pre>
<p>This allows you to debug your code from Go when the need arises. This is very useful when writing non-trivial applications in GopherJS.</p>
<p class="mce-root"/>
<p>Great, now we are ready to explore the package a bit more. GopherJS provides a playground where you can test your GopherJS code at <a href="https://gopherjs.github.io/playground/">https://gopherjs.github.io/playground/</a>.</p>
<p>Now that our GopherJS is set up, let's take a look at the GopherJS types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GopherJS types</h1>
                </header>
            
            <article>
                
<p>GopherJS includes a sub-package called <kbd>js</kbd>. This package provides the functionalities needed to bridge between Go and JavaScript. The package can be found at <a href="https://godoc.org/github.com/gopherjs/gopherjs/js">https://godoc.org/github.com/gopherjs/gopherjs/js</a>.</p>
<p>The key feature provided by the <kbd>js</kbd> package is the ability to transform Go types into JavaScript types, and vice versa. </p>
<p>When we consider data types, there are two main categories that need to be supported: basic types (<kbd>int</kbd>, <kbd>float</kbd>, and <kbd>string</kbd>) and constructed types (structs and interfaces). The following table shows the type mappings between Go basic types and JavaScript types, as supported by GopherJS:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Go type</strong></td>
<td><strong>JavaScript type</strong></td>
</tr>
<tr>
<td><kbd>bool</kbd></td>
<td><kbd>Boolean</kbd></td>
</tr>
<tr>
<td><kbd>int</kbd> and <kbd>float</kbd></td>
<td><kbd>Number</kbd></td>
</tr>
<tr>
<td><kbd>string</kbd></td>
<td><kbd>String</kbd></td>
</tr>
<tr>
<td><kbd>[]int8</kbd></td>
<td><kbd>Int8Array</kbd></td>
</tr>
<tr>
<td><kbd>[]int16</kbd></td>
<td><kbd>Int16Array</kbd></td>
</tr>
<tr>
<td><kbd>[]int32</kbd>, <kbd>[]int</kbd></td>
<td><kbd>Int32Array</kbd></td>
</tr>
<tr>
<td><kbd>[]uint8</kbd></td>
<td><kbd>Uint8Array</kbd></td>
</tr>
<tr>
<td><kbd>[]uint16</kbd></td>
<td><kbd>Uint16Array</kbd></td>
</tr>
<tr>
<td><kbd>[]uint32</kbd>, <kbd>[]uint</kbd></td>
<td><kbd>Uint32Array</kbd></td>
</tr>
<tr>
<td><kbd>[]float32</kbd></td>
<td><kbd>Float32Array</kbd></td>
</tr>
<tr>
<td><kbd>[]float64</kbd></td>
<td>
<p class="mce-root"><kbd>Float64Array</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>For example, if you utilize GopherJS to compile a piece of code that includes a Go <kbd>int</kbd> type into JavaScript, the <kbd>int</kbd> type will become a JavaScript <kbd>Number</kbd> type. It is recommended that you stick with the <kbd>int</kbd> type, instead of the <kbd>uint8</kbd>/<kbd>uint16</kbd>/<kbd>uint32</kbd>/<kbd>uint64</kbd> types, to improve performance of your transpiled code. It is also recommended to use <kbd>float64</kbd> over <kbd>float32</kbd>.</p>
<p>Now that we know the different GopherJS types, let's move on to object types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object types</h1>
                </header>
            
            <article>
                
<p class="mce-root">Basic types are good; however, they are just a simple component of any real piece of code. What about Go structs, interfaces, methods, functions, and goroutines? The <kbd>js</kbd> package gives you the power to convert those types to JavaScript. </p>
<p>One of the key building blocks provided by the <kbd>js</kbd> package is the <kbd>*js.Object</kbd> type. This type is simply a container for a native JavaScript object. Most of GopherJS's code involves converting Go objects to <kbd>*js.Object</kbd> or vice versa. JavaScript modules are exposed as <kbd>*js.Object</kbd> in our Go code.</p>
<p><span>Now, l</span>et's explore how to call JavaScript functions from our Go code in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calling JavaScript functions from your Go code</h1>
                </header>
            
            <article>
                
<p>Typically, JavaScript code runs either on Node.js or in the browser. Any code that runs on Node.js should have access to what is known as <em>Node.js</em> g<em>lobal objects</em> (<a href="https://nodejs.org/api/globals.html">https://nodejs.org/api/globals.html</a>). If your code ends up running on a Node.js environment, GopherJS gives you access to the global objects using the <kbd>js.Global</kbd> variable, which returns a <kbd>*js.Object</kbd> that hosts your global variables. You can then access a specific object using a method called <kbd>Get</kbd>, then call the object methods using a method called <kbd><span><span>Call</span></span></kbd>. Let's see an example to better explain this paragraph.  </p>
<p>Run the following code:</p>
<pre>package main<br/><br/>import (<br/>  "github.com/gopherjs/gopherjs/js"<br/>)<br/><br/>func main() {<br/>  //the console variable is of type *js.Object<br/>  console := js.Global.Get("console")<br/>  /*<br/>    the *js.Object support a method called Call which     can access the methods of console.<br/>  */<br/>  console.Call("log", "Hello world!!")<br/>}</pre>
<p>This will be the equivalent of writing a piece of Node.js JavaScript code that looks like this:</p>
<pre>console.log("Hello World!!");</pre>
<p>The <kbd>js.Global</kbd> object opens up very interesting possibilities, as it allows you to access Node.js modules and use them in your Go code. For example, let's assume we imported a Node.js module called <kbd>prettyjson</kbd> to our node project, and we would like to use it in our Go code. <kbd>prettyjson</kbd> is a real package, it has a method called <kbd>render()</kbd>, which converts objects to beautiful-looking JSON. This is shown in the following code:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/><br/>  "github.com/gopherjs/gopherjs/js"<br/>)<br/><br/>func main() {<br/>  //Some data type<br/>  type MyType struct {<br/>    Name string<br/>    Projects []string<br/>  }<br/>  //A value from our data type<br/>  value := MyType{Name: "mina", Projects: []string{"GopherJS", "ReactJS"}}<br/>  /*<br/>    Call the prettyjson module, this is equivalent to the following code in JavaScript:<br/>        var prettyjson = require("prettyjson");<br/> */<br/>  prettyjson := js.Global.Call("require", "prettyjson")<br/><br/>  // The line below is equivalent to 'prettyjson.render(value);' in JavaScript<br/>  result := prettyjson.Call("render", value)<br/>  /*<br/>    Do something with result<br/>    */<br/>}</pre>
<p>As mentioned, JavaScript code can also run on a browser. The globals available to the browser are different. For example, the following piece of code will run fine on a browser, but won't be happy if you try to run it with Node.js:</p>
<pre>package main<br/><br/>import (<br/>  "github.com/gopherjs/gopherjs/js"<br/>)<br/><br/>func main() {<br/>  document := js.Global.Get("document")<br/>  document.Call("write", "Hello world!!")<br/>}</pre>
<p>That is because <kbd>"document"</kbd> is a global object available for almost all browsers.</p>
<p>In the next section, we will take a look at the GopherJS commands.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GopherJS commands</h1>
                </header>
            
            <article>
                
<p>We now have enough knowledge to start exploring the commands provided by GopherJS in order to compile Go code into JavaScript. For any GopherJS command you run, make sure the<span> </span><kbd>GOOS</kbd><span> </span>flag is set to either <kbd>darwin</kbd> or <kbd>linux</kbd>. If you are running on Windows, you'll need to run the following command from the Terminal session expected to run GopherJS's commands:</p>
<pre><strong>set GOOS=linux</strong></pre>
<p>Here is what we need to do next—let's start by getting an environment ready. After installing<span> </span>GopherJS<span> </span>and the<span> </span><kbd>source-map-support</kbd><span> </span>module, as covered earlier in <em>GopherJS fundamentals</em> section, create a new folder inside your Go<span> </span><kbd>src</kbd><span> </span>folder that is in your<span> </span><kbd>GOPATH</kbd>. Let's name the new folder<span> </span><kbd>9-Isomorphic-GO</kbd>. Inside the new folder, create another folder called <kbd>node</kbd>. This is where we'll write our code that is expecting to interface with node packages. </p>
<p>Now create a file called<span> </span><kbd>main.go</kbd><span> </span>inside the<span> </span><kbd>node</kbd><span> </span>folder. Then type the following code into the file:</p>
<pre>package main<br/><br/>import (<br/>  "github.com/gopherjs/gopherjs/js"<br/>)<br/><br/>func main() {<br/>  console := js.Global.Get("console")<br/>  console.Call("log", "Hello world!!")<br/>}</pre>
<p>The next step is to use the power of GopherJS to convert the preceding code into JavaScript. This can simply be done using the<span> </span><kbd>gopherjs build</kbd><span> </span>command. So in the console, navigate to the <kbd>node</kbd> folder, then type the following:</p>
<pre><strong>gopherjs build main.go</strong></pre>
<p>This will create a new file called<span> </span><kbd>main.js</kbd><span>, </span>which will host your converted JavaScript code. You will notice that the <kbd>main.js</kbd> file has a lot of JavaScript code. This is because GopherJS re-implements key pieces of Go runtime in the generated JavaScript file, in order to be able to support a large number of Go apps and packages. </p>
<p>Like any other Node.js file, you can simply run JavaScript code in the new file by typing the following:</p>
<pre><strong>node main.js</strong></pre>
<p>GopherJS also supports the <kbd>install</kbd> command. Run the following command:</p>
<pre><strong>gopherjs install</strong></pre>
<p class="CDPAlignLeft CDPAlign">Doing so will produce a JavaScript file in your <kbd>bin</kbd> folder. This is similar to what the <kbd>go install</kbd> command would do, except that the result in this case is a JavaScript file, not an executable file.</p>
<p class="CDPAlignLeft CDPAlign">The GopherJS commands support a flag that allows us to output minified JavaScript, this flag is <kbd>-m</kbd>. Minifying JavaScript involves removing all unnecessary characters, such as white spaces, new line characters, and comments.  </p>
<p>If you would like to run the code directly, and you already have Node.js's<span> </span><kbd>source-map-support</kbd><span> </span>module installed, you can simply use the<span> </span><kbd>gopherjs run</kbd><span> </span>command, so it would look like this:</p>
<pre><strong>gopherjs run main.go</strong></pre>
<p>What if we want to try some browser code?</p>
<p>Let's go back to the parent folder we created, it was called <kbd>9-Isomorphic-GO</kbd>. Under that folder, create a new folder called<span> </span><kbd>browser</kbd>, then underneath, create a new file called<span> </span><kbd>main.go</kbd>. Inside the <kbd>main.go</kbd> file, write the following code:</p>
<pre>package main<br/><br/>import (<br/>  "github.com/gopherjs/gopherjs/js"<br/>)<br/><br/>func main() {<br/>  document := js.Global.Get("document")<br/>  document.Call("write", "Hello world!!")<br/>}</pre>
<p>The preceding code is obviously expected to run on the browser, since it makes use of the<span> </span><kbd>document</kbd><span> </span>object. We can still utilize <kbd>gopherjs build</kbd> here in order to convert it into JavaScript. However, we have another option.</p>
<p>Run the following command at the<span> </span><kbd>browser</kbd><span> </span>folder:</p>
<pre><strong>gopherjs serve</strong></pre>
<p>A web server will be started, which, by default, will serve your generated files at the<span> </span><kbd>localhost:8080</kbd><span> </span>address. Any changes you make to the <kbd>main.go</kbd> file will be reflected in the web-served page; however, you will probably need to refresh the web page to see changes.</p>
<p>If your Go code exists in a subfolder from where you run the <kbd>gopherjs serve</kbd> command, your page will get served at<span> </span><kbd>localhost:8080/your/sub/folder</kbd>, where <kbd>your/sub/folder</kbd> refers to the folder path to your <kbd>main.go</kbd> file. So for example, if your code is at<span> </span><kbd>/test/main.go</kbd>, your page will get served at<span> </span><kbd>localhost:8080/test</kbd><span class="packt_screen">.</span></p>
<p>Now, let's discover the bindings between Go and JavaScript that GopherJS provides to us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Go bindings</h1>
                </header>
            
            <article>
                
<p>So far, we've looked at how to embed JavaScript packages into our Go code through GopherJS. However, that can get tedious, especially since there are lots of shared functionalities between JavaScript and Go packages. Luckily, GopherJS supports the conversion of most of Go's standard packages into JavaScript. The list of compatible Go packages can be found at <a href="https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md">https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md</a>. </p>
<p>Some of the packages, such as the <kbd>os</kbd> package, are only supported in Node.js environments. This is because most of the package operations are not meant for the browser.</p>
<p>For example, if you look at the list of compatible Go packages, you'll find the <kbd>encoding/csv</kbd>, <kbd>fmt</kbd>, and <kbd>string</kbd> packages as some of the supported packages. Let's write the following program in Go:</p>
<pre>package main<br/><br/>import (<br/>  "encoding/csv"<br/>  "fmt"<br/>  "strings"<br/>)<br/><br/>func main() {<br/>  //sample csv data<br/>  data := "item11,item12,item13\nitem21,item22,item23\nitem31,item32,item33\n"<br/>  //create a new csv reader<br/>  csvReader := csv.NewReader(strings.NewReader(data))<br/>  i := 0<br/>  for {<br/>    row, err := csvReader.Read()<br/>    if err != nil {<br/>      break<br/>    }<br/>    i++<br/>    fmt.Println("Line", i, "of CSV data:", row)<br/>  }<br/>}</pre>
<p>The preceding code will produce the following output:</p>
<pre><strong>Line 1 of CSV data: [item11 item12 item13]</strong><br/><strong>Line 2 of CSV data: [item21 item22 item23]</strong><br/><strong>Line 3 of CSV data: [item31 item32 item33]</strong></pre>
<p>If the code is compiled with GopherJS, it will generate a JavaScript file that will produce the same result. This is a very powerful feature in GopherJS, as we didn't even need to import GopherJS packages in this project to make it compatible with JavaScript.</p>
<p>Let's see how to export JavaScript modules from Go code in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exporting code</h1>
                </header>
            
            <article>
                
<p>When working with GopherJS, an interesting use case is writing code modules in Go that are then expected to be used by JavaScript module. </p>
<p>Before we explore how to export JavaScript modules that originated from Go code, let's go through some vanilla JavaScript code in order to gain a simple understanding of how module exporting works in the language.</p>
<p>Inside our <kbd>node</kbd> folder, create a new folder called <kbd>calc</kbd>. In that folder, we'll write a simple JavaScript module that will allow us to add and/or subtract some numbers.</p>
<p>Inside the <span class="packt_screen"><kbd>calc</kbd></span> <span>folder, create a file called</span> <kbd>addsub.js</kbd><span>. There, we'll create two functions,</span> <kbd>add()</kbd><span> and</span> <kbd>sub()</kbd><span>:</span></p>
<pre>function add(i,j){<br/>    return i+j;<br/>}<br/><br/>function sub(i,j){<br/>    return i-j;<br/>}</pre>
<p><span>The next step needed is to export these</span> two functions so that other JavaScript modules can make calls to them. This is done by assigning the two functions to <kbd>modules.exports</kbd>:</p>
<pre>module.exports={<br/>    Add: add,<br/>    Sub: sub<br/>}</pre>
<p>The preceding code will expose the two functions as <kbd>Add()</kbd> and <kbd>Sub()</kbd>, so that they can be imported and called by other JavaScript files. </p>
<p>Let's create a new file called <kbd>calc.js</kbd>. This is where we'll call the exported functions from the <kbd>addsub.js</kbd> file. To access the exported functions from <kbd>addsub.js</kbd>, we just need to execute the following code:</p>
<pre>var calc = require('./addsub.js');</pre>
<p>We can then very simply execute our exported functions like this:</p>
<pre>//Call Add() then save result in the add variable<br/>var add = calc.Add(2,3);<br/><br/>//Call Sub() then save result in the sub variable<br/>var sub = calc.Sub(5,2);</pre>
<p><span>We can then print the output like this</span>:</p>
<pre>console.log(add);<br/>console.log(sub);</pre>
<p>Now, how can we write an equivalent code to the <kbd>addsub.js</kbd> module in Go?</p>
<p>It's simple—we start by writing our functions in Go. Let's create a new file called <kbd>addsubgo.go</kbd>, and in there, write the following code:</p>
<pre>package main<br/><br/>import (<br/> "github.com/gopherjs/gopherjs/js"<br/>)<br/><br/>//The Add function<br/>func Add(i, j int) int {<br/> return i + j<br/>}<br/><br/>//The Sub function<br/>func Sub(i, j int) int {<br/> return i - j<br/>}</pre>
<p>Now, in Go's main function, we'll utilize a variable provided by GopherJS, which is called <kbd>js.Module</kbd>. This variable gives you access to the <kbd>module</kbd> variable set by Node.js. Let's type the following code:</p>
<pre>js.Module.Get("exports")</pre>
<p>It will be equivalent to <kbd>module.exports</kbd> in the JavaScript code.</p>
<p>As with most of GopherJS's variables, <kbd>js.Module</kbd> is of the <kbd>*js.Object</kbd> type, which basically means that we can call <kbd>Get</kbd> or <kbd>Set</kbd> on it to get or set objects. Consider the following code in Go:</p>
<pre>exports := js.Module.Get("exports")<br/>exports.Set("Add", Add)<br/>exports.Set("Sub", Sub)</pre>
<p>It is equivalent to the following code in JavaScript:</p>
<pre>module.exports={<br/>    Add: add,<br/>    Sub: sub<br/>}</pre>
<p class="mce-root">And that is the key piece of knowledge you need to write exportable JavaScript code in Go through GopherJS. Here is how the whole Go file would look:</p>
<pre>package main<br/><br/>import (<br/> "github.com/gopherjs/gopherjs/js"<br/>)<br/><br/>func main() {<br/> exports := js.Module.Get("exports")<br/> exports.Set("Add", Add)<br/> exports.Set("Sub", Sub)<br/>}<br/><br/>func Add(i, j int) int {<br/> return i + j<br/>}<br/><br/>func Sub(i, j int) int {<br/> return i - j<br/>}</pre>
<p>We then need to build the preceding code through GopherJS in order to compile it into JavaScript:</p>
<pre><strong>gopherjs build addsubgo.go</strong></pre>
<p>This will generate a new file called <kbd>addsubgo.js</kbd>, which we can now import or use with other JavaScript files. If we go back to <kbd>calc.js</kbd>, we can change it a bit to look like this:</p>
<pre>//We import the compiled JavaScript file here<br/><strong>var calc = require('./addsubgo.js');</strong><br/><br/>//Call Add() then save result in the add variable<br/>var add = calc.Add(2,3);<br/><br/>//Call Sub() then save result in the sub variable<br/>var sub = calc.Sub(5,2);<br/><br/>console.log(add);<br/>console.log(sub);</pre>
<p>The preceding code will produce the same result we expect.</p>
<p>What if we want to write a function that expects an object or a number of objects as arguments? Take this one, for example:</p>
<pre>function formatnumbers(Obj){<br/>    return "First number: " + Obj.first + " second number: " + Obj.second;<br/>}</pre>
<p>This is a very simple function that takes an object as an argument. It then returns a <kbd>string</kbd>, which includes the object fields. The object expects to contain two fields: <kbd>first</kbd> and <kbd>second</kbd>. When this function gets called, we will need to pass an object as an argument to it. Here is how calling the function looks:</p>
<pre>//Call FormatWords then save the result in the fw variable<br/>var fw = calc.FormatNumbers({<br/>    first: 10,<br/>    second: 20,<br/>});</pre>
<p>Writing the equivalent code in Go is very easy, thanks to GopherJS.</p>
<p>Since Go is a statically-typed programming language, first we need to define the data type of our object argument. Let's continue to write code in the <kbd>addsubgo.go</kbd> file. Here is how this looks in Go:</p>
<pre>type Obj struct {<br/>  /*<br/>For any struct type expected to be processed by GopherJS, we need to embed the *js.Object type to it, like below:<br/>*/<br/><br/>  *js.Object<br/><br/>/*<br/>  We then define the fields of our object<br/>*/<br/>  First int `js:"first"` //struct tag represents the field name in JavaScript<br/>  Second int `js:"second"` //struct tag represents the field name in JavaScript<br/>}</pre>
<p>The <kbd>struct</kbd> type was built with two rules in mind:</p>
<ul>
<li>Embed the <kbd>*js.Object</kbd> type in the Go struct</li>
<li>Assign the <kbd>js</kbd> struct tag for any field name expected to be converted to JavaScript</li>
</ul>
<p>Perfect—the next step is to write our function in Go:</p>
<pre>func FormatNumbers(o Obj) string {<br/>  return fmt.Sprintf("First number: %d second number: %d", o.First, o.Second)<br/>}</pre>
<p>This function will be capable of translating to JavaScript using GopherJS, thanks to the fact that we followed the two rules when creating the <kbd>Obj</kbd> type.</p>
<p>Next, we export the <kbd>FormatNumbers()</kbd> function:</p>
<pre>func main() {<br/>  exports := js.Module.Get("exports")<br/>  exports.Set("Add", Add)<br/>  exports.Set("Sub", Sub)<br/><strong>  //Make the FormatNumbers function exportable as a JavaScript module</strong><br/><strong>  exports.Set("FormatNumbers", FormatNumbers)</strong><br/>}</pre>
<p>Once we build this code using the <kbd>gopherjs build addsubgo.go</kbd> command, our new function will callable from JavaScript modules.</p>
<p>Now that we know how to export our code, let's take a look at Go methods and goroutines in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Go Methods</h1>
                </header>
            
            <article>
                
<p>What if we want to expose a Go type with methods to JavaScript?</p>
<p>Let's explore a Go type. The following code has a <kbd>struct</kbd> type that represents a musical instrument, and has some <kbd>getter</kbd> and <kbd>setter</kbd> methods:</p>
<pre>type MI struct {<br/>  MIType string<br/>  Price float64<br/>  Color string<br/>  Age int<br/>}<br/><br/>func (mi *MI) SetMIType(s string) {<br/>  mi.MIType = s<br/>}<br/><br/>func (mi *MI) GetMIType() string {<br/>  return mi.MIType<br/>}<br/><br/>func (mi *MI) SetPrice(f float64) {<br/>  mi.Price = f<br/>}<br/><br/>func (mi *MI) GetPrice() float64 {<br/>  return mi.Price<br/>}<br/><br/>func (mi *MI) SetColor(c string) {<br/>  mi.Color = c<br/>}<br/><br/>func (mi *MI) GetColor() string {<br/>  return mi.Color<br/>}<br/><br/>func (mi *MI) SetAge(a int) {<br/>  mi.Age = a<br/>}<br/><br/>func (mi *MI) GetAge() int {<br/>  return mi.Age<br/>}</pre>
<p>Let's say we want this type to be accessible to JavaScript code. GopherJS comes to the rescue with a function called <kbd>js.MakeWrapper()</kbd>. This function can take a Go type as an argument, and it then returns a <kbd>*js.Object</kbd> that represents the Go type with all its exportable methods. </p>
<p>Create a constructor for our <kbd>MI</kbd> <kbd>struct</kbd> type. It will look like this:</p>
<pre>func New() *js.Object {<br/>  return js.MakeWrapper(&amp;MI{})<br/>}</pre>
<p>In our <kbd>main</kbd> function, we can make this constructor available to JavaScript by adding it to the <kbd>Global</kbd> object:</p>
<pre>func main() {<br/>  //musicalInstruments is the namespace, 'New' is the available function<br/>  js.Global.Set("musicalInstruments", map[string]interface{}{<br/>    "New": New,<br/>  })<br/>}</pre>
<p>The preceding code will create a JavaScript function called <kbd>New()</kbd>, under a namespace called <kbd>musicalInstruments</kbd>.</p>
<p class="mce-root">We could have made the <kbd>New()</kbd> constructor available through a module export, through the <kbd>js.Module</kbd> variable. But for simplicity, it's added to the <kbd>Global</kbd> object for now.</p>
<p>Let's assume that the filename where this code is hosted is called <kbd>mi.go</kbd>. The GopherJS command to compile this code to JavaScript will look like this:</p>
<pre><strong>gopherjs build mi.go</strong></pre>
<p>A new file called <kbd>mi.js</kbd> will get generated, JavaScript can simply access the <kbd>MI</kbd> <kbd>struct</kbd> type by importing the file, then call the <kbd>New()</kbd> function from the <kbd>musicalinstruments</kbd> namespace:</p>
<pre>require("./mi.js");<br/><br/>var mi = musicalInstruments.New();<br/><br/>mi.SetAge(20);<br/><br/>console.log(mi.GetAge());</pre>
<p>This will create a new musical instrument object. We can then set its age. Finally, we get the age and log it to the standard output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Goroutines</h1>
                </header>
            
            <article>
                
<p>GopherJS supports goroutines, so you can use goroutines in your Go code, and GopherJS will take care of the rest. </p>
<p>One important requirement is that goroutines must be used if you need to call some blocking code from an external JavaScript.</p>
<p>For example, consider the following JavaScript code running in the browser:</p>
<pre>document.getElementById("myBtn").addEventListener("click", function(){<br/>    /*SOME BLOCKING CODE*/<br/>});</pre>
<p class="mce-root"/>
<p>The preceding code defines a callback function that is expected to execute when a button is clicked.</p>
<p>Here is how this should be handled in Go with the help of GopherJS:</p>
<pre>js.Global.Get("document").Call("getElementById", "mybtn").Call("addEventListener","call", func() {<br/>  go func() {<br/>        /*SOME BLOCKING CODE*/<br/>  }()<br/>})</pre>
<p>As shown in the preceding code snippet, we had to use a goroutine inside the event listener callback code, because it was expected to run some blocking code.</p>
<p>Now that we know the fundamentals of GopherJS, let's use GopherJS with React.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GopherJS with React</h1>
                </header>
            
            <article>
                
<p>Previously in <a href="e875a3eb-c517-4246-8233-cc681f6c3356.xhtml">Chapter 4</a>, <em>Frontend with React.js</em>, we covered the powerful and popular React.js framework. Due to the power of GopherJS, there are now several open source projects that allow you to write React applications in Go. In this chapter, we'll cover one of these open source projects with the aid of an example, to offer us an idea about how to build a practical React application using Go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The project</h1>
                </header>
            
            <article>
                
<p>In this chapter, we'll build a very simple interactive web app using React. The app contains an input text and a button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/00d4d58b-f10f-4e03-8da2-06db08a5db26.png" style="width:20.17em;height:7.00em;"/></p>
<p>Whenever we type a name and then hit <span class="packt_screen">Submit</span>, it gets added to a list on the screen, with the word <span class="packt_screen">Hell</span><span class="packt_screen">o</span> next to it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/11a98fe7-b9f0-4f1b-8d88-81ed0e6660c9.png" style="width:18.25em;height:15.67em;"/></p>
<p>The text input is interactive. So, as you type text, it will display on the screen in real time. This is the kind of reactivity that React is known for.</p>
<p>Let's take a look at the project architecture in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The project application's architecture</h1>
                </header>
            
            <article>
                
<p class="mce-root">The React application we are about to implement is simple, so we will not need more than one component. Our single component will include the input text, the <span class="packt_screen">Submit</span> button, the interactive text, and the list of names. Here is our component:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/820e90a8-325d-4c39-b750-f860dfd1e5d3.png" style="width:28.33em;height:18.75em;"/></p>
<p>In order to cover all the key React concepts in this section, our component will make use of React elements, state, props, and forms. </p>
<p>The form will consist of the input text and the <span class="packt_screen">Submit</span> button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b60bdfcc-5421-4f9b-9a34-de2240eec749.png" style="width:15.83em;height:3.17em;"/></p>
<p class="mce-root">Our React <kbd>state</kbd> object will host two values:</p>
<ul>
<li class="mce-root">The current name being written</li>
<li class="mce-root">The list of names:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/28060daf-4b2e-43b9-b777-f7e390c16613.png" style="width:24.83em;height:19.08em;"/></p>
<p>The prop value for our component will be the generic message that shows up next to the displayed name. In other words, our prop is the word <span class="packt_screen">Hello</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/baded1ec-7703-4562-91c0-b83211c1f730.png" style="width:14.33em;height:12.67em;"/></p>
<p class="mce-root"/>
<p class="mce-root">Let's go ahead and build this React application in Go in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the React application in Go</h1>
                </header>
            
            <article>
                
<p>Now it's time to start writing our React application in Go. We will make use of a popular package known as <span><kbd>myitcv.io/react</kbd>. This package offers some GopherJS bindings for the React framework. The package documentation can be found at <a href="https://github.com/myitcv/x/tree/master/react">https://github.com/myitcv/x/tree/master/react</a>.</span></p>
<p>The first thing we need to do is retrieve the <kbd><span>myitcv.io/react</span></kbd> package, in order to use it in our code:</p>
<pre><strong>go get -u myitcv.io/react</strong></pre>
<p>Retrieve a tool called <kbd>reactGen</kbd>, this tool facilitates building React applications in Go. It can be used to auto-build skeleton applications that act as building blocks for more complex applications:</p>
<pre><strong>go get -u myitcv.io/react myitcv.io/react/cmd/reactGen</strong></pre>
<p>Open a Terminal window, then navigate to the <kbd>reactGen</kbd> folder:</p>
<pre>//In windows:<br/><strong>cd %GOPATH%\src\myitcv.io\react\cmd\reactGen</strong><br/><br/>//or in other operating systems:<br/><strong>cd $GOPATH\src\myitcv.io\react\cmd\reactGen</strong></pre>
<p>Type the <kbd>go install</kbd> command. This should compile and deploy the <kbd>reactGen</kbd> tool to the <kbd>%GOPATH%\bin</kbd> folder. Make sure that path is present in your <kbd>PATH</kbd> environmental variable. </p>
<p>Type the following command to inspect whether <kbd>reactGen</kbd> is installed yet:</p>
<pre><strong>reactGen -help</strong></pre>
<p>Once <kbd>reactGen</kbd> is installed, we are ready to write our application. Go to the <kbd>9-Isomorphic-Go</kbd> folder. Inside, we'll create a new folder called <kbd>reactproject</kbd>. In the Terminal, navigate to the <kbd>reactproject</kbd> folder, then type the following command:</p>
<pre><strong>reactGen -init minimal</strong></pre>
<p>This will create a skeleton for our React application. Let's explore the generated app—there are four files inside:</p>
<ul>
<li><kbd>main.go</kbd><span>: The entry point for our app.</span></li>
<li><kbd>index.html</kbd>: The entry HTML file for our app.</li>
<li><kbd>app.go</kbd>: The <kbd>App</kbd> component of our React application—this will be the first component to get rendered in our application.</li>
<li><kbd>gen_App_reactGen.go</kbd>: This file is auto-generated from <kbd>app.go</kbd>. For any component we write, some auto-generated code will get created afterward, which will contain all the plumbing code needed to make our component work. This code generation allows us to focus only on building the important pieces in our React components, such as props, states, and elements. </li>
</ul>
<p><span>Before we start writing our React component, l</span>et's explore the <kbd>App</kbd> component that we created in the <kbd>app.go</kbd> file, with the <kbd>reactGen</kbd> tool:</p>
<pre>// Template generated by reactGen<br/><br/>package main<br/><br/>import (<br/>  "myitcv.io/react"<br/>)<br/><br/>type AppDef struct {<br/>  react.ComponentDef<br/>}<br/><br/>func App() *AppElem {<br/>  return buildAppElem()<br/>}<br/><br/>func (a AppDef) Render() react.Element {<br/>  return react.Div(nil,<br/>    react.H1(nil,<br/>      react.S("Hello World"),<br/>    ),<br/>    react.P(nil,<br/>      react.S("This is my first GopherJS React App."),<br/>    ),<br/>  )<br/>}</pre>
<p>The preceding code creates a Go struct called <kbd>AppDef</kbd>, which acts as a React component. In order for a Go <kbd>struct</kbd> type to qualify as a React component, it needs to satisfy three requirements:</p>
<ul>
<li>The Go struct name must have the <kbd>Def</kbd> suffix.</li>
<li>The Go struct has to embed the <kbd>react.ComponentDef</kbd> type.</li>
<li>The <kbd>struct</kbd> type must implement the <kbd>Render()</kbd> method, which acts as the equivalent of the React's <kbd>render()</kbd> method.</li>
</ul>
<p>Similar to React.js, the <kbd>Render()</kbd> method has to return React elements. The <span><kbd>myitcv.io/react</kbd> framework offers methods that correspond to React elements. From the preceding code, we see that <kbd>Render()</kbd> returns the following:</span></p>
<pre>react.Div(nil,<br/>    react.H1(nil,<br/>      react.S("Hello World"),<br/>    ),<br/>    react.P(nil,<br/>      react.S("This is my first GopherJS React App."),<br/>    ),<br/>  )</pre>
<p>The preceding code corresponds to the following React JSX:</p>
<pre>&lt;div&gt;<br/>   &lt;h1&gt;Hello World&lt;/h1&gt;<br/>   &lt;p&gt;This is my first GopherJS React App.&lt;/p&gt; <br/>&lt;/div&gt;</pre>
<p>Each one of the JSX elements corresponds to a <kbd>react.&lt;element type&gt;</kbd> function in Go. There were a total of three elements. The first is the <kbd>&lt;div&gt;</kbd> element, which hosted the other two elements. In Go, this translated to <kbd>react.Div(nil,...other_elements)</kbd>. The first argument is our element's props. Since we didn't include any props, the first argument ended up being <kbd>nil</kbd>. If we needed to add a React prop—let's say, the <kbd>className</kbd> prop—it can simply be done like this:</p>
<pre>react.Div(&amp;react.DivProps{<br/>    ClassName:"css_class_name"<br/>  },...other_elements)</pre>
<p>The second element is the <kbd>h1</kbd> element. In Go, we represented it as <kbd>react.H1(nil,react.S("Hello World"))</kbd>. The first argument represents props passed to the element. The <kbd>react.S("")</kbd> function simply represents a string. </p>
<p>The third element is the <kbd><span><span>P</span></span></kbd> element. In Go, it looked like this:</p>
<pre>react.P(nil, react.S("This is my first GopherJS React App."))</pre>
<p>Now, let's see this code in action. Set the <kbd>GOOS</kbd> environmental variable to <kbd>linux</kbd> if you're using Windows:</p>
<pre><strong>set GOOS=linux</strong></pre>
<p>From our <kbd>reactproject</kbd> folder, run the following command in the Terminal:</p>
<pre><strong>gopherjs serve</strong></pre>
<p>This will serve our React application on port <kbd>8080</kbd>. If we open a web browser and visit <kbd>localhost:8080/&lt;the Go project folder from src&gt;</kbd>, we'll be greeted with this simple application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6704b900-8cee-410a-8926-a8cd8e7894ea.png" style="width:45.50em;height:7.83em;"/></p>
<p>Now, we are ready to build our custom component, which we will do in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a custom component</h1>
                </header>
            
            <article>
                
<p>Under the <kbd>reactproject</kbd> <span>folder, create a new folder called</span> <kbd>hello_message</kbd><span>. Inside the folder, we'll create a new file called</span> <kbd>hello_message.go</kbd><span>. In the file, we will call the <kbd>hellomessage</kbd> package:</span></p>
<pre>package hellomessage</pre>
<p>We then create a Go struct to represent our React component:</p>
<pre>import "myitcv.io/react"<br/>type HelloMessageDef struct {<br/>  react.ComponentDef<br/>}</pre>
<p>Now, it's time to define our props. This can simply be done by a <kbd>struct</kbd> type that contains our expected props. As mentioned, our prop is the message string:</p>
<pre>//Naming convention is *props<br/>type HelloMessageProps struct {<br/>  Message string<br/>}</pre>
<p>Defining a <kbd>state</kbd> object is very similar to props. A <kbd>struct</kbd> type needs to be created with the expected React <kbd>state</kbd> object fields. Our <kbd>state</kbd> object fields are the current name being written to the text input, as well as the list of names written so far:</p>
<pre>//Naming convention is *State<br/>type HelloMessageState struct {<br/>  CurrName string<br/>  Names []string<br/>}</pre>
<p>As mentioned in <a href="e875a3eb-c517-4246-8233-cc681f6c3356.xhtml">Chapter 4</a>, <em>Frontend with React.js,</em> the React framework makes a decision to re-render your component whenever React detects that the <kbd>state</kbd> object has changed. Since our <kbd>state</kbd> object here contains a Go slice, future and current states cannot simply be compared using an <kbd>==</kbd> operator. In this case, it's strongly recommended to provide React with a way to decide whether the React object has changed. This is done using the <kbd>Equals</kbd> method, which is implemented by the <kbd>state</kbd> Go struct. Here is how this looks:</p>
<pre>func (c HelloMessageState) Equals(v HelloMessageState) bool {<br/> //compare CurrName between current and future states<br/>  if c.CurrName != v.CurrName {<br/>    return false<br/>  }<br/>  //compare Names between current and future states<br/>  /*there are other ways to compare slices, below is a very simplistic approach*/<br/>  if len(c.Names) != len(v.Names) {<br/>    return false<br/>  }<br/><br/>  for i := range v.Names {<br/>    if v.Names[i] != c.Names[i] {<br/>      return false<br/>    }<br/>  }<br/>  return true<br/>}</pre>
<p>At this point, we need to run the <kbd>go generate</kbd> command from the Terminal to generate some helper code that we can use to write the rest of our component. After you run the <kbd>go generate</kbd> command, you will notice that a new file, called <kbd>gen_HelloMessage_reactGen.go</kbd>, was generated for us. Do not edit this file. </p>
<p>The generated file will provide a new data type for you to use: <kbd>*HelloMessageElem</kbd>. This type represents our component's React element.</p>
<p>Let's go back to our code inside <kbd>hello_message.go</kbd>, the next step is to write a constructor for our new React component. The constructor will need to take props as an argument, and returns the React element as a result. Here is how this will look:</p>
<pre>func HelloMessage(p HelloMessageProps) *HelloMessageElem {<br/>  fmt.Println("Building element...")<br/>  return buildHelloMessageElem(p)<br/>}</pre>
<p>Since our code gets compiled to JavaScript through GopherJS, the <kbd>fmt.Println()</kbd> function will get translated to <kbd>console.log()</kbd>, as covered in the <em>Go bindings</em> section.</p>
<p>Next, we need to define the <kbd>Render()</kbd> method of our component. The <kbd>Render()</kbd> method needs to be defined in a non-pointer type of our component Go struct. Here is an empty <kbd>Render()</kbd> method:</p>
<pre>func (r HelloMessageDef) Render() react.Element {<br/>    return nil<br/>}</pre>
<p>We now have to fill up the <kbd>Render()</kbd> method with the following:</p>
<ul>
<li>A form that includes an input text box, and a <span class="packt_screen">Submit</span> button</li>
<li>A string to host the name currently being written</li>
<li>A list of strings to represent a history of the names entered</li>
</ul>
<p>As a refresher, have a look at the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b4b82c02-079f-416a-9664-d2aac373cc8f.png" style="width:28.08em;height:21.58em;"/></p>
<p>The red rectangles represent our React states, the green rectangles represent our props, and the blue rectangle represents our entire React component. </p>
<p>Going back to our <kbd>Render()</kbd> method, first, we need to write the text input element. It's an HTML form input element of the <kbd>"text"</kbd> type. Here is how this looks:</p>
<pre>InputName := react.Input(&amp;react.InputProps{<br/>    Type: "text",<br/>    Key: "FirstName",<br/>    Placeholder: "Mina",<br/>    Value: r.State().CurrName,<br/>    OnChange: r,<br/>  }, nil)</pre>
<p>The preceding code represents a React <kbd>input</kbd> element, courtesy of the <kbd>myitcv.io/react</kbd> package.  The first argument is the props for the input element; the second argument is <kbd>nil</kbd>, because we don't need any children for this element. The input props are the same as the ones we used in the JSX format. There are two notable props that we used here:</p>
<pre>Value: r.State().CurrName,<br/>OnChange: r,</pre>
<p><span>The </span><kbd>Value</kbd><span> prop is the current value of the input text. By assigning the <kbd>State</kbd> object of the </span><kbd>CurrName</kbd><span> field to the input text </span><kbd>Value</kbd><span> field, we've guaranteed that the input text will change based on the name you enter.</span></p>
<p>The <kbd>OnChange</kbd> prop represents the action taken whenever a change happens to our input text. The prop must point to a type that implements the <kbd>OnChange(event)</kbd> method. Since we assign <kbd>r</kbd> to it, we must implement <kbd>OnChange</kbd>. Here is how this will look:</p>
<pre>func (r HelloMessageDef) OnChange(e *react.SyntheticEvent) {<br/>  //we need to import "honnef.co/go/js/dom" for this to work<br/>  //get target: our input text HTML element<br/>  target := e.Target().(*dom.HTMLInputElement)<br/>  //get current state<br/>  currState := r.State()<br/>  //change state to include new value in our input text component, as well as the existing history of names<br/>  r.SetState(HelloMessageState{CurrName: target.Value, Names: currState.Names})<br/>}</pre>
<p>The preceding code is self-explanatory:</p>
<ul>
<li>The Go React framework provides a type called <kbd>*react.SyntheticEvent</kbd>, which represents the event getting passed to the <kbd>OnChange</kbd> method.</li>
<li>We retrieve the value of the text being written to the input text.</li>
<li>We retrieve our current React state. This is done using the <kbd>State()</kbd> method.</li>
<li>We change our React state to represent the new name. This is done using the <kbd>SetState()</kbd> method.</li>
</ul>
<p>Now, let's go back to our <kbd>Render()</kbd> method. The next step is to write the <span class="packt_screen">Submit</span> button component. It is also an HTML form input element, but it's of the <kbd>"Submit"</kbd> type. An HTML form input element of the <kbd>"Submit"</kbd> type is a button. Whenever the <span class="packt_screen">Submit</span> button gets pressed, the form will get submitted:</p>
<pre>InputBtn := react.Input(&amp;react.InputProps{<br/>    Type: "Submit",<br/>    Value: "Submit",<br/>  }, nil)</pre>
<p>Next, we need to write our React form. The form element will act as a parent element for both the text and the button elements. Our form element will also host a <kbd>"Name:"</kbd> string.</p>
<p>As mentioned earlier, whenever the <span class="packt_screen">Submit</span> button gets pressed, the form will be submitted. Typically, when an HTML form gets submitted, its input data is sent to the server, where the form's input data gets processed. In our case, we want to capture the submission event, and then instead of the form submission's default behavior, we want to change our <kbd>state</kbd> object to add the new input name to our <kbd>state.Names</kbd> list.</p>
<p>Before we delve more into how to define the actions taken on form submission, let's go back to the <kbd>render</kbd> method, and define our form:</p>
<pre>Form := react.Form(&amp;react.FormProps{<br/>    OnSubmit: r,<br/>  },<br/>    react.S("Name: "),<br/>    InputName,<br/>    InputBtn)</pre>
<p>Notice that we defined an <kbd>OnSubmit</kbd> React form prop. This is how we define the actions taken on form submission in our Go code. The data type we pass to the <kbd>OnSubmit</kbd> prop must implement a method with the <kbd><span>OnSubmit(</span><span>*</span><span>react.SyntheticEvent</span><span>)</span></kbd><span> signature. </span>Let's implement this method in our code:</p>
<pre>func (r HelloMessageDef) OnSubmit(e *react.SyntheticEvent) {<br/>  //Prevent the default form submission action<br/>  e.PreventDefault()<br/>  //Add the new name to the list of names in the state object<br/>  names := r.State().Names<br/>  names = append(names, r.State().CurrName)<br/>  /*<br/>    Change the state so that the current name is now empty, and the new name gets added to the existing list of names<br/>  */<br/>  r.SetState(HelloMessageState{CurrName: "", Names: names})<br/>}</pre>
<p>Perfect—now we just need to finish the <kbd>Render()</kbd> method. Here are the remaining tasks for our custom form's <kbd>Render()</kbd> method:</p>
<ul>
<li>Get the list of saved names in our <kbd>state</kbd> object.</li>
<li>For each saved name in the list, convert it to an <kbd>Li</kbd> element. This is a form list element.</li>
<li>Return a <kbd>Div</kbd> object, which contains the following:
<ul>
<li>The defined form</li>
<li>A  string with the prop message, combined with the current name saved in the <kbd>state</kbd> object</li>
<li>The list of existing names</li>
</ul>
</li>
</ul>
<p>Here is how the rest of the code will look:</p>
<pre> names := r.State().Names<br/> fmt.Println(names)<br/> entries := make([]react.RendersLi, len(names))<br/> for i, name := range names {<br/>   entries[i] = react.Li(nil, react.S(r.Props().Message+" "+name))<br/>  }<br/>  return react.Div(nil,<br/>    Form,<br/>    react.S(r.Props().Message+" "+r.State().CurrName),<br/>    react.Ul(nil, entries...),<br/>  )</pre>
<p>And here is the entire <kbd>Render()</kbd> method:</p>
<pre>func (r HelloMessageDef) Render() react.Element {<br/>  InputName := react.Input(&amp;react.InputProps{<br/>    Type: "text",<br/>    Key: "FirstName",<br/>    Placeholder: "Mina",<br/>    Value: r.State().CurrName,<br/>    OnChange: r,<br/>  }, nil)<br/>  InputBtn := react.Input(&amp;react.InputProps{<br/>    Type: "Submit",<br/>    Value: "Submit",<br/>  }, nil)<br/>  Form := react.Form(&amp;react.FormProps{<br/>    OnSubmit: r,<br/>  },<br/>    react.S("Name: "),<br/>    InputName,<br/>    InputBtn)<br/>  names := r.State().Names<br/>  fmt.Println(names)<br/>  entries := make([]react.RendersLi, len(names))<br/>  for i, name := range names {<br/>    entries[i] = react.Li(nil, react.S(r.Props().Message+" "+name))<br/>  }<br/>  return react.Div(nil,<br/>    Form,<br/>    react.S(r.Props().Message+" "+r.State().CurrName),<br/>    react.Ul(nil, entries...),<br/>  )<br/>}</pre>
<p>Now, we can run <kbd>go generate</kbd>. </p>
<p>Our component is done; however, there is still some work left. We need to call our newly-created component from the <kbd>App</kbd> component, located in the <kbd>app.go</kbd> file. This will be done using the <kbd>HelloMessage(p HelloMessageProps) *HelloMessageElem</kbd> constructor, which we created before. The constructor takes the props as an argument and returns our custom component React element. The code we need to modify is under the <kbd>Render()</kbd> method of our <kbd>App</kbd> component. The prop object contains a field called <kbd>Message</kbd>. The value of the message we would like to pass is simply <kbd>"Hello"</kbd>:</p>
<pre>func (a AppDef) Render() react.Element {<br/>  /*<br/>    Return a react div that hosts a title, as well as our custom hello message component<br/>  */<br/>  return react.Div(nil,<br/>    react.P(nil,<br/>      react.S("This is my first GopherJS React App."),<br/>    ),<br/>    react.H1(nil,<br/>     <strong> hellomessage.HelloMessage(hellomessage.HelloMessageProps{Message: "Hello"})</strong>,<br/>    ),<br/>  )<br/>}</pre>
<p>That's it for our code. If you run the <kbd>gopherjs serve</kbd> command from your Terminal at the <kbd>reactproject</kbd> folder, the project will be accessible in the browser at the <kbd>localhost:8080/&lt;your project folder from src&gt;</kbd> address.</p>
<p>When you are ready to transpile your React project to JavaScript, simply run the <kbd>gopherjs build</kbd> command from the <kbd>reactproject</kbd> folder. This will generate a <kbd>reactproject.js</kbd> file that can be used from the <kbd>index.html</kbd> file in your project folder. If you look at the <kbd>index.html</kbd> file in your project folder, you will find that it references a script called <kbd>reactproject.js</kbd>. If you open <kbd>index.html</kbd> from a browser after performing the build step, you will find your application working as expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we focused on building isomorphic applications using Go. We covered some key topics regarding converting Go code into JavaScript code. We dove into Go bindings in GopherJS, and considered how it can empower us to bridge the two languages.</p>
<p>We also made use of the GopherJS framework to build Go applications that integrate with JavaScript, whether at the frontend or on the server side. We explored important topics, such as concurrency and methods.</p>
<p>We also covered the Go React framework, and went through the process of building a simple React application in Go.</p>
<p>In the next chapter, we'll cover topics such as cloud-native applications and the React Native framework so that you can further hone your skills.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What does transpling mean?</li>
<li>What is GopherJS?</li>
<li>What is the <kbd>*js.Object</kbd> type?</li>
<li>What is the <kbd>js.Global</kbd> variable?</li>
<li>What is the <kbd>js.Module</kbd> variable?</li>
<li>What does the <kbd>js.MakeWrapper()</kbd> function do?</li>
<li>What does the <kbd>js</kbd> Go struct tag do?</li>
<li>What are the main steps to build a React component in Go?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>For more information, check out the following links:</p>
<ul>
<li><strong>GopherJS</strong>: <a href="https://github.com/gopherjs/gopherjs">https://github.com/gopherjs/gopherjs</a></li>
<li><strong>GopherJS with React</strong>: <a href="https://github.com/myitcv/x/tree/master/react/_doc">https://github.com/myitcv/x/tree/master/react/_doc</a></li>
<li><strong>Creating a GopherJS React app</strong>: <a href="https://github.com/myitcv/x/blob/master/react/_doc/creating_app.md">https://github.com/myitcv/x/blob/master/react/_doc/creating_app.md</a></li>
<li><strong>GopherJS React examples</strong>: <a href="https://blog.myitcv.io/gopherjs_examples_sites/examplesshowcase/">https://blog.myitcv.io/gopherjs_examples_sites/examplesshowcase/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>