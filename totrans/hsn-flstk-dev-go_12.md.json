["```go\ngo get -u github.com/gopherjs/gopherjs\n```", "```go\nnpm install --global source-map-support\n```", "```go\npackage main\n\nimport (\n  \"github.com/gopherjs/gopherjs/js\"\n)\n\nfunc main() {\n  //the console variable is of type *js.Object\n  console := js.Global.Get(\"console\")\n  /*\n    the *js.Object support a method called Call which     can access the methods of console.\n  */\n  console.Call(\"log\", \"Hello world!!\")\n}\n```", "```go\nconsole.log(\"Hello World!!\");\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/gopherjs/gopherjs/js\"\n)\n\nfunc main() {\n  //Some data type\n  type MyType struct {\n    Name string\n    Projects []string\n  }\n  //A value from our data type\n  value := MyType{Name: \"mina\", Projects: []string{\"GopherJS\", \"ReactJS\"}}\n  /*\n    Call the prettyjson module, this is equivalent to the following code in JavaScript:\n        var prettyjson = require(\"prettyjson\");\n */\n  prettyjson := js.Global.Call(\"require\", \"prettyjson\")\n\n  // The line below is equivalent to 'prettyjson.render(value);' in JavaScript\n  result := prettyjson.Call(\"render\", value)\n  /*\n    Do something with result\n    */\n}\n```", "```go\npackage main\n\nimport (\n  \"github.com/gopherjs/gopherjs/js\"\n)\n\nfunc main() {\n  document := js.Global.Get(\"document\")\n  document.Call(\"write\", \"Hello world!!\")\n}\n```", "```go\nset GOOS=linux\n```", "```go\npackage main\n\nimport (\n  \"github.com/gopherjs/gopherjs/js\"\n)\n\nfunc main() {\n  console := js.Global.Get(\"console\")\n  console.Call(\"log\", \"Hello world!!\")\n}\n```", "```go\ngopherjs build main.go\n```", "```go\nnode main.js\n```", "```go\ngopherjs install\n```", "```go\ngopherjs run main.go\n```", "```go\npackage main\n\nimport (\n  \"github.com/gopherjs/gopherjs/js\"\n)\n\nfunc main() {\n  document := js.Global.Get(\"document\")\n  document.Call(\"write\", \"Hello world!!\")\n}\n```", "```go\ngopherjs serve\n```", "```go\npackage main\n\nimport (\n  \"encoding/csv\"\n  \"fmt\"\n  \"strings\"\n)\n\nfunc main() {\n  //sample csv data\n  data := \"item11,item12,item13\\nitem21,item22,item23\\nitem31,item32,item33\\n\"\n  //create a new csv reader\n  csvReader := csv.NewReader(strings.NewReader(data))\n  i := 0\n  for {\n    row, err := csvReader.Read()\n    if err != nil {\n      break\n    }\n    i++\n    fmt.Println(\"Line\", i, \"of CSV data:\", row)\n  }\n}\n```", "```go\nLine 1 of CSV data: [item11 item12 item13]\nLine 2 of CSV data: [item21 item22 item23]\nLine 3 of CSV data: [item31 item32 item33]\n```", "```go\nfunction add(i,j){\n    return i+j;\n}\n\nfunction sub(i,j){\n    return i-j;\n}\n```", "```go\nmodule.exports={\n    Add: add,\n    Sub: sub\n}\n```", "```go\nvar calc = require('./addsub.js');\n```", "```go\n//Call Add() then save result in the add variable\nvar add = calc.Add(2,3);\n\n//Call Sub() then save result in the sub variable\nvar sub = calc.Sub(5,2);\n```", "```go\nconsole.log(add);\nconsole.log(sub);\n```", "```go\npackage main\n\nimport (\n \"github.com/gopherjs/gopherjs/js\"\n)\n\n//The Add function\nfunc Add(i, j int) int {\n return i + j\n}\n\n//The Sub function\nfunc Sub(i, j int) int {\n return i - j\n}\n```", "```go\njs.Module.Get(\"exports\")\n```", "```go\nexports := js.Module.Get(\"exports\")\nexports.Set(\"Add\", Add)\nexports.Set(\"Sub\", Sub)\n```", "```go\nmodule.exports={\n    Add: add,\n    Sub: sub\n}\n```", "```go\npackage main\n\nimport (\n \"github.com/gopherjs/gopherjs/js\"\n)\n\nfunc main() {\n exports := js.Module.Get(\"exports\")\n exports.Set(\"Add\", Add)\n exports.Set(\"Sub\", Sub)\n}\n\nfunc Add(i, j int) int {\n return i + j\n}\n\nfunc Sub(i, j int) int {\n return i - j\n}\n```", "```go\ngopherjs build addsubgo.go\n```", "```go\n//We import the compiled JavaScript file here\nvar calc = require('./addsubgo.js');\n\n//Call Add() then save result in the add variable\nvar add = calc.Add(2,3);\n\n//Call Sub() then save result in the sub variable\nvar sub = calc.Sub(5,2);\n\nconsole.log(add);\nconsole.log(sub);\n```", "```go\nfunction formatnumbers(Obj){\n    return \"First number: \" + Obj.first + \" second number: \" + Obj.second;\n}\n```", "```go\n//Call FormatWords then save the result in the fw variable\nvar fw = calc.FormatNumbers({\n    first: 10,\n    second: 20,\n});\n```", "```go\ntype Obj struct {\n  /*\nFor any struct type expected to be processed by GopherJS, we need to embed the *js.Object type to it, like below:\n*/\n\n  *js.Object\n\n/*\n  We then define the fields of our object\n*/\n  First int `js:\"first\"` //struct tag represents the field name in JavaScript\n  Second int `js:\"second\"` //struct tag represents the field name in JavaScript\n}\n```", "```go\nfunc FormatNumbers(o Obj) string {\n  return fmt.Sprintf(\"First number: %d second number: %d\", o.First, o.Second)\n}\n```", "```go\nfunc main() {\n  exports := js.Module.Get(\"exports\")\n  exports.Set(\"Add\", Add)\n  exports.Set(\"Sub\", Sub)\n //Make the FormatNumbers function exportable as a JavaScript module\n exports.Set(\"FormatNumbers\", FormatNumbers)\n}\n```", "```go\ntype MI struct {\n  MIType string\n  Price float64\n  Color string\n  Age int\n}\n\nfunc (mi *MI) SetMIType(s string) {\n  mi.MIType = s\n}\n\nfunc (mi *MI) GetMIType() string {\n  return mi.MIType\n}\n\nfunc (mi *MI) SetPrice(f float64) {\n  mi.Price = f\n}\n\nfunc (mi *MI) GetPrice() float64 {\n  return mi.Price\n}\n\nfunc (mi *MI) SetColor(c string) {\n  mi.Color = c\n}\n\nfunc (mi *MI) GetColor() string {\n  return mi.Color\n}\n\nfunc (mi *MI) SetAge(a int) {\n  mi.Age = a\n}\n\nfunc (mi *MI) GetAge() int {\n  return mi.Age\n}\n```", "```go\nfunc New() *js.Object {\n  return js.MakeWrapper(&MI{})\n}\n```", "```go\nfunc main() {\n  //musicalInstruments is the namespace, 'New' is the available function\n  js.Global.Set(\"musicalInstruments\", map[string]interface{}{\n    \"New\": New,\n  })\n}\n```", "```go\ngopherjs build mi.go\n```", "```go\nrequire(\"./mi.js\");\n\nvar mi = musicalInstruments.New();\n\nmi.SetAge(20);\n\nconsole.log(mi.GetAge());\n```", "```go\ndocument.getElementById(\"myBtn\").addEventListener(\"click\", function(){\n    /*SOME BLOCKING CODE*/\n});\n```", "```go\njs.Global.Get(\"document\").Call(\"getElementById\", \"mybtn\").Call(\"addEventListener\",\"call\", func() {\n  go func() {\n        /*SOME BLOCKING CODE*/\n  }()\n})\n```", "```go\ngo get -u myitcv.io/react\n```", "```go\ngo get -u myitcv.io/react myitcv.io/react/cmd/reactGen\n```", "```go\n//In windows:\ncd %GOPATH%\\src\\myitcv.io\\react\\cmd\\reactGen\n\n//or in other operating systems:\ncd $GOPATH\\src\\myitcv.io\\react\\cmd\\reactGen\n```", "```go\nreactGen -help\n```", "```go\nreactGen -init minimal\n```", "```go\n// Template generated by reactGen\n\npackage main\n\nimport (\n  \"myitcv.io/react\"\n)\n\ntype AppDef struct {\n  react.ComponentDef\n}\n\nfunc App() *AppElem {\n  return buildAppElem()\n}\n\nfunc (a AppDef) Render() react.Element {\n  return react.Div(nil,\n    react.H1(nil,\n      react.S(\"Hello World\"),\n    ),\n    react.P(nil,\n      react.S(\"This is my first GopherJS React App.\"),\n    ),\n  )\n}\n```", "```go\nreact.Div(nil,\n    react.H1(nil,\n      react.S(\"Hello World\"),\n    ),\n    react.P(nil,\n      react.S(\"This is my first GopherJS React App.\"),\n    ),\n  )\n```", "```go\n<div>\n   <h1>Hello World</h1>\n   <p>This is my first GopherJS React App.</p> \n</div>\n```", "```go\nreact.Div(&react.DivProps{\n    ClassName:\"css_class_name\"\n  },...other_elements)\n```", "```go\nreact.P(nil, react.S(\"This is my first GopherJS React App.\"))\n```", "```go\nset GOOS=linux\n```", "```go\ngopherjs serve\n```", "```go\npackage hellomessage\n```", "```go\nimport \"myitcv.io/react\"\ntype HelloMessageDef struct {\n  react.ComponentDef\n}\n```", "```go\n//Naming convention is *props\ntype HelloMessageProps struct {\n  Message string\n}\n```", "```go\n//Naming convention is *State\ntype HelloMessageState struct {\n  CurrName string\n  Names []string\n}\n```", "```go\nfunc (c HelloMessageState) Equals(v HelloMessageState) bool {\n //compare CurrName between current and future states\n  if c.CurrName != v.CurrName {\n    return false\n  }\n  //compare Names between current and future states\n  /*there are other ways to compare slices, below is a very simplistic approach*/\n  if len(c.Names) != len(v.Names) {\n    return false\n  }\n\n  for i := range v.Names {\n    if v.Names[i] != c.Names[i] {\n      return false\n    }\n  }\n  return true\n}\n```", "```go\nfunc HelloMessage(p HelloMessageProps) *HelloMessageElem {\n  fmt.Println(\"Building element...\")\n  return buildHelloMessageElem(p)\n}\n```", "```go\nfunc (r HelloMessageDef) Render() react.Element {\n    return nil\n}\n```", "```go\nInputName := react.Input(&react.InputProps{\n    Type: \"text\",\n    Key: \"FirstName\",\n    Placeholder: \"Mina\",\n    Value: r.State().CurrName,\n    OnChange: r,\n  }, nil)\n```", "```go\nValue: r.State().CurrName,\nOnChange: r,\n```", "```go\nfunc (r HelloMessageDef) OnChange(e *react.SyntheticEvent) {\n  //we need to import \"honnef.co/go/js/dom\" for this to work\n  //get target: our input text HTML element\n  target := e.Target().(*dom.HTMLInputElement)\n  //get current state\n  currState := r.State()\n  //change state to include new value in our input text component, as well as the existing history of names\n  r.SetState(HelloMessageState{CurrName: target.Value, Names: currState.Names})\n}\n```", "```go\nInputBtn := react.Input(&react.InputProps{\n    Type: \"Submit\",\n    Value: \"Submit\",\n  }, nil)\n```", "```go\nForm := react.Form(&react.FormProps{\n    OnSubmit: r,\n  },\n    react.S(\"Name: \"),\n    InputName,\n    InputBtn)\n```", "```go\nfunc (r HelloMessageDef) OnSubmit(e *react.SyntheticEvent) {\n  //Prevent the default form submission action\n  e.PreventDefault()\n  //Add the new name to the list of names in the state object\n  names := r.State().Names\n  names = append(names, r.State().CurrName)\n  /*\n    Change the state so that the current name is now empty, and the new name gets added to the existing list of names\n  */\n  r.SetState(HelloMessageState{CurrName: \"\", Names: names})\n}\n```", "```go\n names := r.State().Names\n fmt.Println(names)\n entries := make([]react.RendersLi, len(names))\n for i, name := range names {\n   entries[i] = react.Li(nil, react.S(r.Props().Message+\" \"+name))\n  }\n  return react.Div(nil,\n    Form,\n    react.S(r.Props().Message+\" \"+r.State().CurrName),\n    react.Ul(nil, entries...),\n  )\n```", "```go\nfunc (r HelloMessageDef) Render() react.Element {\n  InputName := react.Input(&react.InputProps{\n    Type: \"text\",\n    Key: \"FirstName\",\n    Placeholder: \"Mina\",\n    Value: r.State().CurrName,\n    OnChange: r,\n  }, nil)\n  InputBtn := react.Input(&react.InputProps{\n    Type: \"Submit\",\n    Value: \"Submit\",\n  }, nil)\n  Form := react.Form(&react.FormProps{\n    OnSubmit: r,\n  },\n    react.S(\"Name: \"),\n    InputName,\n    InputBtn)\n  names := r.State().Names\n  fmt.Println(names)\n  entries := make([]react.RendersLi, len(names))\n  for i, name := range names {\n    entries[i] = react.Li(nil, react.S(r.Props().Message+\" \"+name))\n  }\n  return react.Div(nil,\n    Form,\n    react.S(r.Props().Message+\" \"+r.State().CurrName),\n    react.Ul(nil, entries...),\n  )\n}\n```", "```go\nfunc (a AppDef) Render() react.Element {\n  /*\n    Return a react div that hosts a title, as well as our custom hello message component\n  */\n  return react.Div(nil,\n    react.P(nil,\n      react.S(\"This is my first GopherJS React App.\"),\n    ),\n    react.H1(nil,\n      hellomessage.HelloMessage(hellomessage.HelloMessageProps{Message: \"Hello\"}),\n    ),\n  )\n}\n```"]