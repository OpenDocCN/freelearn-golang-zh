- en: Introduction to Isomorphic Go with GopherJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered how to write our frontend using JavaScript. However,
    if you prefer to use Go in the frontend, there is an option for that. This option
    is known as GopherJS, which is a popular Go package combined with a set of commands
    with only one purpose: to compile (also known as **transpiling**) Go code to JavaScript.
    Once Go code is compiled to JavaScript, the code could be utilized in the frontend
    component similarly to JavaScript. An application that relies on the same programming
    language for the frontend and the backend is known as an **isomorphic application**.'
  prefs: []
  type: TYPE_NORMAL
- en: Like any other software-design approach, writing isomorphic applications has
    its own pros and cons. The chief advantage is the convenience and speed of development
    that comes with using a single programming language that you are really good at
    for most of your code. The main disadvantage is the difficulty of troubleshooting
    non-trivial issues, since you will have to dive into the generated JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is an introduction to isomorphic web development. We will cover
    some of the key building blocks of GopherJS, and how you can make use of it to
    write code that can interact with both web browsers and Node.js modules. We will
    also cover how to write a simple React application powered by GopherJS, and some
    open source projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: GopherJS fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GopherJS with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will need the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go language installed ([https://golang.org/doc/install](https://golang.org/doc/install))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js and npm ([https://nodejs.org/en/](https://nodejs.org/en/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code editor, such as VS Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapter assumes familiarity with JavaScript, HTML, React, and Go.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not yet familiar with React, please have a look at [Chapter 3](72d04e99-a5af-4af9-b51a-54c4c750871f.xhtml), *Go
    Concurrency,* and [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go).
  prefs: []
  type: TYPE_NORMAL
- en: GopherJS fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GopherJS is a set of tools, data types, and Go packages that allows you to compile
    Go code to JavaScript. Compiling the code of one programming language to another
    is also known as **transpiling**. GopherJS is very useful for Go developers who
    are not very proficient in JavaScript, because it allows you to write code in
    Go that can be integrated with JavaScript modules. This means that you can write
    code in Go that empowers the frontend of your application, or can be integrated
    with Node.js modules, offering you the flexibility of JavaScript combined with
    the power of Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'GopherJS is a very a powerful piece of software that is used in numerous applications.
    However, in order to effectively utilize GopherJS, you need to understand its
    building blocks. The first step is to retrieve the package using the `go get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, to be able to run some of GopherJS commands, we need to install the `source-map-support`
    node module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to debug your code from Go when the need arises. This is very
    useful when writing non-trivial applications in GopherJS.
  prefs: []
  type: TYPE_NORMAL
- en: Great, now we are ready to explore the package a bit more. GopherJS provides
    a playground where you can test your GopherJS code at [https://gopherjs.github.io/playground/](https://gopherjs.github.io/playground/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that our GopherJS is set up, let's take a look at the GopherJS types.
  prefs: []
  type: TYPE_NORMAL
- en: GopherJS types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GopherJS includes a sub-package called `js`. This package provides the functionalities
    needed to bridge between Go and JavaScript. The package can be found at [https://godoc.org/github.com/gopherjs/gopherjs/js](https://godoc.org/github.com/gopherjs/gopherjs/js).
  prefs: []
  type: TYPE_NORMAL
- en: The key feature provided by the `js` package is the ability to transform Go
    types into JavaScript types, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we consider data types, there are two main categories that need to be
    supported: basic types (`int`, `float`, and `string`) and constructed types (structs
    and interfaces). The following table shows the type mappings between Go basic
    types and JavaScript types, as supported by GopherJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Go type** | **JavaScript type** |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `Boolean` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` and `float` | `Number` |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `String` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]int8` | `Int8Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]int16` | `Int16Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]int32`, `[]int` | `Int32Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]uint8` | `Uint8Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]uint16` | `Uint16Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]uint32`, `[]uint` | `Uint32Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]float32` | `Float32Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]float64` | `Float64Array` |'
  prefs: []
  type: TYPE_TB
- en: For example, if you utilize GopherJS to compile a piece of code that includes
    a Go `int` type into JavaScript, the `int` type will become a JavaScript `Number` type.
    It is recommended that you stick with the `int` type, instead of the `uint8`/`uint16`/`uint32`/`uint64`
    types, to improve performance of your transpiled code. It is also recommended
    to use `float64` over `float32`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the different GopherJS types, let's move on to object types.
  prefs: []
  type: TYPE_NORMAL
- en: Object types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic types are good; however, they are just a simple component of any real
    piece of code. What about Go structs, interfaces, methods, functions, and goroutines?
    The `js` package gives you the power to convert those types to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key building blocks provided by the `js` package is the `*js.Object`
    type. This type is simply a container for a native JavaScript object. Most of
    GopherJS's code involves converting Go objects to `*js.Object` or vice versa.
    JavaScript modules are exposed as `*js.Object` in our Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how to call JavaScript functions from our Go code in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Calling JavaScript functions from your Go code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, JavaScript code runs either on Node.js or in the browser. Any code
    that runs on Node.js should have access to what is known as *Node.js* g*lobal
    objects* ([https://nodejs.org/api/globals.html](https://nodejs.org/api/globals.html)).
    If your code ends up running on a Node.js environment, GopherJS gives you access
    to the global objects using the `js.Global` variable, which returns a `*js.Object`
    that hosts your global variables. You can then access a specific object using
    a method called `Get`, then call the object methods using a method called `Call`.
    Let's see an example to better explain this paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the equivalent of writing a piece of Node.js JavaScript code that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `js.Global` object opens up very interesting possibilities, as it allows
    you to access Node.js modules and use them in your Go code. For example, let''s
    assume we imported a Node.js module called `prettyjson` to our node project, and
    we would like to use it in our Go code. `prettyjson` is a real package, it has
    a method called `render()`, which converts objects to beautiful-looking JSON.
    This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, JavaScript code can also run on a browser. The globals available
    to the browser are different. For example, the following piece of code will run
    fine on a browser, but won''t be happy if you try to run it with Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That is because `"document"` is a global object available for almost all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at the GopherJS commands.
  prefs: []
  type: TYPE_NORMAL
- en: GopherJS commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have enough knowledge to start exploring the commands provided by GopherJS
    in order to compile Go code into JavaScript. For any GopherJS command you run,
    make sure the `GOOS` flag is set to either `darwin` or `linux`. If you are running
    on Windows, you''ll need to run the following command from the Terminal session
    expected to run GopherJS''s commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here is what we need to do next—let's start by getting an environment ready.
    After installing GopherJS and the `source-map-support` module, as covered earlier
    in *GopherJS fundamentals* section, create a new folder inside your Go `src` folder
    that is in your `GOPATH`. Let's name the new folder `9-Isomorphic-GO`. Inside
    the new folder, create another folder called `node`. This is where we'll write
    our code that is expecting to interface with node packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a file called `main.go` inside the `node` folder. Then type the
    following code into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to use the power of GopherJS to convert the preceding code
    into JavaScript. This can simply be done using the `gopherjs build` command. So
    in the console, navigate to the `node` folder, then type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new file called `main.js`, which will host your converted
    JavaScript code. You will notice that the `main.js` file has a lot of JavaScript
    code. This is because GopherJS re-implements key pieces of Go runtime in the generated
    JavaScript file, in order to be able to support a large number of Go apps and
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other Node.js file, you can simply run JavaScript code in the new
    file by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'GopherJS also supports the `install` command. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Doing so will produce a JavaScript file in your `bin` folder. This is similar
    to what the `go install` command would do, except that the result in this case
    is a JavaScript file, not an executable file.
  prefs: []
  type: TYPE_NORMAL
- en: The GopherJS commands support a flag that allows us to output minified JavaScript,
    this flag is `-m`. Minifying JavaScript involves removing all unnecessary characters,
    such as white spaces, new line characters, and comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to run the code directly, and you already have Node.js''s `source-map-support` module
    installed, you can simply use the `gopherjs run` command, so it would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What if we want to try some browser code?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the parent folder we created, it was called `9-Isomorphic-GO`.
    Under that folder, create a new folder called `browser`, then underneath, create
    a new file called `main.go`. Inside the `main.go` file, write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is obviously expected to run on the browser, since it makes
    use of the `document` object. We can still utilize `gopherjs build` here in order
    to convert it into JavaScript. However, we have another option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command at the `browser` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A web server will be started, which, by default, will serve your generated files
    at the `localhost:8080` address. Any changes you make to the `main.go` file will
    be reflected in the web-served page; however, you will probably need to refresh
    the web page to see changes.
  prefs: []
  type: TYPE_NORMAL
- en: If your Go code exists in a subfolder from where you run the `gopherjs serve`
    command, your page will get served at `localhost:8080/your/sub/folder`, where
    `your/sub/folder` refers to the folder path to your `main.go` file. So for example,
    if your code is at `/test/main.go`, your page will get served at `localhost:8080/test`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discover the bindings between Go and JavaScript that GopherJS provides
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: Go bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've looked at how to embed JavaScript packages into our Go code through
    GopherJS. However, that can get tedious, especially since there are lots of shared
    functionalities between JavaScript and Go packages. Luckily, GopherJS supports
    the conversion of most of Go's standard packages into JavaScript. The list of
    compatible Go packages can be found at [https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md](https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md).
  prefs: []
  type: TYPE_NORMAL
- en: Some of the packages, such as the `os` package, are only supported in Node.js
    environments. This is because most of the package operations are not meant for
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you look at the list of compatible Go packages, you''ll find
    the `encoding/csv`, `fmt`, and `string` packages as some of the supported packages.
    Let''s write the following program in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the code is compiled with GopherJS, it will generate a JavaScript file that
    will produce the same result. This is a very powerful feature in GopherJS, as
    we didn't even need to import GopherJS packages in this project to make it compatible
    with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to export JavaScript modules from Go code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with GopherJS, an interesting use case is writing code modules
    in Go that are then expected to be used by JavaScript module.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explore how to export JavaScript modules that originated from Go code,
    let's go through some vanilla JavaScript code in order to gain a simple understanding
    of how module exporting works in the language.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our `node` folder, create a new folder called `calc`. In that folder,
    we'll write a simple JavaScript module that will allow us to add and/or subtract
    some numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `calc` folder, create a file called `addsub.js`. There, we''ll create
    two functions, `add()` and `sub()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step needed is to export these two functions so that other JavaScript
    modules can make calls to them. This is done by assigning the two functions to
    `modules.exports`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will expose the two functions as `Add()` and `Sub()`, so
    that they can be imported and called by other JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `calc.js`. This is where we''ll call the exported
    functions from the `addsub.js` file. To access the exported functions from `addsub.js`,
    we just need to execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then very simply execute our exported functions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then print the output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, how can we write an equivalent code to the `addsub.js` module in Go?
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s simple—we start by writing our functions in Go. Let''s create a new file
    called `addsubgo.go`, and in there, write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in Go''s main function, we''ll utilize a variable provided by GopherJS,
    which is called `js.Module`. This variable gives you access to the `module` variable
    set by Node.js. Let''s type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It will be equivalent to `module.exports` in the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most of GopherJS''s variables, `js.Module` is of the `*js.Object` type,
    which basically means that we can call `Get` or `Set` on it to get or set objects.
    Consider the following code in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is equivalent to the following code in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And that is the key piece of knowledge you need to write exportable JavaScript
    code in Go through GopherJS. Here is how the whole Go file would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to build the preceding code through GopherJS in order to compile
    it into JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a new file called `addsubgo.js`, which we can now import
    or use with other JavaScript files. If we go back to `calc.js`, we can change
    it a bit to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will produce the same result we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to write a function that expects an object or a number of objects
    as arguments? Take this one, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple function that takes an object as an argument. It then
    returns a `string`, which includes the object fields. The object expects to contain
    two fields: `first` and `second`. When this function gets called, we will need
    to pass an object as an argument to it. Here is how calling the function looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Writing the equivalent code in Go is very easy, thanks to GopherJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Go is a statically-typed programming language, first we need to define
    the data type of our object argument. Let''s continue to write code in the `addsubgo.go`
    file. Here is how this looks in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `struct` type was built with two rules in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Embed the `*js.Object` type in the Go struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the `js` struct tag for any field name expected to be converted to JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perfect—the next step is to write our function in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This function will be capable of translating to JavaScript using GopherJS, thanks
    to the fact that we followed the two rules when creating the `Obj` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we export the `FormatNumbers()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once we build this code using the `gopherjs build addsubgo.go` command, our
    new function will callable from JavaScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to export our code, let's take a look at Go methods and
    goroutines in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Go Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we want to expose a Go type with methods to JavaScript?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore a Go type. The following code has a `struct` type that represents
    a musical instrument, and has some `getter` and `setter` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's say we want this type to be accessible to JavaScript code. GopherJS comes
    to the rescue with a function called `js.MakeWrapper()`. This function can take
    a Go type as an argument, and it then returns a `*js.Object` that represents the
    Go type with all its exportable methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a constructor for our `MI` `struct` type. It will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `main` function, we can make this constructor available to JavaScript
    by adding it to the `Global` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create a JavaScript function called `New()`, under a
    namespace called `musicalInstruments`.
  prefs: []
  type: TYPE_NORMAL
- en: We could have made the `New()` constructor available through a module export,
    through the `js.Module` variable. But for simplicity, it's added to the `Global`
    object for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that the filename where this code is hosted is called `mi.go`.
    The GopherJS command to compile this code to JavaScript will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A new file called `mi.js` will get generated, JavaScript can simply access
    the `MI` `struct` type by importing the file, then call the `New()` function from
    the `musicalinstruments` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new musical instrument object. We can then set its age. Finally,
    we get the age and log it to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GopherJS supports goroutines, so you can use goroutines in your Go code, and
    GopherJS will take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: One important requirement is that goroutines must be used if you need to call
    some blocking code from an external JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following JavaScript code running in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a callback function that is expected to execute when
    a button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how this should be handled in Go with the help of GopherJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, we had to use a goroutine inside the
    event listener callback code, because it was expected to run some blocking code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the fundamentals of GopherJS, let's use GopherJS with React.
  prefs: []
  type: TYPE_NORMAL
- en: GopherJS with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*, we covered the powerful and popular React.js framework. Due to
    the power of GopherJS, there are now several open source projects that allow you
    to write React applications in Go. In this chapter, we'll cover one of these open
    source projects with the aid of an example, to offer us an idea about how to build
    a practical React application using Go.
  prefs: []
  type: TYPE_NORMAL
- en: The project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll build a very simple interactive web app using React.
    The app contains an input text and a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00d4d58b-f10f-4e03-8da2-06db08a5db26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Whenever we type a name and then hit Submit, it gets added to a list on the
    screen, with the word Hello next to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11a98fe7-b9f0-4f1b-8d88-81ed0e6660c9.png)'
  prefs: []
  type: TYPE_IMG
- en: The text input is interactive. So, as you type text, it will display on the
    screen in real time. This is the kind of reactivity that React is known for.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the project architecture in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The project application's architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The React application we are about to implement is simple, so we will not need
    more than one component. Our single component will include the input text, the
    Submit button, the interactive text, and the list of names. Here is our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/820e90a8-325d-4c39-b750-f860dfd1e5d3.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to cover all the key React concepts in this section, our component
    will make use of React elements, state, props, and forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form will consist of the input text and the Submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b60bdfcc-5421-4f9b-9a34-de2240eec749.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our React `state` object will host two values:'
  prefs: []
  type: TYPE_NORMAL
- en: The current name being written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The list of names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/28060daf-4b2e-43b9-b777-f7e390c16613.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The prop value for our component will be the generic message that shows up
    next to the displayed name. In other words, our prop is the word Hello:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/baded1ec-7703-4562-91c0-b83211c1f730.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go ahead and build this React application in Go in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building the React application in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to start writing our React application in Go. We will make use
    of a popular package known as `myitcv.io/react`. This package offers some GopherJS
    bindings for the React framework. The package documentation can be found at [https://github.com/myitcv/x/tree/master/react](https://github.com/myitcv/x/tree/master/react).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is retrieve the `myitcv.io/react` package, in
    order to use it in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve a tool called `reactGen`, this tool facilitates building React applications
    in Go. It can be used to auto-build skeleton applications that act as building
    blocks for more complex applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a Terminal window, then navigate to the `reactGen` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Type the `go install` command. This should compile and deploy the `reactGen`
    tool to the `%GOPATH%\bin` folder. Make sure that path is present in your `PATH`
    environmental variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command to inspect whether `reactGen` is installed yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `reactGen` is installed, we are ready to write our application. Go to
    the `9-Isomorphic-Go` folder. Inside, we''ll create a new folder called `reactproject`.
    In the Terminal, navigate to the `reactproject` folder, then type the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a skeleton for our React application. Let''s explore the generated
    app—there are four files inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.go`: The entry point for our app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.html`: The entry HTML file for our app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.go`: The `App` component of our React application—this will be the first
    component to get rendered in our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gen_App_reactGen.go`: This file is auto-generated from `app.go`. For any component
    we write, some auto-generated code will get created afterward, which will contain
    all the plumbing code needed to make our component work. This code generation
    allows us to focus only on building the important pieces in our React components,
    such as props, states, and elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we start writing our React component, let''s explore the `App` component
    that we created in the `app.go` file, with the `reactGen` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a Go struct called `AppDef`, which acts as a React
    component. In order for a Go `struct` type to qualify as a React component, it
    needs to satisfy three requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go struct name must have the `Def` suffix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go struct has to embed the `react.ComponentDef` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `struct` type must implement the `Render()` method, which acts as the equivalent
    of the React's `render()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to React.js, the `Render()` method has to return React elements. The `myitcv.io/react`
    framework offers methods that correspond to React elements. From the preceding
    code, we see that `Render()` returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code corresponds to the following React JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Each one of the JSX elements corresponds to a `react.<element type>` function
    in Go. There were a total of three elements. The first is the `<div>` element,
    which hosted the other two elements. In Go, this translated to `react.Div(nil,...other_elements)`.
    The first argument is our element''s props. Since we didn''t include any props,
    the first argument ended up being `nil`. If we needed to add a React prop—let''s
    say, the `className` prop—it can simply be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The second element is the `h1` element. In Go, we represented it as `react.H1(nil,react.S("Hello
    World"))`. The first argument represents props passed to the element. The `react.S("")`
    function simply represents a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third element is the `P` element. In Go, it looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see this code in action. Set the `GOOS` environmental variable
    to `linux` if you''re using Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'From our `reactproject` folder, run the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This will serve our React application on port `8080`. If we open a web browser
    and visit `localhost:8080/<the Go project folder from src>`, we''ll be greeted
    with this simple application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6704b900-8cee-410a-8926-a8cd8e7894ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are ready to build our custom component, which we will do in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Under the `reactproject` folder, create a new folder called `hello_message`.
    Inside the folder, we''ll create a new file called `hello_message.go`. In the
    file, we will call the `hellomessage` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a Go struct to represent our React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to define our props. This can simply be done by a `struct`
    type that contains our expected props. As mentioned, our prop is the message string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining a `state` object is very similar to props. A `struct` type needs to
    be created with the expected React `state` object fields. Our `state` object fields
    are the current name being written to the text input, as well as the list of names
    written so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js,* the React framework makes a decision to re-render your component
    whenever React detects that the `state` object has changed. Since our `state`
    object here contains a Go slice, future and current states cannot simply be compared
    using an `==` operator. In this case, it''s strongly recommended to provide React
    with a way to decide whether the React object has changed. This is done using
    the `Equals` method, which is implemented by the `state` Go struct. Here is how
    this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we need to run the `go generate` command from the Terminal to
    generate some helper code that we can use to write the rest of our component.
    After you run the `go generate` command, you will notice that a new file, called
    `gen_HelloMessage_reactGen.go`, was generated for us. Do not edit this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated file will provide a new data type for you to use: `*HelloMessageElem`.
    This type represents our component''s React element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our code inside `hello_message.go`, the next step is to write
    a constructor for our new React component. The constructor will need to take props
    as an argument, and returns the React element as a result. Here is how this will
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Since our code gets compiled to JavaScript through GopherJS, the `fmt.Println()`
    function will get translated to `console.log()`, as covered in the *Go bindings*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define the `Render()` method of our component. The `Render()`
    method needs to be defined in a non-pointer type of our component Go struct. Here
    is an empty `Render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have to fill up the `Render()` method with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A form that includes an input text box, and a Submit button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string to host the name currently being written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of strings to represent a history of the names entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a refresher, have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4b82c02-079f-416a-9664-d2aac373cc8f.png)'
  prefs: []
  type: TYPE_IMG
- en: The red rectangles represent our React states, the green rectangles represent
    our props, and the blue rectangle represents our entire React component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our `Render()` method, first, we need to write the text input
    element. It''s an HTML form input element of the `"text"` type. Here is how this
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code represents a React `input` element, courtesy of the `myitcv.io/react`
    package.  The first argument is the props for the input element; the second argument
    is `nil`, because we don''t need any children for this element. The input props
    are the same as the ones we used in the JSX format. There are two notable props
    that we used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `Value` prop is the current value of the input text. By assigning the `State`
    object of the `CurrName` field to the input text `Value` field, we've guaranteed
    that the input text will change based on the name you enter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OnChange` prop represents the action taken whenever a change happens to
    our input text. The prop must point to a type that implements the `OnChange(event)`
    method. Since we assign `r` to it, we must implement `OnChange`. Here is how this
    will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go React framework provides a type called `*react.SyntheticEvent`, which
    represents the event getting passed to the `OnChange` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We retrieve the value of the text being written to the input text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We retrieve our current React state. This is done using the `State()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We change our React state to represent the new name. This is done using the
    `SetState()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s go back to our `Render()` method. The next step is to write the
    Submit button component. It is also an HTML form input element, but it''s of the `"Submit"` type.
    An HTML form input element of the `"Submit"` type is a button. Whenever the Submit
    button gets pressed, the form will get submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to write our React form. The form element will act as a parent
    element for both the text and the button elements. Our form element will also
    host a `"Name:"` string.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, whenever the Submit button gets pressed, the form will
    be submitted. Typically, when an HTML form gets submitted, its input data is sent
    to the server, where the form's input data gets processed. In our case, we want
    to capture the submission event, and then instead of the form submission's default
    behavior, we want to change our `state` object to add the new input name to our
    `state.Names` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we delve more into how to define the actions taken on form submission,
    let''s go back to the `render` method, and define our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we defined an `OnSubmit` React form prop. This is how we define
    the actions taken on form submission in our Go code. The data type we pass to
    the `OnSubmit` prop must implement a method with the `OnSubmit(*react.SyntheticEvent)` signature. Let''s
    implement this method in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect—now we just need to finish the `Render()` method. Here are the remaining
    tasks for our custom form''s `Render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of saved names in our `state` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each saved name in the list, convert it to an `Li` element. This is a form
    list element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return a `Div` object, which contains the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The defined form
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A  string with the prop message, combined with the current name saved in the
    `state` object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of existing names
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how the rest of the code will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the entire `Render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run `go generate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our component is done; however, there is still some work left. We need to call
    our newly-created component from the `App` component, located in the `app.go`
    file. This will be done using the `HelloMessage(p HelloMessageProps) *HelloMessageElem` constructor,
    which we created before. The constructor takes the props as an argument and returns
    our custom component React element. The code we need to modify is under the `Render()`
    method of our `App` component. The prop object contains a field called `Message`.
    The value of the message we would like to pass is simply `"Hello"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: That's it for our code. If you run the `gopherjs serve` command from your Terminal
    at the `reactproject` folder, the project will be accessible in the browser at
    the `localhost:8080/<your project folder from src>` address.
  prefs: []
  type: TYPE_NORMAL
- en: When you are ready to transpile your React project to JavaScript, simply run
    the `gopherjs build` command from the `reactproject` folder. This will generate
    a `reactproject.js` file that can be used from the `index.html` file in your project
    folder. If you look at the `index.html` file in your project folder, you will
    find that it references a script called `reactproject.js`. If you open `index.html`
    from a browser after performing the build step, you will find your application
    working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on building isomorphic applications using Go. We
    covered some key topics regarding converting Go code into JavaScript code. We
    dove into Go bindings in GopherJS, and considered how it can empower us to bridge
    the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: We also made use of the GopherJS framework to build Go applications that integrate
    with JavaScript, whether at the frontend or on the server side. We explored important
    topics, such as concurrency and methods.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the Go React framework, and went through the process of building
    a simple React application in Go.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover topics such as cloud-native applications and
    the React Native framework so that you can further hone your skills.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does transpling mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is GopherJS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `*js.Object` type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `js.Global` variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `js.Module` variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `js.MakeWrapper()` function do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `js` Go struct tag do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main steps to build a React component in Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, check out the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GopherJS**: [https://github.com/gopherjs/gopherjs](https://github.com/gopherjs/gopherjs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GopherJS with React**: [https://github.com/myitcv/x/tree/master/react/_doc](https://github.com/myitcv/x/tree/master/react/_doc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating a GopherJS React app**: [https://github.com/myitcv/x/blob/master/react/_doc/creating_app.md](https://github.com/myitcv/x/blob/master/react/_doc/creating_app.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GopherJS React examples**: [https://blog.myitcv.io/gopherjs_examples_sites/examplesshowcase/](https://blog.myitcv.io/gopherjs_examples_sites/examplesshowcase/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
