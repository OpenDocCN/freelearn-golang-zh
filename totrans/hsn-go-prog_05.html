<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Maps and Arrays</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter<span>, you will learn how to work with maps and arrays in Go.</span> <span>You will see practical examples of manipulating and iterating arrays, merging arrays and maps, and testing whether a key is present in a map</span>. We will go through the following recipes in this chapter:</p>
<ul>
<li>Extracting unique elements from a list</li>
<li>Finding an element from an array</li>
<li>Reverting an array</li>
<li>Iterating over an array</li>
<li>Converting a map into an array of keys and values</li>
<li>Merging arrays</li>
<li>Merging maps</li>
<li>Testing for the presence of a key in a map</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting unique elements from an array</h1>
                </header>
            
            <article>
                
<p class="mce-root">First, we are going to learn how to extract unique elements from a list. To begin, let's imagine we have a slice, containing duplicate elements in it.</p>
<p class="mce-root">Now, let's say that we want to extract the unique elements. Since we don't have a built-in construct in Go, we're going to make our own function that will do the extraction. <span>So, we have the </span><kbd>uniqueIntSlice</kbd><span> </span>function and it accepts <kbd>intSlice</kbd> or <kbd>intarray</kbd>. Our unique function will accept <kbd>intSlice</kbd> and it will return another slice.</p>
<p class="mce-root"/>
<p class="mce-root">So, the idea of this function is to track the duplicate elements in a separate list and if an element reappears in our given list, then we're not going to add that element to our new list. Now, check out the following code:</p>
<pre>package main<br/>import "fmt"<br/>func main(){<br/>  intSlice := []int{1,5,5,5,5,7,8,6,6, 6}<br/>  fmt.Println(intSlice)<br/>  uniqueIntSlice := unique(intSlice)<br/>  fmt.Println(uniqueIntSlice)<br/>}<br/>func unique(intSlice []int) []int{<br/>  keys := make(map[int]bool)<br/>  uniqueElements := []int{}<br/>  for _,entry := range intSlice {<br/>    if _, value := keys[entry]; !value{<br/>      keys[entry] =true<br/>      uniqueElements = append(uniqueElements, entry)<br/>    }<br/>  }<br/>  return uniqueElements<br/>}</pre>
<p class="mce-root">So, we're going to have <kbd>keys</kbd>, which is basically a map, known as a dictionary in other languages. We'll have another slice that keeps our <kbd>uniqueElements</kbd>, and we will do a <kbd>for each</kbd> loop to iterate over each element and add it to our new list if it is not a duplicate. We basically get our value by passing an <kbd>entry</kbd>; if the value is <kbd>false</kbd>, then we add that entry to our key or our map and set its value to <kbd>true</kbd> so that we can see whether this element already appears in our list. We also have a <span>built-in  </span><kbd>append</kbd> function that accepts a slice and also appends the entry to the end of our slice, which returns another slice. On running the code, you should obtain the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-728 image-border" src="assets/2c9e9a14-96fe-4b83-8ff2-7c2f67227f16.png" style="width:26.00em;height:15.25em;"/></p>
<p class="mce-root"/>
<p class="mce-root">If you look at the first array, there are duplicate elements: multiple instances of <kbd>6</kbd> and <kbd>5</kbd>. In our new array or slice, we don't have any duplicates, and that's how we extract unique elements from a list.</p>
<p class="mce-root">In the next section, we're going to learn how to find an element from an array in Go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding an element from an array</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to learn how to find an element from an array or a slice. There are many ways you can do this, but we're going to cover two of them in this chapter. Imagine that we have a variable that holds a slice of strings. The first way of searching for a particular string in this slice will be using a <kbd>for</kbd> loop:</p>
<pre>package main<br/>import (<br/> "fmt"<br/> "sort"<br/>)<br/>func main() {<br/> str := []string{"Sandy","Provo","St. George","Salt Lake City","Draper","South Jordan","Murray"}<br/> for i,v := range str{<br/> if v == "Sandy" {<br/> fmt.Println(i)<br/> }<br/> }<br/>}</pre>
<p>On running the preceding code, we find the word <kbd>Sandy</kbd> at index <kbd>0</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-729 image-border" src="assets/04364147-9fe6-462e-8079-69aa08775fe6.png" style="width:25.75em;height:15.08em;"/></p>
<p class="mce-root"/>
<p>The other approach is to use sorting, where we can sort the slice first and then search for a particular item afterwards. In order to do that, Go provides a <kbd>sort</kbd> package. To be able to sort a slice, the slice needs to implement various methods that the <kbd>sort</kbd> package needs. The <kbd>sort</kbd> package provides a type called <kbd>sort.stringslice</kbd>, and what we can do is convert our <kbd>stringslice</kbd> to the <kbd>StringSlice</kbd> type provided by <kbd>sort</kbd>. Here, <kbd>sortedList</kbd> is not sorted, so we have to sort it explicitly. Now, check out the following code:</p>
<pre>package main<br/>import (<br/>  "fmt"<br/>  "sort"<br/>)<br/>func main() {<br/>  str := []string{"Sandy","Provo","St. George","Salt Lake City","Draper","South Jordan","Murray"}<br/>  for i,v := range str{<br/>    if v == "Sandy" {<br/>      fmt.Println(i)<br/>    }<br/>  }<br/>  sortedList := sort.StringSlice(str)<br/>  sortedList.Sort()<br/>  fmt.Println(sortedList)<br/>}</pre>
<p>The code will give the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-730 image-border" src="assets/484a6d9d-267e-4450-ae74-4d1e856e821a.png" style="width:45.42em;height:15.42em;"/></p>
<p class="mce-root"/>
<p>You can see that <kbd>Draper</kbd> comes first and then <kbd>Murray</kbd>, and it is basically sorted in ascending order. Now, to search for a particular item here, for example <kbd>Sandy</kbd>, just add the following lines of code in the <kbd>main</kbd> function:</p>
<pre>index := sortedList.Search("Sandy")<br/>fmt.Println(index)</pre>
<p>The following output is obtained after running the whole code:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-731 image-border" src="assets/5f078198-f4e9-4361-a7e8-db94193a14d3.png" style="width:46.00em;height:15.33em;"/></p>
<p>It outputs <kbd>4</kbd>, which is the placing of the word <kbd>Sandy</kbd>. That's how you find an element in an array. The same thing applies to numbers as well; for instance, if you look at the <kbd>sort</kbd> package, you'll find <kbd>IntSlice</kbd> as well. Using integer slices really simplifies all the sorting and searching operations for numbers. In our next section, we're going to see how to revert an array.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reverting an array</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to learn how to reverse sort an array. We'll have a variable that holds a slice of numbers. Since you are now familiar with the <kbd>sort</kbd> package in Go, you'll know that the <kbd>sort</kbd> package provides a lot of functionality that we can use to sort arrays and slices. If you look at the <kbd>sort</kbd> package, you'll see many types and functions. </p>
<p class="mce-root"/>
<p>Now, we need the <kbd>sort</kbd> function and it accepts an interface, and this interface is defined in the <kbd>sort</kbd> package; therefore, we can call it the <kbd>Sort</kbd> interface. We are going to convert our <span>slice</span><span> of </span><span>numbers into an interface. Check out the following code:</span></p>
<pre>package main<br/>import (<br/>  "sort"<br/>  "fmt"<br/>)<br/>func main() {<br/>  numbers := []int{1, 5, 3, 6, 2, 10, 8}<br/>  tobeSorted := sort.IntSlice(numbers)<br/>  sort.Sort(tobeSorted)<br/>  fmt.Println(tobeSorted)<br/>}</pre>
<p>This code will give you the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-732 image-border" src="assets/5408e565-0603-4b8d-b016-f488a25c5eae.png" style="width:22.92em;height:13.42em;"/></p>
<p>If you look at the output, you'll see that we have sorted the numbers in ascending order. What if we want to sort them in descending order? To be able to do that, we have another type called <kbd>Reverse</kbd>, which implements different functions to sort things in descending order. Check out the following code:</p>
<pre>package main<br/>import (<br/>  "sort"<br/>  "fmt"<br/>)<br/>func main() {<br/>  numbers := []int{1, 5, 3, 6, 2, 10, 8}<br/>  tobeSorted := sort.IntSlice(numbers)<br/>  sort.Sort(sort.Reverse(tobeSorted))<br/>  fmt.Println(tobeSorted)<br/>}</pre>
<p>On running the code, we obtain the following output and you'll see that the numbers are arranged in descending order:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-733 image-border" src="assets/a92c26d9-a869-495f-b7f1-404564a40df3.png" style="width:25.75em;height:15.33em;"/></p>
<p>In the next section, we're going to see how we can iterate over an array.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterating over an array</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to learn how to iterate over an array. Iterating over an array is one of the most fundamental and common operations in Go programming. Let's go to our editor and see how we can do it <span>easily</span><span>:</span></p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main(){<br/>  numbers := []int{1, 5, 3, 6, 2, 10, 8}<br/><br/>  for index,value := range numbers{<br/>     fmt.Printf("Index: %v and Value: %v\n", index, value)<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We obtain the following output from the preceding code:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-734 image-border" src="assets/3ee49dac-df50-42af-bf76-1874d827de22.png" style="width:25.92em;height:16.92em;"/></p>
<p>That's how easily you can iterate over various types of slice, including string slices, byte slices, or byte arrays.</p>
<p>Sometimes, you won't need the <kbd>index</kbd>. In that case, you can just ignore it by using underscore (<kbd>_</kbd>). This will mean that you're only interested in the value. To carry this out, you can type in the following code:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main(){<br/>  numbers := []int{1, 5, 3, 6, 2, 10, 8}<br/>  for _,value := range numbers{<br/>    // fmt.Printf("Index: %v and Value: %v\n", index, value)<br/>    fmt.Println(value)<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The output of this code will be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-735 image-border" src="assets/b70f4a9a-ee1f-4338-8d5f-37f7a7b02984.png" style="width:26.00em;height:17.00em;"/></p>
<p>That's how you can easily iterate over various types of slice. In the next section, we're going to see how we can convert a map into an array of keys and values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting a map into an array of keys and values</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to see how to convert a map into an array of keys and values. Let's imagine a variable named <kbd>nameAges</kbd> that has <kbd>map</kbd>, as shown in the following code block, and we map string values to integer values. There are names and ages too.</p>
<p>We need to add a new struct named <kbd>NameAge</kbd> and it will have <kbd>Name</kbd> as a string and <kbd>Age</kbd> as integer. We are going to iterate over our <kbd>nameAges</kbd> map now. We'll be using a <kbd>for</kbd> loop and when you use a range operator on a map type, it returns two things, a key and the value. So, let's write this code:</p>
<pre>package main<br/>import "fmt"<br/>type NameAge struct{<br/>  Name string<br/>  Age int<br/>}<br/>func main(){<br/>  var nameAgeSlice []NameAge<br/>  nameAges := map[string]int{<br/>    "Michael": 30,<br/>    "John": 25,<br/>    "Jessica": 26,<br/>    "Ali": 18,<br/>  }<br/>  for key, value := range nameAges{<br/>    nameAgeSlice = append(nameAgeSlice, NameAge {key, value})<br/>  }<br/><br/>  fmt.Println(nameAgeSlice)<br/><br/>}</pre>
<p>On running the preceding code, you'll obtain the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-736 image-border" src="assets/25a71f49-0975-4bdc-8a4f-d0b45c58ccd2.png" style="width:33.33em;height:15.25em;"/></p>
<p>This is how you can easily convert a map into an array. In the next section, we're going to learn how to merge arrays in Go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merging arrays</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to see how to merge two arrays easily in Go. Consider that we have two arrays and we are going to merge them. If you used <kbd>append</kbd> earlier, you will know that it can accept as many parameters as required. Let's check the following code:</p>
<pre>package main<br/>import "fmt"<br/>func main(){<br/>  items1 := []int{3,4}<br/>  items2 := []int{1,2}<br/>  result := append(items1, items2...)<br/>  fmt.Println(result)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>On running the following code, you will obtain the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-737 image-border" src="assets/f122f01d-3833-498a-b4de-ed35626bda0b.png" style="width:26.17em;height:15.25em;"/></p>
<p>Now, we can see <kbd>[3 4 1 2]</kbd> in our output. You can add more values to the arrays and still merge them. This is how we can easily merge two arrays in Go. In the next section, we're going to see how to merge maps this time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merging maps</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to learn how to merge maps. Check out the two maps in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-738 image-border" src="assets/3c48d9be-6bf9-4d6a-b7b5-feac3fd561c4.png" style="width:18.33em;height:17.17em;"/></p>
<p>As you can see, there are four items, and the maps are basically mapping a string to an integer.</p>
<p class="mce-root"/>
<div class="packt_infobox">If you don't use a comma, as shown after <kbd>22</kbd> in the preceding screenshot, you'll get a compile-time exception. This is because of the automatic addition of a semicolon in Go, which is not appropriate in this code.</div>
<p>Okay, so let's go ahead and merge these two maps together. Unfortunately, there's no built-in way of doing this, so all we have to do is just to iterate these two maps and then merge them together. Check out the following code:</p>
<pre>package main<br/>import "fmt"<br/>func main(){<br/>  map1 := map[string]int {<br/>   "Michael":10,<br/>   "Jessica":20,<br/>   "Tarik":33,<br/>   "Jon": 22,<br/>  }<br/>  fmt.Println(map1)<br/><br/>  map2 := map[string]int {<br/>    "Lord":11,<br/>    "Of":22,<br/>    "The":36,<br/>    "Rings": 23,<br/>  }<br/>  for key, value := range map2{<br/>    map1[key] = value<br/>  }<br/>  fmt.Println(map1)<br/>}</pre>
<p>The output for the preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-739 image-border" src="assets/b5759f76-ccad-406c-892b-7567588ef0c4.png" style="width:48.50em;height:15.17em;"/></p>
<p class="mce-root"/>
<p>Okay, so the first line, as you can see, has only the initial elements that we used, and the second one contains basically everything, that is, all the items from <kbd>map2</kbd> as well. So, that's how you can quickly merge two maps into one. In the next section, we're going to learn how to test for the presence of a key in a map.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing for the presence of a key in a map</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to see how to check whether a key exists in a given map. So we have a map, <kbd>nameAges</kbd>, which basically maps names to ages. Check out the following code:</p>
<pre>package main<br/>import "fmt"<br/>func main() {<br/>  nameAges := map[string]int{<br/>    "Tarik": 32,<br/>    "Michael": 30,<br/>    "Jon": 25,<br/>  }<br/><br/>  fmt.Println(nameAges["Tarik"])<br/>}</pre>
<p>As you can see from the following screenshot, we basically fetched the value from the <kbd>Tarik</kbd><span> </span><span>key</span><span>. Therefore, it returned only one value, which was <kbd>32</kbd>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-740 image-border" src="assets/233df873-945f-418d-809e-98e38d7d60ab.png" style="width:26.42em;height:15.17em;"/></p>
<p class="mce-root"/>
<p>However, there's another way of using this map that returns two things: the first is the value and the second is whether the key exists. For instance, check out the following code:</p>
<pre>package main<br/>import "fmt"<br/>func main() {<br/>  nameAges := map[string]int{<br/>    "Tarik": 32,<br/>    "Michael": 30,<br/>    "Jon": 25,<br/>  }<br/><br/>  value, exists := nameAges["Tarik"]<br/>  fmt.Println(value)<br/>  fmt.Println(exists)<br/>}</pre>
<p>The output will be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-741 image-border" src="assets/4b64a2b0-285c-4827-b8a1-6dd206e0055c.png" style="width:25.83em;height:15.25em;"/></p>
<p>As you can see, the code returns <kbd>true</kbd> because <kbd>Tarik</kbd>, present in the map, exists in <kbd>nameAges</kbd>. Now, what if we type a name that does not exist in the map? If we replace <kbd>Tarik</kbd> with <kbd>Jessica</kbd> in <kbd>nameAges</kbd>, the code returns <kbd>0</kbd> and <kbd>false</kbd>, instead of the <kbd>32</kbd> and <kbd>true</kbd> obtained earlier.</p>
<p>Furthermore, you can use the <kbd>if</kbd> condition of Go, which is a conditional check. Check out the following code:</p>
<pre>package main<br/>import "fmt"<br/>func main() {<br/>  nameAges := map[string]int{<br/>    "Tarik": 32,<br/>    "Michael": 30,<br/>    "Jon": 25,<br/>  }<br/>  if _, exists := nameAges["Jessica"]; exists{<br/>    fmt.Println("Jessica has found")<br/>  }else {<br/>    fmt.Println("Jessica cannot be found")<br/>  }<br/>}</pre>
<p>If you check out the following output, you can see that we get <kbd>Jessica cannot be found</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-742 image-border" src="assets/f215982e-5966-4997-a611-85304fcfe2b8.png" style="width:26.42em;height:14.92em;"/></p>
<p>This means it doesn't exist. Now, what if I add <kbd>Jessica</kbd> to the map and run the following code:</p>
<pre>package main<br/>import "fmt"<br/>func main() {<br/>  nameAges := map[string]int{<br/>    "Tarik": 32,<br/>    "Michael": 30,<br/>    "Jon": 25,<br/>    "Jessica" : 20,<br/>  }<br/>  if _, exists := nameAges["Jessica"]; exists{<br/>    fmt.Println("Jessica can be found")<br/>  }else {<br/>    fmt.Println("Jessica cannot be found")<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p>As you can see from the output of the preceding code, the code returns <kbd>Jessica can be found</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-743 image-border" src="assets/fd232325-4901-4e23-8243-0bdfbce0fe38.png" style="width:26.83em;height:15.17em;"/></p>
<p>In fact, we can even add a <kbd>value</kbd> after <kbd>if</kbd>, as we saw previously, and print the <kbd>value</kbd> too with the following code:</p>
<pre>package main<br/>import "fmt"<br/>func main() {<br/>  nameAges := map[string]int{<br/>    "Tarik": 32,<br/>    "Michael": 30,<br/>    "Jon": 25,<br/>    "Jessica" : 20,<br/>  }<br/>  if value, exists := nameAges["Jessica"]; exists{<br/>    fmt.Println(value)<br/>  }else {<br/>    fmt.Println("Jessica cannot be found")<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-744 image-border" src="assets/97d71283-452a-45f9-a97b-3d48e436ebcc.png" style="width:25.83em;height:15.25em;"/></p>
<p>That's how you can simply see whether a key exists in a given map.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter took you through numerous topics, such as extracting unique elements from a list, finding an element from an array, reverting an array, converting a map into an array of keys and values, merging arrays, merging maps, and testing for the presence of a key in a map. In <a href="f45bf697-95b3-4921-b97c-86c978e74be4.xhtml">chapter 6</a>, <em>Errors and Logging</em>, we will see recipes for errors and logging, and we're going to start off with creating custom error types in Go.</p>


            </article>

            
        </section>
    </body></html>