- en: Maps and Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to work with maps and arrays in Go. You
    will see practical examples of manipulating and iterating arrays, merging arrays
    and maps, and testing whether a key is present in a map. We will go through the
    following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting unique elements from a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding an element from an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverting an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a map into an array of keys and values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for the presence of a key in a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting unique elements from an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we are going to learn how to extract unique elements from a list. To
    begin, let's imagine we have a slice, containing duplicate elements in it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's say that we want to extract the unique elements. Since we don't have
    a built-in construct in Go, we're going to make our own function that will do
    the extraction. So, we have the `uniqueIntSlice` function and it accepts `intSlice`
    or `intarray`. Our unique function will accept `intSlice` and it will return another
    slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the idea of this function is to track the duplicate elements in a separate
    list and if an element reappears in our given list, then we''re not going to add
    that element to our new list. Now, check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we''re going to have `keys`, which is basically a map, known as a dictionary
    in other languages. We''ll have another slice that keeps our `uniqueElements`,
    and we will do a `for each` loop to iterate over each element and add it to our
    new list if it is not a duplicate. We basically get our value by passing an `entry`;
    if the value is `false`, then we add that entry to our key or our map and set
    its value to `true` so that we can see whether this element already appears in
    our list. We also have a built-in  `append` function that accepts a slice and
    also appends the entry to the end of our slice, which returns another slice. On
    running the code, you should obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c9e9a14-96fe-4b83-8ff2-7c2f67227f16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the first array, there are duplicate elements: multiple instances
    of `6` and `5`. In our new array or slice, we don''t have any duplicates, and
    that''s how we extract unique elements from a list.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to learn how to find an element from an array
    in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an element from an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to learn how to find an element from an array
    or a slice. There are many ways you can do this, but we''re going to cover two
    of them in this chapter. Imagine that we have a variable that holds a slice of
    strings. The first way of searching for a particular string in this slice will
    be using a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding code, we find the word `Sandy` at index `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04364147-9fe6-462e-8079-69aa08775fe6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The other approach is to use sorting, where we can sort the slice first and
    then search for a particular item afterwards. In order to do that, Go provides
    a `sort` package. To be able to sort a slice, the slice needs to implement various
    methods that the `sort` package needs. The `sort` package provides a type called
    `sort.stringslice`, and what we can do is convert our `stringslice` to the `StringSlice`
    type provided by `sort`. Here, `sortedList` is not sorted, so we have to sort
    it explicitly. Now, check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/484a6d9d-267e-4450-ae74-4d1e856e821a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that `Draper` comes first and then `Murray`, and it is basically
    sorted in ascending order. Now, to search for a particular item here, for example
    `Sandy`, just add the following lines of code in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained after running the whole code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f078198-f4e9-4361-a7e8-db94193a14d3.png)'
  prefs: []
  type: TYPE_IMG
- en: It outputs `4`, which is the placing of the word `Sandy`. That's how you find
    an element in an array. The same thing applies to numbers as well; for instance,
    if you look at the `sort` package, you'll find `IntSlice` as well. Using integer
    slices really simplifies all the sorting and searching operations for numbers.
    In our next section, we're going to see how to revert an array.
  prefs: []
  type: TYPE_NORMAL
- en: Reverting an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to reverse sort an array. We'll have
    a variable that holds a slice of numbers. Since you are now familiar with the `sort`
    package in Go, you'll know that the `sort` package provides a lot of functionality
    that we can use to sort arrays and slices. If you look at the `sort` package,
    you'll see many types and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need the `sort` function and it accepts an interface, and this interface
    is defined in the `sort` package; therefore, we can call it the `Sort` interface.
    We are going to convert our slice of numbers into an interface. Check out the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5408e565-0603-4b8d-b016-f488a25c5eae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the output, you''ll see that we have sorted the numbers in ascending
    order. What if we want to sort them in descending order? To be able to do that,
    we have another type called `Reverse`, which implements different functions to
    sort things in descending order. Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the code, we obtain the following output and you''ll see that the
    numbers are arranged in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a92c26d9-a869-495f-b7f1-404564a40df3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we're going to see how we can iterate over an array.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to learn how to iterate over an array. Iterating
    over an array is one of the most fundamental and common operations in Go programming.
    Let''s go to our editor and see how we can do it easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain the following output from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ee49dac-df50-42af-bf76-1874d827de22.png)'
  prefs: []
  type: TYPE_IMG
- en: That's how easily you can iterate over various types of slice, including string
    slices, byte slices, or byte arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you won''t need the `index`. In that case, you can just ignore it
    by using underscore (`_`). This will mean that you''re only interested in the
    value. To carry this out, you can type in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70f4a9a-ee1f-4338-8d5f-37f7a7b02984.png)'
  prefs: []
  type: TYPE_IMG
- en: That's how you can easily iterate over various types of slice. In the next section,
    we're going to see how we can convert a map into an array of keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a map into an array of keys and values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to see how to convert a map into an array of keys
    and values. Let's imagine a variable named `nameAges` that has `map`, as shown
    in the following code block, and we map string values to integer values. There
    are names and ages too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a new struct named `NameAge` and it will have `Name` as a string
    and `Age` as integer. We are going to iterate over our `nameAges` map now. We''ll
    be using a `for` loop and when you use a range operator on a map type, it returns
    two things, a key and the value. So, let''s write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding code, you''ll obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25a71f49-0975-4bdc-8a4f-d0b45c58ccd2.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how you can easily convert a map into an array. In the next section,
    we're going to learn how to merge arrays in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Merging arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to see how to merge two arrays easily in Go.
    Consider that we have two arrays and we are going to merge them. If you used `append`
    earlier, you will know that it can accept as many parameters as required. Let''s
    check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the following code, you will obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f122f01d-3833-498a-b4de-ed35626bda0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can see `[3 4 1 2]` in our output. You can add more values to the arrays
    and still merge them. This is how we can easily merge two arrays in Go. In the
    next section, we're going to see how to merge maps this time.
  prefs: []
  type: TYPE_NORMAL
- en: Merging maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to learn how to merge maps. Check out the two
    maps in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c48d9be-6bf9-4d6a-b7b5-feac3fd561c4.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are four items, and the maps are basically mapping a string
    to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't use a comma, as shown after `22` in the preceding screenshot, you'll
    get a compile-time exception. This is because of the automatic addition of a semicolon
    in Go, which is not appropriate in this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so let''s go ahead and merge these two maps together. Unfortunately,
    there''s no built-in way of doing this, so all we have to do is just to iterate
    these two maps and then merge them together. Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5759f76-ccad-406c-892b-7567588ef0c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Okay, so the first line, as you can see, has only the initial elements that
    we used, and the second one contains basically everything, that is, all the items
    from `map2` as well. So, that's how you can quickly merge two maps into one. In
    the next section, we're going to learn how to test for the presence of a key in
    a map.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for the presence of a key in a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to see how to check whether a key exists in a
    given map. So we have a map, `nameAges`, which basically maps names to ages. Check
    out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following screenshot, we basically fetched the value
    from the `Tarik` key. Therefore, it returned only one value, which was `32`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/233df873-945f-418d-809e-98e38d7d60ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, there''s another way of using this map that returns two things: the
    first is the value and the second is whether the key exists. For instance, check
    out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b64a2b0-285c-4827-b8a1-6dd206e0055c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the code returns `true` because `Tarik`, present in the map,
    exists in `nameAges`. Now, what if we type a name that does not exist in the map?
    If we replace `Tarik` with `Jessica` in `nameAges`, the code returns `0` and `false`,
    instead of the `32` and `true` obtained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you can use the `if` condition of Go, which is a conditional check.
    Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check out the following output, you can see that we get `Jessica cannot
    be found`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f215982e-5966-4997-a611-85304fcfe2b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means it doesn''t exist. Now, what if I add `Jessica` to the map and run
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output of the preceding code, the code returns `Jessica
    can be found`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd232325-4901-4e23-8243-0bdfbce0fe38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In fact, we can even add a `value` after `if`, as we saw previously, and print
    the `value` too with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97d71283-452a-45f9-a97b-3d48e436ebcc.png)'
  prefs: []
  type: TYPE_IMG
- en: That's how you can simply see whether a key exists in a given map.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took you through numerous topics, such as extracting unique elements
    from a list, finding an element from an array, reverting an array, converting
    a map into an array of keys and values, merging arrays, merging maps, and testing
    for the presence of a key in a map. In [chapter 6](f45bf697-95b3-4921-b97c-86c978e74be4.xhtml),
    *Errors and Logging*, we will see recipes for errors and logging, and we're going
    to start off with creating custom error types in Go.
  prefs: []
  type: TYPE_NORMAL
