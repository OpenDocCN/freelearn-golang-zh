- en: Errors and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to deal with errors and return an error
    when you need to. Go''s error mechanism is different to those of some of the other
    popular languages, and this section will teach you how to work with errors the
    Go way. We will also learn how to perform simple logging operations in your application
    to get insights into your running application for better debugging. We will cover
    the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom error types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `try...catch` equivalent in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing simple logging in your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gracefully dealing with panics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom error types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with creating your custom error type. If you come from languages
    such as C# and Java, you may find the error mechanism a little different in Go.
    Moreover, the way you create your own custom error is very simple because Go is
    a duck-typed language, which means that you are good to go as long as your struct
    satisfies an interface. Let's go ahead and create our own custom error using a
    new type. So, I will have two fields, `ShortMessage` and the `DetailedMessage`
    of string type. You can have as many fields as you want, to capture more information
    about your errors. Furthermore, to satisfy the `error` interface, I'm going to
    implement a new method, `*MyError`, which will return a `string` value, and we
    can output this error to either our console or some log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, what I''m going to do is to return the error message. So, the way you
    do this is very simple: you can just return this error type from your method.
    Let''s imagine that we have a `doSomething` method that returns an error. Let''s
    imagine we did some lines of codes in that method and it returns an error for
    some reason, such as a `ShortMessage` instance of `"Wohoo something happened!"`.
    Of course, you will probably need to use more meaningful messages here, and don''t
    forget to use this `&` operator. It will get the address of your `*MyError` object,
    since we are working with a pointer here. If you don''t do this, you will see
    there''s a type error, and one way to fix is this is to just remove that `*` pointer
    and the error will be will fixed. But you probably don''t want to have multiple
    copies of the same object, so instead of doing what I have just described, you
    can easily do this: send a reference back so that you have better memory management.
    Let''s look at the whole code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s run this, and of course it will return some errors; we''re just
    going to add `err` here and then run it to the console. Now, we can see that our
    message or error message is written to the console, which is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6df9a90-ea0c-4398-817c-d7addf448f5d.png)'
  prefs: []
  type: TYPE_IMG
- en: That's how you can simply create your own error message types. In our next section,
    we're going to learn the `try...catch` equivalent in Go.
  prefs: []
  type: TYPE_NORMAL
- en: The try...catch equivalent in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike in other languages, there is no `try...catch` block in Go. In this section,
    we're going to see how Go handles basic errors. So, the first thing we're going
    to see is how to handle the errors returned by an API calls. We can use the `time.Parse()` method
    for that as it accepts a layout and a value string. It returns two things, one
    is the `parsedDate` and the other one is an error. Instead of returning an exception,
    Go returns an error as its second parameter most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the way you can handle this is to check whether the `parsedDate` is nil.
    If it''s not nil in Go, then we know that an error has happened and we need to
    handle it. If nothing happens, we can safely proceed to our next line, and that
    is to write the content of our `parsedDate` to output. So, for this, check the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/150d4ada-4907-439b-b23e-bcb639aa084a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that it works fine. What happens if we add some `string` values
    after `2018`? Let''s add `abc`, and run the code. If you see the following screenshot,
    you can see that an error occurred in parsing time; it also added the error message
    `An error occured parsing time "2018 abc": extra text: abc`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f6e2e3d-0e2b-4cef-99b2-2e1070ab3f0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the second part of this section is when you return an error yourself.
    Let''s say we have the `doSomething` function and it returns an `err` type. Check
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fdffdf3-e102-4817-b4a6-6db1eb04ef37.png)'
  prefs: []
  type: TYPE_IMG
- en: So, that's how you can do a simple `try...catch` equivalent in Go. In our next
    section, we're going to see how to do simple logging in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Doing simple logging in your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to learn how you can do simple logging in your
    application. Of course, there are various ways you can do this, and there are
    also third-party packages that allow you to do it as well, but we''re going to
    use the `log` package that Go provides. So, the first thing we have to do is create
    a new file by using the `os` package, and if, somehow, when creating the `log`
    file, an error happens, we''re going to write it to the console. We will also
    be using the `defer` function. Before the `main` method exits this `defer` function
    will be called, and the next step will be to set the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code, a new file called `log_file` is created with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e907f02e-c236-4823-a6a7-946bd6ab4355.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may wonder what the difference is between a fatal error and a normal info
    error. Let''s reorder the two lines and see how that new order behaves. Hence,
    we will run `Fatalln` first and then `Println` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run the preceding code and check the content of the `log_file`,
    you will see that the second `Println` did not get written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a37bdce9-51b4-4c7c-9ead-f353274673bc.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference is that `Fatalln` is similar to `Println` but only followed by
    a call to `os.Exit`. So, it basically writes a log and exits out of the application,
    which is the simple difference between the two. This is how you can simply do
    logging in your application. Of course, you can wrap `main` function into your
    package if you don't want to be setting the output all the time as we did here.
    In our next section, we're going to see how to gracefully deal with panics.
  prefs: []
  type: TYPE_NORMAL
- en: Gracefully dealing with panics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to see how to gracefully deal with panics. Unlike
    with errors, if you don''t recover from panics, it will stop the execution of
    your program. Therefore, dealing with them is important if you want your program
    to continue. First of all, let''s see how we can throw a panic in our Go program.
    You can simply use a keyword called `panic`, which is a built-in function, type
    panicked, and run it to obtain the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8bfa192-2f73-42ac-886d-0b6f49bb6bd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s another way to do this. Let''s use another function here and write
    something. Let''s imagine we''re doing something and for some reason it just panicked.
    This might be a third-party method, which means it is located in a third-party
    package, so we may not have full control over that package. So, here, if you run
    the preceding code, this is what we''re going to see in the application window,
    along with the message we want to write to the console, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a142bb04-f555-4a89-a8f0-c9a7eec7fa69.png)'
  prefs: []
  type: TYPE_IMG
- en: We also see the stack trace of our `panic` here. First, it hit the main message,
    and later, it hit the `writeSomething()` method. So how can we deal with this
    `panic`? We have this `defer` keyword and you have to use this `defer`. The `defer`
    means that; well, let's say that right before your method exits, you want to run
    another piece of code, so you just pass a function and you say "I want to run
    this `defer` function". Of course, it needs to be like this: `defer func(){}()`,
    or you can just say `defer writeSomething()` here. It doesn't matter, but since
    I'm going to run a couple of codes, I encapsulated them within function here.
    We have another keyword called `recover` that runs the `defer` function right
    before this `main` function exits. Also, within this function, we try `recover`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a panic happened, this `recover` returns something, and if there''s no panic,
    that means it will not return something. Therefore, the value of `r` will be `nil` ,
    which means we just don''t write anything to the console because we don''t need
    to. However, if the panic happened, then we''ll just enter the `if` condition
    and we''ll just write whatever comes from the `recover` building method and just
    go ahead and run the following code, and we will get the corresponding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e79fd976-228d-41d9-be1e-1c15e47e6d58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, now you can see that we basically say `Recovered in f` and the message
    is whatever the panic threw, and that''s something we wrote here. If you want
    to see the continuation of this process, we can just copy the `defer func()` function
    from the `main` function. Next, we will create another method called `sayHello()` and
    paste the `defer func()` into it. What I''m trying to show you is that we have
    recovered from the panic, so the execution will also hit this line as well. So,
    we can just go ahead and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the execution `main` function, so now we see the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f04575d2-ccdd-4269-94d3-ee71ba297f3b.png)'
  prefs: []
  type: TYPE_IMG
- en: If we didn't have the `defer` function, let's see how that would have behaved.
    Now you see that it didn't hit `main` function, we have the panic and all the
    stack trace here, and that's how you can gracefully handle panics in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a walkthrough of errors and logging. In the next chapter, we
    will learn how to work with files and directories in an operating system. We will
    also learn about parsing and using various formats, such as XML, YAML, and JSON.
  prefs: []
  type: TYPE_NORMAL
