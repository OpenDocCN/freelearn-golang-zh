<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Concurrency</h1>
                </header>
            
            <article>
                
<p class="mce-root">One of the most powerful things about Go is its concurrency with APIs. In this chapter, you will learn how to make use of concurrency constructs in the Go language. We will cover the following topics in this chapter:</p>
<ul>
<li>Running multiple functions concurrently</li>
<li>Passing data between concurrently running functions</li>
<li>Waiting for all concurrent functions to finish</li>
<li>Selecting the results of concurrent functions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running multiple functions concurrently</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's begin with running multiple functions concurrently.</p>
<p class="mce-root">Take a look at the code in the following block:</p>
<pre>import (<br/>  "fmt"<br/>  "time"<br/>)<br/><br/>func main() {<br/><br/>  names := []string{"tarik", "john", "michael", "jessica"}<br/><br/>  for _, name := range names {<br/>   time.Sleep(1 * time.Second)<br/>   fmt.Println(name)<br/>  }</pre>
<pre>ages := []int{1, 2, 3, 4, 5}<br/>  for _, age:= range ages {<br/>    time.Sleep(1 * time.Second)<br/>    fmt.Println(age)<br/>  }<br/>}</pre>
<p class="mce-root">You can see from the preceding code that there are two different lists; each list has items that have taken at least a second to finish, but for practice purposes, we're not going to have any actual code but just <kbd>fmt.Println</kbd>. We have added <kbd>time.Sleep</kbd> for a second within each iteration. As seen in the preceding code, we first process the names and then the ages. One thing you can notice is that they're not really dependent on each other; they're actually two different works. So, let's go ahead and run this and see what that it like on our console:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-989 image-border" src="assets/721b22d0-b2f7-4f4b-a57f-5a724a78e8cf.png" style="width:23.25em;height:17.75em;"/></p>
<p class="mce-root">If you observe the process of the output, you will see that each line of output waits a second before delivering the next. You'll see that they're actually sequential pieces of code even though they do not depend on each other. We'll have to wait for the loop to finish before we can continue to the second <kbd>for</kbd> loop.</p>
<p class="mce-root">We can make this process more scalable and efficient by using concurrent patterns. For this, we are going to use Go routines in Go. Go routines are more lightweight than threads, and, unlike threads, they give the control back voluntarily instead of preemptively. You'll know more about what exactly I mean as we go further along. Check the following code:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>  "time"<br/>)</pre>
<pre>func main() {<br/><br/>  go func() {<br/>    names := []string{"tarik", "john", "michael", "jessica"}<br/><br/>    for _, name := range names {<br/>      time.Sleep(1 * time.Second)<br/>      fmt.Println(name)<br/>    }<br/>  }()<br/><br/>  go func(){<br/>    ages := []int{1, 2, 3, 4, 5}<br/>    for _, age:= range ages {<br/>      time.Sleep(1 * time.Second)<br/>      fmt.Println(age)<br/>    }<br/>  }()<br/>  time.Sleep(10*time.Second)<br/>}</pre>
<p class="mce-root">As you can see, we have converted the code to independent pieces of functionality into Go routines, using the Go keyword and an anonymous function. We have done the same thing for ages as well. On running the code, you will obtain the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-990 image-border" src="assets/5e34080c-da13-44f9-8bae-8c9aefd3ebb9.png" style="width:24.42em;height:18.92em;"/></p>
<p class="mce-root">As you can see, instead of the output showing up sequentially as before, it shows up randomly. This means that both the loops are processed concurrently.</p>
<div class="mce-root packt_tip">If we remove <kbd>time.Sleep</kbd> (comment it out using <kbd>//</kbd>), we will not see any result on the console. This is because the main application is also run under a Go routine and that means we have three Go routines: the two that we typed and one that is the entire main application. The problem, as mentioned before, is that Go routines give control back to other Go routines voluntarily instead of preemptively. This means that when you use <kbd>time.Sleep</kbd>, the control will be given to other Go routines and our system will work properly.</div>
<p class="mce-root">Now, what happens if we use <kbd>1</kbd> second instead of <kbd>10</kbd> seconds, as seen in our last screenshot with code? You will not obtain any output. This is because <kbd>1</kbd> second is not enough for all the Go routines to finish the task. O<span>nce the main Go routine is done with its process, it shuts off the entire application and does not give enough time for other Go routines to complete.</span> <span>There is a way of handling this</span> situation, where we have another construct called channels. So, for simplicity, we will remove the second Go routine and use the channels now. Check the following code:</p>
<pre>package main<br/><br/>import (<br/>    "time"<br/>  "fmt"<br/>)<br/><br/>func main() {<br/><br/>  nameChannel := make(chan string)<br/><br/>  go func() {<br/>    names := []string{"tarik", "john", "michael", "jessica"}<br/><br/>    for _, name := range names {<br/>    time.Sleep(1 * time.Second)<br/>      //fmt.Println(name)<br/>    nameChannel &lt;- name<br/>    }<br/>  }()<br/><br/>  for data:= range nameChannel{<br/>    fmt.Println(data)<br/>  }<br/>}</pre>
<p class="mce-root">When you run the preceding code, you will get an exception as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-991 image-border" src="assets/0fac42a1-dd9c-4212-b301-4fe2103f88c3.png" style="width:72.83em;height:19.75em;"/></p>
<p class="mce-root">The reason for this exception is that when you've finished with a channel, you need to close it, otherwise the <kbd>for</kbd> loop will keep waiting and waiting. However, because your Go routine is finished with that channel, the loop will go into a deadlock and stop your application. So, one way to close a channel is by adding the following line of code that is highlighted:</p>
<pre>package main<br/><br/>import (<br/>    "time"<br/>  "fmt"<br/>)<br/><br/>func main() {<br/><br/>  nameChannel := make(chan string)<br/><br/>  go func() {<br/>    names := []string{"tarik", "john", "michael", "jessica"}<br/><br/>    for _, name := range names {<br/>    time.Sleep(1 * time.Second)<br/>      //fmt.Println(name)<br/>    nameChannel &lt;- name<br/>    }<br/>    <strong>close(nameChannel)</strong><br/>    //nameChannel &lt;- ""<br/>  }()<br/><br/>  for data:= range nameChannel{<br/>    fmt.Println(data)<br/><br/>    }<br/><br/>  //&lt;-nameChannel<br/>}</pre>
<p class="mce-root">When a channel is closed, the loop will terminate. So, let's go ahead and run this and check the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-992 image-border" src="assets/6f1d0e64-646b-4cb4-ae45-044c555a6f24.png" style="width:23.92em;height:13.92em;"/></p>
<p class="mce-root">As you see, we didn't get any exception here, and everything looks fine. If you don't care about the result, and if you want to use our first approach, you can use the following code:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>  "time"<br/>)<br/><br/>func main() {<br/>  nameChannel := make(chan string)<br/>  go func() {<br/>    names := []string{"tarik", "john", "michael", "jessica"}<br/>    for _, name := range names {<br/>      time.Sleep(1 * time.Second)<br/>      fmt.Println(name)<br/>    }<br/>    nameChannel &lt;- ""<br/>  }()<br/>  &lt;-nameChannel<br/>}</pre>
<p class="mce-root">What we did is write everything to the console and, once the loop was finished, it set <kbd>nameChannel</kbd>. Moreover, in this scenario, we wait until we get some data from the name channel, and therefore we don't terminate the application. Once we get some data from the name channel, we read it and we don't really assign it to anything. When the <kbd>main</kbd> Go routine proceeds to the next line, there is no code there and hence the <kbd>main</kbd> function is exited. Therefore, our application is closed. You will obtain the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-994 image-border" src="assets/bc660bd9-45d1-4133-9054-387c8f3783c3.png" style="width:25.42em;height:14.67em;"/></p>
<p class="mce-root">That's how you can use channels and functions to do concurrent operations. Before we conclude, let's reiterate one point about channels. If a channel is empty and you try to read it, it will block its Go routine. Once it is filled, we can read something from it; we read the data and continue. The reason why the <kbd>main</kbd> Go routine could not be exited is because we didn't send any value to it before, and this is much more effective than using a timer, as we did in our previous example.</p>
<p class="mce-root">In the next section, we're going to see how to pass data between concurrently running functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing data between concurrently running functions</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to see how to pass data between Go routines. Imagine that we have two Go routines. The first Go routine performs some actions on the data and hands the data to another Go routine, which performs the second processing stage on that data. Now, we need a way to pass data between the first Go routine and the second one. As you can see, we may need some synchronization between the two Go routines because the second Go routine will have to wait until the second Go routine provides some data to it.</p>
<p>To begin, we are going to use the following code:</p>
<pre>package main<br/>import "fmt"<br/>func main(){<br/>  nameChannel := make(chan string)<br/>  done := make(chan string)<br/>  go func(){<br/>    names := []string {"tarik", "michael", "gopi", "jessica"}<br/>    for _, name := range names {<br/>      // doing some operation<br/>      fmt.Println("Processing the first stage of: " + name)<br/>      nameChannel &lt;- name<br/>    }<br/>    close(nameChannel)<br/>  }()<br/>  go func(){<br/>    for name := range nameChannel{<br/>      fmt.Println("Processing the second stage of: " + name)<br/>    }<br/>    done &lt;- ""<br/>  }()<br/>  &lt;-done<br/>}</pre>
<p>If you look at the code, you can see that we have used a channel again: <kbd>nameChannel</kbd>. Since we need to access <kbd>nameChannel</kbd> from the two Go routines, we have to declare it within the <kbd>main</kbd> function. In the first Go routine, we are going to pass some data to <kbd>nameChannel</kbd>, which is <kbd>name</kbd>. The <kbd>name</kbd> variable is the string array that has some data and comes from the first Go routine. In the second Go routine, we are going to use <kbd>nameChannel</kbd> and we are going to read it as it is filled. Moreover, we will have to use another Go routine just to signal to the main Go routine to indicate that all the Go routines are finished (<kbd>done := make(chan string)</kbd>). We also have to terminate the application to avoid any deadlocks, using the <kbd>close</kbd> function. When the channel is closed, the <kbd>for</kbd> loop will be terminated, and the Go routine will send some data into the <kbd>done</kbd> variable. Then, our main Go routine will read it and proceed to the next line, exit out of the <kbd>main</kbd> function, and our application will be done. This was the unbuffered channel; that is, you can send single data that has to be read and emptied before you send more data to it, otherwise it will be blocked.</p>
<p>Another way to do this is by using the buffered channel for improved performance. A slight modification in the preceding code will help us. We are going to add the integer <kbd>5</kbd>, which means you can send five pieces of data into <kbd>nameChannel</kbd> without waiting. Check the modified code:</p>
<pre>package main<br/>import "fmt"<br/>func main(){<br/>  nameChannel := make(chan string, 5)<br/>  done := make(chan string)<br/>  go func(){<br/>    names := []string {"tarik", "michael", "gopi", "jessica"}<br/>    for _, name := range names {<br/>      // doing some operation<br/>      fmt.Println("Processing the first stage of: " + name)<br/>      nameChannel &lt;- name<br/>    }<br/>    close(nameChannel)<br/>  }()<br/>  go func(){<br/>    for name := range nameChannel{<br/>      fmt.Println("Processing the second stage of: " + name)<br/>    }<br/>    done &lt;- ""<br/>  }()<br/>  &lt;-done<br/>}</pre>
<p>So, for instance, it will send some data and it will not wait because there will still be four places left. Thus, it will go to the second iteration and it will send some data into it until the count goes to <kbd>5</kbd>. The good thing is that while we send data to the name channel, we also read data from it. The following will be the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-995 image-border" src="assets/36126b7a-c835-4f54-94fe-13a491a92433.png" style="width:25.75em;height:15.50em;"/></p>
<p>This is how you can pass data between multiple Go routines. In our next section, we are going to see how to wait for all the concurrent functions to complete.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Waiting for all concurrent functions to finish</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to see how to wait for all concurrent functions to finish. Consider that we have a piece of code, as follows:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>  )<br/><br/>func main() {<br/>  for i := 0; i &lt; 10; i++ {<br/>    go func(){<br/>      fmt.Println("Hello World")<br/>    }()<br/>  }<br/>}</pre>
<p>Imagine we want to create multiple Go routines within a loop. In this case, let's say we want to have 10 Go routines plus the main Go routine, so 11 Go routines in total. <span>If you run the code shown in the previous screenshot, you will find no output.</span></p>
<p>One way to wait for all these Go routines to complete so that we can show something to the console is to use <kbd>time.Sleep</kbd>, as shown in the following code:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/>  "time"<br/>)<br/><br/>func main() {<br/>  for i := 0; i &lt; 10; i++ {<br/>   go func(){<br/>      fmt.Println("Hello World")<br/>    }()<br/>  }<br/><br/>  time.Sleep(10*time.Second)<br/>}<br/><br/></pre>
<p>On running the preceding code, you will obtain the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-996 image-border" src="assets/8297efd4-819f-4e5c-a987-9c80373f5477.png" style="width:24.42em;height:19.50em;"/></p>
<p>Now, you have obtained an output, but the problem with this approach is that you usually don't know how much time is needed for all the Go routines to complete; therefore, you can't really predict the time. So what we can do is use something that is provided by the Go library itself and that is <kbd>sync.WaitGroup</kbd>. As its name suggests, it's basically a group of waits that you can use to wait for all the Go routines to finish. Check the following code:</p>
<pre>package main<br/>import (<br/>  "fmt"<br/>  "sync"<br/>)<br/><br/>func main() {<br/>  var wg sync.WaitGroup<br/>  for i := 0; i &lt; 10; i++ {<br/>    wg.Add(1)<br/>    go func(){<br/>      fmt.Println("Hello World")<br/>      wg.Done()<br/>    }()<br/>  }<br/>  wg.Wait()<br/>}</pre>
<p>So, here, for each iteration, we can add a new item to our wait group, which will be <kbd>1</kbd> in this case. So we'll basically increment the number of waits in this <kbd>WaitGroup</kbd> by <kbd>1</kbd>. When a Go routine is done, it will be signaled using <kbd>wg.Done()</kbd>, and that will basically reduce the number of waits in the group by <kbd>1</kbd>. Moreover, <kbd>wg.Wait</kbd> will block our main Go routine until all of our Go routines are finished. On running the code, we will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-997 image-border" src="assets/aa31888d-52ee-44f6-91d9-ca023b519084.png" style="width:23.92em;height:18.17em;"/></p>
<p>This is how you can simply wait for all the Go routines to complete in your application properly. In the next section, we're going to see how to select the results of concurrent functions as they are returned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting the results of concurrent functions</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to see how to select the results of concurrent rank functions as they are returned. Consider that we have two Go routines in our <kbd>main</kbd> function that are basically setting their own channels: <kbd>channel1</kbd> and <kbd>channel2</kbd>. Let's say that we want to read whatever comes first and then continue to the next line. For this, Go provides a built-in construct that is called <kbd>select</kbd>, and <kbd>select</kbd> basically waits for a channel to be filled and looks like a <kbd>switch</kbd> statement. So, let's go ahead and see what that looks like now:</p>
<pre>package main<br/>import (<br/>  "time"<br/>  "fmt"<br/>)<br/>func main() {<br/>  channel1 := make(chan string)<br/>  channel2 := make(chan string)<br/>  go func(){<br/>    time.Sleep(1*time.Second)<br/>    channel1 &lt;- "Hello from channel1"<br/>  }()<br/>  go func(){<br/>    time.Sleep(1 * time.Second)<br/>    channel2 &lt;- "Hello from channel2"<br/>  }()<br/>  var result string<br/>  select {<br/>  case result = &lt;-channel1:<br/>    fmt.Println(result)<br/>  case result = &lt;-channel2:<br/>    fmt.Println(result)<br/>  }<br/>}</pre>
<p>So, you just say <kbd>select</kbd> and you say, for instance, <kbd>channel1</kbd>,  and when <kbd>channel1</kbd> is ready, we will do something like create a <kbd>result</kbd> variable of type <kbd>string</kbd>. So, here, I'm going to assign the value of <kbd>channel1</kbd> to the <kbd>result</kbd> variable which will be printed to the console using <kbd>Println</kbd>. In the second case, if it is not <kbd>channel1</kbd> but <kbd>channel2</kbd> that is ready to be read, then we're going to read it instead into our <kbd>result</kbd> variable. The <kbd>select</kbd> statement will will not use both case here; so, for instance, if <kbd>channel1</kbd> and <kbd>channel2</kbd> are ready at the same time, then the <kbd>select</kbd> statement will just choose one of them randomly.</p>
<p>Since <kbd>channel1</kbd> was ready, we got <kbd>Hello</kbd> from <kbd>channel1</kbd> as the output. If we run the code again, we get <kbd>channel2</kbd>, as you can see from the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-998 image-border" src="assets/0b00762b-54ca-44c7-bc7a-1e2acbeeb215.png" style="width:22.75em;height:12.83em;"/></p>
<p>Thus, you can easily see the randomness in the output provided. This is how it works.</p>
<p>Now, there may be some instances where you need to wait multiple times. In such cases, you can use loops:</p>
<pre>package main<br/>import (<br/> "time"<br/> "fmt"<br/>)<br/>func main() {<br/> channel1 := make(chan string)<br/> channel2 := make(chan string)<br/>go func(){<br/> time.Sleep(1*time.Second)<br/> channel1 &lt;- "Hello from channel1"<br/> }()<br/>go func(){<br/> time.Sleep(1 * time.Second)<br/> channel2 &lt;- "Hello from channel2"<br/> }()<br/>var result string<br/> for {<br/> select {<br/> case result = &lt;-channel1:<br/> fmt.Println(result)<br/> case result = &lt;-channel2:<br/> fmt.Println(result)<br/> }<br/> case &lt;-quit:<br/> return<br/> }<br/>}</pre>
<p>Imagine that you're writing something that has to wait constantly for some incoming data, and as the data is coming in, you want to write it to the console. Or it may be that you want to do some operations on those. In this case, you can wait for them in an infinite loop. If you want to get out of this loop, you can read another channel, such as <kbd>quit</kbd>. If <kbd>quit</kbd> is already present, then you can just break out of this loop or if it's a function, you can use return and that will <kbd>return</kbd> out of the function as well.</p>
<p>So, this is how you can easily read data coming from multiple functions in Go. This concludes our concurrency chapter.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span> In this chapter, you learned how to make use of concurrency constructs in the Go language. I</span>n the next chapter, we're going to learn system programming and we're going to start off with catching signals. <span>You will also learn how to process command line arguments using Go.</span></p>


            </article>

            
        </section>
    </body></html>