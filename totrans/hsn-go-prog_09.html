<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">System Programming</h1>
                </header>
            
            <article>
                
<p class="mce-root">System programming allows you to work with system messages and run processing tasks. In this chapter, you will learn how to process command-line arguments using Go. The following topics will be covered in this chapter:</p>
<ul>
<li>Catching signals</li>
<li>Running child processes</li>
<li>Processing command-line arguments</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Catching signals</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before we go in-depth into catching signals, let's understand what signals are and how you can use them. Signals are a limited form of inter-process communication and are typically used in Unix and Unix-like operating systems. A signal is an asynchronous notification sent to a specific threat in the same process or another target process to notify it of an event occurrence. You can catch signals for various reasons; for instance, you can catch a termination signal made to your process from another process to perform some termination cleanup operation in your application. When it comes to Go, Go signal notification works by sending <kbd>os.signal</kbd> values on our channel. Now, let's proceed and see what it looks like in our Go application.</p>
<p class="mce-root">First of all, we will create a new channel called signals and use <kbd>os.signal</kbd> here. If you want to catch more than one signal, you can use a buffered channel and type 3 or 4 as the integer. To catch only one signal at a time, we can type 1, or you can just pass that and the default will be 1 automatically. We will also need some other channel to notify that we are done with the signal processing so that we can terminate our application or carry out other operations. In our <kbd>signal</kbd> package, we have a method called <kbd>Notify()</kbd>, so let's go ahead and see the documentation that says that <em>Notify causes package signals to relay incoming signals to channel</em>. So, Go will automatically listen to signals and relate those signals to this channel that we're going to provide as its first argument. Now, check the following code:</p>
<pre>package main<br/>import (<br/>  "os"<br/>  "os/signal"<br/>  "syscall"<br/>  "fmt"<br/>)<br/>func main(){<br/>  signals := make (chan os.Signal, 1)<br/>  done := make(chan bool)<br/>  signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)<br/>  go func (){<br/>    sig := &lt;- signals<br/>    fmt.Println(sig)<br/>    fmt.Println("Signal captured and processed...")<br/>    done &lt;- true<br/>  }()<br/>  fmt.Println("Waiting for signal")<br/>  &lt;-done<br/>  fmt.Println("Exiting the application...")<br/>}</pre>
<p class="mce-root">There are parameters to filter which signals you want to listen to, namely, <kbd>syscall.SIGINT</kbd> and <kbd>syscall.SIGTERM</kbd>. Furthermore, we will create a Go routine that will simply listen to this signal and perform an operation. Furthermore, we are going to read the value and write the content of the signal to the console. We will add a <kbd>print</kbd> statement stating <span><kbd>Signal captured and processed...</kbd>. </span>In addition, <kbd>done &lt;- true</kbd> will help us with the processing of the signal. Finally, we will type the <kbd>print</kbd> statement <kbd>Waiting for signal</kbd> and then we are done with our signal capturing and processing. Let's proceed and run the code to obtain the output. We are going to run the <kbd>main.go</kbd> application now, and it'll print <kbd>Waiting for signal</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1023 image-border" src="assets/0912732c-aef3-4fe4-be62-f53299e646da.png" style="width:48.92em;height:6.58em;"/></p>
<p class="mce-root">Now, we can send a signal to close the application using the <em>Ctrl</em> + <em>C</em> command, and, as you can see in the following screenshot, an interruption occurs. Our interruption is captured and processed and now we exit the application, which can also be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1024 image-border" src="assets/1464852b-0859-47f3-b5a0-24ec0bcda1cc.png" style="width:48.00em;height:8.58em;"/></p>
<p class="mce-root">This is how you can simply capture processes and use signals in your Go application. In our next section, we're going to see how to run child processes from a Go application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running child processes</h1>
                </header>
            
            <article>
                
<p>In this video, we're going to see how to run child processes within your application. In our application, we will run a command called <kbd>ls</kbd> (in Linux) and <kbd>dir</kbd> (in Windows). The <kbd>ls</kbd> and <kbd>dir</kbd> command is an application that simply lists all the files within a given directory. Thus, from our current directory, it will give us <kbd>hello.txt</kbd> and <kbd>main.go</kbd> files. We are going to run this <kbd>ls</kbd> utility app within our application. So, the first thing we have to do is to use the <kbd>exec</kbd> package, which provides commands. We are going to use the <kbd>ls</kbd> command and not pass any argument right now. This will return the command itself. You will find two functions; one is <kbd>start</kbd> and the other one is <kbd>run</kbd>.</p>
<div class="packt_infobox"><span>The difference between <kbd>start</kbd> and <kbd>r</kbd> is, if you look at the documentation, you'll see that <kbd>run</kbd> starts the specified command and waits for it to complete. Based on your requirements, you can choose <kbd>start</kbd> or <kbd>run</kbd>.</span></div>
<p>We also have <kbd>PID</kbd>, which is the process ID, and we are going to output that to the console. So, let's proceed and run the code. You can see the following:</p>
<pre>package main<br/><br/>import (<br/>  "os/exec"<br/>  "fmt"<br/>  )<br/><br/>func main() {<br/>  lsCommand := exec.Command("ls")<br/>  lsCommand.Start()<br/>  fmt.Println(lsCommand.Process.Pid)<br/>}</pre>
<p>You will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1025 image-border" src="assets/eb96b7d3-53e9-45ec-8a16-636df48002eb.png" style="width:39.58em;height:10.58em;"/></p>
<p>As you can see, we get the process ID, but we don't see the files yet that are within the directory. Now, let's try <kbd>run</kbd>. We would want to read whatever comes from the <kbd>ls</kbd> command and then we'll print it out to the console. We're going to use <kbd>lsCommand.Output()</kbd>, which returns a byte array and an error, but we are going to ignore the error for now. Okay! Let's check the as-described code now:</p>
<pre>package main<br/>import (<br/>  "os/exec"<br/>  "fmt"<br/>)<br/>func main() {<br/>  lsCommand := exec.Command("ls")<br/>  output,_ := lsCommand.Output()<br/>  lsCommand.Run()<br/>  fmt.Println(lsCommand.Process.Pid)<br/>  fmt.Println(string(output))<br/>}</pre>
<p>We will also clear the terminal and then check the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1026 image-border" src="assets/a05fed55-3db4-4954-b005-49f51cade729.png" style="width:39.75em;height:10.83em;"/></p>
<p>As you can see, it gave us the two filenames and also the process ID. That's how you can simply run a process from within your Go application. Of course there are more ways to this. You can run other types of process, such as Google Chrome or Firefox, or another application that you've developed. Thus, it is a pretty powerful tool that you may want to use when you need to start a process from within your application. In our next section, we're going to see how we can process command-line arguments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing command-line arguments</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to see how to process command-line arguments. A typical example of a command-line argument is <kbd>ls -a</kbd>. Here, <kbd>a</kbd> is a command-line argument that is passed to our last command, and <kbd>ls</kbd> is a program located in the operating system. Based on the arguments that are passed to the <kbd>ls</kbd> command, it behaves differently.</p>
<p>For instance, if we type <kbd>ls</kbd>, it will show us all the visible files. If we type <kbd>ls -a</kbd>, then it shows everything under that directory, including invisible items as well, which can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1027 image-border" src="assets/e35aa49a-a983-4e9e-937a-2c45ee281411.png" style="width:42.50em;height:8.33em;"/></p>
<p>So, we're going to do the same thing to our program. You can use <span><kbd>os.Args</kbd> to</span> read your arguments that are passed to your application. We are going to read and write these arguments to the console and see how it looks after we passed some arguments to our application. We will have to clear our terminal first and type <kbd>go run main.go</kbd>. Since, initially, we are not going to pass any argument, we can expect to see just one argument and that is the path of our executable. However, <span>since we use <kbd>go run</kbd>, it will just create a temporary executable file and run it for us, hence, that's the <kbd>temp</kbd> location</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1028 image-border" src="assets/89961188-ade2-488f-a20b-04ac43867414.png" style="width:42.83em;height:3.50em;"/></p>
<p>If we type <kbd>go run main.go -someArgument</kbd>, we will get the second item, and that's <kbd>- someArgument</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1029 image-border" src="assets/3ad043dd-4f1c-4f88-99c4-c5f56bf5da15.png" style="width:42.92em;height:6.42em;"/></p>
<p>If we don't care about the first argument, we can use <kbd>realArgs</kbd>:</p>
<pre>package main<br/>import (<br/>  "os"<br/>  "fmt"<br/>)<br/><br/>func main(){<br/>  realArgs := os.Args[1:]<br/>  fmt.Println(realArgs)<br/>}</pre>
<p><span>You will get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1030 image-border" src="assets/11f0f182-4278-4a29-b500-9675fb734e87.png" style="width:43.58em;height:8.58em;"/></p>
<p>Let's go ahead and check a real-world example. Let's assume that we only expect one argument that is passed. Check the following code:</p>
<pre>package main<br/>import (<br/>  "os"<br/>  "fmt"<br/>)<br/>func main(){<br/>  realArgs := os.Args[1:]<br/>  if len(realArgs) == 0{<br/>    fmt.Println("Please pass an argument.")<br/>    return<br/>  }<br/>  if realArgs[0] == "a"{<br/>    writeHelloWorld()<br/>  }else if realArgs[0] == "b"{<br/>    writeHelloMars()<br/>  }else{<br/>    fmt.Println("Please pass a valid argument.")<br/>  }<br/>}<br/>func writeHelloWorld(){<br/>  fmt.Println("Hello, World")<br/>}<br/>func writeHelloMars(){<br/>  fmt.Println("Hello, Mars")<br/>}</pre>
<p>As you can see in the preceding code, we've typed <kbd>realArgs[0] == "a"</kbd>, which will run a function called <kbd>writeHelloWorld()</kbd>; if it's <kbd>realArgs[0] == "b"</kbd>, then it will run <kbd>writeHelloMars()</kbd> and, for anything that is a default, we'll print a warning, <kbd>Please pass a valid argument</kbd>. Now, we will add the <kbd>writeHelloWorld()</kbd> and <kbd>writeHelloMars()</kbd> functions. Furthermore, we're going to use a built-in function to get the length of our <kbd>realArgs</kbd> and, if it's <kbd>0</kbd>, we're going to print <kbd>Please pass an argument</kbd>. After that is done, we will need to add a <kbd>return</kbd> statement and exit.</p>
<p>On running the code, you will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1031 image-border" src="assets/450e0c02-df4b-45b7-a076-a604d5590583.png" style="width:44.00em;height:3.50em;"/></p>
<p>As you can see, we get our first message. If we type <kbd>go run main.go a</kbd>, we get <kbd>Hello, World</kbd> <span>printed on the console, </span>as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1032 image-border" src="assets/c1c21852-4c85-4653-8698-8738c4979892.png" style="width:47.58em;height:3.75em;"/></p>
<p>If we type <kbd><span>go run main.go b</span></kbd>, we get <kbd>Hello, Mars</kbd><span> printed on the console, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1033 image-border" src="assets/21173ecf-0784-4eba-bd53-f1c2d1239970.png" style="width:45.92em;height:5.67em;"/></p>
<p>That is simply how you can execute command-line argument processing in your Go application. This concludes our chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, you learned about catching signals, running child processes, and processing command-line arguments. In the next chapter, you will learn how to download web pages and files from the internet. You will also see how to create files and web servers, as well as handle HTTP request and responses.</span></p>


            </article>

            
        </section>
    </body></html>