- en: System Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'System programming allows you to work with system messages and run processing
    tasks. In this chapter, you will learn how to process command-line arguments using
    Go. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Catching signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running child processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go in-depth into catching signals, let's understand what signals are
    and how you can use them. Signals are a limited form of inter-process communication
    and are typically used in Unix and Unix-like operating systems. A signal is an
    asynchronous notification sent to a specific threat in the same process or another
    target process to notify it of an event occurrence. You can catch signals for
    various reasons; for instance, you can catch a termination signal made to your
    process from another process to perform some termination cleanup operation in
    your application. When it comes to Go, Go signal notification works by sending
    `os.signal` values on our channel. Now, let's proceed and see what it looks like
    in our Go application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will create a new channel called signals and use `os.signal`
    here. If you want to catch more than one signal, you can use a buffered channel
    and type 3 or 4 as the integer. To catch only one signal at a time, we can type
    1, or you can just pass that and the default will be 1 automatically. We will
    also need some other channel to notify that we are done with the signal processing
    so that we can terminate our application or carry out other operations. In our
    `signal` package, we have a method called `Notify()`, so let''s go ahead and see
    the documentation that says that *Notify causes package signals to relay incoming
    signals to channel*. So, Go will automatically listen to signals and relate those
    signals to this channel that we''re going to provide as its first argument. Now,
    check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are parameters to filter which signals you want to listen to, namely,
    `syscall.SIGINT` and `syscall.SIGTERM`. Furthermore, we will create a Go routine
    that will simply listen to this signal and perform an operation. Furthermore,
    we are going to read the value and write the content of the signal to the console.
    We will add a `print` statement stating `Signal captured and processed...`. In
    addition, `done <- true` will help us with the processing of the signal. Finally,
    we will type the `print` statement `Waiting for signal` and then we are done with
    our signal capturing and processing. Let''s proceed and run the code to obtain
    the output. We are going to run the `main.go` application now, and it''ll print
    `Waiting for signal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0912732c-aef3-4fe4-be62-f53299e646da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can send a signal to close the application using the *Ctrl* + *C* command,
    and, as you can see in the following screenshot, an interruption occurs. Our interruption
    is captured and processed and now we exit the application, which can also be seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1464852b-0859-47f3-b5a0-24ec0bcda1cc.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how you can simply capture processes and use signals in your Go application.
    In our next section, we're going to see how to run child processes from a Go application.
  prefs: []
  type: TYPE_NORMAL
- en: Running child processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this video, we're going to see how to run child processes within your application.
    In our application, we will run a command called `ls` (in Linux) and `dir` (in
    Windows). The `ls` and `dir` command is an application that simply lists all the
    files within a given directory. Thus, from our current directory, it will give
    us `hello.txt` and `main.go` files. We are going to run this `ls` utility app
    within our application. So, the first thing we have to do is to use the `exec`
    package, which provides commands. We are going to use the `ls` command and not
    pass any argument right now. This will return the command itself. You will find
    two functions; one is `start` and the other one is `run`.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `start` and `r` is, if you look at the documentation,
    you'll see that `run` starts the specified command and waits for it to complete.
    Based on your requirements, you can choose `start` or `run`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have `PID`, which is the process ID, and we are going to output that
    to the console. So, let''s proceed and run the code. You can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb96b7d3-53e9-45ec-8a16-636df48002eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we get the process ID, but we don''t see the files yet that
    are within the directory. Now, let''s try `run`. We would want to read whatever
    comes from the `ls` command and then we''ll print it out to the console. We''re
    going to use `lsCommand.Output()`, which returns a byte array and an error, but
    we are going to ignore the error for now. Okay! Let''s check the as-described
    code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also clear the terminal and then check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a05fed55-3db4-4954-b005-49f51cade729.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it gave us the two filenames and also the process ID. That's
    how you can simply run a process from within your Go application. Of course there
    are more ways to this. You can run other types of process, such as Google Chrome
    or Firefox, or another application that you've developed. Thus, it is a pretty
    powerful tool that you may want to use when you need to start a process from within
    your application. In our next section, we're going to see how we can process command-line
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Processing command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to see how to process command-line arguments. A
    typical example of a command-line argument is `ls -a`. Here, `a` is a command-line
    argument that is passed to our last command, and `ls` is a program located in
    the operating system. Based on the arguments that are passed to the `ls` command,
    it behaves differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we type `ls`, it will show us all the visible files. If we
    type `ls -a`, then it shows everything under that directory, including invisible
    items as well, which can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e35aa49a-a983-4e9e-937a-2c45ee281411.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we''re going to do the same thing to our program. You can use `os.Args`
    to read your arguments that are passed to your application. We are going to read
    and write these arguments to the console and see how it looks after we passed
    some arguments to our application. We will have to clear our terminal first and
    type `go run main.go`. Since, initially, we are not going to pass any argument,
    we can expect to see just one argument and that is the path of our executable.
    However, since we use `go run`, it will just create a temporary executable file
    and run it for us, hence, that''s the `temp` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89961188-ade2-488f-a20b-04ac43867414.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we type `go run main.go -someArgument`, we will get the second item, and
    that''s `- someArgument`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ad043dd-4f1c-4f88-99c4-c5f56bf5da15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we don''t care about the first argument, we can use `realArgs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11f0f182-4278-4a29-b500-9675fb734e87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go ahead and check a real-world example. Let''s assume that we only
    expect one argument that is passed. Check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we've typed `realArgs[0] == "a"`, which
    will run a function called `writeHelloWorld()`; if it's `realArgs[0] == "b"`,
    then it will run `writeHelloMars()` and, for anything that is a default, we'll
    print a warning, `Please pass a valid argument`. Now, we will add the `writeHelloWorld()` and
    `writeHelloMars()` functions. Furthermore, we're going to use a built-in function
    to get the length of our `realArgs` and, if it's `0`, we're going to print `Please
    pass an argument`. After that is done, we will need to add a `return` statement
    and exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'On running the code, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/450e0c02-df4b-45b7-a076-a604d5590583.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we get our first message. If we type `go run main.go a`, we
    get `Hello, World` printed on the console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1c21852-4c85-4653-8698-8738c4979892.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we type `go run main.go b`, we get `Hello, Mars` printed on the console,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21173ecf-0784-4eba-bd53-f1c2d1239970.png)'
  prefs: []
  type: TYPE_IMG
- en: That is simply how you can execute command-line argument processing in your
    Go application. This concludes our chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about catching signals, running child processes,
    and processing command-line arguments. In the next chapter, you will learn how
    to download web pages and files from the internet. You will also see how to create
    files and web servers, as well as handle HTTP request and responses.
  prefs: []
  type: TYPE_NORMAL
