<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Graphical User Interface Challenges</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we explored the history of graphical user interfaces, looking at how they evolved and why they can provide a better user experience than contemporary alternatives. Unfortunately, despite all the benefits of graphical applications for end users, they can pose many challenges to the team designing and building them. In this chapter, we look at the sorts of issues that a team may face at various stages of creating an average-complexity graphical application.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Choosing a look and feel to match the operating system or product brand</li>
<li>Different approaches to application layout and multiple windows</li>
<li>The challenges of concurrency and cloud service integration</li>
<li>Overheads introduced when developing a graphical application for multiple platforms</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Standard look and feel or app theme</h1>
                </header>
            
            <article>
                
<p>When designing your graphical application, it's likely that an early question will be around the visual identity; should the application fit within the operating system's look and feel or should it have a brand of its own? Do you want to work on a complete theme for the user interface that the user will identify with, or do you wish to make use of the well-crafted and commonly understood interface elements of the user's operating system?</p>
<p>As with most questions that we will encounter throughout this chapter, there is no right or wrong answer, and whichever path you choose will have positive and negative side effects. Going with completely standard components will likely result in faster development and be easier for users to understand, but how do you differentiate your app from others? If you design the complete application interface from scratch, then you will develop a good brand identity for the software that users will recognize, but it may take them longer to learn and it could look out of place on the platform you are targeting.</p>
<p>Different design approaches typically suit different types of applications. Games clearly rely on heavily customized graphical interfaces and rarely use standard components but their users, the gamer community, understand the standard interactions of the genre so don't need the common visual cues that using the operating system's default elements provides. Utility apps (those that you load to do a quick task alongside your current work) will benefit from blending in so that very little thought is needed to operate them and no identity needs to be associated with the experience:</p>
<div class="CDPAlignCenter packt_figref"><img src="Images/36a9525a-2250-46a0-ad19-b99ffa9fb28c.png" style="width:44.67em;height:33.08em;" width="1159" height="858"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Microsoft Excel uses a blend of system components and brand identity. Used with permission from Microsoft. </span></div>
<p><span>Assuming that you have decided whether your visual design will fit with a standardized look or require a more bespoke approach, you need to consider the platforms you will deploy to. Is this an application designed for a single operating system or for many? If your software will only work on Windows, then using the standard look and feel could clearly be the way to go, but what if you are looking for a cross-platform distribution? macOS looks very different to Windows, which in turn is not the same as an average Linux desktop. Which do you target? Or, do you opt for the same interface design on all platforms?</span></p>
<p>The complexity of cross-platform GUI design is not a new problem, but it is one that requires some thought as you design the application experience. If you have a standardized interface design that works for your brand or application, will it apply equally well across different operating systems? Alternatively, if you aim to use standard components on each platform, how will you ensure a consistent user experience and how much more time will be put into support materials or your help desk?</p>
<p>When Java Swing was the standard for cross-platform graphical applications, their approach was unique: allow the developer to code against a standard API for building the GUI, but provide the ability for it to have different presentation modes, to look consistent across platforms, or to blend in with the system it is running on. This meant that the same application could be configured to look the same across all operating systems or to fit within the current desktop environment. Unfortunately, this method has its limitations, due to the way that it ends up providing a lowest-common-denominator set of functionality. Advanced integrations in one area would not be usable in a cross-platform app unless it were a feature of all supported operating systems.</p>
<p>Additionally, the user interface design can age badly on an operating system that changes look drastically from one release to another (such as Microsoft Windows moving from Vista to 7 to 10, each of which had quite distinctive looks):</p>
<p class="CDPAlignCenter packt_figref CDPAlign"><img src="Images/b01254d0-35d8-445a-b1ec-3179cb6f155d.png" style="width:35.75em;height:34.08em;" width="491" height="469"/></p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4a257393-6143-467c-a547-ccf287136c35.png" style="width:36.42em;height:34.50em;" width="495" height="469"/></p>
<div class="CDPAlignCenter packt_figref">Java Swing demo – cross-platform look (metal) on the top, macOS system look on the bottom</div>
<p>Over time, the number of ways to build graphical applications has increased, with many options available for most programming languages. Some are designed to use the system style, some prefer their own graphical style, and others leave that to developer or user preference. And so you must choose: do you want your app to blend in to a standard operating system look, or are you aiming for a brand identity or design that looks the same on each system you will deliver to? We will explore both options in <a href="36bfea00-c659-4569-864c-de2c460c7467.xhtml">Section 2</a>, <em>Toolkits Using Existing Widgets</em> and <a href="ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml">Section 3</a>, <em>Modern Graphical Toolkits</em> of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GUIs and visual hierarchy</h1>
                </header>
            
            <article>
                
<p>The graphical language and common visual layouts of software have evolved a lot over the recent history of consumer software products and continues to evolve. Each operating system and graphical toolkit focuses on usability while attempting to have a unique look. These principles have driven each platform in slightly different directions, which impacts the software we write and the content we present.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Multiple documents</h1>
                </header>
            
            <article>
                
<p>Let's first look at the ways that applications can handle multiple concurrent documents. These interfaces all aim to present a way to work with many documents at the same time. Whether it's a word processor, an image editor, or a web browser, there are many ways to approach this. An operating system typically has a default behavior that application developers are encouraged to use (sometimes by promoting enhanced usability with the latest changes, and other times by adding or removing APIs within their respective toolkits). These interface preferences can change over time, but can also become standardized around certain categories of application. For example, earlier in their history, Microsoft promoted the Windows <strong>multiple document interface </strong>(<strong>MDI</strong>) layout, which remains popular with text editors and <strong>integrated development environments</strong> (<strong>IDEs</strong>):</p>
<div class="CDPAlignCenter packt_figref"><img src="Images/3b7f1e9b-d3dd-4d2f-a64b-5c587cda1fa8.png" style="width:37.67em;height:24.75em;" width="917" height="603"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">An example application using the Microsoft Windows MDI layout</div>
<p><span>Developers of native macOS applications are encouraged to use a new window for each document, but to group them under the same application, so the user only sees one icon that groups them:</span></p>
<div class="CDPAlignCenter packt_figref"><img src="Images/918bd31f-1fe4-472e-8944-6e82615106c1.png" width="918" height="656"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Multiple documents in macOS load as windows of a single application</div>
<p><span>The Chrome web browser decided to integrate their tabbed display into the window header bar, a space that normally shows just the title of the application or loaded document:</span></p>
<div class="CDPAlignCenter"><img src="Images/b1682aea-e427-4ff7-9a8d-63529b4c85ae.png" style="width:50.92em;height:23.58em;" width="814" height="376"/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">This Chrome screenshot shows their distinct look for the tabbed display of loaded web pages</div>
<p>With all these possible approaches, which is right for your application? If you have to deal with multiple documents, it's worth looking at applications that manage similar file types, or comparing how various applications in the same environment handle window management.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accessory windows</h1>
                </header>
            
            <article>
                
<p>There is also a notable variance in the positioning of toolboxes and the grouping of features that relate to common areas of functionality. Over the years, there have been many iterations such as drawers (which slide out from the window) and pop-out dialog windows (still used where context is important but the tools are used less often), but the always-visible toolbar or accessory window remains the most popular.</p>
<p>For example, applications designed for Linux and Unix desktops <span>are </span>typically presented using separate windows for each of the supporting tool panels:</p>
<div class="CDPAlignCenter"><img src="Images/9df9898a-af3d-4107-ac4e-5b6bc3f0da2d.png" width="876" height="563"/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Multiple windows were commonly used in Gimp, the popular open source image manipulation program</div>
<p><span>Compare this with Windows software, which commonly uses a combined layout where controls are positioned around the borders of the document window:</span></p>
<div class="CDPAlignCenter packt_figref"><img src="Images/cbd4f924-4b3f-4cdd-8e9a-6b8b35996c24.png" width="1303" height="660"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">In Microsoft Paint, however, the tools are grouped at the top of the document. Used with permission from Microsoft.</div>
<p><span>Both of these approaches, within a single platform, provide a consistent user experience, but for a graphical application that targets multiple operating systems, it is important to consider which approach suits best. Does your software particularly suit one approach or the other? Maybe it will be easier for people to use your application if its graphical design adapts the layout to match the conventions of the platform it is running on.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Visual hierarchy</h1>
                </header>
            
            <article>
                
<p>The evolution of web-based applications followed a different path. Historically, this medium has been used for presenting large amounts of textual information and academic documents. This was usually formatted as hyperlinked content and often included a list of popular links in a navigation area that would help people to find important content. While it was common for each site to have a very individual look (distinct colors and typesetting have had their trends along the way), this grouping of content was largely consistent across the internet. It was a big shift from the desktop software at that time, but once a user had learned the way to interact with one website, they could relatively easily find their way around most of them.</p>
<p>In terms of applications that were delivered through a website, this had a large benefit: the standardized layout or visual hierarchy meant that a new, distinct design would still be usable by most internet-savvy computer users. This was in addition to the fact that they would look the same on any operating system or web browser. This consistency for the user made it easier for designers to apply rich visuals or branding to a web application without reducing the user experience. As the evolving <strong>Cascading Style Sheets </strong>(<strong>CSS</strong>) open standard gained popularity, it became easier to share subsets of these designs and to separate the layout details from the visual styling and brand. As a result, there emerged common code for structuring websites and applications, similar to the desktop toolkits that developers were familiar with. But combined with consistency across any internet-connected computer, this standard approach started to make desktop applications seem confusing to learn in comparison:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/17d3741d-4110-4a16-8556-d84759db6f47.png" style="width:27.08em;height:14.33em;" width="573" height="304"/></div>
<div class="CDPAlignCenter CDPAlign"><img src="Images/9faa5dd2-6de6-4627-a012-904c247dd2ad.png" style="width:26.75em;height:14.17em;" width="574" height="305"/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Standard web page layouts—on the top, the navigation is a side bar,<br/>
and in the next image, it is a shorter inline area</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mobile standards</h1>
                </header>
            
            <article>
                
<p class="mce-root CDPAlignLeft CDPAlign">Mobile applications pose a different design challenge: how to make a great user experience on a far smaller screen when the main input device is a touch screen where your fingers may obscure content. The companies behind the major mobile operating systems (Apple, Google, and Microsoft) spent many years developing a visual language and standard interactions that provided a smooth flow through increasingly complicated applications. As previously with web applications, it was important that native mobile applications behave in a consistent manner for users to quickly learn and feel comfortable with these new platforms. iOS, Android, and Windows Phone provide standard APIs that developers can use to create applications that fit with the platform standards. Within each platform, there are enough customization options to support brand identity through use of color, icons, or the content of each screen within the app. While the specific design aesthetic of mobile platforms has changed over the years, it is clear that the carefully designed layout and workflow aspects remain consistent throughout. Users can comfortably pick up the latest iPhone, appreciate its new design, and still be completely familiar with how the applications will work:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5988052c-ecfe-4cf6-abd4-55682a7e3c7f.png" style="width:14.67em;height:28.92em;" width="453" height="892"/></p>
<div class="mce-root CDPAlignCenter packt_figref">A standard iOS layout:navigation at the top and actions at the bottom</div>
<div class="CDPAlignCenter CDPAlign"><img src="Images/303715e9-14f2-49e1-9bf1-c8dee55aa647.png" style="width:13.67em;height:26.17em;" width="380" height="725"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A similar iOS layout 4 years earlier</div>
<p>There is clearly a lot more to designing an application GUI than designing a workflow and picking a color scheme. Will your application take inspiration from modern application UX, or is it aimed at users who are more familiar with the classic look of desktop applications established over many years? Will you be sticking to a single platform and its standard look and feel, or are you interested in launching your software across multiple operating systems? Before we look at the different toolkits available, take some time to consider these options and identify which is likely the right strategy for your application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Concurrency and multi-threading</h1>
                </header>
            
            <article>
                
<p>A GUI must remain responsive to user input at all times. While this is largely an aesthetic consideration, it is also possible that the operating system may monitor applications and force unresponsive user interfaces to quit. Effective event handling is what makes this possible, and this is the core paradigm for a GUI. The event handler is responsible for responding to user events (such as mouse click, finger tap, and keyboard entry), system events (such as file changes, network availability, and application state), and also for updating the user interface (such as rendering content, changing interface state, and more). Anything that stops this work from occurring could cause the application to stop responding. In most graphical toolkits, there is a single thread (a task that manages a set of concurrent operations) that is responsible for the event handling and graphical updates. In some systems, this is the main thread (where an application launches from), and in others it is a separate thread or process. It is important to know the semantics of the system you are using, as it is commonly required that only the graphical or event handling thread can make changes to the user interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Switching threads</h1>
                </header>
            
            <article>
                
<p>The ways that different toolkits and languages handle multithreading and graphical updates vary substantially. The following illustrations aim to highlight the complexity of this problem, in case you are not familiar with these constraints. The specifics sometimes vary based on language or version, but the concepts are usually consistent, otherwise software developed using the APIs would be very difficult to manage.</p>
<p>For our first example, consider an application written in Java. Its convention is that the graphics and user interaction are handled by a single event dispatch thread. Therefore, any change you wish to make to the user interface needs to be pushed to this thread using <kbd>SwingUtilities.invokeLater()</kbd>:</p>
<pre>SwingUtilities.invokeLater(new Runnable() {<br/>    public void run() {<br/>        button.SetText("Updated!");<br/>    }<br/>});</pre>
<p>The approach for working with Apple's operating systems is slightly different. Applications built with AppKit or UIKit (which are used for desktop and mobile applications respectively) start the user interface event handling on the main thread. This means that after the interface is configured, all processing must be handled on a background thread and changes to the user interface must be executed on the main thread. The objective-C block construct (for encapsulating a single behavior) makes this a little easier, but the code is still non-trivial:</p>
<pre>dispatch_async(dispatch_get_main_queue(), ^{<br/>    [button setTitle:@"Updated!" forState:UIControlStateNormal];<br/>});</pre>
<p>Applications using GTK (which supports building apps for various different platforms) have a similar restriction. For those, the graphical updates must be processed on whichever thread you invoked <kbd>gtk_init()</kbd> and <kbd>gtk_main()</kbd>. For such applications, the thread handling provided by <kbd>GLib</kbd> will help to manage multithreading in your application, but you have to set this up in the interface initialization code:</p>
<pre>...<br/>gtk_init(&amp;argc, &amp;argv);<br/>...<br/>gdk_threads_enter();<br/>gtk_main();<br/>gdk_threads_leave();<br/>...</pre>
<p>Then, you can use the gdk thread helpers to manage background updates as follows:</p>
<pre>gdk_threads_enter();<br/>gtk_button_set_label(GTK_BUTTON(label), "Updated!");<br/>gdk_threads_leave();</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Avoiding complexity</h1>
                </header>
            
            <article>
                
<p>Graphical toolkits do a lot to help application developers avoid the complications of concurrency where possible. For example, a button's click handler will typically run on the thread that controls graphical updates; this means that simple cases of user feedback or displaying data as a result of a user action can be done without worrying about multi-threading complexity. A simple callback function for an Android application may be as simple as the following code:</p>
<pre>button.setOnClickListener(new View.OnClickListener() {<br/>    public void onClick(View v) {<br/>        button.SetText("Updated!");<br/>    }<br/>});</pre>
<p>However, even a modest application is unlikely to avoid these complications for long. Consider a simple RSS newsfeed application; all it does is set up a GUI, load the contents of a newsfeed from a set URL, and display the results in a list in the user interface. To remain responsive, the graphical interface must be presented when the application loads, before requesting the contents of the news feed. As the feed downloads, it can be parsed and the items displayed. However, because this is executing as a background process, it is not allowed to simply make changes to the interface, such as adding list items. Instead, it must identify the items to be added and pass this information back to the main (or event dispatch) thread to show the updates to the user. Such code can be difficult to read and will often lead to debugging complexity, as concurrent software may not always behave in the same way. In the next chapter, we will look at how Go's design for handling concurrency can simplify this for us.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Web services and cloud integration</h1>
                </header>
            
            <article>
                
<p>Web services and online functionality is a core part of most applications today. Whether you are working with data downloaded from a central source, collaborating on documents stored online, or just looking to share your creation, this will probably be done via the internet. The core of most graphical toolkits and APIs are focused solely on the widgets—the presentation of the interface to the user. While this is due to various different reasons (and is evolving and expanding over time), it mostly reflects the period when they were created. Programming languages such as C and C++ underpin many of the native graphical toolkits (especially those targeting multiple platforms), and they pre-date cloud services and web-based APIs as we know them today. <span>Powerful web services and standardized protocols for communications vastly improve the speed of development for web-based applications. Conversely, they can make it harder for native graphical applications on the desktop where support is lacking from the core language or standard libraries.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communications</h1>
                </header>
            
            <article>
                
<p>Assuming that your chosen language either has good support for connecting to HTTP web services, or that a suitable library has been identified, then making a data transfer from your required service is not going to be a problem. However, what happens if the connection fails? While native GUI applications typically sit on a desktop or laptop computer where permanent network connections are common, it is not wise to rely on this. With increased remote working, coffee shop meetings, and higher levels of mobility (enabled by Wi-Fi and cellular networks), any modern application needs to handle unexpected network conditions.</p>
<p>When developing a web-based application, it may not be necessary to be as diligent as the user is probably already online. It's also possible that a failure of the internet connection could represent a fatal situation for the software, so in some situations an error displayed to the user asking them to try again later may be acceptable. However, user expectations of native graphical applications are far higher than this. Smart phones and the software they come with are expected to gracefully handle such failure conditions caused by frequent changes in network condition or availability. So, what can we do to match this higher expectation in these situations? This probably takes some planning; the error message of <em>Try again later</em> must be a last resort.</p>
<p>How much of your application actually requires an internet connection all the time (or at a specific point in the workflow)? Are there elements that can be accessed occasionally and stored locally (cached)? And is it OK for outgoing communications to happen at a later time, rather than immediately on user action? It's helpful to be creative when thinking about a network connection and when it's really needed. Not too long ago, a chat client (such as IRC, ICQ, MSN, and others) would need to be online all the time, and if the connection stopped responding, you'd have to wait until it reconnected. More recently, expectations have shifted and new chat services (such as Slack and Skype) will allow you to type into chats or channels even when offline, and messages will be delivered as soon as they can.</p>
<p>One additional challenge in a web-based connected world is authentication. Old password- and application secret-based authentication worked easily within most programming languages, but they had security issues. The most recent standard to be adopted is OAuth2, which aims to ensure that the user knows what they are allowing when applications connect to a secured service. The workflow is designed to work well in a web browser, but from within a native application, will it be a reasonable user experience to switch to a web browser when asking for permission? Will you improve the flow slightly by embedding a web view within your application? Unfortunately, it's been noted that this is also open to potential security attacks, and there is now a document focusing on the best practices for OAuth2 integration into native applications (IETF RFC 8252). Adapting applications to implement these recommendations will become a requirement over time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Data parsing</h1>
                </header>
            
            <article>
                
<p>Having established a connection to a remote server (or loaded the data from a local cache), the next challenge is likely to be parsing the response. Complicated string processing (which is what most HTTP-based APIs require due to their human readable design) is not a strength of many older programming languages that are common for native application development. Numerous libraries have been developed <span>that will help with this task </span>and are often shared freely (using an open source software license), but if the programming language does not have great string handling, it may still be a non-trivial task.</p>
<p><strong>Extensible Markup Language</strong> (<strong>XML</strong>) and <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) are the main formats for transferring data over the internet, both reinforced by the great support they have in all languages aimed at web development <span>(it should be no surprise that JSON usage is trivial in JavaScript applications)</span>. As the name implies, they are designed to transmit object-oriented, or structured, data, and there should be sufficient metadata within the content to allow objects to be recreated in the client software without complex un-marshaling code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Standard components</h1>
                </header>
            
            <article>
                
<p>One huge advance in cloud service integration with web development is the addition of <strong><span>Asynchronous JavaScript and XML </span></strong>(<strong><span>AJAX</span></strong>) functionality. Due to the ubiquitous support for JavaScript, XML, and HTML in all modern browsers, a web developer can configure parts of their user interface to refresh as a result of a web service request. Such an update does not require data parsing or merging information; the data from the server can literally be the replacement state for the user interface (in HTML or JavaScript format normally), and this directly replaces the old content.</p>
<p>Unfortunately, most native application toolkits do not have built-in components for displaying the results of a web service function call. Over time, however, popular services will often release libraries that assist with these features. If the company behind a web service does not create a supporting library or component, it is often the case that one may have been created independently and shared online. Languages that have good support for external modules, or provide a suitable package manager, often benefit the most from these sorts of contributions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing for multiple platforms</h1>
                </header>
            
            <article>
                
<p>Beyond the challenges described earlier in this chapter, graphical applications face additional complications when targeting multi-platform distributions. Dependency and package management are out of scope for this section as they affect system and web applications in broadly the same way, although system applications rarely have to handle packaged resources (such as images and design elements) and web applications are unlikely to publish binary packages. Outlined in this section are the main challenges that are unique to, or harder for, GUI-based applications planning a cross-platform strategy.  While each of these can be overcome, they typically introduce additional development overheads that should be taken into consideration when designing your application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-platform APIs</h1>
                </header>
            
            <article>
                
<p>When designing for multiple platforms the first consideration is probably the look and feel (see the <em>Standard look and feel or app theme</em> at the beginning of this chapter). However, it is also very important to consider whether your interface design will be easy to understand for your users (should it match the desktop widgets?). For a high-quality graphical application, it's important to consider how it will interact with the rest of the user's environment. For example, if your workflow included opening a web page outside the current interface, the expectation would probably be that it should open in the default web browser, which maybe configured by the operating system. Does the toolkit you selected handle opening web pages or other types of document specified by a URL? Will you instead need to write some code for each platform you wish to support to make the right thing happen?</p>
<p>To learn from the recent developments in mobile applications, we should look at the <kbd>Share</kbd> functionality. On Android, and more recently on iOS, an application can initiate a share action, and the platform toolkit will show an appropriate visual choice of ways to share that type of content. The user will then make their selection, and the application registered to handle that type of share will receive the content and request any further information required. How can native application developers of cross-platform applications provide similar functionality? If that is important to your application, then you could look for a language or toolkit that aims to provide this feature, but you may be left to try and implement it directly within your own code or to work with an external, web-based service to provide a similar experience.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Icons and design</h1>
                </header>
            
            <article>
                
<p>Most graphical environments (such as desktop, mobile, and more) have a default set of icons—those that are used to show file types, navigation arrows, and standard toolbars to help users recognize common actions. If your application is providing more than just the simplest of functionality, there will probably be a need to add some graphical elements to the design— most likely icons or symbols to help your users along. Will your additional icons match those provided by the environment the application is running in? If you are supporting just one platform, this is probably not an issue, but when you are aiming for a cross-platform solution, this could be much harder:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/084d241d-ace0-4a37-b774-2ee2d73c22fc.png" style="width:36.33em;height:22.83em;" width="597" height="373"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>The default style for macOS toolbar icons</span></div>
<p class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/09004296-9f23-4ad5-a8a6-c05f414917ed.png" style="width:37.33em;height:24.75em;" width="616" height="409"/></p>
<p class="CDPAlignCenter CDPAlign packt_figref"><span>Windows uses a very different style to macOS</span></p>
<p>Think about this challenge when designing your application GUI: do you need additional icons or graphical elements?  Doing so may be different to the system style, but it may match your user's expectations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>The only way to ensure a good-quality application is to test it on each platform that you aim to support. This is the same for system applications (which could aim to work on Linux and Mac, for example) and for web applications (each web browser could behave slightly differently). However, the variance in graphical desktop environments can be substantial, potentially leading to many different versions of your user interface. Additionally, setting up each of these platforms probably requires more computers, or some complicated multiple-boot setups. Virtualization offers a good solution here: where possible, you could create virtual environments to mimic each of the operating system installations you need to test on.</p>
<p>If you are including Linux or similar open source operating systems, remember that users are free to choose different desktop environments, each of which have a different look and default behavior. For example, if you are supporting Ubuntu Linux, you probably need to test the default environment (Unity) but also the very common <em>Gnome</em> alternative. There are many different desktop environments for Linux to consider, including KDE and Xfce, which are also very popular, each with a different look and feel and often with different workflows to consider.</p>
<p>Even if you intend to focus support on just Windows and macOS, you will still need to consider what versions you will support. The look and feel, and even default interactions, can change from one major release to another, so will you aim to adapt to these nuances or instead just provide a great experience for the latest version of these systems? Be sure to record which operating systems and versions (and even desktop configurations if you are going to target Linux) you will support and set up a test environment for each of these, if possible. It will help in the long run!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging and distribution</h1>
                </header>
            
            <article>
                
<p>Packaging a native graphical application for multiple platforms can introduce additional challenges. A native GUI will typically have to adapt to the current platform and it will <span>need to include package metadata to integrate as expected on a user's desktop.</span> Most graphical apps also require many assets to be embedded into the release package. Additionally, the semantics of installing an application vary from one operating system to another. macOS, for example, expects that applications are packaged as a <em>bundle</em> that can be dragged (or moved) from the <kbd>Downloads</kbd> folder into the <kbd>Applications</kbd> folder. Windows users will expect a single executable file that will run once downloaded, or an installer that can set up the components required. The platforms you aim to distribute on may impact your application capabilities or the resources it can be packaged with<span>, and we want to do this using a single code base for ease of maintenance</span>.</p>
<p>In recent years, we have seen many platforms create a<em>pp stores</em> or similar, where users can browse the applications available for their computer. This provides some free marketing and a new channel for downloads, but adds additional overheads for the developer. Screenshots and other metadata about your application will be required as a minimum, and to stand out, you may even need to create a video of your software in action. Stores such as these make installation trivial for the user but often place additional constraints on the developer. Be sure to research these distribution methods if you intend to use them for your application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed various additional complications that developers of native graphical applications are likely to face, especially if looking to build for multiple operating systems. Addressing the challenges around graphical presentation (visual hierarchy, system look or application design, and custom graphical elements) will take some planning and investigation—not just to design the ideal application, but also to choose the constraints or overheads that you will work with.</p>
<p>The remaining technical challenges—concurrency, web integration, packaging, and distribution—will vary based on the implementation language. As outlined previously, many graphical toolkits are created using languages that did not originally provide support for these considerations. Some provide low-level support that the developer must build upon for their application to meet the expected level of functionality for a modern GUI-based application. Thankfully, Go provides elegant solutions to many of these challenges. Although the language was not designed with GUIs built into the standard library, we will look at why Go is a great match for this kind of application in the next chapter.</p>


            </article>

            
        </section>
    </div>



  </body></html>