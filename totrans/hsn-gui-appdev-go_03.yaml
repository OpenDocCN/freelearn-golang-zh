- en: Graphical User Interface Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored the history of graphical user interfaces,
    looking at how they evolved and why they can provide a better user experience
    than contemporary alternatives. Unfortunately, despite all the benefits of graphical
    applications for end users, they can pose many challenges to the team designing
    and building them. In this chapter, we look at the sorts of issues that a team
    may face at various stages of creating an average-complexity graphical application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a look and feel to match the operating system or product brand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different approaches to application layout and multiple windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The challenges of concurrency and cloud service integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overheads introduced when developing a graphical application for multiple platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard look and feel or app theme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing your graphical application, it's likely that an early question
    will be around the visual identity; should the application fit within the operating
    system's look and feel or should it have a brand of its own? Do you want to work
    on a complete theme for the user interface that the user will identify with, or
    do you wish to make use of the well-crafted and commonly understood interface
    elements of the user's operating system?
  prefs: []
  type: TYPE_NORMAL
- en: As with most questions that we will encounter throughout this chapter, there
    is no right or wrong answer, and whichever path you choose will have positive
    and negative side effects. Going with completely standard components will likely
    result in faster development and be easier for users to understand, but how do
    you differentiate your app from others? If you design the complete application
    interface from scratch, then you will develop a good brand identity for the software
    that users will recognize, but it may take them longer to learn and it could look
    out of place on the platform you are targeting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different design approaches typically suit different types of applications.
    Games clearly rely on heavily customized graphical interfaces and rarely use standard
    components but their users, the gamer community, understand the standard interactions
    of the genre so don''t need the common visual cues that using the operating system''s
    default elements provides. Utility apps (those that you load to do a quick task
    alongside your current work) will benefit from blending in so that very little
    thought is needed to operate them and no identity needs to be associated with
    the experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36a9525a-2250-46a0-ad19-b99ffa9fb28c.png)'
  prefs: []
  type: TYPE_IMG
- en: Microsoft Excel uses a blend of system components and brand identity. Used with
    permission from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you have decided whether your visual design will fit with a standardized
    look or require a more bespoke approach, you need to consider the platforms you
    will deploy to. Is this an application designed for a single operating system
    or for many? If your software will only work on Windows, then using the standard
    look and feel could clearly be the way to go, but what if you are looking for
    a cross-platform distribution? macOS looks very different to Windows, which in
    turn is not the same as an average Linux desktop. Which do you target? Or, do
    you opt for the same interface design on all platforms?
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of cross-platform GUI design is not a new problem, but it is
    one that requires some thought as you design the application experience. If you
    have a standardized interface design that works for your brand or application,
    will it apply equally well across different operating systems? Alternatively,
    if you aim to use standard components on each platform, how will you ensure a
    consistent user experience and how much more time will be put into support materials
    or your help desk?
  prefs: []
  type: TYPE_NORMAL
- en: 'When Java Swing was the standard for cross-platform graphical applications,
    their approach was unique: allow the developer to code against a standard API
    for building the GUI, but provide the ability for it to have different presentation
    modes, to look consistent across platforms, or to blend in with the system it
    is running on. This meant that the same application could be configured to look
    the same across all operating systems or to fit within the current desktop environment.
    Unfortunately, this method has its limitations, due to the way that it ends up
    providing a lowest-common-denominator set of functionality. Advanced integrations
    in one area would not be usable in a cross-platform app unless it were a feature
    of all supported operating systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the user interface design can age badly on an operating system
    that changes look drastically from one release to another (such as Microsoft Windows
    moving from Vista to 7 to 10, each of which had quite distinctive looks):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b01254d0-35d8-445a-b1ec-3179cb6f155d.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/4a257393-6143-467c-a547-ccf287136c35.png)'
  prefs: []
  type: TYPE_IMG
- en: Java Swing demo – cross-platform look (metal) on the top, macOS system look
    on the bottom
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, the number of ways to build graphical applications has increased,
    with many options available for most programming languages. Some are designed
    to use the system style, some prefer their own graphical style, and others leave
    that to developer or user preference. And so you must choose: do you want your
    app to blend in to a standard operating system look, or are you aiming for a brand
    identity or design that looks the same on each system you will deliver to? We
    will explore both options in [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits
    Using Existing Widgets* and [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits* of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: GUIs and visual hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The graphical language and common visual layouts of software have evolved a
    lot over the recent history of consumer software products and continues to evolve.
    Each operating system and graphical toolkit focuses on usability while attempting
    to have a unique look. These principles have driven each platform in slightly
    different directions, which impacts the software we write and the content we present.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first look at the ways that applications can handle multiple concurrent
    documents. These interfaces all aim to present a way to work with many documents
    at the same time. Whether it''s a word processor, an image editor, or a web browser,
    there are many ways to approach this. An operating system typically has a default
    behavior that application developers are encouraged to use (sometimes by promoting
    enhanced usability with the latest changes, and other times by adding or removing
    APIs within their respective toolkits). These interface preferences can change
    over time, but can also become standardized around certain categories of application.
    For example, earlier in their history, Microsoft promoted the Windows **multiple
    document interface **(**MDI**) layout, which remains popular with text editors
    and **integrated development environments** (**IDEs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b7f1e9b-d3dd-4d2f-a64b-5c587cda1fa8.png)'
  prefs: []
  type: TYPE_IMG
- en: An example application using the Microsoft Windows MDI layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers of native macOS applications are encouraged to use a new window
    for each document, but to group them under the same application, so the user only
    sees one icon that groups them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/918bd31f-1fe4-472e-8944-6e82615106c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple documents in macOS load as windows of a single application
  prefs: []
  type: TYPE_NORMAL
- en: 'The Chrome web browser decided to integrate their tabbed display into the window
    header bar, a space that normally shows just the title of the application or loaded
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1682aea-e427-4ff7-9a8d-63529b4c85ae.png)'
  prefs: []
  type: TYPE_IMG
- en: This Chrome screenshot shows their distinct look for the tabbed display of loaded
    web pages
  prefs: []
  type: TYPE_NORMAL
- en: With all these possible approaches, which is right for your application? If
    you have to deal with multiple documents, it's worth looking at applications that
    manage similar file types, or comparing how various applications in the same environment
    handle window management.
  prefs: []
  type: TYPE_NORMAL
- en: Accessory windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is also a notable variance in the positioning of toolboxes and the grouping
    of features that relate to common areas of functionality. Over the years, there
    have been many iterations such as drawers (which slide out from the window) and
    pop-out dialog windows (still used where context is important but the tools are
    used less often), but the always-visible toolbar or accessory window remains the
    most popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, applications designed for Linux and Unix desktops are typically
    presented using separate windows for each of the supporting tool panels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9df9898a-af3d-4107-ac4e-5b6bc3f0da2d.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple windows were commonly used in Gimp, the popular open source image manipulation
    program
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare this with Windows software, which commonly uses a combined layout where
    controls are positioned around the borders of the document window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbd4f924-4b3f-4cdd-8e9a-6b8b35996c24.png)'
  prefs: []
  type: TYPE_IMG
- en: In Microsoft Paint, however, the tools are grouped at the top of the document.
    Used with permission from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these approaches, within a single platform, provide a consistent user
    experience, but for a graphical application that targets multiple operating systems,
    it is important to consider which approach suits best. Does your software particularly
    suit one approach or the other? Maybe it will be easier for people to use your
    application if its graphical design adapts the layout to match the conventions
    of the platform it is running on.
  prefs: []
  type: TYPE_NORMAL
- en: Visual hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The evolution of web-based applications followed a different path. Historically,
    this medium has been used for presenting large amounts of textual information
    and academic documents. This was usually formatted as hyperlinked content and
    often included a list of popular links in a navigation area that would help people
    to find important content. While it was common for each site to have a very individual
    look (distinct colors and typesetting have had their trends along the way), this
    grouping of content was largely consistent across the internet. It was a big shift
    from the desktop software at that time, but once a user had learned the way to
    interact with one website, they could relatively easily find their way around
    most of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of applications that were delivered through a website, this had a
    large benefit: the standardized layout or visual hierarchy meant that a new, distinct
    design would still be usable by most internet-savvy computer users. This was in
    addition to the fact that they would look the same on any operating system or
    web browser. This consistency for the user made it easier for designers to apply
    rich visuals or branding to a web application without reducing the user experience.
    As the evolving **Cascading Style Sheets **(**CSS**) open standard gained popularity,
    it became easier to share subsets of these designs and to separate the layout
    details from the visual styling and brand. As a result, there emerged common code
    for structuring websites and applications, similar to the desktop toolkits that
    developers were familiar with. But combined with consistency across any internet-connected
    computer, this standard approach started to make desktop applications seem confusing
    to learn in comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17d3741d-4110-4a16-8556-d84759db6f47.png)![](img/9faa5dd2-6de6-4627-a012-904c247dd2ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Standard web page layouts—on the top, the navigation is a side bar,
  prefs: []
  type: TYPE_NORMAL
- en: and in the next image, it is a shorter inline area
  prefs: []
  type: TYPE_NORMAL
- en: Mobile standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mobile applications pose a different design challenge: how to make a great
    user experience on a far smaller screen when the main input device is a touch
    screen where your fingers may obscure content. The companies behind the major
    mobile operating systems (Apple, Google, and Microsoft) spent many years developing
    a visual language and standard interactions that provided a smooth flow through
    increasingly complicated applications. As previously with web applications, it
    was important that native mobile applications behave in a consistent manner for
    users to quickly learn and feel comfortable with these new platforms. iOS, Android,
    and Windows Phone provide standard APIs that developers can use to create applications
    that fit with the platform standards. Within each platform, there are enough customization
    options to support brand identity through use of color, icons, or the content
    of each screen within the app. While the specific design aesthetic of mobile platforms
    has changed over the years, it is clear that the carefully designed layout and
    workflow aspects remain consistent throughout. Users can comfortably pick up the
    latest iPhone, appreciate its new design, and still be completely familiar with
    how the applications will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5988052c-ecfe-4cf6-abd4-55682a7e3c7f.png)'
  prefs: []
  type: TYPE_IMG
- en: A standard iOS layout:navigation at the top and actions at the bottom
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/303715e9-14f2-49e1-9bf1-c8dee55aa647.png)'
  prefs: []
  type: TYPE_IMG
- en: A similar iOS layout 4 years earlier
  prefs: []
  type: TYPE_NORMAL
- en: There is clearly a lot more to designing an application GUI than designing a
    workflow and picking a color scheme. Will your application take inspiration from
    modern application UX, or is it aimed at users who are more familiar with the
    classic look of desktop applications established over many years? Will you be
    sticking to a single platform and its standard look and feel, or are you interested
    in launching your software across multiple operating systems? Before we look at
    the different toolkits available, take some time to consider these options and
    identify which is likely the right strategy for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and multi-threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GUI must remain responsive to user input at all times. While this is largely
    an aesthetic consideration, it is also possible that the operating system may
    monitor applications and force unresponsive user interfaces to quit. Effective
    event handling is what makes this possible, and this is the core paradigm for
    a GUI. The event handler is responsible for responding to user events (such as
    mouse click, finger tap, and keyboard entry), system events (such as file changes,
    network availability, and application state), and also for updating the user interface
    (such as rendering content, changing interface state, and more). Anything that
    stops this work from occurring could cause the application to stop responding.
    In most graphical toolkits, there is a single thread (a task that manages a set
    of concurrent operations) that is responsible for the event handling and graphical
    updates. In some systems, this is the main thread (where an application launches
    from), and in others it is a separate thread or process. It is important to know
    the semantics of the system you are using, as it is commonly required that only
    the graphical or event handling thread can make changes to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Switching threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ways that different toolkits and languages handle multithreading and graphical
    updates vary substantially. The following illustrations aim to highlight the complexity
    of this problem, in case you are not familiar with these constraints. The specifics
    sometimes vary based on language or version, but the concepts are usually consistent,
    otherwise software developed using the APIs would be very difficult to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first example, consider an application written in Java. Its convention
    is that the graphics and user interaction are handled by a single event dispatch
    thread. Therefore, any change you wish to make to the user interface needs to
    be pushed to this thread using `SwingUtilities.invokeLater()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach for working with Apple''s operating systems is slightly different.
    Applications built with AppKit or UIKit (which are used for desktop and mobile
    applications respectively) start the user interface event handling on the main
    thread. This means that after the interface is configured, all processing must
    be handled on a background thread and changes to the user interface must be executed
    on the main thread. The objective-C block construct (for encapsulating a single
    behavior) makes this a little easier, but the code is still non-trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Applications using GTK (which supports building apps for various different
    platforms) have a similar restriction. For those, the graphical updates must be
    processed on whichever thread you invoked `gtk_init()` and `gtk_main()`. For such
    applications, the thread handling provided by `GLib` will help to manage multithreading
    in your application, but you have to set this up in the interface initialization
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use the gdk thread helpers to manage background updates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphical toolkits do a lot to help application developers avoid the complications
    of concurrency where possible. For example, a button''s click handler will typically
    run on the thread that controls graphical updates; this means that simple cases
    of user feedback or displaying data as a result of a user action can be done without
    worrying about multi-threading complexity. A simple callback function for an Android
    application may be as simple as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, even a modest application is unlikely to avoid these complications
    for long. Consider a simple RSS newsfeed application; all it does is set up a
    GUI, load the contents of a newsfeed from a set URL, and display the results in
    a list in the user interface. To remain responsive, the graphical interface must
    be presented when the application loads, before requesting the contents of the
    news feed. As the feed downloads, it can be parsed and the items displayed. However,
    because this is executing as a background process, it is not allowed to simply
    make changes to the interface, such as adding list items. Instead, it must identify
    the items to be added and pass this information back to the main (or event dispatch)
    thread to show the updates to the user. Such code can be difficult to read and
    will often lead to debugging complexity, as concurrent software may not always
    behave in the same way. In the next chapter, we will look at how Go's design for
    handling concurrency can simplify this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Web services and cloud integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web services and online functionality is a core part of most applications today.
    Whether you are working with data downloaded from a central source, collaborating
    on documents stored online, or just looking to share your creation, this will
    probably be done via the internet. The core of most graphical toolkits and APIs
    are focused solely on the widgets—the presentation of the interface to the user.
    While this is due to various different reasons (and is evolving and expanding
    over time), it mostly reflects the period when they were created. Programming
    languages such as C and C++ underpin many of the native graphical toolkits (especially
    those targeting multiple platforms), and they pre-date cloud services and web-based
    APIs as we know them today. Powerful web services and standardized protocols for
    communications vastly improve the speed of development for web-based applications.
    Conversely, they can make it harder for native graphical applications on the desktop
    where support is lacking from the core language or standard libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming that your chosen language either has good support for connecting to
    HTTP web services, or that a suitable library has been identified, then making
    a data transfer from your required service is not going to be a problem. However,
    what happens if the connection fails? While native GUI applications typically
    sit on a desktop or laptop computer where permanent network connections are common,
    it is not wise to rely on this. With increased remote working, coffee shop meetings,
    and higher levels of mobility (enabled by Wi-Fi and cellular networks), any modern
    application needs to handle unexpected network conditions.
  prefs: []
  type: TYPE_NORMAL
- en: When developing a web-based application, it may not be necessary to be as diligent
    as the user is probably already online. It's also possible that a failure of the
    internet connection could represent a fatal situation for the software, so in
    some situations an error displayed to the user asking them to try again later
    may be acceptable. However, user expectations of native graphical applications
    are far higher than this. Smart phones and the software they come with are expected
    to gracefully handle such failure conditions caused by frequent changes in network
    condition or availability. So, what can we do to match this higher expectation
    in these situations? This probably takes some planning; the error message of *Try
    again later* must be a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: How much of your application actually requires an internet connection all the
    time (or at a specific point in the workflow)? Are there elements that can be
    accessed occasionally and stored locally (cached)? And is it OK for outgoing communications
    to happen at a later time, rather than immediately on user action? It's helpful
    to be creative when thinking about a network connection and when it's really needed.
    Not too long ago, a chat client (such as IRC, ICQ, MSN, and others) would need
    to be online all the time, and if the connection stopped responding, you'd have
    to wait until it reconnected. More recently, expectations have shifted and new
    chat services (such as Slack and Skype) will allow you to type into chats or channels
    even when offline, and messages will be delivered as soon as they can.
  prefs: []
  type: TYPE_NORMAL
- en: One additional challenge in a web-based connected world is authentication. Old
    password- and application secret-based authentication worked easily within most
    programming languages, but they had security issues. The most recent standard
    to be adopted is OAuth2, which aims to ensure that the user knows what they are
    allowing when applications connect to a secured service. The workflow is designed
    to work well in a web browser, but from within a native application, will it be
    a reasonable user experience to switch to a web browser when asking for permission?
    Will you improve the flow slightly by embedding a web view within your application?
    Unfortunately, it's been noted that this is also open to potential security attacks,
    and there is now a document focusing on the best practices for OAuth2 integration
    into native applications (IETF RFC 8252). Adapting applications to implement these
    recommendations will become a requirement over time.
  prefs: []
  type: TYPE_NORMAL
- en: Data parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having established a connection to a remote server (or loaded the data from
    a local cache), the next challenge is likely to be parsing the response. Complicated
    string processing (which is what most HTTP-based APIs require due to their human
    readable design) is not a strength of many older programming languages that are
    common for native application development. Numerous libraries have been developed
    that will help with this task and are often shared freely (using an open source
    software license), but if the programming language does not have great string
    handling, it may still be a non-trivial task.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensible Markup Language** (**XML**) and **JavaScript Object Notation** (**JSON**)
    are the main formats for transferring data over the internet, both reinforced
    by the great support they have in all languages aimed at web development (it should
    be no surprise that JSON usage is trivial in JavaScript applications). As the
    name implies, they are designed to transmit object-oriented, or structured, data,
    and there should be sufficient metadata within the content to allow objects to
    be recreated in the client software without complex un-marshaling code.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One huge advance in cloud service integration with web development is the addition
    of **Asynchronous JavaScript and XML **(**AJAX**) functionality. Due to the ubiquitous
    support for JavaScript, XML, and HTML in all modern browsers, a web developer
    can configure parts of their user interface to refresh as a result of a web service
    request. Such an update does not require data parsing or merging information;
    the data from the server can literally be the replacement state for the user interface
    (in HTML or JavaScript format normally), and this directly replaces the old content.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, most native application toolkits do not have built-in components
    for displaying the results of a web service function call. Over time, however,
    popular services will often release libraries that assist with these features.
    If the company behind a web service does not create a supporting library or component,
    it is often the case that one may have been created independently and shared online.
    Languages that have good support for external modules, or provide a suitable package
    manager, often benefit the most from these sorts of contributions.
  prefs: []
  type: TYPE_NORMAL
- en: Developing for multiple platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond the challenges described earlier in this chapter, graphical applications
    face additional complications when targeting multi-platform distributions. Dependency
    and package management are out of scope for this section as they affect system
    and web applications in broadly the same way, although system applications rarely
    have to handle packaged resources (such as images and design elements) and web
    applications are unlikely to publish binary packages. Outlined in this section
    are the main challenges that are unique to, or harder for, GUI-based applications
    planning a cross-platform strategy.  While each of these can be overcome, they
    typically introduce additional development overheads that should be taken into
    consideration when designing your application.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing for multiple platforms the first consideration is probably the
    look and feel (see the *Standard look and feel or app theme* at the beginning
    of this chapter). However, it is also very important to consider whether your
    interface design will be easy to understand for your users (should it match the
    desktop widgets?). For a high-quality graphical application, it's important to
    consider how it will interact with the rest of the user's environment. For example,
    if your workflow included opening a web page outside the current interface, the
    expectation would probably be that it should open in the default web browser,
    which maybe configured by the operating system. Does the toolkit you selected
    handle opening web pages or other types of document specified by a URL? Will you
    instead need to write some code for each platform you wish to support to make
    the right thing happen?
  prefs: []
  type: TYPE_NORMAL
- en: To learn from the recent developments in mobile applications, we should look
    at the `Share` functionality. On Android, and more recently on iOS, an application
    can initiate a share action, and the platform toolkit will show an appropriate
    visual choice of ways to share that type of content. The user will then make their
    selection, and the application registered to handle that type of share will receive
    the content and request any further information required. How can native application
    developers of cross-platform applications provide similar functionality? If that
    is important to your application, then you could look for a language or toolkit
    that aims to provide this feature, but you may be left to try and implement it
    directly within your own code or to work with an external, web-based service to
    provide a similar experience.
  prefs: []
  type: TYPE_NORMAL
- en: Icons and design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most graphical environments (such as desktop, mobile, and more) have a default
    set of icons—those that are used to show file types, navigation arrows, and standard
    toolbars to help users recognize common actions. If your application is providing
    more than just the simplest of functionality, there will probably be a need to
    add some graphical elements to the design— most likely icons or symbols to help
    your users along. Will your additional icons match those provided by the environment
    the application is running in? If you are supporting just one platform, this is
    probably not an issue, but when you are aiming for a cross-platform solution,
    this could be much harder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/084d241d-ace0-4a37-b774-2ee2d73c22fc.png)'
  prefs: []
  type: TYPE_IMG
- en: The default style for macOS toolbar icons
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09004296-9f23-4ad5-a8a6-c05f414917ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Windows uses a very different style to macOS
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about this challenge when designing your application GUI: do you need
    additional icons or graphical elements?  Doing so may be different to the system
    style, but it may match your user''s expectations.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only way to ensure a good-quality application is to test it on each platform
    that you aim to support. This is the same for system applications (which could
    aim to work on Linux and Mac, for example) and for web applications (each web
    browser could behave slightly differently). However, the variance in graphical
    desktop environments can be substantial, potentially leading to many different
    versions of your user interface. Additionally, setting up each of these platforms
    probably requires more computers, or some complicated multiple-boot setups. Virtualization
    offers a good solution here: where possible, you could create virtual environments
    to mimic each of the operating system installations you need to test on.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are including Linux or similar open source operating systems, remember
    that users are free to choose different desktop environments, each of which have
    a different look and default behavior. For example, if you are supporting Ubuntu
    Linux, you probably need to test the default environment (Unity) but also the
    very common *Gnome* alternative. There are many different desktop environments
    for Linux to consider, including KDE and Xfce, which are also very popular, each
    with a different look and feel and often with different workflows to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you intend to focus support on just Windows and macOS, you will still
    need to consider what versions you will support. The look and feel, and even default
    interactions, can change from one major release to another, so will you aim to
    adapt to these nuances or instead just provide a great experience for the latest
    version of these systems? Be sure to record which operating systems and versions
    (and even desktop configurations if you are going to target Linux) you will support
    and set up a test environment for each of these, if possible. It will help in
    the long run!
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging a native graphical application for multiple platforms can introduce
    additional challenges. A native GUI will typically have to adapt to the current
    platform and it will need to include package metadata to integrate as expected
    on a user's desktop. Most graphical apps also require many assets to be embedded
    into the release package. Additionally, the semantics of installing an application
    vary from one operating system to another. macOS, for example, expects that applications
    are packaged as a *bundle* that can be dragged (or moved) from the `Downloads`
    folder into the `Applications` folder. Windows users will expect a single executable
    file that will run once downloaded, or an installer that can set up the components
    required. The platforms you aim to distribute on may impact your application capabilities
    or the resources it can be packaged with, and we want to do this using a single
    code base for ease of maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, we have seen many platforms create a*pp stores* or similar,
    where users can browse the applications available for their computer. This provides
    some free marketing and a new channel for downloads, but adds additional overheads
    for the developer. Screenshots and other metadata about your application will
    be required as a minimum, and to stand out, you may even need to create a video
    of your software in action. Stores such as these make installation trivial for
    the user but often place additional constraints on the developer. Be sure to research
    these distribution methods if you intend to use them for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed various additional complications that developers
    of native graphical applications are likely to face, especially if looking to
    build for multiple operating systems. Addressing the challenges around graphical
    presentation (visual hierarchy, system look or application design, and custom
    graphical elements) will take some planning and investigation—not just to design
    the ideal application, but also to choose the constraints or overheads that you
    will work with.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining technical challenges—concurrency, web integration, packaging,
    and distribution—will vary based on the implementation language. As outlined previously,
    many graphical toolkits are created using languages that did not originally provide
    support for these considerations. Some provide low-level support that the developer
    must build upon for their application to meet the expected level of functionality
    for a modern GUI-based application. Thankfully, Go provides elegant solutions
    to many of these challenges. Although the language was not designed with GUIs
    built into the standard library, we will look at why Go is a great match for this
    kind of application in the next chapter.
  prefs: []
  type: TYPE_NORMAL
