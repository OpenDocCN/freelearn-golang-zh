- en: Graphical User Interface Challenges
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形用户界面挑战
- en: In the previous chapter, we explored the history of graphical user interfaces,
    looking at how they evolved and why they can provide a better user experience
    than contemporary alternatives. Unfortunately, despite all the benefits of graphical
    applications for end users, they can pose many challenges to the team designing
    and building them. In this chapter, we look at the sorts of issues that a team
    may face at various stages of creating an average-complexity graphical application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了图形用户界面的历史，了解了它们是如何演变的以及为什么它们可以比当代替代品提供更好的用户体验。不幸的是，尽管图形应用程序对最终用户有很多好处，但它们会给设计和构建它们的团队带来许多挑战。在本章中，我们将探讨团队在创建平均复杂度的图形应用程序的各个阶段可能面临的问题。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Choosing a look and feel to match the operating system or product brand
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择与操作系统或产品品牌相匹配的外观和感觉
- en: Different approaches to application layout and multiple windows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序布局的不同方法和多个窗口
- en: The challenges of concurrency and cloud service integration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发和云服务集成的挑战
- en: Overheads introduced when developing a graphical application for multiple platforms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在为多个平台开发图形应用程序时引入的 overheads
- en: Standard look and feel or app theme
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准外观和感觉或应用程序主题
- en: When designing your graphical application, it's likely that an early question
    will be around the visual identity; should the application fit within the operating
    system's look and feel or should it have a brand of its own? Do you want to work
    on a complete theme for the user interface that the user will identify with, or
    do you wish to make use of the well-crafted and commonly understood interface
    elements of the user's operating system?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计你的图形应用程序时，一个早期的问题可能是关于视觉身份；应用程序是否应该符合操作系统的外观和感觉，或者它应该有自己的品牌？你希望为用户界面工作一个完整的主题，用户会认同它，还是希望利用用户操作系统的精心制作和普遍理解的界面元素？
- en: As with most questions that we will encounter throughout this chapter, there
    is no right or wrong answer, and whichever path you choose will have positive
    and negative side effects. Going with completely standard components will likely
    result in faster development and be easier for users to understand, but how do
    you differentiate your app from others? If you design the complete application
    interface from scratch, then you will develop a good brand identity for the software
    that users will recognize, but it may take them longer to learn and it could look
    out of place on the platform you are targeting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本章中会遇到的大多数问题一样，没有正确或错误的答案，你选择的任何路径都会有正面和负面的影响。完全使用标准组件可能会使开发更快，并且对用户来说更容易理解，但你如何使你的应用程序与其他应用程序区分开来？如果你从头开始设计完整的应用程序界面，那么你将为软件开发一个良好的品牌识别度，用户会认出它，但这可能需要他们更长的时间来学习，并且可能在目标平台上看起来不合适。
- en: 'Different design approaches typically suit different types of applications.
    Games clearly rely on heavily customized graphical interfaces and rarely use standard
    components but their users, the gamer community, understand the standard interactions
    of the genre so don''t need the common visual cues that using the operating system''s
    default elements provides. Utility apps (those that you load to do a quick task
    alongside your current work) will benefit from blending in so that very little
    thought is needed to operate them and no identity needs to be associated with
    the experience:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的设计方法通常适合不同类型的应用程序。游戏明显依赖于高度定制的图形界面，很少使用标准组件，但他们的用户，游戏社区，理解该类别的标准交互，因此不需要使用操作系统默认元素提供的常见视觉提示。实用应用程序（那些你在当前工作中快速完成任务时加载的应用程序）将受益于融入其中，这样操作它们时几乎不需要思考，并且不需要将任何身份与体验相关联：
- en: '![](img/36a9525a-2250-46a0-ad19-b99ffa9fb28c.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36a9525a-2250-46a0-ad19-b99ffa9fb28c.png)'
- en: Microsoft Excel uses a blend of system components and brand identity. Used with
    permission from Microsoft.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Excel 使用系统组件和品牌身份的混合。经微软许可使用。
- en: Assuming that you have decided whether your visual design will fit with a standardized
    look or require a more bespoke approach, you need to consider the platforms you
    will deploy to. Is this an application designed for a single operating system
    or for many? If your software will only work on Windows, then using the standard
    look and feel could clearly be the way to go, but what if you are looking for
    a cross-platform distribution? macOS looks very different to Windows, which in
    turn is not the same as an average Linux desktop. Which do you target? Or, do
    you opt for the same interface design on all platforms?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经决定你的视觉设计是适合标准化外观还是需要更定制化的方法，你需要考虑你将部署的平台。这是一个为单一操作系统设计的应用，还是为多个操作系统设计的？如果你的软件只能在Windows上运行，那么使用标准的外观和感觉显然是可行的，但如果你在寻找跨平台分发呢？macOS看起来与Windows截然不同，而Windows又与平均的Linux桌面不同。你将针对哪个？或者，你选择在所有平台上使用相同的界面设计？
- en: The complexity of cross-platform GUI design is not a new problem, but it is
    one that requires some thought as you design the application experience. If you
    have a standardized interface design that works for your brand or application,
    will it apply equally well across different operating systems? Alternatively,
    if you aim to use standard components on each platform, how will you ensure a
    consistent user experience and how much more time will be put into support materials
    or your help desk?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台GUI设计的复杂性不是一个新问题，但在设计应用体验时，它确实需要一些思考。如果你有一个适用于你的品牌或应用的标准化界面设计，它是否能在不同的操作系统上一视同仁呢？或者，如果你旨在在每个平台上使用标准组件，你将如何确保一致的用户体验，以及你将投入多少时间到支持材料或客服台？
- en: 'When Java Swing was the standard for cross-platform graphical applications,
    their approach was unique: allow the developer to code against a standard API
    for building the GUI, but provide the ability for it to have different presentation
    modes, to look consistent across platforms, or to blend in with the system it
    is running on. This meant that the same application could be configured to look
    the same across all operating systems or to fit within the current desktop environment.
    Unfortunately, this method has its limitations, due to the way that it ends up
    providing a lowest-common-denominator set of functionality. Advanced integrations
    in one area would not be usable in a cross-platform app unless it were a feature
    of all supported operating systems.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java Swing是跨平台图形应用的标准时，它们的做法是独特的：允许开发者针对标准API编写代码以构建GUI，但提供使其在不同平台上有不同呈现模式的能力，以保持跨平台的一致性，或者与它运行的系统融为一体。这意味着同一个应用可以被配置为在所有操作系统上看起来都一样，或者适应当前的桌面环境。不幸的是，这种方法有其局限性，因为它最终提供的是一组最低的共同功能集。除非它是所有支持操作系统的特性，否则一个区域的高级集成在跨平台应用中是不可用的。
- en: 'Additionally, the user interface design can age badly on an operating system
    that changes look drastically from one release to another (such as Microsoft Windows
    moving from Vista to 7 to 10, each of which had quite distinctive looks):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户界面设计在操作系统外观发生剧烈变化的情况下可能会显得过时（例如，微软Windows从Vista到7再到10的转变，每个版本都有相当独特的样子）：
- en: '![](img/b01254d0-35d8-445a-b1ec-3179cb6f155d.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b01254d0-35d8-445a-b1ec-3179cb6f155d.png)'
- en: '![](img/4a257393-6143-467c-a547-ccf287136c35.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a257393-6143-467c-a547-ccf287136c35.png)'
- en: Java Swing demo – cross-platform look (metal) on the top, macOS system look
    on the bottom
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java Swing演示 - 顶部为跨平台外观（金属），底部为macOS系统外观
- en: 'Over time, the number of ways to build graphical applications has increased,
    with many options available for most programming languages. Some are designed
    to use the system style, some prefer their own graphical style, and others leave
    that to developer or user preference. And so you must choose: do you want your
    app to blend in to a standard operating system look, or are you aiming for a brand
    identity or design that looks the same on each system you will deliver to? We
    will explore both options in [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits
    Using Existing Widgets* and [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits* of this book.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，构建图形应用的方法越来越多，大多数编程语言都有很多选项。有些是为使用系统样式而设计的，有些则偏好自己的图形样式，而有些则留给开发者或用户偏好。因此，你必须做出选择：你希望你的应用融入标准操作系统的外观，还是你希望实现一个在每个系统上看起来都一样的品牌身份或设计？我们将在这本书的[第2节](36bfea00-c659-4569-864c-de2c460c7467.xhtml)和[第3节](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml)中探讨这两种选项，即*使用现有小部件的工具包*和*现代图形工具包*。
- en: GUIs and visual hierarchy
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形用户界面和视觉层次结构
- en: The graphical language and common visual layouts of software have evolved a
    lot over the recent history of consumer software products and continues to evolve.
    Each operating system and graphical toolkit focuses on usability while attempting
    to have a unique look. These principles have driven each platform in slightly
    different directions, which impacts the software we write and the content we present.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的图形语言和常见的视觉布局在消费软件产品的近期历史中已经发生了很大的变化，并且仍在不断发展。每个操作系统和图形工具包都专注于可用性，同时试图拥有独特的风格。这些原则推动了每个平台以略微不同的方向前进，这影响了我们所编写的软件和我们所呈现的内容。
- en: Multiple documents
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个文档
- en: 'Let''s first look at the ways that applications can handle multiple concurrent
    documents. These interfaces all aim to present a way to work with many documents
    at the same time. Whether it''s a word processor, an image editor, or a web browser,
    there are many ways to approach this. An operating system typically has a default
    behavior that application developers are encouraged to use (sometimes by promoting
    enhanced usability with the latest changes, and other times by adding or removing
    APIs within their respective toolkits). These interface preferences can change
    over time, but can also become standardized around certain categories of application.
    For example, earlier in their history, Microsoft promoted the Windows **multiple
    document interface **(**MDI**) layout, which remains popular with text editors
    and **integrated development environments** (**IDEs**):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看应用程序可以如何处理多个并发文档。这些界面都旨在同时处理多个文档的方式。无论是文字处理器、图像编辑器还是网页浏览器，都有许多方法可以做到这一点。操作系统通常有一个默认行为，鼓励应用程序开发者使用（有时通过推广最新的变化来提高可用性，有时通过在其各自的工具包中添加或删除
    API）。这些界面偏好可能会随时间变化，但也可以围绕某些应用程序类别标准化。例如，在它们历史的早期，微软推广了 Windows **多文档界面（MDI**）布局，这种布局在文字编辑器和
    **集成开发环境（IDE**）中仍然很受欢迎：
- en: '![](img/3b7f1e9b-d3dd-4d2f-a64b-5c587cda1fa8.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b7f1e9b-d3dd-4d2f-a64b-5c587cda1fa8.png)'
- en: An example application using the Microsoft Windows MDI layout
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Microsoft Windows MDI 布局的示例应用程序
- en: 'Developers of native macOS applications are encouraged to use a new window
    for each document, but to group them under the same application, so the user only
    sees one icon that groups them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励开发原生 macOS 应用程序的开发者为每个文档使用一个新窗口，但将它们分组在同一个应用程序下，这样用户只看到一个将它们分组的图标：
- en: '![](img/918bd31f-1fe4-472e-8944-6e82615106c1.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/918bd31f-1fe4-472e-8944-6e82615106c1.png)'
- en: Multiple documents in macOS load as windows of a single application
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 中多个文档作为单个应用程序的窗口加载
- en: 'The Chrome web browser decided to integrate their tabbed display into the window
    header bar, a space that normally shows just the title of the application or loaded
    document:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 网络浏览器决定将它们的标签显示集成到窗口标题栏中，这个空间通常只显示应用程序或加载文档的标题：
- en: '![](img/b1682aea-e427-4ff7-9a8d-63529b4c85ae.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1682aea-e427-4ff7-9a8d-63529b4c85ae.png)'
- en: This Chrome screenshot shows their distinct look for the tabbed display of loaded
    web pages
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这张 Chrome 截图显示了加载网页标签显示的独特外观
- en: With all these possible approaches, which is right for your application? If
    you have to deal with multiple documents, it's worth looking at applications that
    manage similar file types, or comparing how various applications in the same environment
    handle window management.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些可能的方法中，哪一种适合您的应用程序？如果您必须处理多个文档，查看管理类似文件类型的应用程序或比较同一环境中各种应用程序如何处理窗口管理是值得的。
- en: Accessory windows
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加窗口
- en: There is also a notable variance in the positioning of toolboxes and the grouping
    of features that relate to common areas of functionality. Over the years, there
    have been many iterations such as drawers (which slide out from the window) and
    pop-out dialog windows (still used where context is important but the tools are
    used less often), but the always-visible toolbar or accessory window remains the
    most popular.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 工具箱的位置和与常见功能区域相关的功能的分组也存在显著的差异。多年来，出现了许多迭代，如抽屉（从窗口滑出）和弹出对话框窗口（在上下文很重要但工具使用较少的地方仍然使用），但始终可见的工具栏或附加窗口仍然是最受欢迎的。
- en: 'For example, applications designed for Linux and Unix desktops are typically
    presented using separate windows for each of the supporting tool panels:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为 Linux 和 Unix 桌面设计的应用程序通常使用单独的窗口为每个支持的工具面板呈现：
- en: '![](img/9df9898a-af3d-4107-ac4e-5b6bc3f0da2d.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9df9898a-af3d-4107-ac4e-5b6bc3f0da2d.png)'
- en: Multiple windows were commonly used in Gimp, the popular open source image manipulation
    program
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gimp这个流行的开源图像处理程序中，通常使用多个窗口
- en: 'Compare this with Windows software, which commonly uses a combined layout where
    controls are positioned around the borders of the document window:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常在文档窗口的边缘定位控件的综合布局的Windows软件相比：
- en: '![](img/cbd4f924-4b3f-4cdd-8e9a-6b8b35996c24.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbd4f924-4b3f-4cdd-8e9a-6b8b35996c24.png)'
- en: In Microsoft Paint, however, the tools are grouped at the top of the document.
    Used with permission from Microsoft.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Microsoft Paint中，工具被分组在文档的顶部。本图使用已获得Microsoft的许可。
- en: Both of these approaches, within a single platform, provide a consistent user
    experience, but for a graphical application that targets multiple operating systems,
    it is important to consider which approach suits best. Does your software particularly
    suit one approach or the other? Maybe it will be easier for people to use your
    application if its graphical design adapts the layout to match the conventions
    of the platform it is running on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在单一平台上都提供了一致的用户体验，但对于针对多个操作系统的图形应用来说，考虑哪种方法最适合是很重要的。你的软件特别适合哪种方法？也许如果它的图形设计适应了运行平台的规范，人们使用你的应用会更容易。
- en: Visual hierarchy
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉层次结构
- en: The evolution of web-based applications followed a different path. Historically,
    this medium has been used for presenting large amounts of textual information
    and academic documents. This was usually formatted as hyperlinked content and
    often included a list of popular links in a navigation area that would help people
    to find important content. While it was common for each site to have a very individual
    look (distinct colors and typesetting have had their trends along the way), this
    grouping of content was largely consistent across the internet. It was a big shift
    from the desktop software at that time, but once a user had learned the way to
    interact with one website, they could relatively easily find their way around
    most of them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络的应用的演变遵循了不同的路径。从历史上看，这种媒介一直被用来展示大量的文本信息和学术文档。这通常以超链接内容的形式呈现，并且通常包括一个在导航区域中的流行链接列表，这有助于人们找到重要内容。虽然每个网站都有非常个性化的外观（颜色和排版趋势一路走来都有所变化），但这种内容分组在互联网上大体上一致。这相对于当时的桌面软件来说是一个巨大的转变，但一旦用户学会了与一个网站交互的方式，他们就可以相对容易地找到大多数网站的方法。
- en: 'In terms of applications that were delivered through a website, this had a
    large benefit: the standardized layout or visual hierarchy meant that a new, distinct
    design would still be usable by most internet-savvy computer users. This was in
    addition to the fact that they would look the same on any operating system or
    web browser. This consistency for the user made it easier for designers to apply
    rich visuals or branding to a web application without reducing the user experience.
    As the evolving **Cascading Style Sheets **(**CSS**) open standard gained popularity,
    it became easier to share subsets of these designs and to separate the layout
    details from the visual styling and brand. As a result, there emerged common code
    for structuring websites and applications, similar to the desktop toolkits that
    developers were familiar with. But combined with consistency across any internet-connected
    computer, this standard approach started to make desktop applications seem confusing
    to learn in comparison:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过网站提供的应用方面，这有一个很大的好处：标准化的布局或视觉层次结构意味着新的、独特的设计仍然可以被大多数互联网用户使用。此外，它们在任何操作系统或网络浏览器上看起来都一样。这种对用户的一致性使得设计师更容易将丰富的视觉或品牌应用到网络应用中，而不会降低用户体验。随着不断发展的**层叠样式表（CSS**）开放标准的普及，共享这些设计子集以及将布局细节与视觉样式和品牌分离变得更加容易。因此，出现了用于构建网站和应用的通用代码，类似于开发者熟悉的桌面工具包。但结合任何互联网连接计算机的一致性，这种标准方法开始使桌面应用的学习显得更加复杂：
- en: '![](img/17d3741d-4110-4a16-8556-d84759db6f47.png)![](img/9faa5dd2-6de6-4627-a012-904c247dd2ad.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17d3741d-4110-4a16-8556-d84759db6f47.png)![图片](img/9faa5dd2-6de6-4627-a012-904c247dd2ad.png)'
- en: Standard web page layouts—on the top, the navigation is a side bar,
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 标准网页布局——在顶部，导航是一个侧边栏，
- en: and in the next image, it is a shorter inline area
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图片中，它是一个较短的行内区域
- en: Mobile standards
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动标准
- en: 'Mobile applications pose a different design challenge: how to make a great
    user experience on a far smaller screen when the main input device is a touch
    screen where your fingers may obscure content. The companies behind the major
    mobile operating systems (Apple, Google, and Microsoft) spent many years developing
    a visual language and standard interactions that provided a smooth flow through
    increasingly complicated applications. As previously with web applications, it
    was important that native mobile applications behave in a consistent manner for
    users to quickly learn and feel comfortable with these new platforms. iOS, Android,
    and Windows Phone provide standard APIs that developers can use to create applications
    that fit with the platform standards. Within each platform, there are enough customization
    options to support brand identity through use of color, icons, or the content
    of each screen within the app. While the specific design aesthetic of mobile platforms
    has changed over the years, it is clear that the carefully designed layout and
    workflow aspects remain consistent throughout. Users can comfortably pick up the
    latest iPhone, appreciate its new design, and still be completely familiar with
    how the applications will work:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序提出了不同的设计挑战：如何在主要输入设备是触摸屏且手指可能会遮挡内容的情况下，在远小的屏幕上提供出色的用户体验。主要移动操作系统背后的公司（苹果、谷歌和微软）花费了许多年开发了一种视觉语言和标准交互，这些语言和交互为用户在日益复杂的应用程序中提供了流畅的流程。正如之前在Web应用程序中一样，对于用户快速学习和适应这些新平台来说，原生移动应用程序保持一致的行为方式非常重要。iOS、Android和Windows
    Phone提供了标准API，开发者可以使用这些API创建符合平台标准的应用程序。在每一个平台上，都有足够的定制选项来支持品牌识别，例如使用颜色、图标或应用中每个屏幕的内容。尽管移动平台的具体设计美学在过去几年中发生了变化，但精心设计的布局和工作流程方面始终保持一致。用户可以轻松地拿起最新的iPhone，欣赏其新的设计，并且仍然完全熟悉应用程序的工作方式：
- en: '![](img/5988052c-ecfe-4cf6-abd4-55682a7e3c7f.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5988052c-ecfe-4cf6-abd4-55682a7e3c7f.png)'
- en: A standard iOS layout:navigation at the top and actions at the bottom
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的iOS布局：顶部导航和底部操作
- en: '![](img/303715e9-14f2-49e1-9bf1-c8dee55aa647.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/303715e9-14f2-49e1-9bf1-c8dee55aa647.png)'
- en: A similar iOS layout 4 years earlier
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 4年前的类似iOS布局
- en: There is clearly a lot more to designing an application GUI than designing a
    workflow and picking a color scheme. Will your application take inspiration from
    modern application UX, or is it aimed at users who are more familiar with the
    classic look of desktop applications established over many years? Will you be
    sticking to a single platform and its standard look and feel, or are you interested
    in launching your software across multiple operating systems? Before we look at
    the different toolkits available, take some time to consider these options and
    identify which is likely the right strategy for your application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序GUI远不止设计工作流程和选择配色方案那么简单。你的应用程序是否会从现代应用程序UX中汲取灵感，还是针对那些更熟悉多年以来建立的桌面应用程序经典外观的用户？你将坚持使用单一平台及其标准的外观和感觉，还是对在多个操作系统上发布你的软件感兴趣？在我们查看不同的工具包之前，花些时间考虑这些选项，并确定哪种策略可能最适合你的应用程序。
- en: Concurrency and multi-threading
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和多线程
- en: A GUI must remain responsive to user input at all times. While this is largely
    an aesthetic consideration, it is also possible that the operating system may
    monitor applications and force unresponsive user interfaces to quit. Effective
    event handling is what makes this possible, and this is the core paradigm for
    a GUI. The event handler is responsible for responding to user events (such as
    mouse click, finger tap, and keyboard entry), system events (such as file changes,
    network availability, and application state), and also for updating the user interface
    (such as rendering content, changing interface state, and more). Anything that
    stops this work from occurring could cause the application to stop responding.
    In most graphical toolkits, there is a single thread (a task that manages a set
    of concurrent operations) that is responsible for the event handling and graphical
    updates. In some systems, this is the main thread (where an application launches
    from), and in others it is a separate thread or process. It is important to know
    the semantics of the system you are using, as it is commonly required that only
    the graphical or event handling thread can make changes to the user interface.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: GUI必须始终响应用户输入。虽然这主要是美学考虑，但操作系统也可能监控应用程序并强制无响应的用户界面退出。有效的事件处理使得这一点成为可能，这也是GUI的核心范式。事件处理器负责响应用户事件（如鼠标点击、手指轻触和键盘输入）、系统事件（如文件更改、网络可用性和应用程序状态），以及更新用户界面（如渲染内容、更改界面状态等）。任何阻止这项工作进行的因素都可能导致应用程序停止响应。在大多数图形工具包中，有一个负责事件处理和图形更新的单个线程（一个管理一组并发操作的任务）。在某些系统中，这是主线程（应用程序从中启动的地方），而在其他系统中，它是一个单独的线程或进程。了解您所使用的系统的语义很重要，因为通常只有图形或事件处理线程可以更改用户界面。
- en: Switching threads
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程切换
- en: The ways that different toolkits and languages handle multithreading and graphical
    updates vary substantially. The following illustrations aim to highlight the complexity
    of this problem, in case you are not familiar with these constraints. The specifics
    sometimes vary based on language or version, but the concepts are usually consistent,
    otherwise software developed using the APIs would be very difficult to manage.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的工具包和语言处理多线程和图形更新的方式差异很大。以下插图旨在强调此问题的复杂性，以防您不熟悉这些约束。具体细节有时会根据语言或版本而有所不同，但概念通常是统一的，否则使用API开发的软件将很难管理。
- en: 'For our first example, consider an application written in Java. Its convention
    is that the graphics and user interaction are handled by a single event dispatch
    thread. Therefore, any change you wish to make to the user interface needs to
    be pushed to this thread using `SwingUtilities.invokeLater()`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个示例，考虑一个用Java编写的应用程序。它的惯例是图形和用户交互由单个事件调度线程处理。因此，您希望对用户界面进行的任何更改都需要使用`SwingUtilities.invokeLater()`推送到此线程：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The approach for working with Apple''s operating systems is slightly different.
    Applications built with AppKit or UIKit (which are used for desktop and mobile
    applications respectively) start the user interface event handling on the main
    thread. This means that after the interface is configured, all processing must
    be handled on a background thread and changes to the user interface must be executed
    on the main thread. The objective-C block construct (for encapsulating a single
    behavior) makes this a little easier, but the code is still non-trivial:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与苹果操作系统的交互方法略有不同。使用AppKit或UIKit（分别用于桌面和移动应用程序）构建的应用程序在主线程上启动用户界面事件处理。这意味着在界面配置完成后，所有处理都必须在后台线程上处理，并且对用户界面的更改必须在主线程上执行。Objective-C的块结构（用于封装单个行为）使这变得稍微容易一些，但代码仍然相当复杂：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Applications using GTK (which supports building apps for various different
    platforms) have a similar restriction. For those, the graphical updates must be
    processed on whichever thread you invoked `gtk_init()` and `gtk_main()`. For such
    applications, the thread handling provided by `GLib` will help to manage multithreading
    in your application, but you have to set this up in the interface initialization
    code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GTK（支持为各种不同平台构建应用程序）的应用程序也有类似的限制。对于这些应用程序，图形更新必须在调用`gtk_init()`和`gtk_main()`的线程上处理。对于这类应用程序，`GLib`提供的线程处理可以帮助管理应用程序中的多线程，但您必须在界面初始化代码中设置此配置：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, you can use the gdk thread helpers to manage background updates as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用gdk线程助手来管理后台更新，如下所示：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Avoiding complexity
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免复杂性
- en: 'Graphical toolkits do a lot to help application developers avoid the complications
    of concurrency where possible. For example, a button''s click handler will typically
    run on the thread that controls graphical updates; this means that simple cases
    of user feedback or displaying data as a result of a user action can be done without
    worrying about multi-threading complexity. A simple callback function for an Android
    application may be as simple as the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图形工具包在尽可能避免并发复杂性方面做了很多工作。例如，按钮的点击处理程序通常在控制图形更新的线程上运行；这意味着简单的用户反馈或显示用户操作的结果可以完成，而无需担心多线程复杂性。一个Android应用程序的简单回调函数可能如下所示：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, even a modest application is unlikely to avoid these complications
    for long. Consider a simple RSS newsfeed application; all it does is set up a
    GUI, load the contents of a newsfeed from a set URL, and display the results in
    a list in the user interface. To remain responsive, the graphical interface must
    be presented when the application loads, before requesting the contents of the
    news feed. As the feed downloads, it can be parsed and the items displayed. However,
    because this is executing as a background process, it is not allowed to simply
    make changes to the interface, such as adding list items. Instead, it must identify
    the items to be added and pass this information back to the main (or event dispatch)
    thread to show the updates to the user. Such code can be difficult to read and
    will often lead to debugging complexity, as concurrent software may not always
    behave in the same way. In the next chapter, we will look at how Go's design for
    handling concurrency can simplify this for us.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使是简单的应用程序也不太可能长期避免这些复杂性。考虑一个简单的RSS新闻源应用程序；它所做的只是设置一个GUI，从指定的URL加载新闻源的内容，并在用户界面中以列表的形式显示结果。为了保持响应性，图形界面必须在应用程序加载时呈现，在请求新闻源内容之前。随着内容的下载，它可以被解析并显示项目。然而，因为这是一个后台进程，它不允许简单地更改界面，例如添加列表项。相反，它必须识别要添加的项目，并将此信息传递回主线程（或事件调度线程）以向用户显示更新。这样的代码可能难以阅读，并且通常会引发调试复杂性，因为并发软件可能不会始终以相同的方式表现。在下一章中，我们将探讨Go处理并发的设计如何简化这一过程。
- en: Web services and cloud integration
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务和云集成
- en: Web services and online functionality is a core part of most applications today.
    Whether you are working with data downloaded from a central source, collaborating
    on documents stored online, or just looking to share your creation, this will
    probably be done via the internet. The core of most graphical toolkits and APIs
    are focused solely on the widgets—the presentation of the interface to the user.
    While this is due to various different reasons (and is evolving and expanding
    over time), it mostly reflects the period when they were created. Programming
    languages such as C and C++ underpin many of the native graphical toolkits (especially
    those targeting multiple platforms), and they pre-date cloud services and web-based
    APIs as we know them today. Powerful web services and standardized protocols for
    communications vastly improve the speed of development for web-based applications.
    Conversely, they can make it harder for native graphical applications on the desktop
    where support is lacking from the core language or standard libraries.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务和在线功能是当今大多数应用程序的核心部分。无论您是在处理从中央源下载的数据，在线协作存储的文档，还是仅仅想要分享您的创作，这很可能会通过互联网来完成。大多数图形工具包和API的核心都集中在小部件上——即用户界面的展示。尽管这有多种不同的原因（并且随着时间的推移而演变和扩展），但它主要反映了它们被创建的时期。例如，C和C++等编程语言是许多本地图形工具包的基础（尤其是那些针对多个平台的工具包），并且它们早于我们今天所知道的云服务和基于Web的API。强大的网络服务和标准化的通信协议大大提高了基于Web应用程序的开发速度。相反，它们可能会使桌面上的本地图形应用程序更难，因为这些应用程序的核心语言或标准库缺乏支持。
- en: Communications
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信
- en: Assuming that your chosen language either has good support for connecting to
    HTTP web services, or that a suitable library has been identified, then making
    a data transfer from your required service is not going to be a problem. However,
    what happens if the connection fails? While native GUI applications typically
    sit on a desktop or laptop computer where permanent network connections are common,
    it is not wise to rely on this. With increased remote working, coffee shop meetings,
    and higher levels of mobility (enabled by Wi-Fi and cellular networks), any modern
    application needs to handle unexpected network conditions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你选择的语言要么对连接到HTTP网络服务有良好的支持，要么已经确定了一个合适的库，那么从你的所需服务进行数据传输不会成为问题。然而，如果连接失败会怎样呢？虽然原生GUI应用程序通常位于桌面或笔记本电脑上，那里永久性网络连接很常见，但依赖这一点并不明智。随着远程工作的增加、咖啡店会议以及由Wi-Fi和蜂窝网络带来的更高流动性，任何现代应用程序都需要处理意外的网络条件。
- en: When developing a web-based application, it may not be necessary to be as diligent
    as the user is probably already online. It's also possible that a failure of the
    internet connection could represent a fatal situation for the software, so in
    some situations an error displayed to the user asking them to try again later
    may be acceptable. However, user expectations of native graphical applications
    are far higher than this. Smart phones and the software they come with are expected
    to gracefully handle such failure conditions caused by frequent changes in network
    condition or availability. So, what can we do to match this higher expectation
    in these situations? This probably takes some planning; the error message of *Try
    again later* must be a last resort.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发基于Web的应用程序时，可能不需要像用户可能已经在线那样勤奋。也可能互联网连接的失败对软件来说可能是一个致命的情况，所以在某些情况下，向用户显示的错误信息要求他们稍后再试可能是可以接受的。然而，用户对原生图形应用程序的期望要远高于此。智能手机及其所带的软件预计能够优雅地处理由网络条件或可用性的频繁变化引起的此类故障条件。那么，在这种情况下，我们能够做些什么来满足这种更高的期望呢？这可能需要一些规划；*稍后再试*的错误信息必须是最后的手段。
- en: How much of your application actually requires an internet connection all the
    time (or at a specific point in the workflow)? Are there elements that can be
    accessed occasionally and stored locally (cached)? And is it OK for outgoing communications
    to happen at a later time, rather than immediately on user action? It's helpful
    to be creative when thinking about a network connection and when it's really needed.
    Not too long ago, a chat client (such as IRC, ICQ, MSN, and others) would need
    to be online all the time, and if the connection stopped responding, you'd have
    to wait until it reconnected. More recently, expectations have shifted and new
    chat services (such as Slack and Skype) will allow you to type into chats or channels
    even when offline, and messages will be delivered as soon as they can.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序中有多少部分实际上需要一直（或在工作流程的特定点）保持互联网连接？（或者，是否有部分元素可以偶尔访问并本地存储（缓存）？）以及，是否可以接受出站通信在稍后而不是用户操作立即发生？在考虑网络连接及其真正需要的时候，富有创意是有帮助的。不久前，一个聊天客户端（如IRC、ICQ、MSN等）需要一直在线，如果连接停止响应，你就必须等待它重新连接。最近，期望已经发生了变化，新的聊天服务（如Slack和Skype）允许你在离线时也能输入聊天或频道，消息会尽快送达。
- en: One additional challenge in a web-based connected world is authentication. Old
    password- and application secret-based authentication worked easily within most
    programming languages, but they had security issues. The most recent standard
    to be adopted is OAuth2, which aims to ensure that the user knows what they are
    allowing when applications connect to a secured service. The workflow is designed
    to work well in a web browser, but from within a native application, will it be
    a reasonable user experience to switch to a web browser when asking for permission?
    Will you improve the flow slightly by embedding a web view within your application?
    Unfortunately, it's been noted that this is also open to potential security attacks,
    and there is now a document focusing on the best practices for OAuth2 integration
    into native applications (IETF RFC 8252). Adapting applications to implement these
    recommendations will become a requirement over time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Web的互联世界中，一个额外的挑战是身份验证。基于旧密码和应用密钥的身份验证在大多数编程语言中工作得很好，但它们存在安全问题。最近采用的标准是OAuth2，旨在确保用户知道当应用程序连接到受保护的服务时他们允许了什么。工作流程设计得很好，可以在Web浏览器中工作，但从一个原生应用程序内部，当请求权限时切换到Web浏览器是否是一个合理的用户体验？你通过在应用程序中嵌入Web视图来稍微改善流程吗？不幸的是，已经有人指出这也可能受到潜在的安全攻击，现在有一个文档专注于OAuth2集成到原生应用程序的最佳实践（IETF
    RFC 8252）。随着时间的推移，适应应用程序以实施这些建议将成为一项要求。
- en: Data parsing
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据解析
- en: Having established a connection to a remote server (or loaded the data from
    a local cache), the next challenge is likely to be parsing the response. Complicated
    string processing (which is what most HTTP-based APIs require due to their human
    readable design) is not a strength of many older programming languages that are
    common for native application development. Numerous libraries have been developed
    that will help with this task and are often shared freely (using an open source
    software license), but if the programming language does not have great string
    handling, it may still be a non-trivial task.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 建立与远程服务器（或从本地缓存加载数据）的连接后，接下来的挑战很可能是解析响应。复杂的字符串处理（由于它们的人读性设计，大多数基于HTTP的API都需要这种处理）并不是许多用于原生应用程序开发的较老编程语言的强项。已经开发了许多库来帮助完成这项任务，并且通常可以免费共享（使用开源软件许可），但如果编程语言没有很好的字符串处理能力，这仍然可能是一个非平凡的挑战。
- en: '**Extensible Markup Language** (**XML**) and **JavaScript Object Notation** (**JSON**)
    are the main formats for transferring data over the internet, both reinforced
    by the great support they have in all languages aimed at web development (it should
    be no surprise that JSON usage is trivial in JavaScript applications). As the
    name implies, they are designed to transmit object-oriented, or structured, data,
    and there should be sufficient metadata within the content to allow objects to
    be recreated in the client software without complex un-marshaling code.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**（**XML**）和**JavaScript对象表示法**（**JSON**）是互联网上传输数据的主要格式，它们在所有针对Web开发的语言中都得到了很好的支持（在JavaScript应用程序中JSON的使用是微不足道的，这应该不会让人感到惊讶）。正如其名称所暗示的，它们被设计用来传输面向对象或结构化数据，内容中应该包含足够的元数据，以便在客户端软件中无需复杂的反序列化代码即可重新创建对象。'
- en: Standard components
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准组件
- en: One huge advance in cloud service integration with web development is the addition
    of **Asynchronous JavaScript and XML **(**AJAX**) functionality. Due to the ubiquitous
    support for JavaScript, XML, and HTML in all modern browsers, a web developer
    can configure parts of their user interface to refresh as a result of a web service
    request. Such an update does not require data parsing or merging information;
    the data from the server can literally be the replacement state for the user interface
    (in HTML or JavaScript format normally), and this directly replaces the old content.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务与Web开发集成的一个巨大进步是添加了**异步JavaScript和XML**（**AJAX**）功能。由于JavaScript、XML和HTML在现代浏览器中的普遍支持，Web开发者可以配置用户界面的部分，使其在Web服务请求的结果下刷新。这种更新不需要数据解析或合并信息；服务器上的数据实际上可以替换用户界面（通常是HTML或JavaScript格式）的旧内容。
- en: Unfortunately, most native application toolkits do not have built-in components
    for displaying the results of a web service function call. Over time, however,
    popular services will often release libraries that assist with these features.
    If the company behind a web service does not create a supporting library or component,
    it is often the case that one may have been created independently and shared online.
    Languages that have good support for external modules, or provide a suitable package
    manager, often benefit the most from these sorts of contributions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数本地应用程序工具包没有内置用于显示Web服务功能调用结果的组件。然而，随着时间的推移，流行的服务通常会发布帮助这些功能的库。如果提供Web服务的公司没有创建支持库或组件，通常情况下，可能已经有人独立创建并在线共享。支持外部模块或提供合适的包管理器的语言，通常能从这些类型的贡献中获得最大的好处。
- en: Developing for multiple platforms
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多个平台开发
- en: Beyond the challenges described earlier in this chapter, graphical applications
    face additional complications when targeting multi-platform distributions. Dependency
    and package management are out of scope for this section as they affect system
    and web applications in broadly the same way, although system applications rarely
    have to handle packaged resources (such as images and design elements) and web
    applications are unlikely to publish binary packages. Outlined in this section
    are the main challenges that are unique to, or harder for, GUI-based applications
    planning a cross-platform strategy.  While each of these can be overcome, they
    typically introduce additional development overheads that should be taken into
    consideration when designing your application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章前面描述的挑战之外，图形应用程序在针对多平台发行版时还会面临额外的复杂性。依赖性和包管理不在此节范围内，因为它们以相同的方式影响系统和网络应用程序，尽管系统应用程序很少需要处理打包资源（如图像和设计元素），而网络应用程序不太可能发布二进制包。本节概述了仅针对或对基于GUI的应用程序计划跨平台策略更具挑战性的主要挑战。虽然每个挑战都可以克服，但它们通常会在设计应用程序时引入额外的开发开销，这些开销应该被考虑在内。
- en: Cross-platform APIs
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台API
- en: When designing for multiple platforms the first consideration is probably the
    look and feel (see the *Standard look and feel or app theme* at the beginning
    of this chapter). However, it is also very important to consider whether your
    interface design will be easy to understand for your users (should it match the
    desktop widgets?). For a high-quality graphical application, it's important to
    consider how it will interact with the rest of the user's environment. For example,
    if your workflow included opening a web page outside the current interface, the
    expectation would probably be that it should open in the default web browser,
    which maybe configured by the operating system. Does the toolkit you selected
    handle opening web pages or other types of document specified by a URL? Will you
    instead need to write some code for each platform you wish to support to make
    the right thing happen?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当为多个平台设计时，首先考虑的可能是外观和感觉（参见本章开头的*标准外观和感觉或应用主题*）。然而，考虑你的界面设计是否易于用户理解（是否应该与桌面小部件相匹配）也非常重要。对于高质量的图形应用程序，考虑它与用户环境的交互方式也很重要。例如，如果你的工作流程包括在当前界面之外打开网页，预期可能是在默认的网页浏览器中打开，这可能是操作系统配置的。你选择的工具包是否可以处理打开网页或其他由URL指定的文档类型？你是否需要为每个你希望支持的平台编写一些代码，以确保正确的行为发生？
- en: To learn from the recent developments in mobile applications, we should look
    at the `Share` functionality. On Android, and more recently on iOS, an application
    can initiate a share action, and the platform toolkit will show an appropriate
    visual choice of ways to share that type of content. The user will then make their
    selection, and the application registered to handle that type of share will receive
    the content and request any further information required. How can native application
    developers of cross-platform applications provide similar functionality? If that
    is important to your application, then you could look for a language or toolkit
    that aims to provide this feature, but you may be left to try and implement it
    directly within your own code or to work with an external, web-based service to
    provide a similar experience.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从移动应用程序的最新发展中学习，我们应该看看“分享”功能。在Android上，以及最近在iOS上，一个应用程序可以启动分享操作，平台工具包将显示适当的视觉选择，以分享该类型的内容。然后用户将做出选择，注册处理该类型分享的应用程序将接收内容并请求任何进一步所需的信息。跨平台应用程序的原生开发者如何提供类似的功能？如果这对你的应用程序很重要，那么你可以寻找旨在提供此功能的语言或工具包，但你可能需要直接在你的代码中尝试实现它，或者与外部基于Web的服务合作以提供类似的经验。
- en: Icons and design
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图标和设计
- en: 'Most graphical environments (such as desktop, mobile, and more) have a default
    set of icons—those that are used to show file types, navigation arrows, and standard
    toolbars to help users recognize common actions. If your application is providing
    more than just the simplest of functionality, there will probably be a need to
    add some graphical elements to the design— most likely icons or symbols to help
    your users along. Will your additional icons match those provided by the environment
    the application is running in? If you are supporting just one platform, this is
    probably not an issue, but when you are aiming for a cross-platform solution,
    this could be much harder:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数图形环境（如桌面、移动等）都有一个默认的图标集——那些用于显示文件类型、导航箭头和标准工具栏以帮助用户识别常见操作的图标。如果你的应用程序提供的不仅仅是简单的功能，那么可能需要在设计中添加一些图形元素——很可能是图标或符号来帮助用户。你的附加图标将与应用程序运行的环境提供的图标相匹配吗？如果你只支持一个平台，这可能不是问题，但当你追求跨平台解决方案时，这可能要困难得多：
- en: '![](img/084d241d-ace0-4a37-b774-2ee2d73c22fc.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/084d241d-ace0-4a37-b774-2ee2d73c22fc.png)'
- en: The default style for macOS toolbar icons
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: macOS工具栏图标的默认样式
- en: '![](img/09004296-9f23-4ad5-a8a6-c05f414917ed.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09004296-9f23-4ad5-a8a6-c05f414917ed.png)'
- en: Windows uses a very different style to macOS
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Windows使用的样式与macOS非常不同
- en: 'Think about this challenge when designing your application GUI: do you need
    additional icons or graphical elements?  Doing so may be different to the system
    style, but it may match your user''s expectations.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序GUI时考虑这个挑战：你需要额外的图标或图形元素吗？这样做可能与系统样式不同，但它可能与用户的期望相符。
- en: Testing
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'The only way to ensure a good-quality application is to test it on each platform
    that you aim to support. This is the same for system applications (which could
    aim to work on Linux and Mac, for example) and for web applications (each web
    browser could behave slightly differently). However, the variance in graphical
    desktop environments can be substantial, potentially leading to many different
    versions of your user interface. Additionally, setting up each of these platforms
    probably requires more computers, or some complicated multiple-boot setups. Virtualization
    offers a good solution here: where possible, you could create virtual environments
    to mimic each of the operating system installations you need to test on.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确保应用程序质量良好的唯一方法是在你打算支持的每个平台上对其进行测试。这同样适用于系统应用程序（例如，可能旨在在Linux和Mac上运行）和Web应用程序（每个Web浏览器的行为可能略有不同）。然而，图形桌面环境中的差异可能很大，可能导致用户界面的许多不同版本。此外，设置这些平台中的每一个可能需要更多的计算机，或者一些复杂的多重启动设置。虚拟化在这里提供了一个很好的解决方案：在可能的情况下，你可以创建虚拟环境来模拟你需要测试的每个操作系统安装。
- en: If you are including Linux or similar open source operating systems, remember
    that users are free to choose different desktop environments, each of which have
    a different look and default behavior. For example, if you are supporting Ubuntu
    Linux, you probably need to test the default environment (Unity) but also the
    very common *Gnome* alternative. There are many different desktop environments
    for Linux to consider, including KDE and Xfce, which are also very popular, each
    with a different look and feel and often with different workflows to consider.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你包含 Linux 或类似的开源操作系统，请记住，用户可以自由选择不同的桌面环境，每个环境都有不同的外观和默认行为。例如，如果你支持 Ubuntu
    Linux，你可能需要测试默认环境（Unity），但也需要非常常见的 *Gnome* 替代方案。Linux 有许多不同的桌面环境可以考虑，包括 KDE 和
    Xfce，它们也非常受欢迎，每个都有不同的外观和感觉，通常还有不同的工作流程需要考虑。
- en: Even if you intend to focus support on just Windows and macOS, you will still
    need to consider what versions you will support. The look and feel, and even default
    interactions, can change from one major release to another, so will you aim to
    adapt to these nuances or instead just provide a great experience for the latest
    version of these systems? Be sure to record which operating systems and versions
    (and even desktop configurations if you are going to target Linux) you will support
    and set up a test environment for each of these, if possible. It will help in
    the long run!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你打算只关注 Windows 和 macOS 的支持，你仍然需要考虑你将支持哪些版本。外观和感觉，甚至默认交互，都可能从一个大版本到另一个大版本发生变化，那么你将致力于适应这些细微差别，还是只为这些系统的最新版本提供出色的体验？请务必记录你将支持的操作系统和版本（如果你打算针对
    Linux，甚至包括桌面配置），并在可能的情况下为每个这些设置一个测试环境。这将在长期内有所帮助！
- en: Packaging and distribution
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和分发
- en: Packaging a native graphical application for multiple platforms can introduce
    additional challenges. A native GUI will typically have to adapt to the current
    platform and it will need to include package metadata to integrate as expected
    on a user's desktop. Most graphical apps also require many assets to be embedded
    into the release package. Additionally, the semantics of installing an application
    vary from one operating system to another. macOS, for example, expects that applications
    are packaged as a *bundle* that can be dragged (or moved) from the `Downloads`
    folder into the `Applications` folder. Windows users will expect a single executable
    file that will run once downloaded, or an installer that can set up the components
    required. The platforms you aim to distribute on may impact your application capabilities
    or the resources it can be packaged with, and we want to do this using a single
    code base for ease of maintenance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为多个平台打包本机图形应用程序可能会引入额外的挑战。本机 GUI 通常需要适应当前平台，并且它需要包含包元数据，以便在用户的桌面上按预期集成。大多数图形应用程序还需要将许多资产嵌入到发布包中。此外，安装应用程序的语义在不同的操作系统中各不相同。例如，macOS
    预期应用程序被打包成一个 *包*，可以从 `下载` 文件夹拖动（或移动）到 `应用程序` 文件夹。Windows 用户将期望一个可执行文件，下载后运行一次，或者一个可以设置所需组件的安装程序。你打算分发的平台可能会影响你的应用程序功能或可以打包的资源，我们希望使用单个代码库来简化维护。
- en: In recent years, we have seen many platforms create a*pp stores* or similar,
    where users can browse the applications available for their computer. This provides
    some free marketing and a new channel for downloads, but adds additional overheads
    for the developer. Screenshots and other metadata about your application will
    be required as a minimum, and to stand out, you may even need to create a video
    of your software in action. Stores such as these make installation trivial for
    the user but often place additional constraints on the developer. Be sure to research
    these distribution methods if you intend to use them for your application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，我们看到了许多平台创建了 *应用商店* 或类似的应用，用户可以浏览适用于其计算机的应用程序。这提供了一些免费的市场营销和新的下载渠道，但给开发者增加了额外的负担。你的应用程序的截图和其他元数据至少是必需的，为了脱颖而出，你可能甚至需要创建一个展示软件操作的演示视频。这样的商店对用户来说安装变得非常简单，但通常会对开发者施加额外的限制。如果你打算为你的应用程序使用这些分发方法，请务必进行研究。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed various additional complications that developers
    of native graphical applications are likely to face, especially if looking to
    build for multiple operating systems. Addressing the challenges around graphical
    presentation (visual hierarchy, system look or application design, and custom
    graphical elements) will take some planning and investigation—not just to design
    the ideal application, but also to choose the constraints or overheads that you
    will work with.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了原生图形应用程序开发者可能面临的各种附加复杂性，尤其是如果他们打算为多个操作系统构建应用程序的话。解决图形展示方面的挑战（视觉层次、系统外观或应用程序设计以及自定义图形元素）需要一些规划和调查——不仅是为了设计理想的应用程序，还要选择你将与之工作的约束或开销。
- en: The remaining technical challenges—concurrency, web integration, packaging,
    and distribution—will vary based on the implementation language. As outlined previously,
    many graphical toolkits are created using languages that did not originally provide
    support for these considerations. Some provide low-level support that the developer
    must build upon for their application to meet the expected level of functionality
    for a modern GUI-based application. Thankfully, Go provides elegant solutions
    to many of these challenges. Although the language was not designed with GUIs
    built into the standard library, we will look at why Go is a great match for this
    kind of application in the next chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的技术挑战——并发、Web集成、打包和分发——将根据实现语言的不同而有所差异。如前所述，许多图形工具包是使用最初并未提供对这些考虑因素支持的编程语言创建的。一些提供了低级支持，开发者必须在此基础上构建以使他们的应用程序达到现代基于GUI的应用程序所期望的功能水平。幸运的是，Go语言为许多这些挑战提供了优雅的解决方案。尽管该语言并非专为内置GUI的标准库而设计，但下一章我们将探讨为什么Go语言非常适合这类应用程序。
