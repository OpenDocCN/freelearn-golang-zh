<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Go to the Rescue!</h1>
                </header>
            
            <article>
                
<p>Having read the previous chapter on the challenges of building native graphical applications, you may be wondering whether it's worth all the effort. Hopefully, you are confident that your users will appreciate the quality user experience you are designing, and your team will be keen to see the benefits of taking this route over a web app or other approach. Thankfully, the team at Google that designed the Go programming language understood these challenges and decided that something should be done to aid developers in their quest!</p>
<p>In this chapter, we will take a detailed look at the Go language and see how its design can solve (or help with) the various challenges discussed in <a href="d5375343-5332-4374-9297-dfbb256a5d91.xhtml">Chapter 2</a>, <em>Graphical User Interface Challenges</em>. In particular, we will look at the following topics:</p>
<ul>
<li>A cross-platform approach for any applications</li>
<li>How the concurrency model helps create reliable applications</li>
<li>Built-in support for working with web services</li>
<li>Choosing the look and feel of your GUI and managing the GUI code</li>
</ul>
<p>By the end of this chapter, you will be familiar with how the Go language can support GUI application design, and be ready to start working on real examples using the various frameworks available to Go developers.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><span>Go is a language that (like C, C++, Lisp, and many others) compiles to a native binary on every platform it supports. This is important for graphical applications as it's the best way to create the most responsive and smoothest user interfaces on mainstream computer hardware. </span><span>At the time of writing, the platforms that Go runs on includes Windows, macOS, Linux, Solaris, and other popular Unix-based operating systems (which is essentially all desktop personal computers). </span><span>What stands out about Go compared to other modern languages is that its source code will compile, without any alterations or special adaptation, to native code on every platform that it supports. The language also comprises a large library of APIs that fully support every one of its supported operating systems. This is a huge advantage for developers who want to write an efficient application for multiple operating systems without maintaining slightly different versions for each </span><span>platform. Go is also a <em>typed</em> language, which means that every variable, constant, function parameter, and return type must have a single, defined type. Unlike some older typed languages, Go is often able to infer a type, which helps avoid the duplication of information in the source code. These features help to create a language that's great for development—so let's look at some real code and how this is built and run.</span><span> We'll work with a simple <em>hello world</em> example, which we will write into a file named <kbd>main.go</kbd>:</span></p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    fmt.Println("Hello World!")<br/>}</pre>
<p>This example shows the most basic Go program. The first line indicates the package name (here, <kbd>main</kbd> means that the file describes an executable command). Then, we have the import block where you reference any standard library packages or external code. Finally, there is a <kbd>main()</kbd> method, which is the start of any Go program—and this method simply prints <em>Hello World!</em> to the command line using the <kbd>fmt</kbd> package. This method doesn't mention a return type (which would be placed after <kbd>main()</kbd>)—that means there is no return type, such as <kbd>void</kbd> in C or Java programs. We run this application using the <kbd>go run main.go</kbd> command, as follows:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/dd672840-ca62-45c6-87c0-4647e0db3879.png" style="width:32.00em;height:10.58em;" width="445" height="147"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Running main.go outputs the message before exiting</div>
<p>Alongside each Go file will usually be a test file that runs unit tests against the main code. Let's demonstrate that with another trivial example. Enter the following code into <kbd>main_test.go</kbd>:</p>
<pre>package main<br/><br/>import "testing"<br/><br/>func TestLogic(t *testing.T) {<br/>    if true == false {<br/>        t.Error("It's illogical")<br/>    }<br/>}</pre>
<p>Before we run this code, you should notice two important differences compared to a regular Go file. First, the import list includes <kbd>"testing"</kbd>—this is required for writing any test method. Second, the method name starts with <kbd>Test</kbd> this time, and includes a single parameter of the <kbd>*testing.T</kbd> type. Any method that conforms to those conditions and is in a file that has a name ending in <kbd>_test.go</kbd> will be considered a unit test. Now let's run the tests using the built-in test runner:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/821947c8-7442-4b31-b486-c8d761e7a0b4.png" style="width:35.83em;height:13.00em;" width="521" height="189"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Running Go tests in verbose mode</div>
<p>In this command, the <kbd>-v</kbd> parameter requests verbose output, which is seen as the tests run, and the resulting <kbd>command-line-arguments</kbd> indicates that the tests were run on the files specified in our parameter list, rather than a full package. Alternatively, typing <kbd>go test</kbd> would output less information and would run all the tests in the current package.</p>
<p>In addition to these basic commands, Go comes with many tools that help developers to write and maintain high-quality code. The three that are most commonly used are as follows:</p>
<ul>
<li><kbd>gofmt</kbd>: This ensures that source code is formatted according to the Go specification, and can rewrite your files if requested (by passing <kbd>-w</kbd>).</li>
<li><kbd>godoc</kbd>: This runs a local documentation server to check how your API will look to other developers.</li>
<li><kbd>go vet</kbd>: This examines the code for common programming mistakes that a compiler won't detect.</li>
</ul>
<p><span>You may have noticed that these commands simply run without needing to compile – but how can that be, if Go is a compiled language? That is because the <kbd>run</kbd> command is actually a shortcut to build the application and then run it. This makes running the latest version of an application much quicker than the usual approach of compiling and then running, without losing any of the benefits of being a native binary. In this mode, the built application is discarded when the run finishes. If you want to build and then run many times, you can use the <kbd>build</kbd> command, as shown here:</span></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/de1217c1-790f-43d0-b808-52730d7927e1.png" style="width:38.75em;height:16.92em;" width="527" height="230"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Building a binary to run many times</div>
<p class="mce-root"/>
<p>As you can see, the compiler has created an executable file that has the same name as the file we entered the code into. This file is the native application built from our source code and it can be run like any other application. Note that this is a native application and so it's not portable the way that a Java application is. It will run on the computer we built it on and others like it, but an application built on a Windows computer will not run on macOS directly. The source code is compatible with both platforms, but the binary application is not.</p>
<p>It should be noted at this point that the Go language also provides <em>garbage collection</em>, which contributes to the ease of development. This means that when objects we created are no longer needed, the system will ensure the memory they occupy is freed up. Compared to <kbd>C</kbd> and other (older) compiled languages where this isn't provided, we have less code to write, and a much lower risk of our application leaking memory. Now that we know the language, let's explore the compiler features that support the cross-platform approach and see how to build these examples for different operating systems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-platform for any application</h1>
                </header>
            
            <article>
                
<p>In the introduction, we saw that a file with a name ending in <kbd><span>_test.go</span></kbd> would automatically be run as part of the test phase. Go uses this naming convention for additional compiler features to provide the ability to include code for a specific platform or computer architecture. For example, a file named <kbd>main_windows.go</kbd> will only be included in the compilation if you are building for Microsoft Windows, and the <kbd>main_darwin.go</kbd> file would only be compiled for macOS (darwin is the name of the underlying operating system). Similarly, the computer architecture can be used to conditionally include source code, and so a file named <kbd>main_arm.go</kbd> would only be part of the build for a 32-bit ARM-based processor.</p>
<p>Go also supports the conditional compilation of arbitrary files through the use of build constraints (also known as build tags). These operate at a file level to determine whether a file should be included in the build. To use this functionality, a comment is placed at the top of the file before the package declaration (with an important blank line afterward):</p>
<pre>// +build linux,!386<br/><br/>package myapp</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Basic build tags match the platform and architecture strings used for the file naming described previously, with the addition that they can be combined and negated (using the <kbd>!</kbd> character). Therefore, the preceding example will be included when compiling for Linux on a non-32-bit processor (<kbd>!386</kbd>). This functionality can be further extended by the use of custom tags that can be passed to the compiler. In this way, an application that has advanced features only for a Macintosh could update the file to read the following:</p>
<pre>// +build darwin,coolstuff<br/><br/>package myapp</pre>
<p>This means that, when compiling for a macOS computer, you could invoke the compiler with an extra parameter to enable this <kbd>coolstuff</kbd> functionality as follows: <kbd><span>go build -tags coolstuff main.go</span></kbd>. </p>
<p>This level of conditional compilation means that the code is not cluttered or confusing to read—each file either is, or isn't, included when building. Often, a file that contains conditional code will be paired with another that contains the alternative implementation, such as <kbd>// +build !darwin !coolstuff</kbd> to provide a fallback of the preceding extra functionality (this would be compiled if not on macOS or not passing the <kbd>coolstuff</kbd> tag). For more information about the way that build constraints are calculated, please read the documentation: <a href="https://golang.org/pkg/go/build/">https://golang.org/pkg/go/build/</a>.</p>
<p>One additional compiler feature that is very useful in native app development (but should be used with caution) is the ability to call C code directly from Go, this is known as <strong>Cgo</strong>. The following example illustrates a small Cgo program that, through importing the <kbd>"C"</kbd> package, is able to call C code. It also defines a small inline function that can be helpful in keeping your Go code neat if you have multiple C calls to make in a method:</p>
<pre class="p1"><span class="s1">package main<br/><br/></span><span class="s1">/*<br/></span><span class="s1">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/><br/></span><span class="s1">void print_hello(const char *name) {<br/></span><span class="s1">    printf("Hello %s!\n", name);<br/></span><span class="s1">}<br/></span><span class="s1">*/<br/></span><span class="s1">import "C"<br/>import "unsafe"<br/><br/></span><span class="s1">func main() {<br/>    </span><span class="s1">cName := C.CString("World")<br/>    </span><span class="s1">C.print_hello(cName)<br/>    C.free(unsafe.Pointer(cName))<br/></span><span class="s1">}</span></pre>
<p>When this is run like a normal Go program, this will print out the message exactly as you would expect:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/52e9a341-6c4c-4b3e-8073-ade76081912f.png" style="width:27.83em;height:7.50em;" width="404" height="109"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Running C code from a go file.</div>
<p>As you can see, the inline C method is part of a comment, along with the required imports, which is read by Cgo when placed immediately before <kbd>import "C"</kbd>. Notice also that a Go string cannot be passed directly to C code, but must be converted to a <kbd>CString</kbd> through the <kbd>"C"</kbd> package. It's also possible to call Go functions from the C code that is included in the compilation. A full explanation of Cgo is outside the scope of this book, but more information can be found in the documentation at <a href="https://golang.org/cmd/cgo/">https://golang.org/cmd/cgo/</a>.  While this is very powerful functionality, it can quickly lead to platform-specific code, so it's unwise to use this unless absolutely necessary.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-compiling</h1>
                </header>
            
            <article>
                
<p>The compiler features that we've explored so far have been built only for the current platform. This means that when developing on Linux, the compiler will create (and run, if requested) a native Linux binary (known technically as ELF). If executed on macOS, the result will be a native binary for darwin (a Mach-O executable), and on Windows it would be a native binary for the Windows platform (PE32+). If developers wish to target many different platforms, one option is to have a different computer for each build, but this is expensive and time-consuming. It's far more convenient to create native binary applications for various platforms from the developer's computer—this is called <strong>cross-compiling</strong>.</p>
<p class="mce-root"/>
<p>Cross-compiling with the Go toolchain is simple. All you need to know is the operating system and architecture you wish to compile for. To run a build for a different platform, we simply set the <kbd>GOOS</kbd> and <kbd>GOARCH</kbd> environment variables<span> (for the operating system and architecture, respectively) and invoke <kbd>"go build"</kbd>. In this example, we illustrate the principle by compiling the introductory example for different platforms and check the resulting application using the Unix <kbd>file</kbd> command. As you can see from the first invocation, this illustration is executed from a 64-bit Linux computer and we then build for 32-bit Linux, Windows, and macOS, respectively:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/a0cf57d5-92de-4517-ad13-dfbb53c4f01d.png" style="width:49.92em;height:25.00em;" width="651" height="325"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Building for different platforms on one computer</div>
<p>And so you see how simple it is to build a Go application for any platform. With this knowledge, we can create a graphical application on the developer's preferred platform and cross-compile it for many of the most popular operating systems, without any custom code or build configurations.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Standard library</h1>
                </header>
            
            <article>
                
<p>The standard library of a programming language is the set of APIs and features that are provided by the language runtime. C, for example, has a very small standard library—as a low-level language, the number of features that it supports for every operating system is limited. Java, on the other hand, historically known for being heavy on memory and startup time, provides a massive standard library—including the Swing GUI described in <a href="d5375343-5332-4374-9297-dfbb256a5d91.xhtml">Chapter 2</a>, <em>Graphical User Interface Challenges</em>.</p>
<p>The size of the standard library is usually part of the trade-off when choosing a programming language. For performant native applications that start quickly, the number of built-in APIs is often small. When building with a higher-level language, developers typically expect a lot of supporting features and API packages—and this will usually come with a penalty in startup time or performance. The Go language attempts to provide a full standard library without any of the runtime penalties. This is managed through its cross-platform compilation and static linking, which includes all of the utilized features in the native binary being built. This means that the files are probably larger than programs compiled from C code and they may take longer to compile—but these one-time costs (building and downloading) enable the high performance of Go apps across all platforms.</p>
<p>The standard library included with Go includes powerful features across many areas, including cryptography, image manipulation, text handling (including Unicode), networking, HTML <span>templating,</span> and web service integration. You can read the full documentation at <a href="https://golang.org/pkg/#stdlib">https://golang.org/pkg/#stdlib</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Concurrency in language design</h1>
                </header>
            
            <article>
                
<p>In most mainstream programming languages, concurrency and multithreading can add complexity and make code harder to read. The designers of Go decided that concurrency should be built in from the beginning, making it easy to manage many threads of execution while still avoiding the difficulty of shared memory management. Go does not expose traditional <em>threads</em>, but instead introduces the concept of <strong>goroutines</strong>—these are akin to lightweight threads, but it's possible to have several thousand at the same time. Shared memory is normally the main communication mechanism for concurrent applications, but in Go communication is used to share instead—this built-in feature is called <strong>channels</strong>. In addition to these language features, Go has a <kbd>sync</kbd> package within the standard library that provides tools for further concurrency management.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Goroutines</h1>
                </header>
            
            <article>
                
<p>First, let's examine the most basic Go concurrency feature: the goroutine. Any normal function, when called, will execute the code inside and exit when <kbd>return</kbd> is encountered, or the function exits—at which point it will return control to the function that invoked it. A goroutine is one that starts execution, but immediately returns control to the function calling it—essentially creating a background process for each invocation. Any function can be called as a goroutine simply by prefixing <kbd>go</kbd> to the invocation, as follows:</p>
<pre>package main<br/><br/>import (<br/>    "fmt"<br/>    "time"<br/>)<br/><br/>func tick(message string) {<br/>    for i := 0; i &lt; 5; i++ {<br/>        time.Sleep(10 * time.Millisecond)<br/>        fmt.Println(message)<br/>    }<br/>}<br/><br/>func main() {<br/>    go tick("goroutine")<br/>    tick("function")<br/>}</pre>
<p>This code sample defines a <kbd>tick(string)</kbd> method that will output the requested message every 10 milliseconds. The <kbd>main()</kbd> function calls this code in two different ways: first, it is invoked as a goroutine, and then as a normal function call. If this were invoked as two function calls, one after the other, we would see a lot of copies of <kbd>"goroutine"</kbd> output to the command line, followed by <kbd>"function"</kbd> many times. Instead, however, the goroutine executes concurrently with the following code, and so we see this output instead:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/7fe4dd2d-d312-4743-98e6-514205275843.png" width="489" height="239"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Concurrent output with a goroutine</div>
<p>What you see may be slightly different, as the order appears a little random. What you should see is that each pair of output lines say either <kbd>"goroutine"</kbd> or <kbd>"function"</kbd> with a small time gap between them. The order of each pair will depend on the scheduler, but what you can clearly see is that two invocations of the <kbd>tick</kbd> function were running at the same time (that is, concurrently). Goroutines are not limited to such trivial examples but as they occupy the same address space (like a normal function call), they have access to shared areas of memory. When multiple threads can write to the same area of memory, synchronization is typically required to ensure correct operation. To provide better semantics for communicating in this way, the Go language has a feature named <strong>channels</strong>. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Channels</h1>
                </header>
            
            <article>
                
<p><span>The philosophy for sharing data with Go is</span> <em>Don't communicate by sharing memory; instead, share memory by communicating</em>. Channels are the language construct that support this approach <span>–</span> they allow the sharing of data by communicating between goroutines correctly, rather than sharing common data. This is the main way that Go avoids race conditions (that is, one thread writing data while others read the same data). Channels are used for all sorts of patterns in Go <span>–</span> they can communicate the result of a goroutine (or pass data between routines), <span>provide updates when data changes, or even</span> signal that processes should finish.</p>
<p>Channels, just like all variables and constants in Go, require a type. The type of a channel determines the data that can be communicated through it. The type could be <kbd>bool</kbd> if you want to send information that is just <kbd>true</kbd>/<kbd>false</kbd>, or it could be a custom <kbd>struct</kbd> data type if you wish to communicate more information, such as a data-changed notification. In this example of channels, we are using a simple string channel that is read from a number of times while a goroutine continues to write into it:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func say(words string, to chan string) {<br/>    fmt.Println("Speaking:", words)<br/>    to &lt;- words<br/>}<br/><br/>func talk(to chan string) {<br/>    say("Hello", to)<br/>    say("Everyone", to)<br/>    say("My name is...", to)<br/>    fmt.Println("Never mind")<br/>}<br/><br/>func listen(to chan string) {<br/>    heard := &lt;-to<br/>    fmt.Println("I heard:", heard)}<br/><br/>func main() {<br/>    chat := make(chan string)<br/><br/>    go talk(chat)<br/><br/>    listen(chat)<br/>    listen(chat)<br/>    fmt.Println("Bye")<br/>}</pre>
<p>Running this sample will demonstrate that each time the channel is written to (in <kbd>say</kbd>), it must wait until the channel is read (in <kbd>listen</kbd>) before it can be written to again. You can also see that the <kbd>talk</kbd> goroutine never completed the message because we didn't read all of the data it was waiting to write:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/5adcac5a-6d5c-44e0-999b-652bd7df54d3.png" style="width:35.58em;height:14.67em;" width="451" height="185"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Communicating through a simple channel</div>
<p>By default, writing to a channel will block until some code is ready to read from the other end, and likewise, reading will block until data is written to the channel, at which point the program flow will continue. This behavior can be altered by using a buffered channel <span>–</span> if a channel has a buffer size of 5, it could be written to 5 times before blocking; similarly, reading from that channel would potentially return 5 values before blocking (reading a channel will always block when no data is available). If we updated the preceding example to create a buffered channel of size 3 (by using <kbd>make(chan string, 3)</kbd>), we would see that the full message is written and the <kbd>talk</kbd> method completes:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/a19fbe72-b053-4070-8990-ccd33373d1da.png" style="width:33.17em;height:16.67em;" width="430" height="215"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Adding buffering to the channel</div>
<p>This trivial example indicates how you can safely communicate between goroutines, but let's look at some more practical examples by including some additional features. For example, a configuration struct could be communicated through a channel each time it changes, so that the application can respond accordingly: </p>
<pre>go func() {<br/>    for {<br/>        config := &lt;-configManager<br/>        myWidget.applyConfiguration(config)}<br/>}()</pre>
<p>To be able to manage concurrency and communication between multiple goroutines, the language has an enhancement for the <kbd>select</kbd> keyword, which provides the ability to wait on multiple channels. This means that you don't have to have a goroutine for each blocking channel. The following example illustrates how a background function can work on some complex calculations (in this case, <kbd>square</kbd>) that are fed back to the main function, and also wait on a signal to finish processing:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func square(c, quit chan int) {<br/>    sq := 2<br/>    for {<br/>        select {<br/>        case c &lt;- sq:<br/>            sq*=sq<br/>        case &lt;-quit:<br/>            fmt.Println("quitting")<br/>            return<br/>        }<br/>    }<br/>}<br/><br/>func main() {<br/>    c := make(chan int)<br/>    quit := make(chan int)<br/>    go square(c, quit)<br/><br/>    func() {<br/>        for i := 0; i &lt; 5; i++ {<br/>            fmt.Println("Square", &lt;-c)<br/>        }<br/>        quit &lt;- 1<br/>    }()<br/>}</pre>
<p>Running this example will output the calculations returned until the process is signaled to stop:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/1eae1b51-c38f-4f30-a9b7-3baded6543b8.png" width="442" height="191"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Reading from the calculation channel until quit is signaled</div>
<p>And finally, the channels in Go can be closed by the writer; this means that the function reading from a channel may stop getting new values. To avoid this deadlock situation, a reader of a channel can detect whether the channel has been closed. The syntax to check for the status of a channel is to read an optional second parameter, <kbd>val, ok := &lt;-ch</kbd>, where <kbd>val</kbd> is the value read and <kbd>ok</kbd> indicates that the channel isn't closed. In addition to this, a new <kbd>range</kbd> keyword has been added, which will iterate through the values of a channel until it closes. The following example includes a <kbd>download()</kbd> function that simulates downloading data and updating its percentage to completion. The process reaches a logical conclusion and so the <kbd>main</kbd> function can complete. You can see how this could be used to ensure a progress bar stays up to date while other parts of the program keep running:</p>
<pre>package main<br/><br/>import "fmt"<br/><br/>func download(file string, c chan int) {<br/>    fmt.Println("Downloading", file)<br/><br/>    c &lt;- 10<br/>    c &lt;- 40<br/>    c &lt;- 65<br/>    c &lt;- 100<br/><br/>    close(c)<br/>}<br/><br/>func main() {<br/>    c := make(chan int)<br/>    go download("myfile.jpg", c)<br/><br/>    for i := range c {<br/>        fmt.Printf("Progress %d%%...\n", i)<br/>    }<br/>    fmt.Println("Download complete")<br/>}</pre>
<p>Running this example will show how a simulated download progresses and returns once the process is complete. The simple <kbd>range</kbd> keyword is used to avoid handling the channel-close condition directly:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f6c5fc5d-bf06-4a58-a9d2-0e3679c54daa.png" width="440" height="166"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Iterating on a channel range</div>
<p>Sometimes, you need to go beyond the concurrency primitives and handle special cases. This is what the standard library <kbd>sync</kbd> package provides.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The sync package</h1>
                </header>
            
            <article>
                
<p>The sync package of Go's standard library provides additional synchronization features that aren't included in the language itself. Its additions to concurrency management include Mutex, WaitGroup, and Once, which we'll look at briefly.</p>
<p><kbd>Mutex</kbd> is used when you want to ensure mutual exclusion—that is, if you only want one goroutine to access a piece of data at a time (to avoid potential conflicts). The key methods are <kbd>Lock()</kbd> and <kbd>Unlock()</kbd>, which surround the section of code that should never be executed concurrently. If a second goroutine attempts to enter the section, it will block until the lock is released:</p>
<pre>var vals map[string]string<br/>var lock sync.Mutex<br/><br/>func Get(key string) string {<br/>    lock.Lock()<br/>    defer lock.Unlock()<br/>    return vals[key]<br/>}<br/><br/>func Set(key, value string) {<br/>    lock.Lock()<br/>    vals[key] = value<br/>    lock.Unlock()<br/>}</pre>
<p>In the preceding example, we have a map, <kbd>vals</kbd>, that we want to share and so must ensure thread-safety. We add <kbd>sync.Mutex</kbd> to guard the access and ensure that the lock is obtained before using the map. Note that in the <kbd>Get</kbd> method, we use the <kbd>defer</kbd> keyword to ensure the code is called as the method exits—this avoids needing to access the map, storing the value, and unlocking before then returning (making the code neater).</p>
<p><kbd>WaitGroup</kbd> is helpful if you want to create a number of background activities and then wait until they all complete. For example, this code snippet creates a download method that takes an additional parameter for the group it's part of. Each download instance increments the group counter (<kbd>Add(1)</kbd>) at the start of the download and clears it (<kbd>Done()</kbd>) at the end. The calling function sets up a wait group and then calls <kbd>Wait()</kbd>, which will return once all downloads are complete:</p>
<pre>func Download(url string, group *sync.WaitGroup) {<br/>    group.Add(1)<br/>    http.Get(url)<br/>    group.Done()<br/>}<br/><br/>func main() {<br/>    ...<br/>    var group sync.WaitGroup<br/>    go download("http://example.com/image1.png", group)<br/>    go download("http://example.com/image2.png", group)<br/>    group.Wait()<br/>    fmt.Println("Done")<br/>    ...<br/>}</pre>
<p class="mce-root">The last example, <kbd>Once</kbd>, is rather self-explanatory—it allows code to be executed once only. Invoking its <kbd>Do(func())</kbd> method will cause the passed function to never be called more than once. This is helpful if you're trying to implement a lazy-loading singleton pattern, such as the following code:</p>
<pre>var instance *myStruct<br/>var once sync.Once<br/><br/>func GetInstance() *myStruct {<br/>    once.Do(func() {<br/>        instance = &amp;myStruct{}<br/>    })<br/><br/>    return instance<br/>}</pre>
<p>The full documentation is available at <a href="https://golang.org/pkg/sync/">https://golang.org/pkg/sync/</a>; however, it's recommended to use the <span>channel constructs when possible, instead of</span> most of these features.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Web services included as standard</h1>
                </header>
            
            <article>
                
<p>As a modern programming language, Go comes with extensive support for HTTP clients, servers, and standard encoding handlers, including JSON and XML. Combined with the built-in string and map features, this removes many of the hurdles of working with web services. In addition to this, the format for structs in Go allows for additional <kbd>tags</kbd> that can provide metadata to its fields. Both the <kbd>encoding/json</kbd> and <kbd>encoding/xml</kbd> packages make use of this to understand how to correctly encode and decode instances of these structs. The following example demonstrates these features by connecting to a web service, accessing a JSON response, and decoding it into a struct that is then used like any other:</p>
<pre>package main<br/><br/>import "encoding/json"<br/>import "fmt"<br/>import "io/ioutil"<br/>import "net/http"<br/><br/>type Person struct {<br/>    Title     string `json:"title,omitempty"`<br/>    Firstname string `json:"firstname"`<br/>    Surname   string `json:"surname"`<br/><br/>    Username string `json:"username"`<br/>    Password string `json:"-"`<br/>}<br/><br/>func readFromURL(url string) ([]byte, error) {<br/>    var body []byte<br/>    resp, err := http.Get(url)<br/>    if err != nil {<br/>        return body, err<br/>    }<br/><br/>    defer resp.Body.Close()<br/>    return ioutil.ReadAll(resp.Body)<br/>}<br/><br/>func main() {<br/>    person := &amp;Person{<br/>        "",<br/>        "John",<br/>        "Doe",<br/>        "someuser",<br/>        "somepassword",<br/>    }<br/>    fmt.Println("Struct:", person)<br/><br/>    data, _ := json.MarshalIndent(person, "", "  ")<br/>    fmt.Println("JSON:", string(data))<br/><br/>    fmt.Println("Downloading...")<br/>    data, _ = readFromURL("http://echo.jsontest.com/title/Sir/" +<br/>        "firstname/Anthony/surname/Other/username/anon123/")<br/>    fmt.Println("Download:", string(data))<br/><br/>    person = &amp;Person{}<br/>    json.Unmarshal(data, person)<br/>    fmt.Println("Decoded:", person)<br/>}</pre>
<p>In the preceding example code you can see the usage of struct tags prefixed with <kbd>"json:"</kbd>. These provide hints to the <kbd>"encoding/json"</kbd> package that manages the encoding and decoding of theses objects. We can run this example and see the output of converting a struct into JSON and back again:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/e6562dfc-82fa-4e12-bf6b-74526049f17c.png" style="width:26.42em;height:19.92em;" width="798" height="602"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Encoding and decoding JSON for an HTTP request</div>
<p class="mce-root"><span>Notice that zero value fields marked with <kbd>omitempty</kbd> were not included in the JSON output, and equally the password field that was marked as <kbd>"-"</kbd> (meaning do not include) was ignored when encoding the data. After downloading the data from a test web service, it was marshaled directly into an instance of the <kbd>Person</kbd> struct, leaving missing fields with their zero value. This was all possible using built-in features of the language and standard library. It's very straightforward, thanks to Go's readiness for working with web services.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Choosing your look and feel</h1>
                </header>
            
            <article>
                
<p>As discussed in <a href="d5375343-5332-4374-9297-dfbb256a5d91.xhtml">Chapter 2</a>, <em>Graphical User Interface Challenges</em>, there are many approaches to graphical applications, leaving developers to choose between native versus hybrid (packaged web apps) and designers to pick from system look and feel, a multi-platform widget set, or even a custom design. The choice you make will probably be impacted by the needs of your application and the platforms you aim to target—is performance important and do you aim for a cross-platform deployment? Go doesn't have a standard graphical toolkit, and this omission has led developers to think it's not a language to be used for coding GUI applications. However, as we've seen in this chapter, it's a great fit for graphical application development. This leads to the question: which toolkits are available to build GUI apps in Go?</p>
<p>Simply put: a lot. You can see a list of the major, currently-maintained toolkits online at <a href="https://awesome-go.com/#gui">https://awesome-go.com/#gui</a>—there is probably an option that suits most use cases. As we are looking to build high-performance applications that look great, we'll skip the items that rely on bundling web content to create hybrid applications. That still leaves a large list! There are some that give direct access to system components for a truly native experience, and some that provide abstracted APIs for the same platform look and feel. Others provide their own rendering of the user interface, which is consistent on all platforms they support (similar to Java Swing's <em>Metal</em> look and feel).</p>
<p>As well as a great language for GUI development, Go presents us with the opportunity to choose the right GUI toolkit for our application. <a href="36bfea00-c659-4569-864c-de2c460c7467.xhtml">Section 2</a>, <em>Toolkits Using Existing Widgets</em> (Chapters <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">4</a>, <a href="4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml">5</a>, <a href="6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml">6</a> and <a href="68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml"/><a href="68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml">7</a>), and <a href="ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml">Section 3</a>, <em>Modern Graphical Toolkits</em> (Chapters <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">8</a>, <a href="48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml">9</a> and <a href="2476a1b6-0915-496b-8290-7a673f533aca.xhtml">10</a>),  introduces developers to each of the main options, and shows how to start building beautiful graphical applications with each of them. <a href="36bfea00-c659-4569-864c-de2c460c7467.xhtml">Section <span>2</span></a>, <em>Toolkits Using Existing Widgets</em>,<span> </span>is focused on building applications that match the operating system's look and feel, and <a href="ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml">Section 3</a><span>, </span><em>Modern Graphical Toolkits, </em>is for applications that are going for a more modern look that aims to be consistent across multiple platforms.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at how the Go language is very well-suited to developing graphical applications. Its design for handling concurrency makes the types of multithreading needed by GUIs easy to manage. Channels, the main thread-communication feature, are a little hard to learn, but through some basic examples, we saw how common concurrency issues could easily be avoided. The write-once-compile-anywhere ethos of Go means that developers can easily compile the same code and deliver native apps across most common platforms from a single codebase using the provided tools. As a modern language, it's designed to operate in a connected world and its support for network communications and web services is excellent <span>–</span> we ran examples that illustrated how objects can be easily transformed to and from common web formats.</p>
<p>Having explored the many ways that Go suits graphical application development, we also reflected on the many toolkits available to choose from. Despite not having a standard user interface, there are many possibilities for building great-looking graphical apps with Go. In <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications,</em> <a href="4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml">Chapter 5</a>, <em>andlabs UI - Cross-platform Native UIs,</em> <a href="6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml">Chapter 6</a>, <em>Go-GTK - Multiple Platforms with GTK,</em> <a href="68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml">Chapter 7</a>, <em>Go-Qt - Multiple Platforms with Qt</em> <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a>, <em>Shiny - Experimental Go GUI API</em> <a href="48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml">Chapter 9</a>, <em>nk - Nuklear for Go,</em> and <a href="2476a1b6-0915-496b-8290-7a673f533aca.xhtml">Chapter 10</a>, <em>Fyne - Material Design based GUI,</em> we'll look at the different toolkits available and how to start building your first Go-based GUI. We start by exploring how to build traditional user interfaces, beginning with apps for Microsoft Windows in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications</em>.</p>


            </article>

            
        </section>
    </div>



  </body></html>