- en: Go to the Rescue!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 来拯救！
- en: Having read the previous chapter on the challenges of building native graphical
    applications, you may be wondering whether it's worth all the effort. Hopefully,
    you are confident that your users will appreciate the quality user experience
    you are designing, and your team will be keen to see the benefits of taking this
    route over a web app or other approach. Thankfully, the team at Google that designed
    the Go programming language understood these challenges and decided that something
    should be done to aid developers in their quest!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了关于构建原生图形应用程序挑战的上一章后，你可能想知道这一切是否值得。希望你对用户将欣赏你设计的优质用户体验充满信心，并且你的团队将热衷于看到采用这种方法而不是网页应用程序或其他方法的益处。幸运的是，设计
    Go 编程语言的 Google 团队理解了这些挑战，并决定应该做些什么来帮助开发者们在他们的追求中取得进展！
- en: 'In this chapter, we will take a detailed look at the Go language and see how
    its design can solve (or help with) the various challenges discussed in [Chapter
    2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml), *Graphical User Interface Challenges*.
    In particular, we will look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨 Go 语言，并了解其设计如何解决（或帮助解决）在 [第 2 章](d5375343-5332-4374-9297-dfbb256a5d91.xhtml)
    “图形用户界面挑战” 中讨论的各种挑战。特别是，我们将探讨以下主题：
- en: A cross-platform approach for any applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于任何应用程序的跨平台方法
- en: How the concurrency model helps create reliable applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发模型如何帮助创建可靠的应用程序
- en: Built-in support for working with web services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置支持与网络服务协同工作
- en: Choosing the look and feel of your GUI and managing the GUI code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你的 GUI 的外观和感觉以及管理 GUI 代码
- en: By the end of this chapter, you will be familiar with how the Go language can
    support GUI application design, and be ready to start working on real examples
    using the various frameworks available to Go developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉 Go 语言如何支持 GUI 应用程序设计，并准备好开始使用为 Go 开发者提供的各种框架来编写真实示例。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Go is a language that (like C, C++, Lisp, and many others) compiles to a native
    binary on every platform it supports. This is important for graphical applications
    as it''s the best way to create the most responsive and smoothest user interfaces
    on mainstream computer hardware. At the time of writing, the platforms that Go
    runs on includes Windows, macOS, Linux, Solaris, and other popular Unix-based
    operating systems (which is essentially all desktop personal computers). What
    stands out about Go compared to other modern languages is that its source code
    will compile, without any alterations or special adaptation, to native code on
    every platform that it supports. The language also comprises a large library of
    APIs that fully support every one of its supported operating systems. This is
    a huge advantage for developers who want to write an efficient application for
    multiple operating systems without maintaining slightly different versions for
    each platform. Go is also a *typed* language, which means that every variable,
    constant, function parameter, and return type must have a single, defined type.
    Unlike some older typed languages, Go is often able to infer a type, which helps
    avoid the duplication of information in the source code. These features help to
    create a language that''s great for development—so let''s look at some real code
    and how this is built and run. We''ll work with a simple *hello world* example,
    which we will write into a file named `main.go`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种语言，它（类似于 C、C++、Lisp 以及许多其他语言）在它支持的每一个平台上编译成原生二进制文件。这对于图形应用程序来说非常重要，因为这是在主流计算机硬件上创建最响应和最平滑的用户界面的最佳方式。在撰写本文时，Go
    运行的平台包括 Windows、macOS、Linux、Solaris 以及其他流行的基于 Unix 的操作系统（这实际上涵盖了所有桌面个人电脑）。与其它现代语言相比，Go
    的一个突出特点是它的源代码可以在不进行任何修改或特殊适配的情况下，编译成它支持的每一个平台的原生代码。该语言还包含了一个庞大的 API 库，完全支持它所支持的每一个操作系统。这对于想要为多个操作系统编写高效应用程序的开发者来说是一个巨大的优势，因为他们无需为每个平台维护略有不同的版本。Go
    还是一种 *类型化* 语言，这意味着每个变量、常量、函数参数和返回类型都必须有一个单一、已定义的类型。与一些较老的类型化语言不同，Go 通常能够推断类型，这有助于避免在源代码中重复信息。这些特性有助于创建一个非常适合开发的语言——那么，让我们看看一些真实的代码以及它是如何构建和运行的。我们将使用一个简单的
    *hello world* 示例，我们将将其写入一个名为 `main.go` 的文件：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example shows the most basic Go program. The first line indicates the
    package name (here, `main` means that the file describes an executable command).
    Then, we have the import block where you reference any standard library packages
    or external code. Finally, there is a `main()` method, which is the start of any
    Go program—and this method simply prints *Hello World!* to the command line using
    the `fmt` package. This method doesn''t mention a return type (which would be
    placed after `main()`)—that means there is no return type, such as `void` in C
    or Java programs. We run this application using the `go run main.go` command,
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了最基本的 Go 程序。第一行指示包名（在这里，`main` 表示该文件描述了一个可执行命令）。然后，我们有导入块，其中引用任何标准库包或外部代码。最后，有一个
    `main()` 方法，这是任何 Go 程序的开始——该方法简单地使用 `fmt` 包将 *Hello World!* 打印到命令行。此方法没有提及返回类型（它将放在
    `main()` 之后）——这意味着没有返回类型，例如 C 或 Java 程序中的 `void`。我们使用 `go run main.go` 命令运行此应用程序，如下所示：
- en: '![](img/dd672840-ca62-45c6-87c0-4647e0db3879.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd672840-ca62-45c6-87c0-4647e0db3879.png)'
- en: Running main.go outputs the message before exiting
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 main.go 输出消息然后退出
- en: 'Alongside each Go file will usually be a test file that runs unit tests against
    the main code. Let''s demonstrate that with another trivial example. Enter the
    following code into `main_test.go`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个 Go 文件旁边都会有一个测试文件，它会对主代码执行单元测试。让我们用一个简单的例子来演示。将以下代码输入到 `main_test.go` 中：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before we run this code, you should notice two important differences compared
    to a regular Go file. First, the import list includes `"testing"`—this is required
    for writing any test method. Second, the method name starts with `Test` this time,
    and includes a single parameter of the `*testing.T` type. Any method that conforms
    to those conditions and is in a file that has a name ending in `_test.go` will
    be considered a unit test. Now let''s run the tests using the built-in test runner:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行此代码之前，你应该注意到与常规 Go 文件相比有两个重要差异。首先，导入列表包括 `"testing"`——这是编写任何测试方法所必需的。其次，这次方法名以
    `Test` 开头，并包含一个 `*testing.T` 类型的单个参数。任何符合这些条件且在以 `_test.go` 结尾的文件中的方法都将被视为单元测试。现在让我们使用内置的测试运行器来运行测试：
- en: '![](img/821947c8-7442-4b31-b486-c8d761e7a0b4.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/821947c8-7442-4b31-b486-c8d761e7a0b4.png)'
- en: Running Go tests in verbose mode
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以详细模式运行 Go 测试
- en: In this command, the `-v` parameter requests verbose output, which is seen as
    the tests run, and the resulting `command-line-arguments` indicates that the tests
    were run on the files specified in our parameter list, rather than a full package.
    Alternatively, typing `go test` would output less information and would run all
    the tests in the current package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`-v` 参数请求详细输出，显示正在运行的测试，以及结果中的 `command-line-arguments` 指示测试是在我们参数列表中指定的文件上运行的，而不是整个包。或者，键入
    `go test` 将输出更少的信息，并运行当前包中的所有测试。
- en: 'In addition to these basic commands, Go comes with many tools that help developers
    to write and maintain high-quality code. The three that are most commonly used
    are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本命令之外，Go 还附带了许多工具，可以帮助开发者编写和维护高质量的代码。以下是最常用的三个：
- en: '`gofmt`: This ensures that source code is formatted according to the Go specification, and
    can rewrite your files if requested (by passing `-w`).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gofmt`：这确保源代码按照 Go 规范格式化，如果请求（通过传递 `-w`）还可以重写你的文件。'
- en: '`godoc`: This runs a local documentation server to check how your API will
    look to other developers.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`godoc`：这运行一个本地文档服务器来检查你的 API 将如何显示给其他开发者。'
- en: '`go vet`: This examines the code for common programming mistakes that a compiler
    won''t detect.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go vet`：这检查代码中编译器无法检测到的常见编程错误。'
- en: 'You may have noticed that these commands simply run without needing to compile
    – but how can that be, if Go is a compiled language? That is because the `run` command
    is actually a shortcut to build the application and then run it. This makes running
    the latest version of an application much quicker than the usual approach of compiling
    and then running, without losing any of the benefits of being a native binary.
    In this mode, the built application is discarded when the run finishes. If you
    want to build and then run many times, you can use the `build` command, as shown
    here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这些命令只是简单地运行，不需要编译——但如果 Go 是一种编译型语言，这是如何实现的呢？这是因为 `run` 命令实际上是一个构建应用程序然后运行的快捷方式。这使得运行应用程序的最新版本比通常的编译然后运行的方法要快得多，而且不会失去作为本地二进制文件的所有优势。在这种情况下，构建的应用程序在运行完成后将被丢弃。如果你想多次构建和运行，可以使用
    `build` 命令，如下所示：
- en: '![](img/de1217c1-790f-43d0-b808-52730d7927e1.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de1217c1-790f-43d0-b808-52730d7927e1.png)'
- en: Building a binary to run many times
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 构建可多次运行的二进制文件
- en: As you can see, the compiler has created an executable file that has the same
    name as the file we entered the code into. This file is the native application
    built from our source code and it can be run like any other application. Note
    that this is a native application and so it's not portable the way that a Java
    application is. It will run on the computer we built it on and others like it,
    but an application built on a Windows computer will not run on macOS directly.
    The source code is compatible with both platforms, but the binary application
    is not.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编译器已创建了一个与我们所输入代码的文件名相同的可执行文件。这个文件是由我们的源代码构建的本地应用程序，它可以像任何其他应用程序一样运行。请注意，这是一个本地应用程序，因此它不像Java应用程序那样可移植。它将在我们构建它的计算机上以及其他类似计算机上运行，但基于Windows计算机构建的应用程序不能直接在macOS上运行。源代码与这两个平台兼容，但二进制应用程序则不兼容。
- en: It should be noted at this point that the Go language also provides *garbage
    collection*, which contributes to the ease of development. This means that when
    objects we created are no longer needed, the system will ensure the memory they
    occupy is freed up. Compared to `C` and other (older) compiled languages where
    this isn't provided, we have less code to write, and a much lower risk of our
    application leaking memory. Now that we know the language, let's explore the compiler
    features that support the cross-platform approach and see how to build these examples
    for different operating systems.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出的是，Go语言还提供了*垃圾回收*功能，这有助于开发过程的简化。这意味着当我们创建的对象不再需要时，系统将确保它们占用的内存被释放。与不提供这种功能的`C`和其他（较老）编译语言相比，我们编写的代码更少，并且我们的应用程序泄漏内存的风险要低得多。现在我们了解了这种语言，让我们来探索支持跨平台方法的编译器功能，并看看如何为不同的操作系统构建这些示例。
- en: Cross-platform for any application
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于任何应用程序的跨平台
- en: In the introduction, we saw that a file with a name ending in `_test.go` would
    automatically be run as part of the test phase. Go uses this naming convention
    for additional compiler features to provide the ability to include code for a
    specific platform or computer architecture. For example, a file named `main_windows.go`
    will only be included in the compilation if you are building for Microsoft Windows,
    and the `main_darwin.go` file would only be compiled for macOS (darwin is the
    name of the underlying operating system). Similarly, the computer architecture
    can be used to conditionally include source code, and so a file named `main_arm.go` would
    only be part of the build for a 32-bit ARM-based processor.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我们了解到以`_test.go`结尾的文件将自动作为测试阶段的一部分运行。Go使用这种命名约定为编译器提供额外的功能，以提供为特定平台或计算机架构包含代码的能力。例如，名为`main_windows.go`的文件只有在构建Microsoft
    Windows时才会被包含在编译中，而`main_darwin.go`文件将仅针对macOS（darwin是底层操作系统的名称）进行编译。同样，计算机架构也可以用来条件性地包含源代码，因此名为`main_arm.go`的文件将仅作为32位ARM架构处理器的构建的一部分。
- en: 'Go also supports the conditional compilation of arbitrary files through the
    use of build constraints (also known as build tags). These operate at a file level
    to determine whether a file should be included in the build. To use this functionality,
    a comment is placed at the top of the file before the package declaration (with
    an important blank line afterward):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Go还支持通过使用构建约束（也称为构建标记）对任意文件进行条件编译。这些操作在文件级别上确定一个文件是否应该包含在构建中。要使用此功能，需要在文件顶部的包声明之前放置一个注释（之后有一个重要的空白行）：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Basic build tags match the platform and architecture strings used for the file
    naming described previously, with the addition that they can be combined and negated
    (using the `!` character). Therefore, the preceding example will be included when
    compiling for Linux on a non-32-bit processor (`!386`). This functionality can
    be further extended by the use of custom tags that can be passed to the compiler.
    In this way, an application that has advanced features only for a Macintosh could
    update the file to read the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基本构建标记与之前描述的用于文件命名的平台和架构字符串相匹配，并且它们可以组合和否定（使用`!`字符）。因此，当编译针对非32位处理器的Linux系统时（`!386`），前面的示例将被包含在内。通过向编译器传递自定义标记，该功能可以进一步扩展。这样，一个仅针对Macintosh提供高级功能的程序可以更新文件以读取以下内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that, when compiling for a macOS computer, you could invoke the compiler
    with an extra parameter to enable this `coolstuff` functionality as follows: `go
    build -tags coolstuff main.go`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，当为macOS计算机编译时，您可以通过添加一个额外的参数来调用编译器以启用此`coolstuff`功能，如下所示：`go build -tags
    coolstuff main.go`。
- en: This level of conditional compilation means that the code is not cluttered or
    confusing to read—each file either is, or isn't, included when building. Often,
    a file that contains conditional code will be paired with another that contains
    the alternative implementation, such as `// +build !darwin !coolstuff` to provide
    a fallback of the preceding extra functionality (this would be compiled if not
    on macOS or not passing the `coolstuff` tag). For more information about the way
    that build constraints are calculated, please read the documentation: [https://golang.org/pkg/go/build/](https://golang.org/pkg/go/build/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种级别的条件编译意味着代码不会显得杂乱或难以阅读——每个文件在构建时要么被包含，要么不被包含。通常，包含条件代码的文件将与包含替代实现的另一个文件配对，例如`//
    +build !darwin !coolstuff`，以提供前面额外功能的回退（如果不在macOS上或没有传递`coolstuff`标签，则会被编译）。有关构建约束计算方式的更多信息，请参阅文档：[https://golang.org/pkg/go/build/](https://golang.org/pkg/go/build/)。
- en: 'One additional compiler feature that is very useful in native app development
    (but should be used with caution) is the ability to call C code directly from
    Go, this is known as **Cgo**. The following example illustrates a small Cgo program
    that, through importing the `"C"` package, is able to call C code. It also defines
    a small inline function that can be helpful in keeping your Go code neat if you
    have multiple C calls to make in a method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的编译器功能，在本地应用程序开发中非常有用（但应谨慎使用）是能够直接从Go代码中调用C代码，这被称为**Cgo**。以下示例演示了一个小的Cgo程序，通过导入`"C"`包，能够调用C代码。它还定义了一个小的内联函数，如果您在方法中需要多次调用C代码，这个函数可能会有所帮助：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When this is run like a normal Go program, this will print out the message
    exactly as you would expect:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当像正常的Go程序一样运行时，这将打印出您预期的消息：
- en: '![](img/52e9a341-6c4c-4b3e-8073-ade76081912f.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52e9a341-6c4c-4b3e-8073-ade76081912f.png)'
- en: Running C code from a go file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从go文件中运行C代码。
- en: As you can see, the inline C method is part of a comment, along with the required
    imports, which is read by Cgo when placed immediately before `import "C"`. Notice
    also that a Go string cannot be passed directly to C code, but must be converted
    to a `CString` through the `"C"` package. It's also possible to call Go functions
    from the C code that is included in the compilation. A full explanation of Cgo
    is outside the scope of this book, but more information can be found in the documentation
    at [https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/).  While this is
    very powerful functionality, it can quickly lead to platform-specific code, so
    it's unwise to use this unless absolutely necessary.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，内联C方法是注释的一部分，包括所需的导入，当放置在`import "C"`之前时，会被Cgo读取。请注意，Go字符串不能直接传递给C代码，而必须通过`"C"`包转换为`CString`。从C代码中调用Go函数也是可能的，这被称为**Cgo**。Cgo的完整解释超出了本书的范围，但更多信息可以在[https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)的文档中找到。虽然这是一个非常强大的功能，但它会迅速导致平台特定的代码，因此除非绝对必要，否则不建议使用。
- en: Cross-compiling
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台编译
- en: The compiler features that we've explored so far have been built only for the
    current platform. This means that when developing on Linux, the compiler will
    create (and run, if requested) a native Linux binary (known technically as ELF).
    If executed on macOS, the result will be a native binary for darwin (a Mach-O
    executable), and on Windows it would be a native binary for the Windows platform
    (PE32+). If developers wish to target many different platforms, one option is
    to have a different computer for each build, but this is expensive and time-consuming.
    It's far more convenient to create native binary applications for various platforms
    from the developer's computer—this is called **cross-compiling**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止探索的编译器功能仅针对当前平台构建。这意味着当在Linux上开发时，编译器将创建（如果请求运行，则运行）一个本机Linux二进制文件（技术上称为ELF）。如果在macOS上执行，结果将是一个针对darwin（Mach-O可执行文件）的本机二进制文件，而在Windows上则是一个针对Windows平台的本机二进制文件（PE32+）。如果开发者希望针对许多不同的平台，一个选项是为每个构建拥有不同的计算机，但这既昂贵又耗时。从开发者的计算机创建针对各种平台的本机二进制应用程序要方便得多——这被称为**跨平台编译**。
- en: 'Cross-compiling with the Go toolchain is simple. All you need to know is the
    operating system and architecture you wish to compile for. To run a build for
    a different platform, we simply set the `GOOS` and `GOARCH` environment variables (for
    the operating system and architecture, respectively) and invoke `"go build"`.
    In this example, we illustrate the principle by compiling the introductory example
    for different platforms and check the resulting application using the Unix `file`
    command. As you can see from the first invocation, this illustration is executed
    from a 64-bit Linux computer and we then build for 32-bit Linux, Windows, and
    macOS, respectively:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go工具链进行交叉编译很简单。您需要知道的是您希望编译的操作系统和架构。为了运行针对不同平台的构建，我们只需设置`GOOS`和`GOARCH`环境变量（分别对应操作系统和架构）并调用`"go
    build"`。在这个例子中，我们通过为不同平台编译入门示例并使用Unix的`file`命令检查结果应用程序来阐述这个原则。如您从第一次调用中看到的那样，这个示例是在64位Linux计算机上执行的，然后我们分别为32位Linux、Windows和macOS进行构建：
- en: '![](img/a0cf57d5-92de-4517-ad13-dfbb53c4f01d.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0cf57d5-92de-4517-ad13-dfbb53c4f01d.png)'
- en: Building for different platforms on one computer
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台计算机上为不同的平台构建
- en: And so you see how simple it is to build a Go application for any platform.
    With this knowledge, we can create a graphical application on the developer's
    preferred platform and cross-compile it for many of the most popular operating
    systems, without any custom code or build configurations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到构建适用于任何平台的Go应用程序是多么简单。有了这些知识，我们可以在开发者的首选平台上创建图形应用程序，并将其交叉编译为许多最流行的操作系统，而无需任何自定义代码或构建配置。
- en: Standard library
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库
- en: The standard library of a programming language is the set of APIs and features
    that are provided by the language runtime. C, for example, has a very small standard
    library—as a low-level language, the number of features that it supports for every
    operating system is limited. Java, on the other hand, historically known for being
    heavy on memory and startup time, provides a massive standard library—including
    the Swing GUI described in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml),
    *Graphical User Interface Challenges*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的标准库是由语言运行时提供的API和功能集。例如，C语言有一个非常小的标准库——作为一个底层语言，它支持的每个操作系统的功能数量是有限的。另一方面，Java历史上以内存和启动时间消耗大而闻名，提供了一个庞大的标准库——包括在第2章中描述的Swing
    GUI，*图形用户界面挑战*。
- en: The size of the standard library is usually part of the trade-off when choosing
    a programming language. For performant native applications that start quickly,
    the number of built-in APIs is often small. When building with a higher-level
    language, developers typically expect a lot of supporting features and API packages—and
    this will usually come with a penalty in startup time or performance. The Go language
    attempts to provide a full standard library without any of the runtime penalties.
    This is managed through its cross-platform compilation and static linking, which
    includes all of the utilized features in the native binary being built. This means
    that the files are probably larger than programs compiled from C code and they
    may take longer to compile—but these one-time costs (building and downloading)
    enable the high performance of Go apps across all platforms.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的大小通常是选择编程语言时需要权衡的一部分。对于性能良好的原生应用程序，启动速度快，内置API的数量通常较小。当使用高级语言进行构建时，开发者通常期望有很多支持特性和API包——这通常会在启动时间或性能上带来一定的代价。Go语言试图提供一个完整的标准库，而不带来任何运行时惩罚。这是通过其跨平台编译和静态链接来管理的，它包括正在构建的原生二进制文件中使用的所有功能。这意味着文件可能比从C代码编译的程序要大，并且可能需要更长的时间来编译——但这些一次性成本（构建和下载）使得Go应用程序在所有平台上都能实现高性能。
- en: The standard library included with Go includes powerful features across many
    areas, including cryptography, image manipulation, text handling (including Unicode),
    networking, HTML templating, and web service integration. You can read the full
    documentation at [https://golang.org/pkg/#stdlib](https://golang.org/pkg/#stdlib).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Go附带的标准库在许多领域都提供了强大的功能，包括密码学、图像处理、文本处理（包括Unicode）、网络、HTML模板和Web服务集成。您可以在[https://golang.org/pkg/#stdlib](https://golang.org/pkg/#stdlib)上阅读完整的文档。
- en: Concurrency in language design
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言设计中的并发
- en: In most mainstream programming languages, concurrency and multithreading can
    add complexity and make code harder to read. The designers of Go decided that
    concurrency should be built in from the beginning, making it easy to manage many
    threads of execution while still avoiding the difficulty of shared memory management.
    Go does not expose traditional *threads*, but instead introduces the concept of
    **goroutines**—these are akin to lightweight threads, but it's possible to have
    several thousand at the same time. Shared memory is normally the main communication mechanism
    for concurrent applications, but in Go communication is used to share instead—this
    built-in feature is called **channels**. In addition to these language features,
    Go has a `sync` package within the standard library that provides tools for further
    concurrency management.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数主流编程语言中，并发和多线程可以增加复杂性，并使代码更难阅读。Go 的设计者决定从一开始就构建并发，使其易于管理许多执行线程，同时避免共享内存管理的困难。Go
    不暴露传统的 *threads*，而是引入了 **goroutines** 的概念——这些类似于轻量级线程，但可以同时拥有数千个。共享内存通常是并发应用程序的主要通信机制，但在
    Go 中，通信用于共享——这个内置特性被称为 **channels**。除了这些语言特性之外，Go 在标准库中有一个 `sync` 包，它提供了进一步并发管理的工具。
- en: Goroutines
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: 'First, let''s examine the most basic Go concurrency feature: the goroutine.
    Any normal function, when called, will execute the code inside and exit when `return`
    is encountered, or the function exits—at which point it will return control to
    the function that invoked it. A goroutine is one that starts execution, but immediately
    returns control to the function calling it—essentially creating a background process
    for each invocation. Any function can be called as a goroutine simply by prefixing
    `go` to the invocation, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查最基础的 Go 并发特性：goroutine。任何正常函数在被调用时，都会执行其内部的代码，并在遇到 `return` 时退出，或者函数退出——此时它将控制权返回给调用它的函数。Goroutine
    是一种开始执行但立即将控制权返回给调用它的函数的函数——本质上为每次调用创建一个后台进程。任何函数都可以通过在调用前加上 `go` 前缀作为 goroutine
    调用，如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code sample defines a `tick(string)` method that will output the requested
    message every 10 milliseconds. The `main()` function calls this code in two different
    ways: first, it is invoked as a goroutine, and then as a normal function call.
    If this were invoked as two function calls, one after the other, we would see
    a lot of copies of `"goroutine"` output to the command line, followed by `"function"`
    many times. Instead, however, the goroutine executes concurrently with the following
    code, and so we see this output instead:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例定义了一个 `tick(string)` 方法，它将每隔 10 毫秒输出请求的消息。`main()` 函数以两种不同的方式调用此代码：首先，它作为
    goroutine 调用，然后作为正常的函数调用。如果这是作为两个连续的函数调用调用的，我们会在命令行中看到很多 `"goroutine"` 的副本，然后是多次
    `"function"`。然而，goroutine 与以下代码并发执行，所以我们看到的是这个输出：
- en: '![](img/7fe4dd2d-d312-4743-98e6-514205275843.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fe4dd2d-d312-4743-98e6-514205275843.png)'
- en: Concurrent output with a goroutine
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 goroutine 的并发输出
- en: What you see may be slightly different, as the order appears a little random.
    What you should see is that each pair of output lines say either `"goroutine"`
    or `"function"` with a small time gap between them. The order of each pair will
    depend on the scheduler, but what you can clearly see is that two invocations
    of the `tick` function were running at the same time (that is, concurrently).
    Goroutines are not limited to such trivial examples but as they occupy the same
    address space (like a normal function call), they have access to shared areas
    of memory. When multiple threads can write to the same area of memory, synchronization
    is typically required to ensure correct operation. To provide better semantics
    for communicating in this way, the Go language has a feature named **channels**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的内容可能略有不同，因为顺序看起来有点随机。你应该看到的是，每一对输出行之间要么是 `"goroutine"` 或 `"function"`，并且它们之间有一个小的时间间隔。每一对顺序将取决于调度器，但你可以清楚地看到，`tick`
    函数的两次调用是同时运行的（即并发）。Goroutines 并不仅限于这样的简单示例，但它们占用相同的地址空间（就像正常的函数调用一样），因此它们可以访问共享的内存区域。当多个线程可以写入同一内存区域时，通常需要同步来确保正确操作。为了提供更好的语义以这种方式进行通信，Go
    语言有一个名为 **channels** 的特性。
- en: Channels
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Channels
- en: The philosophy for sharing data with Go is *Don't communicate by sharing memory;
    instead, share memory by communicating*. Channels are the language construct that
    support this approach – they allow the sharing of data by communicating between
    goroutines correctly, rather than sharing common data. This is the main way that
    Go avoids race conditions (that is, one thread writing data while others read
    the same data). Channels are used for all sorts of patterns in Go – they can communicate
    the result of a goroutine (or pass data between routines), provide updates when
    data changes, or even signal that processes should finish.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Go中共享数据的哲学是*不要通过共享内存来通信；相反，通过通信来共享内存*。通道是支持这种方法的语言结构——它们允许通过在goroutine之间正确通信来共享数据，而不是共享公共数据。这是Go避免竞态条件（即一个线程写入数据，而其他线程读取相同的数据）的主要方式。通道在Go中用于各种模式——它们可以传递goroutine的结果（或在不同程序之间传递数据），在数据更改时提供更新，甚至可以发出进程应该结束的信号。
- en: 'Channels, just like all variables and constants in Go, require a type. The
    type of a channel determines the data that can be communicated through it. The
    type could be `bool` if you want to send information that is just `true`/`false`,
    or it could be a custom `struct` data type if you wish to communicate more information,
    such as a data-changed notification. In this example of channels, we are using
    a simple string channel that is read from a number of times while a goroutine
    continues to write into it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通道，就像Go中所有的变量和常量一样，需要有一个类型。通道的类型决定了可以通过它传递的数据。如果只想发送`true`/`false`这样的信息，类型可以是`bool`；如果您希望传递更多信息，例如数据更改通知，则可以是自定义的`struct`数据类型。在这个通道的例子中，我们使用了一个简单的字符串通道，它被读取多次，而goroutine继续向其中写入：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this sample will demonstrate that each time the channel is written
    to (in `say`), it must wait until the channel is read (in `listen`) before it
    can be written to again. You can also see that the `talk` goroutine never completed
    the message because we didn''t read all of the data it was waiting to write:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将演示每次向通道写入（在`say`中），它必须等待通道被读取（在`listen`中），然后才能再次写入。您还可以看到`talk`协程从未完成消息，因为我们没有读取它等待写入的所有数据：
- en: '![](img/5adcac5a-6d5c-44e0-999b-652bd7df54d3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5adcac5a-6d5c-44e0-999b-652bd7df54d3.png)'
- en: Communicating through a simple channel
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单通道进行通信
- en: 'By default, writing to a channel will block until some code is ready to read
    from the other end, and likewise, reading will block until data is written to
    the channel, at which point the program flow will continue. This behavior can
    be altered by using a buffered channel – if a channel has a buffer size of 5,
    it could be written to 5 times before blocking; similarly, reading from that channel
    would potentially return 5 values before blocking (reading a channel will always
    block when no data is available). If we updated the preceding example to create
    a buffered channel of size 3 (by using `make(chan string, 3)`), we would see that
    the full message is written and the `talk` method completes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，向通道写入将阻塞，直到有代码准备好从另一端读取，同样，读取将阻塞，直到向通道写入数据，此时程序流程将继续。这种行为可以通过使用带缓冲的通道来改变——如果通道的缓冲区大小为5，则可以写入5次而不阻塞；同样，从该通道读取可能会在阻塞之前返回5个值（在没有数据可用时，读取通道将始终阻塞）。如果我们更新前面的示例以创建一个大小为3的带缓冲通道（通过使用`make(chan
    string, 3)`），我们会看到完整的信息被写入，并且`talk`方法完成：
- en: '![](img/a19fbe72-b053-4070-8990-ccd33373d1da.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a19fbe72-b053-4070-8990-ccd33373d1da.png)'
- en: Adding buffering to the channel
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 向通道添加缓冲
- en: 'This trivial example indicates how you can safely communicate between goroutines,
    but let''s look at some more practical examples by including some additional features.
    For example, a configuration struct could be communicated through a channel each
    time it changes, so that the application can respond accordingly:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子说明了您如何在goroutine之间安全地通信，但让我们通过包含一些额外的功能来查看一些更实际的例子。例如，每次配置结构体更改时，都可以通过通道传递，这样应用程序就可以相应地做出反应：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To be able to manage concurrency and communication between multiple goroutines,
    the language has an enhancement for the `select` keyword, which provides the ability
    to wait on multiple channels. This means that you don''t have to have a goroutine
    for each blocking channel. The following example illustrates how a background
    function can work on some complex calculations (in this case, `square`) that are
    fed back to the main function, and also wait on a signal to finish processing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够管理多个goroutine之间的并发和通信，语言对 `select` 关键字进行了增强，它提供了在多个通道上等待的能力。这意味着你不需要为每个阻塞通道创建一个goroutine。以下示例说明了后台函数如何处理一些复杂的计算（在这种情况下，`square`），并将结果反馈给主函数，同时等待信号以完成处理：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running this example will output the calculations returned until the process
    is signaled to stop:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将输出计算结果，直到进程被信号通知停止：
- en: '![](img/1eae1b51-c38f-4f30-a9b7-3baded6543b8.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1eae1b51-c38f-4f30-a9b7-3baded6543b8.png)'
- en: Reading from the calculation channel until quit is signaled
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 读取计算通道直到收到退出信号
- en: 'And finally, the channels in Go can be closed by the writer; this means that
    the function reading from a channel may stop getting new values. To avoid this
    deadlock situation, a reader of a channel can detect whether the channel has been
    closed. The syntax to check for the status of a channel is to read an optional
    second parameter, `val, ok := <-ch`, where `val` is the value read and `ok` indicates
    that the channel isn''t closed. In addition to this, a new `range` keyword has
    been added, which will iterate through the values of a channel until it closes.
    The following example includes a `download()` function that simulates downloading
    data and updating its percentage to completion. The process reaches a logical
    conclusion and so the `main` function can complete. You can see how this could
    be used to ensure a progress bar stays up to date while other parts of the program
    keep running:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Go中的通道可以被写入者关闭；这意味着从通道读取的函数可能停止接收新值。为了避免这种死锁情况，通道的读取者可以检测通道是否已关闭。检查通道状态的语法是读取一个可选的第二个参数，`val,
    ok := <-ch`，其中 `val` 是读取的值，`ok` 表示通道没有被关闭。此外，还增加了一个新的 `range` 关键字，它将迭代通道的值，直到它关闭。以下示例包括一个
    `download()` 函数，该函数模拟下载数据并更新完成百分比。进程达到逻辑结论，因此 `main` 函数可以完成。你可以看到如何确保进度条在程序的其他部分继续运行时保持更新：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running this example will show how a simulated download progresses and returns
    once the process is complete. The simple `range` keyword is used to avoid handling
    the channel-close condition directly:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将展示模拟下载的进度，并在进程完成后返回。简单的 `range` 关键字用于避免直接处理通道关闭条件：
- en: '![](img/f6c5fc5d-bf06-4a58-a9d2-0e3679c54daa.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6c5fc5d-bf06-4a58-a9d2-0e3679c54daa.png)'
- en: Iterating on a channel range
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在通道范围内迭代
- en: Sometimes, you need to go beyond the concurrency primitives and handle special
    cases. This is what the standard library `sync` package provides.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要超越并发原语并处理特殊情况。这正是标准库中的 `sync` 包所提供的。
- en: The sync package
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sync` 包'
- en: The sync package of Go's standard library provides additional synchronization
    features that aren't included in the language itself. Its additions to concurrency
    management include Mutex, WaitGroup, and Once, which we'll look at briefly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库的 `sync` 包提供了语言本身不包括的额外同步功能。它在并发管理方面的补充包括 Mutex、WaitGroup 和 Once，我们将简要介绍。
- en: '`Mutex` is used when you want to ensure mutual exclusion—that is, if you only
    want one goroutine to access a piece of data at a time (to avoid potential conflicts).
    The key methods are `Lock()` and `Unlock()`, which surround the section of code
    that should never be executed concurrently. If a second goroutine attempts to
    enter the section, it will block until the lock is released:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想确保互斥访问——也就是说，你只想让一个goroutine一次访问一块数据（以避免潜在的冲突）时，会使用 `Mutex`。关键方法是 `Lock()`
    和 `Unlock()`，它们包围了不应该并发执行的代码段。如果第二个goroutine尝试进入该段，它将阻塞，直到锁被释放：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we have a map, `vals`, that we want to share and so
    must ensure thread-safety. We add `sync.Mutex` to guard the access and ensure
    that the lock is obtained before using the map. Note that in the `Get` method,
    we use the `defer` keyword to ensure the code is called as the method exits—this
    avoids needing to access the map, storing the value, and unlocking before then
    returning (making the code neater).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个`vals`映射，我们想要共享，因此必须确保线程安全。我们添加`sync.Mutex`来保护访问并确保在使用映射之前获得锁。注意，在`Get`方法中，我们使用`defer`关键字来确保代码在方法退出时被调用——这避免了在返回之前需要访问映射、存储值和解锁的需要（使代码更整洁）。
- en: '`WaitGroup` is helpful if you want to create a number of background activities
    and then wait until they all complete. For example, this code snippet creates
    a download method that takes an additional parameter for the group it''s part
    of. Each download instance increments the group counter (`Add(1)`) at the start
    of the download and clears it (`Done()`) at the end. The calling function sets
    up a wait group and then calls `Wait()`, which will return once all downloads
    are complete:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitGroup`很有用，如果你想要创建多个后台活动，然后等待它们全部完成。例如，这个代码片段创建了一个下载方法，它接受一个额外的参数，即它所属的组。每个下载实例在下载开始时增加组计数器（`Add(1)`），在下载结束时清除它（`Done()`）。调用函数设置一个等待组，然后调用`Wait()`，这将返回一旦所有下载完成：'
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last example, `Once`, is rather self-explanatory—it allows code to be executed
    once only. Invoking its `Do(func())` method will cause the passed function to
    never be called more than once. This is helpful if you''re trying to implement
    a lazy-loading singleton pattern, such as the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，`Once`，相当直观——它允许代码只执行一次。调用它的`Do(func())`方法将导致传递的函数不会被调用超过一次。如果你试图实现一个懒加载的单例模式，这很有帮助，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The full documentation is available at [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/);
    however, it's recommended to use the channel constructs when possible, instead
    of most of these features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完整文档可在[https://golang.org/pkg/sync/](https://golang.org/pkg/sync/)找到；然而，建议尽可能使用channel构造，而不是这些功能中的大多数。
- en: Web services included as standard
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准包含的Web服务
- en: 'As a modern programming language, Go comes with extensive support for HTTP
    clients, servers, and standard encoding handlers, including JSON and XML. Combined
    with the built-in string and map features, this removes many of the hurdles of
    working with web services. In addition to this, the format for structs in Go allows
    for additional `tags` that can provide metadata to its fields. Both the `encoding/json`
    and `encoding/xml` packages make use of this to understand how to correctly encode
    and decode instances of these structs. The following example demonstrates these
    features by connecting to a web service, accessing a JSON response, and decoding
    it into a struct that is then used like any other:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种现代编程语言，Go提供了广泛的HTTP客户端、服务器和标准编码处理程序的支持，包括JSON和XML。结合内置的字符串和映射功能，这消除了许多与Web服务一起工作的障碍。除此之外，Go中结构体的格式允许额外的`tags`，可以为字段提供元数据。`encoding/json`和`encoding/xml`包都利用这一点来理解如何正确地编码和解码这些结构体的实例。以下示例通过连接到Web服务、访问JSON响应并将其解码为结构体来演示这些功能，然后像使用任何其他结构体一样使用它：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example code you can see the usage of struct tags prefixed
    with `"json:"`. These provide hints to the `"encoding/json"` package that manages
    the encoding and decoding of theses objects. We can run this example and see the
    output of converting a struct into JSON and back again:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，你可以看到带有前缀`"json:"`的结构体标签的使用。这些为管理这些对象编码和解码的`"encoding/json"`包提供了提示。我们可以运行这个示例，并看到将结构体转换为JSON然后再转换回来的输出：
- en: '![](img/e6562dfc-82fa-4e12-bf6b-74526049f17c.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6562dfc-82fa-4e12-bf6b-74526049f17c.png)'
- en: Encoding and decoding JSON for an HTTP request
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对HTTP请求进行JSON编码和解码
- en: Notice that zero value fields marked with `omitempty` were not included in the
    JSON output, and equally the password field that was marked as `"-"` (meaning
    do not include) was ignored when encoding the data. After downloading the data
    from a test web service, it was marshaled directly into an instance of the `Person`
    struct, leaving missing fields with their zero value. This was all possible using
    built-in features of the language and standard library. It's very straightforward,
    thanks to Go's readiness for working with web services.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到标记为 `omitempty` 的零值字段未包含在 JSON 输出中，同样地，标记为 `"-"`（表示不包含）的密码字段在编码数据时也被忽略。从测试网络服务下载数据后，它被直接
    marshaled 到 `Person` 结构体的实例中，缺失的字段保留其零值。这一切都是使用语言的内置特性和标准库功能实现的。这要归功于 Go 在处理网络服务方面的简便性。
- en: Choosing your look and feel
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择外观和感觉
- en: 'As discussed in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml), *Graphical
    User Interface Challenges*, there are many approaches to graphical applications,
    leaving developers to choose between native versus hybrid (packaged web apps)
    and designers to pick from system look and feel, a multi-platform widget set,
    or even a custom design. The choice you make will probably be impacted by the
    needs of your application and the platforms you aim to target—is performance important
    and do you aim for a cross-platform deployment? Go doesn''t have a standard graphical
    toolkit, and this omission has led developers to think it''s not a language to
    be used for coding GUI applications. However, as we''ve seen in this chapter,
    it''s a great fit for graphical application development. This leads to the question:
    which toolkits are available to build GUI apps in Go?'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 2 章](d5375343-5332-4374-9297-dfbb256a5d91.xhtml) 中所讨论的，*图形用户界面挑战*，图形应用程序有许多方法，让开发者可以在原生与混合（打包的
    Web 应用）之间选择，让设计师可以从系统外观和感觉、多平台小部件集或甚至自定义设计中进行选择。您所做的选择可能会受到您的应用程序需求和目标平台的影响——性能是否重要，您是否希望实现跨平台部署？Go
    没有标准的图形工具包，这种省略导致开发者认为它不是用于编码 GUI 应用的语言。然而，正如我们在本章中所看到的，它非常适合图形应用程序开发。这引出了一个问题：在
    Go 中构建 GUI 应用程序有哪些工具包可用？
- en: 'Simply put: a lot. You can see a list of the major, currently-maintained toolkits
    online at [https://awesome-go.com/#gui](https://awesome-go.com/#gui)—there is
    probably an option that suits most use cases. As we are looking to build high-performance
    applications that look great, we''ll skip the items that rely on bundling web
    content to create hybrid applications. That still leaves a large list! There are
    some that give direct access to system components for a truly native experience,
    and some that provide abstracted APIs for the same platform look and feel. Others
    provide their own rendering of the user interface, which is consistent on all
    platforms they support (similar to Java Swing''s *Metal* look and feel).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：很多。您可以在网上看到主要、目前维护的工具包列表，请访问 [https://awesome-go.com/#gui](https://awesome-go.com/#gui)——可能有一个选项适合大多数用例。由于我们正在寻找构建性能出色的高性能应用程序，我们将跳过依赖于捆绑网络内容以创建混合应用程序的项目。这仍然留下了一个庞大的列表！有些工具包提供对系统组件的直接访问，以实现真正的原生体验，有些则提供抽象的
    API 以实现相同平台的外观和感觉。其他工具包提供他们自己的用户界面渲染，这在所有支持的平台上都是一致的（类似于 Java Swing 的 *Metal*
    外观和感觉）。
- en: As well as a great language for GUI development, Go presents us with the opportunity
    to choose the right GUI toolkit for our application. [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits
    Using Existing Widgets* (Chapters [4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    [5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml), [6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml) and
    [7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)), and [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits* (Chapters [8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml),
    [9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml) and [10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml)), 
    introduces developers to each of the main options, and shows how to start building
    beautiful graphical applications with each of them. [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits
    Using Existing Widgets*, is focused on building applications that match the operating
    system's look and feel, and [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits, *is for applications that are going for a more modern look
    that aims to be consistent across multiple platforms.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是GUI开发的优秀语言外，Go还为我们提供了选择适合我们应用程序的正确GUI工具包的机会。[第2节](36bfea00-c659-4569-864c-de2c460c7467.xhtml)，*使用现有小部件的工具包*（第[4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)章、[5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml)章、[6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml)章和[7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)章）和[第3节](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml)，*现代图形工具包*（第[8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml)章、[9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml)章和[10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml)章），介绍了每个主要选项，并展示了如何使用每个工具包开始构建美观的图形应用程序。[第2节](36bfea00-c659-4569-864c-de2c460c7467.xhtml)，*使用现有小部件的工具包*，专注于构建与操作系统外观和感觉相匹配的应用程序，而[第3节](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml)，*现代图形工具包*，则是为那些追求更现代外观并旨在跨多个平台保持一致性的应用程序而设计的。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how the Go language is very well-suited to developing
    graphical applications. Its design for handling concurrency makes the types of
    multithreading needed by GUIs easy to manage. Channels, the main thread-communication
    feature, are a little hard to learn, but through some basic examples, we saw how
    common concurrency issues could easily be avoided. The write-once-compile-anywhere
    ethos of Go means that developers can easily compile the same code and deliver
    native apps across most common platforms from a single codebase using the provided
    tools. As a modern language, it's designed to operate in a connected world and
    its support for network communications and web services is excellent – we ran
    examples that illustrated how objects can be easily transformed to and from common
    web formats.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Go语言在开发图形应用程序方面的优势。它处理并发的架构使得GUI所需的线程类型易于管理。通道，作为主要的线程通信特性，学习起来有点困难，但通过一些基本示例，我们看到了如何轻松避免常见的并发问题。Go的“一次编写，到处编译”的理念意味着开发者可以轻松地编译相同的代码，并使用提供的工具从单一代码库在大多数常见平台上交付原生应用程序。作为一种现代语言，它旨在在互联的世界中运行，其对网络通信和Web服务的支持非常出色——我们运行了示例，展示了如何轻松地将对象转换为常见的Web格式。
- en: Having explored the many ways that Go suits graphical application development,
    we also reflected on the many toolkits available to choose from. Despite not having
    a standard user interface, there are many possibilities for building great-looking
    graphical apps with Go. In [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications,* [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml), *andlabs
    UI - Cross-platform Native UIs,* [Chapter 6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml), *Go-GTK
    - Multiple Platforms with GTK,* [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), *Go-Qt
    - Multiple Platforms with Qt* [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    - Experimental Go GUI API* [Chapter 9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml), *nk
    - Nuklear for Go,* and [Chapter 10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml), *Fyne
    - Material Design based GUI,* we'll look at the different toolkits available and
    how to start building your first Go-based GUI. We start by exploring how to build
    traditional user interfaces, beginning with apps for Microsoft Windows in [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 探索了Go语言适用于图形应用开发的多种方式后，我们也反思了可供选择的众多工具包。尽管Go语言没有标准用户界面，但仍有许多可能性可以用来构建外观出色的图形应用程序。在[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，*Walk
    - 构建图形窗口应用程序*，[第5章](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml)，*andlabs UI -
    跨平台原生UI*，[第6章](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml)，*Go-GTK - 多平台与GTK*，[第7章](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)，*Go-Qt
    - 多平台与Qt*，[第8章](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml)，*Shiny - 实验性Go GUI
    API*，[第9章](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml)，*nk - Nuklear for Go*，以及[第10章](2476a1b6-0915-496b-8290-7a673f533aca.xhtml)，*Fyne
    - 基于 Material Design 的 GUI*中，我们将探讨不同的工具包以及如何开始构建你的第一个基于Go的GUI。我们首先从探索如何构建传统用户界面开始，从[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，*Walk
    - 构建图形窗口应用程序*中的Microsoft Windows应用程序开始。
