- en: Go to the Rescue!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having read the previous chapter on the challenges of building native graphical
    applications, you may be wondering whether it's worth all the effort. Hopefully,
    you are confident that your users will appreciate the quality user experience
    you are designing, and your team will be keen to see the benefits of taking this
    route over a web app or other approach. Thankfully, the team at Google that designed
    the Go programming language understood these challenges and decided that something
    should be done to aid developers in their quest!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a detailed look at the Go language and see how
    its design can solve (or help with) the various challenges discussed in [Chapter
    2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml), *Graphical User Interface Challenges*.
    In particular, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A cross-platform approach for any applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the concurrency model helps create reliable applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in support for working with web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the look and feel of your GUI and managing the GUI code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with how the Go language can
    support GUI application design, and be ready to start working on real examples
    using the various frameworks available to Go developers.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go is a language that (like C, C++, Lisp, and many others) compiles to a native
    binary on every platform it supports. This is important for graphical applications
    as it''s the best way to create the most responsive and smoothest user interfaces
    on mainstream computer hardware. At the time of writing, the platforms that Go
    runs on includes Windows, macOS, Linux, Solaris, and other popular Unix-based
    operating systems (which is essentially all desktop personal computers). What
    stands out about Go compared to other modern languages is that its source code
    will compile, without any alterations or special adaptation, to native code on
    every platform that it supports. The language also comprises a large library of
    APIs that fully support every one of its supported operating systems. This is
    a huge advantage for developers who want to write an efficient application for
    multiple operating systems without maintaining slightly different versions for
    each platform. Go is also a *typed* language, which means that every variable,
    constant, function parameter, and return type must have a single, defined type.
    Unlike some older typed languages, Go is often able to infer a type, which helps
    avoid the duplication of information in the source code. These features help to
    create a language that''s great for development—so let''s look at some real code
    and how this is built and run. We''ll work with a simple *hello world* example,
    which we will write into a file named `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows the most basic Go program. The first line indicates the
    package name (here, `main` means that the file describes an executable command).
    Then, we have the import block where you reference any standard library packages
    or external code. Finally, there is a `main()` method, which is the start of any
    Go program—and this method simply prints *Hello World!* to the command line using
    the `fmt` package. This method doesn''t mention a return type (which would be
    placed after `main()`)—that means there is no return type, such as `void` in C
    or Java programs. We run this application using the `go run main.go` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd672840-ca62-45c6-87c0-4647e0db3879.png)'
  prefs: []
  type: TYPE_IMG
- en: Running main.go outputs the message before exiting
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside each Go file will usually be a test file that runs unit tests against
    the main code. Let''s demonstrate that with another trivial example. Enter the
    following code into `main_test.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we run this code, you should notice two important differences compared
    to a regular Go file. First, the import list includes `"testing"`—this is required
    for writing any test method. Second, the method name starts with `Test` this time,
    and includes a single parameter of the `*testing.T` type. Any method that conforms
    to those conditions and is in a file that has a name ending in `_test.go` will
    be considered a unit test. Now let''s run the tests using the built-in test runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/821947c8-7442-4b31-b486-c8d761e7a0b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Running Go tests in verbose mode
  prefs: []
  type: TYPE_NORMAL
- en: In this command, the `-v` parameter requests verbose output, which is seen as
    the tests run, and the resulting `command-line-arguments` indicates that the tests
    were run on the files specified in our parameter list, rather than a full package.
    Alternatively, typing `go test` would output less information and would run all
    the tests in the current package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these basic commands, Go comes with many tools that help developers
    to write and maintain high-quality code. The three that are most commonly used
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gofmt`: This ensures that source code is formatted according to the Go specification, and
    can rewrite your files if requested (by passing `-w`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`godoc`: This runs a local documentation server to check how your API will
    look to other developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go vet`: This examines the code for common programming mistakes that a compiler
    won''t detect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may have noticed that these commands simply run without needing to compile
    – but how can that be, if Go is a compiled language? That is because the `run` command
    is actually a shortcut to build the application and then run it. This makes running
    the latest version of an application much quicker than the usual approach of compiling
    and then running, without losing any of the benefits of being a native binary.
    In this mode, the built application is discarded when the run finishes. If you
    want to build and then run many times, you can use the `build` command, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de1217c1-790f-43d0-b808-52730d7927e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a binary to run many times
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the compiler has created an executable file that has the same
    name as the file we entered the code into. This file is the native application
    built from our source code and it can be run like any other application. Note
    that this is a native application and so it's not portable the way that a Java
    application is. It will run on the computer we built it on and others like it,
    but an application built on a Windows computer will not run on macOS directly.
    The source code is compatible with both platforms, but the binary application
    is not.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted at this point that the Go language also provides *garbage
    collection*, which contributes to the ease of development. This means that when
    objects we created are no longer needed, the system will ensure the memory they
    occupy is freed up. Compared to `C` and other (older) compiled languages where
    this isn't provided, we have less code to write, and a much lower risk of our
    application leaking memory. Now that we know the language, let's explore the compiler
    features that support the cross-platform approach and see how to build these examples
    for different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform for any application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the introduction, we saw that a file with a name ending in `_test.go` would
    automatically be run as part of the test phase. Go uses this naming convention
    for additional compiler features to provide the ability to include code for a
    specific platform or computer architecture. For example, a file named `main_windows.go`
    will only be included in the compilation if you are building for Microsoft Windows,
    and the `main_darwin.go` file would only be compiled for macOS (darwin is the
    name of the underlying operating system). Similarly, the computer architecture
    can be used to conditionally include source code, and so a file named `main_arm.go` would
    only be part of the build for a 32-bit ARM-based processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also supports the conditional compilation of arbitrary files through the
    use of build constraints (also known as build tags). These operate at a file level
    to determine whether a file should be included in the build. To use this functionality,
    a comment is placed at the top of the file before the package declaration (with
    an important blank line afterward):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Basic build tags match the platform and architecture strings used for the file
    naming described previously, with the addition that they can be combined and negated
    (using the `!` character). Therefore, the preceding example will be included when
    compiling for Linux on a non-32-bit processor (`!386`). This functionality can
    be further extended by the use of custom tags that can be passed to the compiler.
    In this way, an application that has advanced features only for a Macintosh could
    update the file to read the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means that, when compiling for a macOS computer, you could invoke the compiler
    with an extra parameter to enable this `coolstuff` functionality as follows: `go
    build -tags coolstuff main.go`.
  prefs: []
  type: TYPE_NORMAL
- en: This level of conditional compilation means that the code is not cluttered or
    confusing to read—each file either is, or isn't, included when building. Often,
    a file that contains conditional code will be paired with another that contains
    the alternative implementation, such as `// +build !darwin !coolstuff` to provide
    a fallback of the preceding extra functionality (this would be compiled if not
    on macOS or not passing the `coolstuff` tag). For more information about the way
    that build constraints are calculated, please read the documentation: [https://golang.org/pkg/go/build/](https://golang.org/pkg/go/build/).
  prefs: []
  type: TYPE_NORMAL
- en: 'One additional compiler feature that is very useful in native app development
    (but should be used with caution) is the ability to call C code directly from
    Go, this is known as **Cgo**. The following example illustrates a small Cgo program
    that, through importing the `"C"` package, is able to call C code. It also defines
    a small inline function that can be helpful in keeping your Go code neat if you
    have multiple C calls to make in a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is run like a normal Go program, this will print out the message
    exactly as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52e9a341-6c4c-4b3e-8073-ade76081912f.png)'
  prefs: []
  type: TYPE_IMG
- en: Running C code from a go file.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the inline C method is part of a comment, along with the required
    imports, which is read by Cgo when placed immediately before `import "C"`. Notice
    also that a Go string cannot be passed directly to C code, but must be converted
    to a `CString` through the `"C"` package. It's also possible to call Go functions
    from the C code that is included in the compilation. A full explanation of Cgo
    is outside the scope of this book, but more information can be found in the documentation
    at [https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/).  While this is
    very powerful functionality, it can quickly lead to platform-specific code, so
    it's unwise to use this unless absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The compiler features that we've explored so far have been built only for the
    current platform. This means that when developing on Linux, the compiler will
    create (and run, if requested) a native Linux binary (known technically as ELF).
    If executed on macOS, the result will be a native binary for darwin (a Mach-O
    executable), and on Windows it would be a native binary for the Windows platform
    (PE32+). If developers wish to target many different platforms, one option is
    to have a different computer for each build, but this is expensive and time-consuming.
    It's far more convenient to create native binary applications for various platforms
    from the developer's computer—this is called **cross-compiling**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-compiling with the Go toolchain is simple. All you need to know is the
    operating system and architecture you wish to compile for. To run a build for
    a different platform, we simply set the `GOOS` and `GOARCH` environment variables (for
    the operating system and architecture, respectively) and invoke `"go build"`.
    In this example, we illustrate the principle by compiling the introductory example
    for different platforms and check the resulting application using the Unix `file`
    command. As you can see from the first invocation, this illustration is executed
    from a 64-bit Linux computer and we then build for 32-bit Linux, Windows, and
    macOS, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0cf57d5-92de-4517-ad13-dfbb53c4f01d.png)'
  prefs: []
  type: TYPE_IMG
- en: Building for different platforms on one computer
  prefs: []
  type: TYPE_NORMAL
- en: And so you see how simple it is to build a Go application for any platform.
    With this knowledge, we can create a graphical application on the developer's
    preferred platform and cross-compile it for many of the most popular operating
    systems, without any custom code or build configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library of a programming language is the set of APIs and features
    that are provided by the language runtime. C, for example, has a very small standard
    library—as a low-level language, the number of features that it supports for every
    operating system is limited. Java, on the other hand, historically known for being
    heavy on memory and startup time, provides a massive standard library—including
    the Swing GUI described in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml),
    *Graphical User Interface Challenges*.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the standard library is usually part of the trade-off when choosing
    a programming language. For performant native applications that start quickly,
    the number of built-in APIs is often small. When building with a higher-level
    language, developers typically expect a lot of supporting features and API packages—and
    this will usually come with a penalty in startup time or performance. The Go language
    attempts to provide a full standard library without any of the runtime penalties.
    This is managed through its cross-platform compilation and static linking, which
    includes all of the utilized features in the native binary being built. This means
    that the files are probably larger than programs compiled from C code and they
    may take longer to compile—but these one-time costs (building and downloading)
    enable the high performance of Go apps across all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The standard library included with Go includes powerful features across many
    areas, including cryptography, image manipulation, text handling (including Unicode),
    networking, HTML templating, and web service integration. You can read the full
    documentation at [https://golang.org/pkg/#stdlib](https://golang.org/pkg/#stdlib).
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency in language design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most mainstream programming languages, concurrency and multithreading can
    add complexity and make code harder to read. The designers of Go decided that
    concurrency should be built in from the beginning, making it easy to manage many
    threads of execution while still avoiding the difficulty of shared memory management.
    Go does not expose traditional *threads*, but instead introduces the concept of
    **goroutines**—these are akin to lightweight threads, but it's possible to have
    several thousand at the same time. Shared memory is normally the main communication mechanism
    for concurrent applications, but in Go communication is used to share instead—this
    built-in feature is called **channels**. In addition to these language features,
    Go has a `sync` package within the standard library that provides tools for further
    concurrency management.
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s examine the most basic Go concurrency feature: the goroutine.
    Any normal function, when called, will execute the code inside and exit when `return`
    is encountered, or the function exits—at which point it will return control to
    the function that invoked it. A goroutine is one that starts execution, but immediately
    returns control to the function calling it—essentially creating a background process
    for each invocation. Any function can be called as a goroutine simply by prefixing
    `go` to the invocation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sample defines a `tick(string)` method that will output the requested
    message every 10 milliseconds. The `main()` function calls this code in two different
    ways: first, it is invoked as a goroutine, and then as a normal function call.
    If this were invoked as two function calls, one after the other, we would see
    a lot of copies of `"goroutine"` output to the command line, followed by `"function"`
    many times. Instead, however, the goroutine executes concurrently with the following
    code, and so we see this output instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fe4dd2d-d312-4743-98e6-514205275843.png)'
  prefs: []
  type: TYPE_IMG
- en: Concurrent output with a goroutine
  prefs: []
  type: TYPE_NORMAL
- en: What you see may be slightly different, as the order appears a little random.
    What you should see is that each pair of output lines say either `"goroutine"`
    or `"function"` with a small time gap between them. The order of each pair will
    depend on the scheduler, but what you can clearly see is that two invocations
    of the `tick` function were running at the same time (that is, concurrently).
    Goroutines are not limited to such trivial examples but as they occupy the same
    address space (like a normal function call), they have access to shared areas
    of memory. When multiple threads can write to the same area of memory, synchronization
    is typically required to ensure correct operation. To provide better semantics
    for communicating in this way, the Go language has a feature named **channels**.
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The philosophy for sharing data with Go is *Don't communicate by sharing memory;
    instead, share memory by communicating*. Channels are the language construct that
    support this approach – they allow the sharing of data by communicating between
    goroutines correctly, rather than sharing common data. This is the main way that
    Go avoids race conditions (that is, one thread writing data while others read
    the same data). Channels are used for all sorts of patterns in Go – they can communicate
    the result of a goroutine (or pass data between routines), provide updates when
    data changes, or even signal that processes should finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels, just like all variables and constants in Go, require a type. The
    type of a channel determines the data that can be communicated through it. The
    type could be `bool` if you want to send information that is just `true`/`false`,
    or it could be a custom `struct` data type if you wish to communicate more information,
    such as a data-changed notification. In this example of channels, we are using
    a simple string channel that is read from a number of times while a goroutine
    continues to write into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this sample will demonstrate that each time the channel is written
    to (in `say`), it must wait until the channel is read (in `listen`) before it
    can be written to again. You can also see that the `talk` goroutine never completed
    the message because we didn''t read all of the data it was waiting to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5adcac5a-6d5c-44e0-999b-652bd7df54d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Communicating through a simple channel
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, writing to a channel will block until some code is ready to read
    from the other end, and likewise, reading will block until data is written to
    the channel, at which point the program flow will continue. This behavior can
    be altered by using a buffered channel – if a channel has a buffer size of 5,
    it could be written to 5 times before blocking; similarly, reading from that channel
    would potentially return 5 values before blocking (reading a channel will always
    block when no data is available). If we updated the preceding example to create
    a buffered channel of size 3 (by using `make(chan string, 3)`), we would see that
    the full message is written and the `talk` method completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a19fbe72-b053-4070-8990-ccd33373d1da.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding buffering to the channel
  prefs: []
  type: TYPE_NORMAL
- en: 'This trivial example indicates how you can safely communicate between goroutines,
    but let''s look at some more practical examples by including some additional features.
    For example, a configuration struct could be communicated through a channel each
    time it changes, so that the application can respond accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to manage concurrency and communication between multiple goroutines,
    the language has an enhancement for the `select` keyword, which provides the ability
    to wait on multiple channels. This means that you don''t have to have a goroutine
    for each blocking channel. The following example illustrates how a background
    function can work on some complex calculations (in this case, `square`) that are
    fed back to the main function, and also wait on a signal to finish processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this example will output the calculations returned until the process
    is signaled to stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1eae1b51-c38f-4f30-a9b7-3baded6543b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading from the calculation channel until quit is signaled
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, the channels in Go can be closed by the writer; this means that
    the function reading from a channel may stop getting new values. To avoid this
    deadlock situation, a reader of a channel can detect whether the channel has been
    closed. The syntax to check for the status of a channel is to read an optional
    second parameter, `val, ok := <-ch`, where `val` is the value read and `ok` indicates
    that the channel isn''t closed. In addition to this, a new `range` keyword has
    been added, which will iterate through the values of a channel until it closes.
    The following example includes a `download()` function that simulates downloading
    data and updating its percentage to completion. The process reaches a logical
    conclusion and so the `main` function can complete. You can see how this could
    be used to ensure a progress bar stays up to date while other parts of the program
    keep running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this example will show how a simulated download progresses and returns
    once the process is complete. The simple `range` keyword is used to avoid handling
    the channel-close condition directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6c5fc5d-bf06-4a58-a9d2-0e3679c54daa.png)'
  prefs: []
  type: TYPE_IMG
- en: Iterating on a channel range
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you need to go beyond the concurrency primitives and handle special
    cases. This is what the standard library `sync` package provides.
  prefs: []
  type: TYPE_NORMAL
- en: The sync package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sync package of Go's standard library provides additional synchronization
    features that aren't included in the language itself. Its additions to concurrency
    management include Mutex, WaitGroup, and Once, which we'll look at briefly.
  prefs: []
  type: TYPE_NORMAL
- en: '`Mutex` is used when you want to ensure mutual exclusion—that is, if you only
    want one goroutine to access a piece of data at a time (to avoid potential conflicts).
    The key methods are `Lock()` and `Unlock()`, which surround the section of code
    that should never be executed concurrently. If a second goroutine attempts to
    enter the section, it will block until the lock is released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a map, `vals`, that we want to share and so
    must ensure thread-safety. We add `sync.Mutex` to guard the access and ensure
    that the lock is obtained before using the map. Note that in the `Get` method,
    we use the `defer` keyword to ensure the code is called as the method exits—this
    avoids needing to access the map, storing the value, and unlocking before then
    returning (making the code neater).
  prefs: []
  type: TYPE_NORMAL
- en: '`WaitGroup` is helpful if you want to create a number of background activities
    and then wait until they all complete. For example, this code snippet creates
    a download method that takes an additional parameter for the group it''s part
    of. Each download instance increments the group counter (`Add(1)`) at the start
    of the download and clears it (`Done()`) at the end. The calling function sets
    up a wait group and then calls `Wait()`, which will return once all downloads
    are complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example, `Once`, is rather self-explanatory—it allows code to be executed
    once only. Invoking its `Do(func())` method will cause the passed function to
    never be called more than once. This is helpful if you''re trying to implement
    a lazy-loading singleton pattern, such as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The full documentation is available at [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/);
    however, it's recommended to use the channel constructs when possible, instead
    of most of these features.
  prefs: []
  type: TYPE_NORMAL
- en: Web services included as standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a modern programming language, Go comes with extensive support for HTTP
    clients, servers, and standard encoding handlers, including JSON and XML. Combined
    with the built-in string and map features, this removes many of the hurdles of
    working with web services. In addition to this, the format for structs in Go allows
    for additional `tags` that can provide metadata to its fields. Both the `encoding/json`
    and `encoding/xml` packages make use of this to understand how to correctly encode
    and decode instances of these structs. The following example demonstrates these
    features by connecting to a web service, accessing a JSON response, and decoding
    it into a struct that is then used like any other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example code you can see the usage of struct tags prefixed
    with `"json:"`. These provide hints to the `"encoding/json"` package that manages
    the encoding and decoding of theses objects. We can run this example and see the
    output of converting a struct into JSON and back again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6562dfc-82fa-4e12-bf6b-74526049f17c.png)'
  prefs: []
  type: TYPE_IMG
- en: Encoding and decoding JSON for an HTTP request
  prefs: []
  type: TYPE_NORMAL
- en: Notice that zero value fields marked with `omitempty` were not included in the
    JSON output, and equally the password field that was marked as `"-"` (meaning
    do not include) was ignored when encoding the data. After downloading the data
    from a test web service, it was marshaled directly into an instance of the `Person`
    struct, leaving missing fields with their zero value. This was all possible using
    built-in features of the language and standard library. It's very straightforward,
    thanks to Go's readiness for working with web services.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing your look and feel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml), *Graphical
    User Interface Challenges*, there are many approaches to graphical applications,
    leaving developers to choose between native versus hybrid (packaged web apps)
    and designers to pick from system look and feel, a multi-platform widget set,
    or even a custom design. The choice you make will probably be impacted by the
    needs of your application and the platforms you aim to target—is performance important
    and do you aim for a cross-platform deployment? Go doesn''t have a standard graphical
    toolkit, and this omission has led developers to think it''s not a language to
    be used for coding GUI applications. However, as we''ve seen in this chapter,
    it''s a great fit for graphical application development. This leads to the question:
    which toolkits are available to build GUI apps in Go?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply put: a lot. You can see a list of the major, currently-maintained toolkits
    online at [https://awesome-go.com/#gui](https://awesome-go.com/#gui)—there is
    probably an option that suits most use cases. As we are looking to build high-performance
    applications that look great, we''ll skip the items that rely on bundling web
    content to create hybrid applications. That still leaves a large list! There are
    some that give direct access to system components for a truly native experience,
    and some that provide abstracted APIs for the same platform look and feel. Others
    provide their own rendering of the user interface, which is consistent on all
    platforms they support (similar to Java Swing''s *Metal* look and feel).'
  prefs: []
  type: TYPE_NORMAL
- en: As well as a great language for GUI development, Go presents us with the opportunity
    to choose the right GUI toolkit for our application. [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits
    Using Existing Widgets* (Chapters [4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    [5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml), [6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml) and
    [7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)), and [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits* (Chapters [8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml),
    [9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml) and [10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml)), 
    introduces developers to each of the main options, and shows how to start building
    beautiful graphical applications with each of them. [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits
    Using Existing Widgets*, is focused on building applications that match the operating
    system's look and feel, and [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits, *is for applications that are going for a more modern look
    that aims to be consistent across multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how the Go language is very well-suited to developing
    graphical applications. Its design for handling concurrency makes the types of
    multithreading needed by GUIs easy to manage. Channels, the main thread-communication
    feature, are a little hard to learn, but through some basic examples, we saw how
    common concurrency issues could easily be avoided. The write-once-compile-anywhere
    ethos of Go means that developers can easily compile the same code and deliver
    native apps across most common platforms from a single codebase using the provided
    tools. As a modern language, it's designed to operate in a connected world and
    its support for network communications and web services is excellent – we ran
    examples that illustrated how objects can be easily transformed to and from common
    web formats.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored the many ways that Go suits graphical application development,
    we also reflected on the many toolkits available to choose from. Despite not having
    a standard user interface, there are many possibilities for building great-looking
    graphical apps with Go. In [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications,* [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml), *andlabs
    UI - Cross-platform Native UIs,* [Chapter 6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml), *Go-GTK
    - Multiple Platforms with GTK,* [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), *Go-Qt
    - Multiple Platforms with Qt* [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    - Experimental Go GUI API* [Chapter 9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml), *nk
    - Nuklear for Go,* and [Chapter 10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml), *Fyne
    - Material Design based GUI,* we'll look at the different toolkits available and
    how to start building your first Go-based GUI. We start by exploring how to build
    traditional user interfaces, beginning with apps for Microsoft Windows in [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications*.
  prefs: []
  type: TYPE_NORMAL
