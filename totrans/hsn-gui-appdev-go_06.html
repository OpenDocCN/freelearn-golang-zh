<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Walk - Building Graphical Windows Applications</h1>
                </header>
            
            <article>
                
<p>Walk i<span>s a Windows GUI toolkit for the Go programming language—its purpose is to enable us to build native desktop GUI applications for Windows using Go. It's built on top of the win package by the same authors, which is a direct Go binding of the Windows API. The main API is designed to make working with the <strong>Windows API</strong> (<strong>WinAPI</strong>) both easier and more in keeping with Go design principles.</span></p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Background and aims</li>
<li>Get started with Walk</li>
<li>Benefits of a declarative API</li>
<li>Building a user interface</li>
<li>Walk in a cross-platform application</li>
</ul>
<p>Let's get started exploring the background of the Walk project and its solution for Go apps developed for the Windows platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background and aims</h1>
                </header>
            
            <article>
                
<p>The Walk project is one of the oldest GUI toolkits for Go, having been started in September of 2010. The name stands for <strong>Windows Application Library Kit</strong>, which reflects its purpose to support building GUI apps for the Microsoft platform. Its project home is on GitHub, where you can check out the latest developments and discussions: <a href="https://github.com/lxn/walk">https://github.com/lxn/walk</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The project API was inspired by the Qt Widgets module for the Qt framework (which will be covered in <a href="68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml">Chapter 7</a>, <em>Go-Qt - Multiple Platforms with QT</em>). Qt Widgets is a selection of standard user interface features for creating graphical applications with a familiar look and feel. By matching the Qt design closely, it's possible to use some of the Qt tools, such as UI designer, when preparing a Walk-based user interface for your application. Walk currently supports the most commonly-utilized widgets, which means it may not be suitable for every application. At the time of writing, the <strong><span>Multi Document </span>Interface</strong> (<strong>MDI</strong>) and dockable tool windows described in <a href="d5375343-5332-4374-9297-dfbb256a5d91.xhtml">Chapter 2</a>, <em>Graphical User Interface Challenges</em> are not supported—though the author notes that it is an open source project and contributions are welcome.</p>
<p>Walk offers a great API for building applications for the Windows desktop. Although it doesn't provide the choice of themes or presentation styles that some toolkits offer, applications that use it look exactly like other Windows apps. <span>One of the project aims is for it to work without any additional dependencies or complicated setup, which means that it's a great place to get started—as you'll see in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Get started with walk</h1>
                </header>
            
            <article>
                
<p>Now that we've learned a bit about the Walk library, let's see it in action. The steps that follow aim to create a trivial application using the Walk API, which will verify everything is working. If you have any problems with these steps, consider looking at the <a href="a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml">Appendix</a>, <span><em>Installation Details,</em></span> and work through the <em>Microsoft Windows</em> section within <em>Installing Go</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setup</h1>
                </header>
            
            <article>
                
<p>Before we can start writing a GUI with Walk, we need to install the library<span>—</span>this means that Go will be able to compile the code we write, and also that any development environments installed will be able to offer suggestions when writing the code. Simply execute <kbd><span>go get github.com/lxn/walk</span></kbd> from the Command Prompt. This command will download and install the Walk library to <kbd>%GOPATH%/src</kbd> so it can be used in your applications. If you have not set the <kbd>GOPATH</kbd> environment variable manually, don't worry, as the Go installer will have set up a default for you (normally <kbd><span>%HOMEDRIVE%%HOMEPATH%</span>/go</kbd>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code</h1>
                </header>
            
            <article>
                
<p>Now let's write some code! First of all, create a new directory to put this code into<span>—</span>due to the way that Walk binaries are created (see the following code), we need to build at a directory level, rather with than single files, so it's good to have a clean workspace. Copy the following code into a file named <kbd>hello.go</kbd>:</p>
<pre>package main<br/><br/>import (<br/>   "github.com/lxn/walk"<br/>   . "github.com/lxn/walk/declarative"<br/>)<br/><br/>func main() {<br/>   MainWindow{<br/>      Title: "Hello",<br/>      Layout: VBox{},<br/>      Children: []Widget{<br/>         Label{Text: "Hello World!"},<br/>         PushButton{<br/>            Text: "Quit",<br/>            OnClicked: func() {<br/>               walk.App().Exit(0)<br/>            },<br/>         },<br/>      },<br/>   }.Run()<br/>}</pre>
<p>In the preceding code, you can see two different imports for Walk<span>—</span>we will talk about that more later. Inside the <kbd>main()</kbd> function, we set up a simple window with two items in a <kbd>VBox</kbd> layout: one <kbd>Label</kbd>, and one <kbd>PushButton</kbd> that will exit the app when clicked. Next, we need to create an additional file, named <kbd>hello.exe.manifest</kbd>, with the following contents (this manifest file is needed in the build process):</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;<br/>&lt;assembly  manifestVersion="1.0" &gt;<br/>   &lt;assemblyIdentity version="1.0.0.0" processorArchitecture="*" name="HelloWorld" type="win32"/&gt;<br/>   &lt;dependency&gt;<br/>      &lt;dependentAssembly&gt;<br/>         &lt;assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"/&gt;<br/>      &lt;/dependentAssembly&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;asmv3:application&gt;<br/>      &lt;asmv3:windowsSettings &gt;<br/>         &lt;dpiAware&gt;true&lt;/dpiAware&gt;<br/>      &lt;/asmv3:windowsSettings&gt;<br/>   &lt;/asmv3:application&gt;<br/>&lt;/assembly&gt;</pre>
<p>This manifest file is required to tell Windows runtime that we are using the Common Controls framework version 6.0.0.0 (or newer), which is required by the Walk APIs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Build</h1>
                </header>
            
            <article>
                
<p>Once you have saved the two files, you can build the application. Due to the nature of a Walk application (specifically, the Windows APIs that are described in the manifest file), there is an additional step to prepare the directory. The walk applications require a manifest file that will be embedded in the executable we are building. To do this, we need to download the rsrc tool from <span><kbd>github.com/akavel/rsrc</kbd>, </span>which will embed the required metadata. We then run the <kbd>rsrc.exe</kbd> command with the <kbd>-manifest</kbd> parameter to generate the embedded file, as follows:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/806392a6-6529-45bb-8b61-9a363c7024c3.png" style="width:42.17em;height:15.50em;" width="618" height="227"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span><span>The rsrc tool generates the .syso file to embed</span></span></div>
<p>That step will create a <kbd>.syso</kbd> file, which will automatically get included in the next step. Now we can actually run the go build. On the command line, we add an extra <kbd>ldflag</kbd> parameter, set to <kbd>"-H windowsgui"</kbd>, which tells the compiler to output a GUI app, rather than a command-line app. While it would work OK without this parameter, your application would show a command-line window behind it when launched from a regular icon-click:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/9f8d266b-e4cc-467c-b5c5-015777942b80.png" style="width:38.08em;height:13.00em;" width="617" height="210"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Running go build again will embed the <kbd>.syso</kbd> file</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Run</h1>
                </header>
            
            <article>
                
<p>The hello world app that was built in the last step can be executed in two ways: either by running it from the command line, or by clicking the icon from the file manager:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/3f5b6e49-6443-4f2e-bf62-e9f5016fed5c.png" style="width:9.50em;height:10.92em;" width="100" height="114"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>The hello app icon</span></div>
<p>You should see an icon like the preceding one in your file manager in the current directory. Alternatively, return to the command prompt and simply enter the <kbd>hello.exe</kbd> command from the project directory. Using either method, you should now see this app running on your desktop (you may need to hunt as it's a very small window):</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/88337cd0-9fa8-46a9-8086-574e4c6f633f.png" style="width:10.08em;height:6.92em;" width="172" height="117"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A Walk-based Hello World</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Benefits of a declarative API</h1>
                </header>
            
            <article>
                
<p>As illustrated in the code example, the Walk API is split in to two notable packages: <kbd>github.com/lxn/walk</kbd> and <kbd>github.com/lxn/walk/declarative</kbd>. The declarative API is the preferred approach for developing application GUIs using Walk, as it offers a better abstraction to work with and is more idiomatic. The implementation of the declarative API also provides various standard metrics and default values that help to create a standard user interface with minimal code. The package is typically imported using the <kbd>.</kbd> prefix, so that GUI code can avoid repeatedly using the <kbd>declarative.</kbd> prefix.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compared with the native API</h1>
                </header>
            
            <article>
                
<p>Using the native API, (Go bindings of the native winAPI) is possible, but in most cases this is more verbose, as you are working directly with a low-level API. Coding in this way can't make use of standard metrics or configurations that are handled by the higher-level declarative API, designed to better suit a modern programming language. To illustrate the difference, here is what the preceding example would look like if we only used the native API:</p>
<pre>package main<br/><br/>import (<br/>   "log"<br/><br/>   "github.com/lxn/walk"<br/>)<br/><br/>var marginSize = 9<br/><br/>func buildWindow() (*walk.MainWindow, error) {<br/>   win, err := walk.NewMainWindowWithName("Hello")<br/>   if err != nil {<br/>      return nil, err<br/>   }<br/>   layout := walk.NewVBoxLayout()<br/>   layout.SetMargins(walk.Margins{marginSize, marginSize, marginSize, marginSize})<br/>   layout.SetSpacing(marginSize)<br/>   win.SetLayout(layout)<br/><br/>   label, err := walk.NewLabel(win)<br/>   if err != nil {<br/>      return win, err<br/>   }<br/>   label.SetText("Hello World!")<br/><br/>   button, err := walk.NewPushButton(win)<br/>   if err != nil {<br/>      return win, err<br/>   }<br/>   button.SetText("Quit")<br/>   button.Clicked().Attach(func() {<br/>      walk.App().Exit(0)<br/>   })<br/><br/>   return win, nil<br/>}<br/><br/>func main() {<br/>   win, err := buildWindow()<br/>   if err != nil {<br/>      log.Fatalln(err)<br/>   }<br/><br/>   win.SetVisible(true)<br/>   win.Run()<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This code can be compiled in the same way as the previous example, and when run, it will look exactly the same. Clearly, this is a lot more code to obtain the same result and it is a lot harder to read with no particular gain. The error handling that clutters this alternative example is handled implicitly when using the declarative API. Putting aside the differences in the Go syntax, it should be clear that the native API calls used in this example are directly manipulating widgets from the WinAPI. In fact, each of the objects created (through <kbd>NewLabel()</kbd>, <kbd>NewPushButton()</kbd>, and <kbd>NewMainWindowWithName()</kbd>) is a lightweight wrapper for Go the bindings of the WinAPI (provided by <kbd>github.com/lxn/win</kbd>).</p>
<p><span>There are many times where usage of this native API can be useful; most commonly, when you need control of fine details or are dealing with changes to existing widgets, for example within event-handling code. The declarative API is designed for easy definition of an application user interface, but it isn't normally enough to manage the workflow of a complex GUI. Therefore, it's common to use both of these APIs together—using the power of each at the right time.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using both APIs for flexibility</h1>
                </header>
            
            <article>
                
<p>It's important to understand the difference between the declarative and native APIs, as any application will probably require the use of both. Using the declarative syntax is great for a concise description of the user interface, but runtime manipulation of the graphical elements will require a reference to one of the native widgets that this code wraps. To make this connection, each of the declarative types has an <kbd>AssignTo</kbd> field, which is typically passed a pointer to a <kbd>var</kbd>, which itself is a pointer to an object that represents a native type. This means that, during the user-interface-construction phase, the declarative API parser can create native widgets and set the pointer within your code for later use. Let's look at this feature in action:</p>
<pre>package main<br/><br/>import (<br/>   "fmt"<br/><br/>   "github.com/lxn/walk"<br/>   . "github.com/lxn/walk/declarative"<br/>)<br/><br/>func main() {<br/>   var message *walk.Label<br/>   var userName *walk.TextEdit<br/><br/>   MainWindow{<br/>      Title: "Hello",<br/>      Layout: VBox{},<br/>      Children: []Widget{<br/>         Label{<br/>            AssignTo: &amp;message,<br/>            Text: "Hello World!",<br/>         },<br/>         TextEdit{<br/>            AssignTo: &amp;userName,<br/>            OnTextChanged: func() {<br/>               welcome := fmt.Sprintf("Hello %s!", userName.Text())<br/>               message.SetText(welcome)<br/>            },<br/>         },<br/>         PushButton{<br/>            Text: "Quit",<br/>            OnClicked: func() {<br/>               walk.App().Exit(0)<br/>            },<br/>         },<br/>      },<br/>   }.Run()<br/>}</pre>
<p>The preceding code can be compiled exactly as the previous <em>hello world</em> examples (don't forget to include and process a manifest if you have created a new project for this sample). When running this example, you should see the following interface with an additional text input field. When you type into the input box, the welcome message will change, for example <kbd>John Doe</kbd> was entered for this screenshot:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/316b3d6d-9e48-4ad9-88c5-7a9f81bbe9cf.png" style="width:8.50em;height:7.83em;" width="169" height="154"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">The hello world with name entry</div>
<p>You will notice that the <kbd>message</kbd> and <kbd>userName</kbd> variables are not initialized directly by the application code, but by the time the function assigned to <kbd>OnTextChanged</kbd> is called, they hold valid references to instantiated widgets. Using this approach, we can get the type of access that the native API wrappers provide while also writing an easy-to-read UI definition provided by the declarative API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a user interface</h1>
                </header>
            
            <article>
                
<p>Armed with the knowledge of how the Walk API is designed and utilized, let's move on to a real-world example. In this book, we will be building the same user interface for each toolkit explored (in Chapters <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml"/><a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">4</a>, <a href="4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml">5</a>, <a href="6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml">6</a>, <a href="68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml">7</a>, <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">8</a>, <a href="48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml">9</a>, and <a href="2476a1b6-0915-496b-8290-7a673f533aca.xhtml">10</a>), which will be a simple email application named GoMail. Due to the close relationship between Walk and Qt widgets, we can quickly get started designing the user interface using the UI Builder included in Qt Creator (documentation is available at <a href="http://doc.qt.io/qtcreator/creator-using-qt-designer.html">http://doc.qt.io/qtcreator/creator-using-qt-designer.html</a>).</p>
<p>The basic application will be formed of two windows: the main email browser and a secondary window for composing new emails. The main window will contain a list or tree view that shows the emails we have received, a larger panel to display the content of the currently-selected email, and a menu and toolbar for accessing the various features of our email application:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4a56d7ac-9caa-43f3-a214-08c19f1ffa2b.png" width="717" height="308"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The main email window within Qt Designer</div>
<p>To compose new emails, we will show a secondary window that will ask for the various details for the email being sent. Opening a new window will allow the user to continue reading emails while they compose new emails to be sent. The compose window will also have buttons to send or discard the email being written:</p>
<p class="mce-root"/>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/6d06edc7-b37e-4aa0-91b2-1d56d4b81f16.png" style="width:30.92em;height:24.92em;" width="412" height="332"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The additional compose window being designed</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Style</h1>
                </header>
            
            <article>
                
<p>Applications built using Walk are composed of native Windows components, and, as such, the style is set by the implementation provided by Microsoft (this is provided by Common Controls, part of <kbd>ComCtl32.dll</kbd>). The version required by Walk (version 6.0) adds support for visual styles; this is the system that provides the ability for applications to use the correct visual style for the version of the Windows desktop that is currently running.</p>
<p>This functionality is available as far back as Windows XP, but comes as standard from Vista onward:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/314919e2-6f34-4990-8ed3-843a13378f2b.png" style="width:15.33em;height:8.92em;" width="243" height="142"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Windows 7 default theme (Aero –used with permission from Microsoft)</div>
<div class="CDPAlignCenter CDPAlign"><img src="Images/92e81544-3c7f-40bd-81ad-145cd166d9bc.png" style="width:13.83em;height:9.92em;" width="219" height="157"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Windows 8 default theme (called Windows used with permission from Microsoft)</div>
<p>The preceding images show how a simple application will adapt to the theme on different versions of Windows. These illustrations are using the default theme, but the user may apply additional customizations on their desktop, which will also apply to any applications built with Walk.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>Walk layouts (like those Qt Widget layouts they were inspired by) are based on a limited number of grid-based variants. The list of implemented layouts includes the following:</p>
<ul>
<li><kbd>GridLayout</kbd>: Items are laid out in a regular grid</li>
<li><kbd>VBoxLayout</kbd>: Items are placed in a single column</li>
<li><kbd>HBoxLayout</kbd>: Items are aligned in a single row</li>
</ul>
<p>If you have explored the Qt UI Builder or are familiar with Qt, you may be expecting a fourth layout, <kbd>FormLayout</kbd>, which is not currently present in Walk. This can be simulated, however, using a two-column <kbd>GridLayout</kbd> and applying alignment properties as required.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In addition to the standard layouts, there are various widgets (some of which are invisible in the final interface) that help group UI elements and provide a more satisfying layout. The most commonly used of these are as follows:</p>
<ul>
<li><span><kbd>Splitter</kbd></span>: Places a draggable split bar between two child widgets</li>
<li><span><kbd>Spacer</kbd></span>: Used to create visual padding so items can shrink instead of filling space</li>
<li><span><kbd>Separator</kbd></span>: Provides a visual separation between widgets, such as in a toolbar or menu</li>
<li><span><kbd>ScrollView</kbd></span>: A standard widget for providing scrollable content</li>
<li><span><kbd>GroupBox</kbd></span>: A visual widget container with a border and optional title</li>
<li><span><kbd>Composite</kbd>: A widget container used to logically group items</span></li>
</ul>
<p>Let's get started implementing our email app user interface by creating some Go code using the declarative API. We start with a <kbd>MainWindow</kbd> that has a suitable <kbd>MinSize</kbd> set and an <kbd>HSplitter</kbd> that will hold our content. <kbd>TreeView</kbd> is used for listing emails on the left of the splitter (as the first item in the <kbd>Children</kbd> list), and on the right (item two in the list) is a <kbd><span><span>Composite</span></span></kbd> set to use a <kbd>Grid</kbd> layout—the closest we have to the form layout designed. Within the group, we add many instances of the child <kbd>Label</kbd> where we will show email details (that will be updated in <em>Communicating with the GUI</em> section):</p>
<pre>MainWindow{<br/>   Title:   <span>"GoMail"</span>,<br/>   Layout:  HBox{},<br/>   MinSize: Size{<span>600</span>, <span>400</span>},<br/>   Children: []Widget{<br/>      HSplitter{<br/>         Children: []Widget{<br/>            TreeView{},<br/>            Composite{<br/>               Layout: Grid{Columns: <span>3</span>},<br/>               Children: []Widget{<br/>                  Label{<br/>                     Text:       <span>"subject"</span>,<br/>                     Font:       Font{Bold: <span>true</span>},<br/>                     ColumnSpan: <span>3</span>,<br/>                  },<br/>                  Label{<br/>                     Text: <span>"From"</span>,<br/>                     Font: Font{Bold: <span>true</span>},<br/>                  },<br/>                  Label{<br/>                     Text:       <span>"email"</span>,<br/>                     ColumnSpan: <span>2</span>,<br/>                  },<br/>                  Label{<br/>                     Text: <span>"To"</span>,<br/>                     Font: Font{Bold: <span>true</span>},<br/>                  },<br/>                  Label{<br/>                     Text:       <span>"email"</span>,<br/>                     ColumnSpan: <span>2</span>,<br/>                  },<br/>                  Label{<br/>                     Text: <span>"Date"</span>,<br/>                     Font: Font{Bold: <span>true</span>},<br/>                  },<br/>                  Label{<br/>                     Text:       <span>"email"</span>,<br/>                     ColumnSpan: <span>2</span>,<br/>                  },<br/>                  TextEdit{<br/>                     Text:       <span>"email content"</span>,<br/>                     ReadOnly:   <span>true</span>,<br/>                     ColumnSpan: <span>3</span>,<br/>                  },<br/>               },<br/>            },<br/>         },<br/>      },<br/>   },<br/>}</pre>
<p>The preceding code can be run by replacing the <kbd>MainWindow</kbd> in the previous <em>hello world</em> example, recompiling, and then running the example again. If you set up a new project, remember to include the manifest file and run <kbd>rsrc</kbd> again! When run, it should look like the following screenshot, taken on Windows 10:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/1d169ecc-273f-4863-9dc5-a58073df514c.png" style="width:28.92em;height:12.58em;" width="570" height="248"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The basic email interface using Walk's declarative API</div>
<p>Next, we will make a <kbd>Dialog</kbd> with a similar layout that replaces the instances of <kbd>Label</kbd> with <kbd>LineEdit</kbd> or <kbd>TextEdit</kbd> for entering details of a new email. Last, we add another <span><span><kbd>Composite</kbd></span></span> with an <kbd>HBox</kbd> layout that contains the instances of <kbd>PushButton</kbd> for <kbd>Cancel</kbd> and <kbd>Send</kbd>, along with an <kbd>HSpacer</kbd> to complete the layout:</p>
<pre>Dialog{<br/>   Title:   <span>"New GoMail"</span>,<br/>   Layout:  Grid{Columns: 3},<br/>   MinSize: Size{<span>400</span>, <span>320</span>},<br/>   Children: []Widget{<br/>      Composite{<br/>         Layout: Grid{Columns: <span>3</span>},<br/>         Children: []Widget{<br/>            LineEdit{<br/>               Text:       <span>"subject"</span>,<br/>               Font:       Font{Bold: <span>true</span>},<br/>               ColumnSpan: <span>3</span>,<br/>            },<br/>            Label{<br/>               Text: <span>"To"</span>,<br/>               Font: Font{Bold: <span>true</span>},<br/>            },<br/>            LineEdit{<br/>               Text:       <span>"email"</span>,<br/>               ColumnSpan: <span>2</span>,<br/>            },<br/>            TextEdit{<br/>               Text:       <span>"email content"</span>,<br/>               ColumnSpan: <span>3</span>,<br/>            },<br/>            Composite{<br/>               Layout:     HBox{},<br/>               ColumnSpan: <span>3</span>,<br/>               Children: []Widget{<br/>                  HSpacer{},<br/>                  PushButton{Text: <span>"Cancel"</span>},<br/>                  PushButton{Text: <span>"Send"</span>},<br/>               },<br/>            },<br/>   },<br/>}</pre>
<p>If you want to test this code, the easiest approach is to replace <kbd>Dialog</kbd> with <kbd>MainWindow</kbd> and run it like the main layout (don't forget to change it back before moving on).</p>
<p>Once we have some event-handling, this will open like a dialog box, which is why it's not a <kbd>MainWindow</kbd> in the preceding listing. Running the code should produce the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/113d56b1-49c2-425f-9af6-9cf2a935bc33.png" style="width:21.75em;height:13.67em;" width="373" height="233"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The compose email view using Walk's declarative API</div>
<p>That's all that's required to complete the layout code of the main interface features. Next, let's add the menu, toolbar, and set up actions for the buttons we have defined.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Toolbar and menu</h1>
                </header>
            
            <article>
                
<p>Adding menus and toolbars with the declarative API is very straightforward. The <kbd>MainWindow</kbd> struct has the <kbd>Menu</kbd> field (which is a slice of <kbd>MenuItem</kbd>) and the <kbd>ToolBar</kbd> field (which takes a <kbd>ToolBar</kbd> struct that contains an <kbd>Items</kbd> field for the <kbd>MenuItem</kbd> list). Each item in the list is either an <kbd>Action</kbd>, a <kbd>Separator</kbd>, or another <kbd>Menu</kbd> that mirrors the designs we created earlier.</p>
<p>Each <kbd>Action</kbd> in the declarative API expects a <kbd>Text</kbd> string that is used for the display in menus. Toolbars also use this content for tooltips, and for display if the style is set to <kbd>ToolBarButtonTextOnly</kbd>. An <kbd>Image</kbd> field allows you to set an icon for the toolbars if you want to reference installed images or icons distributed with your app. Most important is the <kbd>OnTriggered</kbd> field, which should be set to a <kbd>func()</kbd> that will be executed when the button or menu item is clicked.</p>
<p>The following code is used set up the menu on the <kbd>MainWindow</kbd> we created in the <em>Layout</em> section:</p>
<pre>MenuItems: []MenuItem{<br/>   Menu{<br/>      Text: <span>"File"</span>,<br/>      Items: []MenuItem{<br/>         Action{<br/>            Text: <span>"New"</span>,<br/>         },<br/>         Action{<br/>            Text: <span>"Reply"</span>,<br/>         },<br/>         Action{<br/>            Text: <span>"Reply All"</span>,<br/>         },<br/>         Separator{},<br/>         Action{<br/>            Text: <span>"Delete"</span>,<br/>         },<br/>         Separator{},<br/>         Action{<br/>            Text: <span>"Quit"</span>,<br/>         },<br/>      },<br/>   },<br/>   Menu{<br/>      Text:  <span>"Edit"</span>,<br/>      Items: []MenuItem{<br/>         Action{<br/>            Text: <span>"Cut"</span><span>,<br/></span>         },<br/>         Action{<br/>            Text: <span>"Copy"</span>,<br/>         },<br/>         Action{<br/>            Text: <span>"Paste"</span>,<br/>         },<br/>      },<br/>   },<br/>   Menu{<br/>      Text: <span>"Help"</span>,<br/>   },<br/>},</pre>
<p>The code for the toolbar is almost identical and so the details have been omitted, but you can add it to the <kbd>MainWindow</kbd> using the <kbd>ToolBar</kbd> field, as follows:</p>
<pre>ToolBar: ToolBar{<br/>   Items: []MenuItem{<br/>      Action{<br/>         Text: <span>"New"</span>,<br/>      },<br/><br/>// full listing omitted but is available in the book's example code<br/><br/>   },<br/>   ButtonStyle: <span>ToolBarButtonTextOnly</span>,<br/>},</pre>
<p>The result of the code added should be a window like <span>that in </span>the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/a0b8777c-59a4-47a7-8e09-d54caa1692af.png" style="width:34.92em;height:15.58em;" width="674" height="301"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The main email interface with the menu and toolbar added</div>
<p><span>Don't worry if the code for the new button didn't work for you—the completed application source code is available to download at </span><a href="https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go">https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go</a><span>. </span>Before the user interface code is completed, we should add some code that will help us to navigate the app. The simplest is the quit item from the file menu. Just add the following code to the preceding <kbd>Quit</kbd> action:</p>
<pre>OnTriggered: <span>func</span>() {<br/>   walk.App().Exit(<span>0</span>)<br/>},</pre>
<p>The opening of our compose dialog is a little more complicated because a dialog needs to know which parent it's loading from. To do this, create a local variable, called <kbd>window</kbd>, of the <kbd>*walk.MainWindow</kbd> type and assign it to the <kbd>MainWindow</kbd> declarative API using the following line:</p>
<pre>AssignTo:  &amp;window,</pre>
<p>This can then be referenced in your <kbd>New</kbd> action handler, where <kbd>NewCompose</kbd> is a function that creates the email compose window:</p>
<pre>OnTriggered: <span>func</span>() {<br/>   <span>NewCompose().Run</span>(window)<br/>},</pre>
<p>Finally, we should set up default behavior for the buttons on our compose dialog. To do this, we need to declare two <kbd>*walk.PushButton</kbd> variables that are assigned to the <kbd>Cancel</kbd> and <kbd>Send</kbd> buttons, respectively. By then passing these to the dialog definition using the <kbd>CancelButton</kbd> and <kbd>DefaultButton</kbd> fields, we get the appropriate behavior:</p>
<pre>DefaultButton: &amp;send,<br/>CancelButton:  &amp;cancel,</pre>
<p>Now, let's set the cancel button to close the dialog—you will need to create a <kbd>walk.Dialog</kbd> variable to <kbd>AssignTo</kbd> the declarative API as with the main window. With these steps complete, either <span><span>clicking </span></span>the <span class="packt_screen">cancel</span> button or pressing the <em>Esc</em> key should dismiss the compose window:</p>
<pre>OnClicked: <span>func</span>() {<br/>   dialog.Cancel()<br/>},</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating with the GUI</h1>
                </header>
            
            <article>
                
<p>To populate the user interface, we need to <span>define a data model and </span>load some test data. Within the code for this book, there is a client package that contains a data model and some test data to simulate an email server. We will use that package by importing it into the Go files for this project using the <kbd>github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client</kbd> package. We won't cover the details of the package in this chapter, but we will reference its defined <kbd>client.EmailServer</kbd> and <kbd>client.EmailMessage</kbd> types. The email message definition is as follows—the field names will be useful when loading email details in the UI:</p>
<pre>type EmailMessage struct {<br/>   Subject, Content string<br/>   To, From         Email<br/>   Date             time.Time<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">View model</h1>
                </header>
            
            <article>
                
<p>To communicate with the Walk user interface, we need to define another data model. This view model is designed to communicate information in a way that the declarative API understands. We will create a type named <kbd>EmailClientModel</kbd>, which will handle translating data from our client code to our user interface definition. Create a new file, <kbd>model.go</kbd>, where you can start to define these models. The first section of the code allows an email server to be set causing the email list to update accordingly.</p>
<p>For brevity, the trivial methods for <kbd>walk.TreeModel</kbd> have been left out—you can find them in the full code listing for this book:</p>
<pre><span>type </span>EmailClientModel <span>struct </span>{<br/>   Server *client.EmailServer<br/><br/>   root walk.TreeItem<br/><br/>   itemsResetPublisher  walk.TreeItemEventPublisher<br/>   itemChangedPublisher walk.TreeItemEventPublisher<br/>}<br/><br/>// TreeModel methods omitted - see full code listing<br/><br/><span>func </span>(e *EmailClientModel) SetServer(s *client.EmailServer) {<br/>   e.Server = s<br/><br/>   e.root = NewInboxList(s.ListMessages())<br/>   e.itemsResetPublisher.Publish(e.root)<br/>}<br/><br/><span>func </span>NewEmailClientModel() *EmailClientModel{<br/>   <span>return </span>&amp;EmailClientModel{}<br/>}</pre>
<p><span>The email list for this model needs to represent our email list as items in a tree, rather than a simple list as returned by the client code. To support this we need another type, </span><kbd>EmailModel</kbd>, that implements the <kbd>walk.TreeItem</kbd> interface. Here, again, we have omitted the trivial details—each email item will never contain child elements and so we can ignore this complexity:</p>
<pre><span>type </span>EmailModel <span>struct </span>{<br/>   email  *client.EmailMessage<br/>   parent walk.TreeItem<br/>}<br/><br/>// TreeItem functions omitted - see full code listing</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We want to group our emails under an <kbd>Inbox</kbd> heading, so we need to build the root node and then populate the email list within it. For this, we define one more type, <kbd>InboxList</kbd>, which also implements <kbd>walk.TreeItem</kbd>, but this time it will allow access to the child list (emails) it holds. We will also need to write a method for building the inbox list from a list of messages (which we would be provided by the client code). See how the final method in this code snippet creates instances of <kbd>EmailModel</kbd> for each message and adds them to the inbox list:</p>
<pre><span>type </span>InboxList <span>struct </span>{<br/>   emails []walk.TreeItem<br/>}<br/><br/><span>func </span>(i *InboxList) Text() string {<br/>   <span>return </span><span>"Inbox"<br/></span>}<br/><br/><span>func </span>NewInboxList(l []*client.EmailMessage) *InboxList {<br/>   list := &amp;InboxList{}<br/><br/>   <span>for </span>_, item := <span>range </span>l {<br/>      list.emails = append(list.emails, &amp;EmailModel{item, list})<br/>   }<br/><br/>   <span>return </span>list<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Detail view</h1>
                </header>
            
            <article>
                
<p>Now that we have a data model built, let's display the data that's loaded. Starting with the email detail view, we will make use of Walk's declarative API, <kbd>DataBinder</kbd>. This allows us to avoid having to manually set the data on each label every time a new message is loaded. To work correctly, we also need to create a <kbd>walk.DataBinder</kbd> to assign to—this will handle the actual bindings:</p>
<pre><span>emailDetail *walk.DataBinder</span></pre>
<p>Then we can update the <kbd>Composite</kbd> widget that displays the email information to use this data binding. Let's also set the default content through the <kbd>DataSource</kbd> field. This information will come from the model, which we will initialize shortly:</p>
<pre><span>DataBinder: DataBinder{</span><br/><span>   AssignTo: &amp;emailDetail,</span><br/><span>   DataSource: model.Server.CurrentMessage(),</span><br/><span>},</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Then, each item simply has its static <kbd>Text</kbd> field changed to an appropriate <kbd>Bind()</kbd> call; the parameter will be the name of the field on an <kbd>client.EmailMessage</kbd> type described in the <em>View model</em> <span>section:</span></p>
<pre>Text:       Bind(<span>"Subject"</span>),</pre>
<p>For the <kbd>Date</kbd> field, we can't directly bind a <kbd>time.Time</kbd> type, so use the <kbd>DateString()</kbd> helper instead:</p>
<pre>Text:       Bind(<span>"DateString"</span>),</pre>
<p>And finally, let's create a helper method that will allow us to update the email message that is currently bound:</p>
<pre><span>func </span>(g *GoMailUIBrowse) SetMessage(email *client.EmailMessage) {<br/>   g.emailDetail.SetDataSource(email)<br/>   g.emailDetail.Reset()<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">List view</h1>
                </header>
            
            <article>
                
<p><span>Most of the work for our email list was done in the preceding model code—now we need to connect it to the user interface. The following code sets up a <kbd>walk.TreeView</kbd> class that we use to keep track of the current item and assigns it to the declarative <kbd>TreeView</kbd>. After that, the model is set and then we pass a function that will be informed when the current item changes:</span></p>
<pre>emailList *walk.TreeView<br/><br/>TreeView{<br/>   AssignTo: &amp;g.emailList,<br/>   Model: model,<br/>   OnCurrentItemChanged: <span>func</span>() {<br/>      item := g.emailList.CurrentItem()<br/><br/>      <span>if </span>email, ok := item.(*EmailModel); ok {<br/>         g.SetMessage(email.email)<br/>      }<br/>   },<br/>},</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>With all that in place, the application will load the email details from the current email message using <kbd>model.Server.CurrentMessage()</kbd> via the default <kbd>DataSource</kbd> of the <kbd>DataBinder</kbd>. When the main list is clicked, the function passed to <kbd>OnCurrentItemChanged</kbd> checks that the item is an <kbd>EmailModel</kbd> and, if so, updates the detail view. Finally, we need to set up the model that will be used in the preceding code, as follows:</span></p>
<pre>model := NewEmailClientModel()<br/>model.SetServer(client.NewTestServer())</pre>
<p><span>This model is used to set the list content and also to set the default content of the detail view. When built and run, the application should now look like a complete, albeit basic, email client:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/e9a2ab00-3882-451f-b633-103bca097548.png" style="width:34.33em;height:15.25em;" width="715" height="317"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Our email interface with some test data loaded</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background processing</h1>
                </header>
            
            <article>
                
<p>All user interface code with Walk must run on the main thread; this is a constraint of the winAPI that handles the widgets. This means that any work in the background must change threads before running any UI code. This is done using the <kbd>Synchronize()</kbd> function on <kbd>walk.Window</kbd>. It takes a single function as a parameter and ensures that the code it contains will be run appropriately.</p>
<p class="mce-root"/>
<p>To handle the updating when an incoming email arrives, we create a new function, <kbd>incomingEmail()</kbd>, that will update our email list model. This function will cause an email to be added to the model, which will happen on the main thread so that the user interface can be updated to reflect the new data:</p>
<pre>func (g *GoMailUIBrowse) incomingEmail(email *client.EmailMessage, model *EmailClientModel) {<br/>   g.window.Synchronize(func() {<br/>      model.AddEmail(email)<br/>   })<br/>}</pre>
<p>To support this change, we need to update <kbd>EmailClientModel</kbd> to add this new <kbd>AddEmail()</kbd> function. The function will add an item to the list and publish the data-reset event:</p>
<pre>func (e *EmailClientModel) AddEmail(email *client.EmailMessage) {<br/>   e.root.Add(email)<br/>   e.itemsResetPublisher.Publish(e.root)<br/>}</pre>
<p>This, in turn, needs an <kbd>Add()</kbd> function in the <kbd>InboxList</kbd> type that we created to provide data to the model:</p>
<pre>func (i *InboxList) Add(email *client.EmailMessage) {<br/>   i.emails = append(i.emails, &amp;EmailModel{email, i})<br/>}</pre>
<p>Finally, we need to listen to the <kbd>Incoming()</kbd> server channel, which will deliver each new email to our application. As this channel read will block until an email is received, this must run in a separate goroutine—hence the background processing. When an email arrives, we simply call the function we just created, passing the new <kbd>email</kbd> and a reference to the <kbd>model</kbd> which we should refresh:</p>
<pre>server := client.NewTestServer()<br/>model.SetServer(server)<br/><br/>go func() {<br/>   incoming := server.Incoming()<br/>   for email = range incoming {<br/>      g.incomingEmail(email, model)<br/>   }<br/>}()</pre>
<p>With this code in place, you will see the email list update when a new email arrives. The email can then be clicked to see the details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Walk in a cross-platform application</h1>
                </header>
            
            <article>
                
<p>Walk is clearly a library aimed at creating graphical user interfaces for the Microsoft Windows platform—but this doesn't mean that building your application with Walk limits you to Windows only. Using the techniques explored in <a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml">Chapter 3</a>, <em>Go to the Rescue!</em>, we can set the code for Windows to be conditionally included when building for the platform, and introduce other files that could provide a user interface for other platforms.</p>
<p>The first step is to update the files we have built so far to only build on Windows. We do this using the build constraints comment format (you could also use file naming for this step if you wish):</p>
<pre><span>// </span><span>+build</span><span> windows<br/></span><span><br/></span><span>package </span>main<br/><br/>...</pre>
<p>We then introduce a new file that will handle the fallback case when we're on a different platform. For this simple project we will call it <kbd>nonwindows.go</kbd> as the content will run for any computer not running Windows. In this file, we place a small amount of code that will print a failure message and quit if the application is launched on any unsupported platform. Note that the build constraint here is set to compile on any non-Windows platform; this too would be updated to match any fallback cases your project may have:</p>
<pre><span>// </span><span>+build</span><span> !windows<br/></span><span><br/></span><span>package </span>main<br/><br/><span>import </span><span>"log"<br/></span><span><br/></span><span>func </span>NewMailUIBrowse() {<br/>   log.Fatalln(<span>"GoMail with Walk only works on windows"</span>)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Note the <kbd>NewMailUIBrowse()</kbd> function name—this is our generic method name for loading and running the main GoMail browse interface. You probably need to update the name of the method that was previously used to run the application. Most likely, you used <kbd>main()</kbd>, but we will need to provide a new <kbd>main.go</kbd> with that method. This new file is the only file in the project with no build constraints. It will compile for any platform and, when running, it will execute whichever <kbd>NewMailUIBrowse()</kbd> method was compiled in for the target platform:</p>
<pre><span>package </span>main<br/><br/><span>func </span>main() {<br/>   NewMailUIBrowse()<br/>}</pre>
<p>If we switch to another operating system, say macOS, and compile the code now, there should be no compile errors. Running the application will yield a simple error message and it will immediately quit. Clearly this code could do something more meaningful than just exiting with an error message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a1ee956a-b0c8-41e8-8c67-4178b61a6ff1.png" style="width:35.92em;height:9.33em;" width="489" height="127"/></p>
<p>And so you see how we can use Walk to develop a Windows-specific user interface. As part of a multi-platform strategy, this could help ensure greater platform integration for your audience on Windows, or you may wish to provide certain sections of your application with platform-specific implementations. Whatever the reason, you can see how easy it is to include multiple platform-specific alternatives within a cross-platform application build with Go.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started the exploration of GUI toolkits by first looking at the Walk API for Windows' graphical application development. We looked at how to get a Go-based Windows application running, and learned how the Walk project is structured into separate declarative and native APIs. We also saw how each of these APIs provides different benefits and how they are best combined to create a simple application.</p>
<p>As the Walk design was heavily inspired by the Qt project (which we will return to in <a href="68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml">Chapter 7</a>, <em>Go-Qt - Multiple Platforms with Qt</em>), we were able to use the interface-designer features of Qt Creator to mock up a basic email application that we then built out using the declarative API. This email application is a design that can be reused for each of the toolkit-exploration chapters. To support the example applications, we imported another package that is provided in this book's source code, which provides some data models and test data. By combining our UI code, the email client library, and the data binding capabilities of the Walk toolkit, we were able to create a simple email application that would run natively on the Windows platform using the system-provided widgets. Through some small alterations, it was shown that this could be part of a wider cross-platform strategy where each platform's graphical presentation is provided by different toolkits.</p>
<p>In the next chapter, we will move our focus to code that provides a native look and feel across multiple platforms. We will be looking specifically at andlabs UI—a GUI toolkit that aims to provide a look and feel that matches the current operating system. If used on Windows, this will be similar to Walk, but it also adapts to different desktop platforms while only needing to write the user-interface code once.</p>


            </article>

            
        </section>
    </div>



  </body></html>