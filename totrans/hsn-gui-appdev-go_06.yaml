- en: Walk - Building Graphical Windows Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Walk is a Windows GUI toolkit for the Go programming language—its purpose is
    to enable us to build native desktop GUI applications for Windows using Go. It's
    built on top of the win package by the same authors, which is a direct Go binding
    of the Windows API. The main API is designed to make working with the **Windows
    API** (**WinAPI**) both easier and more in keeping with Go design principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Background and aims
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get started with Walk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of a declarative API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walk in a cross-platform application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started exploring the background of the Walk project and its solution
    for Go apps developed for the Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: Background and aims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Walk project is one of the oldest GUI toolkits for Go, having been started
    in September of 2010\. The name stands for **Windows Application Library Kit**,
    which reflects its purpose to support building GUI apps for the Microsoft platform.
    Its project home is on GitHub, where you can check out the latest developments
    and discussions: [https://github.com/lxn/walk](https://github.com/lxn/walk).
  prefs: []
  type: TYPE_NORMAL
- en: The project API was inspired by the Qt Widgets module for the Qt framework (which
    will be covered in [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), *Go-Qt
    - Multiple Platforms with QT*). Qt Widgets is a selection of standard user interface
    features for creating graphical applications with a familiar look and feel. By
    matching the Qt design closely, it's possible to use some of the Qt tools, such
    as UI designer, when preparing a Walk-based user interface for your application.
    Walk currently supports the most commonly-utilized widgets, which means it may
    not be suitable for every application. At the time of writing, the **Multi Document Interface**
    (**MDI**) and dockable tool windows described in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml),
    *Graphical User Interface Challenges* are not supported—though the author notes
    that it is an open source project and contributions are welcome.
  prefs: []
  type: TYPE_NORMAL
- en: Walk offers a great API for building applications for the Windows desktop. Although
    it doesn't provide the choice of themes or presentation styles that some toolkits
    offer, applications that use it look exactly like other Windows apps. One of the
    project aims is for it to work without any additional dependencies or complicated
    setup, which means that it's a great place to get started—as you'll see in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Get started with walk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned a bit about the Walk library, let's see it in action.
    The steps that follow aim to create a trivial application using the Walk API,
    which will verify everything is working. If you have any problems with these steps,
    consider looking at the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml), *Installation
    Details,* and work through the *Microsoft Windows* section within *Installing
    Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start writing a GUI with Walk, we need to install the library—this
    means that Go will be able to compile the code we write, and also that any development
    environments installed will be able to offer suggestions when writing the code.
    Simply execute `go get github.com/lxn/walk` from the Command Prompt. This command
    will download and install the Walk library to `%GOPATH%/src` so it can be used
    in your applications. If you have not set the `GOPATH` environment variable manually,
    don't worry, as the Go installer will have set up a default for you (normally `%HOMEDRIVE%%HOMEPATH%/go`).
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s write some code! First of all, create a new directory to put this
    code into—due to the way that Walk binaries are created (see the following code),
    we need to build at a directory level, rather with than single files, so it''s
    good to have a clean workspace. Copy the following code into a file named `hello.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, you can see two different imports for Walk—we will talk
    about that more later. Inside the `main()` function, we set up a simple window
    with two items in a `VBox` layout: one `Label`, and one `PushButton` that will
    exit the app when clicked. Next, we need to create an additional file, named `hello.exe.manifest`,
    with the following contents (this manifest file is needed in the build process):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This manifest file is required to tell Windows runtime that we are using the
    Common Controls framework version 6.0.0.0 (or newer), which is required by the
    Walk APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have saved the two files, you can build the application. Due to the
    nature of a Walk application (specifically, the Windows APIs that are described
    in the manifest file), there is an additional step to prepare the directory. The
    walk applications require a manifest file that will be embedded in the executable
    we are building. To do this, we need to download the rsrc tool from `github.com/akavel/rsrc`, which
    will embed the required metadata. We then run the `rsrc.exe` command with the
    `-manifest` parameter to generate the embedded file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/806392a6-6529-45bb-8b61-9a363c7024c3.png)'
  prefs: []
  type: TYPE_IMG
- en: The rsrc tool generates the .syso file to embed
  prefs: []
  type: TYPE_NORMAL
- en: 'That step will create a `.syso` file, which will automatically get included
    in the next step. Now we can actually run the go build. On the command line, we
    add an extra `ldflag` parameter, set to `"-H windowsgui"`, which tells the compiler
    to output a GUI app, rather than a command-line app. While it would work OK without
    this parameter, your application would show a command-line window behind it when
    launched from a regular icon-click:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f8d266b-e4cc-467c-b5c5-015777942b80.png)'
  prefs: []
  type: TYPE_IMG
- en: Running go build again will embed the `.syso` file
  prefs: []
  type: TYPE_NORMAL
- en: Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hello world app that was built in the last step can be executed in two
    ways: either by running it from the command line, or by clicking the icon from
    the file manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f5b6e49-6443-4f2e-bf62-e9f5016fed5c.png)'
  prefs: []
  type: TYPE_IMG
- en: The hello app icon
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see an icon like the preceding one in your file manager in the current
    directory. Alternatively, return to the command prompt and simply enter the `hello.exe` command
    from the project directory. Using either method, you should now see this app running
    on your desktop (you may need to hunt as it''s a very small window):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88337cd0-9fa8-46a9-8086-574e4c6f633f.png)'
  prefs: []
  type: TYPE_IMG
- en: A Walk-based Hello World
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of a declarative API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As illustrated in the code example, the Walk API is split in to two notable
    packages: `github.com/lxn/walk` and `github.com/lxn/walk/declarative`. The declarative
    API is the preferred approach for developing application GUIs using Walk, as it
    offers a better abstraction to work with and is more idiomatic. The implementation
    of the declarative API also provides various standard metrics and default values
    that help to create a standard user interface with minimal code. The package is
    typically imported using the `.` prefix, so that GUI code can avoid repeatedly
    using the `declarative.` prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: Compared with the native API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the native API, (Go bindings of the native winAPI) is possible, but in
    most cases this is more verbose, as you are working directly with a low-level
    API. Coding in this way can''t make use of standard metrics or configurations
    that are handled by the higher-level declarative API, designed to better suit
    a modern programming language. To illustrate the difference, here is what the
    preceding example would look like if we only used the native API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code can be compiled in the same way as the previous example, and when
    run, it will look exactly the same. Clearly, this is a lot more code to obtain
    the same result and it is a lot harder to read with no particular gain. The error
    handling that clutters this alternative example is handled implicitly when using
    the declarative API. Putting aside the differences in the Go syntax, it should
    be clear that the native API calls used in this example are directly manipulating
    widgets from the WinAPI. In fact, each of the objects created (through `NewLabel()`,
    `NewPushButton()`, and `NewMainWindowWithName()`) is a lightweight wrapper for
    Go the bindings of the WinAPI (provided by `github.com/lxn/win`).
  prefs: []
  type: TYPE_NORMAL
- en: There are many times where usage of this native API can be useful; most commonly,
    when you need control of fine details or are dealing with changes to existing
    widgets, for example within event-handling code. The declarative API is designed
    for easy definition of an application user interface, but it isn't normally enough
    to manage the workflow of a complex GUI. Therefore, it's common to use both of
    these APIs together—using the power of each at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: Using both APIs for flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s important to understand the difference between the declarative and native
    APIs, as any application will probably require the use of both. Using the declarative
    syntax is great for a concise description of the user interface, but runtime manipulation
    of the graphical elements will require a reference to one of the native widgets
    that this code wraps. To make this connection, each of the declarative types has
    an `AssignTo` field, which is typically passed a pointer to a `var`, which itself
    is a pointer to an object that represents a native type. This means that, during
    the user-interface-construction phase, the declarative API parser can create native
    widgets and set the pointer within your code for later use. Let''s look at this
    feature in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled exactly as the previous *hello world* examples
    (don''t forget to include and process a manifest if you have created a new project
    for this sample). When running this example, you should see the following interface
    with an additional text input field. When you type into the input box, the welcome
    message will change, for example `John Doe` was entered for this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/316b3d6d-9e48-4ad9-88c5-7a9f81bbe9cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The hello world with name entry
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the `message` and `userName` variables are not initialized
    directly by the application code, but by the time the function assigned to `OnTextChanged` is
    called, they hold valid references to instantiated widgets. Using this approach,
    we can get the type of access that the native API wrappers provide while also
    writing an easy-to-read UI definition provided by the declarative API.
  prefs: []
  type: TYPE_NORMAL
- en: Building a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Armed with the knowledge of how the Walk API is designed and utilized, let's
    move on to a real-world example. In this book, we will be building the same user
    interface for each toolkit explored (in Chapters [4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    [5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml), [6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml),
    [7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), [8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml),
    [9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml), and [10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml)),
    which will be a simple email application named GoMail. Due to the close relationship
    between Walk and Qt widgets, we can quickly get started designing the user interface
    using the UI Builder included in Qt Creator (documentation is available at [http://doc.qt.io/qtcreator/creator-using-qt-designer.html](http://doc.qt.io/qtcreator/creator-using-qt-designer.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic application will be formed of two windows: the main email browser
    and a secondary window for composing new emails. The main window will contain
    a list or tree view that shows the emails we have received, a larger panel to
    display the content of the currently-selected email, and a menu and toolbar for
    accessing the various features of our email application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a56d7ac-9caa-43f3-a214-08c19f1ffa2b.png)'
  prefs: []
  type: TYPE_IMG
- en: The main email window within Qt Designer
  prefs: []
  type: TYPE_NORMAL
- en: 'To compose new emails, we will show a secondary window that will ask for the
    various details for the email being sent. Opening a new window will allow the
    user to continue reading emails while they compose new emails to be sent. The
    compose window will also have buttons to send or discard the email being written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d06edc7-b37e-4aa0-91b2-1d56d4b81f16.png)'
  prefs: []
  type: TYPE_IMG
- en: The additional compose window being designed
  prefs: []
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications built using Walk are composed of native Windows components, and,
    as such, the style is set by the implementation provided by Microsoft (this is
    provided by Common Controls, part of `ComCtl32.dll`). The version required by
    Walk (version 6.0) adds support for visual styles; this is the system that provides
    the ability for applications to use the correct visual style for the version of
    the Windows desktop that is currently running.
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality is available as far back as Windows XP, but comes as standard
    from Vista onward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/314919e2-6f34-4990-8ed3-843a13378f2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Windows 7 default theme (Aero –used with permission from Microsoft)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92e81544-3c7f-40bd-81ad-145cd166d9bc.png)'
  prefs: []
  type: TYPE_IMG
- en: Windows 8 default theme (called Windows used with permission from Microsoft)
  prefs: []
  type: TYPE_NORMAL
- en: The preceding images show how a simple application will adapt to the theme on
    different versions of Windows. These illustrations are using the default theme,
    but the user may apply additional customizations on their desktop, which will
    also apply to any applications built with Walk.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Walk layouts (like those Qt Widget layouts they were inspired by) are based
    on a limited number of grid-based variants. The list of implemented layouts includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GridLayout`: Items are laid out in a regular grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VBoxLayout`: Items are placed in a single column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HBoxLayout`: Items are aligned in a single row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have explored the Qt UI Builder or are familiar with Qt, you may be expecting
    a fourth layout, `FormLayout`, which is not currently present in Walk. This can
    be simulated, however, using a two-column `GridLayout` and applying alignment
    properties as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the standard layouts, there are various widgets (some of which
    are invisible in the final interface) that help group UI elements and provide
    a more satisfying layout. The most commonly used of these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Splitter`: Places a draggable split bar between two child widgets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spacer`: Used to create visual padding so items can shrink instead of filling
    space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Separator`: Provides a visual separation between widgets, such as in a toolbar
    or menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScrollView`: A standard widget for providing scrollable content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupBox`: A visual widget container with a border and optional title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Composite`: A widget container used to logically group items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s get started implementing our email app user interface by creating some
    Go code using the declarative API. We start with a `MainWindow` that has a suitable
    `MinSize` set and an `HSplitter` that will hold our content. `TreeView` is used
    for listing emails on the left of the splitter (as the first item in the `Children`
    list), and on the right (item two in the list) is a `Composite` set to use a `Grid` layout—the
    closest we have to the form layout designed. Within the group, we add many instances
    of the child `Label` where we will show email details (that will be updated in
    *Communicating with the GUI* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be run by replacing the `MainWindow` in the previous
    *hello world* example, recompiling, and then running the example again. If you
    set up a new project, remember to include the manifest file and run `rsrc` again!
    When run, it should look like the following screenshot, taken on Windows 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d169ecc-273f-4863-9dc5-a58073df514c.png)'
  prefs: []
  type: TYPE_IMG
- en: The basic email interface using Walk's declarative API
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will make a `Dialog` with a similar layout that replaces the instances
    of `Label` with `LineEdit` or `TextEdit` for entering details of a new email.
    Last, we add another `Composite` with an `HBox` layout that contains the instances
    of `PushButton` for `Cancel` and `Send`, along with an `HSpacer` to complete the
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you want to test this code, the easiest approach is to replace `Dialog` with
    `MainWindow` and run it like the main layout (don't forget to change it back before
    moving on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have some event-handling, this will open like a dialog box, which is
    why it''s not a `MainWindow` in the preceding listing. Running the code should
    produce the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/113d56b1-49c2-425f-9af6-9cf2a935bc33.png)'
  prefs: []
  type: TYPE_IMG
- en: The compose email view using Walk's declarative API
  prefs: []
  type: TYPE_NORMAL
- en: That's all that's required to complete the layout code of the main interface
    features. Next, let's add the menu, toolbar, and set up actions for the buttons
    we have defined.
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar and menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding menus and toolbars with the declarative API is very straightforward.
    The `MainWindow` struct has the `Menu` field (which is a slice of `MenuItem`)
    and the `ToolBar` field (which takes a `ToolBar` struct that contains an `Items`
    field for the `MenuItem` list). Each item in the list is either an `Action`, a
    `Separator`, or another `Menu` that mirrors the designs we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Each `Action` in the declarative API expects a `Text` string that is used for
    the display in menus. Toolbars also use this content for tooltips, and for display
    if the style is set to `ToolBarButtonTextOnly`. An `Image` field allows you to
    set an icon for the toolbars if you want to reference installed images or icons
    distributed with your app. Most important is the `OnTriggered` field, which should
    be set to a `func()` that will be executed when the button or menu item is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used set up the menu on the `MainWindow` we created in
    the *Layout* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the toolbar is almost identical and so the details have been omitted,
    but you can add it to the `MainWindow` using the `ToolBar` field, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the code added should be a window like that in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0b8777c-59a4-47a7-8e09-d54caa1692af.png)'
  prefs: []
  type: TYPE_IMG
- en: The main email interface with the menu and toolbar added
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry if the code for the new button didn''t work for you—the completed
    application source code is available to download at [https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go](https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go). Before
    the user interface code is completed, we should add some code that will help us
    to navigate the app. The simplest is the quit item from the file menu. Just add
    the following code to the preceding `Quit` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The opening of our compose dialog is a little more complicated because a dialog
    needs to know which parent it''s loading from. To do this, create a local variable,
    called `window`, of the `*walk.MainWindow` type and assign it to the `MainWindow` declarative
    API using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be referenced in your `New` action handler, where `NewCompose`
    is a function that creates the email compose window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we should set up default behavior for the buttons on our compose dialog.
    To do this, we need to declare two `*walk.PushButton` variables that are assigned
    to the `Cancel` and `Send` buttons, respectively. By then passing these to the
    dialog definition using the `CancelButton` and `DefaultButton` fields, we get
    the appropriate behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s set the cancel button to close the dialog—you will need to create
    a `walk.Dialog` variable to `AssignTo` the declarative API as with the main window.
    With these steps complete, either clicking the cancel button or pressing the *Esc*
    key should dismiss the compose window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Communicating with the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To populate the user interface, we need to define a data model and load some
    test data. Within the code for this book, there is a client package that contains
    a data model and some test data to simulate an email server. We will use that
    package by importing it into the Go files for this project using the `github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client` package.
    We won''t cover the details of the package in this chapter, but we will reference
    its defined `client.EmailServer` and `client.EmailMessage` types. The email message
    definition is as follows—the field names will be useful when loading email details
    in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: View model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To communicate with the Walk user interface, we need to define another data
    model. This view model is designed to communicate information in a way that the
    declarative API understands. We will create a type named `EmailClientModel`, which
    will handle translating data from our client code to our user interface definition.
    Create a new file, `model.go`, where you can start to define these models. The
    first section of the code allows an email server to be set causing the email list
    to update accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For brevity, the trivial methods for `walk.TreeModel` have been left out—you
    can find them in the full code listing for this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The email list for this model needs to represent our email list as items in
    a tree, rather than a simple list as returned by the client code. To support this
    we need another type, `EmailModel`, that implements the `walk.TreeItem` interface.
    Here, again, we have omitted the trivial details—each email item will never contain
    child elements and so we can ignore this complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to group our emails under an `Inbox` heading, so we need to build the
    root node and then populate the email list within it. For this, we define one
    more type, `InboxList`, which also implements `walk.TreeItem`, but this time it
    will allow access to the child list (emails) it holds. We will also need to write
    a method for building the inbox list from a list of messages (which we would be
    provided by the client code). See how the final method in this code snippet creates
    instances of `EmailModel` for each message and adds them to the inbox list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Detail view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a data model built, let''s display the data that''s loaded.
    Starting with the email detail view, we will make use of Walk''s declarative API, `DataBinder`.
    This allows us to avoid having to manually set the data on each label every time
    a new message is loaded. To work correctly, we also need to create a `walk.DataBinder`
    to assign to—this will handle the actual bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can update the `Composite` widget that displays the email information to
    use this data binding. Let''s also set the default content through the `DataSource`
    field. This information will come from the model, which we will initialize shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, each item simply has its static `Text` field changed to an appropriate `Bind()`
    call; the parameter will be the name of the field on an `client.EmailMessage`
    type described in the *View model* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `Date` field, we can''t directly bind a `time.Time` type, so use the
    `DateString()` helper instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let''s create a helper method that will allow us to update the
    email message that is currently bound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: List view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the work for our email list was done in the preceding model code—now
    we need to connect it to the user interface. The following code sets up a `walk.TreeView`
    class that we use to keep track of the current item and assigns it to the declarative
    `TreeView`. After that, the model is set and then we pass a function that will
    be informed when the current item changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With all that in place, the application will load the email details from the
    current email message using `model.Server.CurrentMessage()` via the default `DataSource` of
    the `DataBinder`. When the main list is clicked, the function passed to `OnCurrentItemChanged`
    checks that the item is an `EmailModel` and, if so, updates the detail view. Finally,
    we need to set up the model that will be used in the preceding code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This model is used to set the list content and also to set the default content
    of the detail view. When built and run, the application should now look like a
    complete, albeit basic, email client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9a2ab00-3882-451f-b633-103bca097548.png)'
  prefs: []
  type: TYPE_IMG
- en: Our email interface with some test data loaded
  prefs: []
  type: TYPE_NORMAL
- en: Background processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All user interface code with Walk must run on the main thread; this is a constraint
    of the winAPI that handles the widgets. This means that any work in the background
    must change threads before running any UI code. This is done using the `Synchronize()`
    function on `walk.Window`. It takes a single function as a parameter and ensures
    that the code it contains will be run appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the updating when an incoming email arrives, we create a new function,
    `incomingEmail()`, that will update our email list model. This function will cause
    an email to be added to the model, which will happen on the main thread so that
    the user interface can be updated to reflect the new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To support this change, we need to update `EmailClientModel` to add this new
    `AddEmail()` function. The function will add an item to the list and publish the
    data-reset event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This, in turn, needs an `Add()` function in the `InboxList` type that we created
    to provide data to the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to listen to the `Incoming()` server channel, which will deliver
    each new email to our application. As this channel read will block until an email
    is received, this must run in a separate goroutine—hence the background processing.
    When an email arrives, we simply call the function we just created, passing the
    new `email` and a reference to the `model` which we should refresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this code in place, you will see the email list update when a new email
    arrives. The email can then be clicked to see the details.
  prefs: []
  type: TYPE_NORMAL
- en: Walk in a cross-platform application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Walk is clearly a library aimed at creating graphical user interfaces for the
    Microsoft Windows platform—but this doesn't mean that building your application
    with Walk limits you to Windows only. Using the techniques explored in [Chapter
    3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the Rescue!*, we can set
    the code for Windows to be conditionally included when building for the platform,
    and introduce other files that could provide a user interface for other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to update the files we have built so far to only build on
    Windows. We do this using the build constraints comment format (you could also
    use file naming for this step if you wish):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then introduce a new file that will handle the fallback case when we''re
    on a different platform. For this simple project we will call it `nonwindows.go` as
    the content will run for any computer not running Windows. In this file, we place
    a small amount of code that will print a failure message and quit if the application
    is launched on any unsupported platform. Note that the build constraint here is
    set to compile on any non-Windows platform; this too would be updated to match
    any fallback cases your project may have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `NewMailUIBrowse()` function name—this is our generic method name
    for loading and running the main GoMail browse interface. You probably need to
    update the name of the method that was previously used to run the application.
    Most likely, you used `main()`, but we will need to provide a new `main.go` with
    that method. This new file is the only file in the project with no build constraints.
    It will compile for any platform and, when running, it will execute whichever
    `NewMailUIBrowse()` method was compiled in for the target platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we switch to another operating system, say macOS, and compile the code now,
    there should be no compile errors. Running the application will yield a simple
    error message and it will immediately quit. Clearly this code could do something
    more meaningful than just exiting with an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1ee956a-b0c8-41e8-8c67-4178b61a6ff1.png)'
  prefs: []
  type: TYPE_IMG
- en: And so you see how we can use Walk to develop a Windows-specific user interface.
    As part of a multi-platform strategy, this could help ensure greater platform
    integration for your audience on Windows, or you may wish to provide certain sections
    of your application with platform-specific implementations. Whatever the reason,
    you can see how easy it is to include multiple platform-specific alternatives
    within a cross-platform application build with Go.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started the exploration of GUI toolkits by first looking
    at the Walk API for Windows' graphical application development. We looked at how
    to get a Go-based Windows application running, and learned how the Walk project
    is structured into separate declarative and native APIs. We also saw how each
    of these APIs provides different benefits and how they are best combined to create
    a simple application.
  prefs: []
  type: TYPE_NORMAL
- en: As the Walk design was heavily inspired by the Qt project (which we will return
    to in [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), *Go-Qt - Multiple
    Platforms with Qt*), we were able to use the interface-designer features of Qt
    Creator to mock up a basic email application that we then built out using the
    declarative API. This email application is a design that can be reused for each
    of the toolkit-exploration chapters. To support the example applications, we imported
    another package that is provided in this book's source code, which provides some
    data models and test data. By combining our UI code, the email client library,
    and the data binding capabilities of the Walk toolkit, we were able to create
    a simple email application that would run natively on the Windows platform using
    the system-provided widgets. Through some small alterations, it was shown that
    this could be part of a wider cross-platform strategy where each platform's graphical
    presentation is provided by different toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move our focus to code that provides a native look
    and feel across multiple platforms. We will be looking specifically at andlabs
    UI—a GUI toolkit that aims to provide a look and feel that matches the current
    operating system. If used on Windows, this will be similar to Walk, but it also
    adapts to different desktop platforms while only needing to write the user-interface
    code once.
  prefs: []
  type: TYPE_NORMAL
