<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">andlabs UI - Cross-platform Native UIs</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Like the Walk API we explored in the previous chapter, andlabs UI aims to create a Go API on top of operating system native widgets, but, unlike Walk, andlabs UI project supports multiple operating systems with a single API. This means that graphical applications created using the API can be compiled and run on Windows, macOS, and Linux using the same source code.</span></p>
<p>In this chapter, we will explore cross-platform native applications that match the operating system's look and feel. In particular, we will cover the following topics:</p>
<ul>
<li>Background and history</li>
<li>Getting started with andlabs UI</li>
<li>Generic API for multiple platforms</li>
<li>Building a user interface</li>
<li>Challenges with multiple native GUIs</li>
</ul>
<p>Before we get started with the benefits and complexities of a cross-platform API using native widget toolkits, let's look more at the background of the project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background and history</h1>
                </header>
            
            <article>
                
<p>The andlabs UI project was created to provide a simple-to-use way to create native graphical applications using Go. The API is minimal as it aims to provide only what is necessary to create GUI programs. The core is a C library, which hides the platform-specific APIs, allowing the main library to manage the idiomatic considerations for a Go GUI API. Recently, the C library (libui) was moved to a separate project, which is included in the Go project for developers' convenience.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There is a demonstration of the widgets available included in the project—when run on a Linux computer, it will look like the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d518b369-6ae8-4ce1-aca3-21d7b12c60a0.png" width="748" height="348"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The widget demo from andlabs UI</div>
<p>As a platform-native implementation, the widgets in andlabs UI will look different on each operating system. On Windows and macOS, the library uses the native widget set, and on Linux it uses the GTK+ library. This approach creates applications that are consistent with other software on the current computer and so should be simple for users to understand. This approach is powerful and has substantial benefits, but can add complications for application developers. We will explore the benefits and challenges of such an approach within this chapter, but first let's get running with a simple <em>hello world</em> application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started with andlabs UI</h1>
                </header>
            
            <article>
                
<p>Andlabs UI is easy to get started with on most platforms, but the details vary from system to system. Due to the nature of linking to many different operating systems' native widget toolkits, there can be some hidden complexities, especially when developing Linux-based applications. Before we can build our first andlabs-based application GUI, there is some setup required. We need to prepare the current development environment to work with native widgets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p class="mce-root">As an API that utilizes the native widgets for each platform, the prerequisites vary for Windows, macOS, and Linux. Any packages that need to be installed in this section will be required by any users of the applications that you develop as well. It's also necessary to have CGo running (the ability for Go code to call C functions is illustrated in <a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml"/><a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml">Chapter 3</a>, <em>Go to the Rescue!</em>), which may require the installation of additional build tools.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Microsoft windows</h1>
                </header>
            
            <article>
                
<p>The native widgets used on Windows are the Common Controls—the same used by the Walk library that we explored in detail in the <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications</em>. As they are native to the operating system, no installation is required when using Windows Vista or later. If you want to support earlier versions (back to Windows XP), it's possible if you install at least version 6.0 of <kbd>ComCtl32.dll</kbd>.</p>
<p><span>Andlabs UI, like many of the other toolkits featured in this book, requires the presence of CGo to utilize native libraries. On a full development system, it's likely that this is already set up. If you're unsure, or would like a reminder of how to set up the Cgo dependencies, please check</span> <span><em>Setting up CGo</em> section from the </span><a href="a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml">Appendix</a><a href="a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml"/><span>, </span><span><em>Installation Details</em></span>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">macOS</h1>
                </header>
            
            <article>
                
<p>When developing for macOS, the native widgets are used directly. As these are provided by the operating system for every recent version of macOS, no additional libraries are required.</p>
<p>CGo support is required for andlabs UI and this requires XCode command-line tools to be installed. If you have not already set this up <span>please check</span> the <span><em>Setting up CGo</em> section from the <a href="a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml">Appendix</a>, <em>Installation Details</em></span><em>.</em></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linux</h1>
                </header>
            
            <article>
                
<p>On Linux, andlabs UI uses the GTK+ widget library (which we will explore in detail in <a href="6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml">Chapter 6</a>, <em>Go-GTK - Multiple Platforms with GTK</em>) and so the library must be installed on your computer. If you have the Gnome desktop installed, or other applications that use GTK+ (such as Gimp), the library will already be installed. If not, you will need to install this dependency using your system's package manager.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>While this is a simple task, the package name varies across systems—it will probably be called <span><kbd>gtk3-devel</kbd>, <kbd>libgtk-3-dev</kbd>, or <kbd>gtk3</kbd>. Install this in the usual manner and you'll be ready to set up andlabs UI library.</span></p>
<p>To enable CGo, required by andlabs UI, on Linux you must have a compiler (gcc or clang) installed. This is often already installed on a development Linux installation, but if you're unsure, you can follow the <span><em>Setting up CGo</em> section from the <a href="a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml">Appendix</a>, <em>Installation Details</em></span>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setup</h1>
                </header>
            
            <article>
                
<p>The setup of andlabs UI is very simple—it only requires you to get the library using Go tools. You only need to execute <kbd>go get github.com/andlabs/ui</kbd>. This works exactly the same on Windows, macOS, and Linux, assuming that you have Go installed and running (if not, check out <em>Installing Go</em> section in the <a href="a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml">Appendix</a>, <em>Installation Details</em>). If you encounter an error, first check that your Go installation is up to date<span>—</span>these issues often get fixed quickly<span>—</span>and that you have set up CGo as described.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rebuilding the UI library (workaround)</h1>
                </header>
            
            <article>
                
<p>The libui library that andlabs UI is built upon is packaged with the main library, but sometimes this gets out of date or is not compiled for the exact configuration of your computer. If you see an error when this happens, such as <kbd>relocation R_X86_64_32S against '.rodata' can not be used when making a shared object</kbd>, these instructions will help. If you see no error when installing, please skip these tips!</p>
<p class="mce-root">The following commands will rebuild the libui file for your computer. It assumes a Linux bash shell, as this situation is most likely to occur on a Linux computer. This is not going to be needed for anyone using the applications you build—just for setting up your development environment. The libui project is downloaded from Github and built using standard cmake tools. Be sure to specify the <kbd>-DBUILD_SHARED_LIBS=OFF</kbd> parameter, as we must build a static library to embed in the Go library:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/c9ad32e8-e03a-4a29-89a3-06212cfe6276.png" width="642" height="368"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Rebuilding libui if the packaged version doesn't work</div>
<p class="mce-root">The commands are designed to work without any environment configuration, but you will need cmake installed—your system's package manager will be able to install it if you find it isn't installed. Once the build is complete, the resulting library, <kbd>out/libui.a</kbd>, should be moved into the UI project and renamed appropriately.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code</h1>
                </header>
            
            <article>
                
<p>Now that the library is installed, it's time to write some code. The following sample is andlabs UI equivalent of the <em>hello world</em> example we used in the <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications</em>. Start by entering the following code into a new file, named <kbd>hello.go</kbd>:</p>
<pre>package main<br/><br/>import "github.com/andlabs/ui"<br/><br/>func main() {<br/>        err := ui.Main(func() {<br/>                window := ui.NewWindow("Hello", 100, 50, false)<br/>                window.SetMargined(true)<br/>                window.OnClosing(func(*ui.Window) bool {<br/>                        ui.Quit()<br/>                        return true<br/>                })<br/><br/>                button := ui.NewButton("Quit")<br/>                button.OnClicked(func(*ui.Button) {<br/>                        ui.Quit()<br/>                })<br/>                box := ui.NewVerticalBox()<br/>                box.Append(ui.NewLabel("Hello World!"), false)<br/>                box.Append(button, false)<br/><br/>                window.SetChild(box)<br/>                window.Show()<br/>        })<br/>        if err != nil {<br/>                panic(err)<br/>        }<br/>}</pre>
<p class="mce-root">This code is pretty straightforward, but there are a few things that we should cover, so let's step through it. As usual, for a simple graphical Go app, we are using the <kbd>main</kbd> package and importing the toolkit library, before defining the <kbd>main()</kbd> function. We then call the main entry point for an andlabs UI application, <kbd>ui.Main()</kbd>, which takes a single function that will build and show the app's GUI. If an error occurred, we cause the binary to panic, as the interface couldn't be loaded.</p>
<p>In our user interface code, we first set up a window with <kbd>ui.NewWindow()</kbd>, with a title and a default size, and <span>the final parameter indicates whether the window should have a menu bar</span>. We turn on the default margin (padding) and assign a closing function to exit the app by calling <kbd>ui.Quit()</kbd>. Next, a new button is created with <kbd>ui.NewButton()</kbd>, labelled <kbd>Quit</kbd>, that also exits the application when clicked. These components are laid out using a container with <kbd>ui.NewVerticalBox()</kbd>. A <kbd>Hello World!</kbd> label and the <kbd>Quit</kbd> button are both added. The <kbd>Append()</kbd> method of <kbd>ui.Box</kbd> takes a Boolean parameter, <kbd>stretchy</kbd>—if this is set to <kbd>true</kbd>, the component will expand to fill the available space. Last, we set the content of the window with <kbd>SetChild()</kbd> and show it using <kbd>Show()</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Build</h1>
                </header>
            
            <article>
                
<p>Building this sample app is trivial. For example, in the following screenshot, we are running a Terminal on a Linux computer and simply execute <kbd>go build hello.go</kbd>. This creates an executable file that can be run directly without needing the Go tools installed:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/b3de9f96-2285-4865-b01d-914b9e26b047.png" style="width:44.42em;height:9.75em;" width="642" height="141"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Building for the current Linux environment</div>
<p>Building on a Windows computer (as long as gcc is in the command-line path—see <em>Prerequisites</em> section mentioned earlier) is just as simple as on Linux or macOS:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/28d70e8c-5e3d-472b-8e4e-42f0d564e00c.png" style="width:34.92em;height:20.25em;" width="671" height="389"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Building the hello world app on Windows</div>
<p>In these examples, we are building the applications on the platform they will run. Cross-compilation, one of the strengths of the Go toolchain, is more complicated with andlabs UI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Run</h1>
                </header>
            
            <article>
                
<p>The application can be run from the command line (<kbd>./hello</kbd> on Linux or macOS, and <kbd>hello.exe</kbd> on Windows) or simply by double-clicking the file icon from your system's file browser. Either way, the result should be the appearance of a familiar <em>hello world</em> window. <span>This will look very similar across multiple operating systems, but the look and feel will vary:</span></p>
<p>On Windows this is the same as Walk:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/e1024499-c9e2-417a-88e0-f1dffbdf98b3.png" style="width:7.67em;height:6.00em;" width="174" height="136"/></div>
<div>Andlabs UI hello world on Linux:</div>
<div class="CDPAlignCenter CDPAlign"><img src="Images/2e5a1ab8-3a60-469b-a144-f6dd50e61764.png" style="width:7.08em;height:6.67em;" width="105" height="99"/></div>
<div>Hello world running on macOS:</div>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6d5f8a00-07a0-435b-9a0e-956a805eebee.png" style="width:8.17em;height:6.58em;" width="196" height="155"/><span>  </span>
<p> </p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generic API for multiple platforms</h1>
                </header>
            
            <article>
                
<p>The andlabs UI project provides a generic API that wraps operating-system-native widgets on Windows, Linux, and macOS. Due to this approach, it's largely limited to the <em>lowest common denominator</em> level of functionality, but considering how similar these toolkits are, the resulting API is surprisingly rich.</p>
<p class="mce-root"/>
<p>All widgets inherit from the <kbd>ui.Control</kbd> interface, which defines the <kbd>Show()</kbd>, <kbd>Hide()</kbd>, <kbd>Enable()</kbd>, and <kbd>Disable()</kbd> methods that all controls must implement (with obvious expected behavior). Additionally, it defines the <span><kbd>LibuiControl()</kbd> and <kbd>Handle()</kbd> methods, which provide a pointer to the low-level libui and operating-system widgets, respectively. The use of those methods is generally not recommended and so not covered in this chapter.<br/></span></p>
<p>When compared to the Qt inspired Walk API of the <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications</em>, the layout capabilities of andlabs UI appear limited with fewer controls managing the GUI visual flow. Native controls (while broadly similar) are programmed differently and not necessarily compatible with the same high-level layout definitions. What you will see in the following section is that containers are typically set up to expect one child, which is laid out using a <kbd>ui.Box</kbd> control. Many widgets, which could be considered containers in other toolkits, are managed as a single control in andlabs UI (such as <kbd>ui.RadioButtons</kbd>) so that the operating-system-specific implementation can be handled internally.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controls</h1>
                </header>
            
            <article>
                
<p>All the widgets defined in andlabs UI implement the <kbd>Control</kbd> interface and, as such, can be shown, hidden, enabled, or disabled and set as the content of a window through <kbd>SetChild()</kbd> (with the obvious exception of <kbd>ui.Window</kbd>). A window may not be the child of any other <kbd>ui.Control</kbd>, for obvious reasons. The definition of <kbd>show()</kbd> and <kbd>hide()</kbd> for a window will be set by the operating system or widget toolkit, as will the manner of disabling the window content.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Box</h1>
                </header>
            
            <article>
                
<p>It is probable that any window will have its content set to a Box—this is because it's the only control that provides a way to group multiple controls together. It's a control with no visible container, which is the basic layout mechanism within andlabs UI. You can create a new box using <span><kbd>ui.NewHorizontalBox()</kbd> or <kbd>ui.NewVerticalBox()</kbd>, which lays out its child controls horizontally or vertically in a linear arrangement. In a horizontal arrangement, the child items will all have the same height (which will match the height required for the tallest child), and in a vertical (stacked) configuration, they will all have the same width.</span></p>
<p>The method of adding child controls to a box is to call the <kbd>Append()</kbd> function, which takes a <kbd>ui.Control</kbd> child parameter and a <kbd>bool</kbd> stretchy parameter. The <strong>child</strong> will be added to the list of the components, and the <strong>stretchy</strong> parameter determines how the available space should be filled. When the stretchy parameter is <kbd>true</kbd>, the item will expand to fill extra space; if it's <kbd>false</kbd>, the minimum size will be observed. If multiple components have stretchy switched on, the spare space will be divided equally between them.</p>
<p>It's often going to provide a better visual flow for your user interface if widgets are separated by some space. There is a suitable method provided, <kbd>SetPadded()</kbd>, which will set a standard space between child widgets in the box. This size is set by the widget toolkit's standard metrics, and will vary from platform to platform. The padding applied in this way is placed between the child components—for outer (surrounding) space, you should set a margin. The margin is available in controls which embed a child control<span>—</span>dubbed <kbd>containers</kbd> in this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Containers</h1>
                </header>
            
            <article>
                
<p>Containers, or controls that allow us to embed another control, are typically identified by the existence of a <kbd>SetChild()</kbd> or <kbd>SetMargined()</kbd> function in their type definition. As these controls embed one another, a margin around the content is often desirable—this is the outer equivalent of the padding in <kbd>ui.Box</kbd>. This can be turned on using <kbd>SetMargined(true)</kbd>, and the system-defined margin size will be introduced around the child control.</p>
<p>The following containers are defined as part of andlabs UI:</p>
<ul>
<li><kbd>Window</kbd> controls describe an application window and are the main entry point for an andlabs UI graphical application. The main content is set using <kbd>SetChild()</kbd>. Margins should probably be switched on if it's a simple content window, or left off if you are adding further container controls.</li>
<li><kbd>Group</kbd> defines a frame around a child widget (assigned with <kbd>SetChild()</kbd>) with a title (passed to <kbd>ui.NewGroup()</kbd>). The appearance of the group control will vary across systems; on some it may be a box around the child, and on others it may be invisible. As with the window controls, you should consider the child content before deciding whether the margins should be enabled.</li>
<li><kbd>Tab</kbd> is slightly different from the others, as it may contain multiple child controls<span>—</span>but only one is visible at a time. As there are multiple child controls, the method to add the child is <kbd>Append(string, Control)<span>—</span></kbd>the first parameter is the title to be displayed on the tab and the second is the child for this new tab. To accommodate multiple child controls, the margin control is adapted also<span>—</span>you will need to call <kbd><span class="pl-en">SetMargined</span><span>(</span><span class="pl-v">int</span><span>,</span> <span class="pl-v">bool)</span></kbd><span> where the first parameter is the tab index, and the latter is the usual parameter to turn margins on or off.</span></li>
</ul>
<p>That's all of the controls that manage others, let's look at the details of the main widgets that an andlabs UI application is constructed from.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Widgets</h1>
                </header>
            
            <article>
                
<p>The remaining widgets will be familiar to to any developer of desktop graphical applications, or indeed anyone who uses them. Provided here is a quick overview for the features or limitations of each:</p>
<ul>
<li><kbd>Button</kbd>: A standard <kbd>pushbutton</kbd> with a label, and an <kbd>onClicked</kbd> callback
<ul>
<li><kbd>Checkbox</kbd>: A toggled entry that is either checked or unchecked; an <kbd>onToggled</kbd> callback will trigger on change</li>
</ul>
</li>
<li><kbd>Combobox</kbd>: A widget that provides a list of strings to select from</li>
<li><kbd>DateTimePicker</kbd>: A field for entering date and/or time<span>—</span>the configuration is set by different constructor functions</li>
<li><kbd>Entry</kbd>: A single-line text-entry widget, which can be read-only; it supports an <kbd>onChanged</kbd> handler for change events</li>
<li><kbd>Label</kbd>: A simple read-only text component for annotating the user interface</li>
<li><kbd>ProgressBar</kbd>: A horizontal bar to indicate progress; values range from 0 to 100</li>
<li><kbd>RadioButtons</kbd>: A control for presenting a list of options, such as check boxes, but where only one can be selected</li>
<li><kbd>Separator</kbd>: A horizontal or vertical line to visually separate other controls</li>
<li><kbd>Slider</kbd>: A horizontal bar for selecting between the set min and max integer values by moving an indicator</li>
<li><kbd>Spinbox</kbd>: An entry box for selecting an integer between the min and max values with the up and down buttons</li>
</ul>
<p>A noticeable omission on this list is menu or toolbar widgets; they are not included in andlabs UI toolkit at the time of writing. Next, we'll look at a potential workaround for menus (which unfortunately will not work for a toolbar) by accessing the underlying libui.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Menu</h1>
                </header>
            
            <article>
                
<p>At the time of writing, andlabs UI doesn't expose a menu API (despite <kbd>ui.NewWindow()</kbd> taking a <kbd>hasMenubar</kbd> parameter). There is a project underway to properly expose menu functionality to the Go API, but for now it's only available if you work with the underlying libui C code. The menu defined in the C library can be accessed from a Go project by adding a little CGo code, such as the following:</p>
<pre>/*<br/>void onMenuNewClicked(uiMenuItem *item, uiWindow *w, void *data) {<br/>   void menuNewClicked(void);<br/>   menuNewClicked();<br/>}<br/><br/>int onQuit(void *data) {<br/>   return 1;<br/>}<br/><br/>void loadMenu() {<br/>   uiMenu *menu;<br/>   uiMenuItem *item;<br/><br/>   menu = uiNewMenu("File");<br/>   item = uiMenuAppendItem(menu, "New");<br/>   uiMenuItemOnClicked(item, onMenuNewClicked, NULL);<br/>   uiMenuAppendSeparator(menu);<br/>   item = uiMenuAppendQuitItem(menu);<br/>   uiOnShouldQuit(onQuit, NULL);<br/><br/>   menu = uiNewMenu("Help");<br/>   item = uiMenuAppendItem(menu, "About");<br/>}<br/>*/<br/>import "C"</pre>
<p>The code snippet sets up a click handler for a <span class="packt_screen">New</span> menu item, and a quit handler for the <span class="packt_screen">Quit</span> menu item (which is a special item due to macOS handling a quit menu item differently). Then we have a <kbd>loadMenu()</kbd> function, which sets up a <span class="packt_screen">File</span> menu to which the child items are added, with a separator, and a currently-empty <span class="packt_screen">Help</span> menu.</p>
<p class="mce-root"/>
<p>To compile this code correctly will require the <kbd>cfuncs.go</kbd> file knowing where the header file and C library are stored. Before running this code make sure that the <kbd>CFLAGS</kbd> and <kbd>LDFLAGS</kbd> show the correct locations. While the code to build a menu is not very complicated, the CGo configuration and linking is rather complex, and as such, may not be recommended:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/ddb3b8fe-6bac-4a65-9b06-c98d54710f62.png" width="642" height="96"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Launching the menu example</div>
<p>The result should look similar to this screenshot, which was taken on a Linux computer:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/e8606215-3a10-45b4-b741-e9fe9b2824c0.png" style="width:18.25em;height:8.42em;" width="269" height="124"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The andlabs libui menu</div>
<p><span>There is a complete menu project in the code repository for this book. Unfortunately, it isn't a cross-platform project and may not execute correctly on every operating system or version o</span><span>f Go.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Area and drawing</h1>
                </header>
            
            <article>
                
<p>The <kbd>ui.Area</kbd> widget presents a canvas-like control—a surface that can be drawn on using Path and other drawing primitives. At the time of writing, these APIs are all part of the <kbd>ui</kbd> package, but it may soon move to <kbd>ui/draw</kbd> in an effort to separate them from the main controls API. An area can either be the size of the space it occupies or it can be larger, in which case it will be embedded in a scrollable control. The desired behavior is chosen based on whether <span><kbd>ui.NewArea(handler)</kbd> or <kbd>ui.NewScrollingArea(handler, width, height)</kbd> is called (where width and height are the desired content size).</span></p>
<p>The logic behind an area is <kbd>ui.AreaHandler</kbd>, the first parameter to either of the area constructor functions. Its <kbd>Draw(*ui.Area, *ui.<span>AreaDrawParams</span>)</kbd> function is invoked by the toolkit whenever the area needs to be redrawn, the first parameter being the area it's registered on and the second providing context, such as the clipping rectangle to be filled. As well as drawing the content of an area, the handler is responsible for handling the mouse and key events, with <kbd>MouseEvent(*ui.Area, *ui.AreaMouseEvent)</kbd> <span>being called whenever a mouse event occurs and <kbd>Key<span class="pl-c1">Event</span>(*ui.Area, *ui.AreaKeyEvent)</kbd> for any keyboard events.</span></p>
<p>To look more closely at the drawing capabilities, let's run a little code. In this example, we are creating a new <kbd>ui.AreaHandler</kbd> type (named <kbd>areaHandler</kbd>) that implements all the required functions from the interface. The only method of interest is the <kbd>Draw()</kbd> call, which is included here:</p>
<pre><span>func </span>(areaHandler) Draw(a *ui.Area, dp *ui.AreaDrawParams) {<br/>   p := ui.NewPath(ui.<span>Winding</span>)<br/>   p.NewFigure(<span>10</span>, <span>10</span>)<br/>   p.LineTo(dp.ClipWidth - <span>10</span>, <span>10</span>)<br/>   p.LineTo(dp.ClipWidth - <span>10</span>, dp.ClipHeight - <span>10</span>)<br/>   p.LineTo(<span>10</span>, dp.ClipHeight - <span>10</span>)<br/>   p.CloseFigure()<br/>   p.End()<br/><br/>   dp.Context.Fill(p, &amp;ui.Brush{Type:ui.<span>Solid</span>, R:<span>.75</span>, G:<span>.25</span>, B:<span>0</span>, A:<span>1</span>})<br/>   dp.Context.Stroke(p, &amp;ui.Brush{Type:ui.<span>Solid</span>, R:<span>.25</span>, G:<span>.25</span>, B:<span>.75</span>, A:.5},<br/>      &amp;ui.StrokeParams{Thickness: <span>4</span>, Dashes: []float64{<span>10</span>, <span>6</span>}, Cap:ui.<span>RoundCap</span>})<br/>   p.Free()<br/>}</pre>
<p>This code is split into two parts: first we set up a <kbd>ui.Path</kbd> and then we use the path to draw. The path (named p) is set to be 10 pixels inside the clip area that is being drawn—this is done so the canvas background is demonstrated (the drawing area is cleared before every <kbd>Draw()</kbd> call). Next, we use this path to <kbd>Fill()</kbd> and <kbd>Stroke()</kbd> within the draw context (<kbd>dp.Context</kbd>). The call to <kbd>Fill()</kbd> specifies a Brush that is a solid orange color of full opacity (<kbd>A</kbd> in the preceding code stands for alpha). Then, we call <kbd>Stroke()</kbd> using the same path (this will draw a line around the filled box). We are asking for a four-pixel-wide dashed line with round caps—this time with a semi-transparent blue color.</p>
<p>To draw this to screen, we need to configure a window to have a <kbd>ui.Area</kbd> control that expands to fill the window, as follows:</p>
<pre><span>func </span>main() {<br/>   err := ui.Main(<span>func</span>() {<br/>      window := ui.NewWindow(<span>"Draw"</span>, <span>200</span>, <span>150</span>, <span>false</span>)<br/>      window.SetMargined(<span>false</span>)<br/>      window.OnClosing(<span>func</span>(*ui.Window) bool {<br/>         ui.Quit()<br/>         <span>return </span><span>true<br/></span><span>      </span>})<br/><br/>      handler := new(areaHandler)<br/>      box := ui.NewVerticalBox()<br/>      box.Append(ui.NewArea(handler), <span>true</span>)<br/><br/>      window.SetChild(box)<br/>      window.Show()<br/>   })<br/>   <span>if </span>err != nil {<br/>      panic(err)<br/>   }<br/>}</pre>
<p>If you put all this together (or run the <kbd>chapter5/draw</kbd> example), you should see something like the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"> <img src="Images/687129fa-f84e-4a76-b986-c77a862d0c7b.png" style="width:16.00em;height:14.00em;" width="200" height="174"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Andlabs UI draw functions</div>
<p>Notice how the transparent blue is outlining the orange—filled rectangle, and also displaying the rectangle and the background from beneath. If we reversed the order of the <kbd>Fill()</kbd> and <kbd>Stroke()</kbd> calls, the orange rectangle would completely cover half of the dashed outline.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a user interface</h1>
                </header>
            
            <article>
                
<p>Now that we've looked at the API capabilities of andlabs UI, let's look at building a graphical application of some complexity. For this section, we will follow the design of the "GoMail" application introduced in the <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications</em>. The design presented was created using the Qt Creator tool which, while being a good fit for developing applications with the Walk library, is not a direct fit for all GUI toolkits. The multiple-platform approach of andlabs UI to use the native widgets means that some components are not available, but some can be created by combining simple widgets to form more complex components.</p>
<p class="mce-root">With that in mind, let's have a quick look at how the different platforms' styling capabilities may affect the application we are building. After exploring styles, we will start implementing the basic layout of our application and add the controls and features to demonstrate the user interface capabilities.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Style</h1>
                </header>
            
            <article>
                
<p>The styling of an andlabs-UI-based application is platform-specific and is normally set by the operating system. Some support user-based customization, which can subtly or vastly affect the look and feel of your application—so it's important to consider the possible variations during your application design and testing.</p>
<p>When run on Microsoft Windows, the toolkit in use is Common Controls (discussed in the <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows</em> <em>Applications</em>). Essentially, the controls will look somewhat different across versions of Windows, which helps the applications blend in with the evolving desktop's look and feel. Most user-customization options within Windows are focused on the newer ("Universal") applications, but may show some color changes within applications built using Common Controls (and therefore with andlabs UI). Be sure to consider which versions of Windows you intend to support when testing your application layout and design.</p>
<p>Apple also evolves their macOS widget toolkit look and feel over time, though most recent versions (since OS X 10.5—released in 2007) remain largely consistent in the layout and sizing of components. Applications running on andlabs UI in the macOS environment should remain fairly consistent across all supported versions—unless users enable the new <kbd>dark mode</kbd> in macOS Mojave (released in late 2018). Following this new user-configuration option, the user interface may be presented in a light (default) or dark mode to match the user's preference. Application designers should consider this and ensure their content presents well in both configurations.</p>
<p class="mce-root"/>
<p>The widgets used within andlabs UI adapt correctly to this new style, but custom content may not. There is currently no API to detect which color mode is being used and so the easiest approach is to either limit your interface to standard controls or to pick a color scheme that will look suitable in either mode:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/3a42f309-39f0-4c2c-a316-42915b4742eb.jpg" width="1341" height="835"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Side- by-side comparison of macOS light and dark modes (copyright IDG UK via MacWorld)</div>
<p>In Linux, andlabs UI toolkit is built upon the GTK+ widget set, which is designed to allow theming and style adjustments. While these types of themes can't substantially change the layout of components, they can significantly impact the sizing, padding, and colouring that a theme provides, and so affect the flow and sizing of an application's user interface. This can present a challenge for software developers who want to support the inherent flexibility in their programs. There are over a thousand GTK+ themes, and many can be found on the Gnome Look website: <a href="https://www.gnome-look.org/browse/cat/135/ord/top/">https://www.gnome-look.org/browse/cat/135/ord/top/</a>. GTK+ Theming is explored further in <a href="6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml">Chapter 6</a>, <em>Go-GTK - Multiple Platforms with GTK</em>. where we take a deeper look at the GTK+ toolkit.</p>
<p> These two screenshots compare a popular light and dark theme—clearly they can change more than simply the color scheme:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><img src="Images/cd0e0e02-5fa7-40ea-8fc5-998a2ff064fc.png" width="999" height="489"/></td>
<td class="CDPAlignCenter CDPAlign"><img src="Images/f199d48b-6a6d-4666-b381-227a0050350a.png" width="970" height="491"/></td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">GTK+ SuperFlat and Vertex themes compared</div>
<p class="mce-root">Each of these platform themes and configuration options can have an impact on the look and feel of the resulting application. If you're planning to support these visual styles, the best strategy is to avoid custom controls, and draw features and let the native controls adapt appropriately. If your application requires custom content or rendering, it will be important to choose a color palette that works well across many different themes or styles.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>Layouts in andlabs UI are composed of horizontal and vertical boxes, each of which contain a list of child elements, which may be stretched or static. Horizontal boxes are laid out on a single row, and every control within has the same height (that is, matching the height of the tallest element). In a vertical box, the controls are laid out in a single column and every element is the same width (being that of the widest item). If the container is larger than the minimum required to fit the items, any extra space is shared between any element that was appended as <em>stretchy—</em>if none stretch, the items will remain left- or top-aligned.</p>
<p>To provide a visual separation between groups of elements, we can use the <kbd>ui.Separator</kbd> control, which draws a thin line horizontally or vertically<em>—</em>remember to mark it as not stretchy within the box layout. If you wish to introduce space within your layout without the visual line, you can create a blank label (using <kbd>ui.Label("")</kbd>) and set its stretchy parameter to <kbd>true</kbd> when appended to a box.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Main email window</h1>
                </header>
            
            <article>
                
<p>The main layout box of our email client, <kbd>content</kbd>, is a horizontal box created with <kbd>ui.NewHorizontalBox()</kbd>, which contains the email list on the left (the first item to be appended), a vertical <kbd>ui.Separator</kbd>, and the detail view on the right (as it was the list item to be appended). The email list is composed of a <kbd>ui.Group</kbd> named <kbd>inbox</kbd>, which includes the <kbd>Inbox</kbd> title; note that our title label is followed by a series of spaces—this helps to create a more spacious layout in our application. Within this, we have a vertical <kbd>ui.Box</kbd>, which has a <kbd>ui.Label</kbd> for each of our emails.</p>
<p>As there is no grid layout available, the <kbd>detail</kbd> view is composed of various boxes. You can see that the <kbd>meta</kbd> box is a horizontal layout of two child instances of a vertical <kbd>ui.Box</kbd>: the first containing a vertical box of labels, the second being the list of values that will be filled later<span>—</span>the padding will provide a suitable gap between them.</p>
<p>As with the <em>hello world</em> example, we create a window with the <kbd>GoMail</kbd> title, a requested size, and set <kbd>false</kbd> for the <kbd>hasMenu</kbd> parameter. At the end of the sample, we set the content of the window and <kbd>Show()</kbd> it:</p>
<pre>window := ui.NewWindow(<span>"GoMail"</span>, <span>600</span>, <span>400</span>, <span>false</span>)<br/>window.SetMargined(<span>true</span>)<br/>window.OnClosing(<span>func</span>(*ui.Window) bool {<br/>   ui.Quit()<br/>   <span>return </span><span>true<br/></span>})<br/><br/>list := ui.NewVerticalBox()<br/>list.Append(ui.NewLabel(<span>"email1"</span>), <span>false</span>)<br/>list.Append(ui.NewLabel(<span>"email2"</span>), <span>false</span>)<br/>inbox := ui.NewGroup(<span>"Inbox"</span>)<br/>inbox.SetChild(list)<br/><br/>subject := ui.NewLabel(<span>"subject"</span>)<br/>content := ui.NewLabel(<span>"content"</span>)<br/>labels := ui.NewVerticalBox()<br/>labels.Append(ui.NewLabel(<span>"From "</span>), <span>false</span>)<br/>labels.Append(ui.NewLabel(<span>"To "</span>), <span>false</span>)<br/>labels.Append(ui.NewLabel(<span>"Date "</span>), <span>false</span>)<br/><br/>values := ui.NewVerticalBox()<br/>from := ui.NewLabel(<span>"email"</span>)<br/>values.Append(from, <span>false</span>)<br/>to := ui.NewLabel(<span>"email"</span>)<br/>values.Append(to, <span>false</span>)<br/>date := ui.NewLabel(<span>"date"</span>)<br/>values.Append(date, <span>false</span>)<br/><br/>meta := ui.NewHorizontalBox()<br/>meta.SetPadded(true)<br/>meta.Append(labels, <span>false</span>)<br/>meta.Append(values, <span>true</span>)<br/><br/>detail := ui.NewVerticalBox()<br/>detail.SetPadded(true)<br/>detail.Append(subject, <span>false</span>)<br/>detail.Append(meta, <span>false</span>)<br/>detail.Append(ui.NewHorizontalSeparator(), <span>false</span>)<br/>detail.Append(content, <span>true</span>)<br/><br/>content := ui.NewHorizontalBox()<br/>content.SetPadded(true)<br/>content.Append(inbox, <span>false</span>)<br/>content.Append(ui.NewVerticalSeparator(), <span>false</span>)<br/>content.Append(detail, <span>true</span>)<br/><br/>window.SetChild(content)<br/>window.Show()</pre>
<p>By dropping that code into the same <kbd>main()</kbd> wrapper that we used in the <em>hello world</em> application, we can run this user interface to see how the layout works. You should see something like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/1954760c-e09d-4adb-a98e-dc20ebdf861c.png" style="width:28.50em;height:9.58em;" width="419" height="141"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The main email browser layout</div>
<p><span>As you can see, we weren't able to use the</span> splitter <span>from the Walk example, but have simulated that look using</span> <kbd>ui.Separator</kbd><span>. Whilst the code is the same, they can behave differently across different operating systems, like the following expanded vertical <kbd>ui.Box</kbd> on macOS:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/dc748417-5991-4960-b9e5-236f5c18d369.png" style="width:33.58em;height:12.92em;" width="480" height="184"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">On macOS, the layout is different but will improve as we add content</div>
<p>The tree, or list, component on the left is a simple collection of labels at this stage, as there is no standard list component provided. Lastly, we have not rendered the labels in bold. This is possible, but only by using the draw API, which significantly complicates the code. Additionally, the use of drawing can cause parts of the user interface to vary from the loaded platform theme; for this purpose, we have stuck with the standard <kbd>ui.Label</kbd> component. In the preceding screenshot, you can see how different platforms have very different layouts at this stage—this will even out as we add more content.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Email compose dialog</h1>
                </header>
            
            <article>
                
<p>The layout of our compose dialog window is slightly more basic: a vertical box named <kbd>layout</kbd> manages the stack of controls into which the input elements are appended. We need to create another box, in horizontal arrangement, to place the <span class="packt_screen">To</span> label before the input field; make sure to turn the padding on to provide some spacing. Each of the text input boxes is created using <kbd>ui.NewEntry()</kbd>, which creates a simple one-line input field. Unfortunately, at the time of writing, there was no multi-line input field—a constraint that does not have an obvious workaround at this stage. The next release of the UI library will have a new <span><kbd>ui.MultilineEntry</kbd>, which will provide this functionality.</span></p>
<p>The last of the compose layout is the second horizontal box, <kbd>buttonBox</kbd>, which uses the familiar empty label trick to cause the <span class="packt_screen">Cancel</span> and <span class="packt_screen">Send</span> buttons to be right-aligned within the available space:</p>
<pre>window := ui.NewWindow(<span>"New GoMail"</span>, <span>400</span>, <span>320</span>, <span>false</span>)<br/>window.SetMargined(<span>true</span>)<br/>window.OnClosing(<span>func</span>(*ui.Window) bool {<br/>   <span>return </span><span>true<br/></span>})<br/><br/>subject := ui.NewEntry()<br/>subject.SetText(<span>"subject"</span>)<br/><br/>toBox := ui.NewHorizontalBox()<br/>toBox.setPadded(true)<br/>toBox.Append(ui.NewLabel(<span>"To"</span>), <span>false</span>)<br/>to := ui.NewEntry()<br/>to.SetText(<span>"email"</span>)<br/>toBox.Append(to, <span>true</span>)<br/><br/>content := ui.NewEntry()<br/>content.SetText(<span>"email content"</span>)<br/><br/>buttonBox := ui.NewHorizontalBox()<br/>buttonBox.SetPadded(true)<br/>buttonBox.Append(ui.NewLabel(<span>""</span>), <span>true</span>)<br/>buttonBox.Append(ui.NewButton(<span>"Cancel"</span>), <span>false</span>)<br/>buttonBox.Append(ui.NewButton(<span>"Send"</span>), <span>false</span>)<br/><br/>layout := ui.NewVerticalBox()<br/>layout.SetPadded(true)<br/>layout.Append(subject, <span>false</span>)<br/>layout.Append(toBox, <span>false</span>)<br/>layout.Append(content, <span>true</span>)<br/>layout.Append(buttonBox, <span>false</span>)<br/><br/>window.SetChild(layout)<br/>window.Show()</pre>
<p>As you can see in the preceding code, it uses the same <kbd>ui.NewWindow()</kbd> as the main email browser code—this is because andlabs UI doesn't differentiate between types of windows. Various dialog windows do exist but they are predefined for specific purposes, and so for our custom dialog, we will use a normal window. Therefore, you can test this code easily by using the same <kbd>main()</kbd> method as the previous code examples. Once run, you should see something similar to these screenshots:</p>
<div class="CDPAlignCenter CDPAlign">
<p class="mce-root CDPAlignLeft CDPAlign">The email compose window:</p>
</div>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8e5c1e80-b4dd-4b42-8472-d89e9f90d72f.png" style="width:25.83em;height:21.50em;" width="400" height="333"/></div>
<div>
<p>Email compose on macOS:</p>
</div>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="font-size: 1em;width:26.08em;height:14.00em;" src="Images/1a7f13b2-19f2-4ca7-bc67-f0423ef2cb31.png" width="390" height="209"/></div>
<p>Loaded on a Windows computer:</p>
<div class="CDPAlignCenter CDPAlign">
<div class="CDPAlignCenter CDPAlign packt_figref"><img style="font-size: 10pt;width:19.67em;height:15.33em;" src="Images/38aa675b-9541-4608-b100-671646a49f31.png" width="382" height="298"/></div>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Toolbar and menu</h1>
                </header>
            
            <article>
                
<p>Unfortunately there is currently no API support for menu or toolbar features in andlabs UI. Instead, we will simulate a toolbar by using a horizontal box, buttons, and a separator, which should provide the desired effect. As the separator can be very thin, we are padding it with an extra space on either side:</p>
<pre>toolbar := ui.NewHorizontalBox()<br/>toolbar.Append(ui.NewButton(<span>"New"</span>), <span>false</span>)<br/>toolbar.Append(ui.NewButton(<span>"Reply"</span>), <span>false</span>)<br/>toolbar.Append(ui.NewButton(<span>"Reply All"</span>), <span>false</span>)<br/><br/>toolbar.Append(ui.NewLabel(<span>" "</span>), <span>false</span>)<br/>toolbar.Append(ui.NewVerticalSeparator(), <span>false</span>)<br/>toolbar.Append(ui.NewLabel(<span>" "</span>), <span>false</span>)<br/>toolbar.Append(ui.NewButton(<span>"Delete"</span>), <span>false</span>)<br/>toolbar.Append(ui.NewLabel(<span>" "</span>), <span>false</span>)<br/>toolbar.Append(ui.NewVerticalSeparator(), <span>false</span>)<br/>toolbar.Append(ui.NewLabel(<span>" "</span>), <span>false</span>)<br/><br/>toolbar.Append(ui.NewButton(<span>"Cut"</span>), <span>false</span>)<br/>toolbar.Append(ui.NewButton(<span>"Copy"</span>), <span>false</span>)<br/>toolbar.Append(ui.NewButton(<span>"Paste"</span>), <span>false</span>)</pre>
<p class="mce-root"/>
<p class="mce-root">As you can see, we have specified that no buttons, separators, or spacers should expand, so the buttons will be left-aligned on the bar. This behavior could be changed if you'd prefer the buttons to spread out, by passing <kbd>true</kbd> for the <kbd>stretchy</kbd> parameter, for example, when appending the empty <kbd>ui.Label</kbd> controls.</p>
<p>We need to add this to the window—a new vertical box, called layout, is added and the previous content is packed underneath the toolbar. To provide some separation between this toolbar and the main content, we've called <kbd>SetPadded(true)</kbd>. Notice that the toolbar and space don't stretch (vertically), but the content layout does:</p>
<pre>layout := ui.NewVerticalBox()<br/>layout.SetPadding(true)<br/>layout.Append(buildToolbar(), <span>false</span>)<br/>layout.Append(content, <span>true</span>)<br/><br/>window.SetChild(layout)</pre>
<p>By combining this code with the main layout described, you should get an application that's approaching the look of the email user interface that we designed in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications</em>:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/3e9fb07f-cbd3-4f7b-939e-54bf9b637a90.png" style="width:34.42em;height:13.00em;" width="480" height="181"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A box of buttons is added to simulate a toolbar</div>
<p><span>Notice how the look can vary between different operating systems—the following is running on Microsoft Windows:</span></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/40acca23-2adf-4d8c-8236-a360b5e915bf.png" style="width:30.83em;height:17.08em;" width="664" height="368"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The addition of our toolbar box on Windows</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating with the GUI</h1>
                </header>
            
            <article>
                
<p>Now that the basic layout is coded, we will add functionality to present some data from a mock email server. As with the Walk example, we will load the model definitions and a test email server from the <kbd>github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client</kbd> package.</p>
<p><span>First of all, let's write the code to load content from our model into the user interface. We will create a <kbd>SetEmail(EmailMessage)</kbd> function that sets the content of an email into the user interface. To help with converting from <kbd>client.Email</kbd> and <kbd>time.Time</kbd> to <kbd>string</kbd>, we will use the helper <kbd>ToEmailString()</kbd> and <kbd>DateString()</kbd> functions. This function will be called during interface load and also whenever we change the selected email:</span></p>
<pre><span>func </span>(m *mainUI) setEmail(e *client.EmailMessage) {<br/>   m.subject.SetText(e.Subject)<br/>   m.to.SetText(e.ToEmailString())<br/>   m.from.SetText(e.FromEmailString())<br/>   m.date.SetText(e.DateString())<br/>   m.content.SetText(e.Content)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Next, we should update the email list. Instead of two dummy emails in the list, we create a new method that will iterate over all emails and add an item for each. To be able to set the email content when clicked, we have to move from <kbd>ui.Label</kbd> to <kbd>ui.Button</kbd> (no other andlabs UI standard controls have an <kbd>OnClicked</kbd> callback). As you can see, we set a new function for each button added, which sets the displayed email by calling the <kbd>setEmail()</kbd> function. The <kbd>captured</kbd> variable is required to avoid the for loop's re-definition of <kbd>email</kbd> in each iteration:</p>
<pre><span>func </span>(m *mainUI) listEmails(list []*client.EmailMessage) {<br/>   <span>for </span>_, email := <span>range </span>list {<br/>      item := ui.NewButton(email.Subject)<br/>      captured := email<br/>      item.OnClicked(<span>func</span>(*ui.Button) {<br/>         m.SetEmail(captured)<br/>      })<br/>      m.list.Append(item, <span>false</span>)<br/>   }<br/>}</pre>
<p>To invoke these new functions on load, we need to update the <kbd>main()</kbd> method. First, a new server is created with <kbd>client.NewTestServer()</kbd>, and then the functions we wrote are invoked with the appropriate information from the server:</p>
<pre><span>func </span>main() {<br/>   server := client.NewTestServer()<br/>   err := ui.Main(<span>func</span>() {<br/>      main := new(mainUI)<br/>      window := main.buildUI()<br/><br/>      main.listEmails(server.ListMessages())<br/>      main.setEmail(server.CurrentMessage())<br/>      window.Show()<br/>   })<br/>   <span>if </span>err != nil {<br/>      panic(err)<br/>   }<br/>}</pre>
<p>The last step for the main view is to open the compose window when the user clicks on the <span class="packt_screen">New</span> button. This is easily accomplished with another <kbd>OnClicked</kbd> handler, which builds and shows the secondary <kbd>ui.Window</kbd>:</p>
<pre>compose := ui.NewButton(<span>"New"</span>)<br/>compose.OnClicked(<span>func</span>(*ui.Button) {<br/>   compose := &amp;composeUI{}<br/>   compose.buildUI().Show()<br/>})</pre>
<p>Before we can send an email, we need to construct one from the controls in the compose user interface. This new <kbd>CreateMessage()</kbd> function simply gathers the information entered by the user and encapsulates it in a new <kbd>client.EmailMessage</kbd> that's ready for sending:</p>
<pre><span>func </span>(c *composeUI) createMessage() *client.EmailMessage {<br/>   email := &amp;client.EmailMessage{}<br/><br/>   email.Subject = c.subject.Text()<br/>   email.To = client.Email(c.to.Text())<br/>   email.Content = c.content.Text()<br/>   email.Date = time.Now()<br/><br/>   <span>return </span>email<br/>}</pre>
<p>Lastly, we want the <span class="packt_screen">Cancel</span> and <span class="packt_screen">Send</span> buttons to function as expected. Both should close the compose window, but the <span class="packt_screen">Send</span> button should first attempt to send the email. We add simple <kbd>OnClicked</kbd> handlers for these buttons, attached to the buttons which are appended to the <kbd>buttonBox</kbd> already created in the UI code:</p>
<pre>cancel := ui.NewButton(<span>"Cancel"</span>)<br/>cancel.OnClicked(<span>func</span>(*ui.Button) {<br/>   window.Hide()<br/>})<br/>buttonBox.Append(cancel, <span>false</span>)<br/>send := ui.NewButton(<span>"Send"</span>)<br/>send.OnClicked(<span>func</span>(*ui.Button) {<br/>   email := c.createMessage()<br/>   c.server.Send(email)<br/><br/>   window.Hide()<br/>})<br/>buttonBox.Append(send, <span>false</span>)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Once all of this code is put together, you can run it, and should see an application that looks something like these screenshots:</p>
<ul>
<li><span>The GoMail interface with test data loaded running on Linux:</span></li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><img style="border: 1em solid black;text-align: center;width:39.75em;height:16.75em;" src="Images/f04eeffe-bafc-4d02-a525-e022b2fb5aa1.png" width="600" height="253"/></div>
<ul>
<li class="mce-root">
<p>The same interface with a different theme (Minwaita):</p>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="Images/aa407337-87bf-4a7a-8e3c-46cc957e333e.png" style="width:41.58em;height:12.83em;" width="600" height="185"/></div>
<p class="mce-root"/>
<ul>
<li>The completed GoMail interface running on macOS:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="Images/77223f1f-3e44-4c64-922e-d5f0e9fba2a3.png" style="width:37.00em;height:14.50em;" width="592" height="232"/></div>
<ul>
<li>Running on macOS dark mode:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f699006a-9c7a-45e4-8411-a10cf778b52a.png" style="width:36.58em;height:15.67em;" width="818" height="351"/></div>
<ul>
<li><span>The GoMail interface running on windows 10:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/13203d19-894a-44e9-9e00-3bf360273dfc.png" style="width:38.42em;height:13.58em;" width="894" height="316"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background processing</h1>
                </header>
            
            <article>
                
<p>As you may have realized from the first line of andlabs UI code (<kbd>ui.Main(func() { ... })</kbd>), multithreading is something that needs to be considered when building using this API. This is due to the fact that most of the toolkits it integrates with will require graphical updates to all execute on the same thread (often, the main application thread). The andlabs UI aims to hide this complexity by managing the threads internally and provides helper methods to manage this.</p>
<p>As a result of this design, any user interface updates outside of the <kbd>ui.Main()</kbd> setup (or callbacks on controls created there) must be passed to the <kbd>ui.QueueMain()</kbd> method in the form of a function, as with the initial setup. This allows andlabs UI code to process the updates on the appropriate thread for the current framework. The following code illustrates how a label's text could be changed as the result of some background processing:</p>
<pre>ui.<span class="pl-c1">QueueMain</span>(<span class="pl-k">func</span> () {<br/>   label.SetText("background")<br/>})</pre>
<p>Callbacks such as <kbd>OnClicked()</kbd> and <kbd>OnClosing()</kbd> also take a <kbd>func()</kbd> parameter, just as the <kbd>ui.QueueMain()</kbd> function does. This code will automatically be executed on the correct thread, so there is no additional complexity to worry about.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example</h1>
                </header>
            
            <article>
                
<p>To look at the impact of background threads, we will add another feature to the GoMail application—updating the user interface when a new email arrives. To enable this, we must listen to the <kbd>Incoming</kbd> channel that our <kbd>client.EmailServer</kbd> type defines.</p>
<p>First, we create a function that will handle incoming email. This is simply a wrapper to a new method, <kbd>appendEmail(*client.EmailMessage)</kbd>, that handles adding new items to the email list. But it must create a wrapping <kbd>func()</kbd> and pass it to <kbd>ui.QueueMain</kbd> so that the code executes on the correct thread:</p>
<pre><span>func </span>(m *mainUI) incomingEmail(email *client.EmailMessage) {<br/>   ui.QueueMain(<span>func</span>() {<br/>      m.appendEmail(email)<br/>   })<br/>}</pre>
<p>Then we add a little more code to our <kbd>main()</kbd> method to listen for incoming emails from <kbd>client.EmailServer</kbd>. The following code requests the incoming channel from the server model and then loops over any emails that are communicated through the channel, triggering our handler for any that arrive:</p>
<pre><span>go func</span>() {<br/>   incoming := server.Incoming()<br/>   <span>for </span>email := <span>range </span>incoming {<br/>      main.incomingEmail(email)<br/>   }<br/>}()</pre>
<p>With these updates running, the same client will trigger a new email to appear after 10 seconds. With Go, the concurrency is simple to handle, and the preceding code shows how andlabs UI allows us to benefit from that in the handling of our user interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Challenges with multiple native GUIs</h1>
                </header>
            
            <article>
                
<p>In this chapter, we've seen how a single code base can create applications that work with native widget toolkits across multiple platforms. This is a very powerful approach to quickly develop graphical apps that are consistent with the platform style to provide a familiar user experience. However, this approach also has challenges you may need to overcome for your project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Consistent style</h1>
                </header>
            
            <article>
                
<p>While it may not be obvious that a consistent style is important when choosing to adapt to the native toolkit, there are many parameters involved in style and application design. Does your design team or product specialist have defined standards or approaches to user experience that they wish to apply across all applications and platforms? Are there brand guidelines that you should be including in your interface design?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Brand styles</h1>
                </header>
            
            <article>
                
<p>As andlabs UI is a toolkit that aims to provide an abstraction to standard widgets (and therefore using the current platform's look and feel), customization options are limited. The only facility to introduce custom elements is the <kbd>ui.Area</kbd> widget and the draw features we explored. This enables a company font or logo to be drawn (support for loading images is said to be coming in a later version) at a certain location in the interface.</p>
<p>If you are looking for further abilities to customize or theme the applications you are building, then andlabs UI may not be the right solution for your project. It's probably better to explore GTK+ or Qt (which we cover in <a href="6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml">Chapter 6</a>, <em>Go-GTK - Multiple Platforms with GTK</em>, and <a href="68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml">Chapter 7</a>, <em>Go-Qt - Multiple Platforms with QT</em>) or skip to Part 3 (<a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml"/><a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a>, <em>Shiny - Experimental Go GUI API</em>, <a href="48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml"/><a href="48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml"/><a href="48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml"><span>Chapter </span>9</a>, <em>nk - Nuklear for Go</em> and <a href="2476a1b6-0915-496b-8290-7a673f533aca.xhtml">Chapter 10</a>, <em>Fyne - Material Design based GUI</em>) and read about other approaches to graphical application design.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">User experience</h1>
                </header>
            
            <article>
                
<p>Using a single API does not guarantee consistency across multiple operating systems. The toolkits used may have different layout defaults, with different padding or alignment, for example. The andlabs UI (and the underlying andlabs <kbd>libui</kbd>) API is designed to provide an application that's as close to the OS defaults as possible. If you have specific requirements that should be met regarding the user interface appearance (other than the style), such as layout or alignment, you may need to write special code. Using Go's approach to build tags and load different code for different operating systems, you can adapt your code to behave slightly differently on different platforms.</p>
<p>If we look at the previous <em>hello world</em> example, we can update the code to adjust the quit button's layout on different platforms. Here, we will load a right-aligned button for macOS, but leave it as full width for other systems.</p>
<p>The code to create the <span class="packt_screen">Quit</span> button is removed from <kbd>hello.go</kbd> and replaced with a line that calls into a new <kbd>layoutQuit()</kbd> function:</p>
<pre>button := layoutQuit()</pre>
<p>In a new file, called <kbd>custom_other.go</kbd>, we move the previous button definition into a new <kbd>layoutQuit()</kbd> function. Additionally, a conditional build comment is added at the top to ensure that this file is not included for macOS (darwin). Note that the text has also changed to <span class="packt_screen">Exit</span>, to illustrate how platforms can be adapted:</p>
<pre><span>// </span><span>+build</span><span> !darwin<br/></span><span><br/></span><span>package </span>main<br/><br/><span>import </span><span>"github.com/andlabs/ui"<br/></span><span><br/></span><span>func </span>layoutQuit() ui.Control {<br/>   button := ui.NewButton(<span>"Exit"</span>)<br/>   button.OnClicked(<span>func</span>(*ui.Button) <br/>   {<br/>      ui.Quit()<br/>   })<br/><br/>   <span>return </span>button<br/>}</pre>
<p>That's all pretty straightforward; then we add another file, named <kbd>custom_darwin.go</kbd>, where we define the alternative behavior. In this file, we don't need the build definition, as the filename provides that for us. In this implementation, we create a horizontal <kbd>ui.Box</kbd> with the <span class="packt_screen">Quit</span> button padded to the right using an empty, stretchy <kbd>ui.Label</kbd>, as follows:</p>
<pre><span>package </span>main<br/><br/><span>import </span><span>"github.com/andlabs/ui"<br/></span><span><br/></span><span>func </span>layoutQuit() ui.Control {<br/>   button := ui.NewButton(<span>"Quit"</span>)<br/>   button.OnClicked(<span>func</span>(*ui.Button) {<br/>      ui.Quit()<br/>   })<br/><br/>   box := ui.NewHorizontalBox()<br/>   box.Append(ui.NewLabel(<span>""</span>), <span>true</span>)<br/>   box.Append(button, <span>false</span>)<br/><br/>   <span>return </span>box<br/>}</pre>
<p><span>Using this approach, it's possible to adapt your user interface to appear slightly differently on specific platforms. This is a useful approach if you need to have different widget layouts on different systems:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/09a2c322-a5d9-424b-91d0-79da426968dc.png" style="width:8.42em;height:6.92em;" width="103" height="83"/>  <img src="Images/79ca5af6-fcb5-4ffb-9b2b-94904eb8d102.png" style="width:8.17em;height:6.75em;" width="110" height="91"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The updated hello app (left) and <span>layout for macOS (right)</span></div>
<div>
<div class="CDPAlignCenter CDPAlign packt_figref"/>
</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>Due to various aspects of multiple-platform abstraction (including the variation in style), it can take a long time to test an andlabs UI application. As well as developing an application that, by design, looks and works slightly differently across Windows, macOS, and Linux, the application may be subject to additional user customization. All three of those platforms offer some user options to change the user interface—Windows allows color adjustments, macOS similarly has highlight colors and recently added a dark mode, and GTK+ (the Linux implementation) offers full theme support.</p>
<p>Part of testing an application built in this way is to decide which platforms and variations you will support. Should your Windows users all be on the latest version of Windows, or will you ensure the application works with older widget styles? On macOS, are you checking that your interface reads well in dark and light <span>modes</span>? With Linux, are you supporting (and therefore testing) a variety of different themes?</p>
<p>It's highly recommended that you have a configured test environment for every variation of a system that can impact how your application looks. Thankfully, this is made easier with virtual machines<span>—</span>you no longer need to have rows of computers or complex multi-boot configurations. If you can load and set up each of these configurations in separate virtual machine images, it should be possible to test all of these potential variations. Note that macOS licensing requires that it's run on a Macintosh computer<span>—</span>even if within a virtualized environment.</p>
<p>Of course, the impact of this cross-platform approach may be wider-reaching<span>—</span>operating systems have many non-visible differences as well. It's important to load and fully run through your application to check all features, simply looking at the user interface isn't enough to satisfy a solid test strategy. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-compilation</h1>
                </header>
            
            <article>
                
<p><span>Due to the way that libui builds against native widget APIs, the cross-complication is more complicated than a simple Go application. As well as the developer tools that are required for building an application with andlabs UI for the current computer, you will need to have access to the widget library definitions to successfully cross-compile. In some instances, that means a simple library installation, in other cases it may be necessary to install the operating system's <strong>Software Development Kit</strong> (<strong>SDK</strong>). Let's look at the details for each target platform.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>As with normal Go cross-compilation, we start by setting the environment variable, <kbd>GOOS</kbd> (and optionally <kbd>GOARCH</kbd>), to define the target platform of our build. To work with libui, we need to turn CGo back on (this is disabled when cross-compiling by default) using <kbd>CGO_ENABLED=1</kbd>. Simply executing the build with this setup would likely fail due to a missing library or SDK, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a26eff48-0c0b-47f6-b177-80f92bc64990.png" style="width:38.08em;height:13.92em;" width="670" height="245"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Building on macOS for Linux fails</div>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7ba40449-f2aa-4734-937d-dd5a8c3f5a05.png" style="width:39.92em;height:13.50em;" width="642" height="217"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A Linux computer failing to compile for macOS</div>
<p><span>Let's look into how cross-compilation can be enabled for various configurations.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building for Linux on macOS or windows</h1>
                </header>
            
            <article>
                
<p>To be able to cross-compile for Linux, the main requirement is the GTK+ library, which provides the widgets for andlabs UI on Linux. Installing this is a little more difficult as the operating systems don't come with a standard package manager, but if you follow the steps described here it should be possible. The process also involves installing the cross-compiling toolchain, much like other examples in this section. The details for setting up cross-compilation can be found in <em>Cross compiling for Linux with CGo</em> section given in the <a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml">Appendix</a>, <em>Cross-Compiler Setup</em>. The main steps are outlined here for quick reference.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">macOS</h1>
                </header>
            
            <article>
                
<p>To cross-compile with macOS, we need to install a package manager. The easiest and most complete is Homebrew—you can install it from <a href="https://brew.sh/">https://brew.sh/</a>. The recommended toolchain for Linux compilation is <kbd>musl-cross</kbd>, which is in the <span><kbd>FiloSottile/musl-cross/musl-cross</kbd> package. With Homebrew installed, execute the following commands in your Terminal window</span>:</p>
<ol>
<li><kbd>brew install gtk+3</kbd></li>
<li><kbd><span>export HOMEBREW_BUILD_FROM_SOURCE=1</span></kbd></li>
<li><kbd>brew install <span>FiloSottile/musl-cross/musl-cross</span></kbd></li>
</ol>
<p>Once that is completed, you should be able to build for Linux by setting the <span><kbd>GOOS=linux</kbd>, </span><span><kbd>GOARCH=amd64</kbd>, </span><span><kbd>CGO_ENABLED=1</kbd>, and <kbd>CC=x86_64-linux-musl-gcc</kbd> environment variables with <kbd>CXX=x86_64-linux-musl-g++</kbd>. You can then build as normal, resulting in a Linux executable instead of macOS:</span></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/e21d08e5-1c6a-40bb-a186-3f117d939eb6.png" style="width:27.25em;height:10.75em;" width="662" height="260"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Building a Linux executable from macOS</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Windows</h1>
                </header>
            
            <article>
                
<p>Cross-compiling with Windows is a little more complicated as there is no standard package manager. The recommended approach is to install Cygwin (from <a href="https://cygwin.com/install.html">cygwin.com/install.html</a>). Then install the gtk3 and linux-gcc (cross compiler) packages. From there, follow the preceding instructions for macOS, but use <kbd>CC=linux-gcc</kbd> and <kbd>CXX=linux-g++</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building for windows on Linux or macOS</h1>
                </header>
            
            <article>
                
<p>Building for Windows from another platform requires an installation of mingw (similar to what we installed on Windows to support CGo). <span>The details for setting up cross-compilation can be found in the <em>Cross compiling for Windows with CGo</em> section of an </span><a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml">Appendix</a>, <em>Cross-Compiler Setup</em><span>.</span></p>
<p><span>The main steps are outlined here for quick reference:</span></p>
<p><span>Using your package manager (Homebrew on macOS and various on Linux), install the mingw package, which is usually named <kbd>mingw-w64-clang or w64-mingw</kbd>. If you cannot find this package, it can be installed directly using the instructions at </span><a href="https://github.com/tpoechtrager/wclang">https://github.com/tpoechtrager/wclang</a><span>. </span></p>
<p>Once installed, we need to set up the appropriate build flags—specifically <kbd><span>CC=x86_64-w64-mingw32-clang</span></kbd> (for the C toolchain) and <kbd>CXX=x86_64-w64-mingw32-g++</kbd> (for C++ requirements). Assuming you also have set <kbd>CGO_ENABLED=1</kbd> and <kbd>GOOS=windows</kbd>, you can build the Windows binary. Looking at the resulting <kbd>hello.exe</kbd> file, you can see it's an MS Windows binary:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/cf726ec5-1d71-4f28-8ae5-b2a3d70e8dd4.png" width="642" height="169"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span><span>Using mingw (x86_64-w64-mingw32-clang), we built a Windows-native UI application on Linux</span></span></div>
<p>When building from macOS, you can use Homebrew to install the <span>mingw-w64 package.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building for macOS on Linux or Windows</h1>
                </header>
            
            <article>
                
<p><span>Cross-compiling for mac requires that the macOS SDK is available to link against. When building from a Linux or Windows computer, we must download and install the SDK and also update our build toolchain to use it. The easiest way to do this is with the <em>osxcross</em> tool. </span><span>The details for this setup can be found in the <em>Cross compiling for macOS with CGo</em> section of an </span><a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml">Appendix</a>, <em>Cross-Compiler Setup</em><span>. The main steps are outlined here for quick reference using a Linux terminal—the Windows setup is similar once you have installed the cygwin or mingw terminals.</span></p>
<p>First, we need to download the macOS SDK, which is bundled with Xcode. D<span>ownload <kbd>XCode.dmg</kbd></span> from the Apple download site at <a href="https://developer.apple.com/download/more/?name=Xcode%207.3">https://developer.apple.com/download/more/?name=Xcode%207.3</a> (7.3.1 is recommended for osxcross). Next, install the osxcross tools from <a href="https://github.com/tpoechtrager/osxcross">github.com/tpoechtrager/osxcross</a> (full installation details are available at that URL or in the Appendix). Completing the installation will have extracted the macOS SDK and created the compilation toolchain that will build against these installed APIs<span>.</span></p>
<p>And now we are ready to build. As well as the previous environment variables, we add <span><kbd>CC=o32-clang</kbd>, after which our build command should succeed. Here you can see that our Linux computer managed to create a macOS 64-bit Mach-O executable file named <kbd>hello</kbd>:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f7c76b31-1997-4acd-8d1b-2e45e8dfa85a.png" width="642" height="147"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><br/>
Using osxcross (o32-clang), we built a macOS-native UI application on Linux.</div>
<p>The process for Windows is similar and full details can be found in the <em>Cross compiling for macOS with CGo</em> section of an <a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml">Appendix</a>, <em>Cross-Compiler Setup</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A better solution</h1>
                </header>
            
            <article>
                
<p><span>These steps are complicated and potentially fragile. Due to these challenges, a new project was created to assist in the cross compilation of andlabs UI applications. You can find out more and compare the process with those detailed here by visiting the project homepage at <a href="https://github.com/magJ/go-ui-crossbuild/">https://github.com/magJ/go-ui-crossbuild/</a></span><span>.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored andlabs UI toolkit, which provides a single API to build graphical Go applications using the native widgets of the running operating system. We stepped through getting set up to build an andlabs UI application on macOS, Windows, and Linux, and showed how a simple <em>hello world</em> application could be run on each system from a single Go source file. We then looked in detail at the widget API for building applications and the drawing APIs for custom rendering.</p>
<p>With this knowledge, we revisited the GoMail application from <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml"/><a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications</em>, and built the user interface again using andlabs UI library. While there were some limitations with the current version, we were able to simulate some of the missing widgets to almost completely recreate the application. The benefit, of course, is that we could then run the GUI on Windows, Linux, and macOS from the same source code.</p>
<p>Testing an application built with a library where the user interface varies, and ensuring it looks as consistent as possible, may be difficult depending on your app design. Additionally, the simple cross-compilation that Go provides is significantly harder with andlabs UI due to the way it implements using operating-system-specific widget APIs. We explored how to work within these constraints and build applications for different platforms. </p>
<p><span>In the next two chapters, investigate existing cross-platform widget libraries that have been made available through Go APIs. GTK+ (which we saw being used by andlabs UI for Linux) and QT both present a standard widget set, which will seem familiar to users of existing desktop applications. We'll start by exploring GTK+ in detail in the next chapter.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>