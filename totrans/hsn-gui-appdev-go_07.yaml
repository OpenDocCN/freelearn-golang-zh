- en: andlabs UI - Cross-platform Native UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the Walk API we explored in the previous chapter, andlabs UI aims to create
    a Go API on top of operating system native widgets, but, unlike Walk, andlabs
    UI project supports multiple operating systems with a single API. This means that
    graphical applications created using the API can be compiled and run on Windows,
    macOS, and Linux using the same source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore cross-platform native applications that match
    the operating system''s look and feel. In particular, we will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Background and history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with andlabs UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic API for multiple platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges with multiple native GUIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we get started with the benefits and complexities of a cross-platform
    API using native widget toolkits, let's look more at the background of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Background and history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The andlabs UI project was created to provide a simple-to-use way to create
    native graphical applications using Go. The API is minimal as it aims to provide
    only what is necessary to create GUI programs. The core is a C library, which
    hides the platform-specific APIs, allowing the main library to manage the idiomatic
    considerations for a Go GUI API. Recently, the C library (libui) was moved to
    a separate project, which is included in the Go project for developers' convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a demonstration of the widgets available included in the project—when
    run on a Linux computer, it will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d518b369-6ae8-4ce1-aca3-21d7b12c60a0.png)'
  prefs: []
  type: TYPE_IMG
- en: The widget demo from andlabs UI
  prefs: []
  type: TYPE_NORMAL
- en: As a platform-native implementation, the widgets in andlabs UI will look different
    on each operating system. On Windows and macOS, the library uses the native widget
    set, and on Linux it uses the GTK+ library. This approach creates applications
    that are consistent with other software on the current computer and so should
    be simple for users to understand. This approach is powerful and has substantial
    benefits, but can add complications for application developers. We will explore
    the benefits and challenges of such an approach within this chapter, but first
    let's get running with a simple *hello world* application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with andlabs UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Andlabs UI is easy to get started with on most platforms, but the details vary
    from system to system. Due to the nature of linking to many different operating
    systems' native widget toolkits, there can be some hidden complexities, especially
    when developing Linux-based applications. Before we can build our first andlabs-based
    application GUI, there is some setup required. We need to prepare the current
    development environment to work with native widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an API that utilizes the native widgets for each platform, the prerequisites
    vary for Windows, macOS, and Linux. Any packages that need to be installed in
    this section will be required by any users of the applications that you develop
    as well. It's also necessary to have CGo running (the ability for Go code to call
    C functions is illustrated in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml),
    *Go to the Rescue!*), which may require the installation of additional build tools.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The native widgets used on Windows are the Common Controls—the same used by
    the Walk library that we explored in detail in the [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications*. As they are native to the operating
    system, no installation is required when using Windows Vista or later. If you
    want to support earlier versions (back to Windows XP), it's possible if you install
    at least version 6.0 of `ComCtl32.dll`.
  prefs: []
  type: TYPE_NORMAL
- en: Andlabs UI, like many of the other toolkits featured in this book, requires
    the presence of CGo to utilize native libraries. On a full development system,
    it's likely that this is already set up. If you're unsure, or would like a reminder
    of how to set up the Cgo dependencies, please check *Setting up CGo* section from
    the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml), *Installation Details*.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing for macOS, the native widgets are used directly. As these are
    provided by the operating system for every recent version of macOS, no additional
    libraries are required.
  prefs: []
  type: TYPE_NORMAL
- en: CGo support is required for andlabs UI and this requires XCode command-line
    tools to be installed. If you have not already set this up please check the *Setting
    up CGo* section from the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml), *Installation
    Details**.*
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Linux, andlabs UI uses the GTK+ widget library (which we will explore in
    detail in [Chapter 6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml), *Go-GTK - Multiple
    Platforms with GTK*) and so the library must be installed on your computer. If
    you have the Gnome desktop installed, or other applications that use GTK+ (such
    as Gimp), the library will already be installed. If not, you will need to install
    this dependency using your system's package manager.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a simple task, the package name varies across systems—it will
    probably be called `gtk3-devel`, `libgtk-3-dev`, or `gtk3`. Install this in the
    usual manner and you'll be ready to set up andlabs UI library.
  prefs: []
  type: TYPE_NORMAL
- en: To enable CGo, required by andlabs UI, on Linux you must have a compiler (gcc
    or clang) installed. This is often already installed on a development Linux installation,
    but if you're unsure, you can follow the *Setting up CGo* section from the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml), *Installation
    Details*.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The setup of andlabs UI is very simple—it only requires you to get the library
    using Go tools. You only need to execute `go get github.com/andlabs/ui`. This
    works exactly the same on Windows, macOS, and Linux, assuming that you have Go
    installed and running (if not, check out *Installing Go* section in the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml),
    *Installation Details*). If you encounter an error, first check that your Go installation
    is up to date—these issues often get fixed quickly—and that you have set up CGo
    as described.
  prefs: []
  type: TYPE_NORMAL
- en: Rebuilding the UI library (workaround)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The libui library that andlabs UI is built upon is packaged with the main library,
    but sometimes this gets out of date or is not compiled for the exact configuration
    of your computer. If you see an error when this happens, such as `relocation R_X86_64_32S
    against '.rodata' can not be used when making a shared object`, these instructions
    will help. If you see no error when installing, please skip these tips!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will rebuild the libui file for your computer. It assumes
    a Linux bash shell, as this situation is most likely to occur on a Linux computer.
    This is not going to be needed for anyone using the applications you build—just
    for setting up your development environment. The libui project is downloaded from
    Github and built using standard cmake tools. Be sure to specify the `-DBUILD_SHARED_LIBS=OFF`
    parameter, as we must build a static library to embed in the Go library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9ad32e8-e03a-4a29-89a3-06212cfe6276.png)'
  prefs: []
  type: TYPE_IMG
- en: Rebuilding libui if the packaged version doesn't work
  prefs: []
  type: TYPE_NORMAL
- en: The commands are designed to work without any environment configuration, but
    you will need cmake installed—your system's package manager will be able to install
    it if you find it isn't installed. Once the build is complete, the resulting library, `out/libui.a`,
    should be moved into the UI project and renamed appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the library is installed, it''s time to write some code. The following
    sample is andlabs UI equivalent of the *hello world* example we used in the [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications*. Start by entering the following code into a new file, named `hello.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty straightforward, but there are a few things that we should
    cover, so let's step through it. As usual, for a simple graphical Go app, we are
    using the `main` package and importing the toolkit library, before defining the
    `main()` function. We then call the main entry point for an andlabs UI application,
    `ui.Main()`, which takes a single function that will build and show the app's
    GUI. If an error occurred, we cause the binary to panic, as the interface couldn't
    be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: In our user interface code, we first set up a window with `ui.NewWindow()`,
    with a title and a default size, and the final parameter indicates whether the
    window should have a menu bar. We turn on the default margin (padding) and assign
    a closing function to exit the app by calling `ui.Quit()`. Next, a new button
    is created with `ui.NewButton()`, labelled `Quit`, that also exits the application
    when clicked. These components are laid out using a container with `ui.NewVerticalBox()`.
    A `Hello World!` label and the `Quit` button are both added. The `Append()` method
    of `ui.Box` takes a Boolean parameter, `stretchy`—if this is set to `true`, the
    component will expand to fill the available space. Last, we set the content of
    the window with `SetChild()` and show it using `Show()`.
  prefs: []
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building this sample app is trivial. For example, in the following screenshot,
    we are running a Terminal on a Linux computer and simply execute `go build hello.go`.
    This creates an executable file that can be run directly without needing the Go
    tools installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3de9f96-2285-4865-b01d-914b9e26b047.png)'
  prefs: []
  type: TYPE_IMG
- en: Building for the current Linux environment
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on a Windows computer (as long as gcc is in the command-line path—see
    *Prerequisites* section mentioned earlier) is just as simple as on Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28d70e8c-5e3d-472b-8e4e-42f0d564e00c.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the hello world app on Windows
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, we are building the applications on the platform they will
    run. Cross-compilation, one of the strengths of the Go toolchain, is more complicated
    with andlabs UI.
  prefs: []
  type: TYPE_NORMAL
- en: Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application can be run from the command line (`./hello` on Linux or macOS,
    and `hello.exe` on Windows) or simply by double-clicking the file icon from your
    system''s file browser. Either way, the result should be the appearance of a familiar
    *hello world* window. This will look very similar across multiple operating systems,
    but the look and feel will vary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows this is the same as Walk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1024499-c9e2-417a-88e0-f1dffbdf98b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Andlabs UI hello world on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e5a1ab8-3a60-469b-a144-f6dd50e61764.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hello world running on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d5f8a00-07a0-435b-9a0e-956a805eebee.png)'
  prefs: []
  type: TYPE_IMG
- en: Generic API for multiple platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The andlabs UI project provides a generic API that wraps operating-system-native
    widgets on Windows, Linux, and macOS. Due to this approach, it's largely limited
    to the *lowest common denominator* level of functionality, but considering how
    similar these toolkits are, the resulting API is surprisingly rich.
  prefs: []
  type: TYPE_NORMAL
- en: All widgets inherit from the `ui.Control` interface, which defines the `Show()`,
    `Hide()`, `Enable()`, and `Disable()` methods that all controls must implement
    (with obvious expected behavior). Additionally, it defines the `LibuiControl()`
    and `Handle()` methods, which provide a pointer to the low-level libui and operating-system
    widgets, respectively. The use of those methods is generally not recommended and
    so not covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When compared to the Qt inspired Walk API of the [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    *Walk - Building Graphical Windows Applications*, the layout capabilities of andlabs
    UI appear limited with fewer controls managing the GUI visual flow. Native controls
    (while broadly similar) are programmed differently and not necessarily compatible
    with the same high-level layout definitions. What you will see in the following
    section is that containers are typically set up to expect one child, which is
    laid out using a `ui.Box` control. Many widgets, which could be considered containers
    in other toolkits, are managed as a single control in andlabs UI (such as `ui.RadioButtons`)
    so that the operating-system-specific implementation can be handled internally.
  prefs: []
  type: TYPE_NORMAL
- en: Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the widgets defined in andlabs UI implement the `Control` interface and,
    as such, can be shown, hidden, enabled, or disabled and set as the content of
    a window through `SetChild()` (with the obvious exception of `ui.Window`). A window
    may not be the child of any other `ui.Control`, for obvious reasons. The definition
    of `show()` and `hide()` for a window will be set by the operating system or widget
    toolkit, as will the manner of disabling the window content.
  prefs: []
  type: TYPE_NORMAL
- en: Box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is probable that any window will have its content set to a Box—this is because
    it's the only control that provides a way to group multiple controls together.
    It's a control with no visible container, which is the basic layout mechanism
    within andlabs UI. You can create a new box using `ui.NewHorizontalBox()` or `ui.NewVerticalBox()`,
    which lays out its child controls horizontally or vertically in a linear arrangement.
    In a horizontal arrangement, the child items will all have the same height (which
    will match the height required for the tallest child), and in a vertical (stacked)
    configuration, they will all have the same width.
  prefs: []
  type: TYPE_NORMAL
- en: The method of adding child controls to a box is to call the `Append()` function,
    which takes a `ui.Control` child parameter and a `bool` stretchy parameter. The
    **child** will be added to the list of the components, and the **stretchy** parameter
    determines how the available space should be filled. When the stretchy parameter
    is `true`, the item will expand to fill extra space; if it's `false`, the minimum
    size will be observed. If multiple components have stretchy switched on, the spare
    space will be divided equally between them.
  prefs: []
  type: TYPE_NORMAL
- en: It's often going to provide a better visual flow for your user interface if
    widgets are separated by some space. There is a suitable method provided, `SetPadded()`,
    which will set a standard space between child widgets in the box. This size is
    set by the widget toolkit's standard metrics, and will vary from platform to platform.
    The padding applied in this way is placed between the child components—for outer
    (surrounding) space, you should set a margin. The margin is available in controls
    which embed a child control—dubbed `containers` in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers, or controls that allow us to embed another control, are typically
    identified by the existence of a `SetChild()` or `SetMargined()` function in their
    type definition. As these controls embed one another, a margin around the content
    is often desirable—this is the outer equivalent of the padding in `ui.Box`. This
    can be turned on using `SetMargined(true)`, and the system-defined margin size
    will be introduced around the child control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following containers are defined as part of andlabs UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Window` controls describe an application window and are the main entry point
    for an andlabs UI graphical application. The main content is set using `SetChild()`.
    Margins should probably be switched on if it''s a simple content window, or left
    off if you are adding further container controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Group` defines a frame around a child widget (assigned with `SetChild()`)
    with a title (passed to `ui.NewGroup()`). The appearance of the group control
    will vary across systems; on some it may be a box around the child, and on others
    it may be invisible. As with the window controls, you should consider the child
    content before deciding whether the margins should be enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tab` is slightly different from the others, as it may contain multiple child
    controls—but only one is visible at a time. As there are multiple child controls,
    the method to add the child is `Append(string, Control)—`the first parameter is
    the title to be displayed on the tab and the second is the child for this new
    tab. To accommodate multiple child controls, the margin control is adapted also—you
    will need to call `SetMargined(int, bool)` where the first parameter is the tab
    index, and the latter is the usual parameter to turn margins on or off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's all of the controls that manage others, let's look at the details of
    the main widgets that an andlabs UI application is constructed from.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The remaining widgets will be familiar to to any developer of desktop graphical
    applications, or indeed anyone who uses them. Provided here is a quick overview
    for the features or limitations of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Button`: A standard `pushbutton` with a label, and an `onClicked` callback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Checkbox`: A toggled entry that is either checked or unchecked; an `onToggled`
    callback will trigger on change'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Combobox`: A widget that provides a list of strings to select from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTimePicker`: A field for entering date and/or time—the configuration is
    set by different constructor functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entry`: A single-line text-entry widget, which can be read-only; it supports
    an `onChanged` handler for change events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label`: A simple read-only text component for annotating the user interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgressBar`: A horizontal bar to indicate progress; values range from 0 to
    100'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RadioButtons`: A control for presenting a list of options, such as check boxes,
    but where only one can be selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Separator`: A horizontal or vertical line to visually separate other controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider`: A horizontal bar for selecting between the set min and max integer
    values by moving an indicator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spinbox`: An entry box for selecting an integer between the min and max values
    with the up and down buttons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A noticeable omission on this list is menu or toolbar widgets; they are not
    included in andlabs UI toolkit at the time of writing. Next, we'll look at a potential
    workaround for menus (which unfortunately will not work for a toolbar) by accessing
    the underlying libui.
  prefs: []
  type: TYPE_NORMAL
- en: Menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of writing, andlabs UI doesn''t expose a menu API (despite `ui.NewWindow()`
    taking a `hasMenubar` parameter). There is a project underway to properly expose
    menu functionality to the Go API, but for now it''s only available if you work
    with the underlying libui C code. The menu defined in the C library can be accessed
    from a Go project by adding a little CGo code, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code snippet sets up a click handler for a New menu item, and a quit handler
    for the Quit menu item (which is a special item due to macOS handling a quit menu
    item differently). Then we have a `loadMenu()` function, which sets up a File
    menu to which the child items are added, with a separator, and a currently-empty
    Help menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile this code correctly will require the `cfuncs.go` file knowing where
    the header file and C library are stored. Before running this code make sure that
    the `CFLAGS` and `LDFLAGS` show the correct locations. While the code to build
    a menu is not very complicated, the CGo configuration and linking is rather complex,
    and as such, may not be recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddb3b8fe-6bac-4a65-9b06-c98d54710f62.png)'
  prefs: []
  type: TYPE_IMG
- en: Launching the menu example
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should look similar to this screenshot, which was taken on a Linux
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8606215-3a10-45b4-b741-e9fe9b2824c0.png)'
  prefs: []
  type: TYPE_IMG
- en: The andlabs libui menu
  prefs: []
  type: TYPE_NORMAL
- en: There is a complete menu project in the code repository for this book. Unfortunately,
    it isn't a cross-platform project and may not execute correctly on every operating
    system or version of Go.
  prefs: []
  type: TYPE_NORMAL
- en: Area and drawing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ui.Area` widget presents a canvas-like control—a surface that can be drawn
    on using Path and other drawing primitives. At the time of writing, these APIs
    are all part of the `ui` package, but it may soon move to `ui/draw` in an effort
    to separate them from the main controls API. An area can either be the size of
    the space it occupies or it can be larger, in which case it will be embedded in
    a scrollable control. The desired behavior is chosen based on whether `ui.NewArea(handler)`
    or `ui.NewScrollingArea(handler, width, height)` is called (where width and height
    are the desired content size).
  prefs: []
  type: TYPE_NORMAL
- en: The logic behind an area is `ui.AreaHandler`, the first parameter to either
    of the area constructor functions. Its `Draw(*ui.Area, *ui.AreaDrawParams)` function
    is invoked by the toolkit whenever the area needs to be redrawn, the first parameter
    being the area it's registered on and the second providing context, such as the
    clipping rectangle to be filled. As well as drawing the content of an area, the
    handler is responsible for handling the mouse and key events, with `MouseEvent(*ui.Area,
    *ui.AreaMouseEvent)` being called whenever a mouse event occurs and `KeyEvent(*ui.Area,
    *ui.AreaKeyEvent)` for any keyboard events.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look more closely at the drawing capabilities, let''s run a little code.
    In this example, we are creating a new `ui.AreaHandler` type (named `areaHandler`)
    that implements all the required functions from the interface. The only method
    of interest is the `Draw()` call, which is included here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is split into two parts: first we set up a `ui.Path` and then we
    use the path to draw. The path (named p) is set to be 10 pixels inside the clip
    area that is being drawn—this is done so the canvas background is demonstrated
    (the drawing area is cleared before every `Draw()` call). Next, we use this path
    to `Fill()` and `Stroke()` within the draw context (`dp.Context`). The call to
    `Fill()` specifies a Brush that is a solid orange color of full opacity (`A` in
    the preceding code stands for alpha). Then, we call `Stroke()` using the same
    path (this will draw a line around the filled box). We are asking for a four-pixel-wide
    dashed line with round caps—this time with a semi-transparent blue color.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw this to screen, we need to configure a window to have a `ui.Area` control
    that expands to fill the window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you put all this together (or run the `chapter5/draw` example), you should
    see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/687129fa-f84e-4a76-b986-c77a862d0c7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Andlabs UI draw functions
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the transparent blue is outlining the orange—filled rectangle, and
    also displaying the rectangle and the background from beneath. If we reversed
    the order of the `Fill()` and `Stroke()` calls, the orange rectangle would completely
    cover half of the dashed outline.
  prefs: []
  type: TYPE_NORMAL
- en: Building a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at the API capabilities of andlabs UI, let's look at building
    a graphical application of some complexity. For this section, we will follow the
    design of the "GoMail" application introduced in the [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    *Walk - Building Graphical Windows Applications*. The design presented was created
    using the Qt Creator tool which, while being a good fit for developing applications
    with the Walk library, is not a direct fit for all GUI toolkits. The multiple-platform
    approach of andlabs UI to use the native widgets means that some components are
    not available, but some can be created by combining simple widgets to form more
    complex components.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's have a quick look at how the different platforms' styling
    capabilities may affect the application we are building. After exploring styles,
    we will start implementing the basic layout of our application and add the controls
    and features to demonstrate the user interface capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The styling of an andlabs-UI-based application is platform-specific and is normally
    set by the operating system. Some support user-based customization, which can
    subtly or vastly affect the look and feel of your application—so it's important
    to consider the possible variations during your application design and testing.
  prefs: []
  type: TYPE_NORMAL
- en: When run on Microsoft Windows, the toolkit in use is Common Controls (discussed
    in the [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building
    Graphical Windows* *Applications*). Essentially, the controls will look somewhat
    different across versions of Windows, which helps the applications blend in with
    the evolving desktop's look and feel. Most user-customization options within Windows
    are focused on the newer ("Universal") applications, but may show some color changes
    within applications built using Common Controls (and therefore with andlabs UI).
    Be sure to consider which versions of Windows you intend to support when testing
    your application layout and design.
  prefs: []
  type: TYPE_NORMAL
- en: Apple also evolves their macOS widget toolkit look and feel over time, though
    most recent versions (since OS X 10.5—released in 2007) remain largely consistent
    in the layout and sizing of components. Applications running on andlabs UI in
    the macOS environment should remain fairly consistent across all supported versions—unless
    users enable the new `dark mode` in macOS Mojave (released in late 2018). Following
    this new user-configuration option, the user interface may be presented in a light
    (default) or dark mode to match the user's preference. Application designers should
    consider this and ensure their content presents well in both configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The widgets used within andlabs UI adapt correctly to this new style, but custom
    content may not. There is currently no API to detect which color mode is being
    used and so the easiest approach is to either limit your interface to standard
    controls or to pick a color scheme that will look suitable in either mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a42f309-39f0-4c2c-a316-42915b4742eb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Side- by-side comparison of macOS light and dark modes (copyright IDG UK via
    MacWorld)
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, andlabs UI toolkit is built upon the GTK+ widget set, which is designed
    to allow theming and style adjustments. While these types of themes can't substantially
    change the layout of components, they can significantly impact the sizing, padding,
    and colouring that a theme provides, and so affect the flow and sizing of an application's
    user interface. This can present a challenge for software developers who want
    to support the inherent flexibility in their programs. There are over a thousand
    GTK+ themes, and many can be found on the Gnome Look website: [https://www.gnome-look.org/browse/cat/135/ord/top/](https://www.gnome-look.org/browse/cat/135/ord/top/).
    GTK+ Theming is explored further in [Chapter 6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml),
    *Go-GTK - Multiple Platforms with GTK*. where we take a deeper look at the GTK+
    toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two screenshots compare a popular light and dark theme—clearly they can
    change more than simply the color scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![](img/cd0e0e02-5fa7-40ea-8fc5-998a2ff064fc.png) | ![](img/f199d48b-6a6d-4666-b381-227a0050350a.png)
    |'
  prefs: []
  type: TYPE_TB
- en: GTK+ SuperFlat and Vertex themes compared
  prefs: []
  type: TYPE_NORMAL
- en: Each of these platform themes and configuration options can have an impact on
    the look and feel of the resulting application. If you're planning to support
    these visual styles, the best strategy is to avoid custom controls, and draw features
    and let the native controls adapt appropriately. If your application requires
    custom content or rendering, it will be important to choose a color palette that
    works well across many different themes or styles.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layouts in andlabs UI are composed of horizontal and vertical boxes, each of
    which contain a list of child elements, which may be stretched or static. Horizontal
    boxes are laid out on a single row, and every control within has the same height
    (that is, matching the height of the tallest element). In a vertical box, the
    controls are laid out in a single column and every element is the same width (being
    that of the widest item). If the container is larger than the minimum required
    to fit the items, any extra space is shared between any element that was appended
    as *stretchy—*if none stretch, the items will remain left- or top-aligned.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a visual separation between groups of elements, we can use the `ui.Separator`
    control, which draws a thin line horizontally or vertically*—*remember to mark
    it as not stretchy within the box layout. If you wish to introduce space within
    your layout without the visual line, you can create a blank label (using `ui.Label("")`)
    and set its stretchy parameter to `true` when appended to a box.
  prefs: []
  type: TYPE_NORMAL
- en: Main email window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main layout box of our email client, `content`, is a horizontal box created
    with `ui.NewHorizontalBox()`, which contains the email list on the left (the first
    item to be appended), a vertical `ui.Separator`, and the detail view on the right
    (as it was the list item to be appended). The email list is composed of a `ui.Group` named
    `inbox`, which includes the `Inbox` title; note that our title label is followed
    by a series of spaces—this helps to create a more spacious layout in our application.
    Within this, we have a vertical `ui.Box`, which has a `ui.Label` for each of our
    emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'As there is no grid layout available, the `detail` view is composed of various
    boxes. You can see that the `meta` box is a horizontal layout of two child instances
    of a vertical `ui.Box`: the first containing a vertical box of labels, the second
    being the list of values that will be filled later—the padding will provide a
    suitable gap between them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the *hello world* example, we create a window with the `GoMail` title,
    a requested size, and set `false` for the `hasMenu` parameter. At the end of the
    sample, we set the content of the window and `Show()` it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By dropping that code into the same `main()` wrapper that we used in the *hello
    world* application, we can run this user interface to see how the layout works.
    You should see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1954760c-e09d-4adb-a98e-dc20ebdf861c.png)'
  prefs: []
  type: TYPE_IMG
- en: The main email browser layout
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we weren''t able to use the splitter from the Walk example,
    but have simulated that look using `ui.Separator`. Whilst the code is the same,
    they can behave differently across different operating systems, like the following
    expanded vertical `ui.Box` on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc748417-5991-4960-b9e5-236f5c18d369.png)'
  prefs: []
  type: TYPE_IMG
- en: On macOS, the layout is different but will improve as we add content
  prefs: []
  type: TYPE_NORMAL
- en: The tree, or list, component on the left is a simple collection of labels at
    this stage, as there is no standard list component provided. Lastly, we have not
    rendered the labels in bold. This is possible, but only by using the draw API,
    which significantly complicates the code. Additionally, the use of drawing can
    cause parts of the user interface to vary from the loaded platform theme; for
    this purpose, we have stuck with the standard `ui.Label` component. In the preceding
    screenshot, you can see how different platforms have very different layouts at
    this stage—this will even out as we add more content.
  prefs: []
  type: TYPE_NORMAL
- en: Email compose dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The layout of our compose dialog window is slightly more basic: a vertical
    box named `layout` manages the stack of controls into which the input elements
    are appended. We need to create another box, in horizontal arrangement, to place
    the To label before the input field; make sure to turn the padding on to provide
    some spacing. Each of the text input boxes is created using `ui.NewEntry()`, which
    creates a simple one-line input field. Unfortunately, at the time of writing,
    there was no multi-line input field—a constraint that does not have an obvious
    workaround at this stage. The next release of the UI library will have a new `ui.MultilineEntry`,
    which will provide this functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last of the compose layout is the second horizontal box, `buttonBox`, which
    uses the familiar empty label trick to cause the Cancel and Send buttons to be
    right-aligned within the available space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, it uses the same `ui.NewWindow()` as
    the main email browser code—this is because andlabs UI doesn''t differentiate
    between types of windows. Various dialog windows do exist but they are predefined
    for specific purposes, and so for our custom dialog, we will use a normal window.
    Therefore, you can test this code easily by using the same `main()` method as
    the previous code examples. Once run, you should see something similar to these
    screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The email compose window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e5c1e80-b4dd-4b42-8472-d89e9f90d72f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Email compose on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a7f13b2-19f2-4ca7-bc67-f0423ef2cb31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Loaded on a Windows computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38aa675b-9541-4608-b100-671646a49f31.png)'
  prefs: []
  type: TYPE_IMG
- en: Toolbar and menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unfortunately there is currently no API support for menu or toolbar features
    in andlabs UI. Instead, we will simulate a toolbar by using a horizontal box,
    buttons, and a separator, which should provide the desired effect. As the separator
    can be very thin, we are padding it with an extra space on either side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have specified that no buttons, separators, or spacers should
    expand, so the buttons will be left-aligned on the bar. This behavior could be
    changed if you'd prefer the buttons to spread out, by passing `true` for the `stretchy` parameter,
    for example, when appending the empty `ui.Label` controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add this to the window—a new vertical box, called layout, is added
    and the previous content is packed underneath the toolbar. To provide some separation
    between this toolbar and the main content, we''ve called `SetPadded(true)`. Notice
    that the toolbar and space don''t stretch (vertically), but the content layout
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By combining this code with the main layout described, you should get an application
    that''s approaching the look of the email user interface that we designed in [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e9fb07f-cbd3-4f7b-939e-54bf9b637a90.png)'
  prefs: []
  type: TYPE_IMG
- en: A box of buttons is added to simulate a toolbar
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the look can vary between different operating systems—the following
    is running on Microsoft Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40acca23-2adf-4d8c-8236-a360b5e915bf.png)'
  prefs: []
  type: TYPE_IMG
- en: The addition of our toolbar box on Windows
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the basic layout is coded, we will add functionality to present some
    data from a mock email server. As with the Walk example, we will load the model
    definitions and a test email server from the `github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s write the code to load content from our model into the
    user interface. We will create a `SetEmail(EmailMessage)` function that sets the
    content of an email into the user interface. To help with converting from `client.Email`
    and `time.Time` to `string`, we will use the helper `ToEmailString()` and `DateString()`
    functions. This function will be called during interface load and also whenever
    we change the selected email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we should update the email list. Instead of two dummy emails in the list,
    we create a new method that will iterate over all emails and add an item for each.
    To be able to set the email content when clicked, we have to move from `ui.Label`
    to `ui.Button` (no other andlabs UI standard controls have an `OnClicked` callback).
    As you can see, we set a new function for each button added, which sets the displayed
    email by calling the `setEmail()` function. The `captured` variable is required
    to avoid the for loop''s re-definition of `email` in each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke these new functions on load, we need to update the `main()` method.
    First, a new server is created with `client.NewTestServer()`, and then the functions
    we wrote are invoked with the appropriate information from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step for the main view is to open the compose window when the user
    clicks on the New button. This is easily accomplished with another `OnClicked`
    handler, which builds and shows the secondary `ui.Window`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can send an email, we need to construct one from the controls in
    the compose user interface. This new `CreateMessage()` function simply gathers
    the information entered by the user and encapsulates it in a new `client.EmailMessage` that''s
    ready for sending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we want the Cancel and Send buttons to function as expected. Both should
    close the compose window, but the Send button should first attempt to send the
    email. We add simple `OnClicked` handlers for these buttons, attached to the buttons
    which are appended to the `buttonBox` already created in the UI code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all of this code is put together, you can run it, and should see an application
    that looks something like these screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GoMail interface with test data loaded running on Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f04eeffe-bafc-4d02-a525-e022b2fb5aa1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same interface with a different theme (Minwaita):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/aa407337-87bf-4a7a-8e3c-46cc957e333e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The completed GoMail interface running on macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/77223f1f-3e44-4c64-922e-d5f0e9fba2a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running on macOS dark mode:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f699006a-9c7a-45e4-8411-a10cf778b52a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The GoMail interface running on windows 10:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/13203d19-894a-44e9-9e00-3bf360273dfc.png)'
  prefs: []
  type: TYPE_IMG
- en: Background processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have realized from the first line of andlabs UI code (`ui.Main(func()
    { ... })`), multithreading is something that needs to be considered when building
    using this API. This is due to the fact that most of the toolkits it integrates
    with will require graphical updates to all execute on the same thread (often,
    the main application thread). The andlabs UI aims to hide this complexity by managing
    the threads internally and provides helper methods to manage this.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of this design, any user interface updates outside of the `ui.Main()`
    setup (or callbacks on controls created there) must be passed to the `ui.QueueMain()` method
    in the form of a function, as with the initial setup. This allows andlabs UI code
    to process the updates on the appropriate thread for the current framework. The
    following code illustrates how a label''s text could be changed as the result
    of some background processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Callbacks such as `OnClicked()` and `OnClosing()` also take a `func()` parameter,
    just as the `ui.QueueMain()` function does. This code will automatically be executed
    on the correct thread, so there is no additional complexity to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To look at the impact of background threads, we will add another feature to
    the GoMail application—updating the user interface when a new email arrives. To
    enable this, we must listen to the `Incoming` channel that our `client.EmailServer` type
    defines.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a function that will handle incoming email. This is simply
    a wrapper to a new method, `appendEmail(*client.EmailMessage)`, that handles adding
    new items to the email list. But it must create a wrapping `func()` and pass it
    to `ui.QueueMain` so that the code executes on the correct thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add a little more code to our `main()` method to listen for incoming
    emails from `client.EmailServer`. The following code requests the incoming channel
    from the server model and then loops over any emails that are communicated through
    the channel, triggering our handler for any that arrive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With these updates running, the same client will trigger a new email to appear
    after 10 seconds. With Go, the concurrency is simple to handle, and the preceding
    code shows how andlabs UI allows us to benefit from that in the handling of our
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges with multiple native GUIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've seen how a single code base can create applications that
    work with native widget toolkits across multiple platforms. This is a very powerful
    approach to quickly develop graphical apps that are consistent with the platform
    style to provide a familiar user experience. However, this approach also has challenges
    you may need to overcome for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it may not be obvious that a consistent style is important when choosing
    to adapt to the native toolkit, there are many parameters involved in style and
    application design. Does your design team or product specialist have defined standards
    or approaches to user experience that they wish to apply across all applications
    and platforms? Are there brand guidelines that you should be including in your
    interface design?
  prefs: []
  type: TYPE_NORMAL
- en: Brand styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As andlabs UI is a toolkit that aims to provide an abstraction to standard widgets
    (and therefore using the current platform's look and feel), customization options
    are limited. The only facility to introduce custom elements is the `ui.Area` widget
    and the draw features we explored. This enables a company font or logo to be drawn
    (support for loading images is said to be coming in a later version) at a certain
    location in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for further abilities to customize or theme the applications
    you are building, then andlabs UI may not be the right solution for your project.
    It's probably better to explore GTK+ or Qt (which we cover in [Chapter 6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml), *Go-GTK
    - Multiple Platforms with GTK*, and [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml),
    *Go-Qt - Multiple Platforms with QT*) or skip to Part 3 ([Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    - Experimental Go GUI API*, [Chapter 9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml), *nk
    - Nuklear for Go* and [Chapter 10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml),
    *Fyne - Material Design based GUI*) and read about other approaches to graphical
    application design.
  prefs: []
  type: TYPE_NORMAL
- en: User experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a single API does not guarantee consistency across multiple operating
    systems. The toolkits used may have different layout defaults, with different
    padding or alignment, for example. The andlabs UI (and the underlying andlabs
    `libui`) API is designed to provide an application that's as close to the OS defaults
    as possible. If you have specific requirements that should be met regarding the
    user interface appearance (other than the style), such as layout or alignment,
    you may need to write special code. Using Go's approach to build tags and load
    different code for different operating systems, you can adapt your code to behave
    slightly differently on different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the previous *hello world* example, we can update the code to
    adjust the quit button's layout on different platforms. Here, we will load a right-aligned
    button for macOS, but leave it as full width for other systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to create the Quit button is removed from `hello.go` and replaced
    with a line that calls into a new `layoutQuit()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new file, called `custom_other.go`, we move the previous button definition
    into a new `layoutQuit()` function. Additionally, a conditional build comment
    is added at the top to ensure that this file is not included for macOS (darwin).
    Note that the text has also changed to Exit, to illustrate how platforms can be
    adapted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all pretty straightforward; then we add another file, named `custom_darwin.go`,
    where we define the alternative behavior. In this file, we don''t need the build
    definition, as the filename provides that for us. In this implementation, we create
    a horizontal `ui.Box` with the Quit button padded to the right using an empty,
    stretchy `ui.Label`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this approach, it''s possible to adapt your user interface to appear
    slightly differently on specific platforms. This is a useful approach if you need
    to have different widget layouts on different systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a2c322-a5d9-424b-91d0-79da426968dc.png)  ![](img/79ca5af6-fcb5-4ffb-9b2b-94904eb8d102.png)'
  prefs: []
  type: TYPE_IMG
- en: The updated hello app (left) and layout for macOS (right)
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to various aspects of multiple-platform abstraction (including the variation
    in style), it can take a long time to test an andlabs UI application. As well
    as developing an application that, by design, looks and works slightly differently
    across Windows, macOS, and Linux, the application may be subject to additional
    user customization. All three of those platforms offer some user options to change
    the user interface—Windows allows color adjustments, macOS similarly has highlight
    colors and recently added a dark mode, and GTK+ (the Linux implementation) offers
    full theme support.
  prefs: []
  type: TYPE_NORMAL
- en: Part of testing an application built in this way is to decide which platforms
    and variations you will support. Should your Windows users all be on the latest
    version of Windows, or will you ensure the application works with older widget
    styles? On macOS, are you checking that your interface reads well in dark and light
    modes? With Linux, are you supporting (and therefore testing) a variety of different
    themes?
  prefs: []
  type: TYPE_NORMAL
- en: It's highly recommended that you have a configured test environment for every
    variation of a system that can impact how your application looks. Thankfully,
    this is made easier with virtual machines—you no longer need to have rows of computers
    or complex multi-boot configurations. If you can load and set up each of these
    configurations in separate virtual machine images, it should be possible to test
    all of these potential variations. Note that macOS licensing requires that it's
    run on a Macintosh computer—even if within a virtualized environment.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the impact of this cross-platform approach may be wider-reaching—operating
    systems have many non-visible differences as well. It's important to load and
    fully run through your application to check all features, simply looking at the
    user interface isn't enough to satisfy a solid test strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the way that libui builds against native widget APIs, the cross-complication
    is more complicated than a simple Go application. As well as the developer tools
    that are required for building an application with andlabs UI for the current
    computer, you will need to have access to the widget library definitions to successfully
    cross-compile. In some instances, that means a simple library installation, in
    other cases it may be necessary to install the operating system's **Software Development
    Kit** (**SDK**). Let's look at the details for each target platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with normal Go cross-compilation, we start by setting the environment variable, `GOOS`
    (and optionally `GOARCH`), to define the target platform of our build. To work
    with libui, we need to turn CGo back on (this is disabled when cross-compiling
    by default) using `CGO_ENABLED=1`. Simply executing the build with this setup
    would likely fail due to a missing library or SDK, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a26eff48-0c0b-47f6-b177-80f92bc64990.png)'
  prefs: []
  type: TYPE_IMG
- en: Building on macOS for Linux fails
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ba40449-f2aa-4734-937d-dd5a8c3f5a05.png)'
  prefs: []
  type: TYPE_IMG
- en: A Linux computer failing to compile for macOS
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into how cross-compilation can be enabled for various configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Building for Linux on macOS or windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to cross-compile for Linux, the main requirement is the GTK+ library,
    which provides the widgets for andlabs UI on Linux. Installing this is a little
    more difficult as the operating systems don't come with a standard package manager,
    but if you follow the steps described here it should be possible. The process
    also involves installing the cross-compiling toolchain, much like other examples
    in this section. The details for setting up cross-compilation can be found in
    *Cross compiling for Linux with CGo* section given in the [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml),
    *Cross-Compiler Setup*. The main steps are outlined here for quick reference.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To cross-compile with macOS, we need to install a package manager. The easiest
    and most complete is Homebrew—you can install it from [https://brew.sh/](https://brew.sh/).
    The recommended toolchain for Linux compilation is `musl-cross`, which is in the `FiloSottile/musl-cross/musl-cross`
    package. With Homebrew installed, execute the following commands in your Terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '`brew install gtk+3`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`export HOMEBREW_BUILD_FROM_SOURCE=1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`brew install FiloSottile/musl-cross/musl-cross`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once that is completed, you should be able to build for Linux by setting the
    `GOOS=linux`, `GOARCH=amd64`, `CGO_ENABLED=1`, and `CC=x86_64-linux-musl-gcc` environment
    variables with `CXX=x86_64-linux-musl-g++`. You can then build as normal, resulting
    in a Linux executable instead of macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e21d08e5-1c6a-40bb-a186-3f117d939eb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a Linux executable from macOS
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-compiling with Windows is a little more complicated as there is no standard
    package manager. The recommended approach is to install Cygwin (from [cygwin.com/install.html](https://cygwin.com/install.html)).
    Then install the gtk3 and linux-gcc (cross compiler) packages. From there, follow
    the preceding instructions for macOS, but use `CC=linux-gcc` and `CXX=linux-g++`.
  prefs: []
  type: TYPE_NORMAL
- en: Building for windows on Linux or macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building for Windows from another platform requires an installation of mingw
    (similar to what we installed on Windows to support CGo). The details for setting
    up cross-compilation can be found in the *Cross compiling for Windows with CGo*
    section of an [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler
    Setup*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main steps are outlined here for quick reference:'
  prefs: []
  type: TYPE_NORMAL
- en: Using your package manager (Homebrew on macOS and various on Linux), install
    the mingw package, which is usually named `mingw-w64-clang or w64-mingw`. If you
    cannot find this package, it can be installed directly using the instructions
    at [https://github.com/tpoechtrager/wclang](https://github.com/tpoechtrager/wclang).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, we need to set up the appropriate build flags—specifically `CC=x86_64-w64-mingw32-clang` (for
    the C toolchain) and `CXX=x86_64-w64-mingw32-g++` (for C++ requirements). Assuming
    you also have set `CGO_ENABLED=1` and `GOOS=windows`, you can build the Windows
    binary. Looking at the resulting `hello.exe` file, you can see it''s an MS Windows
    binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf726ec5-1d71-4f28-8ae5-b2a3d70e8dd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Using mingw (x86_64-w64-mingw32-clang), we built a Windows-native UI application
    on Linux
  prefs: []
  type: TYPE_NORMAL
- en: When building from macOS, you can use Homebrew to install the mingw-w64 package.
  prefs: []
  type: TYPE_NORMAL
- en: Building for macOS on Linux or Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-compiling for mac requires that the macOS SDK is available to link against.
    When building from a Linux or Windows computer, we must download and install the
    SDK and also update our build toolchain to use it. The easiest way to do this
    is with the *osxcross* tool. The details for this setup can be found in the *Cross
    compiling for macOS with CGo* section of an [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler
    Setup*. The main steps are outlined here for quick reference using a Linux terminal—the
    Windows setup is similar once you have installed the cygwin or mingw terminals.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to download the macOS SDK, which is bundled with Xcode. Download
    `XCode.dmg` from the Apple download site at [https://developer.apple.com/download/more/?name=Xcode%207.3](https://developer.apple.com/download/more/?name=Xcode%207.3) (7.3.1
    is recommended for osxcross). Next, install the osxcross tools from [github.com/tpoechtrager/osxcross](https://github.com/tpoechtrager/osxcross)
    (full installation details are available at that URL or in the Appendix). Completing
    the installation will have extracted the macOS SDK and created the compilation
    toolchain that will build against these installed APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we are ready to build. As well as the previous environment variables,
    we add `CC=o32-clang`, after which our build command should succeed. Here you
    can see that our Linux computer managed to create a macOS 64-bit Mach-O executable
    file named `hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7c76b31-1997-4acd-8d1b-2e45e8dfa85a.png)'
  prefs: []
  type: TYPE_IMG
- en: Using osxcross (o32-clang), we built a macOS-native UI application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The process for Windows is similar and full details can be found in the *Cross
    compiling for macOS with CGo* section of an [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler
    Setup*.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These steps are complicated and potentially fragile. Due to these challenges,
    a new project was created to assist in the cross compilation of andlabs UI applications.
    You can find out more and compare the process with those detailed here by visiting
    the project homepage at [https://github.com/magJ/go-ui-crossbuild/](https://github.com/magJ/go-ui-crossbuild/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored andlabs UI toolkit, which provides a single API
    to build graphical Go applications using the native widgets of the running operating
    system. We stepped through getting set up to build an andlabs UI application on
    macOS, Windows, and Linux, and showed how a simple *hello world* application could
    be run on each system from a single Go source file. We then looked in detail at
    the widget API for building applications and the drawing APIs for custom rendering.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we revisited the GoMail application from [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications*, and built the user interface again
    using andlabs UI library. While there were some limitations with the current version,
    we were able to simulate some of the missing widgets to almost completely recreate
    the application. The benefit, of course, is that we could then run the GUI on
    Windows, Linux, and macOS from the same source code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing an application built with a library where the user interface varies,
    and ensuring it looks as consistent as possible, may be difficult depending on
    your app design. Additionally, the simple cross-compilation that Go provides is
    significantly harder with andlabs UI due to the way it implements using operating-system-specific
    widget APIs. We explored how to work within these constraints and build applications
    for different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, investigate existing cross-platform widget libraries
    that have been made available through Go APIs. GTK+ (which we saw being used by
    andlabs UI for Linux) and QT both present a standard widget set, which will seem
    familiar to users of existing desktop applications. We'll start by exploring GTK+
    in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
