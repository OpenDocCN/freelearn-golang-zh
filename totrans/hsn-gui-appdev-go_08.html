<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Go-GTK - Multiple Platforms with GTK</h1>
                </header>
            
            <article>
                
<p>We've explored toolkits that connect directly to an operating system's native widget set (Walk for Windows only and andlabs UI for Windows, macOS, and Linux) in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications,</em> and <a href="4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml">Chapter 5</a>, <em>andlabs UI - Cross-platform Native UIs</em>. In this chapter and the next (<a href="68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml">Chapter 7</a>, <em>Go-Qt - Multiple Platforms with Qt</em>), we'll look at widget toolkits that were designed to look similar to traditional native widgets while being built for multi-platform distribution. In each chapter, we'll work with a popular Go binding that provides access to most of the functionality of the underlying API.</p>
<p>In this chapter, we'll explore Go-GTK, the most popular Go binding to the GTK+ widget library. We'll cover the following:</p>
<ul>
<li>GTK+ background</li>
<li>Getting started with Go-GTK</li>
<li>Signals and namespaces</li>
<li>Sample application</li>
<li>Theming</li>
</ul>
<p class="mce-root">By the end of this chapter, you'll be familiar with GTK+ and the Go-GTK library, having explored a few example applications. We will build a new version of the GoMail application and compare the results with our previous versions built with Walk and andlabs UI.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GTK+ background</h1>
                </header>
            
            <article>
                
<p>GTK+, or the <span><strong>GNU Image Manipulation Program</strong> (</span><strong>GIMP</strong>) Toolkit (a popular cross-platform image editor), is a cross-platform API for creating graphical applications. The project aims to provide a complete set of GUI widgets, supporting small graphical utilities up to large application suites:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/50f4ae3b-fb9e-4ae7-a12b-37847595cc39.png" width="1057" height="707"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">GIMP, which uses GTK+, shown on Windows Vista; copyright the GTK+ team</div>
<p>Since its creation, the toolkit's adoption has rapidly expanded, supported by its open source license, which supports its use in commercial and freely available applications alike. While version 1.0 (released in 1998) was primarily to support the functions of the GIMP application, by 1.2 (released less than a year later) the toolkit was aiming at a broader audience. In 2002, version 2.0 was released, which saw GTK+ become the official tookit for the Gnome Linux desktop. This fully featured release greatly expanded adoption, to become one of the most popular widget sets available for cross-platform development<span>—</span>and minor releases of the 2.x version are still very popular in 2018. In 2011, 3.0 was released with many changes included, the most visual of which was a new theme engine based on <span><strong>Cascading Style Sheets</strong> (</span><strong>CSS</strong>), which is familiar to most web developers. Though CSS is easier to create themes for, there have been criticisms of the new approach, and many distributors continue to deliver version 2.24 despite it being more than seven years old.</p>
<p>One of the benefits of Go is that it offers a single API for applications that behave consistently across multiple platforms. GTK+ (and Qt, covered in the following chapter) is an API that has a similar approach to enabling GUI application development. By combining the two through a binding to the Go language, we can create applications that can (depending on a user's theme settings) look and behave the same across all supported operating systems (Windows, macOS, Linux, and many Unix distributions). The Go bindings that we're working with in this chapter were created by Yasuhiro Matsumoto and the project has a long list of maintainers. It focuses on GTK2 support and aims to offer bindings for the complete API, but currently many features aren't available. As you will see in this chapter, the bindings currently available support the needs of most applications and so the partial completion of their goal won't impact most developer's use of this API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started with Go-GTK</h1>
                </header>
            
            <article>
                
<p>Getting up and running with Go-GTK involves installing the GTK+ library on your system (if it's not already installed), setting up CGo, and downloading the Go bindings. Users of applications built using Go-GTK will need the GTK+ library installed on their computer and so the <em>Installing GTK+</em> section may need to be included in your documentation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p>Compiling against the GTK+ library will require CGo to be set up; if this isn't already done, you can work through the <a href="a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml">Appendix</a>, <em><span>Installation Details</span></em>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing GTK+</h1>
                </header>
            
            <article>
                
<p>Using a package manager to install the GTK+ library is the easiest way to get it set up, as it'll also configure your development environment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">macOS</h1>
                </header>
            
            <article>
                
<p>The recommended approach with macOS is to install it using Homebrew. If you haven't previously set up Homebrew, you can simply follow the instructions at <kbd>https://brew.sh</kbd>. Once Homebrew is installed, you can simply open a Terminal and run <kbd>brew install gtk+</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Windows</h1>
                </header>
            
            <article>
                
<p>Windows doesn't come with a standard package manager for things such as GTK+, but the <kbd>MSYS</kbd> project aims to solve this problem. Using the <kbd>MSYS Mingw-w64</kbd> terminal (installed previously if you followed the CGo setup instructions), we can install the additional libraries. By issuing the following commands, the correct libraries should be up and running:</p>
<pre><strong>pacman -S mingw-w64-x86_64-gtk2</strong></pre>
<p><span>This installs the GTK+ library and all of its dependencies. The examples in this chapter will need to run from the MSYS terminal, even once built.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linux</h1>
                </header>
            
            <article>
                
<p>On a Linux installation, there's a good chance that you already have GTK+ 2 installed, as so many applications use this widget set. If not (or if you are not sure), then your system's package manager will manage the installation; simply look for a package named <kbd>gtk2</kbd> or <kbd>gtk</kbd>. You may need to install an additional <kbd>gtk2-dev</kbd> or <kbd>gtk-dev</kbd> package if your distribution splits development headers from the runtime library.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Install Go-GTK</h1>
                </header>
            
            <article>
                
<p>Once Go is working and the GTK+ dependency is installed, you can simply <kbd>go get github.com/mattn/go-gtk</kbd> and then <span><kbd>go get github.com/mattn/go-pointer</kbd>, on which the <kbd>go-gtk</kbd> project depends. With that installed, we're ready to build a test application.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Build</h1>
                </header>
            
            <article>
                
<p>A basic hello world application with Go-GTK is similar to the previous one we looked at: we create a window, add a vertical box, and append a label and a button. The following code sample should be straightforward, but we'll look in more detail at some of the specifics:</p>
<pre><span>package </span>main<br/><br/><span>import </span><span>"github.com/mattn/go-gtk/gtk"<br/></span><span><br/></span><span>func </span>main() {<br/>   gtk.Init(nil)<br/>   window := gtk.NewWindow(gtk.<span>WINDOW_TOPLEVEL</span>)<br/>   window.SetTitle(<span>"Hello"</span>)<br/><br/>   quit := gtk.NewButton()<br/>   quit.SetLabel(<span>"Quit"</span>)<br/>   quit.Clicked(<span>func</span>() {<br/>      gtk.MainQuit()<br/>   })<br/><br/>   vbox := gtk.NewVBox(<span>false</span>, 3)<br/>   vbox.Add(gtk.NewLabel(<span>"Hello World!"</span>))<br/>   vbox.Add(quit)<br/><br/>   window.Add(vbox)<br/>   window.SetBorderWidth(3)<br/>   window.ShowAll()<br/>   gtk.Main()<br/>}</pre>
<p>Firstly, we import the <span><kbd>github.com/mattn/go-gtk/gtk</kbd> </span>package for the main GTK namespace. The <kbd>Go-GTK</kbd> project is split into various namespaces, which we will explore further later in this chapter. Next, the window is created with <kbd>gtk.NewWindow()</kbd>—note that the parameter to this function is the <kbd>window</kbd> type, not its title (which is set next with <kbd>SetTitle()</kbd>). The <kbd>Quit</kbd> button is created with <kbd>gtk.NewButton()</kbd> and the text is set with <kbd>SetLabel()</kbd>, and then we add the code to quit using the <kbd>Clicked()</kbd> function, passing an anonymous function.</p>
<p>The layout is managed by a vertical box that's created with <kbd>gtk.NewVBox(bool, int)</kbd>. The parameters to this message are firstly a <em>homogeneous</em> <kbd>bool</kbd> flag (determining whether all child components should be the same size), and secondly an <kbd>int</kbd> value for <em>spacing</em> (this specifies the amount of padding to place between each child element).</p>
<p class="mce-root"/>
<p>Lastly, the content is set on the window using <kbd>Add()</kbd> and we set a padding consistent with the spacing in the VBox using <kbd>SetBorderWidth(3)</kbd>. Calling <kbd>ShowAll()</kbd> sets the window and its contents to be shown (as widgets are hidden by default), and the call to <kbd>gtk.Main()</kbd> runs the application to render and respond to user input.</p>
<p>You can build this using the standard <kbd>go build hello.go</kbd> command, which should create a runnable file for your operating system:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/94373a75-5e1f-4436-8dfc-06bd1c544adc.png" style="width:42.25em;height:13.42em;" width="642" height="204"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Building the hello world example with Go-GTK</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Run</h1>
                </header>
            
            <article>
                
<p>You can run the built file from the command line by double-clicking the file icon, or even using the Go tools (with <kbd>go run hello.go</kbd>). No matter how it's launched, you should see something like this screenshot appear:</p>
<p>Go-GTK hello world:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/fb078678-c95c-41e0-aade-9de9aad34b50.png" style="width:7.17em;height:5.83em;" width="87" height="70"/></div>
<p>Go-GTK on macOS:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/e6d5026b-c542-4b32-b2c9-ed60f722385f.png" style="width:5.92em;height:5.25em;" width="68" height="59"/></p>
<p>Go-GTK default Windows look:</p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign"><img src="Images/580b3592-c4cd-4561-a113-9c49301dde2d.png" style="width:9.83em;height:6.50em;" width="182" height="121"/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign"/>
<p>You can see that, just like with andlabs UI, we were able to run this single file on many operating systems. The difference here is that the applications look almost identical. That's the benefit of using a toolkit like GTK+ and why you may consider Go-GTK for your next application.</p>
<p>Before we look at a more complete application user interface, we should investigate some of the details of the Go-GTK API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Signals and namespaces</h1>
                </header>
            
            <article>
                
<p>GTK+ is an event-driven toolkit; that means that nothing happens unless an event is emitted and a callback is registered to receive it. The events in GTK+ are implemented through signals, and registering a callback for a signal is called connecting. Signals include most events involved in the GUI behavior and communication, including button click events or the window life cycle.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Signals</h1>
                </header>
            
            <article>
                
<p>Did you notice that, in our hello world example, the <kbd>Quit</kbd> button would exit the application, but that closing the window did not? That's because we didn't connect any callback to the window destroy signal. We can fix this by adding the following lines to handle this case:</p>
<pre>window.Connect(<span>"destroy"</span>, <span>func</span>() {<br/>   gtk.MainQuit()<br/>})</pre>
<p>This code connects the provided anonymous function to the <span><kbd>destroy</kbd> signal of</span> <kbd>window</kbd><span>. When the signal is emitted, the function is called and the application will now exit correctly. As the <kbd>gtk.MainQuit()</kbd> function takes 0 parameters, we could write the same more concisely</span><span> as follows</span><span>:</span></p>
<pre>window.Connect(<span>"destroy"</span>, gtk.MainQuit)</pre>
<p>But hold on a moment, how come the button click worked? That's because we used the <kbd>Clicked()</kbd> function on the <kbd>button</kbd> component. This is a convenience function that sets up the signal connection for you (and keeps the code a little neater!). If you look at the source code for the <kbd>Button.Clicked()</kbd> function, you will see what happens:</p>
<pre><span>func </span>(v *Button) Clicked(onclick <span>interface</span>{}, datas ...<span>interface</span>{}) int {<br/>   <span>return </span>v.Connect(<span>"clicked"</span>, onclick, datas...)<br/>}</pre>
<p>And so, you can see it is not always essential to <em>wire</em> these connections manually as <kbd>Go-GTK</kbd> provides many convenience methods like this one.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passing data</h1>
                </header>
            
            <article>
                
<p>The previous examples all use a function with no parameters. While this is often enough, it can be helpful to pass additional information into your signal handling functions. This can be done easily as the connect functionality (mirrored by the <kbd>Clicked()</kbd> convenience function) allows for additional parameters to be sent. After the function reference, you can pass additional data parameters, which will be available to the function that executes the callback.</p>
<p>We can demonstrate that by creating a new button and passing this button along with the function to the signal connection:</p>
<pre>button := gtk.NewButton()<br/>button.SetLabel(label)<br/>button.Clicked(clicked, button)</pre>
<p><span>In the callback function, we update the function signature to accept a <kbd>*glib.CallbackContext</kbd> parameter. This parameter contains the data that was specified when the signal was connected. The data can be accessed using the context's <kbd>Data()</kbd> function call.</span></p>
<p><span>It's convenient to convert the type of the data returned, but remember to be careful when asserting the new type, as an incorrect type will cause your program to crash:</span></p>
<pre><span>func </span>clicked(ctx *glib.CallbackContext) {<br/>   button := ctx.Data().(*gtk.Button)<br/>   log.Println(<span>"Button clicked was:"</span>, button.GetLabel())<br/>}</pre>
<p>Bringing this together in a simple example where we create three buttons with the same callback function, we can see how this data parameter allows us to avoid unnecessary functions being created:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/595b9349-0a69-4380-97f1-bd584cb48caf.png" style="width:5.42em;height:9.75em;" width="81" height="149"/>    <img src="Images/594dc77d-9ddc-4305-a148-05de9ff54e10.png" style="width:37.17em;height:9.50em;" width="642" height="163"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Multiple buttons; The clicked function handling multiple buttons' click callbacks</span></div>
<p>As you may have noticed, the previous code snippet mentioned a new package, <kbd>glib</kbd>. Let's look at the different packages that the <kbd>Go-GTK</kbd> project consists of and when you might want to use them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Namespaces</h1>
                </header>
            
            <article>
                
<p>The <kbd>Go-GTK</kbd> project contains a number of namespaces used to organize the code and make it easier for developers to find what they're looking for. These sub-projects or packages reflect the naming within the main GTK+ project, so those familiar with this can skip this section. Most of the examples so far used just <kbd>gtk</kbd>, which is clearly the main package to use for building a user interface but, as we saw before, <kbd>glib</kbd> may be important too (for things not specifically about widgets).</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's look at what each namespace covers and see where it might be useful in application development:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><kbd>gdk</kbd></p>
</td>
<td>
<p class="mce-root">GDK stands for GIMP Drawing Kit; it's a low-level component of GTK+ that handles the details of rendering on each platform that is supported. This provides an abstraction of the operating system details, therefore allowing other areas of GTK+ to be platform agnostic. This package will be useful if your application needs to draw any custom elements.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>gdkpixbuf</kbd></p>
</td>
<td>Pixbuf refers to an in-memory buffer containing pixel data for rendering images. This package provides some convenience functions for managing images that can be loaded into a Go-GTK application. Of note is the <kbd>gdkpixbuf.NewPixbufFromData</kbd> function, which, combined with the <kbd>make_inline_pixbuf</kbd> tool, allows the loading of images embedded in the application.</td>
</tr>
<tr>
<td>
<p><kbd>gio</kbd></p>
</td>
<td><kbd>gio</kbd> represents an input/output abstraction for GTK+ applications. It provides access to local and remote files with a consistent API.</td>
</tr>
<tr>
<td>
<p><kbd>glib</kbd></p>
</td>
<td><kbd>glib</kbd> is the supporting library for all GTK+ features and applications. It implements the object-oriented system as well as various data structures and utilities. As the Go language defines many of these natively, the glib package within Go-GTK is responsible for translating from Go to glib (C) structures. This is where thread management and message passing are handled, but most of these features are hidden by the higher-level functions of the library.</td>
</tr>
<tr>
<td>
<p><kbd>gtk</kbd></p>
</td>
<td>The main namespace for widgets in the GTK+ library. As we've already seen, it presents a cross-platform toolkit for creating graphical applications, which is made possible by the other packages listed here.</td>
</tr>
<tr>
<td>
<p><kbd>pango</kbd></p>
</td>
<td><strong>Pango</strong> is a font rendering library, which provides high-quality text glyphs for GTK+ applications. It's unlikely that you would need to call any of these APIs directly; it is mainly used internally for rendering text within GTK+.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Having looked at the main packages within <kbd>Go-GTK</kbd> (and seen that an application will probably only need to use <kbd>gtk</kbd>, <kbd>glib</kbd>, and <kbd>gdk</kbd>), we will see how this comes together in a larger application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sample application</h1>
                </header>
            
            <article>
                
<p>It's time to dust off the GoMail application design again and adapt it for GTK+ widgets. As the andlabs UI application (when run on Linux) was using GTK+, it would seem logical to start from there. However, this time we are not limited by the <em>lowest common denominator</em> design constraint, which the native cross-platform design of andlabs worked around, so let's start from scratch and see what GTK+ can do.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>Basic layout with GTK+-based applications uses a familiar vertical and horizontal box model. Go-GTK (as a straightforward binding to this API) exposes this same functionality. We lay out the GoMail main window using a vertical box to position the menu and toolbar above the main content. Our main content is then a horizontally split pane created with <kbd>gtk.NewHPaned()</kbd> (where <strong>H</strong> refers to the horizontal layout, not the bar orientation, which is vertical). Before looking at the details, here's the basic layout code for the main window. The toolbar and menu creation code is omitted for brevity but can be found in the example code repository:</p>
<pre><span>package </span>main<br/><br/><span>import </span><span>"github.com/mattn/go-gtk/gtk"<br/></span><span><br/>const padding = 3<br/><br/></span><span>func </span>main() {<br/>   gtk.Init(nil)<br/>   window := gtk.NewWindow(gtk.<span>WINDOW_TOPLEVEL</span>)<br/>   window.SetTitle(<span>"GoMail"</span>)<br/>   window.Connect(<span>"destroy"</span>, <span>func</span>() {<br/>      gtk.MainQuit()<br/>   })<br/><br/>   list := gtk.NewTreeView()<br/>   list.AppendColumn(gtk.NewTreeViewColumnWithAttributes("Inbox", gtk.NewCellRendererText(), "text", 0))<br/>   meta := gtk.NewHBox(<span>false</span>, padding)<br/><br/>   labels := gtk.NewVBox(<span>true</span>, padding)<br/>   labels.Add(gtk.NewLabel(<span>"To"</span>))<br/>   labels.Add(gtk.NewLabel(<span>"From"</span>))<br/>   labels.Add(gtk.NewLabel(<span>"Date"</span>))<br/>   values := gtk.NewVBox(<span>true</span>, padding)<br/>   values.Add(gtk.NewLabel(<span>"email"</span>))<br/>   values.Add(gtk.NewLabel(<span>"email"</span>))<br/>   values.Add(gtk.NewLabel(<span>"date"</span>))<br/>   meta.Add(labels)<br/>   meta.Add(values)<br/><br/>   content := gtk.NewTextView()<br/>   content.GetBuffer().SetText(<span>"email content"</span>)<br/>   content.SetEditable(<span>false</span>)<br/><br/>   detail := gtk.NewVBox(false, padding)<br/>   detail.PackStart(gtk.NewLabel(<span>"subject"</span>), <span>false</span>, <span>true</span>, <span>0</span>)<br/>   detail.PackStart(meta, <span>false</span>, <span>true</span>, <span>0</span>)<br/>   detail.Add(content)<br/><br/>   split := gtk.NewHPaned()<br/>   split.Add1(list)<br/>   split.Add2(detail)<br/><br/>   vbox := gtk.NewVBox(<span>false</span>, padding)<br/>   vbox.PackStart(buildMenu(), <span>false</span>, <span>true</span>, <span>0</span>)<br/>   vbox.PackStart(buildToolbar(), <span>false</span>, <span>true</span>, <span>0</span>)<br/>   vbox.Add(split)<br/><br/>   window.Add(vbox)<br/>   window.SetBorderWidth(padding)<br/>   window.Resize(<span>600</span>, <span>400</span>)<br/>   window.ShowAll()<br/>   gtk.Main()<br/>}</pre>
<p>There are two things of note in this code. First is the <kbd>padding</kbd> constant defined at the top of the file. The box model doesn't define a standard spacing and so we pass this constant each time the layout requires some visual padding. The second important lesson is the difference between the <kbd>Add(IWidget)</kbd> and <kbd>PackStart(IWidget, bool, bool, uint)</kbd> methods on the boxes. The <kbd>Add</kbd> method simply appends the widget to the container (<kbd>gtk.Box</kbd> inherits from <kbd>gtk.Container</kbd>) and it'll cause the child to expand to fill the space available. For a menu bar and toolbar, we don't desire a vertical expansion so we use the <kbd>PackStart</kbd> method, which allows more control over behavior. The first Boolean parameter controls expansion; by passing <kbd>false</kbd>, we instruct the container that the widget shouldn't take up any free space.</p>
<p>The second Boolean controls fill and states whether or not the widget should fill any space available after any space calculations have been performed, so passing <kbd>true</kbd> specifies that our toolbar should be full width. In <kbd>gtk.VBox</kbd>, the expand parameter refers to vertical stretch and the fill applies to horizontal. </p>
<p class="mce-root"/>
<p><span>We also need to add some content to the list view, which requires the creation of a model to represent the content we will present. As the content will be a single column with no parent/child relationship, we can use <kbd>gtk.ListStore</kbd>, rather than the more complex <kbd>gtk.TreeStore</kbd>. The way that content is set into a model is by using an iterator and applying values to each row of data. For the purpose of this layout, we add <kbd>email1</kbd> and <kbd>email2</kbd> to the 0th (first) column of the view:</span></p>
<pre>   model := gtk.NewListStore(gtk.<span>TYPE_STRING</span>)<br/>   list.SetModel(model)<br/><br/>   <span>var </span>iter gtk.TreeIter<br/>   model.Append(&amp;iter)<br/>   model.SetValue(&amp;iter, <span>0</span>, <span>"email1"</span>)<br/>   model.Append(&amp;iter)<br/>   model.SetValue(&amp;iter, <span>0</span>, <span>"email2"</span>)</pre>
<p>The toolbar API is simple to use and, by utilizing the stock icons included in GTK+, provides standard icons for many common actions. As some of our buttons are non-standard (<kbd>Reply</kbd> and <kbd>Reply All</kbd>), we set the toolbar style to show icons and labels; later, we can add some custom icons. Each item can have its action set using the <kbd>OnClicked()</kbd> function or by connecting the <kbd>clicked</kbd> signal:</p>
<pre>   toolbar := gtk.NewToolbar()<br/>   toolbar.SetStyle(gtk.<span>TOOLBAR_BOTH</span>)<br/>   item := gtk.NewToolButtonFromStock(gtk.STOCK_NEW)<br/>   item.OnClicked(showCompose)<br/>   toolbar.Add(item)</pre>
<p>The rest of the icons can be added similarly. The menu code is slightly more complicated; each drop-down menu (whether a sub-menu or a main menu) needs to be created with <kbd>gtk.NewMenu()</kbd>, and its items added as shown. Each top-level menu then needs to have a new menu item created (for example, <kbd>gtk.NewMenuItemWithLabel()</kbd>) and the menu connected using <kbd>SetSubmenu()</kbd>. The constructed menu can then be appended to the menu bar:</p>
<pre>menubar := gtk.NewMenuBar()<br/>fileMenu := gtk.NewMenuItemWithLabel(<span>"File"</span>)<br/><br/>menu := gtk.NewMenu()<br/>item := gtk.NewMenuItemWithLabel(<span>"New"</span>)<br/>item.Connect(<span>"activate"</span>, showCompose)<br/>menu.Append(item)<br/><br/>fileMenu.SetSubmenu(menu)<br/>menubar.Append(fileMenu)</pre>
<p><span>With all of this code in place (and a few more items in the toolbar and menu), we have a basic application layout that should look familiar. As you can see, we are already benefiting from the additional features of a larger widget toolkit with standard icons and more complete styling and layouts:</span></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/ab1087c8-df37-4f30-9439-8971ab1b8ecd.png" style="width:33.00em;height:13.92em;" width="600" height="253"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>The basic layout of GoMail using Go-GTK before we make any style adjustments</span></div>
<p>The layout, particularly of the email details panel, can be improved using <kbd>label.SetAlignment(0, 0)</kbd> to set a left alignment, and the content of a label can be made bold by using the markup capability of the <kbd>pango</kbd> library; just call <kbd>label.SetMarkup(fmt.Sprintf("&lt;b&gt;%s&lt;/b&gt;", label.GetText()))</kbd>. The preceding code was focused on the basic layout, so these tweaks have been left out. The additional details are included in the example code repository and the completed interface can be seen in the later section about themes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compose layout</h1>
                </header>
            
            <article>
                
<p>The code to display the compose dialog should look very familiar by now. The window is created as  <kbd>gtk.WINDOW_TOPLEVEL</kbd> because Go-GTK only allows a choice of top-level or popup (that is, floating content), rather than child windows such as a dialog. We set up a destroy function that will close the window rather than exiting the application.</p>
<p>The rest of the layout code is the usual vertical box for each item with a horizontal box for the <kbd>to</kbd> label, which is left of the input field:</p>
<pre><span>func </span>buildCompose() {<br/>   window := gtk.NewWindow(gtk.<span>WINDOW_TOPLEVEL</span>)<br/>   window.SetTitle(<span>"New GoMail"</span>)<br/>   window.Connect(<span>"destroy"</span>, <span>func</span>() {<br/>      window.Destroy()<br/>   })<br/><br/>   vbox := gtk.NewVBox(<span>false</span>, <span>padding</span>)<br/>   subject := gtk.NewEntry()<br/>   subject.SetText(<span>"subject"</span>)<br/>   vbox.PackStart(subject, <span>false</span>, <span>true</span>, <span>0</span>)<br/>   toBox := gtk.NewHBox(<span>false</span>, <span>padding</span>)<br/>   toBox.PackStart(gtk.NewLabel(<span>"To"</span>), <span>false</span>, <span>true</span>, <span>0</span>)<br/>   email := gtk.NewEntry()<br/>   email.SetText(<span>"email"</span>)<br/>   toBox.Add(email)<br/>   vbox.PackStart(toBox, <span>false</span>, <span>true</span>, <span>0</span>)<br/><br/>   content := gtk.NewTextView()<br/>   content.GetBuffer().SetText(<span>"email content"</span>)<br/>   content.SetEditable(<span>true</span>)<br/>   vbox.Add(content)<br/><br/>   buttonBox := gtk.NewHBox(<span>false</span>, <span>padding</span>)<br/>   buttonBox.PackEnd(gtk.NewButtonWithLabel(<span>"Cancel"</span>), <span>false</span>, <span>true</span>, <span>0</span>)<br/>   buttonBox.PackEnd(gtk.NewButtonWithLabel(<span>"Send"</span>), <span>false</span>, <span>true</span>, <span>0</span>)<br/>   vbox.PackEnd(buttonBox, <span>false</span>, <span>true</span>, <span>0</span>)<br/><br/>   window.Add(vbox)<br/>   window.SetBorderWidth(<span>padding</span>)<br/>   window.Resize(<span>400</span>, <span>320</span>)<br/>   window.ShowAll()<br/>}</pre>
<p>As you can see with <kbd>buttonBox</kbd>, we've made use of the <kbd>PackEnd()</kbd> function described before to right-align the buttons at the bottom of the compose window. We also make use of the <kbd>padding</kbd> definition from the main window to provide consistent spacing for our widgets. Running the preceding code should load a window similar to this:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4a944182-f93f-4f78-837f-0754e2dc0461.png" style="width:24.58em;height:9.33em;" width="400" height="152"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The GoMail compose window with Go-GTK</div>
<p>Now that we have the basic layout and input fields prepared, let's connect to some content using our test email server.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Signaling</h1>
                </header>
            
            <article>
                
<p>In a traditional GTK+ application, it would be possible, even recommended, to make use of the built-in signal handling capabilities. A new signal could be created, which would then be emitted by the application at an appropriate time; components could connect to this signal and respond appropriately. However, the ability to create signals is not exposed through the Go-GTK API and so we will use callbacks like the previous examples.</p>
<p>To load our test server, we first update the <kbd>main()</kbd> function to set up a server and pass it to the user interface creation code. We then set the content to show the current message from our test server:</p>
<pre><span>func </span>main() {<br/>   server := client.NewTestServer()<br/>   main := new(mainUI)<br/>   main.showMain(server)<br/>   main.setEmail(server.CurrentMessage())<br/>   <br/>   gtk.Main()<br/>}</pre>
<p>This makes use of a new helper function that will set the content of the email detail panel. We will call this from our list selection code later as well:</p>
<pre><span>func </span>(m *mainUI) setEmail(message *client.EmailMessage) {<br/>   m.subject.SetText(message.Subject)<br/>   m.to.SetText(message.ToEmailString())<br/>   m.from.SetText(message.FromEmailString())<br/>   m.date.SetText(message.DateString())<br/><br/>   m.content.GetBuffer().SetText(message.Content)<br/>}</pre>
<p>To set the content of the email list, we store the iterator and the model in our application struct when created, so they can be referenced later. The following helper function handles the details of prepending an item to the email list. This function is called on each message in <kbd>server.ListMessages()</kbd> to set up the initial list:</p>
<pre><span>func </span>(m *mainUI) prependEmail(message *client.EmailMessage) {<br/>   m.listModel.Prepend(&amp;m.listIter)<br/>   m.listModel.SetValue(&amp;m.listIter, <span>0</span>, message.Subject)<br/>}</pre>
<p>The last part of the basic communication with the user interface is to handle the selection of items in the tree view. To handle this, our application must implement <kbd>gtk.GtkTreeSelecter</kbd>, which has a single <kbd>Select()</kbd> function. The following implementation will suit our needs. Firstly, note that this can be called for selection and deselection, so we need to check that the item is not currently selected. Then, we use the path specified when the callback is invoked to determine the row that was clicked. This row number is used to get the email from the server list of messages. We can then call our helpful <kbd>setEmail()</kbd> function:</p>
<pre><span>func </span>(m *mainUI) Select(selection *gtk.TreeSelection, model *gtk.TreeModel, path *gtk.TreePath, selected bool) bool {<br/>   <span>if </span>selected { <span>// already selected, just return<br/></span><span>      </span><span>return </span><span>true<br/></span><span>   </span>}<br/><br/>   row := path.GetIndices()[0]<br/>   email := m.server.ListMessages()[row]<br/><br/>   m.setEmail(email)<br/>   <span>return </span><span>true<br/></span>}</pre>
<p>For the select handler to be called, we must register it on <kbd>gtk.ListView</kbd> when it is created:</p>
<pre><span>var </span>selecter gtk.GtkTreeSelecter<br/>selecter = mainUI<br/>list.GetSelection().SetSelectFunction(&amp;selecter)</pre>
<p>Now, the user interface should be complete. We need to handle background updates when new emails arrive.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Thread handling</h1>
                </header>
            
            <article>
                
<p>Before we can correctly handle background processing with Go-GTK (or any GTK+ implementations), we must correctly initialize the thread handling portions of the underlying libraries (<kbd>glib</kbd> and <kbd>gdk</kbd>). These lines should be entered at the start of an application's <kbd>main()</kbd> function:</p>
<pre>glib.ThreadInit(nil)<br/>gdk.ThreadsInit()<br/>gdk.ThreadsEnter()<br/>gtk.Init(nil)</pre>
<p class="mce-root"/>
<p>Once the thread handling has been set up, we can write background code that will communicate with the user interface. This code must execute on the same thread that the application was created with. To ensure this, we use the helper functions, <kbd>gdk.ThreadsEnter()</kbd> and <kbd>gdk.ThreadsLeave()</kbd>, around the code we wish to execute. For our application to add new messages to the end of our email list when they arrive, add the following code immediately before calling <kbd>gtk.Main()</kbd> to start the application:</p>
<pre><span>   go func</span>() {<br/>      <span>for </span>email := <span>range </span>server.Incoming() {   <br/><strong>         </strong>gdk.ThreadsEnter()<br/>         main.prependEmail(email)<br/>         gdk.ThreadsLeave()<br/>      }<br/>   }()</pre>
<p>This completes the implementation of our GoMail application in Go-GTK, but how can we compile the app for different platforms?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross compilation</h1>
                </header>
            
            <article>
                
<p>Compiling a Go-GTK based application for additional platforms requires requires additional C compilers to be installed so that CGo can create the necessary binary output. The steps for completing this, if you haven't done so already, are in<span> the <a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml"/><a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml">Appendix</a>, <em>Cross-Compiler Setup</em>. You'll also need to have GTK+ installed, which should obviously already be the case. As the <em>Cross compilation</em> section of <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications,</em> andlabs UI already stepped through the details, so we won't repeat them here. The process is identical due to andlabs UI's use of the GTK+ library for some target platforms. Be sure to set the appropriate <kbd>GOOS</kbd>, <kbd>GOARCH</kbd>, <kbd>CGO_ENABLED</kbd>, <kbd>CC</kbd>, and <kbd>CXX</kbd> environment variables.</span></p>
<p>Before we wrap up our exploration of the toolkit, we should look at the benefits provided by its theming capabilities.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Theming</h1>
                </header>
            
            <article>
                
<p>One of the large benefits of using a GTK+ (or Qt)-based API is that the widget set can be themed. Users are able to install any number of themes (or write their own) to control how applications look. While this can add a testing overhead, they will behave the same across all platforms so the burden is somewhat reduced.</p>
<p>Let's see a few different themes applied to our GoMail application illustrated here, starting with a great light theme named <kbd>Clearlooks</kbd>.</p>
<ul>
<li class="mce-root CDPAlignLeft CDPAlign">The Clearlooks theme on Linux:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b098c234-0783-4547-bdea-f04ef12277e0.png" style="width:43.25em;height:22.58em;" width="600" height="313"/></p>
<ul>
<li>Compose in Clearlooks:</li>
</ul>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign"><img style="font-size: 10pt;width:29.58em;height:12.42em;" src="Images/5b9f0b84-23d6-4ce9-857f-afc942a03423.png" width="400" height="168"/></div>
<p class="mce-root"/>
<p>On Windows, the default theme look<span>s more like the standard widgets, though the user can load any other GTK+ theme. Notice that the default icons are also different, more in-keeping with the operating system standards.</span></p>
<ul>
<li>The Windows default theme:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6cf8a775-a445-4453-865e-55ee25d8bbcc.png" style="width:44.00em;height:18.92em;" width="899" height="385"/></p>
<ul>
<li>Compose with Windows:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/04381830-6892-4a64-a081-e6a380c21ced.png" style="width:22.17em;height:12.50em;" width="436" height="245"/></p>
<p><span>There are also many dark themes;</span><span> </span><em>Arc Dark</em><span> is very popular.</span></p>
<ul>
<li>Arc Dark theme running on Linux:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4d074dae-f1b5-4de5-9b98-03641d205430.png" style="width:42.25em;height:22.67em;" width="600" height="322"/></p>
<ul>
<li>Ark Dark compose window:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/72bfdb9e-5b75-483d-80cc-7b37de092b5f.png" style="width:27.50em;height:12.67em;" width="400" height="183"/></p>
<p><span>Many themes are designed for nostalgia, including this CDE theme, which is based on a colorful desktop environment from the 1990s.</span></p>
<ul>
<li>Running a CDE theme for the old-school look:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d0c5c8e9-5504-4fd0-939d-1b2ee96e4c04.png" width="600" height="310"/></p>
<ul>
<li>Composing in a CDE theme:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d0b8e27c-2dc1-4d6e-aabf-d39e0b2745c7.png" width="400" height="162"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, the colors of the user interface elements can vary significantly but the layouts are largely consistent. If you look at the buttons (<kbd>Send</kbd> and <kbd>Cancel</kbd> on the compose window), there's also a difference between how rounded some edges are. Applications built with Go-GTK should work well with any theme loaded, but it is advisable to check various different configurations as part of your quality assurance process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored the details of the GTK+ toolkit and how it is made available to Go through go-GTK. We looked at how to get it set up on macOS, Windows, and Linux and how the applications look and behave exactly the same across these platforms. We explored the API design, its various components, and how its event driven model is exposed to developers.</p>
<p>We then returned to the GoMail application from <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications,</em> and <a href="4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml">Chapter 5</a>, <em>andlabs UI - Cross-Platform Native UIs</em>, rebuilding it using the Go-GTK library. As the API provides access to most GTK+ features, we found that the application looks more complete than the GTK+ based application created by the Linux driver within andlabs UI used in <a href="4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml">Chapter 5</a>, <em>andlabs UI - Cross-Platform Native UIs</em>. We implemented some basic thread and signal handling within the application to handle user input and background events. Lastly, we explored how the powerful GTK+ theme engine could style the created application user interface.</p>
<p>By now, you should be familiar with the Go-GTK library, and how it leverages the underlying GTK+ toolkit and allows the quick development of GUI applications with Go. These applications will differ from the operating system standard look and feel, but are close to standard application design and so should be familiar to most users. If the interface widget design or API wasn't quite what you were looking for, then read the next chapter, where we look at an alternative to GTK, the Qt framework.</p>


            </article>

            
        </section>
    </div>



  </body></html>