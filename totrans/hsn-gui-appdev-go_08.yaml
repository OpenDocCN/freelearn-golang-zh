- en: Go-GTK - Multiple Platforms with GTK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've explored toolkits that connect directly to an operating system's native
    widget set (Walk for Windows only and andlabs UI for Windows, macOS, and Linux)
    in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical
    Windows Applications,* and [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml),
    *andlabs UI - Cross-platform Native UIs*. In this chapter and the next ([Chapter
    7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), *Go-Qt - Multiple Platforms with
    Qt*), we'll look at widget toolkits that were designed to look similar to traditional
    native widgets while being built for multi-platform distribution. In each chapter,
    we'll work with a popular Go binding that provides access to most of the functionality
    of the underlying API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explore Go-GTK, the most popular Go binding to the
    GTK+ widget library. We''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GTK+ background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Go-GTK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signals and namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll be familiar with GTK+ and the Go-GTK library,
    having explored a few example applications. We will build a new version of the
    GoMail application and compare the results with our previous versions built with
    Walk and andlabs UI.
  prefs: []
  type: TYPE_NORMAL
- en: GTK+ background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GTK+, or the **GNU Image Manipulation Program** (**GIMP**) Toolkit (a popular
    cross-platform image editor), is a cross-platform API for creating graphical applications.
    The project aims to provide a complete set of GUI widgets, supporting small graphical
    utilities up to large application suites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50f4ae3b-fb9e-4ae7-a12b-37847595cc39.png)'
  prefs: []
  type: TYPE_IMG
- en: GIMP, which uses GTK+, shown on Windows Vista; copyright the GTK+ team
  prefs: []
  type: TYPE_NORMAL
- en: Since its creation, the toolkit's adoption has rapidly expanded, supported by
    its open source license, which supports its use in commercial and freely available
    applications alike. While version 1.0 (released in 1998) was primarily to support
    the functions of the GIMP application, by 1.2 (released less than a year later)
    the toolkit was aiming at a broader audience. In 2002, version 2.0 was released,
    which saw GTK+ become the official tookit for the Gnome Linux desktop. This fully
    featured release greatly expanded adoption, to become one of the most popular
    widget sets available for cross-platform development—and minor releases of the
    2.x version are still very popular in 2018\. In 2011, 3.0 was released with many
    changes included, the most visual of which was a new theme engine based on **Cascading
    Style Sheets** (**CSS**), which is familiar to most web developers. Though CSS
    is easier to create themes for, there have been criticisms of the new approach,
    and many distributors continue to deliver version 2.24 despite it being more than
    seven years old.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of Go is that it offers a single API for applications that
    behave consistently across multiple platforms. GTK+ (and Qt, covered in the following
    chapter) is an API that has a similar approach to enabling GUI application development.
    By combining the two through a binding to the Go language, we can create applications
    that can (depending on a user's theme settings) look and behave the same across
    all supported operating systems (Windows, macOS, Linux, and many Unix distributions). The
    Go bindings that we're working with in this chapter were created by Yasuhiro Matsumoto
    and the project has a long list of maintainers. It focuses on GTK2 support and
    aims to offer bindings for the complete API, but currently many features aren't
    available. As you will see in this chapter, the bindings currently available support
    the needs of most applications and so the partial completion of their goal won't
    impact most developer's use of this API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Go-GTK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting up and running with Go-GTK involves installing the GTK+ library on your
    system (if it's not already installed), setting up CGo, and downloading the Go
    bindings. Users of applications built using Go-GTK will need the GTK+ library
    installed on their computer and so the *Installing GTK+* section may need to be
    included in your documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compiling against the GTK+ library will require CGo to be set up; if this isn't
    already done, you can work through the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml),
    *Installation Details*.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GTK+
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a package manager to install the GTK+ library is the easiest way to get
    it set up, as it'll also configure your development environment.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recommended approach with macOS is to install it using Homebrew. If you
    haven't previously set up Homebrew, you can simply follow the instructions at
    `https://brew.sh`. Once Homebrew is installed, you can simply open a Terminal
    and run `brew install gtk+`.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Windows doesn''t come with a standard package manager for things such as GTK+,
    but the `MSYS` project aims to solve this problem. Using the `MSYS Mingw-w64`
    terminal (installed previously if you followed the CGo setup instructions), we
    can install the additional libraries. By issuing the following commands, the correct
    libraries should be up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This installs the GTK+ library and all of its dependencies. The examples in
    this chapter will need to run from the MSYS terminal, even once built.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a Linux installation, there's a good chance that you already have GTK+ 2
    installed, as so many applications use this widget set. If not (or if you are
    not sure), then your system's package manager will manage the installation; simply
    look for a package named `gtk2` or `gtk`. You may need to install an additional
    `gtk2-dev` or `gtk-dev` package if your distribution splits development headers
    from the runtime library.
  prefs: []
  type: TYPE_NORMAL
- en: Install Go-GTK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once Go is working and the GTK+ dependency is installed, you can simply `go
    get github.com/mattn/go-gtk` and then `go get github.com/mattn/go-pointer`, on
    which the `go-gtk` project depends. With that installed, we're ready to build
    a test application.
  prefs: []
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A basic hello world application with Go-GTK is similar to the previous one
    we looked at: we create a window, add a vertical box, and append a label and a
    button. The following code sample should be straightforward, but we''ll look in
    more detail at some of the specifics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we import the `github.com/mattn/go-gtk/gtk` package for the main GTK
    namespace. The `Go-GTK` project is split into various namespaces, which we will
    explore further later in this chapter. Next, the window is created with `gtk.NewWindow()`—note
    that the parameter to this function is the `window` type, not its title (which
    is set next with `SetTitle()`). The `Quit` button is created with `gtk.NewButton()` and
    the text is set with `SetLabel()`, and then we add the code to quit using the
    `Clicked()` function, passing an anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: The layout is managed by a vertical box that's created with `gtk.NewVBox(bool,
    int)`. The parameters to this message are firstly a *homogeneous* `bool` flag
    (determining whether all child components should be the same size), and secondly
    an `int` value for *spacing* (this specifies the amount of padding to place between
    each child element).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the content is set on the window using `Add()` and we set a padding
    consistent with the spacing in the VBox using `SetBorderWidth(3)`. Calling `ShowAll()`
    sets the window and its contents to be shown (as widgets are hidden by default),
    and the call to `gtk.Main()` runs the application to render and respond to user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build this using the standard `go build hello.go` command, which should
    create a runnable file for your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94373a75-5e1f-4436-8dfc-06bd1c544adc.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the hello world example with Go-GTK
  prefs: []
  type: TYPE_NORMAL
- en: Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can run the built file from the command line by double-clicking the file
    icon, or even using the Go tools (with `go run hello.go`). No matter how it''s
    launched, you should see something like this screenshot appear:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go-GTK hello world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb078678-c95c-41e0-aade-9de9aad34b50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go-GTK on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6d5026b-c542-4b32-b2c9-ed60f722385f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go-GTK default Windows look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/580b3592-c4cd-4561-a113-9c49301dde2d.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that, just like with andlabs UI, we were able to run this single
    file on many operating systems. The difference here is that the applications look
    almost identical. That's the benefit of using a toolkit like GTK+ and why you
    may consider Go-GTK for your next application.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at a more complete application user interface, we should investigate
    some of the details of the Go-GTK API.
  prefs: []
  type: TYPE_NORMAL
- en: Signals and namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GTK+ is an event-driven toolkit; that means that nothing happens unless an event
    is emitted and a callback is registered to receive it. The events in GTK+ are
    implemented through signals, and registering a callback for a signal is called
    connecting. Signals include most events involved in the GUI behavior and communication,
    including button click events or the window life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Did you notice that, in our hello world example, the `Quit` button would exit
    the application, but that closing the window did not? That''s because we didn''t
    connect any callback to the window destroy signal. We can fix this by adding the
    following lines to handle this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code connects the provided anonymous function to the `destroy` signal
    of `window`. When the signal is emitted, the function is called and the application
    will now exit correctly. As the `gtk.MainQuit()` function takes 0 parameters,
    we could write the same more concisely as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But hold on a moment, how come the button click worked? That''s because we
    used the `Clicked()` function on the `button` component. This is a convenience
    function that sets up the signal connection for you (and keeps the code a little
    neater!). If you look at the source code for the `Button.Clicked()` function,
    you will see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And so, you can see it is not always essential to *wire* these connections manually
    as `Go-GTK` provides many convenience methods like this one.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous examples all use a function with no parameters. While this is often
    enough, it can be helpful to pass additional information into your signal handling
    functions. This can be done easily as the connect functionality (mirrored by the
    `Clicked()` convenience function) allows for additional parameters to be sent.
    After the function reference, you can pass additional data parameters, which will
    be available to the function that executes the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate that by creating a new button and passing this button along
    with the function to the signal connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the callback function, we update the function signature to accept a `*glib.CallbackContext`
    parameter. This parameter contains the data that was specified when the signal
    was connected. The data can be accessed using the context's `Data()` function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s convenient to convert the type of the data returned, but remember to
    be careful when asserting the new type, as an incorrect type will cause your program
    to crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Bringing this together in a simple example where we create three buttons with
    the same callback function, we can see how this data parameter allows us to avoid
    unnecessary functions being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/595b9349-0a69-4380-97f1-bd584cb48caf.png)    ![](img/594dc77d-9ddc-4305-a148-05de9ff54e10.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple buttons; The clicked function handling multiple buttons' click callbacks
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, the previous code snippet mentioned a new package, `glib`.
    Let's look at the different packages that the `Go-GTK` project consists of and
    when you might want to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Go-GTK` project contains a number of namespaces used to organize the code
    and make it easier for developers to find what they're looking for. These sub-projects
    or packages reflect the naming within the main GTK+ project, so those familiar
    with this can skip this section. Most of the examples so far used just `gtk`,
    which is clearly the main package to use for building a user interface but, as
    we saw before, `glib` may be important too (for things not specifically about
    widgets).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at what each namespace covers and see where it might be useful
    in application development:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `gdk` | GDK stands for GIMP Drawing Kit; it''s a low-level component of GTK+
    that handles the details of rendering on each platform that is supported. This
    provides an abstraction of the operating system details, therefore allowing other
    areas of GTK+ to be platform agnostic. This package will be useful if your application
    needs to draw any custom elements. |'
  prefs: []
  type: TYPE_TB
- en: '| `gdkpixbuf` | Pixbuf refers to an in-memory buffer containing pixel data
    for rendering images. This package provides some convenience functions for managing
    images that can be loaded into a Go-GTK application. Of note is the `gdkpixbuf.NewPixbufFromData`
    function, which, combined with the `make_inline_pixbuf` tool, allows the loading
    of images embedded in the application. |'
  prefs: []
  type: TYPE_TB
- en: '| `gio` | `gio` represents an input/output abstraction for GTK+ applications.
    It provides access to local and remote files with a consistent API. |'
  prefs: []
  type: TYPE_TB
- en: '| `glib` | `glib` is the supporting library for all GTK+ features and applications.
    It implements the object-oriented system as well as various data structures and
    utilities. As the Go language defines many of these natively, the glib package
    within Go-GTK is responsible for translating from Go to glib (C) structures. This
    is where thread management and message passing are handled, but most of these
    features are hidden by the higher-level functions of the library. |'
  prefs: []
  type: TYPE_TB
- en: '| `gtk` | The main namespace for widgets in the GTK+ library. As we''ve already
    seen, it presents a cross-platform toolkit for creating graphical applications,
    which is made possible by the other packages listed here. |'
  prefs: []
  type: TYPE_TB
- en: '| `pango` | **Pango** is a font rendering library, which provides high-quality
    text glyphs for GTK+ applications. It''s unlikely that you would need to call
    any of these APIs directly; it is mainly used internally for rendering text within
    GTK+. |'
  prefs: []
  type: TYPE_TB
- en: Having looked at the main packages within `Go-GTK` (and seen that an application
    will probably only need to use `gtk`, `glib`, and `gdk`), we will see how this
    comes together in a larger application.
  prefs: []
  type: TYPE_NORMAL
- en: Sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to dust off the GoMail application design again and adapt it for GTK+
    widgets. As the andlabs UI application (when run on Linux) was using GTK+, it
    would seem logical to start from there. However, this time we are not limited
    by the *lowest common denominator* design constraint, which the native cross-platform
    design of andlabs worked around, so let's start from scratch and see what GTK+
    can do.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic layout with GTK+-based applications uses a familiar vertical and horizontal
    box model. Go-GTK (as a straightforward binding to this API) exposes this same
    functionality. We lay out the GoMail main window using a vertical box to position
    the menu and toolbar above the main content. Our main content is then a horizontally
    split pane created with `gtk.NewHPaned()` (where **H** refers to the horizontal
    layout, not the bar orientation, which is vertical). Before looking at the details,
    here''s the basic layout code for the main window. The toolbar and menu creation
    code is omitted for brevity but can be found in the example code repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are two things of note in this code. First is the `padding` constant defined
    at the top of the file. The box model doesn't define a standard spacing and so
    we pass this constant each time the layout requires some visual padding. The second
    important lesson is the difference between the `Add(IWidget)` and `PackStart(IWidget,
    bool, bool, uint)` methods on the boxes. The `Add` method simply appends the widget
    to the container (`gtk.Box` inherits from `gtk.Container`) and it'll cause the
    child to expand to fill the space available. For a menu bar and toolbar, we don't
    desire a vertical expansion so we use the `PackStart` method, which allows more
    control over behavior. The first Boolean parameter controls expansion; by passing
    `false`, we instruct the container that the widget shouldn't take up any free
    space.
  prefs: []
  type: TYPE_NORMAL
- en: The second Boolean controls fill and states whether or not the widget should
    fill any space available after any space calculations have been performed, so
    passing `true` specifies that our toolbar should be full width. In `gtk.VBox`,
    the expand parameter refers to vertical stretch and the fill applies to horizontal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add some content to the list view, which requires the creation
    of a model to represent the content we will present. As the content will be a
    single column with no parent/child relationship, we can use `gtk.ListStore`, rather
    than the more complex `gtk.TreeStore`. The way that content is set into a model
    is by using an iterator and applying values to each row of data. For the purpose
    of this layout, we add `email1` and `email2` to the 0th (first) column of the
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The toolbar API is simple to use and, by utilizing the stock icons included
    in GTK+, provides standard icons for many common actions. As some of our buttons
    are non-standard (`Reply` and `Reply All`), we set the toolbar style to show icons
    and labels; later, we can add some custom icons. Each item can have its action
    set using the `OnClicked()` function or by connecting the `clicked` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the icons can be added similarly. The menu code is slightly more
    complicated; each drop-down menu (whether a sub-menu or a main menu) needs to
    be created with `gtk.NewMenu()`, and its items added as shown. Each top-level
    menu then needs to have a new menu item created (for example, `gtk.NewMenuItemWithLabel()`)
    and the menu connected using `SetSubmenu()`. The constructed menu can then be
    appended to the menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of this code in place (and a few more items in the toolbar and menu),
    we have a basic application layout that should look familiar. As you can see,
    we are already benefiting from the additional features of a larger widget toolkit
    with standard icons and more complete styling and layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab1087c8-df37-4f30-9439-8971ab1b8ecd.png)'
  prefs: []
  type: TYPE_IMG
- en: The basic layout of GoMail using Go-GTK before we make any style adjustments
  prefs: []
  type: TYPE_NORMAL
- en: The layout, particularly of the email details panel, can be improved using `label.SetAlignment(0,
    0)` to set a left alignment, and the content of a label can be made bold by using
    the markup capability of the `pango` library; just call `label.SetMarkup(fmt.Sprintf("<b>%s</b>",
    label.GetText()))`. The preceding code was focused on the basic layout, so these
    tweaks have been left out. The additional details are included in the example
    code repository and the completed interface can be seen in the later section about
    themes.
  prefs: []
  type: TYPE_NORMAL
- en: Compose layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code to display the compose dialog should look very familiar by now. The
    window is created as  `gtk.WINDOW_TOPLEVEL` because Go-GTK only allows a choice
    of top-level or popup (that is, floating content), rather than child windows such
    as a dialog. We set up a destroy function that will close the window rather than
    exiting the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the layout code is the usual vertical box for each item with a
    horizontal box for the `to` label, which is left of the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see with `buttonBox`, we''ve made use of the `PackEnd()` function
    described before to right-align the buttons at the bottom of the compose window.
    We also make use of the `padding` definition from the main window to provide consistent
    spacing for our widgets. Running the preceding code should load a window similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a944182-f93f-4f78-837f-0754e2dc0461.png)'
  prefs: []
  type: TYPE_IMG
- en: The GoMail compose window with Go-GTK
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the basic layout and input fields prepared, let's connect to
    some content using our test email server.
  prefs: []
  type: TYPE_NORMAL
- en: Signaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a traditional GTK+ application, it would be possible, even recommended, to
    make use of the built-in signal handling capabilities. A new signal could be created,
    which would then be emitted by the application at an appropriate time; components
    could connect to this signal and respond appropriately. However, the ability to
    create signals is not exposed through the Go-GTK API and so we will use callbacks
    like the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load our test server, we first update the `main()` function to set up a
    server and pass it to the user interface creation code. We then set the content
    to show the current message from our test server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes use of a new helper function that will set the content of the email
    detail panel. We will call this from our list selection code later as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the content of the email list, we store the iterator and the model in
    our application struct when created, so they can be referenced later. The following
    helper function handles the details of prepending an item to the email list. This
    function is called on each message in `server.ListMessages()` to set up the initial
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the basic communication with the user interface is to handle
    the selection of items in the tree view. To handle this, our application must
    implement `gtk.GtkTreeSelecter`, which has a single `Select()` function. The following
    implementation will suit our needs. Firstly, note that this can be called for
    selection and deselection, so we need to check that the item is not currently
    selected. Then, we use the path specified when the callback is invoked to determine
    the row that was clicked. This row number is used to get the email from the server
    list of messages. We can then call our helpful `setEmail()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For the select handler to be called, we must register it on `gtk.ListView`
    when it is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, the user interface should be complete. We need to handle background updates
    when new emails arrive.
  prefs: []
  type: TYPE_NORMAL
- en: Thread handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can correctly handle background processing with Go-GTK (or any GTK+
    implementations), we must correctly initialize the thread handling portions of
    the underlying libraries (`glib` and `gdk`). These lines should be entered at
    the start of an application''s `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the thread handling has been set up, we can write background code that
    will communicate with the user interface. This code must execute on the same thread
    that the application was created with. To ensure this, we use the helper functions, `gdk.ThreadsEnter()`
    and `gdk.ThreadsLeave()`, around the code we wish to execute. For our application
    to add new messages to the end of our email list when they arrive, add the following
    code immediately before calling `gtk.Main()` to start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This completes the implementation of our GoMail application in Go-GTK, but how
    can we compile the app for different platforms?
  prefs: []
  type: TYPE_NORMAL
- en: Cross compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compiling a Go-GTK based application for additional platforms requires requires
    additional C compilers to be installed so that CGo can create the necessary binary
    output. The steps for completing this, if you haven't done so already, are in the
    [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler Setup*.
    You'll also need to have GTK+ installed, which should obviously already be the
    case. As the *Cross compilation* section of [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications,* andlabs UI already stepped through
    the details, so we won't repeat them here. The process is identical due to andlabs
    UI's use of the GTK+ library for some target platforms. Be sure to set the appropriate `GOOS`,
    `GOARCH`, `CGO_ENABLED`, `CC`, and `CXX` environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap up our exploration of the toolkit, we should look at the benefits
    provided by its theming capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Theming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the large benefits of using a GTK+ (or Qt)-based API is that the widget
    set can be themed. Users are able to install any number of themes (or write their
    own) to control how applications look. While this can add a testing overhead,
    they will behave the same across all platforms so the burden is somewhat reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a few different themes applied to our GoMail application illustrated
    here, starting with a great light theme named `Clearlooks`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Clearlooks theme on Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b098c234-0783-4547-bdea-f04ef12277e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Compose in Clearlooks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5b9f0b84-23d6-4ce9-857f-afc942a03423.png)'
  prefs: []
  type: TYPE_IMG
- en: On Windows, the default theme looks more like the standard widgets, though the
    user can load any other GTK+ theme. Notice that the default icons are also different,
    more in-keeping with the operating system standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Windows default theme:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6cf8a775-a445-4453-865e-55ee25d8bbcc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Compose with Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/04381830-6892-4a64-a081-e6a380c21ced.png)'
  prefs: []
  type: TYPE_IMG
- en: There are also many dark themes; *Arc Dark* is very popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arc Dark theme running on Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4d074dae-f1b5-4de5-9b98-03641d205430.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Ark Dark compose window:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/72bfdb9e-5b75-483d-80cc-7b37de092b5f.png)'
  prefs: []
  type: TYPE_IMG
- en: Many themes are designed for nostalgia, including this CDE theme, which is based
    on a colorful desktop environment from the 1990s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running a CDE theme for the old-school look:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d0c5c8e9-5504-4fd0-939d-1b2ee96e4c04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Composing in a CDE theme:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d0b8e27c-2dc1-4d6e-aabf-d39e0b2745c7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the colors of the user interface elements can vary significantly
    but the layouts are largely consistent. If you look at the buttons (`Send` and
    `Cancel` on the compose window), there's also a difference between how rounded
    some edges are. Applications built with Go-GTK should work well with any theme
    loaded, but it is advisable to check various different configurations as part
    of your quality assurance process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the details of the GTK+ toolkit and how it is made
    available to Go through go-GTK. We looked at how to get it set up on macOS, Windows,
    and Linux and how the applications look and behave exactly the same across these
    platforms. We explored the API design, its various components, and how its event
    driven model is exposed to developers.
  prefs: []
  type: TYPE_NORMAL
- en: We then returned to the GoMail application from [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications,* and [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml),
    *andlabs UI - Cross-Platform Native UIs*, rebuilding it using the Go-GTK library.
    As the API provides access to most GTK+ features, we found that the application
    looks more complete than the GTK+ based application created by the Linux driver
    within andlabs UI used in [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml),
    *andlabs UI - Cross-Platform Native UIs*. We implemented some basic thread and
    signal handling within the application to handle user input and background events.
    Lastly, we explored how the powerful GTK+ theme engine could style the created
    application user interface.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be familiar with the Go-GTK library, and how it leverages
    the underlying GTK+ toolkit and allows the quick development of GUI applications
    with Go. These applications will differ from the operating system standard look
    and feel, but are close to standard application design and so should be familiar
    to most users. If the interface widget design or API wasn't quite what you were
    looking for, then read the next chapter, where we look at an alternative to GTK,
    the Qt framework.
  prefs: []
  type: TYPE_NORMAL
