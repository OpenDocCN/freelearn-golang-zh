<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Go-Qt - Multiple Platforms with Qt</h1>
                </header>
            
            <article>
                
<p>Similar to the Go-GTK library we explored in the previous chapter, qt by therecipe allows you to write cross-platform graphical applications with a single Go code base. It leverages Qt,<span> </span><span>a multi-platform application framework that's designed for rapid delivery of applications to desktop and embedded computing environments. Like GTK+, it's designed to draw widgets that are familiar to the end user but aren't reliant upon the operating system's provided toolkit. Additionally, Qt provides a different look for mobile and embedded devices where users expect a different style of presentation. All of this is controlled within the framework so the developer can concentrate on developing a single application.</span></p>
<p>In this chapter, we'll look at the details of therecipe/qt, the most widely adopted Qt binding for the Go language. We'll cover the following:</p>
<ul>
<li>The history and aims of the Qt framework</li>
<li>How the API is designed and bridged into Go</li>
<li>Creating an application using therecipe/qt library</li>
<li>The theming capabilities of Qt applications</li>
</ul>
<p>By the end of this chapter, you'll be familiar with the capabilities of the Qt framework and its support of many different platforms. Through the exploration of some example applications and our GoMail application, you'll learn how the Go bindings of therecipe provide access to these features for development in Go. You should also have an understanding of whether the Qt framework is a good fit for your next application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Qt background</h1>
                </header>
            
            <article>
                
<p>The Qt framework was created in 1991 by a company named Trolltech (now called the Qt Company). The KDE Linux desktop is based on Qt and its increase in popularity may be a key reason why Qt development became more widespread. As a platform that's, in part, aimed at embedded devices, the typical developers using Qt are different to those for the GTK+ framework. Additionally, the tooling and support available is better developed due to their commercial backing.</p>
<p>The Qt framework is released in two separate distributions, one commercial and one open source (known as dual licensing). In this manner, they can support open source-compliant applications for free, while providing unrestricted usage for closed source commercial projects. Before the year 2000 (with the release of 2.2), the source code for the free distribution had been under various licenses that some groups considered incompatible with common open source initiatives. For the 2.2 release, it was changed to GPL licensing, which settled any concerns about the group's commitment to true open source freedoms. In 2007, Qt 4.5 was released and they added LGPL as an option for developers who prefer the more permissive license.</p>
<p><span>In 2011, the Nokia company founded the Qt Project in a move to open up the development and road map of the Qt libraries. Qt's largest market is in embedded devices, such as cars and appliances, the technology being utilized by large companies such as Tesla and Mercedes Benz:</span></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/62482bd5-b103-447a-a4b8-fca90f0d343a.png" width="1193" height="671"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Scribus is a popular desktop publishing application written with Qt (image copyright: Henrik Hüttemann)</div>
<p>The Go bindings by therecipe (whose real name isn't attached to the project), along with many contributors, aims to bring the Qt API along with its substantial list of supported platforms to the Go language. The project supports building applications for Windows, macOS, and Linux desktop computers but also Android, iOS, and many other mobile and embedded devices.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started with therecipe/qt</h1>
                </header>
            
            <article>
                
<p>To begin our exploration of Qt and the binding to Go, we'll build a simple <em>hello world</em> application. To be able to do so, we first need to install therecipe/qt, which depends on various prerequisites that we must first set up.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p>As with Go-GTK, we'll be relying on a native library that requires that we both set up the CGo functionality and install the Qt library appropriate for the current platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Preparing CGo</h1>
                </header>
            
            <article>
                
<p>The Qt Go bindings, like many of the other toolkits featured in this book, require the presence of CGo to utilize native libraries. On a full development system, it's likely that this is already set up. If you're unsure or would like a reminder of how to set up the CGo dependencies, please check the Appendix, <em>Setting Up CGo</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Qt</h1>
                </header>
            
            <article>
                
<p>The Qt website (<a href="https://www.qt.io/download">www.qt.io/download</a>) offers various methods of installation, including a customized online installer available to anyone with a Qt account (which is free to sign up for). Typically, a Qt installation comes with Qt Creator (the project IDE), the GUI designer, additional tools, and examples. Visiting the preceding site will automatically detect your system and suggest the most appropriate download (this is normally the best option).</p>
<div class="packt_infobox">Be aware that the Qt installation can be quite large. If you don't have at least 40 GB of space on your hard drive, you need to make a little space before installing.</div>
<p>Some operating systems offer Qt libraries and tools as part of their package manager, which often provides a more lightweight installation that'll automatically stay up to date. However, this option doesn't deliver the complete feature set of the Qt development tools, and the Qt bindings discussed in this chapter default to using the standard Qt installation provided by the online installer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">macOS</h1>
                </header>
            
            <article>
                
<p>On Apple macOS, the best approach to installation is to use the installer application available at the Qt download site. Visit <a href="https://www.qt.io/download">www.qt.io/download</a> and download the macOS installer. Once it has downloaded, open the package and run the program inside; this will install the selected compilers, tools, and supporting applications. If you encounter any errors during installation, the first step would be to check that your Xcode installation is complete and up to date (for more information, see the <em>Installation Details</em> appendix).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Windows</h1>
                </header>
            
            <article>
                
<p>Installing on Windows is more straightforward than some of the other toolkits we've looked at, as the Qt installer has a <kbd>mingw</kbd> package bundled to set up most of the compiling requirements (though it's still recommended to have your own compiler set up for the binding phase next). To install it, go to the download page listed previously and access the Windows installer. Run the downloaded executable and follow the onscreen instructions.<span> It's recommended to install to the default location. Once that's done, you're ready to set up the bindings.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linux</h1>
                </header>
            
            <article>
                
<p>Using the online installer from <a href="https://www.qt.io">https://www.qt.io</a> is the easiest approach, though it may be possible to install through your system's package manager (if you want to try the package manager approach, then first read the Qt Linux documentation at <a href="https://github.com/therecipe/qt/wiki/Installation-on-Linux">https://github.com/therecipe/qt/wiki/Installation-on-Linux</a>). On most Linux platforms, the Qt downloads website will correctly detect the platform and offer a simple run installer. After downloading the file, you should make it executable and then run it:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/81bc1ed7-f7fc-4d74-b9e5-8c188a6b796f.png" style="width:31.50em;height:7.33em;" width="867" height="201"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">On Linux, you need to make the install file executable and run it</div>
<p>This will start the installer just as on macOS; from here, follow the onscreen instructions and complete the installation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">License / Qt account</h1>
                </header>
            
            <article>
                
<p>When it comes to the login screen, then you should enter your Qt account details if you have them. If you qualify for their open source license (GPL or LGPL), you can skip this step—to do so; make sure the email and password fields are empty.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing qt (the bindings)</h1>
                </header>
            
            <article>
                
<p>To use qt (the Go Qt bindings), we need to download the project and its dependencies and then run a setup script to configure and compile the library. If using Windows, it's recommended to use the MSYS2 Terminal described in the Appendix.</p>
<div class="mce-root packt_infobox"><span>If you installed the Qt download to anything other than the default location, then make sure to set up the <kbd>QT_DIR</kbd> environment variable to the location you chose.</span></div>
<p>First, the library and its dependencies should be installed using the <kbd>go</kbd> tools, by running <kbd><span class="s1">go get github.com/sirupsen/logrus</span></kbd> and <kbd>go get github.com/therecipe/qt</kbd>.</p>
<p>Once the download has completed, we need to run the <kbd>qtsetup</kbd> tool, which is included in the qt project; so, within the <kbd>cmd/qtsetup</kbd> folder, execute <kbd>go run main.go</kbd>. Using a Linux Terminal, it should look something like this:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/7edffb31-a6d7-43ad-a88a-49b9832ea4fa.png" style="width:39.92em;height:12.00em;" width="982" height="295"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Executing the qtsetup script for therecipe/qt bindings</div>
<p>Once this process <span>completes, the bindings should be ready to use. If you encounter errors, then it's probably because the Qt tools aren't correctly installed or the location was customized and you forgot to set the</span> <kbd>QT_DIR</kbd> <span>environment variable.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Build</h1>
                </header>
            
            <article>
                
<p>To build our first qt application with Go, let's make another <em>Hello World</em> application. As with previous examples, we'll make use of a simple vertical box layout within a single application window. The following code should be sufficient to load your first application:</p>
<pre>package main<br/><br/>import (<br/>   "os"<br/><br/>   "github.com/therecipe/qt/widgets"<br/>)<br/><br/>func main() {<br/>   app := widgets.NewQApplication(len(os.Args), os.Args)<br/><br/>   window := widgets.NewQMainWindow(nil, 0)<br/>   window.SetWindowTitle("Hello World")<br/><br/>   widget := widgets.NewQWidget(window, 0)<br/>   widget.SetLayout(widgets.NewQVBoxLayout())<br/>   window.SetCentralWidget(widget)<br/><br/>   label := widgets.NewQLabel2("Hello World!", window, 0)<br/>   widget.Layout().AddWidget(label)<br/><br/>   button := widgets.NewQPushButton2("Quit", window)<br/>   button.ConnectClicked(func(bool) {<br/>      app.QuitDefault()<br/>   })<br/>   widget.Layout().AddWidget(button)<br/><br/>   window.Show()<br/>   widgets.QApplication_Exec()<br/>}</pre>
<p>Let's note a few details from this code snippet. You'll see that each of the widget constructor functions takes (typically) two parameters, each is the parent widget and a <kbd>flags</kbd> parameter. Additional types passed in will usually be added before these values with a note in the function name that there are additional parameters. For example, <kbd>widgets.NewQLabel2(title, parent, flags)</kbd> is equivalent to <kbd>widgets.NewQLabel(parent, flags).SetTitle(title)</kbd>. Additionally, you'll see that the layout is applied to a new <kbd>widgets.QWidget</kbd> through <kbd>SetLayout(layout)</kbd>, and that's set to the window content through <kbd>window.SetCentralWidget(widget)</kbd>.</p>
<p>To load the display and run the application, we call <kbd>window.Show()</kbd> and then <kbd>widgets.QApplication_Exec()</kbd>. This file is built in the usual way with <kbd>go build hello.go</kbd>:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/5c9075ef-025a-43d9-a4af-2f3275a4b57e.png" style="width:33.58em;height:11.92em;" width="490" height="174"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Building is simple though the output file is rather large</div>
<p>The file built is quite large due to the size of the Qt framework. This will be reduced significantly when packaging for a specific distribution. This topic will be covered in depth in <a href="8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml"/><a href="8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml">Chapter 14</a>, <em>Distributing your Application</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Run</h1>
                </header>
            
            <article>
                
<p>The output of the build phase is a binary that can be executed on the current computer, either on the command line or by double-clicking in a file manager. Additionally, you could execute it directly with <kbd>go run hello.go</kbd><span>—</span>either way, you should see a simple window, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img style="border: 1em solid black;font-size: 13.3333px;text-align: center;width:6.17em;height:5.92em;" src="Images/1498312d-2fd5-4bdd-b0bc-b7435b659dc4.png" width="183" height="176"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>qt Hello on Linux</span></div>
<p class="CDPAlignCenter"><img src="Images/b241f60e-5044-47ce-975b-69de70895561.png" style="width:6.33em;height:6.17em;" width="200" height="194"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Running on macOS</div>
<p><span>At this stage, the binaries can be executed on a computer with the same architecture that also has Qt installed. We'll look at wider distribution later in this chapter. Before that, let's take a deeper look into the Qt API and how the qt bindings work.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Object model and event handling</h1>
                </header>
            
            <article>
                
<p>The Qt framework is written using the C++ language, and so much of its architecture will be familiar to those who've coded in C++ before. It's important to note that Go isn't a complete object-oriented language and, as such, doesn't match these capabilities directly. In particular, we should look at inheritance as it's important to the Qt object model.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inheritance</h1>
                </header>
            
            <article>
                
<p>The Qt API is a fully object-oriented model that makes heavy use of the inheritance model. While Go doesn't truly support object-oriented inheritance in the traditional<span> m</span><span>anner, its composition approach is very powerful and works well in its place. The result means that you probably won't notice the difference! This only comes into play if you wish to implement a custom widget, which is out of scope for this chapter.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Memory management</h1>
                </header>
            
            <article>
                
<p>As you'll have noticed in the preceding example, each widget expects the parent to be passed to the constructing function. This enables the Qt framework to handle the tidying up, and freeing of memory when a tree of widgets is removed. <kbd>QObject</kbd> (which is the base object for all of the Qt API) keeps track of its child objects and so, when being removed, can remove its children too. This makes the creation and deletion of complex widget hierarchies easier to handle correctly. To make use of this feature, you should always remember to pass the parent object to a widget's constructor (the Go functions starting with <kbd>New...</kbd>), despite the fact that passing <kbd>nil</kbd> may look like it's working.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Signals and slots</h1>
                </header>
            
            <article>
                
<p>Qt is, like GTK+, an event-driven framework and uses signals extensively to handle event management and data communications. In Qt, this concept is split into signals and slots; a signal is what will be generated when an event occurs and a slot is what can receive a signal. The action of setting a slot to receive a signal is called <strong>connecting</strong> and this causes a slot function to be called when its connected signal is invoked. In Qt, these are typed events meaning that each signal has a list of type parameters associated with it. When the signal is defined, this type is set and any slot wishing to connect to the signal will need to have the same type.</p>
<p>In qt Go code, signals and slots are defined using struct tags such as <kbd>_ func(string) `signal:"mySignal"`</kbd><span class="pl-s"><span class="pl-pds"> and <kbd>_ func(string) `slot:"mySlot"`</kbd></span></span>, which provide metadata to the Go type system, much as our JSON example in <a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml"/><a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml"/><a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml"/><a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml">Chapter 3</a>, <em>Go to the Rescue!</em>. Given a struct, <kbd>s</kbd>, which defines these properties, we could set a function to execute when <kbd>mySignal</kbd> is fired with the following code:</p>
<pre>s.<span class="pl-c1">ConnectMySignal(<br/>   func(msg string) {<br/>      log.Println("Signalled message", msg)<br/>   }<br/>)</span></pre>
<p>Signals and slots are what power user interfaces generated with Qt Designer and are the recommended way of handling multi-threaded applications. A signal may fire from a background thread and the user interface code can connect this signal to its own slot<span>—</span>in essence, listening for the signal. When the signal fires, any associated data (parameters to the signal) will be passed from one thread to another so it can be used safely within the GUI updates. In many ways, this is similar to how Go channels work, which we've discussed extensively in <a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml">Chapter 3</a>, <em>Go to the Rescue!</em>.</p>
<p>As qt is a lightweight binding to the Qt API, the Go-specific documentation is minimal but you can find out a lot more about the Qt design and all of the classes available in the official documentation available at <a href="https://doc.qt.io/qt-5/classes.html">https://doc.qt.io/qt-5/classes.html</a>.</p>
<p>Now that we know how a Qt application and the qt Go implementation are set up, let's explore a more complete application by returning to our GoMail example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sample application</h1>
                </header>
            
            <article>
                
<p>To look at a more complete application, we'll dust off the original designs for the GoMail application<span>—</span>after all, they were created with Qt Designer in the first place. We'll recreate the exact layout generated in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications,</em> and explain the implementation as we go.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>For the first time in our GoMail examples, we have a toolkit that provides all of the layouts required to match the user interface we designed at the beginning of <a href="36bfea00-c659-4569-864c-de2c460c7467.xhtml">Section 2</a>, <em>Toolkits Using Existing Widgets</em>. That's perhaps no surprise, as it was created using the Qt tools, but it's a chance to explore the more complete set of layouts provided by Qt and made available using the qt bindings. The most useful ones are the following:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 5.81959%"><strong><span>Layout</span></strong></td>
<td style="width: 83.1135%"><strong>Description</strong></td>
</tr>
<tr>
<td style="width: 5.81959%"><strong><span>box</span></strong></td>
<td style="width: 83.1135%">The box layout is very familiar by now; it lays out widgets in a horizontal or vertical box. Therefore, it's created with <kbd><span>widgets.</span><span class="pl-c1">NewQVBoxLayout()</span></kbd><span><span> or </span></span><span><kbd>widgets.<span class="pl-c1">NewQVBoxLayout</span>()</kbd> </span>accordingly.</td>
</tr>
<tr>
<td style="width: 5.81959%"><strong><span>form</span></strong></td>
<td style="width: 83.1135%">
<p>This is a convenience layout that's basically a two-column grid where all of the widgets in the left column are labels. This is styled accordingly to produce the design we saw in Qt Creator.</p>
</td>
</tr>
<tr>
<td style="width: 5.81959%">
<p><strong><span>grid</span></strong></p>
</td>
<td style="width: 83.1135%">
<p>This layout represents a flexible grid layout so that cells aren't forced to all be the same size but instead rows and columns flex to accommodate the minimum size of items packed into the grid.</p>
</td>
</tr>
<tr>
<td style="width: 5.81959%"><strong><span>spacer</span></strong></td>
<td style="width: 83.1135%">
<p>While not strictly a layout, the spacer item can be used in layouts to create visual space. Constructed using <kbd>widgets.NewQSpacerItem(width, height, hPolicy, vPolicy)</kbd>, it's possible to add various different types of space using this helpful class.</p>
</td>
</tr>
<tr>
<td style="width: 5.81959%"><strong><span>stacked</span></strong></td>
<td style="width: 83.1135%">
<p>A stacked layout sets all child objects to be the full size of the containing widget, but ensures that only one can be visible at a time. The <kbd>SetCurrentWidget()</kbd> and <kbd>SetCurrentIndex()</kbd> functions can be used to control which child is visible. This is very useful for implementing tabbed panels or paged controls.</p>
</td>
</tr>
</tbody>
</table>
<p>Using this knowledge, we can re-create the GoMail browse interface using pure Qt widgets. A lot of this code will be familiar by now, but there are a number of notable differences. Firstly, you can see that layouts (as listed previously) are typically set on <kbd>widgets.QWidget</kbd> rather than creating a whole new widget for their own purpose. This approach means that the number of different widgets can be kept lower, but it also causes some functionality to be attached to the layout and not the widget. For example, the <kbd>widgets.NewQFormLayout()</kbd> we set on the <kbd>detail</kbd> widget is designed to lay out form components, and as such has helper functions to add rows (<kbd>form.AddRow3</kbd>, for example). To use these functions, we must keep a reference to the layout (the <kbd>form</kbd> <span>variable </span>in this code) to operate on. You can also see that <kbd>AddWidget()</kbd> is called on <kbd>widget.Layout()</kbd> rather than on <kbd>widget</kbd> directly.</p>
<p>This snippet contains most of the code to create our basic layout. Some of the toolbar and menu code (which is rather repetitive) has been left out, but it can be found in the code repository that accompanies this book. We start with the imports and a basic skeleton for creating a menu bar:</p>
<pre>package main<br/><br/><span>import </span>(<br/>   <span>"github.com/therecipe/qt/core"<br/></span><span>   "github.com/therecipe/qt/gui"<br/></span><span>   "github.com/therecipe/qt/widgets"<br/></span><span>   "os"<br/></span>)<br/><br/><span>func </span>buildMenu() *widgets.QMenuBar {<br/>   menu := widgets.NewQMenuBar(nil)<br/><br/>   file := widgets.NewQMenu2(<span>"File"</span>, menu)<br/>   ...<br/>   menu.AddMenu(file)<br/><br/>   ...<br/><br/>   <span>return </span>menu<br/>}</pre>
<p>And similarly, we can create a new toolbar using built-in icons:</p>
<pre><span>func </span>buildToolbar() *widgets.QToolBar {<br/>   toolbar := widgets.NewQToolBar(<span>"tools"</span>, nil)<br/>   toolbar.SetToolButtonStyle(core.Qt__ToolButtonTextUnderIcon)<br/>   toolbar.AddAction2(gui.QIcon_FromTheme2("document-new", nil), "New")<br/><br/>   ...<br/><br/>   <span>return </span>toolbar<br/>}</pre>
<p>And lastly, we lay out the main content of the window:</p>
<pre><span>func </span>main() {<br/>   widgets.NewQApplication(len(os.Args), os.Args)<br/><br/>   window := widgets.NewQMainWindow(nil, <span>0</span>)<br/>   window.SetWindowTitle(<span>"GoMail"</span>)<br/><br/>   widget := widgets.NewQWidget(window, <span>0</span>)<br/>   widget.SetLayout(widgets.NewQVBoxLayout())<br/>   window.SetMinimumSize2(<span>600</span>, <span>400</span>)<br/>   window.SetCentralWidget(widget)<br/><br/>   window.SetMenuBar(buildMenu())<br/>   widget.Layout().AddWidget(buildToolbar())<br/><br/>   list := widgets.NewQTreeView(window)<br/>   list.SetModel(core.NewQStringListModel2([]string{"email1", "email2"}, widget))<br/><br/>   detail := widgets.NewQWidget(window, <span>0</span>)<br/>   form := widgets.NewQFormLayout(detail)<br/>   detail.SetLayout(form)<br/>   form.AddRow5(widgets.NewQLabel2(<span>"subject"</span>, detail, <span>0</span>))<br/>   form.AddRow3(<span>"From"</span>, widgets.NewQLabel2(<span>"email"</span>, detail, <span>0</span>))<br/>   form.AddRow3(<span>"To"</span>, widgets.NewQLabel2(<span>"email"</span>, detail, <span>0</span>))<br/>   form.AddRow3(<span>"Date"</span>, widgets.NewQLabel2(<span>"date"</span>, detail, <span>0</span>))<br/>   form.AddRow5(widgets.NewQLabel2(<span>"content"</span>, detail, <span>0</span>))<br/><br/>   splitter := widgets.NewQSplitter(window)<br/>   splitter.AddWidget(list)<br/>   splitter.AddWidget(detail)<br/>   widget.Layout().AddWidget(splitter)<br/><br/>   window.Show()<br/>   widgets.QApplication_Exec()<br/>}</pre>
<p>The preceding code is similar in structure to the previous chapter (as GTK+ and Qt APIs have many similarities), though the naming will remind you of <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications,</em> and the Walk example. Clearly, as Walk is based largely on Qt, the naming is often the same, but the qt APIs being used here don't offer the same declarative syntax and so must be created using the function-based constructors.</p>
<p>This example introduces two new qt packages, <kbd>core</kbd> and <kbd>gui</kbd>. As you can see from the example, we use the <kbd>core</kbd> package with data models (which many of the more complex widgets make use of). The <kbd>gui</kbd> package provides helpful additions to make a user interface more compelling; in this instance, we're looking up standard icons using the <kbd>gui.QIcon_FromTheme2</kbd> function. In a more complete application, we could provide fallback icons that would complete the <span class="packt_screen">Reply</span> and <span class="packt_screen">Reply All</span> toolbar buttons:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/ba6d0d00-306d-4898-976f-575f62f71bec.png" style="width:23.58em;height:15.17em;" width="448" height="288"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The complete layout of our GoMail application using qt</div>
<p class="mce-root">As you can see from this screenshot, a qt application can look polished with even the most basic of code. You may notice the <span class="packt_screen">1</span> above our email list instead of <span class="packt_screen">Inbox</span>; this is due to a limitation in <kbd>core.QStringListModel</kbd> used for this layout example and should be addressed in our full implementation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The compose layout</h1>
                </header>
            
            <article>
                
<p>The GoMail compose layout is even simpler: we use <kbd>widgets.QFormLayout</kbd> again, though the <kbd>To</kbd> field is the only line with a label included. For this simpler window, we create <kbd>widgets.QDialog</kbd> and set the layout directly on the dialog widget. To add the buttons at the bottom of the screen, we use a new <kbd>widgets.QWidget</kbd> with the layout set to <kbd>widgets.NewQHBoxLayout()</kbd> to lay the buttons out horizontally. To manage the right alignment, we first include <kbd>widgets.NewQSpacerItem()</kbd> in the button box before the buttons. Note lastly that we call <kbd>SetDefault(true)</kbd> on the <kbd>send</kbd> button so it becomes the default action:</p>
<pre><span>package </span>main<br/><br/><span>import </span><span>"github.com/therecipe/qt/widgets"</span><br/><br/>func <span>showCompose() {<br/></span>   dialog := widgets.NewQDialog(nil, <span>0</span>)<br/>   dialog.SetModal(<span>false</span>)<br/>   dialog.SetWindowTitle(<span>"New GoMail"</span>)<br/><br/>   form := widgets.NewQFormLayout(dialog)<br/>   dialog.SetLayout(form)<br/>   dialog.SetMinimumSize2(<span>400</span>, <span>320</span>)<br/><br/>   form.AddRow5(widgets.NewQLineEdit2(<span>"subject"</span>, dialog))<br/>   form.AddRow3(<span>"To"</span>, widgets.NewQLineEdit2(<span>"email"</span>, dialog))<br/>   form.AddRow5(widgets.NewQTextEdit2(<span>"content"</span>, dialog))<br/><br/>   buttons := widgets.NewQWidget(dialog, <span>0</span>)<br/>   buttons.SetLayout(widgets.NewQHBoxLayout())<br/>   buttons.Layout().AddItem(widgets.NewQSpacerItem(<span>0</span>, <span>0</span>, widgets.<span>QSizePolicy__Expanding</span>, <span>0</span>))<br/>   buttons.Layout().AddWidget(widgets.NewQPushButton2(<span>"Cancel"</span>, buttons))<br/>   send := widgets.NewQPushButton2(<span>"Send"</span>, buttons)<br/>   send.SetDefault(<span>true</span>)<br/>   buttons.Layout().AddWidget(send)<br/>   form.AddRow5(buttons)<br/><br/>   dialog.Show()<br/>}</pre>
<p>From the preceding code, we get the following desired outcome<span>—</span>a simple and familiar compose dialog window:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4ae3c61a-ffb3-4135-9f6d-7f0b58246388.png" style="width:21.50em;height:11.75em;" width="400" height="219"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The email compose dialog using qt widgets</div>
<p>Now that the layout is complete, let's connect our test email server to show some email data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Signalling</h1>
                </header>
            
            <article>
                
<p><span>To complete the interaction of our GoMail examples, we'll make use of the standard signals and slots within qt. Firstly, we need to set up an instance of our test email server and load the data. We add a <kbd>setMessage(*client.EmailMessage)</kbd> function to set the content of our labels, which can be called on the loading of our GUI and when the email list is clicked:</span></p>
<pre><span>func </span>(m *mainUI) setMessage(message *client.EmailMessage) {<br/>   m.subject.SetText(message.Subject)<br/>   m.to.SetText(message.ToEmailString())<br/>   m.from.SetText(message.FromEmailString())<br/>   m.date.SetText(message.DateString())<br/><br/>   m.content.SetText(message.Content)<br/>}</pre>
<p>The code to handle clicking on the email list looks something like the following snippet. We're creating an anonymous function and connecting it to the <kbd>selectionChanged</kbd> signal. Remember to check whether there are no selected indexes before finding the selected row number:</p>
<pre>list.ConnectSelectionChanged(<span>func</span>(selected *core.QItemSelection, _ *core.QItemSelection) {<br/>   <span>if </span>len(selected.Indexes()) == <span>0 </span>{<br/>      <span>return<br/></span><span>   </span>}<br/><br/>   row := selected.Indexes()[<span>0</span>].Row()<br/>   m.setMessage(m.server.ListMessages()[row])<br/>})</pre>
<p><span>Next, we need to update our toolbar and menu to open the compose dialog when <span class="packt_screen">New</span> is clicked. The <kbd>triggered</kbd> signal is the one to connect to; we need to wrap <kbd>showCompose()</kbd> in an anonymous function as the signal type passes a <kbd>bool</kbd> flag (for the checked status) that we want to ignore. The code is identical for toolbars and menus:</span></p>
<pre>new := file.AddAction(<span>"New"</span>)<br/>new.ConnectTriggered(<span>func</span>(_ bool){showCompose()})</pre>
<p>Similar code is used to handle button presses, which send a <kbd>clicked</kbd> signal; our compose dialog, <kbd>c</kbd>, will connect an anonymous function to compose an email, send it, and hide the dialog when <span class="packt_screen">Send</span> is clicked:</p>
<pre>send.ConnectClicked(<span>func</span>(_ bool) {<br/>   email := c.createEmail()<br/>   c.server.Send(email)<br/>   c.dialog.Close()<br/>})</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Thread handling</h1>
                </header>
            
            <article>
                
<p>As shown in the preceding click handlers, the multi-threaded aspects of a complex application are handled by the signal-slot design in Qt. Code executed in a slot will be running on the correct thread to do graphical updates. Additionally, any data passed as part of the signal definition can be accessed in a thread-safe manner. We'll make use of this property to handle our background email notifications.</p>
<p>To set this up, we create a new  custom signal. This is made possible by the <kbd>qtmoc</kbd> tool, which comes with therecipe/qt bindings. We'll update our <kbd>mainUI</kbd> struct definition to inherit from <kbd>core.QObject</kbd> (this is a requirement) and then define an anonymous function with the <kbd>signal</kbd> tag, which defines the name of the signal:</p>
<pre>core.QObject<br/>_ <span>func</span>(message *client.EmailMessage) <span>`signal:"newMail"`</span></pre>
<p>Once this is set up, you should run the <kbd>qtmoc</kbd> tool in the current directory; this generates various methods including the <kbd>ConnectNewMail()</kbd> and <kbd>NewMail()</kbd> methods (the slots connecting method and signal trigger respectively), as well as a new constructor. Once this is complete, we must update our code to use the newly generated constructor (if your signals don't trigger slots, then this step was probably missed):</p>
<pre>main := NewMainUI(nil)</pre>
<p>We then add new code to connect <kbd>prependEmail(client.EmailMessage)</kbd> to the <kbd>newMail</kbd> signal. Once that's connected, we listen to the <kbd>server.Incoming()</kbd> channel and, each time a message arrives, we send the signal using the generated <kbd>NewMail(client.EmailMessage)</kbd> function:</p>
<pre>main.ConnectNewMail(main.prependEmail)<br/><span>go func</span>() {<br/>   <span>for </span>email := <span>range </span>main.server.Incoming() {<br/>      main.NewMail(email)<br/>   }<br/>}()</pre>
<p>With this code in place, our background code will trigger the appropriate handlers and all updates occur on the correct thread for immediate updates to the screen.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-compilation</h1>
                </header>
            
            <article>
                
<p>Compiling a<span> qt-based application for another desktop platform isn't currently supported in the same way that we've compiled other examples. There's an alternative approach, however, using Docker as a deployment method. Setting up the tools and running a build in this way is out of scope for this chapter, but you can read more about deploying qt apps at <a href="https://github.com/therecipe/qt/wiki/Deploying-Application">github.com/therecipe/qt/wiki/Deploying-Application</a>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Theming</h1>
                </header>
            
            <article>
                
<p>The Qt theme (known as <em>Style</em> in Qt terminology) can be adjusted similarly to GTK apps in the previous chapter. Before Qt 5, the current theme could be configured using a standard setup application but in Qt 5, the aim was to fit in with the current desktop<span>—</span>therefore, the application style will adapt to blend in. It's possible to override these settings on a per-application basis. As our application passes the command-line parameters in our <kbd>QApplication</kbd> constructor (<kbd>widgets.NewQApplication(len(os.Args), os.Args)</kbd>), we inherit some helpful options, such as <kbd>-style=OtherStyle</kbd>.</p>
<p>Another default parameter that can be very powerful for applications is <kbd>-reverse</kbd>. This option will tell all layouts to work in a right-to-left orientation instead of the default left to right:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/7afeb70c-f3eb-458f-89c8-991a8356bbcd.png" style="width:31.58em;height:15.67em;" width="594" height="295"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">GoMail with reversed layout</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, we explored the popular Qt toolkit, its history, and how we can use it to build attractive graphical applications with Go. We saw how easy it is to create a GUI that works identically across many supported platforms. </span></p>
<p>Through exploring our GoMail application, we found how the powerful layout and built-in standard icons help to quickly build an attractive user interface. The tools provided as part of therecipe's qt bindings allowed us to create custom signals to handle our background processing and avoid multi-threading issues. We'll look further into the distribution of these Go apps for multiple operating systems in <a href="8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml">Chapter 14</a>, <em>Distributing Your Application</em>.</p>
<p>In <a href="ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml">Section 3</a>, <em>Modern Graphical Toolkits</em>, we leave behind the familiar toolkits that make use of standard widget sets. We'll look at various widget toolkits that have either been designed from scratch for cross-platform delivery or to be a great match for the Go programming language.</p>


            </article>

            
        </section>
    </div>



  </body></html>