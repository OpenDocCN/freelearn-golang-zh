- en: Go-Qt - Multiple Platforms with Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the Go-GTK library we explored in the previous chapter, qt by therecipe allows
    you to write cross-platform graphical applications with a single Go code base.
    It leverages Qt, a multi-platform application framework that's designed for rapid
    delivery of applications to desktop and embedded computing environments. Like
    GTK+, it's designed to draw widgets that are familiar to the end user but aren't
    reliant upon the operating system's provided toolkit. Additionally, Qt provides
    a different look for mobile and embedded devices where users expect a different
    style of presentation. All of this is controlled within the framework so the developer
    can concentrate on developing a single application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the details of therecipe/qt, the most widely
    adopted Qt binding for the Go language. We''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The history and aims of the Qt framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the API is designed and bridged into Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an application using therecipe/qt library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The theming capabilities of Qt applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll be familiar with the capabilities of the
    Qt framework and its support of many different platforms. Through the exploration
    of some example applications and our GoMail application, you'll learn how the
    Go bindings of therecipe provide access to these features for development in Go.
    You should also have an understanding of whether the Qt framework is a good fit
    for your next application.
  prefs: []
  type: TYPE_NORMAL
- en: Qt background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt framework was created in 1991 by a company named Trolltech (now called
    the Qt Company). The KDE Linux desktop is based on Qt and its increase in popularity
    may be a key reason why Qt development became more widespread. As a platform that's,
    in part, aimed at embedded devices, the typical developers using Qt are different
    to those for the GTK+ framework. Additionally, the tooling and support available
    is better developed due to their commercial backing.
  prefs: []
  type: TYPE_NORMAL
- en: The Qt framework is released in two separate distributions, one commercial and
    one open source (known as dual licensing). In this manner, they can support open
    source-compliant applications for free, while providing unrestricted usage for
    closed source commercial projects. Before the year 2000 (with the release of 2.2),
    the source code for the free distribution had been under various licenses that
    some groups considered incompatible with common open source initiatives. For the
    2.2 release, it was changed to GPL licensing, which settled any concerns about
    the group's commitment to true open source freedoms. In 2007, Qt 4.5 was released
    and they added LGPL as an option for developers who prefer the more permissive
    license.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2011, the Nokia company founded the Qt Project in a move to open up the
    development and road map of the Qt libraries. Qt''s largest market is in embedded
    devices, such as cars and appliances, the technology being utilized by large companies
    such as Tesla and Mercedes Benz:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62482bd5-b103-447a-a4b8-fca90f0d343a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Scribus is a popular desktop publishing application written with Qt (image
    copyright: Henrik Hüttemann)'
  prefs: []
  type: TYPE_NORMAL
- en: The Go bindings by therecipe (whose real name isn't attached to the project),
    along with many contributors, aims to bring the Qt API along with its substantial
    list of supported platforms to the Go language. The project supports building
    applications for Windows, macOS, and Linux desktop computers but also Android,
    iOS, and many other mobile and embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with therecipe/qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin our exploration of Qt and the binding to Go, we'll build a simple *hello
    world* application. To be able to do so, we first need to install therecipe/qt,
    which depends on various prerequisites that we must first set up.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with Go-GTK, we'll be relying on a native library that requires that we both
    set up the CGo functionality and install the Qt library appropriate for the current
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing CGo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt Go bindings, like many of the other toolkits featured in this book, require
    the presence of CGo to utilize native libraries. On a full development system,
    it's likely that this is already set up. If you're unsure or would like a reminder
    of how to set up the CGo dependencies, please check the Appendix, *Setting Up
    CGo*.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt website ([www.qt.io/download](https://www.qt.io/download)) offers various
    methods of installation, including a customized online installer available to
    anyone with a Qt account (which is free to sign up for). Typically, a Qt installation
    comes with Qt Creator (the project IDE), the GUI designer, additional tools, and
    examples. Visiting the preceding site will automatically detect your system and
    suggest the most appropriate download (this is normally the best option).
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the Qt installation can be quite large. If you don't have at least
    40 GB of space on your hard drive, you need to make a little space before installing.
  prefs: []
  type: TYPE_NORMAL
- en: Some operating systems offer Qt libraries and tools as part of their package
    manager, which often provides a more lightweight installation that'll automatically
    stay up to date. However, this option doesn't deliver the complete feature set
    of the Qt development tools, and the Qt bindings discussed in this chapter default
    to using the standard Qt installation provided by the online installer.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Apple macOS, the best approach to installation is to use the installer application
    available at the Qt download site. Visit [www.qt.io/download](https://www.qt.io/download) and
    download the macOS installer. Once it has downloaded, open the package and run
    the program inside; this will install the selected compilers, tools, and supporting
    applications. If you encounter any errors during installation, the first step
    would be to check that your Xcode installation is complete and up to date (for
    more information, see the *Installation Details* appendix).
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing on Windows is more straightforward than some of the other toolkits
    we've looked at, as the Qt installer has a `mingw` package bundled to set up most
    of the compiling requirements (though it's still recommended to have your own
    compiler set up for the binding phase next). To install it, go to the download
    page listed previously and access the Windows installer. Run the downloaded executable
    and follow the onscreen instructions. It's recommended to install to the default
    location. Once that's done, you're ready to set up the bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the online installer from [https://www.qt.io](https://www.qt.io) is the
    easiest approach, though it may be possible to install through your system''s
    package manager (if you want to try the package manager approach, then first read
    the Qt Linux documentation at [https://github.com/therecipe/qt/wiki/Installation-on-Linux](https://github.com/therecipe/qt/wiki/Installation-on-Linux)).
    On most Linux platforms, the Qt downloads website will correctly detect the platform
    and offer a simple run installer. After downloading the file, you should make
    it executable and then run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81bc1ed7-f7fc-4d74-b9e5-8c188a6b796f.png)'
  prefs: []
  type: TYPE_IMG
- en: On Linux, you need to make the install file executable and run it
  prefs: []
  type: TYPE_NORMAL
- en: This will start the installer just as on macOS; from here, follow the onscreen
    instructions and complete the installation.
  prefs: []
  type: TYPE_NORMAL
- en: License / Qt account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to the login screen, then you should enter your Qt account details
    if you have them. If you qualify for their open source license (GPL or LGPL),
    you can skip this step—to do so; make sure the email and password fields are empty.
  prefs: []
  type: TYPE_NORMAL
- en: Installing qt (the bindings)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use qt (the Go Qt bindings), we need to download the project and its dependencies
    and then run a setup script to configure and compile the library. If using Windows,
    it's recommended to use the MSYS2 Terminal described in the Appendix.
  prefs: []
  type: TYPE_NORMAL
- en: If you installed the Qt download to anything other than the default location,
    then make sure to set up the `QT_DIR` environment variable to the location you
    chose.
  prefs: []
  type: TYPE_NORMAL
- en: First, the library and its dependencies should be installed using the `go` tools,
    by running `go get github.com/sirupsen/logrus` and `go get github.com/therecipe/qt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the download has completed, we need to run the `qtsetup` tool, which is
    included in the qt project; so, within the `cmd/qtsetup` folder, execute `go run
    main.go`. Using a Linux Terminal, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7edffb31-a6d7-43ad-a88a-49b9832ea4fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Executing the qtsetup script for therecipe/qt bindings
  prefs: []
  type: TYPE_NORMAL
- en: Once this process completes, the bindings should be ready to use. If you encounter
    errors, then it's probably because the Qt tools aren't correctly installed or
    the location was customized and you forgot to set the `QT_DIR` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build our first qt application with Go, let''s make another *Hello World* application.
    As with previous examples, we''ll make use of a simple vertical box layout within
    a single application window. The following code should be sufficient to load your
    first application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's note a few details from this code snippet. You'll see that each of the
    widget constructor functions takes (typically) two parameters, each is the parent
    widget and a `flags` parameter. Additional types passed in will usually be added
    before these values with a note in the function name that there are additional
    parameters. For example, `widgets.NewQLabel2(title, parent, flags)` is equivalent
    to `widgets.NewQLabel(parent, flags).SetTitle(title)`. Additionally, you'll see
    that the layout is applied to a new `widgets.QWidget` through `SetLayout(layout)`,
    and that's set to the window content through `window.SetCentralWidget(widget)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the display and run the application, we call `window.Show()` and then
    `widgets.QApplication_Exec()`. This file is built in the usual way with `go build
    hello.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c9075ef-025a-43d9-a4af-2f3275a4b57e.png)'
  prefs: []
  type: TYPE_IMG
- en: Building is simple though the output file is rather large
  prefs: []
  type: TYPE_NORMAL
- en: The file built is quite large due to the size of the Qt framework. This will
    be reduced significantly when packaging for a specific distribution. This topic
    will be covered in depth in [Chapter 14](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml),
    *Distributing your Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The output of the build phase is a binary that can be executed on the current
    computer, either on the command line or by double-clicking in a file manager.
    Additionally, you could execute it directly with `go run hello.go`—either way,
    you should see a simple window, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1498312d-2fd5-4bdd-b0bc-b7435b659dc4.png)'
  prefs: []
  type: TYPE_IMG
- en: qt Hello on Linux
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b241f60e-5044-47ce-975b-69de70895561.png)'
  prefs: []
  type: TYPE_IMG
- en: Running on macOS
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the binaries can be executed on a computer with the same architecture
    that also has Qt installed. We'll look at wider distribution later in this chapter.
    Before that, let's take a deeper look into the Qt API and how the qt bindings
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Object model and event handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt framework is written using the C++ language, and so much of its architecture
    will be familiar to those who've coded in C++ before. It's important to note that
    Go isn't a complete object-oriented language and, as such, doesn't match these
    capabilities directly. In particular, we should look at inheritance as it's important
    to the Qt object model.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt API is a fully object-oriented model that makes heavy use of the inheritance
    model. While Go doesn't truly support object-oriented inheritance in the traditional manner,
    its composition approach is very powerful and works well in its place. The result
    means that you probably won't notice the difference! This only comes into play
    if you wish to implement a custom widget, which is out of scope for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you'll have noticed in the preceding example, each widget expects the parent
    to be passed to the constructing function. This enables the Qt framework to handle
    the tidying up, and freeing of memory when a tree of widgets is removed. `QObject`
    (which is the base object for all of the Qt API) keeps track of its child objects
    and so, when being removed, can remove its children too. This makes the creation
    and deletion of complex widget hierarchies easier to handle correctly. To make
    use of this feature, you should always remember to pass the parent object to a
    widget's constructor (the Go functions starting with `New...`), despite the fact
    that passing `nil` may look like it's working.
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is, like GTK+, an event-driven framework and uses signals extensively to
    handle event management and data communications. In Qt, this concept is split
    into signals and slots; a signal is what will be generated when an event occurs
    and a slot is what can receive a signal. The action of setting a slot to receive
    a signal is called **connecting** and this causes a slot function to be called
    when its connected signal is invoked. In Qt, these are typed events meaning that
    each signal has a list of type parameters associated with it. When the signal
    is defined, this type is set and any slot wishing to connect to the signal will
    need to have the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In qt Go code, signals and slots are defined using struct tags such as `` _
    func(string) `signal:"mySignal"` `` and `` _ func(string) `slot:"mySlot"` ``,
    which provide metadata to the Go type system, much as our JSON example in [Chapter
    3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the Rescue!*. Given a struct,
    `s`, which defines these properties, we could set a function to execute when `mySignal`
    is fired with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Signals and slots are what power user interfaces generated with Qt Designer
    and are the recommended way of handling multi-threaded applications. A signal
    may fire from a background thread and the user interface code can connect this
    signal to its own slot—in essence, listening for the signal. When the signal fires,
    any associated data (parameters to the signal) will be passed from one thread
    to another so it can be used safely within the GUI updates. In many ways, this
    is similar to how Go channels work, which we've discussed extensively in [Chapter
    3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the Rescue!*.
  prefs: []
  type: TYPE_NORMAL
- en: As qt is a lightweight binding to the Qt API, the Go-specific documentation
    is minimal but you can find out a lot more about the Qt design and all of the
    classes available in the official documentation available at [https://doc.qt.io/qt-5/classes.html](https://doc.qt.io/qt-5/classes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how a Qt application and the qt Go implementation are set up,
    let's explore a more complete application by returning to our GoMail example.
  prefs: []
  type: TYPE_NORMAL
- en: Sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To look at a more complete application, we'll dust off the original designs
    for the GoMail application—after all, they were created with Qt Designer in the
    first place. We'll recreate the exact layout generated in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications,* and explain the implementation as
    we go.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the first time in our GoMail examples, we have a toolkit that provides
    all of the layouts required to match the user interface we designed at the beginning
    of [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits Using Existing
    Widgets*. That''s perhaps no surprise, as it was created using the Qt tools, but
    it''s a chance to explore the more complete set of layouts provided by Qt and
    made available using the qt bindings. The most useful ones are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Layout** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **box** | The box layout is very familiar by now; it lays out widgets in
    a horizontal or vertical box. Therefore, it''s created with `widgets.NewQVBoxLayout()` or `widgets.NewQVBoxLayout()` accordingly.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **form** | This is a convenience layout that''s basically a two-column grid
    where all of the widgets in the left column are labels. This is styled accordingly
    to produce the design we saw in Qt Creator. |'
  prefs: []
  type: TYPE_TB
- en: '| **grid** | This layout represents a flexible grid layout so that cells aren''t
    forced to all be the same size but instead rows and columns flex to accommodate
    the minimum size of items packed into the grid. |'
  prefs: []
  type: TYPE_TB
- en: '| **spacer** | While not strictly a layout, the spacer item can be used in
    layouts to create visual space. Constructed using `widgets.NewQSpacerItem(width,
    height, hPolicy, vPolicy)`, it''s possible to add various different types of space
    using this helpful class. |'
  prefs: []
  type: TYPE_TB
- en: '| **stacked** | A stacked layout sets all child objects to be the full size
    of the containing widget, but ensures that only one can be visible at a time.
    The `SetCurrentWidget()` and `SetCurrentIndex()` functions can be used to control
    which child is visible. This is very useful for implementing tabbed panels or
    paged controls. |'
  prefs: []
  type: TYPE_TB
- en: Using this knowledge, we can re-create the GoMail browse interface using pure
    Qt widgets. A lot of this code will be familiar by now, but there are a number
    of notable differences. Firstly, you can see that layouts (as listed previously)
    are typically set on `widgets.QWidget` rather than creating a whole new widget
    for their own purpose. This approach means that the number of different widgets
    can be kept lower, but it also causes some functionality to be attached to the
    layout and not the widget. For example, the `widgets.NewQFormLayout()` we set
    on the `detail` widget is designed to lay out form components, and as such has
    helper functions to add rows (`form.AddRow3`, for example). To use these functions,
    we must keep a reference to the layout (the `form` variable in this code) to operate
    on. You can also see that `AddWidget()` is called on `widget.Layout()` rather
    than on `widget` directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet contains most of the code to create our basic layout. Some of
    the toolbar and menu code (which is rather repetitive) has been left out, but
    it can be found in the code repository that accompanies this book. We start with
    the imports and a basic skeleton for creating a menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And similarly, we can create a new toolbar using built-in icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, we lay out the main content of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is similar in structure to the previous chapter (as GTK+
    and Qt APIs have many similarities), though the naming will remind you of [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications,* and the Walk example. Clearly, as Walk is based largely on Qt,
    the naming is often the same, but the qt APIs being used here don't offer the
    same declarative syntax and so must be created using the function-based constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example introduces two new qt packages, `core` and `gui`. As you can see
    from the example, we use the `core` package with data models (which many of the
    more complex widgets make use of). The `gui` package provides helpful additions
    to make a user interface more compelling; in this instance, we''re looking up
    standard icons using the `gui.QIcon_FromTheme2` function. In a more complete application,
    we could provide fallback icons that would complete the Reply and Reply All toolbar
    buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba6d0d00-306d-4898-976f-575f62f71bec.png)'
  prefs: []
  type: TYPE_IMG
- en: The complete layout of our GoMail application using qt
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this screenshot, a qt application can look polished with
    even the most basic of code. You may notice the 1 above our email list instead
    of Inbox; this is due to a limitation in `core.QStringListModel` used for this
    layout example and should be addressed in our full implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The compose layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GoMail compose layout is even simpler: we use `widgets.QFormLayout` again,
    though the `To` field is the only line with a label included. For this simpler
    window, we create `widgets.QDialog` and set the layout directly on the dialog
    widget. To add the buttons at the bottom of the screen, we use a new `widgets.QWidget`
    with the layout set to `widgets.NewQHBoxLayout()` to lay the buttons out horizontally.
    To manage the right alignment, we first include `widgets.NewQSpacerItem()` in
    the button box before the buttons. Note lastly that we call `SetDefault(true)`
    on the `send` button so it becomes the default action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we get the following desired outcome—a simple and
    familiar compose dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ae3c61a-ffb3-4135-9f6d-7f0b58246388.png)'
  prefs: []
  type: TYPE_IMG
- en: The email compose dialog using qt widgets
  prefs: []
  type: TYPE_NORMAL
- en: Now that the layout is complete, let's connect our test email server to show
    some email data.
  prefs: []
  type: TYPE_NORMAL
- en: Signalling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the interaction of our GoMail examples, we''ll make use of the
    standard signals and slots within qt. Firstly, we need to set up an instance of
    our test email server and load the data. We add a `setMessage(*client.EmailMessage)`
    function to set the content of our labels, which can be called on the loading
    of our GUI and when the email list is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to handle clicking on the email list looks something like the following
    snippet. We''re creating an anonymous function and connecting it to the `selectionChanged`
    signal. Remember to check whether there are no selected indexes before finding
    the selected row number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to update our toolbar and menu to open the compose dialog when
    New is clicked. The `triggered` signal is the one to connect to; we need to wrap
    `showCompose()` in an anonymous function as the signal type passes a `bool` flag
    (for the checked status) that we want to ignore. The code is identical for toolbars
    and menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar code is used to handle button presses, which send a `clicked` signal;
    our compose dialog, `c`, will connect an anonymous function to compose an email,
    send it, and hide the dialog when Send is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Thread handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the preceding click handlers, the multi-threaded aspects of a complex
    application are handled by the signal-slot design in Qt. Code executed in a slot
    will be running on the correct thread to do graphical updates. Additionally, any
    data passed as part of the signal definition can be accessed in a thread-safe
    manner. We'll make use of this property to handle our background email notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set this up, we create a new  custom signal. This is made possible by the
    `qtmoc` tool, which comes with therecipe/qt bindings. We''ll update our `mainUI`
    struct definition to inherit from `core.QObject` (this is a requirement) and then
    define an anonymous function with the `signal` tag, which defines the name of
    the signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is set up, you should run the `qtmoc` tool in the current directory;
    this generates various methods including the `ConnectNewMail()` and `NewMail()`
    methods (the slots connecting method and signal trigger respectively), as well
    as a new constructor. Once this is complete, we must update our code to use the
    newly generated constructor (if your signals don''t trigger slots, then this step
    was probably missed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add new code to connect `prependEmail(client.EmailMessage)` to the
    `newMail` signal. Once that''s connected, we listen to the `server.Incoming()`
    channel and, each time a message arrives, we send the signal using the generated `NewMail(client.EmailMessage)`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this code in place, our background code will trigger the appropriate handlers
    and all updates occur on the correct thread for immediate updates to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compiling a qt-based application for another desktop platform isn't currently
    supported in the same way that we've compiled other examples. There's an alternative
    approach, however, using Docker as a deployment method. Setting up the tools and
    running a build in this way is out of scope for this chapter, but you can read
    more about deploying qt apps at [github.com/therecipe/qt/wiki/Deploying-Application](https://github.com/therecipe/qt/wiki/Deploying-Application).
  prefs: []
  type: TYPE_NORMAL
- en: Theming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt theme (known as *Style* in Qt terminology) can be adjusted similarly
    to GTK apps in the previous chapter. Before Qt 5, the current theme could be configured
    using a standard setup application but in Qt 5, the aim was to fit in with the
    current desktop—therefore, the application style will adapt to blend in. It's
    possible to override these settings on a per-application basis. As our application
    passes the command-line parameters in our `QApplication` constructor (`widgets.NewQApplication(len(os.Args),
    os.Args)`), we inherit some helpful options, such as `-style=OtherStyle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another default parameter that can be very powerful for applications is `-reverse`.
    This option will tell all layouts to work in a right-to-left orientation instead
    of the default left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7afeb70c-f3eb-458f-89c8-991a8356bbcd.png)'
  prefs: []
  type: TYPE_IMG
- en: GoMail with reversed layout
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the popular Qt toolkit, its history, and how we
    can use it to build attractive graphical applications with Go. We saw how easy
    it is to create a GUI that works identically across many supported platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Through exploring our GoMail application, we found how the powerful layout and
    built-in standard icons help to quickly build an attractive user interface. The
    tools provided as part of therecipe's qt bindings allowed us to create custom
    signals to handle our background processing and avoid multi-threading issues.
    We'll look further into the distribution of these Go apps for multiple operating
    systems in [Chapter 14](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml), *Distributing
    Your Application*.
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern Graphical
    Toolkits*, we leave behind the familiar toolkits that make use of standard widget
    sets. We'll look at various widget toolkits that have either been designed from
    scratch for cross-platform delivery or to be a great match for the Go programming
    language.
  prefs: []
  type: TYPE_NORMAL
