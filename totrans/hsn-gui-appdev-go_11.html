<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shiny - Experimental Go GUI API</h1>
                </header>
            
            <article>
                
<p>Shiny is an experimental GUI library designed from scratch and written purely in Go. It was created to explore what's possible when building a cross-platform GUI for the Go language. It is not an official GUI toolkit for Go (though it was created by developers at Google) but provides a solid basis for graphical applications on most supported Go platforms.</p>
<p>This chapter explores how to use the Shiny project to build cross-platform graphical applications without the need for C libraries or pre-installed dependencies. The following topics will be covered in this chapter:</p>
<ul>
<li>The design principles of the Shiny project and its widgets</li>
<li>How the toolkit is built to support multiple platforms without external drivers or native libraries</li>
<li>Building a basic graphical application that can easily cross-compile to different systems</li>
<li>Creating a a complete application using Shiny</li>
</ul>
<p class="mce-root">At the end of this chapter, you should be well-versed in this experimental new API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background and the vision for Shiny</h1>
                </header>
            
            <article>
                
<p>The Shiny project was created in an effort to understand how a graphical application toolkit could be created to be in keeping with the Go idiom. Therefore, it is important that its API and methodologies should match the Go language semantics and standard library, its dependencies should be only pure Go libraries or existing system routines, and it should provide a modern approach to developing an application GUI. Much of this is only possible if you start from scratch, as you can tell from the toolkit bindings we saw in <a href="36bfea00-c659-4569-864c-de2c460c7467.xhtml">Section 2</a>, <em>Toolkits Using Existing Widgets</em> of this book. It lives in the <kbd>golang.org/x/exp/shiny</kbd> repository—an experimental extension to the Go libraries.</p>
<p>The project was started as an investigation by Nigel Tao, a Go developer who had been working on <kbd>golang.org/x/mobile</kbd> (on which Shiny depends), as he wanted to see desktop applications supported by a new API. After substantial development, it was proposed that this be added as an experimental project within the <a href="http://www.golang.org/">golang.org</a> repositories, which was accepted in 2015. It is expected that, at some future point, the commonality between <kbd><span>golang.org/</span><span>x/mobile</span></kbd> and <kbd><span>golang.org/x/exp/shiny</span></kbd> will be captured in a separate project, leaving the mobile and desktop specific portions in their respective projects.</p>
<p>The project's development has slowed in recent years but it remains a strong foundation for graphical applications to be built upon. Whether the project will see a resurgence or instead become the base upon which another is built is unclear at this time. Either way, it is an excellent low-level graphical API for Go and so we will look into the details of it and start to build a sample application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Design and supported platforms</h1>
                </header>
            
            <article>
                
<p>The Shiny project has been designed to ensure good separation between the widget code and the lower-level rendering code that widgets utilize. It is also built with the understanding that graphical drivers may be useful on more than a single platform and could potentially be changed or added to over time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Architecture</h1>
                </header>
            
            <article>
                
<p>The Shiny API is split into two layers, a lower layer that handles graphical buffers and rendering, and a higher layer where the widget and layout code is located. Each layer has clear responsibilities and their separation helps to maintain a clean API.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lower layer</h1>
                </header>
            
            <article>
                
<p>The lower layer of the Shiny API is responsible for creating a render context for each platform supported. It is also responsible for handling input from keyboard and other peripheral devices. The main concepts of the graphical presentation are <strong>Buffer</strong>s, <strong>Texture</strong>s, and <strong>Window</strong>s:</p>
<ul>
<li><strong>Buffer:</strong> A buffer refers to an array of pixel data in memory. This could be a loaded image, a canvas for drawing, or any other graphical data that needs to be presented within an application.</li>
<li><strong>Texture:</strong> A texture is a handle to a snapshot of graphical state that's ready to be rendered. It will not be accessible to the application. A texture may be rendered immediately (such as the current widget state) or stored and rendered many times in the future (such as an image).</li>
<li><strong>Window:</strong> A window is the location of an application's graphical output. Textures are rendered to the window after certain transformations (determined by the driver) have been applied.</li>
</ul>
<p>In normal application flow, the code of a graphical user interface will update a widget or layout state—resulting in a buffer's contents being updated. This buffer will then be uploaded to a texture in preparation for <span>being drawn by the driver</span>. The texture will then be rendered to the application window, potentially through transformations within the driver or the underlying platform's graphical implementation. If you are familiar with how OpenGL works, then the processes will seem quite familiar—this is no coincidence, as the approach is well-proven and one of the Shiny drivers uses the OpenGL APIs. For most application developers, the existence of textures will not be visible or important, but it can help to consider the process when optimizing your code.</p>
<p>The driver also handles user interactions, encapsulating them as <kbd>mouse.Event</kbd> and <kbd>key.Event</kbd> structures (defined in <kbd>x/mobile/event</kbd>). A <kbd>widget.Widget</kbd> can register to receive these events, using a filter that will determine which are relevant to that object, and mark them as handled. Alternatively, an application could access the event queue directly from <kbd>screen.Window</kbd>, where calling <kbd>NextEvent()</kbd> would wait until another event occurs. An application that takes this approach should be aware of the vast number of events that can be generated by Shiny (see <em>Example</em> in the <em>Getting started</em> section later in this chapter). When working with events, the Shiny project includes a powerful gesture package, that enables you to filter on <kbd>gesture.Event</kbd>, which describes more intent-based information than lower-level data. Helpful event types include <kbd>gesture.TypeDrag</kbd>, <kbd>gesture.TypeIsLongPress</kbd>, and <kbd>gesture.TypeIsDoublePress</kbd> (the event type is accessible through <kbd>Event.Type</kbd> on gesture events).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Higher layer</h1>
                </header>
            
            <article>
                
<p>Higher-layer APIs are focused on widgets and the overall layout and behavior of a graphical user interface. Working at this level, a developer wouldn't expect to be dealing with buffers and events but with high-level concepts such as buttons, text areas, and layouts. The types and functions defined at this layer (within the <kbd>widget</kbd> package) are designed to be easy to understand from a high level and includes graphical user interface concepts that will be familiar to most developers.</p>
<p><span>The Shiny widgets (detailed further in the <em>Widgets and material design</em> section later in this chapter) are all written in pure Go and encapsulate any widget logic (such as input handling), as well as rendering (by implementing the</span> <kbd>node.PaintBase()</kbd> <span>or</span> <kbd>node.Paint()</kbd> <span>functions). This allows the user interface code to remain completely detached from the drivers for better testing and to promote consistency across all supported operating systems.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Supported platforms</h1>
                </header>
            
            <article>
                
<p>The Shiny project currently supports Windows, macOS, Linux, DragonFly BSD, and OpenBSD. Other BSD distributions or Unix systems that use X11 (see the following discussion of drivers) may work but are not officially supported at this time.</p>
<p>The code required to support an operating system is relatively lightweight if one of the existing drivers is able to run. For example, if OpenGL is installed on a not-yet-supported platform, then you may be able to add the operating system-specific code to wire it in. In this situation, a platform-specific Go file would need to open a window and handle any platform-specific input or device setup for the OpenGL window.</p>
<p>On a platform where an existing driver does not currently work, it would be a tremendous amount of work to add support. As well as the window- and user-interaction code, it would be necessary to write the graphical renderer and presentation layer from scratch or provide an API bridge to an existing one. Such an implementation would have to handle the complete set of draw primitives and transformations utilized by the main Shiny code (such a list is outside the scope of this book).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Drivers currently included</h1>
                </header>
            
            <article>
                
<p>Shiny has three complete drivers at the time of writing (<strong>win</strong>, <strong>gl,</strong> and <strong>x11)</strong> and each of these drivers must implement all of the input and output capabilities of the Shiny toolkit. The output portion of a driver is required to define a suitable <kbd>screen.Texture</kbd> provider so that buffers can be uploaded ready for rendering and to handle the rendering process. On the input side, a driver must handle mouse and keyboard events and translate them into <kbd>golang.org/x/mobile</kbd> types that can then be filtered by the Shiny event-handling code. The details of each driver are as follows:</p>
<ul>
<li><strong>gl:</strong> The most commonly used driver, built on top of the cross-platform OpenGL, it makes use of this standard API for graphical display. Many operating systems provide this functionality, though it should be noted that this may not be supported on all devices.</li>
<li><strong>win:</strong> The win driver is built specifically for the Microsoft Windows operating system to work without the OpenGL APIs. Rendering is provided by the <strong>Graphics Device Interface</strong> (<strong>GDI</strong>).</li>
<li><strong>x11:</strong> The X11 driver provides support for the standard graphical desktop platform on Linux and Unix. It communicates directly with the <em>XServer</em> and uses the <span><strong>SHared Memory</strong> </span>(<strong><span>SHM</span></strong>) extension for communicating image data efficiently.</li>
</ul>
<p>Between these drivers, there is at least one render definition for all of the operating systems supported by the toolkits described earlier in this book, and potentially more. These details shouldn't be a concern day to day when programming with Shiny but it helps to understand possible extensions in the future.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started with Shiny</h1>
                </header>
            
            <article>
                
<p>In keeping with the design of Shiny to not depend on any native libraries or system dependencies, there are no prerequisites to using it. So, we can jump straight into getting the library installed and see it in action.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setup</h1>
                </header>
            
            <article>
                
<p>Installing the Shiny library is as simple as installing the Go files from <kbd>golang.org/x/exp/shiny</kbd> and its <kbd>x/mobile</kbd> and <kbd>x/image</kbd> dependencies. As these are top-level projects, you may see a warning about no Go files—you can ignore this, as the APIs will be installed:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/1ccc3970-43df-461b-8e14-43fd0ab5b9d8.png" style="width:38.17em;height:27.50em;" width="1124" height="810"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Getting x/exp/shiny will download the package contents</div>
<p>No extra libraries or system configuration are required.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example</h1>
                </header>
            
            <article>
                
<p>Before we start building an application, let's load an example project to check that Shiny is installed and working correctly. The project provides various example projects—we will check the one called <em>basic</em>. Simply change to the <kbd>examples/basic</kbd> directory and run <kbd>main.go</kbd>:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/338a4a6e-9938-4b01-86ce-e77f15bbc616.png" style="width:39.75em;height:13.00em;" width="1124" height="368"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Launching the basic Shiny example</div>
<p>After launching, you should see the following window and (as illustrated in the preceding) the output of all of the events triggered by the application. The size of the window may vary depending on the operating system you are running, due to driver default values:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/c33590d3-f78b-456f-b3f5-b19fe63fdf3c.png" style="width:34.25em;height:18.33em;" width="1024" height="547"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A rather unconventional example application</div>
<p>As you can see, this example application is unlike the other toolkits we've explored. This represents the main focus of the Shiny project as primarily a technology demo.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-compiling</h1>
                </header>
            
            <article>
                
<p>As a project that aims to be written purely in Go, one of its goals is to be just as easy to cross-compile for different platforms as it is to build for the current operating system. In cases where the Shiny driver for the operating system is pure Go (as is currently the case for <strong>windows</strong> and <strong>x11</strong>, used by Linux and BSD), compiling for a specific operating system is as simple as using the <kbd>GOOS</kbd> parameter, as described in <a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml">Chapter 3</a>, <em>Go to the Rescue!</em>:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/72688dd8-3f79-4fa7-bd44-baf54fd17b27.png" style="width:36.25em;height:16.08em;" width="1124" height="498"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Compiling Linux and Windows binaries from a Linux Command Prompt</div>
<p>The <strong>gl</strong> driver that provides hardware-accelerated rendering (used by macOS and Linux) depends on a system API that is not currently available without CGO and so is more challenging to cross-compile. Through the toolkit design, it's possible to use the <strong>x11</strong> driver for a Unix target platform if CGO is not available—so Linux or BSD can still be cross compiled.</p>
<div class="packt_infobox">Note that cross-compiling a Shiny application for Linux will result in an application that does not have graphical acceleration enabled. This can be overcome by using <kbd>CGO_ENABLED=1</kbd> and installing various libraries but it is easily forgotten, so it's advisable to set up a dedicated Linux build environment.</div>
<p>This means that, from macOS, we can cross-compile both Linux and Windows executables by simply setting the appropriate <kbd>GOOS</kbd> variable as would be expected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/13bce09b-80e8-4ed2-ae16-7a3d2f7346f5.png" style="width:31.08em;height:13.42em;" width="490" height="212"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-compiling for macOS</h1>
                </header>
            
            <article>
                
<p>With Windows and Linux (and some BSD flavours), all cross-compiling completes without CGO, therefore, we only need to look at macOS as a special case. T<span>o cross-compile successfully for macOS, we must add </span><kbd>CGO_ENABLED=1</kbd><span> to our build, which will then look for the required system libraries. Clearly, these are not normally available and so we must set up our development environment to provide the required APIs.</span></p>
<p>The procedure for setting up the clang binary and required API bundles for macOS cross-compiling is a complicated process, but if you worked through <a href="4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml">Chapter 5</a>, <em>andlabs UI - Cross-platform Native UIs</em>, this will already be set up. If you've jumped straight to this chapter, then you may need to follow the steps in the <a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml">Appendix</a>, <em>Cross-Compiler Setup, </em>under <em>Cross-compiling for macOS with cgo</em>. Once that's complete, you should have a new compiler available named <kbd>o32-clang</kbd>, which is able to link to macOS Foundation APIs.</p>
<p>To build the application, we now set up the <kbd>GOOS</kbd> and <kbd>CGO_ENABLED</kbd> flags as before, but also specify the compiler to use through an extra <kbd>CC</kbd> environment variable, setting it to <kbd>o32-clang</kbd>. With that configuration complete, we can build a macOS Shiny application from our Linux Terminal:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f1a1b415-fd9b-4629-9ff5-19c88243f0e5.png" style="width:39.75em;height:11.42em;" width="1124" height="321"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Building a macOS application from a Linux terminal</div>
<p>Applications built in this manner will have full OpenGL acceleration as though they were built directly on a macOS computer.</p>
<p>Now that we've seen all of the details for building with Shiny, let's explore how these applications are designed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Widgets and material design</h1>
                </header>
            
            <article>
                
<p>Before we can start a simple application, we need to understand more about Shiny widgets and how their visual design impacts development. The other toolkits that we've looked at didn't need this understanding to start using the API, but the experimental status of the higher-level APIs in Shiny means that even a <em>hello world</em> application requires some understanding of how the toolkit functions.</p>
<p>Before we get into the details of the widgets that Shiny provides and how to work with them, let's take a look at the design and iconography of the Shiny project. This design takes a different approach to the toolkits we've previously looked at in this book, but it should be familiar to any Android app developers or users of the Google product suite.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Design</h1>
                </header>
            
            <article>
                
<p>Material design, if you are not already familiar with the concept, can be defined as follows:</p>
<div class="packt_quote">...<span> an adaptable system of guidelines, components, and tools that support the best practices of user interface design"  <br/></span>                                                                                                                                                          -<a href="https://material.io/">material.io</a></div>
<p>The design principles will be familiar to anyone with an Android smartphone or tablet and are somewhat similar to the user interface design adopted by Microsoft for recent releases of the Windows operating system, which support tablets and touch screen user input. The approach aims to help developers quickly create beautiful applications and to ease communication between developers and designers. The <em>design language</em> also helps to promote a consistent user experience in a world where applications are trying to stand out with their own brand design.</p>
<p>An application that utilizes the material design principles will not look identical to all of the others, but will have sufficient similarities that a user should have no trouble understanding how it works. Colors, layouts, and navigation can be different from one interface to another, as long as they follow the guidelines set out. Material design includes some standard color palettes and advice for creating custom ones for your needs. Layouts and navigation widgets similarly have standard implementations, but these can be extended and used to suit the context. These standard widgets are called <em>material components</em> and have been created for Android, iOS, Flutter, and the web—Shiny is one potential approach to bringing them to desktop:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/626d86cb-3063-4955-99e8-4c510d3adf3f.png" style="width:18.25em;height:37.08em;" width="513" height="1048"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">An Android app demonstrating material design. Image copyright: Google.</div>
<p>There are many tools online to help you learn about and adopt material design principles. They can be found on the material design website at <a href="https://material.io/">material.io</a>. Let's explore a few of the details that are at the core of the Shiny API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Icons</h1>
                </header>
            
            <article>
                
<p>The material design project has created a standard set of <span>icons that are freely available to use in any application. Integrating these clear, concise icons into your user interface adds simple-to-understand hints that are consistent with other applications and can alleviate the need for too much text in the resulting user interface. Shiny bundles the most commonly used icons in the <kbd>materialdesign/icons</kbd> package and they can be referenced by name through the API. To see the list of names and the icons, you can run the Shiny <em>IconGallery</em> example (pictured in the following screenshot):</span></p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/c9af972e-e8e9-4075-98d2-05e57fe1fa52.png" style="width:33.67em;height:27.92em;" width="589" height="489"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Shiny includes the material icon set as vector graphics</div>
<p><span>The icons can be painted within a </span><kbd>node.PaintBase()</kbd><span> method by creating an </span><kbd>iconvg.Rasterizer</kbd><span class="pl-smi"> instance for</span><span> </span><kbd>node.PaintBaseContext</kbd><span> and calling </span><kbd>iconvg.Decode()</kbd><span> for the icon reference (these icons are stored in the compact IconVG format). Examples of this code in action can be found later in the chapter (or in the Shiny example code).</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Themes</h1>
                </header>
            
            <article>
                
<p>One of the central concepts in material design is the color palette—while it does not mandate the colors that an application can use, it has very clear rules about color choice and combinations that work. Designers are encouraged to pick a primary color from the standard palettes (used in most user interface elements) and a secondary color (for highlights and accents) that complement each other. For each color, there are standard light and dark variants, which can add depth to an application interface. You can explore these through the online color tool at <a href="https://material.io/tools/color">material.io/tools/color</a>.</p>
<p>The palette that Shiny uses follows this approach; the available colors are:</p>
<ul>
<li><span><kbd>theme.Foreground</kbd><span>: </span>The standard foreground color for the theme—used for text and icons</span></li>
<li><span><kbd>theme.Background</kbd><span>: </span>The standard background color for containers</span></li>
<li><kbd>theme.Neutral</kbd><span>: A background color for smaller areas that should be distinct from the background</span></li>
<li><span><kbd>theme.Light</kbd>: A lighter version of the neutral color</span></li>
<li><span><kbd>theme.Dark</kbd>: A darker version of the neutral color</span></li>
<li><span><kbd>theme.Accent</kbd>: The main color from the secondary palette, used for highlighting key elements</span></li>
</ul>
<p>Colors in the Shiny API are passed using the <kbd>theme.Color</kbd> type instead of the golang <kbd>color.Color</kbd> <span>type.</span> This ensures that the colors used are from the theme palette. From a theme color type, you can call the <kbd>Color()</kbd> function to get a standard color type or the <kbd>Uniform()</kbd> function to get <kbd>image.Uniform</kbd> which is used to draw filled rectangles in a <kbd>Paint()</kbd> function.</p>
<p>Applications can choose to use the built-in theme (<kbd>theme.Default</kbd>) or to provide their own. Any type that implements <kbd>theme.Theme</kbd> can be used in the rendering of a Shiny GUI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Widgets</h1>
                </header>
            
            <article>
                
<p>As a project that has focused more on the capabilities of cross-platform graphical rendering on the lower layer, Shiny toolkit does not come with many standard widgets. A lot of work has gone in to setting up the building blocks so that applications can provide their own widgets, but if you are looking to use built-in types, the list provided by the <kbd>widget</kbd> package is as follows:</p>
<ul>
<li><strong>Flow:</strong> This is a container that lays out its children along a horizontal or vertical axis (set in<span> </span><kbd>Flow.Axis</kbd> or <kbd>NewFlow()</kbd>).</li>
<li><strong>Flex:</strong> Actually, in a <kbd>flex</kbd> sub-package, this is a container that lays out its children according to the CSS flexbox algorithm. As with<span> </span><kbd>widget.Flow</kbd><span>, </span>the parameters for the layout are set on the<span> </span><kbd>flex.Flex</kbd><span> </span>container.</li>
<li><strong>Image:</strong> This widget renders a golang<span> </span><kbd>image.Image</kbd><span> </span>onscreen. Its dimensions are specified separately to the image.</li>
<li><strong>Label:</strong> This is a simple widget for displaying a line of text with a theme color (for example,<span> </span><kbd>theme.Foreground</kbd>).</li>
<li><strong>Padder:</strong> An invisible widget that contains a child widget and displays it with a specified amount of space around the horizontal or vertical dimensions <span>(or both)</span>.</li>
<li><strong>Sheet:</strong> A sheet provides the buffer on which all other widgets will draw. Any widgets that are not children of a Sheet may not be rendered. Multiple sheets are required if content should move independently, such as a scroll view.</li>
<li><strong>Sizer:</strong> A sizer is an invisible widget that contains a child widget but overrides its size. This can be used to specify a different natural size than the default for an existing widget.</li>
<li><strong>Space:</strong> An invisible widget that takes up available space. Placed between two widgets, they will become left- and right- aligned, or by placing <span> </span><kbd>widget.Space</kbd><span> </span>either side of a widget, it will become centered.</li>
<li><strong>Text:</strong> A multi-line text widget for displaying more complicated text than<span> </span><kbd>widget.Label</kbd>.</li>
<li><strong>Uniform:</strong><span> This is a simple widget that draws a rectangle of a solid color from the theme palette (for example,</span><span> </span><kbd>theme.Background</kbd><span>).</span></li>
</ul>
<p>There is also an advanced widget named<span> </span><kbd>glwidget.GL</kbd>, which renders a <span><strong>OpenGL for embedded systems</strong> </span>(<strong><span>GLES</span></strong>) <kbd>framebuffer</kbd> into a Shiny application. This is not commonly required for traditional applications but it's a great additional feature to support.</p>
<p>Despite the length of the preceding list, you'll probably notice that it does not provide all the widgets we have used in other chapters. For this reason, we will build a different sample application. This time, one that's a better fit for the toolkit's capabilities. Before that, however, let's return to <em>getting started</em> and creating a hello world application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started continued</h1>
                </header>
            
            <article>
                
<p>Now that we have explored a little of how Shiny is designed and its current constraints, we can implement our first graphical application and see it run.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code</h1>
                </header>
            
            <article>
                
<p>Let's get started with writing a simple <em>hello world</em> window, as in the previous chapters. This code is a little more complicated than in previous examples due to the low-level nature of the toolkit at this time. As well as defining the window, label, and button, we will need to set up a background layer and measure the minimum size for the containing window:</p>
<pre><span>package </span>main<br/><br/><span>import </span>(<br/><span>   "golang.org/x/exp/shiny/driver"<br/></span><span>   "golang.org/x/exp/shiny/screen"<br/></span><span>   "golang.org/x/exp/shiny/widget"<br/></span><span>   "golang.org/x/exp/shiny/widget/theme"<br/></span><span><br/></span><span>   "log"<br/></span>)<br/><br/><span>func </span><span>main</span>() {<br/>   driver.Main(<span>func</span>(s screen.<span>Screen</span>) {<br/>      label := widget.NewLabel(<span>"Hello World!"</span>)<br/>      button := newButton(<span>"Quit"</span><span>,<br/></span><span>         </span><span>func</span>() {<br/>            log.Println(<span>"To quit close this window"</span>)<br/>         })<br/><br/>      w := widget.NewFlow(widget.AxisVertical, label, button)<br/>      sheet := widget.NewSheet(widget.NewUniform(theme.<span>Neutral</span><span>, </span>w))<br/><br/>      w.Measure(theme.Default<span>, </span><span>0</span><span>, </span><span>0</span>)<br/>      <span>if </span>err := widget.RunWindow(s<span>, </span>sheet<span>, </span>&amp;widget.<span>RunWindowOptions</span>{<br/>         NewWindowOptions: screen.<span>NewWindowOptions</span>{<br/>            Title: <span>"Hello"</span><span>,<br/></span><span>            </span>Width: w.MeasuredSize.X<span>,<br/></span><span>            </span>Height: w.MeasuredSize.Y<span>,<br/></span><span>         </span>}<span>,<br/></span><span>      </span>})<span>; </span>err != nil {<br/>         log.Fatal(err)<br/>      }<br/>   })<br/>}</pre>
<p>In the preceding code, you can see the flow layout (<kbd>widget.NewFlow()</kbd>), a background layer (<kbd>widget.NewSheet()</kbd>), and the measurement initialization (<kbd>w.Measure()</kbd>). With Shiny, <kbd>widget.Sheet</kbd> is required underneath any widgets so they can paint correctly. On a simple application, a single sheet should be sufficient, but on a more complex user interface where items move independently (that is, scrolling), additional sheets will probably be required.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Supporting code</h1>
                </header>
            
            <article>
                
<p>As you may have noticed, the preceding code has two issues, both relating to the <kbd>Quit</kbd> button. Firstly, the <kbd>func()</kbd> that's called does not actually exit the application. This is a current limitation of the Shiny lifecycle code. It can be worked around with a custom lifecycle, but this is not recommended due to the large amount of code that would be required. Secondly, you may notice that <kbd>newButton()</kbd> is a local function and not part of the <kbd>widget</kbd> package. One of the widgets currently missing from the toolkit list is a standard button, therefore, we must define one ourselves. This can be done by adding the code described as follows:</p>
<p>First, we define the custom node; it must begin by inheriting from <kbd>node.LeafEmbed</kbd>. We add fields for the text label it'll contain and the <kbd>onClick</kbd> function that should be called when it is tapped. We should also add a convenience method to construct the button. This needs to set the <kbd>node.Embed.Wrapper</kbd> field, as that should never be <kbd>nil</kbd>:</p>
<pre><span>type </span>button <span>struct </span>{<br/>   node.<span>LeafEmbed<br/></span><span><br/></span><span>   </span>label   <span>string<br/></span><span>   </span>onClick <span>func</span>()<br/>}<br/><br/>func NewButton(label string, onClick func()) *button {<br/>   b := &amp;button {label: label, onClick: onClick}<br/>   b.Wrapper = b<br/><br/>   return b<br/>}</pre>
<p>To define a suitable area for the button to take up, we need to implement the <kbd>Measure()</kbd> function. This will update a cached size (<kbd>node.Embed.MeasuredSize</kbd>) that's used for the interface layout:</p>
<pre>const buttonPad = 4<br/><br/><span>func </span>(b *<span>button</span>) <span>Measure</span>(t *theme.<span>Theme</span><span>, </span>widthHint<span>, </span>heightHint <span>int</span>) {<br/>   face := t.AcquireFontFace(theme.<span>FontFaceOptions</span>{})<br/>   <span>defer </span>t.ReleaseFontFace(theme.<span>FontFaceOptions</span>{}<span>, </span>face)<br/><br/>   b.MeasuredSize.X = font.MeasureString(face<span>, </span>b.label).Ceil() + <span>2</span>*<span>buttonPad<br/></span><span>   </span>b.MeasuredSize.Y = face.Metrics().Ascent.Ceil() + face.Metrics().Descent.Ceil() + <span>2</span>*<span>buttonPad<br/></span>}</pre>
<p>To display content onscreen (this actually paints to an underlying <kbd>widget.Sheet</kbd> described earlier), we add a <kbd>PaintBase()</kbd> function. For our button, we will paint a <kbd>theme.Foreground</kbd> colored rectangle as a base and use the <kbd>theme.Background</kbd> color for the text (so our button stands out from other text). Note that, before actually painting, we remove the <kbd>node.MarkNeedsPaintBase</kbd> mark from the object so that it will not be redrawn on the next interface redraw:</p>
<pre><span>func </span>(b *<span>button</span>) <span>PaintBase</span>(ctx *node.<span>PaintBaseContext</span><span>, </span>origin image.<span>Point</span>) <span>error </span>{<br/>   b.Marks.UnmarkNeedsPaintBase()<br/>   face := ctx.Theme.AcquireFontFace(theme.<span>FontFaceOptions</span>{})<br/>   <span>defer </span>ctx.Theme.ReleaseFontFace(theme.<span>FontFaceOptions</span>{}<span>, </span>face)<br/><br/>   draw.Draw(ctx.Dst<span>, </span>b.Rect.Add(origin).Inset(<span>buttonPad</span>)<span>, </span>theme.<span>Foreground</span>.Uniform(ctx.Theme)<span>, </span>image.<span>Point</span>{}<span>, </span>draw.<span>Src</span>)<br/>   d := font.<span>Drawer</span>{<br/>      Dst: ctx.Dst<span>,<br/></span><span>      </span>Src: theme.<span>Background</span>.Uniform(ctx.Theme)<span>,<br/></span><span>      </span>Face: face<span>,<br/></span><span>      </span>Dot: fixed.<span>Point26_6</span>{X: fixed.I(b.Rect.Min.X + <span>buttonPad</span>)<span>, </span>Y: fixed.I(b.Rect.Min.Y + face.Metrics().Ascent.Ceil() + <span>buttonPad</span>)}<span>,<br/></span><span>   </span>}<br/>   d.DrawString(b.label)<br/><br/>   <span>return </span>nil<br/>}</pre>
<p>Lastly, a button needs a click handler. We can implement the <kbd>OnInputEvent()</kbd> function so that Shiny can send events to the button. Here, we check to see whether the event's a <kbd>gesture.Event</kbd>, and if so, see that its type is <kbd>gesture.TypeTap</kbd>. If these conditions are met, and we have an <kbd>onClick</kbd> handler registered, then call <kbd>b.onClick()</kbd>:</p>
<pre><span>func </span>(b *<span>button</span>) <span>OnInputEvent</span>(e <span>interface</span>{}<span>, </span>origin image.<span>Point</span>) node.<span>EventHandled </span>{<br/>   <span>if </span>ev<span>, </span>ok := e.(gesture.<span>Event</span>)<span>; </span>ok {<br/>      <span>if </span>ev.Type == gesture.<span>TypeTap </span>&amp;&amp; b.onClick != nil {<br/>         b.onClick()<br/>      }<br/><br/>      <span>return </span>node.<span>Handled<br/></span><span>   </span>}<br/><br/>   <span>return </span>node.<span>NotHandled<br/></span>}</pre>
<p>That concludes the code required to fulfill a hello world GUI app with Shiny (the complete code is in this book's code repository). Let's now build and run the application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Build and Run</h1>
                </header>
            
            <article>
                
<p>Building our Shiny hello world app is simple as Shiny has no native dependencies—we can simply build or run the <kbd>hello.go</kbd> file directly. Additionally, as many platform drivers are written without CGo, we can easily cross-compile for those operating systems. The following screenshot illustrates building for Linux and then Windows with no additional setup:</p>
<p class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/8d248088-92a3-45af-9ca2-8f358eaed9b3.png" style="width:33.83em;height:16.00em;" width="1124" height="527"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Building our hello app and running it with no CGo is easy</span></div>
<p>Note that building for macOS would require some additional setup, as its driver uses CGo (as described in the preceding <em>Cross-compiling</em> section of <em>Getting started</em>).</p>
<p>However you build or run the application, you should see a little window, something like the following:</p>
<p class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/65c0afec-005e-4362-aed7-0e114a55f93a.png" style="width:7.08em;height:6.42em;" width="96" height="87"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Hello world with Shiny</div>
<p><span>We could refine the visuals of our app, but instead, we will move on to a larger application to demonstrate the capabilities of Shiny.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a user interface</h1>
                </header>
            
            <article>
                
<p>To explore the capabilities of the Shiny toolkit, we will build another complete graphical application. As the development of Shiny has been focused on the lower layer of graphical APIs, an application such as GoMail would involve the creation of many custom widgets. Instead, we will look at a more graphically-oriented application—an image viewer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Design</h1>
                </header>
            
            <article>
                
<p>To get an idea of how the image viewer should look, we will make a rough design that we can follow. The online tool Balsamiq (<a href="https://balsamiq.com/">balsamiq.com</a>) is a good way to rapidly create wireframes that will suit this purpose. Take a look at the following export. It includes a navigation bar along the top, a directory listing on the left, and a full-size image view on the right:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/b5014e8c-d3b3-45c8-aee8-0be926181769.png" style="width:45.17em;height:28.75em;" width="755" height="481"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A mockup of the GoImages application using the Balsamiq tool</div>
<p>Clearly, this image has a far lower level of detail than the design tool we used in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk – Building Graphical Windows Applications</em> (back at the beginning of <a href="36bfea00-c659-4569-864c-de2c460c7467.xhtml">Section 2</a>, <em>Toolkits Using Existing Widgets</em>) for our GoMail design, but this is intentional. Each toolkit in <a href="ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml">Section 3</a>, <em>Modern Graphical Toolkits</em> of this book has a very different look, set by its theme definition and by using a rough design we can build an implementation using the best practice for each of them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>To get started, we will implement the layout. The easiest way to set this up for the application we designed is to use horizontal and vertical flow layouts. Before creating the layout, we should define those widgets that will be included. For now these are represented by the placeholders created in <kbd>makeBar()</kbd> and <kbd>makeList()</kbd>—each of which simply creates a label to show the purpose. We also want to ensure that the items are padded according to our design. To do this with Shiny, we use <kbd>widget.NewPadder()</kbd> and a defined unit, <kbd>padSize</kbd>. We also define a <kbd>spaceSize</kbd> used later for the central padding:</p>
<p> </p>
<pre><span>package main<br/><br/>import (<br/>  "golang.org/x/exp/shiny/driver"<br/>  "golang.org/x/exp/shiny/screen"<br/>  "golang.org/x/exp/shiny/unit"<br/>  "golang.org/x/exp/shiny/widget"<br/>  "golang.org/x/exp/shiny/widget/node"<br/>  "golang.org/x/exp/shiny/widget/theme"<br/><br/>  "image"<br/>  "log"<br/>  "os"<br/><br/>  _ "image/jpeg"<br/>)<br/><br/>var </span>padSize = unit.DIPs(<span>20</span>)<br/><span>var </span>spaceSize = unit.DIPs(<span>10</span>)<br/><br/><span>func </span><span>makeBar</span>() node.<span>Node </span>{<br/>   bar := widget.NewUniform(theme.<span>Neutral</span><span>,<br/></span><span>      </span>widget.NewPadder(widget.<span>AxisBoth</span><span>, </span>padSize<span>,<br/>         </span>widget.NewLabel(<span>"Navigation"</span>)))<br/><br/>   <span>return </span>widget.WithLayoutData(bar<span>,<br/></span><span>      </span>widget.<span>FlowLayoutData</span>{ExpandAlong: <span>true</span><span>, </span>ExpandAcross: <span>true</span>})<br/>}<br/><br/><span>func </span><span>makeList</span>() node.<span>Node </span>{<br/>   <span>return </span>widget.NewUniform(theme.<span>Background</span><span>, </span>widget.NewLabel(<span>"File list"</span>))<br/>}</pre>
<p>To show the image in our layout, we can use <kbd>widget.Image</kbd>, but first we need to load an image from the filesystem—a helper function, <kbd>loadImage()</kbd>, is defined to handle this for the application. When loading an image, don't forget to import the appropriate decoder (in this case, <kbd>image/jpeg</kbd>):</p>
<pre><span>func </span><span>loadImage</span>(name string) image.<span>Image </span>{<br/>   reader<span>, </span>err := os.Open(name)<br/>   <span>if </span>err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   <span>defer </span>reader.Close()<br/><br/>   image<span>, </span>_<span>, </span>err := image.Decode(reader)<br/>   <span>if </span>err != nil {<br/>      log.Fatal(err)<br/>   }<br/><br/>   <span>return </span>image<br/>}</pre>
<p>With that in place, we're ready to implement the layout. The main method constructs the widget tree and creates <kbd>widget.Sheet</kbd> to manage their rendering. This is passed to <kbd>widget.RunWindow()</kbd> to show the contents and run the application. The main layout elements are <kbd>body</kbd> (a horizontal flow) and <kbd>container</kbd> (the vertical flow, containing the navigation and the body). Note how a <kbd>nil</kbd> child is passed to <kbd>widget.NewPadder()</kbd> between the file list and the image viewer to approximate widget spacing. You can also see that the child widget of  <kbd>sheet</kbd> is actually a <kbd>theme.Background</kbd> colored rectangle created using <kbd>widget.NewUniform()</kbd> – this helps to ensure that we have a consistent background color if any widgets leave part of their area unpainted. The container then fills the space by being the uniform's child widget:</p>
<pre><span>func </span><span>main</span>() {<br/>   driver.Main(<span>func</span>(s screen.<span>Screen</span>) {<br/>      image := loadImage("shiny-hall.jpg")<br/><br/>      body := widget.NewFlow(widget.<span>AxisHorizontal</span><span>, </span>makeList()<span>,<br/></span><span>         </span>widget.NewPadder(widget.<span>AxisHorizontal</span><span>, </span>spaceSize<span>, </span>nil)<span>,<br/>         </span>widget.NewImage(image<span>, </span>image.Bounds()))<br/>      container := widget.NewFlow(widget.<span>AxisVertical</span><span>, </span>makeBar()<span>,<br/>                      </span>widget.NewPadder(widget.<span>AxisBoth</span><span>, </span>padSize<span>, </span>body))<br/>      sheet := widget.NewSheet(widget.NewUniform(theme.<span>Background</span><span>, </span>container))<br/><br/>      container.Measure(theme.Default<span>, </span><span>0</span><span>, </span><span>0</span>)<br/>      <span>if </span>err := widget.RunWindow(s<span>, </span>sheet<span>, </span>&amp;widget.<span>RunWindowOptions</span>{<br/>         NewWindowOptions: screen.<span>NewWindowOptions</span>{<br/>            Title:  <span>"GoImages"</span><span>,<br/></span><span>            </span>Width:  container.MeasuredSize.X<span>,<br/></span><span>            </span>Height: container.MeasuredSize.Y<span>,<br/></span><span>         </span>}<span>,<br/></span><span>      </span>})<span>; </span>err != nil {<br/>         log.Fatal(err)<br/>      }<br/>   })<br/>}</pre>
<p>Running the preceding code should result in a window showing the following contents, which broadly matches the layout we designed before. As we progress through this chapter, we will add the content to each area and polish each part of the interface:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/209c4b68-1685-4721-9637-0de41329152b.png" style="width:44.00em;height:31.33em;" width="987" height="703"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The GoImages layout with the navigation bar and file list placeholders</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Navigation</h1>
                </header>
            
            <article>
                
<p>To create the navigation bar in our design, a horizontal flow layout is the right tool for the job. We can use <kbd>widget.Spacer</kbd> to create the gaps between the buttons and the label and to ensure the filename is centered within the space available. A helper method, <kbd>expandSpace()</kbd>, is added to create a new spacer that will expand along the flow layout axis. We also define the <kbd>previousImage()</kbd> and <kbd>nextImage()</kbd> functions, which will execute when the buttons are pressed:</p>
<pre><span>func </span><span>previousImage</span>() {}<br/><br/><span>func </span><span>nextImage</span>() {}<br/><br/><span>func </span><span>expandSpace</span>() node.<span>Node </span>{<br/>   <span>return </span>widget.WithLayoutData(widget.NewSpace()<span>,<br/></span><span>      </span>widget.<span>FlowLayoutData</span>{ExpandAlong: <span>true</span><span>, </span>ExpandAcross: <span>true</span><span>, </span>AlongWeight:<span>1</span>})<br/>}</pre>
<p>With those functions defined, we can lay out the navigation bar. We define the <kbd>prev</kbd>, <kbd>next</kbd>, and <kbd>name</kbd> items and add them to a <kbd>widget.AxisHoriontal</kbd> flow container that includes <kbd>expandSpace()</kbd> elements to space the items. <span>To create buttons, we are using the same </span><kbd>newButton()</kbd><span> function as earlier in this chapter (due to the Shiny widget API not having a standard button defined). We use <kbd>theme.Neutral</kbd> for the background container for this section and we set the whole bar to expand along the horizontal axis:</span></p>
<pre><span>func </span><span>makeBar</span>() node.<span>Node </span>{<br/>   prev := newButton(<span>"Previous"</span><span>, </span><span>previousImage</span>)<br/>   next := newButton(<span>"Next"</span><span>, </span><span>nextImage</span>)<br/>   name := widget.NewLabel(<span>"Filename"</span>)<br/><br/>   flow := widget.NewFlow(widget.<span>AxisHorizontal</span><span>, </span>prev<span>, </span>expandSpace()<span>,<br/></span><span>      </span>widget.NewPadder(widget.<span>AxisBoth</span><span>, </span>padSize<span>, </span>name)<span>, </span>expandSpace()<span>, </span>next)<br/><br/>   bar := widget.NewUniform(theme.<span>Neutral</span><span>, </span>flow)<br/><br/>   <span>return </span>widget.WithLayoutData(bar<span>,<br/></span><span>      </span>widget.<span>FlowLayoutData</span>{ExpandAlong: <span>true</span><span>, </span>ExpandAcross: <span>true</span>})<br/>}</pre>
<p>The preceding code should update the navigation bar, as follows. As we've defined the buttons ourselves, they can be customized to use the border style if preferred (the full code listing is available in this book's code repository):</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/17ab4070-c897-4feb-8dd4-ab2d1c06ecd7.png" style="width:45.33em;height:7.67em;" width="987" height="166"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The updated navigation bar with left- and right- aligned buttons</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">File list</h1>
                </header>
            
            <article>
                
<p class="mce-root">As Shiny does not define a list widget, we will construct one using another vertical flow container. Each item within this list will be a custom cell widget that displays an icon on the left with the filename text left-aligned in the remaining space. First, we will update our <kbd>makeList()</kbd> function to add some dummy data. Each item is a new cell, created using <kbd>makeCell()</kbd> (which is defined later). The items are laid out as a list using <kbd>widget.NewFlow()</kbd> on the vertical axis:</p>
<pre><span>func </span><span>makeList</span>(dir <span>string</span>) node.<span>Node </span>{<br/>   parent := makeCell(dir<span>, </span>nil)<br/>   cell1 := makeCell(<span>"Filename 1"</span><span>, </span>loadImage(<span>"shiny-hall.jpg"</span>))<br/>   cell2 := makeCell(<span>"Filename 2"</span><span>, </span>loadImage(<span>"shiny-hall.jpg"</span>))<br/>   cell3 := makeCell(<span>"Filename 3"</span><span>, </span>loadImage(<span>"shiny-hall.jpg"</span>))<br/>   return widget.NewFlow(widget.<span>AxisVertical</span><span>, </span>parent<span>, </span>cell1<span>, </span>cell2<span>, </span>cell3)<br/>}</pre>
<p>As you can see, the first item in the list is the name of our directory, which needs a different icon. We can load a standard icon from the Shiny icon collection using the <kbd>iconvg</kbd> package, specifically, <kbd>iconvg.Rasterizer</kbd> and <kbd>iconvg.Decode()</kbd>. Using the following helper function, we can load the <kbd>icons.FileFolder</kbd> icon into an image so it can be drawn using the same functions as images we load from the filesystem:</p>
<pre><span>func </span><span>loadDirIcon</span>() image.<span>Image </span>{<br/>   <span>var </span>raster iconvg.<span>Rasterizer<br/></span><span>   </span>bounds := image.Rect(<span>0</span><span>, </span><span>0</span><span>, </span><span>iconSize</span><span>, </span><span>iconSize</span>)<br/>   icon := image.NewRGBA(bounds)<br/>   raster.SetDstImage(icon<span>, </span>bounds<span>, </span>draw.<span>Over</span>)<br/><br/>   iconvg.Decode(&amp;raster<span>, </span>icons.FileFolder<span>, </span>nil)<br/>   <span>return </span>icon<br/>}</pre>
<p>The last part of our layout code is the <kbd>makeCell()</kbd> function. In this case, it's a simple wrapper around the creation of a <kbd>cell</kbd> widget. When this function is passed a <kbd>nil</kbd> icon, it will set up the directory icon using the helper above. When an icon is passed, then it creates an <kbd>onClick</kbd> function that will load the image in the main view:</p>
<pre><span>func </span><span>makeCell</span>(name <span>string</span><span>, </span>icon image.<span>Image</span>) node.<span>Node </span>{<br/>   <span>var </span>onClick <span>func</span>()<br/>   <span>if </span>icon == nil {<br/>      icon = loadDirIcon()<br/>   } <span>else </span>{<br/>      onClick = <span>func</span>() {chooseImage(icon)}<br/>   }<br/><br/>   <span>return </span>newCell(icon<span>, </span>name<span>, </span>onClick)<br/>}</pre>
<p>The details of our cell widget are very similar to the button we created earlier and so most of the code is omitted. The next excerpt shows its <kbd>PaintBase()</kbd> function, which draws the icon and text to screen. It calculates the ratio of an image so that it can be correctly painted within the cell. The text is then drawn like the button code, but with a space between it and the image we painted.</p>
<p>To make this work, a simple <kbd>scaleImage()</kbd> function is also needed, which uses <kbd>draw.ApproxBiLinear</kbd> to resize the graphic to fit with reasonable performance:</p>
<pre><br/><span>func </span>(c *<span>cell</span>) <span>PaintBase</span>(ctx *node.<span>PaintBaseContext</span><span>, </span>origin image.<span>Point</span>) <span>error </span>{<br/>   c.Marks.UnmarkNeedsPaintBase()<br/>   face := ctx.Theme.AcquireFontFace(theme.<span>FontFaceOptions</span>{})<br/>   <span>defer </span>ctx.Theme.ReleaseFontFace(theme.<span>FontFaceOptions</span>{}<span>, </span>face)<br/><br/>   ratio := <span>float32</span>(c.icon.Bounds().Max.Y)/<span>float32</span>(c.icon.Bounds().Max.X)<br/>   <span>if </span>c.icon.Bounds().Max.Y &gt; c.icon.Bounds().Max.X {<br/>      ratio = <span>float32</span>(c.icon.Bounds().Max.X)/<span>float32</span>(c.icon.Bounds().Max.Y)<br/>   }<br/>   scaled := scaleImage(c.icon<span>, </span><span>iconSize</span><span>, </span><span>int</span>(<span>float32</span>(<span>iconSize</span>)*ratio))<br/><br/>   draw.Draw(ctx.Dst<span>, </span>c.Rect.Add(origin)<span>, </span>scaled<span>, </span>image.<span>Point</span>{}<span>, </span>draw.<span>Over</span>)<br/>   d := font.<span>Drawer</span>{<br/>      Dst:  ctx.Dst<span>,<br/></span><span>      </span>Src:  theme.<span>Foreground</span>.Uniform(ctx.Theme)<span>,<br/></span><span>      </span>Face: face<span>,<br/></span><span>      </span>Dot:  fixed.<span>Point26_6</span>{X: fixed.I(c.Rect.Min.X + origin.X + <span>iconSize </span>+ <span>space</span>)<span>,<br/></span><span>         </span>Y: fixed.I(c.Rect.Min.Y + origin.Y + face.Metrics().Ascent.Ceil())}<span>,<br/></span><span>   </span>}<br/>   d.DrawString(c.label)<br/><br/>   <span>return </span>nil<br/>}<br/><br/><span>func </span><span>scaleImage</span>(src image.<span>Image</span><span>, </span>width<span>, </span>height <span>int</span>) image.<span>Image </span>{<br/>   ret := image.NewRGBA(image.Rect(<span>0</span><span>, </span><span>0</span><span>, </span>width<span>, </span>height))<br/><br/>   draw.ApproxBiLinear.Scale(ret<span>, </span>ret.Bounds()<span>, </span>src<span>, </span>src.Bounds()<span>, </span>draw.<span>Src</span><span>, </span>nil)<br/><br/>   <span>return </span>ret<br/>}</pre>
<p>All this code comes together to create a file listing with an image preview, as shown in the following screenshot:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/417d4265-d111-43d9-853b-5ca4e8168127.png" style="width:44.08em;height:29.33em;" width="1061" height="706"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The completed file list on the left with placeholder content</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Image view</h1>
                </header>
            
            <article>
                
<p>The <kbd>widget.Image</kbd> type draws an image to the buffer at the same resolution as it was loaded (a pixel in the source image matches a pixel on screen). What we need to do for the image viewer is scale it to fit the available space. To do this, we create a new custom widget named <kbd>scaledImage</kbd>. The code is very similar to the Shiny image widget but with a more complicated <kbd>PaintBase()</kbd> function.</p>
<p>This function calculates <kbd>imgWidth</kbd> and <kbd>imgHeight</kbd> to fit within the current bounds of the widget and<span> maintain the aspect ratio of the source image</span>. It then scales the image using the <kbd>scaleImage()</kbd> helper function defined earlier, ready to paint at the correct resolution. Lastly, <kbd>offset</kbd> is calculated so that the image is centered within the available space:</p>
<pre><span>func </span>(w *<span>scaledImage</span>) <span>PaintBase</span>(ctx *node.<span>PaintBaseContext</span><span>, </span>origin image.<span>Point</span>) <span>error </span>{<br/>   w.Marks.UnmarkNeedsPaintBase()<br/>   <span>if </span>w.Src == nil {<br/>      <span>return </span>nil<br/>   }<br/><br/>   wRect := w.Rect.Add(origin)<br/>   ratio := <span>float32</span>(w.Src.Bounds().Max.X)/<span>float32</span>(w.Src.Bounds().Max.Y)<br/>   width := wRect.Max.X - wRect.Min.X<br/>   height := wRect.Max.Y - wRect.Min.Y<br/><br/>   imgWidth := <span>int</span>(math.Min(<span>float64</span>(width)<span>, </span><span>float64</span>(w.Src.Bounds().Max.X)))<br/>   imgHeight := <span>int</span>(<span>float32</span>(imgWidth)/ratio)<br/><br/>   <span>if </span>imgHeight &gt; height {<br/>      imgHeight = <span>int</span>(math.Min(<span>float64</span>(height)<span>, </span><span>float64</span>(w.Src.Bounds().Max.Y)))<br/>      imgWidth = <span>int</span>(<span>float32</span>(imgHeight)*ratio)<br/>   }<br/><br/>   scaled := scaleImage(w.Src<span>, </span>imgWidth<span>, </span>imgHeight)<br/>   offset := image.<span>Point</span>{(imgWidth-width)/<span>2</span><span>, </span>(imgHeight-height)/<span>2</span>}<br/><br/>   draw.Draw(ctx.Dst<span>, </span>wRect<span>, </span>scaled<span>, </span>offset<span>, </span>draw.<span>Over</span>)<br/>   <span>return </span>nil<br/>}</pre>
<p>To avoid a blank space being left by the preceding calculations, let's add a checkered pattern typical in many other image applications. To make this possible, we create a custom image type named <kbd>checkerImage</kbd> that simply returns pixels from the <kbd>At()</kbd> function based on a regular checker pattern. As images are bounded, we need to add a <kbd>resize()</kbd> function so the image can expand to fill the space:</p>
<pre><span>var </span>checkers = &amp;<span>checkerImage</span>{}<br/><br/><span>type </span>checkerImage <span>struct </span>{<br/>   bounds image.<span>Rectangle<br/></span>}<br/><br/><span>func </span>(c *<span>checkerImage</span>) <span>resize</span>(width<span>, </span>height <span>int</span>) {<br/>   c.bounds = image.<span>Rectangle</span>{image.Pt(<span>0</span><span>, </span><span>0</span>)<span>, </span>image.Pt(width<span>, </span>height)}<br/>}<br/><br/><span>func </span>(c *<span>checkerImage</span>) <span>ColorModel</span>() color.<span>Model </span>{<br/>   <span>return </span>color.RGBAModel<br/>}<br/><br/><span>func </span>(c *<span>checkerImage</span>) <span>Bounds</span>() image.<span>Rectangle </span>{<br/>   <span>return </span>c.bounds<br/>}<br/><br/><span>func </span>(c *<span>checkerImage</span>) <span>At</span>(x<span>, </span>y <span>int</span>) color.<span>Color </span>{<br/>   xr := x/<span>10<br/></span><span>   </span>yr := y/<span>10<br/></span><span><br/></span><span>   </span><span>if </span>xr%<span>2 </span>== yr%<span>2 </span>{<br/>      <span>return </span>color.<span>RGBA</span>{<span>0xc0</span><span>, </span><span>0xc0</span><span>, </span><span>0xc0</span><span>, </span><span>0xff</span>}<br/>   } <span>else </span>{<br/>      <span>return </span>color.<span>RGBA</span>{<span>0x99</span><span>, </span><span>0x99</span><span>, </span><span>0x99</span><span>, </span><span>0xff</span>}<br/>   }<br/>}</pre>
<p>To include the checker pattern, we simply need to update the end of the <kbd>PaintBase()</kbd> function of <kbd>scaledImage</kbd>. Before the image itself is drawn, we set the checker pattern to expand to the correct size and paint it onto the background. The checkers are drawn with the <kbd>draw.Src</kbd> mode and the image is then drawn over the top using the <kbd>draw.Over</kbd> mode:</p>
<pre>func (w *scaledImage) PaintBase(ctx *node.PaintBaseContext, origin image.Point) error {<br/><br/>   ...<br/><br/>   checkers.resize(width<span>, </span>height)<br/>   draw.Draw(ctx.Dst<span>, </span>wRect<span>, </span>checkers<span>, checkers.Bounds().Min</span><span>, </span>draw.<span>Src</span>)<br/>   draw.Draw(ctx.Dst<span>, </span>wRect<span>, </span>scaled<span>, </span>offset<span>, </span>draw.<span>Over</span>)<br/><span>   return </span>nil<br/>}</pre>
<p>With all of this code in place, we have an updated application that correctly fills the layout we designed and scales and positions the placeholder image we have to fit within the available space:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/1a08c0b1-bfd3-4f72-87cc-b15cb00e1d1d.png" style="width:41.25em;height:30.33em;" width="783" height="576"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The interface updated to show images centered at the correct aspect ratio</div>
<p><span>That's the majority of our graphical code complete. Next, we will make the necessary additions to load real content from the</span> local filesystem.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating with the GUI</h1>
                </header>
            
            <article>
                
<p>Now that we have a user interface up and running, we need to load some real data and display it. We start this task by obtaining a list of image files for the requested directory and updating the user interface to list those instead of the placeholder information. Remember, at this stage, to add the extra image imports so we can decode all of the images that we will then filter for in a new <kbd>getImageList()</kbd> function:</p>
<pre><span>import (<br/>   _ "image/jpeg"<br/>   _ "image/png"<br/>   _ "image/gif"<br/>)<br/><br/>var names []string<br/><br/>func </span><span>getImageList</span>(dir <span>string</span>) []<span>string </span>{<br/>   files<span>, </span>_ := ioutil.ReadDir(dir)<br/><br/>   <span>for </span>_<span>, </span>file := <span>range </span>files {<br/>      <span>if </span>file.IsDir() {<br/>         <span>continue<br/></span><span>      </span>}<br/><br/>      ext := strings.ToLower(filepath.Ext(file.Name()))<br/>      <span>if </span>ext == <span>".jpg" </span>|| ext == <span>".jpeg" </span>|| ext == <span>".png" || ext == ".gif" </span>{<br/>         names = append(names<span>, </span>file.Name())<br/>      }<br/>   }<br/><br/>   <span>return </span>names<br/>}</pre>
<p>The listing shows a fairly simple algorithm for checking each item in a directory and adding it to a <kbd>names</kbd> list if the filename looks like a image file that we support. Simple filename extension checking should be sufficient for our purposes here. We add these filenames to a global list for later use in the user interface.</p>
<p>Once we have a list of supported files, we can update the existing <kbd>makeList()</kbd> function. The new version iterates over the <kbd>files</kbd> list and adds a new cell for each item. The <kbd>makeCell()</kbd> function does not need any additional work to use this new content, but we do pass the array index for use later in the button handlers. We also save the <kbd>images</kbd> loaded in memory for display when selected:</p>
<pre><span>var images []image.Image<br/><br/>func </span><span>makeList</span>(dir <span>string</span><span>, </span>files []<span>string</span>) node.<span>Node </span>{<br/>   parent := makeCell(-<span>1</span><span>, </span>filepath.Base(dir)<span>, </span>nil)<br/>   children := []node.<span>Node</span>{parent}<br/><br/>   <span>for </span>idx<span>, </span>name := <span>range </span>files {<br/>      img := loadImage(path.Join(dir<span>, </span>name))<br/>      cell := makeCell(idx<span>, </span>name<span>, </span>img)<br/>      children = append(children<span>, </span>cell)<br/>      images = append(images<span>, </span>img)<br/>   }<br/><br/>   <span>return </span>widget.NewFlow(widget.<span>AxisVertical</span><span>, </span>children...)<br/>}</pre>
<p>To update the main image displayed, we need to add a new function to our <kbd>scaledImage</kbd> widget. This new <kbd>SetImage()</kbd> function sets the image reference to be displayed and marks the widget for painting. Updating the <kbd>node.MarkNeedsPaintBase</kbd> mark means that the widget will be repainted next time there is a graphical paint event (we will discuss paint events in more detail shortly):</p>
<pre><span>func </span>(w *<span>scaledImage</span>) <span>SetImage</span>(img image.<span>Image</span>) {<br/>   w.Src = img<br/>   w.Mark(node.<span>MarkNeedsPaintBase</span>)<br/>}</pre>
<p>To make use of this new function, we update our <kbd>chooseImage()</kbd> code to set the image selected. We also need to store a reference to the <kbd>scaledImage</kbd> widget created to call the function on:</p>
<pre><span>var </span>view *<span>scaledImage<br/><br/>func chooseImage(idx int) {<br/>   view.SetImage(images[idx])<br/>}<br/></span></pre>
<p>When the image is changed, we also need to set the correct filename to the label above the image. To do so, we will add a reference to the <kbd>widget.Label</kbd> object and set its <kbd>Text</kbd> field. After updating this property, we also need to set the <kbd>node.MarkNeedsMeasureLayout</kbd> flag, as the text may have a different size to the previous content. We use the <kbd>names</kbd> array and the index variable passed into <kbd>chooseImage()</kbd> to look up the content. This could also be accomplished by creating a list of items using a new object type that stores the image, name, and metadata in a single list, but the approach of multiple indexed lists is easier to explain in smaller code samples:</p>
<pre><span>var name *widget.Label<br/>var index = 0<br/><br/>func </span><span>chooseImage</span>(idx <span>int</span>) {<br/>   index = idx<br/>   view.SetImage(images[idx])<br/><br/>   name.Text = names[idx]<br/>   name.Mark(node.<span>MarkNeedsMeasureLayout</span>)<br/>   name.Mark(node.<span>MarkNeedsPaintBase</span>)<br/>}</pre>
<p>We also need to fill in the empty <kbd>previousImage()</kbd> and <kbd>nextImage()</kbd> functions that the header buttons call. A simple helper function called <kbd>changeImage()</kbd> is added to handle <span>image </span>switching based on an offset from the current image (either <kbd>1</kbd> or <kbd>-1</kbd>). Each button callback calls this with the appropriate offset:</p>
<pre><span>func </span><span>changeImage</span>(offset <span>int</span>) {<br/>   newidx := index + offset<br/>   <span>if </span>newidx &lt; <span>0 </span>|| newidx &gt;= len(images) {<br/>      <span>return<br/></span><span>   </span>}<br/><br/>   chooseImage(newidx)<br/>}<br/><br/><span>func </span><span>previousImage</span>() {<br/>   changeImage(-<span>1</span>)<br/>}<br/><br/><span>func </span><span>nextImage</span>() {<br/>   changeImage(<span>1</span>)<br/>}</pre>
<p><span>With this in place, the <kbd>main()</kbd> function can include a call to </span><kbd>chooseImage(0)</kbd><span> to load the first image found in the directory. Of course, you should check that there is at least one image before you do this.</span></p>
<p>The last change is to determine which directory to show images for when the application loads. The previous <kbd>main()</kbd> function is renamed <kbd>loadUI()</kbd> (which takes a directory parameter to pass into <kbd>getImageList()</kbd> and <kbd>makeList()</kbd>). A new main function is created that parses command-line arguments to allow the user to specify a directory. The following code will print out a helpful usage hint if some unexpected parameters are passed (or if <kbd>--help</kbd> is specified) and if no parameters are found, it will show the current working directory (using <kbd>os.Getwd()</kbd>):</p>
<pre><span>func </span><span>main</span>() {<br/>   dir<span>, </span>_ := os.Getwd()<br/><br/>   flag.Usage = <span>func</span>() {<br/>      fmt.Println(<span>"goimages takes a single, optional, directory parameter"</span>)<br/>   }<br/>   flag.Parse()<br/><br/>   <span>if </span>len(flag.Args()) &gt; <span>1 </span>{<br/>      flag.Usage()<br/>      os.Exit(<span>2</span>)<br/>   } <span>else if </span>len(flag.Args()) == <span>1 </span>{<br/>      dir = flag.Args()[<span>0</span>]<br/><br/>      <span>if </span>_<span>, </span>err := ioutil.ReadDir(dir)<span>; </span>os.IsNotExist(err) {<br/>         fmt.Println(<span>"Directory"</span><span>, </span>dir<span>, </span><span>"does not exist or could not be read"</span>)<br/>         os.Exit(<span>1</span>)<br/>      }<br/>   }<br/>   loadUI(dir)<br/>}</pre>
<p class="mce-root"/>
<p>With these modifications, we've created a complete image viewer application that displays thumbnails for a whole directory of images and one large image view. By tapping on items in the list, or using the <span class="packt_screen">Next</span> and <span class="packt_screen">Previous</span> buttons, you can switch between the images available. While this works, it can be quite slow to load in a large directory. Next, we'll explore how this can be improved:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4e068050-5e41-4272-968d-64f3ec23dba9.png" style="width:48.25em;height:28.33em;" width="947" height="556"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The completed GoImages application running on macOS</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background processing</h1>
                </header>
            
            <article>
                
<p>Image processing, even just loading the images to be viewed, is a CPU-intensive task, so if we open a directory with a lot of pictures, the application will be very slow to load. We can fix this delay by moving our image loading to work in the background while we load the user interface. Thankfully, creating new threads for asynchronous processing is very simple with Go (as we explored in <a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml">Chapter 3</a>, <em>Go to the Rescue!</em>), but we also need to ensure that the user interface is updated accordingly.</p>
<p><span>To delay the loading of images until there is processing power available, we can replace uses of </span><kbd>loadImage()</kbd><span> with a replacement </span><kbd>asyncImage</kbd> <span>type that will handle the heavy lifting. The main image loading code will be moved into a private <kbd>load()</kbd> function that's called from <kbd>newAsyncImage()</kbd> using <kbd>go img.load()</kbd>, therefore starting it in the background:</span></p>
<pre><span>type </span>asyncImage <span>struct </span>{<br/>   path     <span>string<br/></span><span>   </span>img      image.<span>Image<br/></span><span>   </span>callback <span>func</span>(image.<span>Image</span>)<br/>}<br/><br/><span>func </span>(a *<span>asyncImage</span>) <span>load</span>() {<br/>   reader<span>, </span>err := os.Open(a.path)<br/>   <span>if </span>err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   <span>defer </span>reader.Close()<br/><br/>   a.img<span>, </span>_<span>, </span>err = image.Decode(reader)<br/>   <span>if </span>err != nil {<br/>      log.Fatal(err)<br/>   }<br/><br/>   a.callback(a.img)<br/>}<br/><br/><span>func </span><span>newAsyncImage</span>(path <span>string</span><span>, </span>loaded <span>func</span>(image.<span>Image</span>)) *<span>asyncImage </span>{<br/>   img := &amp;<span>asyncImage</span>{path: path<span>, </span>callback:loaded}<br/>   <span>go </span>img.load()<br/><br/>   <span>return </span>img<br/>}</pre>
<p>With the definition of an asynchronous image loader, we can replace the use of <kbd>image.Image</kbd> with <kbd>asyncImage</kbd>. The important thing to remember is that the image in the <kbd>img</kbd> field will be <kbd>nil</kbd> until the <kbd>load()</kbd> function has completed. Be sure that any code using images checks for <kbd>nil</kbd> data before processing. The first function we update is <kbd>makeCell()</kbd> so that it no longer accepts an image parameter. Instead, we pass a <kbd>loaded</kbd> callback function to set the image once it is loaded. We update <kbd>makeList()</kbd> to replace the cell creation code with the following:</p>
<pre>   cell := makeCell(idx<span>, </span>name)<br/>   i := idx<br/>   img := newAsyncImage(path.Join(dir<span>, </span>name)<span>, </span><span>func</span>(img image.<span>Image</span>) {<br/>      cell.icon.SetImage(img)<br/>      <span>if </span>i == index {<br/>         view.SetImage(img)<br/>      }<br/>   })</pre>
<p>This code will ensure that thumbnails are shown once the image has loaded but also that, if the image is the current selection, it updates the main image <kbd>view</kbd> as well.</p>
<p>If you run the application at this point, you will notice that some images are loaded while others may not be. This is due to us not having signaled to Shiny that a re-paint is necessary. The marks that were applied to the widgets to force them to be repainted do not actually trigger the painting of the interface; it simply marks them as needing to be painted the next time a re-paint is triggered:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/353de3f4-1d2d-4602-b60e-6f1e9ae39bb6.png" style="width:44.92em;height:28.58em;" width="929" height="590"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A partial rendering when loading images in the background</div>
<p>There is no easy way to signal Shiny to refresh the user interface, so we will make a <kbd>refresh()</kbd> function for convenience. This should be called when the text for a filename is updated and when a different (or lazy-loaded) image is set on the <kbd>scaledImage</kbd> widget:</p>
<pre><span>func </span><span>chooseImage</span>(idx <span>int</span><span>, </span>img image.<span>Image</span>) {<br/>   ...<br/><br/>   name.Mark(node.<span>MarkNeedsPaintBase</span>)<br/><span>   refresh(name)<br/></span>}<br/><br/>func (w *scaledImage) SetImage(img image.Image) {<br/>   w.Src = img<br/>   w.Mark(node.MarkNeedsPaintBase)<br/><br/>   refresh(w)<br/>}<br/><br/><span>func </span><span>refresh</span>(_ node.<span>Node</span>) {<br/>   // Ideally we should refresh but this requires a reference to the window<br/>   <span>// win.Send(paint.Event{})</span><span><br/></span>}</pre>
<p>Unfortunately, at this point, we can't proceed further without a significant amount of extra code. This is a limitation of the recommended <kbd>widget.RunWindow()</kbd> function that we used to load our interface. The window reference that we would need to send the paint event to is not available outside the Shiny package. To resolve this issue, it would be necessary to use the <kbd>NewWindow()</kbd> function on the <kbd>screen.Screen</kbd> instance, passed into the <kbd>driver.Main()</kbd> function—but to do so would mean completely re-implementing the event loop as well, which is a lot of work.</p>
<p>The reason we didn't notice the issue when setting the main image earlier is because, when the application is receiving user events (mouse moves and so on), its event loop runs. Each time an iteration of the loop completes, the user interface is repainted. Sending the <kbd>paint.Event</kbd> previously illustrated would also cause this to happen. Therefore, it follows that the interface will update after background image loading if the user is currently interacting with the GUI (even just moving the mouse over it). It's left as an exercise for the reader to implement the replacement lifecycle to resolve this issue, if desired.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at our first modern widget toolkit, Shiny, which has been designed specifically for the Go language. We explored its design principles and how it manages to support cross-platform graphical application development without the need for external dependencies. We also saw that its design makes use of powerful features of the Go language, such as concurrency and the standard library.</p>
<p>The graphical design principles behind Shiny provide a new interpretation of the desktop application GUI, which will be familiar to users of the Android mobile operating system (due to them using the same material design approach). While exploring its graphical capabilities, we saw that the widget set is currently in its early stages and so isn't yet ready to support the GoMail application we've been creating in previous chapters. To explore the capabilities of the Shiny toolkit, we instead developed an image viewer application, which is better suited to the current feature set. We saw how powerful the rendering capabilities of Shiny are, but also that there are a few challenges around creating a rich application user interface.</p>
<p>In the next chapter, we will look at another toolkit that takes a modern approach to the widget toolkit. Nuklear also helps developers to create cross-platform graphical user interfaces but does so from an embedded user interface approach. We'll explore the Go bindings for this library, named <kbd>nk</kbd>.</p>


            </article>

            
        </section>
    </div>



  </body></html>