["```go\npackage main\n\nimport (\n   \"golang.org/x/exp/shiny/driver\"\n   \"golang.org/x/exp/shiny/screen\"\n   \"golang.org/x/exp/shiny/widget\"\n   \"golang.org/x/exp/shiny/widget/theme\"\n\n   \"log\"\n)\n\nfunc main() {\n   driver.Main(func(s screen.Screen) {\n      label := widget.NewLabel(\"Hello World!\")\n      button := newButton(\"Quit\",\n         func() {\n            log.Println(\"To quit close this window\")\n         })\n\n      w := widget.NewFlow(widget.AxisVertical, label, button)\n      sheet := widget.NewSheet(widget.NewUniform(theme.Neutral, w))\n\n      w.Measure(theme.Default, 0, 0)\n      if err := widget.RunWindow(s, sheet, &widget.RunWindowOptions{\n         NewWindowOptions: screen.NewWindowOptions{\n            Title: \"Hello\",\n            Width: w.MeasuredSize.X,\n            Height: w.MeasuredSize.Y,\n         },\n      }); err != nil {\n         log.Fatal(err)\n      }\n   })\n}\n```", "```go\ntype button struct {\n   node.LeafEmbed\n\n   label   string\n   onClick func()\n}\n\nfunc NewButton(label string, onClick func()) *button {\n   b := &button {label: label, onClick: onClick}\n   b.Wrapper = b\n\n   return b\n}\n```", "```go\nconst buttonPad = 4\n\nfunc (b *button) Measure(t *theme.Theme, widthHint, heightHint int) {\n   face := t.AcquireFontFace(theme.FontFaceOptions{})\n   defer t.ReleaseFontFace(theme.FontFaceOptions{}, face)\n\n   b.MeasuredSize.X = font.MeasureString(face, b.label).Ceil() + 2*buttonPad\n   b.MeasuredSize.Y = face.Metrics().Ascent.Ceil() + face.Metrics().Descent.Ceil() + 2*buttonPad\n}\n```", "```go\nfunc (b *button) PaintBase(ctx *node.PaintBaseContext, origin image.Point) error {\n   b.Marks.UnmarkNeedsPaintBase()\n   face := ctx.Theme.AcquireFontFace(theme.FontFaceOptions{})\n   defer ctx.Theme.ReleaseFontFace(theme.FontFaceOptions{}, face)\n\n   draw.Draw(ctx.Dst, b.Rect.Add(origin).Inset(buttonPad), theme.Foreground.Uniform(ctx.Theme), image.Point{}, draw.Src)\n   d := font.Drawer{\n      Dst: ctx.Dst,\n      Src: theme.Background.Uniform(ctx.Theme),\n      Face: face,\n      Dot: fixed.Point26_6{X: fixed.I(b.Rect.Min.X + buttonPad), Y: fixed.I(b.Rect.Min.Y + face.Metrics().Ascent.Ceil() + buttonPad)},\n   }\n   d.DrawString(b.label)\n\n   return nil\n}\n```", "```go\nfunc (b *button) OnInputEvent(e interface{}, origin image.Point) node.EventHandled {\n   if ev, ok := e.(gesture.Event); ok {\n      if ev.Type == gesture.TypeTap && b.onClick != nil {\n         b.onClick()\n      }\n\n      return node.Handled\n   }\n\n   return node.NotHandled\n}\n```", "```go\npackage main\n\nimport (\n  \"golang.org/x/exp/shiny/driver\"\n  \"golang.org/x/exp/shiny/screen\"\n  \"golang.org/x/exp/shiny/unit\"\n  \"golang.org/x/exp/shiny/widget\"\n  \"golang.org/x/exp/shiny/widget/node\"\n  \"golang.org/x/exp/shiny/widget/theme\"\n\n  \"image\"\n  \"log\"\n  \"os\"\n\n  _ \"image/jpeg\"\n)\n\nvar padSize = unit.DIPs(20)\nvar spaceSize = unit.DIPs(10)\n\nfunc makeBar() node.Node {\n   bar := widget.NewUniform(theme.Neutral,\n      widget.NewPadder(widget.AxisBoth, padSize,\n         widget.NewLabel(\"Navigation\")))\n\n   return widget.WithLayoutData(bar,\n      widget.FlowLayoutData{ExpandAlong: true, ExpandAcross: true})\n}\n\nfunc makeList() node.Node {\n   return widget.NewUniform(theme.Background, widget.NewLabel(\"File list\"))\n}\n```", "```go\nfunc loadImage(name string) image.Image {\n   reader, err := os.Open(name)\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer reader.Close()\n\n   image, _, err := image.Decode(reader)\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   return image\n}\n```", "```go\nfunc main() {\n   driver.Main(func(s screen.Screen) {\n      image := loadImage(\"shiny-hall.jpg\")\n\n      body := widget.NewFlow(widget.AxisHorizontal, makeList(),\n         widget.NewPadder(widget.AxisHorizontal, spaceSize, nil),\n         widget.NewImage(image, image.Bounds()))\n      container := widget.NewFlow(widget.AxisVertical, makeBar(),\n                      widget.NewPadder(widget.AxisBoth, padSize, body))\n      sheet := widget.NewSheet(widget.NewUniform(theme.Background, container))\n\n      container.Measure(theme.Default, 0, 0)\n      if err := widget.RunWindow(s, sheet, &widget.RunWindowOptions{\n         NewWindowOptions: screen.NewWindowOptions{\n            Title:  \"GoImages\",\n            Width:  container.MeasuredSize.X,\n            Height: container.MeasuredSize.Y,\n         },\n      }); err != nil {\n         log.Fatal(err)\n      }\n   })\n}\n```", "```go\nfunc previousImage() {}\n\nfunc nextImage() {}\n\nfunc expandSpace() node.Node {\n   return widget.WithLayoutData(widget.NewSpace(),\n      widget.FlowLayoutData{ExpandAlong: true, ExpandAcross: true, AlongWeight:1})\n}\n```", "```go\nfunc makeBar() node.Node {\n   prev := newButton(\"Previous\", previousImage)\n   next := newButton(\"Next\", nextImage)\n   name := widget.NewLabel(\"Filename\")\n\n   flow := widget.NewFlow(widget.AxisHorizontal, prev, expandSpace(),\n      widget.NewPadder(widget.AxisBoth, padSize, name), expandSpace(), next)\n\n   bar := widget.NewUniform(theme.Neutral, flow)\n\n   return widget.WithLayoutData(bar,\n      widget.FlowLayoutData{ExpandAlong: true, ExpandAcross: true})\n}\n```", "```go\nfunc makeList(dir string) node.Node {\n   parent := makeCell(dir, nil)\n   cell1 := makeCell(\"Filename 1\", loadImage(\"shiny-hall.jpg\"))\n   cell2 := makeCell(\"Filename 2\", loadImage(\"shiny-hall.jpg\"))\n   cell3 := makeCell(\"Filename 3\", loadImage(\"shiny-hall.jpg\"))\n   return widget.NewFlow(widget.AxisVertical, parent, cell1, cell2, cell3)\n}\n```", "```go\nfunc loadDirIcon() image.Image {\n   var raster iconvg.Rasterizer\n   bounds := image.Rect(0, 0, iconSize, iconSize)\n   icon := image.NewRGBA(bounds)\n   raster.SetDstImage(icon, bounds, draw.Over)\n\n   iconvg.Decode(&raster, icons.FileFolder, nil)\n   return icon\n}\n```", "```go\nfunc makeCell(name string, icon image.Image) node.Node {\n   var onClick func()\n   if icon == nil {\n      icon = loadDirIcon()\n   } else {\n      onClick = func() {chooseImage(icon)}\n   }\n\n   return newCell(icon, name, onClick)\n}\n```", "```go\n\nfunc (c *cell) PaintBase(ctx *node.PaintBaseContext, origin image.Point) error {\n   c.Marks.UnmarkNeedsPaintBase()\n   face := ctx.Theme.AcquireFontFace(theme.FontFaceOptions{})\n   defer ctx.Theme.ReleaseFontFace(theme.FontFaceOptions{}, face)\n\n   ratio := float32(c.icon.Bounds().Max.Y)/float32(c.icon.Bounds().Max.X)\n   if c.icon.Bounds().Max.Y > c.icon.Bounds().Max.X {\n      ratio = float32(c.icon.Bounds().Max.X)/float32(c.icon.Bounds().Max.Y)\n   }\n   scaled := scaleImage(c.icon, iconSize, int(float32(iconSize)*ratio))\n\n   draw.Draw(ctx.Dst, c.Rect.Add(origin), scaled, image.Point{}, draw.Over)\n   d := font.Drawer{\n      Dst:  ctx.Dst,\n      Src:  theme.Foreground.Uniform(ctx.Theme),\n      Face: face,\n      Dot:  fixed.Point26_6{X: fixed.I(c.Rect.Min.X + origin.X + iconSize + space),\n         Y: fixed.I(c.Rect.Min.Y + origin.Y + face.Metrics().Ascent.Ceil())},\n   }\n   d.DrawString(c.label)\n\n   return nil\n}\n\nfunc scaleImage(src image.Image, width, height int) image.Image {\n   ret := image.NewRGBA(image.Rect(0, 0, width, height))\n\n   draw.ApproxBiLinear.Scale(ret, ret.Bounds(), src, src.Bounds(), draw.Src, nil)\n\n   return ret\n}\n```", "```go\nfunc (w *scaledImage) PaintBase(ctx *node.PaintBaseContext, origin image.Point) error {\n   w.Marks.UnmarkNeedsPaintBase()\n   if w.Src == nil {\n      return nil\n   }\n\n   wRect := w.Rect.Add(origin)\n   ratio := float32(w.Src.Bounds().Max.X)/float32(w.Src.Bounds().Max.Y)\n   width := wRect.Max.X - wRect.Min.X\n   height := wRect.Max.Y - wRect.Min.Y\n\n   imgWidth := int(math.Min(float64(width), float64(w.Src.Bounds().Max.X)))\n   imgHeight := int(float32(imgWidth)/ratio)\n\n   if imgHeight > height {\n      imgHeight = int(math.Min(float64(height), float64(w.Src.Bounds().Max.Y)))\n      imgWidth = int(float32(imgHeight)*ratio)\n   }\n\n   scaled := scaleImage(w.Src, imgWidth, imgHeight)\n   offset := image.Point{(imgWidth-width)/2, (imgHeight-height)/2}\n\n   draw.Draw(ctx.Dst, wRect, scaled, offset, draw.Over)\n   return nil\n}\n```", "```go\nvar checkers = &checkerImage{}\n\ntype checkerImage struct {\n   bounds image.Rectangle\n}\n\nfunc (c *checkerImage) resize(width, height int) {\n   c.bounds = image.Rectangle{image.Pt(0, 0), image.Pt(width, height)}\n}\n\nfunc (c *checkerImage) ColorModel() color.Model {\n   return color.RGBAModel\n}\n\nfunc (c *checkerImage) Bounds() image.Rectangle {\n   return c.bounds\n}\n\nfunc (c *checkerImage) At(x, y int) color.Color {\n   xr := x/10\n   yr := y/10\n\n   if xr%2 == yr%2 {\n      return color.RGBA{0xc0, 0xc0, 0xc0, 0xff}\n   } else {\n      return color.RGBA{0x99, 0x99, 0x99, 0xff}\n   }\n}\n```", "```go\nfunc (w *scaledImage) PaintBase(ctx *node.PaintBaseContext, origin image.Point) error {\n\n   ...\n\n   checkers.resize(width, height)\n   draw.Draw(ctx.Dst, wRect, checkers, checkers.Bounds().Min, draw.Src)\n   draw.Draw(ctx.Dst, wRect, scaled, offset, draw.Over)\n   return nil\n}\n```", "```go\nimport (\n   _ \"image/jpeg\"\n   _ \"image/png\"\n   _ \"image/gif\"\n)\n\nvar names []string\n\nfunc getImageList(dir string) []string {\n   files, _ := ioutil.ReadDir(dir)\n\n   for _, file := range files {\n      if file.IsDir() {\n         continue\n      }\n\n      ext := strings.ToLower(filepath.Ext(file.Name()))\n      if ext == \".jpg\" || ext == \".jpeg\" || ext == \".png\" || ext == \".gif\" {\n         names = append(names, file.Name())\n      }\n   }\n\n   return names\n}\n```", "```go\nvar images []image.Image\n\nfunc makeList(dir string, files []string) node.Node {\n   parent := makeCell(-1, filepath.Base(dir), nil)\n   children := []node.Node{parent}\n\n   for idx, name := range files {\n      img := loadImage(path.Join(dir, name))\n      cell := makeCell(idx, name, img)\n      children = append(children, cell)\n      images = append(images, img)\n   }\n\n   return widget.NewFlow(widget.AxisVertical, children...)\n}\n```", "```go\nfunc (w *scaledImage) SetImage(img image.Image) {\n   w.Src = img\n   w.Mark(node.MarkNeedsPaintBase)\n}\n```", "```go\nvar view *scaledImage\n\nfunc chooseImage(idx int) {\n   view.SetImage(images[idx])\n}\n\n```", "```go\nvar name *widget.Label\nvar index = 0\n\nfunc chooseImage(idx int) {\n   index = idx\n   view.SetImage(images[idx])\n\n   name.Text = names[idx]\n   name.Mark(node.MarkNeedsMeasureLayout)\n   name.Mark(node.MarkNeedsPaintBase)\n}\n```", "```go\nfunc changeImage(offset int) {\n   newidx := index + offset\n   if newidx < 0 || newidx >= len(images) {\n      return\n   }\n\n   chooseImage(newidx)\n}\n\nfunc previousImage() {\n   changeImage(-1)\n}\n\nfunc nextImage() {\n   changeImage(1)\n}\n```", "```go\nfunc main() {\n   dir, _ := os.Getwd()\n\n   flag.Usage = func() {\n      fmt.Println(\"goimages takes a single, optional, directory parameter\")\n   }\n   flag.Parse()\n\n   if len(flag.Args()) > 1 {\n      flag.Usage()\n      os.Exit(2)\n   } else if len(flag.Args()) == 1 {\n      dir = flag.Args()[0]\n\n      if _, err := ioutil.ReadDir(dir); os.IsNotExist(err) {\n         fmt.Println(\"Directory\", dir, \"does not exist or could not be read\")\n         os.Exit(1)\n      }\n   }\n   loadUI(dir)\n}\n```", "```go\ntype asyncImage struct {\n   path     string\n   img      image.Image\n   callback func(image.Image)\n}\n\nfunc (a *asyncImage) load() {\n   reader, err := os.Open(a.path)\n   if err != nil {\n      log.Fatal(err)\n   }\n   defer reader.Close()\n\n   a.img, _, err = image.Decode(reader)\n   if err != nil {\n      log.Fatal(err)\n   }\n\n   a.callback(a.img)\n}\n\nfunc newAsyncImage(path string, loaded func(image.Image)) *asyncImage {\n   img := &asyncImage{path: path, callback:loaded}\n   go img.load()\n\n   return img\n}\n```", "```go\n   cell := makeCell(idx, name)\n   i := idx\n   img := newAsyncImage(path.Join(dir, name), func(img image.Image) {\n      cell.icon.SetImage(img)\n      if i == index {\n         view.SetImage(img)\n      }\n   })\n```", "```go\nfunc chooseImage(idx int, img image.Image) {\n   ...\n\n   name.Mark(node.MarkNeedsPaintBase)\n   refresh(name)\n}\n\nfunc (w *scaledImage) SetImage(img image.Image) {\n   w.Src = img\n   w.Mark(node.MarkNeedsPaintBase)\n\n   refresh(w)\n}\n\nfunc refresh(_ node.Node) {\n   // Ideally we should refresh but this requires a reference to the window\n   // win.Send(paint.Event{})\n}\n```"]