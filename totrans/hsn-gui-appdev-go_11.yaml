- en: Shiny - Experimental Go GUI API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shiny is an experimental GUI library designed from scratch and written purely
    in Go. It was created to explore what's possible when building a cross-platform
    GUI for the Go language. It is not an official GUI toolkit for Go (though it was
    created by developers at Google) but provides a solid basis for graphical applications
    on most supported Go platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter explores how to use the Shiny project to build cross-platform
    graphical applications without the need for C libraries or pre-installed dependencies.
    The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The design principles of the Shiny project and its widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the toolkit is built to support multiple platforms without external drivers
    or native libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a basic graphical application that can easily cross-compile to different
    systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a a complete application using Shiny
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you should be well-versed in this experimental new
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Background and the vision for Shiny
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Shiny project was created in an effort to understand how a graphical application
    toolkit could be created to be in keeping with the Go idiom. Therefore, it is
    important that its API and methodologies should match the Go language semantics
    and standard library, its dependencies should be only pure Go libraries or existing
    system routines, and it should provide a modern approach to developing an application
    GUI. Much of this is only possible if you start from scratch, as you can tell
    from the toolkit bindings we saw in [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits
    Using Existing Widgets* of this book. It lives in the `golang.org/x/exp/shiny`
    repository—an experimental extension to the Go libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The project was started as an investigation by Nigel Tao, a Go developer who
    had been working on `golang.org/x/mobile` (on which Shiny depends), as he wanted
    to see desktop applications supported by a new API. After substantial development,
    it was proposed that this be added as an experimental project within the [golang.org](http://www.golang.org/) repositories,
    which was accepted in 2015\. It is expected that, at some future point, the commonality
    between `golang.org/x/mobile` and `golang.org/x/exp/shiny` will be captured in
    a separate project, leaving the mobile and desktop specific portions in their
    respective projects.
  prefs: []
  type: TYPE_NORMAL
- en: The project's development has slowed in recent years but it remains a strong
    foundation for graphical applications to be built upon. Whether the project will
    see a resurgence or instead become the base upon which another is built is unclear
    at this time. Either way, it is an excellent low-level graphical API for Go and
    so we will look into the details of it and start to build a sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Design and supported platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Shiny project has been designed to ensure good separation between the widget
    code and the lower-level rendering code that widgets utilize. It is also built
    with the understanding that graphical drivers may be useful on more than a single
    platform and could potentially be changed or added to over time.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Shiny API is split into two layers, a lower layer that handles graphical
    buffers and rendering, and a higher layer where the widget and layout code is
    located. Each layer has clear responsibilities and their separation helps to maintain
    a clean API.
  prefs: []
  type: TYPE_NORMAL
- en: Lower layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The lower layer of the Shiny API is responsible for creating a render context
    for each platform supported. It is also responsible for handling input from keyboard
    and other peripheral devices. The main concepts of the graphical presentation
    are **Buffer**s, **Texture**s, and **Window**s:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer:** A buffer refers to an array of pixel data in memory. This could
    be a loaded image, a canvas for drawing, or any other graphical data that needs
    to be presented within an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Texture:** A texture is a handle to a snapshot of graphical state that''s
    ready to be rendered. It will not be accessible to the application. A texture
    may be rendered immediately (such as the current widget state) or stored and rendered
    many times in the future (such as an image).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Window:** A window is the location of an application''s graphical output.
    Textures are rendered to the window after certain transformations (determined
    by the driver) have been applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In normal application flow, the code of a graphical user interface will update
    a widget or layout state—resulting in a buffer's contents being updated. This
    buffer will then be uploaded to a texture in preparation for being drawn by the
    driver. The texture will then be rendered to the application window, potentially
    through transformations within the driver or the underlying platform's graphical
    implementation. If you are familiar with how OpenGL works, then the processes
    will seem quite familiar—this is no coincidence, as the approach is well-proven
    and one of the Shiny drivers uses the OpenGL APIs. For most application developers,
    the existence of textures will not be visible or important, but it can help to
    consider the process when optimizing your code.
  prefs: []
  type: TYPE_NORMAL
- en: The driver also handles user interactions, encapsulating them as `mouse.Event`
    and `key.Event` structures (defined in `x/mobile/event`). A `widget.Widget` can
    register to receive these events, using a filter that will determine which are
    relevant to that object, and mark them as handled. Alternatively, an application
    could access the event queue directly from `screen.Window`, where calling `NextEvent()`
    would wait until another event occurs. An application that takes this approach
    should be aware of the vast number of events that can be generated by Shiny (see
    *Example* in the *Getting started* section later in this chapter). When working
    with events, the Shiny project includes a powerful gesture package, that enables
    you to filter on `gesture.Event`, which describes more intent-based information
    than lower-level data. Helpful event types include `gesture.TypeDrag`, `gesture.TypeIsLongPress`,
    and `gesture.TypeIsDoublePress` (the event type is accessible through `Event.Type` on
    gesture events).
  prefs: []
  type: TYPE_NORMAL
- en: Higher layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Higher-layer APIs are focused on widgets and the overall layout and behavior
    of a graphical user interface. Working at this level, a developer wouldn't expect
    to be dealing with buffers and events but with high-level concepts such as buttons,
    text areas, and layouts. The types and functions defined at this layer (within
    the `widget` package) are designed to be easy to understand from a high level
    and includes graphical user interface concepts that will be familiar to most developers.
  prefs: []
  type: TYPE_NORMAL
- en: The Shiny widgets (detailed further in the *Widgets and material design* section
    later in this chapter) are all written in pure Go and encapsulate any widget logic
    (such as input handling), as well as rendering (by implementing the `node.PaintBase()`
    or `node.Paint()` functions). This allows the user interface code to remain completely
    detached from the drivers for better testing and to promote consistency across
    all supported operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Supported platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Shiny project currently supports Windows, macOS, Linux, DragonFly BSD, and
    OpenBSD. Other BSD distributions or Unix systems that use X11 (see the following
    discussion of drivers) may work but are not officially supported at this time.
  prefs: []
  type: TYPE_NORMAL
- en: The code required to support an operating system is relatively lightweight if
    one of the existing drivers is able to run. For example, if OpenGL is installed
    on a not-yet-supported platform, then you may be able to add the operating system-specific
    code to wire it in. In this situation, a platform-specific Go file would need
    to open a window and handle any platform-specific input or device setup for the
    OpenGL window.
  prefs: []
  type: TYPE_NORMAL
- en: On a platform where an existing driver does not currently work, it would be
    a tremendous amount of work to add support. As well as the window- and user-interaction
    code, it would be necessary to write the graphical renderer and presentation layer
    from scratch or provide an API bridge to an existing one. Such an implementation
    would have to handle the complete set of draw primitives and transformations utilized
    by the main Shiny code (such a list is outside the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: Drivers currently included
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Shiny has three complete drivers at the time of writing (**win**, **gl,** and
    **x11)** and each of these drivers must implement all of the input and output
    capabilities of the Shiny toolkit. The output portion of a driver is required
    to define a suitable `screen.Texture` provider so that buffers can be uploaded
    ready for rendering and to handle the rendering process. On the input side, a
    driver must handle mouse and keyboard events and translate them into `golang.org/x/mobile` types
    that can then be filtered by the Shiny event-handling code. The details of each
    driver are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gl:** The most commonly used driver, built on top of the cross-platform OpenGL,
    it makes use of this standard API for graphical display. Many operating systems
    provide this functionality, though it should be noted that this may not be supported
    on all devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**win:** The win driver is built specifically for the Microsoft Windows operating
    system to work without the OpenGL APIs. Rendering is provided by the **Graphics
    Device Interface** (**GDI**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x11:** The X11 driver provides support for the standard graphical desktop
    platform on Linux and Unix. It communicates directly with the *XServer* and uses
    the **SHared Memory** (**SHM**) extension for communicating image data efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between these drivers, there is at least one render definition for all of the
    operating systems supported by the toolkits described earlier in this book, and
    potentially more. These details shouldn't be a concern day to day when programming
    with Shiny but it helps to understand possible extensions in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Shiny
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In keeping with the design of Shiny to not depend on any native libraries or
    system dependencies, there are no prerequisites to using it. So, we can jump straight
    into getting the library installed and see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing the Shiny library is as simple as installing the Go files from `golang.org/x/exp/shiny`
    and its `x/mobile` and `x/image` dependencies. As these are top-level projects,
    you may see a warning about no Go files—you can ignore this, as the APIs will
    be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ccc3970-43df-461b-8e14-43fd0ab5b9d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting x/exp/shiny will download the package contents
  prefs: []
  type: TYPE_NORMAL
- en: No extra libraries or system configuration are required.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start building an application, let''s load an example project to
    check that Shiny is installed and working correctly. The project provides various
    example projects—we will check the one called *basic*. Simply change to the `examples/basic`
    directory and run `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/338a4a6e-9938-4b01-86ce-e77f15bbc616.png)'
  prefs: []
  type: TYPE_IMG
- en: Launching the basic Shiny example
  prefs: []
  type: TYPE_NORMAL
- en: 'After launching, you should see the following window and (as illustrated in
    the preceding) the output of all of the events triggered by the application. The
    size of the window may vary depending on the operating system you are running,
    due to driver default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c33590d3-f78b-456f-b3f5-b19fe63fdf3c.png)'
  prefs: []
  type: TYPE_IMG
- en: A rather unconventional example application
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this example application is unlike the other toolkits we've
    explored. This represents the main focus of the Shiny project as primarily a technology
    demo.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a project that aims to be written purely in Go, one of its goals is to be
    just as easy to cross-compile for different platforms as it is to build for the
    current operating system. In cases where the Shiny driver for the operating system
    is pure Go (as is currently the case for **windows** and **x11**, used by Linux
    and BSD), compiling for a specific operating system is as simple as using the
    `GOOS` parameter, as described in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml),
    *Go to the Rescue!*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72688dd8-3f79-4fa7-bd44-baf54fd17b27.png)'
  prefs: []
  type: TYPE_IMG
- en: Compiling Linux and Windows binaries from a Linux Command Prompt
  prefs: []
  type: TYPE_NORMAL
- en: The **gl** driver that provides hardware-accelerated rendering (used by macOS
    and Linux) depends on a system API that is not currently available without CGO
    and so is more challenging to cross-compile. Through the toolkit design, it's
    possible to use the **x11** driver for a Unix target platform if CGO is not available—so
    Linux or BSD can still be cross compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Note that cross-compiling a Shiny application for Linux will result in an application
    that does not have graphical acceleration enabled. This can be overcome by using
    `CGO_ENABLED=1` and installing various libraries but it is easily forgotten, so
    it's advisable to set up a dedicated Linux build environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that, from macOS, we can cross-compile both Linux and Windows executables
    by simply setting the appropriate `GOOS` variable as would be expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13bce09b-80e8-4ed2-ae16-7a3d2f7346f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Cross-compiling for macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Windows and Linux (and some BSD flavours), all cross-compiling completes
    without CGO, therefore, we only need to look at macOS as a special case. To cross-compile
    successfully for macOS, we must add `CGO_ENABLED=1` to our build, which will then
    look for the required system libraries. Clearly, these are not normally available
    and so we must set up our development environment to provide the required APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure for setting up the clang binary and required API bundles for macOS
    cross-compiling is a complicated process, but if you worked through [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml),
    *andlabs UI - Cross-platform Native UIs*, this will already be set up. If you've
    jumped straight to this chapter, then you may need to follow the steps in the
    [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler Setup, *under
    *Cross-compiling for macOS with cgo*. Once that's complete, you should have a
    new compiler available named `o32-clang`, which is able to link to macOS Foundation
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the application, we now set up the `GOOS` and `CGO_ENABLED` flags
    as before, but also specify the compiler to use through an extra `CC` environment
    variable, setting it to `o32-clang`. With that configuration complete, we can
    build a macOS Shiny application from our Linux Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1a1b415-fd9b-4629-9ff5-19c88243f0e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a macOS application from a Linux terminal
  prefs: []
  type: TYPE_NORMAL
- en: Applications built in this manner will have full OpenGL acceleration as though
    they were built directly on a macOS computer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen all of the details for building with Shiny, let's explore
    how these applications are designed.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets and material design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start a simple application, we need to understand more about Shiny
    widgets and how their visual design impacts development. The other toolkits that
    we've looked at didn't need this understanding to start using the API, but the
    experimental status of the higher-level APIs in Shiny means that even a *hello
    world* application requires some understanding of how the toolkit functions.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the details of the widgets that Shiny provides and how to
    work with them, let's take a look at the design and iconography of the Shiny project.
    This design takes a different approach to the toolkits we've previously looked
    at in this book, but it should be familiar to any Android app developers or users
    of the Google product suite.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Material design, if you are not already familiar with the concept, can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '... an adaptable system of guidelines, components, and tools that support the
    best practices of user interface design"'
  prefs: []
  type: TYPE_NORMAL
- en: -[material.io](https://material.io/)
  prefs: []
  type: TYPE_NORMAL
- en: The design principles will be familiar to anyone with an Android smartphone
    or tablet and are somewhat similar to the user interface design adopted by Microsoft
    for recent releases of the Windows operating system, which support tablets and
    touch screen user input. The approach aims to help developers quickly create beautiful
    applications and to ease communication between developers and designers. The *design
    language* also helps to promote a consistent user experience in a world where
    applications are trying to stand out with their own brand design.
  prefs: []
  type: TYPE_NORMAL
- en: 'An application that utilizes the material design principles will not look identical
    to all of the others, but will have sufficient similarities that a user should
    have no trouble understanding how it works. Colors, layouts, and navigation can
    be different from one interface to another, as long as they follow the guidelines
    set out. Material design includes some standard color palettes and advice for
    creating custom ones for your needs. Layouts and navigation widgets similarly
    have standard implementations, but these can be extended and used to suit the
    context. These standard widgets are called *material components* and have been
    created for Android, iOS, Flutter, and the web—Shiny is one potential approach
    to bringing them to desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/626d86cb-3063-4955-99e8-4c510d3adf3f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An Android app demonstrating material design. Image copyright: Google.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many tools online to help you learn about and adopt material design
    principles. They can be found on the material design website at [material.io](https://material.io/).
    Let's explore a few of the details that are at the core of the Shiny API.
  prefs: []
  type: TYPE_NORMAL
- en: Icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The material design project has created a standard set of icons that are freely
    available to use in any application. Integrating these clear, concise icons into
    your user interface adds simple-to-understand hints that are consistent with other
    applications and can alleviate the need for too much text in the resulting user
    interface. Shiny bundles the most commonly used icons in the `materialdesign/icons` package
    and they can be referenced by name through the API. To see the list of names and
    the icons, you can run the Shiny *IconGallery* example (pictured in the following
    screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9af972e-e8e9-4075-98d2-05e57fe1fa52.png)'
  prefs: []
  type: TYPE_IMG
- en: Shiny includes the material icon set as vector graphics
  prefs: []
  type: TYPE_NORMAL
- en: The icons can be painted within a `node.PaintBase()` method by creating an `iconvg.Rasterizer` instance
    for `node.PaintBaseContext` and calling `iconvg.Decode()` for the icon reference
    (these icons are stored in the compact IconVG format). Examples of this code in
    action can be found later in the chapter (or in the Shiny example code).
  prefs: []
  type: TYPE_NORMAL
- en: Themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the central concepts in material design is the color palette—while it
    does not mandate the colors that an application can use, it has very clear rules
    about color choice and combinations that work. Designers are encouraged to pick
    a primary color from the standard palettes (used in most user interface elements)
    and a secondary color (for highlights and accents) that complement each other.
    For each color, there are standard light and dark variants, which can add depth
    to an application interface. You can explore these through the online color tool
    at [material.io/tools/color](https://material.io/tools/color).
  prefs: []
  type: TYPE_NORMAL
- en: 'The palette that Shiny uses follows this approach; the available colors are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`theme.Foreground`: The standard foreground color for the theme—used for text
    and icons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`theme.Background`: The standard background color for containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`theme.Neutral`: A background color for smaller areas that should be distinct
    from the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`theme.Light`: A lighter version of the neutral color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`theme.Dark`: A darker version of the neutral color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`theme.Accent`: The main color from the secondary palette, used for highlighting
    key elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colors in the Shiny API are passed using the `theme.Color` type instead of the
    golang `color.Color` type. This ensures that the colors used are from the theme
    palette. From a theme color type, you can call the `Color()` function to get a
    standard color type or the `Uniform()` function to get `image.Uniform` which is
    used to draw filled rectangles in a `Paint()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Applications can choose to use the built-in theme (`theme.Default`) or to provide
    their own. Any type that implements `theme.Theme` can be used in the rendering
    of a Shiny GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a project that has focused more on the capabilities of cross-platform graphical
    rendering on the lower layer, Shiny toolkit does not come with many standard widgets.
    A lot of work has gone in to setting up the building blocks so that applications
    can provide their own widgets, but if you are looking to use built-in types, the
    list provided by the `widget` package is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow:** This is a container that lays out its children along a horizontal
    or vertical axis (set in `Flow.Axis` or `NewFlow()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flex:** Actually, in a `flex` sub-package, this is a container that lays
    out its children according to the CSS flexbox algorithm. As with `widget.Flow`, the
    parameters for the layout are set on the `flex.Flex` container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image:** This widget renders a golang `image.Image` onscreen. Its dimensions
    are specified separately to the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Label:** This is a simple widget for displaying a line of text with a theme
    color (for example, `theme.Foreground`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Padder:** An invisible widget that contains a child widget and displays it
    with a specified amount of space around the horizontal or vertical dimensions (or
    both).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sheet:** A sheet provides the buffer on which all other widgets will draw.
    Any widgets that are not children of a Sheet may not be rendered. Multiple sheets
    are required if content should move independently, such as a scroll view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sizer:** A sizer is an invisible widget that contains a child widget but
    overrides its size. This can be used to specify a different natural size than
    the default for an existing widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Space:** An invisible widget that takes up available space. Placed between
    two widgets, they will become left- and right- aligned, or by placing  `widget.Space` either
    side of a widget, it will become centered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text:** A multi-line text widget for displaying more complicated text than `widget.Label`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform:** This is a simple widget that draws a rectangle of a solid color
    from the theme palette (for example, `theme.Background`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also an advanced widget named `glwidget.GL`, which renders a **OpenGL
    for embedded systems** (**GLES**) `framebuffer` into a Shiny application. This
    is not commonly required for traditional applications but it's a great additional
    feature to support.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the length of the preceding list, you'll probably notice that it does
    not provide all the widgets we have used in other chapters. For this reason, we
    will build a different sample application. This time, one that's a better fit
    for the toolkit's capabilities. Before that, however, let's return to *getting
    started* and creating a hello world application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started continued
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have explored a little of how Shiny is designed and its current
    constraints, we can implement our first graphical application and see it run.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with writing a simple *hello world* window, as in the previous
    chapters. This code is a little more complicated than in previous examples due
    to the low-level nature of the toolkit at this time. As well as defining the window,
    label, and button, we will need to set up a background layer and measure the minimum
    size for the containing window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see the flow layout (`widget.NewFlow()`), a background
    layer (`widget.NewSheet()`), and the measurement initialization (`w.Measure()`).
    With Shiny, `widget.Sheet` is required underneath any widgets so they can paint
    correctly. On a simple application, a single sheet should be sufficient, but on
    a more complex user interface where items move independently (that is, scrolling),
    additional sheets will probably be required.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed, the preceding code has two issues, both relating to
    the `Quit` button. Firstly, the `func()` that''s called does not actually exit
    the application. This is a current limitation of the Shiny lifecycle code. It
    can be worked around with a custom lifecycle, but this is not recommended due
    to the large amount of code that would be required. Secondly, you may notice that
    `newButton()` is a local function and not part of the `widget` package. One of
    the widgets currently missing from the toolkit list is a standard button, therefore,
    we must define one ourselves. This can be done by adding the code described as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the custom node; it must begin by inheriting from `node.LeafEmbed`.
    We add fields for the text label it''ll contain and the `onClick` function that
    should be called when it is tapped. We should also add a convenience method to
    construct the button. This needs to set the `node.Embed.Wrapper` field, as that
    should never be `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To define a suitable area for the button to take up, we need to implement the
    `Measure()` function. This will update a cached size (`node.Embed.MeasuredSize`)
    that''s used for the interface layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To display content onscreen (this actually paints to an underlying `widget.Sheet`
    described earlier), we add a `PaintBase()` function. For our button, we will paint
    a `theme.Foreground` colored rectangle as a base and use the `theme.Background`
    color for the text (so our button stands out from other text). Note that, before
    actually painting, we remove the `node.MarkNeedsPaintBase` mark from the object
    so that it will not be redrawn on the next interface redraw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, a button needs a click handler. We can implement the `OnInputEvent()`
    function so that Shiny can send events to the button. Here, we check to see whether
    the event''s a `gesture.Event`, and if so, see that its type is `gesture.TypeTap`.
    If these conditions are met, and we have an `onClick` handler registered, then
    call `b.onClick()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the code required to fulfill a hello world GUI app with Shiny
    (the complete code is in this book's code repository). Let's now build and run
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Build and Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building our Shiny hello world app is simple as Shiny has no native dependencies—we
    can simply build or run the `hello.go` file directly. Additionally, as many platform
    drivers are written without CGo, we can easily cross-compile for those operating
    systems. The following screenshot illustrates building for Linux and then Windows
    with no additional setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d248088-92a3-45af-9ca2-8f358eaed9b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Building our hello app and running it with no CGo is easy
  prefs: []
  type: TYPE_NORMAL
- en: Note that building for macOS would require some additional setup, as its driver
    uses CGo (as described in the preceding *Cross-compiling* section of *Getting
    started*).
  prefs: []
  type: TYPE_NORMAL
- en: 'However you build or run the application, you should see a little window, something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65c0afec-005e-4362-aed7-0e114a55f93a.png)'
  prefs: []
  type: TYPE_IMG
- en: Hello world with Shiny
  prefs: []
  type: TYPE_NORMAL
- en: We could refine the visuals of our app, but instead, we will move on to a larger
    application to demonstrate the capabilities of Shiny.
  prefs: []
  type: TYPE_NORMAL
- en: Building a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore the capabilities of the Shiny toolkit, we will build another complete
    graphical application. As the development of Shiny has been focused on the lower
    layer of graphical APIs, an application such as GoMail would involve the creation
    of many custom widgets. Instead, we will look at a more graphically-oriented application—an
    image viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get an idea of how the image viewer should look, we will make a rough design
    that we can follow. The online tool Balsamiq ([balsamiq.com](https://balsamiq.com/))
    is a good way to rapidly create wireframes that will suit this purpose. Take a
    look at the following export. It includes a navigation bar along the top, a directory
    listing on the left, and a full-size image view on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5014e8c-d3b3-45c8-aee8-0be926181769.png)'
  prefs: []
  type: TYPE_IMG
- en: A mockup of the GoImages application using the Balsamiq tool
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this image has a far lower level of detail than the design tool we
    used in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk – Building
    Graphical Windows Applications* (back at the beginning of [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml),
    *Toolkits Using Existing Widgets*) for our GoMail design, but this is intentional.
    Each toolkit in [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits* of this book has a very different look, set by its theme definition
    and by using a rough design we can build an implementation using the best practice
    for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we will implement the layout. The easiest way to set this up
    for the application we designed is to use horizontal and vertical flow layouts.
    Before creating the layout, we should define those widgets that will be included.
    For now these are represented by the placeholders created in `makeBar()` and `makeList()`—each
    of which simply creates a label to show the purpose. We also want to ensure that
    the items are padded according to our design. To do this with Shiny, we use `widget.NewPadder()`
    and a defined unit, `padSize`. We also define a `spaceSize` used later for the
    central padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the image in our layout, we can use `widget.Image`, but first we need
    to load an image from the filesystem—a helper function, `loadImage()`, is defined
    to handle this for the application. When loading an image, don''t forget to import
    the appropriate decoder (in this case, `image/jpeg`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, we''re ready to implement the layout. The main method constructs
    the widget tree and creates `widget.Sheet` to manage their rendering. This is
    passed to `widget.RunWindow()` to show the contents and run the application. The
    main layout elements are `body` (a horizontal flow) and `container` (the vertical
    flow, containing the navigation and the body). Note how a `nil` child is passed
    to `widget.NewPadder()` between the file list and the image viewer to approximate
    widget spacing. You can also see that the child widget of  `sheet` is actually
    a `theme.Background` colored rectangle created using `widget.NewUniform()` – this
    helps to ensure that we have a consistent background color if any widgets leave
    part of their area unpainted. The container then fills the space by being the
    uniform''s child widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code should result in a window showing the following
    contents, which broadly matches the layout we designed before. As we progress
    through this chapter, we will add the content to each area and polish each part
    of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/209c4b68-1685-4721-9637-0de41329152b.png)'
  prefs: []
  type: TYPE_IMG
- en: The GoImages layout with the navigation bar and file list placeholders
  prefs: []
  type: TYPE_NORMAL
- en: Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the navigation bar in our design, a horizontal flow layout is the
    right tool for the job. We can use `widget.Spacer` to create the gaps between
    the buttons and the label and to ensure the filename is centered within the space
    available. A helper method, `expandSpace()`, is added to create a new spacer that
    will expand along the flow layout axis. We also define the `previousImage()` and
    `nextImage()` functions, which will execute when the buttons are pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With those functions defined, we can lay out the navigation bar. We define
    the `prev`, `next`, and `name` items and add them to a `widget.AxisHoriontal`
    flow container that includes `expandSpace()` elements to space the items. To create
    buttons, we are using the same `newButton()` function as earlier in this chapter
    (due to the Shiny widget API not having a standard button defined). We use `theme.Neutral` for
    the background container for this section and we set the whole bar to expand along
    the horizontal axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should update the navigation bar, as follows. As we''ve
    defined the buttons ourselves, they can be customized to use the border style
    if preferred (the full code listing is available in this book''s code repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17ab4070-c897-4feb-8dd4-ab2d1c06ecd7.png)'
  prefs: []
  type: TYPE_IMG
- en: The updated navigation bar with left- and right- aligned buttons
  prefs: []
  type: TYPE_NORMAL
- en: File list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Shiny does not define a list widget, we will construct one using another
    vertical flow container. Each item within this list will be a custom cell widget
    that displays an icon on the left with the filename text left-aligned in the remaining
    space. First, we will update our `makeList()` function to add some dummy data.
    Each item is a new cell, created using `makeCell()` (which is defined later).
    The items are laid out as a list using `widget.NewFlow()` on the vertical axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the first item in the list is the name of our directory, which
    needs a different icon. We can load a standard icon from the Shiny icon collection
    using the `iconvg` package, specifically, `iconvg.Rasterizer` and `iconvg.Decode()`.
    Using the following helper function, we can load the `icons.FileFolder` icon into
    an image so it can be drawn using the same functions as images we load from the
    filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of our layout code is the `makeCell()` function. In this case,
    it''s a simple wrapper around the creation of a `cell` widget. When this function
    is passed a `nil` icon, it will set up the directory icon using the helper above.
    When an icon is passed, then it creates an `onClick` function that will load the
    image in the main view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The details of our cell widget are very similar to the button we created earlier
    and so most of the code is omitted. The next excerpt shows its `PaintBase()` function,
    which draws the icon and text to screen. It calculates the ratio of an image so
    that it can be correctly painted within the cell. The text is then drawn like
    the button code, but with a space between it and the image we painted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, a simple `scaleImage()` function is also needed, which uses `draw.ApproxBiLinear`
    to resize the graphic to fit with reasonable performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All this code comes together to create a file listing with an image preview,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/417d4265-d111-43d9-853b-5ca4e8168127.png)'
  prefs: []
  type: TYPE_IMG
- en: The completed file list on the left with placeholder content
  prefs: []
  type: TYPE_NORMAL
- en: Image view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `widget.Image` type draws an image to the buffer at the same resolution
    as it was loaded (a pixel in the source image matches a pixel on screen). What
    we need to do for the image viewer is scale it to fit the available space. To
    do this, we create a new custom widget named `scaledImage`. The code is very similar
    to the Shiny image widget but with a more complicated `PaintBase()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function calculates `imgWidth` and `imgHeight` to fit within the current
    bounds of the widget and maintain the aspect ratio of the source image. It then
    scales the image using the `scaleImage()` helper function defined earlier, ready
    to paint at the correct resolution. Lastly, `offset` is calculated so that the
    image is centered within the available space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid a blank space being left by the preceding calculations, let''s add
    a checkered pattern typical in many other image applications. To make this possible,
    we create a custom image type named `checkerImage` that simply returns pixels
    from the `At()` function based on a regular checker pattern. As images are bounded,
    we need to add a `resize()` function so the image can expand to fill the space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To include the checker pattern, we simply need to update the end of the `PaintBase()`
    function of `scaledImage`. Before the image itself is drawn, we set the checker
    pattern to expand to the correct size and paint it onto the background. The checkers
    are drawn with the `draw.Src` mode and the image is then drawn over the top using
    the `draw.Over` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of this code in place, we have an updated application that correctly
    fills the layout we designed and scales and positions the placeholder image we
    have to fit within the available space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a08c0b1-bfd3-4f72-87cc-b15cb00e1d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: The interface updated to show images centered at the correct aspect ratio
  prefs: []
  type: TYPE_NORMAL
- en: That's the majority of our graphical code complete. Next, we will make the necessary
    additions to load real content from the local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a user interface up and running, we need to load some real
    data and display it. We start this task by obtaining a list of image files for
    the requested directory and updating the user interface to list those instead
    of the placeholder information. Remember, at this stage, to add the extra image
    imports so we can decode all of the images that we will then filter for in a new
    `getImageList()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The listing shows a fairly simple algorithm for checking each item in a directory
    and adding it to a `names` list if the filename looks like a image file that we
    support. Simple filename extension checking should be sufficient for our purposes
    here. We add these filenames to a global list for later use in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a list of supported files, we can update the existing `makeList()`
    function. The new version iterates over the `files` list and adds a new cell for
    each item. The `makeCell()` function does not need any additional work to use
    this new content, but we do pass the array index for use later in the button handlers.
    We also save the `images` loaded in memory for display when selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the main image displayed, we need to add a new function to our `scaledImage`
    widget. This new `SetImage()` function sets the image reference to be displayed
    and marks the widget for painting. Updating the `node.MarkNeedsPaintBase` mark
    means that the widget will be repainted next time there is a graphical paint event
    (we will discuss paint events in more detail shortly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To make use of this new function, we update our `chooseImage()` code to set
    the image selected. We also need to store a reference to the `scaledImage` widget
    created to call the function on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the image is changed, we also need to set the correct filename to the
    label above the image. To do so, we will add a reference to the `widget.Label`
    object and set its `Text` field. After updating this property, we also need to
    set the `node.MarkNeedsMeasureLayout` flag, as the text may have a different size
    to the previous content. We use the `names` array and the index variable passed
    into `chooseImage()` to look up the content. This could also be accomplished by
    creating a list of items using a new object type that stores the image, name,
    and metadata in a single list, but the approach of multiple indexed lists is easier
    to explain in smaller code samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to fill in the empty `previousImage()` and `nextImage()` functions
    that the header buttons call. A simple helper function called `changeImage()`
    is added to handle image switching based on an offset from the current image (either
    `1` or `-1`). Each button callback calls this with the appropriate offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, the `main()` function can include a call to `chooseImage(0)` to
    load the first image found in the directory. Of course, you should check that
    there is at least one image before you do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last change is to determine which directory to show images for when the
    application loads. The previous `main()` function is renamed `loadUI()` (which
    takes a directory parameter to pass into `getImageList()` and `makeList()`). A
    new main function is created that parses command-line arguments to allow the user
    to specify a directory. The following code will print out a helpful usage hint
    if some unexpected parameters are passed (or if `--help` is specified) and if
    no parameters are found, it will show the current working directory (using `os.Getwd()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With these modifications, we''ve created a complete image viewer application
    that displays thumbnails for a whole directory of images and one large image view.
    By tapping on items in the list, or using the Next and Previous buttons, you can
    switch between the images available. While this works, it can be quite slow to
    load in a large directory. Next, we''ll explore how this can be improved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e068050-5e41-4272-968d-64f3ec23dba9.png)'
  prefs: []
  type: TYPE_IMG
- en: The completed GoImages application running on macOS
  prefs: []
  type: TYPE_NORMAL
- en: Background processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image processing, even just loading the images to be viewed, is a CPU-intensive
    task, so if we open a directory with a lot of pictures, the application will be
    very slow to load. We can fix this delay by moving our image loading to work in
    the background while we load the user interface. Thankfully, creating new threads
    for asynchronous processing is very simple with Go (as we explored in [Chapter
    3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the Rescue!*), but we also
    need to ensure that the user interface is updated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delay the loading of images until there is processing power available, we
    can replace uses of `loadImage()` with a replacement `asyncImage` type that will
    handle the heavy lifting. The main image loading code will be moved into a private `load()`
    function that''s called from `newAsyncImage()` using `go img.load()`, therefore
    starting it in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With the definition of an asynchronous image loader, we can replace the use
    of `image.Image` with `asyncImage`. The important thing to remember is that the
    image in the `img` field will be `nil` until the `load()` function has completed.
    Be sure that any code using images checks for `nil` data before processing. The
    first function we update is `makeCell()` so that it no longer accepts an image
    parameter. Instead, we pass a `loaded` callback function to set the image once
    it is loaded. We update `makeList()` to replace the cell creation code with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code will ensure that thumbnails are shown once the image has loaded but
    also that, if the image is the current selection, it updates the main image `view`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application at this point, you will notice that some images
    are loaded while others may not be. This is due to us not having signaled to Shiny
    that a re-paint is necessary. The marks that were applied to the widgets to force
    them to be repainted do not actually trigger the painting of the interface; it
    simply marks them as needing to be painted the next time a re-paint is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/353de3f4-1d2d-4602-b60e-6f1e9ae39bb6.png)'
  prefs: []
  type: TYPE_IMG
- en: A partial rendering when loading images in the background
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no easy way to signal Shiny to refresh the user interface, so we will
    make a `refresh()` function for convenience. This should be called when the text
    for a filename is updated and when a different (or lazy-loaded) image is set on
    the `scaledImage` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, at this point, we can't proceed further without a significant
    amount of extra code. This is a limitation of the recommended `widget.RunWindow()`
    function that we used to load our interface. The window reference that we would
    need to send the paint event to is not available outside the Shiny package. To
    resolve this issue, it would be necessary to use the `NewWindow()` function on
    the `screen.Screen` instance, passed into the `driver.Main()` function—but to
    do so would mean completely re-implementing the event loop as well, which is a
    lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we didn't notice the issue when setting the main image earlier is
    because, when the application is receiving user events (mouse moves and so on),
    its event loop runs. Each time an iteration of the loop completes, the user interface
    is repainted. Sending the `paint.Event` previously illustrated would also cause
    this to happen. Therefore, it follows that the interface will update after background
    image loading if the user is currently interacting with the GUI (even just moving
    the mouse over it). It's left as an exercise for the reader to implement the replacement
    lifecycle to resolve this issue, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at our first modern widget toolkit, Shiny, which
    has been designed specifically for the Go language. We explored its design principles
    and how it manages to support cross-platform graphical application development
    without the need for external dependencies. We also saw that its design makes
    use of powerful features of the Go language, such as concurrency and the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The graphical design principles behind Shiny provide a new interpretation of
    the desktop application GUI, which will be familiar to users of the Android mobile
    operating system (due to them using the same material design approach). While
    exploring its graphical capabilities, we saw that the widget set is currently
    in its early stages and so isn't yet ready to support the GoMail application we've
    been creating in previous chapters. To explore the capabilities of the Shiny toolkit,
    we instead developed an image viewer application, which is better suited to the
    current feature set. We saw how powerful the rendering capabilities of Shiny are,
    but also that there are a few challenges around creating a rich application user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at another toolkit that takes a modern approach
    to the widget toolkit. Nuklear also helps developers to create cross-platform
    graphical user interfaces but does so from an embedded user interface approach.
    We'll explore the Go bindings for this library, named `nk`.
  prefs: []
  type: TYPE_NORMAL
