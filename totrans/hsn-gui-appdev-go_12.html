<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">nk - Nuklear for Go</h1>
                </header>
            
            <article>
                
<p>Nuklear is a lightweight widget library that focuses purely on the graphical interface. It provides a rich widget toolkit that renders identically across all supported platforms. Originally designed for embedded systems, <span>it avoids the complications of application life cycles and windows and managing user interaction to keep its API focused and completely platform-independent. </span>Its implementation has no dependencies and achieves this by avoiding a platform-specific render library or operating system drivers.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>The design and purpose of the Nuklear project</li>
<li>Getting set up with Nuklear and the Go bindings, nk</li>
<li><span>How to create a render context and use the toolkit widgets</span></li>
<li><span>Building a complete application using nk</span></li>
</ul>
<p>By the end of this chapter, you'll have created an nk-based application using an OpenGL backend that will work across all mainstream desktop operating systems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background and design of Nuklear</h1>
                </header>
            
            <article>
                
<p>Nuklear was designed to build graphical user interfaces for embedded applications and games. It aims to be lightweight and completely platform agnostic. It manages this by leaving the window management, operating system-specific methods, and even the render driver to separate modules or the applications that use the library. Many of these features are provided by add-on modules; due to Nuklear's popularity, there are many render drivers to choose from (some are operating system-specific and others work across multiple platforms). Nuklear has been made available within the public domain, which also makes it an attractive option for embedding within commercial software.</p>
<p class="mce-root"/>
<p>Nuklear provides many widgets, layouts, and features for creating rich application GUIs that can also be skinned to suit the application design. The following screenshot is an example of the standard interface design: more can be found in the gallery section of the project website at <a href="https://github.com/vurtun/nuklear#gallery">https://github.com/vurtun/nuklear#gallery</a>:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/10efe27e-4836-49a2-bea3-f559b6c40780.png" width="1125" height="800"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">A screenshot of Nuklear widgets from the project website (Copyright: Micha Mettke)</div>
<p>Alongside the differences that the Nuklear design has to other toolkits we've explored, there's a larger distinction—Nuklear is an <em>immediate mode</em> GUI toolkit. In comparison, the other toolkits we've worked with in this book have all been <em>retained mode</em> user interfaces. With a retained mode API, the developer describes the application GUI by creating objects such as buttons and input boxes, arranging them in layouts, and then the toolkit will draw these features to screen. When an event occurs, the toolkit will change the state of an item and the resulting graphical changes will be reflected onscreen, optionally sending the changes to the application code.</p>
<p class="mce-root"/>
<p>When using an immediate mode library, there's no state retained. The application developer doesn't create buttons and widgets for later use; instead, these widgets are defined during the render process purely for the next graphical update. At a glance, this may seem inefficient but it's actually a very good match for how graphical render pipelines function and so can be far more efficient. It's also a less memory-intensive process as there's no additional structure in memory representing the whole application GUI. The main impact of this decision, as we'll see later, is how the code that creates a GUI is laid out and how events are handled. Rather than try and describe this further, you can see it in action later in this chapter (in the <em>Code</em> section of <em>Getting started with nk</em>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rendering and platform support</h1>
                </header>
            
            <article>
                
<p>The core of the Nuklear library's flexibility is its modular design. The library doesn't render to screen nor does it manage user input; such functionality is provided by modules that accompany the library. An application will typically utilize the core Nuklear library for widgets and layout as well as one of its render modules to control the opening of windows, rendering, and handling user input.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rendering modules</h1>
                </header>
            
            <article>
                
<p>The Nuklear project includes many rendering modules that provide support for various different environments or operating systems. At the time of writing, you can choose from the following backends:</p>
<ul>
<li>Windows:
<ul>
<li><strong><span>Graphics Device Interface </span></strong><span>(<strong>GDI</strong>)</span></li>
<li><span>GDI+</span></li>
<li><span><strong>Direct3D </strong>(<strong>D3D</strong>)</span></li>
</ul>
</li>
<li><span>Linux or Unix:</span>
<ul>
<li><span>X11</span></li>
<li><span>X11 OpenGL</span></li>
</ul>
</li>
<li><span>Games development:</span>
<ul>
<li><span>Allegro</span></li>
</ul>
</li>
<li><span>Cross-platform development:</span>
<ul>
<li><span><strong>Simple DirectMedia Layer </strong>(<strong>SDL</strong>)</span></li>
<li><span><strong>Simple and Fast Multimedia Library </strong></span>(<strong>SFML</strong>)</li>
<li><strong><span>Graphics Library Framework </span></strong>(<strong>GLFW</strong><span>)</span></li>
</ul>
</li>
</ul>
<p>Some of the renderers are 3D accelerated and others aren't, some focus on embedded and low power devices, others for desktop or smart phone type devices. As the GLFW module supports most desktop operating systems (and some smart phones), we'll use this module for the following chapter. If you choose to use a different module, then the application life cycle code should be adapted, but the nk code we'll explore remains the same.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Supported platforms</h1>
                </header>
            
            <article>
                
<p>With such a wide range of renderers available for the toolkit, Nuklear offers exceptional coverage for various different operating systems. With support available for <span>Windows, Linux, macOS, BSD, iPhone, and Android, it offers better support for multiple platforms than other libraries we've explored. By selecting the cross-platform GLFW Nuklear module, we've reduced the possible number of platforms slightly but it'll still support </span>Windows, macOS, and Linux desktop applications as well as Android for mobile applications.</p>
<p>The GLFW library has Go bindings that work alongside the OpenGL Go bindings (both are by the same authors). For most platforms, they don't rely on any external packages or libraries being installed. This is a huge benefit to getting up and running fast with nk, as we don't need to install additional packages or configure our development environment. So, let's get started.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started with nk</h1>
                </header>
            
            <article>
                
<p>To use GLFW and Go-GL, we'll need to link to some C APIs; however, these aren't (on most systems) external libraries. The fact that the only native dependency is the OpenGL native library (which is typically part of the operating system), and any intermediate libraries are embedded within the Go projects, means that all we need to prepare is CGo.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p>As the renderer we'll use for nk requires access to native C APIs, we'll need CGo to be correctly functioning for our applications to build. On most platforms, this simply means installing a compatible C compiler. This is only a development dependency and there's no installation required for the users of applications that we build with nk (other than an OpenGL compatible system). If you've worked through previous chapters of this book, then you probably have this set up already. If not, or you're unsure, then follow the steps in the <a href="a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml">Appendix</a>, <em>Installation Details</em>, in the <em>Setting up CGo</em> section.</p>
<p>Some platforms will require additional development files to be installed for the operating system-specific portions of the code to compile correctly. macOS and Windows developers can skip this section as the development environment for CGo provides all that's required. Linux or Android developers may require additional steps, as follows.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linux</h1>
                </header>
            
            <article>
                
<p>To use nk on Linux, we need to ensure some additional development headers are installed. Due to the GLFW dependency on Xorg for window management and input handling, we'll need to be able to compile against its libraries. If your distribution packages development headers separately to the library, you'll need to ensure that they're installed for compilation to succeed. The required package is called <kbd>xorg-dev</kbd> on Debian or Ubuntu, <kbd>xorg-server-devel</kbd> for Arch Linux, and <span><kbd>xorg-x11-server-devel</kbd> on Fedora or CentOS.</span></p>
<p>Therefore, one of the following should correctly install the development dependencies:</p>
<ul>
<li>For Debian or Ubuntu, use this:<br/>
<kbd>sudo apt-get install xorg-dev</kbd></li>
<li>For Arch Linux (this will probably already be installed), use the following:<br/>
<kbd>sudo pacman -S xorg-server-devel</kbd></li>
<li>For Fedora or CentOS, use this:<br/>
<kbd>sudo yum install xorg-x11-server-devel</kbd></li>
</ul>
<p>If the <kbd>sudo</kbd> command can't be found, then try <kbd>su -c</kbd> instead. Once this library is installed, you should be able to follow the setup steps in the next section and run an nk example application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">macOS and Windows</h1>
                </header>
            
            <article>
                
<p>Once you have Go and CGo set up on your computer, there are no additional prerequisites so you can jump to the following <em>Setup</em> section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Android</h1>
                </header>
            
            <article>
                
<p>To build an Android app using nk, there are some additional steps required. Development of mobile apps is out of scope for this book but, for the curious, these steps are included to get you started. First, you must have the Android <strong>Software<span> Development Kit </span></strong>(<strong><span>SDK</span></strong>) and <strong><span>Native Development Kit </span></strong>(<strong><span>NDK </span></strong>) installed. The easiest way may be to install Android Studio (available from <a href="https://developer.android.com/studio/">https://developer.android.com/studio/</a>) and use the built-in SDK Manager (under <span class="packt_screen">SDK Tools</span>) to install the <kbd>NDK</kbd> packages as well:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/eb9903a7-d7e3-4258-be96-205a2ee597be.png" width="1950" height="1367"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Ensure that the NDK package is installed and up to date for Android nk development</div>
<p>The following steps will be needed to complete the <kbd>nk-android</kbd> build, which should result in a complete development environment. Building the toolchain requires <kbd>ANDROID_HOME</kbd> and <kbd>NDK</kbd> environment variables to be set and your <kbd>PATH</kbd> to be updated correctly. You may not need to set up all of these environment variables as they may already be configured if you've completed previous Android projects. Further documentation is available at <a href="https://github.com/golang-ui/nuklear#android-demo">https://github.com/golang-ui/nuklear#android-demo</a>:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/b9c94378-c2be-4b60-9928-04b214c8a936.png" style="width:40.33em;height:13.17em;" width="1124" height="367"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Setting up an Android environment and building the nk-android toolchain</div>
<p>This should prepare your desktop for Android development using nk and Go. The rest of this chapter focuses on desktop development, but if the tools are working correctly, you should be able to adapt the instructions to Android NDK-based deployment.</p>
<p>Now that the prerequisites for your platform are complete, let's set up nk and run our first example application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setup</h1>
                </header>
            
            <article>
                
<p>Setting up the <kbd>nk</kbd> package to use Nuklear from Go is as simple as installing the <kbd>github.com/golang-ui/nuklear/nk</kbd><span> </span>package with the standard <kbd>go</kbd> tools:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/69c2318b-b86b-4be3-a3f1-7444d9aee95e.png" style="width:28.42em;height:5.83em;" width="879" height="181"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Installing nk is straightforward if you already have CGo up and running</div>
<p>Now that you have the library installed, let's run an example to see nk in action.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example</h1>
                </header>
            
            <article>
                
<p>The Go Nuklear bindings project provides an example application to demonstrate some widgets; we can use this to quickly check that things are working. With the previous setup steps complete, running the demo is as simple as installing the Go project and running it. The code is located in the <kbd>cmd/nk-example</kbd> sub-project of <a href="https://github.com/golang-ui/nuklear">github.com/golang-ui/nuklear</a><span>; we can use <kbd>go install</kbd> to download and install the example and run it using <kbd>nk-example</kbd>:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/ba9af3dc-3e4f-4d93-a306-0f784f6fea54.png" style="width:36.92em;height:8.33em;" width="562" height="127"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Installing and running a nuklear example is trivial once CGo is set up</div>
<p>Running the preceding commands should result in the following example window appearing on your screen. This example shows some of the widgets provided by the Nuklear toolkit, including embedded windows:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f916d590-96f5-46fa-bf34-71abac948cbf.png" style="width:19.17em;height:24.50em;" width="268" height="342"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The nk-example application running on Linux</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code</h1>
                </header>
            
            <article>
                
<p>To get started with our first nk application, there's a certain amount of setup code we need to write. Nuklear is focused on delivering a graphical toolkit API and not the operating system-specific code such as managing windows and user input. To avoid having to write all of that code ourselves, we'll use the <kbd>glfw</kbd> Go bindings to create and show a window for our application. The following code will set up an application window and show it (without any content). We also need to call <kbd>runtime.LockOSThread()</kbd> as this setup code must all execute on the main thread:</p>
<pre><span>package </span>main<br/><br/>import "runtime"<br/><span>import </span><span>"github.com/go-gl/glfw/v3.2/glfw"</span><br/><span>import "github.com/go-gl/gl/v3.2-core/gl"<br/><br/>func </span><span>init</span>() {<br/>   runtime.LockOSThread()<br/>}<br/><br/><span>func </span><span>main</span>() {<br/>   glfw.Init()<br/>   win<span>, </span>_ := glfw.CreateWindow(<span>120</span><span>, </span><span>80</span><span>, </span><span>"Hello World"</span><span>, </span>nil<span>, </span>nil)<br/>   win.MakeContextCurrent()<br/>   gl.Init()<br/><br/>   ...<br/>}</pre>
<p>After initializing <kbd>glfw</kbd>, we need to create a window, which <kbd>glfw.CreateWindow()</kbd> handles for us. We specify the window size and title in the first three parameters. The fourth parameter is used for fullscreen windows; by passing a <kbd>*glfw.Monitor</kbd> reference, we request a window that fills the specified monitor in its default video mode. The final parameter is related to <em>context sharing, </em>passing an existing <kbd>*glfw.Window</kbd> reference requests that this new window shares the same graphical context to reuse textures and other resources. We then make the new window current so that its context is used in the following code. Note that the window may not exactly match the requested parameters (exact window size or monitor modes may not be supported), so it's important to check these values after creation rather than assume the result.</p>
<p>The other setup we must do is to create an OpenGL context that the Nuklear code can utilize. For this task, we'll import the <kbd>go-gl</kbd> library (by the same authors as the <kbd>glfw</kbd> Go bindings). We initialize the OpenGL library ready to use the context from the window that was created by <kbd>glfw</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Additionally, the <kbd>nk</kbd> package needs to be initialized and we need to set up a default font. Thankfully, Nuklear has a standard font packaged but we need to run some code to set it as the default (or load a custom one for our application):</p>
<pre><span>import "github.com/golang-ui/nuklear/nk"</span><br/><br/><span>func </span><span>main</span>() {<br/>   ...<br/><br/>   ctx := nk.NkPlatformInit(win<span>, </span>nk.<span>PlatformInstallCallbacks</span>)<br/>   atlas := nk.NewFontAtlas()<br/>   nk.NkFontStashBegin(&amp;atlas)<br/>   font := nk.NkFontAtlasAddDefault(atlas<span>, </span><span>14</span><span>, </span>nil)<br/>   nk.NkFontStashEnd()<br/>   nk.NkStyleSetFont(ctx<span>, </span>font.Handle())<br/><br/>   ...<br/>}</pre>
<p>With all of the setup done, the window still looks the same as we haven't yet rendered any content. To actually run a Nuklear application, we need to add a run-loop that handles event management and GUI refreshing. The following code isn't the simplest possible event loop (it would be possible to use <kbd>for !win.ShouldClose() { ... }</kbd>, but that would consume a whole CPU!), but it's reasonably efficient for the brevity. It sets up a loop that will check for any events and then refresh the user interface <span>30 times a second</span>. The following code block completes our basic nk <kbd>main()</kbd> function:</p>
<pre><span>import </span><span>"time"</span><span><br/></span><br/><span>func </span><span>main</span>() {<br/>   ...<br/><br/>   quit := <span>make</span>(<span>chan struct</span>{}<span>, </span><span>1</span>)<br/>   ticker := time.NewTicker(time.<span>Second </span>/ <span>30</span>)<br/>   <span>for </span>{<br/>      <span>select </span>{<br/>      <span>case &lt; </span>-quit:<br/>         nk.NkPlatformShutdown()<br/>         glfw.Terminate()<br/>         ticker.Stop()<br/>         <span>return<br/></span><span>      case&lt;</span>-ticker.C:<br/>         <span>if </span>win.ShouldClose() {<br/>            close(quit)<br/>            <span>continue<br/></span><span>         </span>}<br/>         glfw.PollEvents()<br/>         draw(win<span>, </span>ctx)<br/>      }<br/>   }<br/>}</pre>
<p>The preceding code will run our application, but we haven't defined the user interface. The call to a <kbd>draw()</kbd> function in the preceding code is the secret, so we should implement that now. Let's look at the method in two parts: first, the GUI layout and second, the actual rendering. To set up our interface, we create a new <em>frame</em> (imagine a single snapshot of a video) that will be drawn on the next refresh of the user interface. After calling <kbd>nk.NkPlatformNewFrame()</kbd>, we can set up our interface; any code between <kbd>nk.NkBegin()</kbd> and <kbd>nk.NkEnd()</kbd> will be part of our UI update for the frame we just started. We can find out whether re-drawing is needed by checking the returned <kbd>update</kbd> variable; if it's <kbd>0</kbd>, then no changes have occurred and we can skip the UI code.</p>
<p>Inside the <kbd>if update &gt; 0 { ... }</kbd> block, we lay out the application interface, two rows each containing a single cell. In the first row (created with <kbd>nk.NkLayoutRowStatic()</kbd>), we add an <kbd>nk.NkLabel</kbd> containing the text <em>Hello World!</em>. In the second, we create a <span class="packt_screen">Quit</span> button using <kbd>nk.NkButtonLabel()</kbd>. As this is an immediate mode user interface, we don't retain a reference to the button to check its state, nor do we pass an on-click handler; we simply check the return value from the widget draw function. The value that's returned will be greater than <kbd>0</kbd> if the button has been clicked; and so we can place code inline that will tell the window to close and thereby close the application:</p>
<pre>const pad = 8<br/><br/><span>func </span><span>draw</span>(win *glfw.<span>Window</span><span>, </span>ctx *nk.<span>Context</span>) {<br/>   // Define GUI<br/>   nk.NkPlatformNewFrame()<br/><span>   </span>width<span>, </span>height := win.GetSize()<br/>   bounds := nk.NkRect(<span>0</span><span>, </span><span>0</span><span>, </span><span>float32</span>(width)<span>, </span><span>float32</span>(height))<br/>   update := nk.NkBegin(ctx<span>, </span><span>""</span><span>, </span>bounds<span>, </span>nk.<span>WindowNoScrollbar</span>)<br/><br/>   <span>if </span>update &gt; <span>0 </span>{<br/>      cellWidth := <span>int32</span>(width-<span>pad</span>*<span>2</span>)<br/>      cellHeight := <span>float32</span>(height-<span>pad</span>*<span>2</span>) / <span>2.0<br/></span><span>      </span>nk.NkLayoutRowStatic(ctx<span>, </span>cellHeight<span>, </span>cellWidth<span>, </span><span>1</span>)<br/>      {<br/>         nk.NkLabel(ctx<span>, </span><span>"Hello World!"</span><span>, </span>nk.<span>TextCentered</span>)<br/>      }<br/>      nk.NkLayoutRowStatic(ctx<span>, </span>cellHeight<span>, </span>cellWidth<span>, </span><span>1</span>)<br/>      {<br/>         <span>if </span>nk.NkButtonLabel(ctx<span>, </span><span>"Quit"</span>) &gt; <span>0 </span>{<br/>            win.SetShouldClose(<span>true</span>)<br/>         }<br/>      }<br/>   }<br/>   nk.NkEnd(ctx)<br/><br/>   ...<br/>}</pre>
<p>Lastly, at the end of the <kbd>draw()</kbd> function, we need to ask our OpenGL viewport to render the created user interface. To do this, we set up the OpenGL viewport using <kbd>gl.Viewport()</kbd>—as you can see, we use the width and height parameters from the actual window size rather than assuming the size we requested at the beginning of this code is correct. Once the viewport is set up, we clear it and set a background color (using <kbd>gl.ClearColor()</kbd>). The main render work is handled by <kbd>nk.NkPlatformRender()</kbd>, which takes the frame that we defined previously and draws it into the current graphical context. This function requires that we specify buffer sizes for the vertex and element buffers. We pass numbers that will be large enough for our demonstration purposes.</p>
<p>Finally, we cause the content to be shown by calling <kbd>win.SwapBuffers()</kbd>. As <kbd>glfw.Window</kbd> is <em>double buffered</em>, we've been drawing to a back buffer that's currently off-screen. By calling swap, we're moving the back buffer to the screen and setting the previously shown front buffer to be hidden, ready for the next frame to be drawn:</p>
<pre><span>func </span><span>draw</span>(win *glfw.<span>Window</span><span>, </span>ctx *nk.<span>Context</span>) {<br/>   ...<br/><br/><span>   // Draw to viewport<br/></span><span>   </span>gl.Viewport(<span>0</span><span>, </span><span>0</span><span>, </span><span>int32</span>(width)<span>, </span><span>int32</span>(height))<br/>   gl.Clear(gl.<span>COLOR_BUFFER_BIT</span>)<br/>   gl.ClearColor(<span>0x10</span><span>, </span><span>0x10</span><span>, </span><span>0x10</span><span>, </span><span>0xff</span>)<br/>   nk.NkPlatformRender(nk.<span>AntiAliasingOn</span><span>, </span><span>4096</span><span>, </span><span>1024</span>)<br/>   win.SwapBuffers()<br/>}</pre>
<p>That should complete the code for our <em>hello world</em> application. There was a lot of setup but the UI definition code was relatively succinct, so building more complex interfaces won't be much more work.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Build and run</h1>
                </header>
            
            <article>
                
<p class="mce-root">Simply build or run <kbd>hello.go</kbd> and you'll see the expected <span class="packt_screen">Hello World</span> window. Clicking the <span class="packt_screen">Quit</span> button will tell the window to close which in turn will exit the application:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/b23b3b61-32a0-4f24-8a9b-1168cdc29e3e.png" style="width:9.08em;height:8.17em;" width="120" height="108"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Hello world with nk</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-compiling</h1>
                </header>
            
            <article>
                
<p>Compiling an nk-based application for a different operating system can be a complicated process due to its requirement to use CGo to communicate with native OpenGL libraries. However, if you've worked through <a href="4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml">Chapter 5</a>, <em>andlabs UI - Cross-platform Native UIs</em>, or <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a>, <em>Shiny - Experimental Go GUI API</em>, this should already be set up. If you've jumped straight to this chapter, then you may need to follow the steps in the <a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml">Appendix</a>, in the <em>Cross-Compiler Setup</em>. Once that's complete, you should have new compilers available (named <kbd>o32-clang</kbd> for macOS or <kbd>x86_64-w64-mingw32-gcc</kbd> for Windows) that are able to link to macOS Foundation APIs and Windows system calls respectively.</p>
<p>To build the application, we now set up the<span> </span><kbd>GOOS</kbd><span> </span>and<span> </span><kbd>CGO_ENABLED</kbd><span> </span>flags as before, but also specify the compiler to use through an extra<span> </span><kbd>CC</kbd><span> </span>environment variable, setting it to <kbd>o32-clang</kbd> for the Darwin OS or <span><kbd>x86_64-w64-mingw32-gcc</kbd> for Windows</span>. With that configuration complete, we can build our nk application for macOS and Windows from our Linux Terminal:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d60d7e5f-53e3-41b8-a37a-e3b7e1ea4390.png" style="width:37.75em;height:17.33em;" width="1124" height="515"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Compiling for Linux, macOS, and Windows from a Linux Terminal</div>
<div>
<p>Now that we've built our first nk application, let's look further into what the underlying Nuklear library supports for building application GUIs.</p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Widgets, layout, and skinning</h1>
                </header>
            
            <article>
                
<p>As the Nuklear library focuses purely on the widget aspects of an application toolkit, its capability in this area is comparable to that of more established application libraries. As you'll see in the following, there's a long list of widgets that can be included in any Nuklear application. As the nk bindings expose all of the library functionality, these features are all available to an nk application as well.</p>
<p>The GUI functionality is split into three broad areas: <strong>widgets</strong> (the main user interface elements), <strong>drawing</strong> (for drawing directly to the canvas), and <strong>layout</strong> (for arranging elements on screen). In this section, we'll look at each area in turn, starting with the main widgets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Widgets</h1>
                </header>
            
            <article>
                
<p>The Nuklear widgets (and the nk API presenting them) should in many ways be familiar. Sensible naming allows for many of these features to be discovered while programming in your favorite IDE, but let's explore the main widgets and how they function:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr style="height: 27.5596px">
<td style="height: 27.5596px;width: 26.4463%"><strong>Widget name</strong></td>
<td style="height: 27.5596px;width: 69.8347%"><strong>Description</strong></td>
</tr>
<tr style="height: 64px">
<td style="height: 64px;width: 26.4463%"><kbd>NkButtonLabel</kbd></td>
<td style="height: 64px;width: 69.8347%">A standard push button widget, the API reports when it has been clicked. See <kbd>NkButtonImage</kbd> also (to use an image instead of a text label) and <kbd>NkButtonImageLabel</kbd> to include both.</td>
</tr>
<tr style="height: 64px">
<td style="height: 64px;width: 26.4463%"><kbd><span>NkCheckboxLabel</span></kbd></td>
<td style="height: 64px;width: 69.8347%">A checkbox displays a familiar box next to the label that's either checked or not. The API reports when its value has changed.</td>
</tr>
<tr style="height: 64px">
<td style="height: 64px;width: 26.4463%"><kbd><span>NkColorPicker</span></kbd></td>
<td style="height: 64px;width: 69.8347%">This is a special button that opens a color picker. This form returns the currently selected color, or you can use <kbd>NkColorPick</kbd>, which reports when the value changes.</td>
</tr>
<tr style="height: 64px">
<td style="height: 64px;width: 26.4463%"><kbd>NkComboBox</kbd></td>
<td style="height: 64px;width: 69.8347%">This is a combobox container for dropping down a selection. Each item within it can contain text, an image, or both (see the APIs beginning with <span><kbd>NkComboItem</kbd>)</span>.</td>
</tr>
<tr style="height: 64px">
<td style="height: 64px;width: 26.4463%"><kbd><span>NkGroup(</span><span>Begin</span><span>/End)</span></kbd></td>
<td style="height: 64px;width: 69.8347%">This adds a grouping for widgets in an interface. A group has a title and a scrollbar, if required. To manually control the scroll behavior, you can instead use <kbd><span>NkGroupScrolledBegin</span>.</kbd> <span>The widgets declared between begin and end will be included. </span>The begin function returns <kbd>&gt; 0</kbd> if the contents should be drawn. </td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 26.4463%"><kbd>NkImage</kbd></td>
<td style="height: 32px;width: 69.8347%">This displays a simple image in the interface.</td>
</tr>
<tr style="height: 30px">
<td style="height: 30px;width: 26.4463%"><kbd><span>NkMenubar(Begin/End)</span></kbd></td>
<td style="height: 30px;width: 69.8347%">For add a menu bar to the user interface, this requires the use of the various APIs beginning with <kbd>NkMenu</kbd> and <kbd>NkMenuItem</kbd> as well. <span>The begin function returns <kbd>&gt; 0</kbd> if the contents should be drawn.</span></td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 26.4463%"><kbd>NkPopup(Begin/End)</kbd></td>
<td style="height: 32px;width: 69.8347%">This displays a popup over the current content; the widgets declared between begin and end will be included. <span>The begin function returns <kbd>&gt; 0</kbd> if the contents should be drawn.</span></td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 26.4463%"><kbd>NkRadioLabel</kbd></td>
<td style="height: 32px;width: 69.8347%">A radio selection is like a combobox but offers multiple possible values, each added using this function. The return value indicates whether the specified item has been selected.</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 26.4463%"><kbd>NkSlider(Int/Float)</kbd></td>
<td style="height: 32px;width: 69.8347%">The <kbd>NkSlider</kbd> functions add a slide bar with specified minimum, maximum, and current values. The API reports when the value has changed. An alternative format, <kbd>NkSlide(Int/Float)</kbd>, returns the current value.</td>
</tr>
<tr style="height: 29px">
<td style="height: 29px;width: 26.4463%"><kbd><span>NkTexteditString</span></kbd></td>
<td style="height: 29px;width: 69.8347%">This is a text entry widget. This function requires a buffer to edit; this can more easily be set through <kbd>NkEditStringZeroTerminated()</kbd>. There are also many helpful APIs starting with <kbd><span>NkTextedit</span></kbd><span> that can be used to manage the text content.</span></td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 26.4463%"><kbd>NkTree(Push/Pop)</kbd></td>
<td style="height: 32px;width: 69.8347%">Tree widgets can be used to allow sections of the user interface to be expanded and collapsed or to present tree-based data on the screen. Functions beginning with <span><span><kbd>NkTreePush</kbd> mark the start of a new tree section and </span></span><span><kbd>NkTreePop</kbd> ends that section (or the root of the tree). The <kbd>TreeType</kbd> named <kbd>TreeNode</kbd> marks a user interface style tree and <kbd>TreeTab</kbd> is for data style tree.</span></td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 26.4463%">Window (<kbd>NkBegin</kbd>, <kbd>NkEnd</kbd>)</td>
<td style="height: 32px;width: 69.8347%">A window is required to contain all widgets within Nuklear (anything declared outside this scope will be ignored or cause an error). A window is declared with <kbd>NkBegin</kbd> or <kbd>NkBeginTitled</kbd> and marked as complete with <kbd>NkEnd</kbd>. Various window management functions are available and they start with <kbd>NkWindow</kbd>.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As you can see, many of these widgets are straightforward. The more complex ones have semantics for opening and closing their definition that become familiar over time. This is due to the immediate mode nature of the API and its design to not retain any state. Common semantics are for containers to return a value greater than <kbd>0</kbd> when they need to be drawn. Similarly, items that respond to user events will return a non-zero value when they have been activated or changed.</p>
<p class="mce-root"/>
<p>Now that we've explored the widgets available, let's look at how we can arrange elements in our GUI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>The layout system for Nuklear follows a simple rows and columns approach. To lay out widgets, each item should be within a row; columns are implicitly created when widgets are added according to the parameters set in the row configuration. When widgets are added to a row that's full, a new one will be automatically created with the same parameters as the previous. A new row may be started to change the parameters or to finish a previous row without filling the remaining columns. The basic layout is controlled by the NkLayoutRow API as described here; there's also a helpful template-based layout in <kbd>NkLayoutRowTemplate</kbd>, which we'll explore after that. Lastly, <kbd>NkLayoutSpace</kbd> allows directly setting widget locations and sizes<span>—</span>we'll explore that last.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">NkLayoutRow</h1>
                </header>
            
            <article>
                
<p>The easiest approach to layout is to start a new row using <kbd>NkLayoutRowDynamic()</kbd> or <kbd>NkLayoutRowStatic()</kbd>. Both functions specify the number of cells in the row. The difference between the two is that the dynamic row allocation will split all of the space between the cells and resize them all as the window or container changes size. With a static arrangement, the sizes of all cells will remain the same irrespective of the container size. <span>Widgets added after a row is started will append to the row, until it's full; if further widgets are appended, then a new row will be created for the new widgets. This continues until </span><kbd>NkLayoutRowEnd()</kbd><span> is called, or a different row configuration is started using one of these alternative functions.</span></p>
<p><span>Some added control is made possible by using the </span><kbd>NkLayoutRowBegin()</kbd><span> function to start a row; this specifies the row height and number of columns, but not how the columns will be sized. Cells are added to the row before widgets are appended by calling </span><kbd>NkLayoutRowPush()</kbd>; this sets a size or ratio for the next cell and should be followed by the declaration of a widget to fill the cell. This type of row should also conclude by calling <kbd>NkLayoutRowEnd()</kbd>.</p>
<p>Lastly, it's possible to call <kbd>NkLayoutRow</kbd> directly to set up the parameters for the following rows, static or dynamic sizing, and specified height or ratio with a specified number of columns.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">NkLayoutRowTemplate</h1>
                </header>
            
            <article>
                
<p>A more powerful way to lay out rows is to use the template mechanism available. By calling <kbd>NkLayoutRowTemplateBegin()</kbd>, it's possible to set the template for all rows that follow. Column sizing is defined using one of three template functions. Firstly, <kbd>NkLayoutRowTemplatePushStatic()</kbd> specifies that widgets in this column should be of a fixed width. <kbd>NkLayoutRowTemplatePushDynamic()</kbd>, like the definition of dynamic allocation without templates, will split the row width among dynamic columns (this could be as little as <kbd>0</kbd> if no space is available). Finally, there's an additional call to the <kbd>NkLayoutRowTemplatePushVariable()</kbd>function; this will ensure that widgets get their minimum required space and will take up any extra space available (or split evenly across other variable width columns).</p>
<p>At the end of the template specification, you must call <kbd>NkLayoutRowTemplateEnd()</kbd>; this will indicate that any widgets added will start the creation of layout rows that follow the declared template. As before, if there are more widgets that fit in a row, then a new row will automatically be created and widgets will start to be added on this new row. Unlike the regular row layout functions before that specified the number of columns in a row, using this method will add as many widgets to a row as items exist in the template definition.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">NkLayoutSpace</h1>
                </header>
            
            <article>
                
<p>Lastly, the space layout offers full control over the positioning and size of the items in your Nuklear application. The layout is started and ended like the previous row-based layout; use <kbd>NkLayoutSpaceBegin()</kbd> to start a space-based layout and <kbd>NkLayoutSpaceEnd()</kbd> to finish the layout. Before each widget you wish to add to your interface, call the <kbd>NkLayoutSpacePush()</kbd> function, passing <kbd>NkRect</kbd>, which specifies the size and position for the next widget to be added.</p>
<p>As well as the layout control functions, there are a number of helper functions that use the <kbd>NkLayoutSpace</kbd> API prefix. The most useful is <kbd>NkLayoutSpaceBounds()</kbd>—if called within a space layout, it'll return the total space that's available to work within. This is important if you wish to right- or bottom-align or position your widgets centrally within available space.</p>
<p>Those are all of the layout options that the nk API provides; let's look now at the drawing capabilities of the library.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Drawing</h1>
                </header>
            
            <article>
                
<p>The drawing API presents a fairly standard <strong>two</strong>-<strong>dimensional</strong> (<strong>2D</strong>) vector graphics library that's mostly used by the higher level widgets. As it's part of the public API, it's also possible to use them in your application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Command queue</h1>
                </header>
            
            <article>
                
<p>To draw custom areas of an application, our application will be interacting directly with the Nuklear draw command queue (the list of items to draw for rendering a frame of the user interface) so care is recommended. You can get access to <kbd>nk.CommandBuffer</kbd><span>, </span>which is needed for each draw command by using the <span><kbd>NkWindowGetCanvas()</kbd> function. It's important that this is only called when a window is active (after <kbd>NkBegin</kbd></span> and before <kbd>NkEnd</kbd>). The positional values will need to be aware of other widgets and layouts loaded, which can get complicated very fast—it's easiest to draw using these commands only in an otherwise empty window so that you avoid drawing over other widgets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Draw functions</h1>
                </header>
            
            <article>
                
<p>If you want to go ahead and make use of these draw commands directly, you can use the following:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 16%"><strong><span>Stroke function</span></strong></td>
<td style="width: 10%"><strong>Fill function</strong></td>
<td style="width: 75%"><strong>Notes</strong></td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkStrokeLine()</span></kbd></td>
<td style="width: 10%"/>
<td style="width: 75%">Draw a single line segment in the specified color.</td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkStrokeCurve()</span></kbd></td>
<td style="width: 10%"/>
<td style="width: 75%">Draw a single curve segment in the specified color.</td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkStrokeRect()</span></kbd></td>
<td style="width: 10%">
<p class="mce-root"><span><span><kbd>NkFillRect()</kbd>, </span></span></p>
<p class="mce-root"><span><span><kbd>NkFillRectMultiColor()</kbd> <br/></span></span></p>
</td>
<td style="width: 75%"><span><span><span>Draw a rectangle (or square) outline, or solid rectangle in the specified color(s). To draw an outlined, filled rectangle, call </span></span></span><span><span><span><kbd>NkFillRect()</kbd> and then </span></span></span><span><span><kbd>NkStrokeRect()</kbd> using the same coordinates. <kbd>NkFillRectMultiColor()</kbd> is a quick way to draw gradients in a rectangle.</span></span></td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkStrokeCircle()</span></kbd></td>
<td style="width: 10%"><kbd><span>NkFillCircle()</span></kbd></td>
<td style="width: 75%">Draw a circle (or ellipse) outline or fill<span> in the specified color</span>.</td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkStrokeArc()</span></kbd></td>
<td style="width: 10%"><kbd><span>NkFillArc()</span></kbd></td>
<td style="width: 75%">Outline, or fill, an arc around a central point<span> in the specified color</span>.</td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkStrokeTriangle()</span></kbd></td>
<td style="width: 10%"><kbd><span>NkFillTriangle()</span></kbd></td>
<td style="width: 75%">Draw a triangle outline or a solid triangle<span> in the specified color</span>.</td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkStrokePolyline()</span></kbd></td>
<td style="width: 10%"/>
<td style="width: 75%">Draw a series of line segments in the specified color.</td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkStrokePolygon()</span></kbd></td>
<td style="width: 10%"><kbd><span>NkFillPolygon()</span></kbd></td>
<td style="width: 75%">Outline or fill a shape with a list of points defining its boundary.</td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkDrawImage()</span></kbd></td>
<td style="width: 10%"/>
<td style="width: 75%">Draw an image into a specified rectangle and background color.</td>
</tr>
<tr>
<td style="width: 16%"><kbd><span>NkDrawText()</span></kbd></td>
<td style="width: 10%"/>
<td style="width: 75%">Draw a text string with the specified background and foreground colors.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now that we've explored all of the widgets and drawing capabilities, we could jump right in to building a full application. However, Nuklear has one other cool feature that we should look at: the ability to change the interface design using skinning.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Skinning</h1>
                </header>
            
            <article>
                
<p>As well as defining its own style for the widgets included, Nuklear supports <strong>skinning</strong>—loading a theme to change how applications look. This is a powerful feature—very similar to the themes that we saw with GTK+ and Qt, but selected by the application instead of the end user. Any nk application developer looking to set up skinning for their application may find that it isn't easy to do—this is due to the way that most configuration is expose through C structures from the underlying Nuklear API. While these elements are mostly available through the Go API binding, it requires a lot of pointer conversion and unsafe assignments that could affect the stability of your application. It would be possible, however, to write some C code and include it in your application using CGo.</p>
<p>The following C code is extracted from a Nuklear skinning example in case a developer wishes to include a custom skin in their application and is willing to embed C in their Go code. The example uses a single texture image that defines all of the different images that together define the theme. Firstly, the texture must be loaded into the current OpenGL context and then the individual areas identified within the loaded texture, as follows:</p>
<pre>   glEnable(GL_TEXTURE_2D);<br/>   media.skin = image_load("../skins/gwen.png");<br/>   media.check = nk_subimage_id(media.skin, 512,512, nk_rect(464,32,15,15));<br/>   media.check_cursor = nk_subimage_id(media.skin, 512,512, nk_rect(450,34,11,11));<br/><br/>   ...</pre>
<p>The preceding code excerpt specifies only two sub-textures where, in real-life usage, there would be many more. After the textures are loaded, we define a style struct pointer that matches the widget to theme <span>(here, we're skinning the checkbox). The value of this pointer is then set to the location of the loaded style configuration (this is where it becomes very difficult to re-create in pure Go code). For each field in the struct, an appropriate image or color should be set:</span></p>
<pre> {struct nk_style_toggle *toggle;<br/> toggle = &amp;ctx.style.checkbox;<br/> toggle-&gt;normal = nk_style_item_image(media.check);<br/> toggle-&gt;hover = nk_style_item_image(media.check);<br/> toggle-&gt;active = nk_style_item_image(media.check);<br/> toggle-&gt;cursor_normal = nk_style_item_image(media.check_cursor);<br/> toggle-&gt;cursor_hover = nk_style_item_image(media.check_cursor);<br/> toggle-&gt;text_normal = nk_rgb(95,95,95);<br/> toggle-&gt;text_hover = nk_rgb(95,95,95);<br/> toggle-&gt;text_active = nk_rgb(95,95,95);}</pre>
<p class="mce-root"/>
<p>The same technique should be applied for all widgets that will be used in the application to be skinned. This is a lot of work and even the toolkit author warns against it at this time due to its time-consuming nature! Following is the style texture for the <em>Gwen</em> skin and a screenshot of an application with this theme loaded:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/22ba1c35-a47a-4830-91a1-40e9b580807e.png" style="width:22.25em;height:22.25em;" width="527" height="527"/>  <img src="Images/8f767dfc-54eb-4edc-b580-d1fab9748683.png" style="width:17.08em;height:22.75em;" width="285" height="380"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>The Gwen skin is used to demonstrate Nuklear skin capabilities (left); The Gwen skin in action (right)</span></div>
<p class="mce-root"><span>A complete implementation can be found in the</span> <span>examples repository at </span><a href="https://github.com/vurtun/nuklear/blob/master/example/skinning.c">https://github.com/vurtun/nuklear/blob/master/example/skinning.c</a><span>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">
Building a user interface</h1>
                </header>
            
            <article>
                
<p>Let's return to our GoMail application again to try out the nk API. Nuklear is an established toolkit with a lot of functionality so it should be able to build the user interface just as well as previous examples. What we'll see as we build out this user interface is how different an immediate mode toolkit is, in how the code is arranged and how event handling is managed.</p>
<p class="mce-root"><span>We can start by copying the hello world application so we don't have to re-work all of the setup code and life cycle management. As this application is going to contain many more graphical elements, we need to increase the buffer sizes that set using <kbd>NkPlatformRender()</kbd>. Replace the original line with the following for this example. In your own applications, this may need to be higher still—if the number is too low, you may notice graphical elements not showing or disappearing when popups and menu items appear:</span></p>
<pre>nk.NkPlatformRender(nk.<span>AntiAliasingOn</span><span>, </span><span>512 </span>* <span>1024</span><span>, </span><span>128 </span>* <span>1024</span>)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>We'll begin with the basic application layout; to start with, we update our <kbd>draw()</kbd> function to call a separate <kbd>drawLayout()</kbd> function where we'll add our new code. This new function will need to be passed the height of the window to correctly fill the vertical space, as you'll see later:</p>
<pre><span>func </span><span>draw</span>(win *glfw.<span>Window</span><span>, </span>ctx *nk.<span>Context</span>) {<br/>   nk.NkPlatformNewFrame()<br/>   width<span>, </span>height := win.GetSize()<br/>   bounds := nk.NkRect(<span>0</span><span>, </span><span>0</span><span>, </span><span>float32</span>(width)<span>, </span><span>float32</span>(height))<br/>   update := nk.NkBegin(ctx<span>, </span><span>""</span><span>, </span>bounds<span>, </span>nk.<span>WindowNoScrollbar</span>)<br/><br/>   <span>if </span>update &gt; <span>0 </span>{<br/>      drawLayout(win<span>, </span>ctx<span>, </span>height)<br/>   }<br/>   nk.NkEnd(ctx)<br/><br/><span>   </span>gl.Viewport(<span>0</span><span>, </span><span>0</span><span>, </span><span>int32</span>(width)<span>, </span><span>int32</span>(height))<br/>   gl.Clear(gl.<span>COLOR_BUFFER_BIT</span>)<br/>   gl.ClearColor(<span>0x10</span><span>, </span><span>0x10</span><span>, </span><span>0x10</span><span>, </span><span>0xff</span>)<br/>   nk.NkPlatformRender(nk.<span>AntiAliasingOn</span><span>, 512 * 1024, 128 * 1024</span>)<br/>}</pre>
<p>The preceding code is fairly standard for painting a window with nk. Let's jump straight into our new layout code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Main email window</h1>
                </header>
            
            <article>
                
<p>We start with a simple l<span>ayout function called <kbd>drawLayout()</kbd>. This will set up the basic application layout similar to the GoMail design we created in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications</em>. The beginning of the code sets out space for the menu and toolbar that will expand to stretch the width of our window. We then start a template layout using <kbd>NkLayoutRowTemplateBegin()</kbd> to have a fixed size column on the left for our email list and a wider, variable width column on the right that will expand as our window resizes:</span></p>
<pre><span>func </span><span>drawLayout</span>(win *glfw.<span>Window</span><span>, </span>ctx *nk.<span>Context</span><span>, </span>height <span>int</span>) {<br/>   toolbarHeight := <span>float32</span>(<span>36</span>)<br/>   nk.NkLayoutRowDynamic(ctx<span>, </span>toolbarHeight<span>, </span><span>1</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"Toolbar"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/><br/>   nk.NkLayoutRowTemplateBegin(ctx<span>, </span><span>float32</span>(height)-toolbarHeight)<br/>   nk.NkLayoutRowTemplatePushStatic(ctx<span>, </span><span>80</span>)<br/>   nk.NkLayoutRowTemplatePushVariable(ctx<span>, </span><span>320</span>)<br/>   nk.NkLayoutRowTemplateEnd(ctx)<br/><br/>   nk.NkGroupBegin(ctx<span>, </span><span>"Inbox"</span><span>, </span><span>1</span>)<br/>   nk.NkLayoutRowDynamic(ctx<span>,</span><span>0</span><span>, </span><span>1</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"Item1"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"Item2"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"Item3"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkGroupEnd(ctx)<br/><br/>   ...</pre>
<div class="packt_infobox">Notice that, while the width of our layout can adjust automatically, the height isn't quite as flexible. For this example, we pass in the height of the window and deduct from that the height we're allocating for the toolbar. This total is passed to our template layout so it'll expand to the remaining window height.</div>
<p>In the first column of the main layout, we add a new group named <kbd>"Inbox"</kbd> for our email list and add three simple label items that represent the loaded list. Next, we add another group that will occupy the second space in the template layout. This code sets up a mix of one and two column rows that will display email content.</p>
<p>We open the group and set up a simple dynamic row with a single column using <kbd>NkLayoutRowDynamic()</kbd>, inserting the <kbd>NkLabel</kbd> <span>subject </span>in that cell. Next, we add another template layout so we can have a narrow, fixed width column for our labels and a variable width column for the values. After that, <kbd>NkLabel</kbd> for the <span>label and value</span> can be inserted to form a grid. Lastly, we start another single column dynamic row for the main email content:</p>
<pre>   ...<br/><br/>   nk.NkGroupBegin(ctx<span>, </span><span>"Content"</span><span>, </span><span>1</span>)<br/>   nk.NkLayoutRowDynamic(ctx<span>,</span><span>0</span><span>, </span><span>1</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"Subject"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkLayoutRowTemplateBegin(ctx<span>, </span><span>0</span>)<br/>   nk.NkLayoutRowTemplatePushStatic(ctx<span>, </span><span>50</span>)<br/>   nk.NkLayoutRowTemplatePushVariable(ctx<span>, </span><span>320</span>)<br/>   nk.NkLayoutRowTemplateEnd(ctx)<br/>   nk.NkLabel(ctx<span>, </span><span>"From"</span><span>, </span>nk.<span>TextAlignRight</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"email"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"To"</span><span>, </span>nk.<span>TextAlignRight</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"email"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"Date"</span><span>, </span>nk.<span>TextAlignRight</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"date"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkLayoutRowDynamic(ctx<span>,</span><span>0</span><span>, </span><span>1</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"Content"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkGroupEnd(ctx)<br/>}</pre>
<p>Running the preceding code, along with the necessary boilerplate code from our <em>Hello world</em> example, should show a single window, looking a lot like the following:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/206a2e16-ca11-47b3-934d-3b3d778f88c5.png" style="width:15.08em;height:15.58em;" width="246" height="252"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The basic GoMail layout created with the nk API</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Email compose dialog</h1>
                </header>
            
            <article>
                
<p>To start our compose window layout, we create a new <kbd>drawComposeLayout()</kbd> <span>function </span>that (for testing) we can call instead of <kbd>drawLayout()</kbd> from the <kbd>draw()</kbd> function. Before we can add the text edit widgets that the email compose UI will use, we need to create buffers to manage the content they'll edit. Remember that this is an immediate mode toolkit so, to remember any state, we must provide the data storage. This is where the compose window will store the subject, email address, and content for a new email message:</p>
<pre><span>var </span>composeSubject = <span>make</span>([]<span>byte</span><span>, </span><span>512</span><span>, </span><span>512</span>)<br/><span>var </span>composeEmail = <span>make</span>([]<span>byte</span><span>, </span><span>512</span><span>, </span><span>512</span>)<br/><span>var </span>composeContent = <span>make</span>([]<span>byte</span><span>, </span><span>4096</span><span>, </span><span>4096</span>)</pre>
<p>It's also helpful to our user to provide a hint (often called a placeholder) for the user—to do this, we need to copy some data into the buffers before the draw loop begins:</p>
<pre>copy(composeSubject[:]<span>, </span><span>"subject"</span>)<br/>copy(composeEmail[:]<span>, </span><span>"email"</span>)<br/>copy(composeContent[:]<span>, </span><span>"content"</span>)</pre>
<p>Now let's look at the layout for the email compose window. The layout is similar to the content of our email display group in the previous layout code, setting up a dynamic row for the subject widget followed by a row template for the <em>To</em> label and email address entry. Instead of <kbd>NkLabel()</kbd>, this time we're creating a text entry widget using <span><kbd>NkEditStringZeroTerminated()</kbd></span> with a number of parameters. The <kbd>nk.EditBox|nk.EditSelectable|nk.EditClipboard</kbd> flags tell Nuklear that we're setting up an edit box where the text can be selected and interact with the system clipboard. We also need to tell the widget which buffer it should edit (in this case <kbd>composeSubject</kbd>) and what the maximum number of characters should be (which we set to the length of the buffer <kbd>int32(len(composeSubject))</kbd>). This is then repeated for the email and content input widgets:</p>
<pre><span>func </span><span>drawComposeLayout</span>(ctx *nk.<span>Context</span><span>, </span>height <span>int</span>) {<br/>   nk.NkLayoutRowDynamic(ctx<span>,</span><span>0</span><span>, </span><span>1</span>)<br/>   nk.NkEditStringZeroTerminated(ctx<span>, </span>nk.<span>EditBox</span>|nk.<span>EditSelectable</span>|nk.<span>EditClipboard</span><span>,<br/></span><span>      </span>composeSubject<span>, </span><span>int32</span>(len(composeSubject))<span>, </span>nil)<br/>   nk.NkLayoutRowTemplateBegin(ctx<span>, </span><span>0</span>)<br/>   nk.NkLayoutRowTemplatePushStatic(ctx<span>, </span><span>25</span>)<br/>   nk.NkLayoutRowTemplatePushVariable(ctx<span>, </span><span>320</span>)<br/>   nk.NkLayoutRowTemplateEnd(ctx)<br/>   nk.NkLabel(ctx<span>, </span><span>"To"</span><span>, </span>nk.<span>TextAlignRight</span>)<br/>   nk.NkEditStringZeroTerminated(ctx<span>, </span>nk.<span>EditBox</span>|nk.<span>EditSelectable</span>|nk.<span>EditClipboard</span><span>,<br/></span><span>      </span>composeEmail<span>, </span><span>int32</span>(len(composeEmail))<span>, </span>nil)<br/>   nk.NkLayoutRowDynamic(ctx<span>, </span><span>float32</span>(height-<span>114</span>)<span>, </span><span>1</span>)<br/>   nk.NkEditStringZeroTerminated(ctx<span>, </span>nk.<span>EditBox</span>|nk.<span>EditSelectable</span>|nk.<span>EditClipboard</span><span>,<br/></span><span>      </span>composeContent<span>, </span><span>int32</span>(len(composeContent))<span>, </span>nil)<br/><br/>   ...</pre>
<p>Lastly, we need to add the buttons to the bottom of the screen—we use another row template for this. The variable space in this layout is set to be the size of the row, minus the size of our buttons, so that the buttons will align to the right. We insert an empty <kbd>NkLabel</kbd> in the first cell to work as a spacer. The two <kbd>NkButtonLabel()</kbd> function calls set up the buttons at the bottom-right of the layout:</p>
<pre>   ...<br/><br/>   nk.NkLayoutRowTemplateBegin(ctx<span>, </span><span>0</span>)<br/>   nk.NkLayoutRowTemplatePushVariable(ctx<span>, </span><span>234</span>)<br/>   nk.NkLayoutRowTemplatePushStatic(ctx<span>, </span><span>64</span>)<br/>   nk.NkLayoutRowTemplatePushStatic(ctx<span>, </span><span>64</span>)<br/>   nk.NkLayoutRowTemplateEnd(ctx)<br/>   nk.NkLabel(ctx<span>, </span><span>""</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkButtonLabel(ctx<span>, </span><span>"Cancel"</span>)<br/>   nk.NkButtonLabel(ctx<span>, </span><span>"Send"</span>)<br/>}</pre>
<p>With that layout code created, we can show the window and see an email <span class="packt_screen">Compose</span> window like the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/66a55ee0-7102-41cd-ba7a-a424bceb9da1.png" style="width:24.42em;height:12.42em;" width="400" height="203"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The basic Compose layout with the nk toolkit</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Toolbar and menu</h1>
                </header>
            
            <article>
                
<p>Adding a menu to an nk window is accomplished using <kbd>NkMenubarBegin()</kbd>, <kbd>NkMenuBeginLabel()</kbd>, and <kbd>NkMenuItemLabel()</kbd>, among others. The only difficult step in setting up a menu is that we also need to add an appropriate layout for the bar and its items. It's important (in fact, mandatory) that the bar is in a layout where <kbd>y=0</kbd>, so we immediately add a new row layout using dynamic sizing with <kbd>NkLayoutRowBegin()</kbd>. Then, we push the cell size for this layout using <kbd>NLayoutRowPush()</kbd>.</p>
<p>A menu item is opened using <kbd>NkMenuBeginLabel()</kbd> and we must check the return value for this function—<kbd>0</kbd> means that the menu is hidden. If it returns a non-zero value then we should lay out the menu below the bar. We start a new dynamic row layout with a single column using <kbd>NkLayoutRowDynamic()</kbd> to contain each menu item. Each menu item is then added using <kbd>NkMenuItemLabel()</kbd> with the appropriate label <kbd>string</kbd>. The return value for this function indicates whether the item has been clicked. If we get a non-zero value, then we should action the item—as shown by the<br/>
<kbd>Quit</kbd> item. <span>Lastly, if the menu is open, we must close it again with </span><kbd>NkMenuEnd()</kbd><span>:</span></p>
<pre>   nk.NkMenubarBegin(ctx)<br/>   nk.NkLayoutRowBegin(ctx<span>, </span>nk.<span>LayoutStaticRow</span><span>, </span><span>25</span><span>, </span><span>3</span>)<br/>   nk.NkLayoutRowPush(ctx<span>, </span><span>45</span>)<br/><span>   if </span>nk.NkMenuBeginLabel(ctx<span>, </span><span>"File"</span><span>, </span>nk.<span>TextAlignLeft</span><span>, </span>nk.NkVec2(<span>120</span><span>, </span><span>200</span>)) &gt; <span>0 </span>{<br/>      nk.NkLayoutRowDynamic(ctx<span>, </span><span>25</span><span>, </span><span>1</span>)<br/>      nk.NkMenuItemLabel(ctx<span>, </span><span>"New"</span><span>, </span>nk.<span>TextAlignLeft</span>)<br/>      <span>if </span>nk.NkMenuItemLabel(ctx<span>, </span><span>"Quit"</span><span>, </span>nk.<span>TextAlignLeft</span>) &gt; <span>0 </span>{<br/>         win.SetShouldClose(<span>true</span>)<br/>      }<br/><br/>      nk.NkMenuEnd(ctx)<br/>   }<br/><br/>   ...</pre>
<p>Further menus (<kbd>Edit</kbd> and <kbd>Help</kbd>, for example) can simply be added by starting another block with <kbd>NkMenuBeginLabel()</kbd>. For the complete listing, you can see the code repository for this book: <kbd>chapter9/gomail</kbd>.</p>
<p>Adding a toolbar is less straightforward as the Nuklear toolkit has no direct toolbar support. We'll simulate this by adding a row of buttons that are of fixed size and left-aligned in the bar. To do this, we open a new static row layout, specifying the desired size of the buttons as the cell width (and the correct number of columns). We then add each button with <kbd>NkButtonLabel()</kbd> passing a button label. Ideally, we would use <kbd>NkButtonImage()</kbd>, but there are no standard toolbar icons available. We could package the required icons ourselves and load the images, but there's currently little support for loading an image from Go code; a proposal exists to add <kbd>NkImageFromRgba()</kbd>, but at the time of writing, this doesn't exist. Implementing that image loading is out of scope for this chapter:</p>
<pre>   ...<br/><br/>   toolbarHeight := <span>float32</span>(<span>24</span>)<br/>   nk.NkLayoutRowStatic(ctx<span>, </span>toolbarHeight<span>, </span><span>78</span><span>, </span><span>7</span>)<br/>   nk.NkButtonLabel(ctx<span>, </span><span>"New"</span>)<br/>   nk.NkButtonLabel(ctx<span>, </span><span>"Reply"</span>)<br/>   nk.NkButtonLabel(ctx<span>, </span><span>"Reply All"</span>)<br/><br/>   nk.NkButtonLabel(ctx<span>, </span><span>"Delete"</span>)<br/><br/>   nk.NkButtonLabel(ctx<span>, </span><span>"Cut"</span>)<br/>   nk.NkButtonLabel(ctx<span>, </span><span>"Copy"</span>)<br/>   nk.NkButtonLabel(ctx<span>, </span><span>"Paste"</span>)<br/><br/>   ...</pre>
<p>Each of these buttons returns, an <kbd>int</kbd> value, like the preceding menu items, that indicate whether it was clicked. We'll add the button handling in the next section, <em>Communicating with the GUI</em>. With this code in place, we see a complete user interface for our email browse window:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/0dd22abe-c9db-4dc3-8961-3ca228b22e56.png" style="width:28.17em;height:13.42em;" width="600" height="286"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The completed layout of our compose window</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating with the GUI</h1>
                </header>
            
            <article>
                
<p>Now that we have all of the layout completed, we need to connect up a data source and handle the appropriate interaction events. We start by importing the <kbd>client</kbd> email package used in the previous examples. Once imported, we set up a new test server and cache the current message (this will be changed later by clicking an item). As outlined before, we must save all state within the application code, not the user interface:</p>
<pre>import "github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client"<br/><br/>var server = client.NewTestServer()<br/>var current = server.CurrentMessage()</pre>
<p>Updating the email list group is as simple as wrapping the label creation in a <kbd>for</kbd> loop that iterates the range of <kbd>server.ListMessages()</kbd>:</p>
<pre>nk.NkGroupBegin(ctx<span>, </span><span>"Inbox"</span><span>, </span><span>1</span>)<br/>nk.NkLayoutRowDynamic(ctx<span>,</span><span>0</span><span>, </span><span>1</span>)<br/><span>for </span>_<span>, </span>email := <span>range </span>server.ListMessages() {<br/>   nk.NkLabel(ctx<span>, </span>email.Subject<span>, </span>nk.<span>TextAlignLeft</span>)<br/>}<br/>nk.NkGroupEnd(ctx)</pre>
<p>The content is loaded from the <kbd>client.EmailMessage</kbd> that we saved as <kbd>current</kbd>, as follows:</p>
<pre>   nk.NkLabel(ctx, ui.current.Subject, nk.TextAlignLeft)<br/>   ...<br/>   nk.NkLabel(ctx<span>, </span><span>"From"</span><span>, </span>nk.<span>TextAlignRight</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>string</span>(ui.current.From)<span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"To"</span><span>, </span>nk.<span>TextAlignRight</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>string</span>(ui.current.To)<span>, </span>nk.<span>TextAlignLeft</span>)<br/>   nk.NkLabel(ctx<span>, </span><span>"Date"</span><span>, </span>nk.<span>TextAlignRight</span>)<br/>   nk.NkLabel(ctx<span>, </span>ui.current.DateString()<span>, </span>nk.<span>TextAlignLeft</span>)<br/>   ...<br/>   nk.NkLabel(ctx<span>, </span>ui.current.Content<span>, </span>nk.<span>TextAlignLeft</span>)</pre>
<p>For the main interface, the last interaction is the menu and toolbar buttons; each of the relevant functions returns <kbd>&gt; 0</kbd> when the item has been activated. We can add a click handler to the menu items as we did with the <span class="packt_screen">Quit</span> item earlier:</p>
<pre><span>   if </span>nk.NkMenuItemLabel(ctx<span>, </span><span>"Quit"</span><span>, </span>nk.<span>TextAlignLeft</span>) &gt; <span>0 </span>{<br/>      win.SetShouldClose(<span>true</span>)<br/>   }</pre>
<p>The same pattern can be used for toolbar buttons. For the <span class="packt_screen">New</span> button, we set a compose window to appear when it's tapped. As we need to maintain all state locally, you'll see that the button tap here is setting a <kbd>composeUI</kbd> instance (a custom type for the compose state); this will be used in the following to decide whether we should open a compose window:</p>
<pre><span>   if </span>nk.NkButtonLabel(ctx<span>, </span><span>"New"</span>) &gt; <span>0 </span>{<br/>      compose = newComposeUI(this)<br/>   }</pre>
<p>As the Nuklear backends typically don't support multiple native operating system windows, we need to load our compose window within the main GoMail user interface. After the main interface layout code has run, we can insert a new check for the <kbd>compose</kbd> value that we set before. When this value is <kbd>nil</kbd>, we have no compose window to show, but when it has been set, we'll create a second window within the first:</p>
<pre>   ...<br/>   nk.NkEnd(ctx)<br/><br/><span>   if </span>compose != nil {<br/>      drawCompose(ctx)<br/>   }<br/><br/>   ...</pre>
<p>The preceding code executes after the main window (marked by <kbd>NkEnd()</kbd>). If a compose state is set, we'll need to call the new <kbd>drawCompose()</kbd> function:</p>
<pre><span>func </span>(ui *<span>mainUI</span>) <span>drawCompose</span>(ctx *nk.<span>Context</span>) {<br/>   bounds := nk.NkRect(<span>20</span><span>, </span><span>20</span><span>, </span><span>400</span><span>, </span><span>320</span>)<br/>   update := nk.NkBegin(ctx<span>, </span><span>"Compose"</span><span>, </span>bounds<span>, </span>nk.<span>WindowNoScrollbar | nk.WindowBorder </span>| nk.<span>WindowTitle </span>| nk.<span>WindowMovable </span>| nk.<span>WindowMinimizable</span>)<br/><br/>   <span>if </span>update &gt; <span>0 </span>{<br/>      compose.drawLayout(ctx<span>, </span><span>296</span>)<br/>   }<br/><br/>   nk.NkEnd(ctx)<br/>}</pre>
<p>This new function sets up a sub-window and then calls the <kbd>drawComposeLayout()</kbd> that we defined earlier—now renamed <kbd>drawLayout()</kbd> within a new <kbd>composeUI</kbd> type. We need to encapsulate the compose state (the data buffers we declared earlier) in a separate type; this allows us to track changes made in multiple compose windows (as the compose window has no state).</p>
<p>To change email based on the selected item in the list, we can change <kbd>NkLabel</kbd> to <kbd>NkSelectableLabel</kbd>. This widget takes an additional parameter for whether or not it's selected and will return a non-zero value if the selection is changed to the specified item. The update list code should look like this (a little extra code is required to convert from <kbd>bool</kbd> into <kbd>int32</kbd>):</p>
<pre><span>   for </span>_<span>, </span>email := <span>range </span>ui.server.ListMessages() {<br/>      <span>var </span>selected <span>int32<br/></span><span>      </span><span>if </span>email == ui.current {<br/>         selected = <span>1<br/></span><span>      </span>}<br/>      <span>if </span>nk.NkSelectableLabel(ctx<span>, </span>email.Subject<span>, </span>nk.<span>TextAlignLeft</span><span>, </span>&amp;selected) &gt; <span>0 </span>{<br/>         ui.current = email<br/>      }<br/>   }</pre>
<p>With all of our data loaded and the compose window opened from the <span class="packt_screen">New</span> toolbar or menu item, we see something like the following:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/31557268-0d77-48cb-885f-1d015103c922.png" style="width:35.58em;height:18.67em;" width="600" height="316"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Our completed GoMail app with nk showing a compose window</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background processing</h1>
                </header>
            
            <article>
                
<p>One of the benefits of an immediate mode user interface toolkit is that there's no hidden state. When we see a new email arrive, we don't have to communicate the change to a list widget (or equivalent) to instruct it to add a new row. As long as the model data updates when an event occurs, there's no additional work to do. Our nk code will automatically add the new data on the next frame and so the user interface will refresh accordingly.</p>
<p>This also means that we don't have to handle multiple thread complications in our user interface code. If you ensure that any model data is thread-safe (using standard Go tools) then the user interface will continue to render from the main thread on each refresh. It's a requirement that all render code runs on the same thread, but that's unlikely to be a problem due to the way the toolkit is designed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at the second toolkit of three that were designed to break away from the traditional toolkits that we looked at in <a href="36bfea00-c659-4569-864c-de2c460c7467.xhtml">Section <em>2</em></a><em>, <span>Toolkits Using Existing Widgets</span>.</em> The Nuklear project primarily targets embedded applications but we saw that, in many ways, it's a possible fit for desktop applications. Its bespoke widget design means that applications will look identical across all supported operating systems, which is a longer list than Shiny<span>—</span>including Android for mobile development.</p>
<p>We explored how the Nuklear framework is designed and how it interacts with various backends that provide the actual drawing and user input implementation. We examined the main API features, including its drawing capabilities, the widgets it includes, and the layout algorithms that it provides for constructing user interfaces. We then implemented the same GoMail project that was created in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk - Building Graphical Windows Applications</em><em>,</em> through to <a href="68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml">Chapter 7</a>, <em>Go-Qt - Multiple Platforms with Qt</em>, working through the nk APIs and features to create a complete application. There were many differences when working with an immediate mode GUI framework but, in many ways, it was easier to implement our basic application.</p>
<p>In the next chapter, we'll look at <strong>Fyne</strong>, the last toolkit that we'll explore in detail. As with Shiny, it's a material design inspired widget library but, similar to Nuklear, its focus is on providing a complete widget toolkit.</p>


            </article>

            
        </section>
    </div>



  </body></html>