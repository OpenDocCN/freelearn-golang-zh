- en: nk - Nuklear for Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nk - Nuklear for Go
- en: Nuklear is a lightweight widget library that focuses purely on the graphical
    interface. It provides a rich widget toolkit that renders identically across all
    supported platforms. Originally designed for embedded systems, it avoids the complications
    of application life cycles and windows and managing user interaction to keep its
    API focused and completely platform-independent. Its implementation has no dependencies
    and achieves this by avoiding a platform-specific render library or operating
    system drivers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Nuklear 是一个专注于图形界面的轻量级小部件库。它提供了一个丰富的工具包，可以在所有支持的平台上以相同的方式渲染。最初是为嵌入式系统设计的，它避免了应用程序生命周期、窗口和用户交互的复杂性，以保持其
    API 焦点和完全平台无关。其实施没有依赖关系，通过避免特定平台的渲染库或操作系统驱动程序来实现这一点。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The design and purpose of the Nuklear project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuklear 项目的设计和目的
- en: Getting set up with Nuklear and the Go bindings, nk
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nuklear 和 Go 绑定进行设置，nk
- en: How to create a render context and use the toolkit widgets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建渲染上下文并使用工具包小部件
- en: Building a complete application using nk
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 nk 构建 complete application
- en: By the end of this chapter, you'll have created an nk-based application using
    an OpenGL backend that will work across all mainstream desktop operating systems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将创建一个使用 OpenGL 后端且可在所有主流桌面操作系统上运行的基于 nk 的应用程序。
- en: Background and design of Nuklear
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nuklear 的背景和设计
- en: Nuklear was designed to build graphical user interfaces for embedded applications
    and games. It aims to be lightweight and completely platform agnostic. It manages
    this by leaving the window management, operating system-specific methods, and
    even the render driver to separate modules or the applications that use the library.
    Many of these features are provided by add-on modules; due to Nuklear's popularity,
    there are many render drivers to choose from (some are operating system-specific
    and others work across multiple platforms). Nuklear has been made available within
    the public domain, which also makes it an attractive option for embedding within
    commercial software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Nuklear 是为构建嵌入式应用程序和游戏图形用户界面而设计的。它旨在轻量级且完全平台无关。它通过将窗口管理、操作系统特定的方法和甚至渲染驱动程序留给单独的模块或使用库的应用程序来管理这一点。许多这些功能都由附加模块提供；由于
    Nuklear 的流行，有众多渲染驱动程序可供选择（一些是针对特定操作系统的，而另一些可以在多个平台上工作）。Nuklear 已在公共领域内提供，这也使其成为嵌入商业软件中的有吸引力的选择。
- en: 'Nuklear provides many widgets, layouts, and features for creating rich application
    GUIs that can also be skinned to suit the application design. The following screenshot
    is an example of the standard interface design: more can be found in the gallery
    section of the project website at [https://github.com/vurtun/nuklear#gallery](https://github.com/vurtun/nuklear#gallery):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Nuklear 提供了许多小部件、布局和功能，用于创建丰富的应用程序 GUI，这些 GUI 还可以根据应用程序设计进行皮肤化。以下截图是标准界面设计的示例：更多内容可以在项目网站上的画廊部分找到：[https://github.com/vurtun/nuklear#gallery](https://github.com/vurtun/nuklear#gallery)
- en: '![](img/10efe27e-4836-49a2-bea3-f559b6c40780.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10efe27e-4836-49a2-bea3-f559b6c40780.png)'
- en: A screenshot of Nuklear widgets from the project website (Copyright: Micha Mettke)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 项目网站上的 Nuklear 小部件截图（版权：Micha Mettke）
- en: Alongside the differences that the Nuklear design has to other toolkits we've
    explored, there's a larger distinction—Nuklear is an *immediate mode* GUI toolkit.
    In comparison, the other toolkits we've worked with in this book have all been
    *retained mode* user interfaces. With a retained mode API, the developer describes
    the application GUI by creating objects such as buttons and input boxes, arranging
    them in layouts, and then the toolkit will draw these features to screen. When
    an event occurs, the toolkit will change the state of an item and the resulting
    graphical changes will be reflected onscreen, optionally sending the changes to
    the application code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与其他我们探索过的工具包相比的差异之外，还有一个更大的区别——Nuklear 是一个 *即时模式* GUI 工具包。相比之下，我们在本书中使用的其他工具包都是
    *保留模式* 用户界面。在保留模式 API 中，开发者通过创建按钮和输入框等对象、将它们排列在布局中，然后工具包将绘制这些功能到屏幕上来描述应用程序 GUI。当发生事件时，工具包将更改项目的状态，结果图形变化将在屏幕上反映出来，可选地将更改发送到应用程序代码。
- en: When using an immediate mode library, there's no state retained. The application
    developer doesn't create buttons and widgets for later use; instead, these widgets
    are defined during the render process purely for the next graphical update. At
    a glance, this may seem inefficient but it's actually a very good match for how
    graphical render pipelines function and so can be far more efficient. It's also
    a less memory-intensive process as there's no additional structure in memory representing
    the whole application GUI. The main impact of this decision, as we'll see later,
    is how the code that creates a GUI is laid out and how events are handled. Rather
    than try and describe this further, you can see it in action later in this chapter
    (in the *Code* section of *Getting started with nk*).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用即时模式库时，没有状态被保留。应用程序开发者不会创建按钮和控件以供以后使用；相反，这些控件在渲染过程中被定义，纯粹是为了下一次图形更新。乍一看，这似乎效率不高，但实际上这与图形渲染管道的工作方式非常匹配，因此可以更加高效。它也是一个更节省内存的过程，因为没有在内存中代表整个应用程序GUI的额外结构。这个决定的主要影响，正如我们稍后将会看到的，是如何布局创建GUI的代码以及如何处理事件。与其进一步描述，你可以在本章后面的部分（在“入门nk”的*代码*部分）看到它的实际操作。
- en: Rendering and platform support
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染和平台支持
- en: The core of the Nuklear library's flexibility is its modular design. The library
    doesn't render to screen nor does it manage user input; such functionality is
    provided by modules that accompany the library. An application will typically
    utilize the core Nuklear library for widgets and layout as well as one of its
    render modules to control the opening of windows, rendering, and handling user
    input.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Nuklear库灵活性的核心是其模块化设计。库不会将内容渲染到屏幕上，也不会管理用户输入；此类功能由伴随库的模块提供。应用程序通常会利用Nuklear库的核心功能来处理小部件和布局，以及其中一个渲染模块来控制窗口的打开、渲染和处理用户输入。
- en: Rendering modules
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染模块
- en: 'The Nuklear project includes many rendering modules that provide support for
    various different environments or operating systems. At the time of writing, you
    can choose from the following backends:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Nuklear项目包括许多渲染模块，为各种不同的环境或操作系统提供支持。在撰写本文时，你可以从以下后端中进行选择：
- en: 'Windows:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：
- en: '**Graphics Device Interface **(**GDI**)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形设备接口**（**GDI**）'
- en: GDI+
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDI+
- en: '**Direct3D **(**D3D**)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Direct3D**（**D3D**）'
- en: 'Linux or Unix:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux或Unix：
- en: X11
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: X11
- en: X11 OpenGL
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: X11 OpenGL
- en: 'Games development:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开发：
- en: Allegro
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Allegro
- en: 'Cross-platform development:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台开发：
- en: '**Simple DirectMedia Layer **(**SDL**)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单直接媒体层**（**SDL**）'
- en: '**Simple and Fast Multimedia Library **(**SFML**)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单快速多媒体库**（**SFML**）'
- en: '**Graphics Library Framework **(**GLFW**)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形库框架**（**GLFW**）'
- en: Some of the renderers are 3D accelerated and others aren't, some focus on embedded
    and low power devices, others for desktop or smart phone type devices. As the
    GLFW module supports most desktop operating systems (and some smart phones), we'll
    use this module for the following chapter. If you choose to use a different module,
    then the application life cycle code should be adapted, but the nk code we'll
    explore remains the same.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些渲染器是3D加速的，而另一些则不是，一些专注于嵌入式和低功耗设备，而另一些则针对桌面或智能手机类型的设备。由于GLFW模块支持大多数桌面操作系统（以及一些智能手机），我们将使用此模块来编写下一章。如果你选择使用不同的模块，那么应用程序生命周期代码应该进行适配，但我们将探索的nk代码保持不变。
- en: Supported platforms
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持的平台
- en: With such a wide range of renderers available for the toolkit, Nuklear offers
    exceptional coverage for various different operating systems. With support available
    for Windows, Linux, macOS, BSD, iPhone, and Android, it offers better support
    for multiple platforms than other libraries we've explored. By selecting the cross-platform
    GLFW Nuklear module, we've reduced the possible number of platforms slightly but
    it'll still support Windows, macOS, and Linux desktop applications as well as
    Android for mobile applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工具包提供了如此广泛的渲染器，Nuklear为各种不同的操作系统提供了卓越的覆盖范围。它支持Windows、Linux、macOS、BSD、iPhone和Android，为多个平台提供的支持比我们探索的其他库更好。通过选择跨平台的GLFW
    Nuklear模块，我们略微减少了可能支持的平台数量，但它仍然支持Windows、macOS和Linux桌面应用程序以及Android移动应用程序。
- en: The GLFW library has Go bindings that work alongside the OpenGL Go bindings
    (both are by the same authors). For most platforms, they don't rely on any external
    packages or libraries being installed. This is a huge benefit to getting up and
    running fast with nk, as we don't need to install additional packages or configure
    our development environment. So, let's get started.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GLFW 库有 Go 绑定，可以与 OpenGL Go 绑定一起使用（两者都是由同一作者编写的）。对于大多数平台，它们不依赖于安装任何外部包或库。这对于快速使用
    nk 来说是一个巨大的好处，因为我们不需要安装额外的包或配置我们的开发环境。所以，让我们开始吧。
- en: Getting started with nk
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 nk
- en: To use GLFW and Go-GL, we'll need to link to some C APIs; however, these aren't
    (on most systems) external libraries. The fact that the only native dependency
    is the OpenGL native library (which is typically part of the operating system),
    and any intermediate libraries are embedded within the Go projects, means that
    all we need to prepare is CGo.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 GLFW 和 Go-GL，我们需要链接到一些 C API；然而，这些在大多数系统上不是外部库。唯一的原生依赖项是 OpenGL 原生库（通常是操作系统的一部分），任何中间库都嵌入在
    Go 项目中，这意味着我们只需要准备 CGo。
- en: Prerequisites
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预先条件
- en: As the renderer we'll use for nk requires access to native C APIs, we'll need
    CGo to be correctly functioning for our applications to build. On most platforms,
    this simply means installing a compatible C compiler. This is only a development
    dependency and there's no installation required for the users of applications
    that we build with nk (other than an OpenGL compatible system). If you've worked
    through previous chapters of this book, then you probably have this set up already.
    If not, or you're unsure, then follow the steps in the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml),
    *Installation Details*, in the *Setting up CGo* section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将为 nk 使用需要访问原生 C API 的渲染器，我们需要 CGo 正确运行，以便我们的应用程序能够构建。在大多数平台上，这意味着安装一个兼容的
    C 编译器。这只是一个开发依赖项，我们构建的应用程序的用户（除了需要一个兼容 OpenGL 的系统之外）不需要安装。如果你已经完成了这本书的前几章，那么你可能已经设置了这些。如果没有，或者你不确定，那么请遵循
    *设置 CGo* 部分的 [附录](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml) 中 *安装细节* 部分的步骤。
- en: Some platforms will require additional development files to be installed for
    the operating system-specific portions of the code to compile correctly. macOS
    and Windows developers can skip this section as the development environment for
    CGo provides all that's required. Linux or Android developers may require additional
    steps, as follows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台将需要安装额外的开发文件，以便正确编译代码的操作系统特定部分。macOS 和 Windows 开发者可以跳过这一部分，因为 CGo 的开发环境已经提供了所有所需的内容。Linux
    或 Android 开发者可能需要采取以下额外步骤。
- en: Linux
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: To use nk on Linux, we need to ensure some additional development headers are
    installed. Due to the GLFW dependency on Xorg for window management and input
    handling, we'll need to be able to compile against its libraries. If your distribution
    packages development headers separately to the library, you'll need to ensure
    that they're installed for compilation to succeed. The required package is called
    `xorg-dev` on Debian or Ubuntu, `xorg-server-devel` for Arch Linux, and `xorg-x11-server-devel`
    on Fedora or CentOS.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 上使用 nk，我们需要确保安装一些额外的开发头文件。由于 GLFW 依赖于 Xorg 进行窗口管理和输入处理，我们需要能够编译其库。如果你的发行版将开发头文件与库分开打包，你需要确保它们已安装，以便编译成功。所需的包在
    Debian 或 Ubuntu 上称为 `xorg-dev`，在 Arch Linux 上称为 `xorg-server-devel`，在 Fedora 或
    CentOS 上称为 `xorg-x11-server-devel`。
- en: 'Therefore, one of the following should correctly install the development dependencies:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下任一命令都应正确安装开发依赖项：
- en: 'For Debian or Ubuntu, use this:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Debian 或 Ubuntu，请使用以下命令：
- en: '`sudo apt-get install xorg-dev`'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sudo apt-get install xorg-dev`'
- en: 'For Arch Linux (this will probably already be installed), use the following:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Arch Linux（这可能会已经安装），请使用以下命令：
- en: '`sudo pacman -S xorg-server-devel`'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sudo pacman -S xorg-server-devel`'
- en: 'For Fedora or CentOS, use this:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Fedora 或 CentOS，请使用以下命令：
- en: '`sudo yum install xorg-x11-server-devel`'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sudo yum install xorg-x11-server-devel`'
- en: If the `sudo` command can't be found, then try `su -c` instead. Once this library
    is installed, you should be able to follow the setup steps in the next section
    and run an nk example application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到 `sudo` 命令，请尝试 `su -c`。一旦安装了这个库，你应该能够遵循下一节的设置步骤并运行一个 nk 示例应用程序。
- en: macOS and Windows
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS 和 Windows
- en: Once you have Go and CGo set up on your computer, there are no additional prerequisites
    so you can jump to the following *Setup* section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在计算机上设置了 Go 和 CGo，就没有其他预先条件了，你可以跳到以下 *设置* 部分。
- en: Android
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android
- en: 'To build an Android app using nk, there are some additional steps required.
    Development of mobile apps is out of scope for this book but, for the curious,
    these steps are included to get you started. First, you must have the Android
    **Software Development Kit **(**SDK**) and **Native Development Kit **(**NDK **)
    installed. The easiest way may be to install Android Studio (available from [https://developer.android.com/studio/](https://developer.android.com/studio/))
    and use the built-in SDK Manager (under SDK Tools) to install the `NDK` packages
    as well:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用nk构建Android应用程序，需要一些额外的步骤。移动应用程序的开发不在此书的范围之内，但对于好奇的人来说，这些步骤包括在内，以帮助您开始。首先，您必须安装Android
    **软件开发工具包**（**SDK**）和**本地开发工具包**（**NDK**）。最简单的方法可能是安装Android Studio（可在[https://developer.android.com/studio/](https://developer.android.com/studio/)获取）并使用内置的SDK
    Manager（在SDK工具下）安装`NDK`包：
- en: '![](img/eb9903a7-d7e3-4258-be96-205a2ee597be.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb9903a7-d7e3-4258-be96-205a2ee597be.png)'
- en: Ensure that the NDK package is installed and up to date for Android nk development
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 确保安装了最新版本的NDK包，以便进行Android nk开发
- en: 'The following steps will be needed to complete the `nk-android` build, which
    should result in a complete development environment. Building the toolchain requires
    `ANDROID_HOME` and `NDK` environment variables to be set and your `PATH` to be
    updated correctly. You may not need to set up all of these environment variables
    as they may already be configured if you''ve completed previous Android projects.
    Further documentation is available at [https://github.com/golang-ui/nuklear#android-demo](https://github.com/golang-ui/nuklear#android-demo):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下步骤以完成`nk-android`构建，这将导致一个完整的发展环境。构建工具链需要设置`ANDROID_HOME`和`NDK`环境变量，并正确更新您的`PATH`。您可能不需要设置所有这些环境变量，因为如果您已经完成了之前的Android项目，它们可能已经配置好了。更多文档可在[https://github.com/golang-ui/nuklear#android-demo](https://github.com/golang-ui/nuklear#android-demo)找到：
- en: '![](img/b9c94378-c2be-4b60-9928-04b214c8a936.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9c94378-c2be-4b60-9928-04b214c8a936.png)'
- en: Setting up an Android environment and building the nk-android toolchain
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Android环境和构建nk-android工具链
- en: This should prepare your desktop for Android development using nk and Go. The
    rest of this chapter focuses on desktop development, but if the tools are working
    correctly, you should be able to adapt the instructions to Android NDK-based deployment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该为使用nk和Go进行Android开发准备您的桌面。本章的其余部分专注于桌面开发，但如果工具运行正确，您应该能够将说明适应基于Android NDK的部署。
- en: Now that the prerequisites for your platform are complete, let's set up nk and
    run our first example application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的平台准备工作已经完成，让我们设置nk并运行我们的第一个示例应用程序。
- en: Setup
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Setting up the `nk` package to use Nuklear from Go is as simple as installing
    the `github.com/golang-ui/nuklear/nk` package with the standard `go` tools:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将`nk`包设置为从Go使用Nuklear，就像使用标准`go`工具安装`github.com/golang-ui/nuklear/nk`包一样简单：
- en: '![](img/69c2318b-b86b-4be3-a3f1-7444d9aee95e.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69c2318b-b86b-4be3-a3f1-7444d9aee95e.png)'
- en: Installing nk is straightforward if you already have CGo up and running
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装并运行了CGo，安装nk就非常直接
- en: Now that you have the library installed, let's run an example to see nk in action.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了库，让我们运行一个示例来看看nk的实际应用。
- en: Example
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'The Go Nuklear bindings project provides an example application to demonstrate
    some widgets; we can use this to quickly check that things are working. With the
    previous setup steps complete, running the demo is as simple as installing the
    Go project and running it. The code is located in the `cmd/nk-example` sub-project
    of [github.com/golang-ui/nuklear](https://github.com/golang-ui/nuklear); we can
    use `go install` to download and install the example and run it using `nk-example`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Go Nuklear绑定项目提供了一个示例应用程序来演示一些小部件；我们可以使用这个来快速检查一切是否正常工作。在完成之前的设置步骤后，运行演示就像安装Go项目并运行它一样简单。代码位于[github.com/golang-ui/nuklear](https://github.com/golang-ui/nuklear)的`cmd/nk-example`子项目中；我们可以使用`go
    install`下载并安装示例，然后使用`nk-example`运行：
- en: '![](img/ba9af3dc-3e4f-4d93-a306-0f784f6fea54.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba9af3dc-3e4f-4d93-a306-0f784f6fea54.png)'
- en: Installing and running a nuklear example is trivial once CGo is set up
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好CGo，安装和运行nuklear示例就非常简单
- en: 'Running the preceding commands should result in the following example window
    appearing on your screen. This example shows some of the widgets provided by the
    Nuklear toolkit, including embedded windows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令应该在您的屏幕上出现以下示例窗口。此示例展示了Nuklear工具包提供的一些小部件，包括嵌入的窗口：
- en: '![](img/f916d590-96f5-46fa-bf34-71abac948cbf.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f916d590-96f5-46fa-bf34-71abac948cbf.png)'
- en: The nk-example application running on Linux
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上运行的nk-example应用程序
- en: Code
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'To get started with our first nk application, there''s a certain amount of
    setup code we need to write. Nuklear is focused on delivering a graphical toolkit
    API and not the operating system-specific code such as managing windows and user
    input. To avoid having to write all of that code ourselves, we''ll use the `glfw`
    Go bindings to create and show a window for our application. The following code
    will set up an application window and show it (without any content). We also need
    to call `runtime.LockOSThread()` as this setup code must all execute on the main
    thread:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的第一个nk应用程序，我们需要编写一定数量的设置代码。Nuklear专注于提供图形工具包API，而不是操作系统特定的代码，例如管理窗口和用户输入。为了避免必须自己编写所有这些代码，我们将使用
    `glfw` Go绑定来创建并显示我们的应用程序窗口。以下代码将设置应用程序窗口并显示它（没有任何内容）。我们还需要调用 `runtime.LockOSThread()`，因为此设置代码必须在主线程上执行：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After initializing `glfw`, we need to create a window, which `glfw.CreateWindow()`
    handles for us. We specify the window size and title in the first three parameters.
    The fourth parameter is used for fullscreen windows; by passing a `*glfw.Monitor`
    reference, we request a window that fills the specified monitor in its default
    video mode. The final parameter is related to *context sharing, *passing an existing
    `*glfw.Window` reference requests that this new window shares the same graphical
    context to reuse textures and other resources. We then make the new window current
    so that its context is used in the following code. Note that the window may not
    exactly match the requested parameters (exact window size or monitor modes may
    not be supported), so it's important to check these values after creation rather
    than assume the result.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 `glfw` 之后，我们需要创建一个窗口，这由 `glfw.CreateWindow()` 为我们处理。我们在前三个参数中指定窗口大小和标题。第四个参数用于全屏窗口；通过传递一个
    `*glfw.Monitor` 引用，我们请求一个窗口，该窗口在其默认视频模式下填充指定的监视器。最后一个参数与 *上下文共享* 相关，传递一个现有的 `*glfw.Window`
    引用请求这个新窗口共享相同的图形上下文以重用纹理和其他资源。然后我们使新窗口成为当前窗口，以便其上下文在下面的代码中使用。请注意，窗口可能不会完全符合请求的参数（精确的窗口大小或监视器模式可能不受支持），因此创建后检查这些值而不是假设结果是很重要的。
- en: The other setup we must do is to create an OpenGL context that the Nuklear code
    can utilize. For this task, we'll import the `go-gl` library (by the same authors
    as the `glfw` Go bindings). We initialize the OpenGL library ready to use the
    context from the window that was created by `glfw`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的其他设置是创建一个OpenGL上下文，Nuklear代码可以利用它。为此任务，我们将导入 `go-gl` 库（由与 `glfw` Go绑定相同的作者编写）。我们初始化OpenGL库，准备使用由
    `glfw` 创建的窗口的上下文。
- en: 'Additionally, the `nk` package needs to be initialized and we need to set up
    a default font. Thankfully, Nuklear has a standard font packaged but we need to
    run some code to set it as the default (or load a custom one for our application):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`nk` 包需要初始化，并且我们需要设置一个默认字体。幸运的是，Nuklear提供了一个标准字体包，但我们需要运行一些代码来将其设置为默认字体（或者为我们的应用程序加载一个自定义字体）：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With all of the setup done, the window still looks the same as we haven''t
    yet rendered any content. To actually run a Nuklear application, we need to add
    a run-loop that handles event management and GUI refreshing. The following code
    isn''t the simplest possible event loop (it would be possible to use `for !win.ShouldClose()
    { ... }`, but that would consume a whole CPU!), but it''s reasonably efficient
    for the brevity. It sets up a loop that will check for any events and then refresh
    the user interface 30 times a second. The following code block completes our basic
    nk `main()` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有设置完成后，窗口看起来仍然和之前一样，因为我们还没有渲染任何内容。要实际运行一个Nuklear应用程序，我们需要添加一个处理事件管理和GUI刷新的运行循环。下面的代码并不是最简单的可能的事件循环（可以使用`for
    !win.ShouldClose() { ... }`，但那样会消耗整个CPU！），但它对于简洁性来说效率是合理的。它设置了一个循环，该循环将检查任何事件，然后每秒刷新用户界面30次。下面的代码块完成了我们的基本nk
    `main()` 函数：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code will run our application, but we haven''t defined the user
    interface. The call to a `draw()` function in the preceding code is the secret,
    so we should implement that now. Let''s look at the method in two parts: first,
    the GUI layout and second, the actual rendering. To set up our interface, we create
    a new *frame* (imagine a single snapshot of a video) that will be drawn on the
    next refresh of the user interface. After calling `nk.NkPlatformNewFrame()`, we
    can set up our interface; any code between `nk.NkBegin()` and `nk.NkEnd()` will
    be part of our UI update for the frame we just started. We can find out whether
    re-drawing is needed by checking the returned `update` variable; if it''s `0`,
    then no changes have occurred and we can skip the UI code.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将运行我们的应用程序，但我们还没有定义用户界面。在上述代码中调用`draw()`函数的秘密在于此，因此我们现在应该实现它。让我们将方法分为两部分来看：首先，GUI布局，其次，实际渲染。为了设置我们的界面，我们创建一个新的*框架*（想象一下视频的单个快照），它将在用户界面的下一次刷新时被绘制。在调用`nk.NkPlatformNewFrame()`之后，我们可以设置我们的界面；在`nk.NkBegin()`和`nk.NkEnd()`之间的任何代码都将是我们刚刚开始的框架的UI更新的一部分。我们可以通过检查返回的`update`变量来找出是否需要重新绘制；如果它是`0`，则没有发生变化，我们可以跳过UI代码。
- en: 'Inside the `if update > 0 { ... }` block, we lay out the application interface,
    two rows each containing a single cell. In the first row (created with `nk.NkLayoutRowStatic()`),
    we add an `nk.NkLabel` containing the text *Hello World!*. In the second, we create
    a Quit button using `nk.NkButtonLabel()`. As this is an immediate mode user interface,
    we don''t retain a reference to the button to check its state, nor do we pass
    an on-click handler; we simply check the return value from the widget draw function.
    The value that''s returned will be greater than `0` if the button has been clicked;
    and so we can place code inline that will tell the window to close and thereby
    close the application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if update > 0 { ... }`块内部，我们布局应用程序界面，每行包含一个单元格。在第一行（使用`nk.NkLayoutRowStatic()`创建），我们添加了一个包含文本*Hello
    World!*的`nk.NkLabel`。在第二行，我们使用`nk.NkButtonLabel()`创建了一个退出按钮。由于这是一个即时模式用户界面，我们不会保留按钮的引用以检查其状态，也不会传递点击处理程序；我们只需检查小部件绘制函数的返回值。如果按钮已被点击，则返回的值将大于`0`；因此，我们可以放置内联代码，告诉窗口关闭，从而关闭应用程序：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lastly, at the end of the `draw()` function, we need to ask our OpenGL viewport
    to render the created user interface. To do this, we set up the OpenGL viewport
    using `gl.Viewport()`—as you can see, we use the width and height parameters from
    the actual window size rather than assuming the size we requested at the beginning
    of this code is correct. Once the viewport is set up, we clear it and set a background
    color (using `gl.ClearColor()`). The main render work is handled by `nk.NkPlatformRender()`,
    which takes the frame that we defined previously and draws it into the current
    graphical context. This function requires that we specify buffer sizes for the
    vertex and element buffers. We pass numbers that will be large enough for our
    demonstration purposes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`draw()`函数的末尾，我们需要要求我们的OpenGL视口渲染创建的用户界面。为此，我们使用`gl.Viewport()`设置OpenGL视口——正如你所见，我们使用实际窗口大小的宽度和高度参数，而不是假设我们在代码开始时请求的大小是正确的。一旦视口设置好，我们就清除它并设置一个背景颜色（使用`gl.ClearColor()`）。主要的渲染工作由`nk.NkPlatformRender()`处理，它接受我们之前定义的框架并将其绘制到当前图形上下文中。此函数要求我们指定顶点和元素缓冲区的大小。我们传递的数字将足够大，以满足我们的演示目的。
- en: 'Finally, we cause the content to be shown by calling `win.SwapBuffers()`. As
    `glfw.Window` is *double buffered*, we''ve been drawing to a back buffer that''s
    currently off-screen. By calling swap, we''re moving the back buffer to the screen
    and setting the previously shown front buffer to be hidden, ready for the next
    frame to be drawn:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`win.SwapBuffers()`来显示内容。由于`glfw.Window`是*双缓冲*，我们一直在绘制一个当前不在屏幕上的后缓冲区。通过调用交换，我们将后缓冲区移动到屏幕上，并将之前显示的前缓冲区设置为隐藏，以便绘制下一帧：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That should complete the code for our *hello world* application. There was a
    lot of setup but the UI definition code was relatively succinct, so building more
    complex interfaces won't be much more work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就应该完成了我们的*Hello World*应用程序的代码。虽然设置了很多，但UI定义代码相对简洁，因此构建更复杂的界面不会增加太多工作量。
- en: Build and run
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 和 运行
- en: 'Simply build or run `hello.go` and you''ll see the expected Hello World window.
    Clicking the Quit button will tell the window to close which in turn will exit
    the application:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地构建或运行`hello.go`，你将看到预期的Hello World窗口。点击退出按钮将告诉窗口关闭，从而退出应用程序：
- en: '![](img/b23b3b61-32a0-4f24-8a9b-1168cdc29e3e.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b23b3b61-32a0-4f24-8a9b-1168cdc29e3e.png)'
- en: Hello world with nk
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nk的Hello World
- en: Cross-compiling
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉编译
- en: Compiling an nk-based application for a different operating system can be a
    complicated process due to its requirement to use CGo to communicate with native
    OpenGL libraries. However, if you've worked through [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml), *andlabs
    UI - Cross-platform Native UIs*, or [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    - Experimental Go GUI API*, this should already be set up. If you've jumped straight
    to this chapter, then you may need to follow the steps in the [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml),
    in the *Cross-Compiler Setup*. Once that's complete, you should have new compilers
    available (named `o32-clang` for macOS or `x86_64-w64-mingw32-gcc` for Windows)
    that are able to link to macOS Foundation APIs and Windows system calls respectively.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将基于nk的应用程序编译到不同的操作系统可能是一个复杂的过程，因为它需要使用CGo与本地OpenGL库进行通信。然而，如果你已经完成了[第5章](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml)，*andlabs
    UI - 跨平台原生UI*，或者[第8章](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml)，*Shiny - 实验性Go
    GUI API*，那么这些应该已经设置好了。如果你直接跳到了这一章，那么你可能需要遵循[附录](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml)中的步骤，在*交叉编译设置*中。一旦完成，你应该会有新的编译器可用（macOS上命名为`o32-clang`，Windows上命名为`x86_64-w64-mingw32-gcc`），它们能够分别链接到macOS
    Foundation API和Windows系统调用。
- en: 'To build the application, we now set up the `GOOS` and `CGO_ENABLED` flags
    as before, but also specify the compiler to use through an extra `CC` environment
    variable, setting it to `o32-clang` for the Darwin OS or `x86_64-w64-mingw32-gcc` for
    Windows. With that configuration complete, we can build our nk application for
    macOS and Windows from our Linux Terminal:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建应用程序，我们现在设置与之前相同的`GOOS`和`CGO_ENABLED`标志，但还通过额外的`CC`环境变量指定要使用的编译器，将其设置为Darwin
    OS的`o32-clang`或Windows的`x86_64-w64-mingw32-gcc`。完成此配置后，我们可以从Linux终端构建我们的nk应用程序用于macOS和Windows：
- en: '![](img/d60d7e5f-53e3-41b8-a37a-e3b7e1ea4390.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d60d7e5f-53e3-41b8-a37a-e3b7e1ea4390.png)'
- en: Compiling for Linux, macOS, and Windows from a Linux Terminal
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux终端编译Linux、macOS和Windows
- en: Now that we've built our first nk application, let's look further into what
    the underlying Nuklear library supports for building application GUIs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了第一个nk应用程序，让我们进一步了解底层Nuklear库支持构建应用程序GUI的功能。
- en: Widgets, layout, and skinning
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控件、布局和皮肤
- en: As the Nuklear library focuses purely on the widget aspects of an application
    toolkit, its capability in this area is comparable to that of more established
    application libraries. As you'll see in the following, there's a long list of
    widgets that can be included in any Nuklear application. As the nk bindings expose
    all of the library functionality, these features are all available to an nk application
    as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Nuklear库专注于应用程序工具包的控件方面，其在该领域的功能与更成熟的应用程序库相当。正如你将在下面看到的，有一个很长的控件列表可以包含在任何Nuklear应用程序中。由于nk绑定公开了所有库功能，这些功能对nk应用程序也是可用的。
- en: 'The GUI functionality is split into three broad areas: **widgets** (the main
    user interface elements), **drawing** (for drawing directly to the canvas), and
    **layout** (for arranging elements on screen). In this section, we''ll look at
    each area in turn, starting with the main widgets.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: GUI功能分为三个广泛领域：**控件**（主要用户界面元素）、**绘制**（直接绘制到画布上）和**布局**（在屏幕上排列元素）。在本节中，我们将依次查看每个领域，从主要控件开始。
- en: Widgets
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控件
- en: 'The Nuklear widgets (and the nk API presenting them) should in many ways be
    familiar. Sensible naming allows for many of these features to be discovered while
    programming in your favorite IDE, but let''s explore the main widgets and how
    they function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Nuklear控件（以及展示它们的nk API）在许多方面应该是熟悉的。合理的命名使得在您最喜欢的IDE中编程时可以发现许多这些功能，但让我们探索主要的控件及其功能：
- en: '| **Widget name** | **Description** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **控件名称** | **描述** |'
- en: '| `NkButtonLabel` | A standard push button widget, the API reports when it
    has been clicked. See `NkButtonImage` also (to use an image instead of a text
    label) and `NkButtonImageLabel` to include both. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `NkButtonLabel` | 一个标准的按钮控件，API报告了它何时被点击。参见`NkButtonImage`（使用图像而不是文本标签）和`NkButtonImageLabel`（包含两者）。|'
- en: '| `NkCheckboxLabel` | A checkbox displays a familiar box next to the label
    that''s either checked or not. The API reports when its value has changed. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `NkCheckboxLabel` | 复选框显示一个熟悉的框，旁边是标签，可以是勾选的或未勾选的。API报告其值何时发生变化。|'
- en: '| `NkColorPicker` | This is a special button that opens a color picker. This
    form returns the currently selected color, or you can use `NkColorPick`, which
    reports when the value changes. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `NkColorPicker` | 这是一个特殊的按钮，用于打开颜色选择器。此表单返回当前选定的颜色，或者您可以使用 `NkColorPick`，它会在值更改时报告。|'
- en: '| `NkComboBox` | This is a combobox container for dropping down a selection.
    Each item within it can contain text, an image, or both (see the APIs beginning
    with `NkComboItem`). |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `NkComboBox` | 这是一个下拉选择组合框容器。其中每个项目可以包含文本、图像或两者（请参阅以 `NkComboItem` 开头的 API）。|'
- en: '| `NkGroup(Begin/End)` | This adds a grouping for widgets in an interface.
    A group has a title and a scrollbar, if required. To manually control the scroll
    behavior, you can instead use `NkGroupScrolledBegin.` The widgets declared between
    begin and end will be included. The begin function returns `> 0` if the contents
    should be drawn.  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `NkGroup(Begin/End)` | 这为界面中的控件添加分组。一个分组有一个标题，如果需要，还有一个滚动条。要手动控制滚动行为，您可以使用
    `NkGroupScrolledBegin`。在开始和结束之间声明的控件将被包含。开始函数返回 `> 0` 如果内容应该被绘制。|'
- en: '| `NkImage` | This displays a simple image in the interface. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `NkImage` | 这在界面中显示一个简单的图像。|'
- en: '| `NkMenubar(Begin/End)` | For add a menu bar to the user interface, this requires
    the use of the various APIs beginning with `NkMenu` and `NkMenuItem` as well. The
    begin function returns `> 0` if the contents should be drawn. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `NkMenubar(Begin/End)` | 要向用户界面添加菜单栏，这需要使用以 `NkMenu` 和 `NkMenuItem` 开头的各种
    API。开始函数返回 `> 0` 如果内容应该被绘制。|'
- en: '| `NkPopup(Begin/End)` | This displays a popup over the current content; the
    widgets declared between begin and end will be included. The begin function returns
    `> 0` if the contents should be drawn. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `NkPopup(Begin/End)` | 这将在当前内容上显示一个弹出窗口；在开始和结束之间声明的控件将被包含。开始函数返回 `> 0` 如果内容应该被绘制。|'
- en: '| `NkRadioLabel` | A radio selection is like a combobox but offers multiple
    possible values, each added using this function. The return value indicates whether
    the specified item has been selected. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `NkRadioLabel` | 单选选择类似于组合框，但提供多个可能的值，每个值都使用此函数添加。返回值指示指定的项目是否已被选中。|'
- en: '| `NkSlider(Int/Float)` | The `NkSlider` functions add a slide bar with specified
    minimum, maximum, and current values. The API reports when the value has changed.
    An alternative format, `NkSlide(Int/Float)`, returns the current value. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `NkSlider(Int/Float)` | `NkSlider` 函数添加一个具有指定最小值、最大值和当前值的滑动条。API 报告值何时已更改。另一种格式
    `NkSlide(Int/Float)` 返回当前值。|'
- en: '| `NkTexteditString` | This is a text entry widget. This function requires
    a buffer to edit; this can more easily be set through `NkEditStringZeroTerminated()`.
    There are also many helpful APIs starting with `NkTextedit` that can be used to
    manage the text content. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `NkTexteditString` | 这是一个文本输入控件。此函数需要一个缓冲区来编辑；这可以通过 `NkEditStringZeroTerminated()`
    更容易地设置。还有许多以 `NkTextedit` 开头的有用 API，可以用来管理文本内容。|'
- en: '| `NkTree(Push/Pop)` | Tree widgets can be used to allow sections of the user
    interface to be expanded and collapsed or to present tree-based data on the screen.
    Functions beginning with `NkTreePush` mark the start of a new tree section and `NkTreePop`
    ends that section (or the root of the tree). The `TreeType` named `TreeNode` marks
    a user interface style tree and `TreeTab` is for data style tree. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `NkTree(Push/Pop)` | 树形控件可用于允许用户界面的部分被展开和折叠，或用于在屏幕上显示基于树的 数据。以 `NkTreePush`
    开头的函数标记新树部分的开始，而 `NkTreePop` 结束该部分（或树的根）。名为 `TreeNode` 的 `TreeType` 标记用户界面样式树，而
    `TreeTab` 用于数据样式树。|'
- en: '| Window (`NkBegin`, `NkEnd`) | A window is required to contain all widgets
    within Nuklear (anything declared outside this scope will be ignored or cause
    an error). A window is declared with `NkBegin` or `NkBeginTitled` and marked as
    complete with `NkEnd`. Various window management functions are available and they
    start with `NkWindow`. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Window (`NkBegin`, `NkEnd`) | 窗口（`NkBegin`，`NkEnd`）是必需的，以包含 Nuklear 中的所有小部件（在此作用域之外声明的任何内容都将被忽略或导致错误）。窗口通过
    `NkBegin` 或 `NkBeginTitled` 声明，并通过 `NkEnd` 标记为完成。提供了各种窗口管理函数，它们以 `NkWindow` 开头。|'
- en: As you can see, many of these widgets are straightforward. The more complex
    ones have semantics for opening and closing their definition that become familiar
    over time. This is due to the immediate mode nature of the API and its design
    to not retain any state. Common semantics are for containers to return a value
    greater than `0` when they need to be drawn. Similarly, items that respond to
    user events will return a non-zero value when they have been activated or changed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些部件中的许多都很直接。更复杂的部件具有随时间变得熟悉的打开和关闭其定义的语义。这是由于API的即时模式性质及其设计不保留任何状态。常见的语义是当容器需要绘制时返回大于
    `0` 的值。同样，对用户事件做出响应的项目在激活或更改时将返回非零值。
- en: Now that we've explored the widgets available, let's look at how we can arrange
    elements in our GUI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了可用的部件，让我们看看我们如何在我们GUI中排列元素。
- en: Layout
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: The layout system for Nuklear follows a simple rows and columns approach. To
    lay out widgets, each item should be within a row; columns are implicitly created
    when widgets are added according to the parameters set in the row configuration.
    When widgets are added to a row that's full, a new one will be automatically created
    with the same parameters as the previous. A new row may be started to change the
    parameters or to finish a previous row without filling the remaining columns.
    The basic layout is controlled by the NkLayoutRow API as described here; there's
    also a helpful template-based layout in `NkLayoutRowTemplate`, which we'll explore
    after that. Lastly, `NkLayoutSpace` allows directly setting widget locations and
    sizes—we'll explore that last.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Nuklear的布局系统遵循简单的行列方法。为了布局部件，每个项目都应该位于一行内；当根据行配置中设置的参数添加部件时，会隐式创建列。当向已满的行添加部件时，将自动创建一个新的行，其参数与上一个相同。可以通过更改参数或在不填满剩余列的情况下完成前一行的布局来开始一个新的行。基本的布局由这里描述的
    NkLayoutRow API 控制；还有一个有用的基于模板的布局在 `NkLayoutRowTemplate` 中，我们将在之后探索。最后，`NkLayoutSpace`
    允许直接设置部件的位置和大小——我们将最后探索这一点。
- en: NkLayoutRow
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NkLayoutRow
- en: The easiest approach to layout is to start a new row using `NkLayoutRowDynamic()`
    or `NkLayoutRowStatic()`. Both functions specify the number of cells in the row.
    The difference between the two is that the dynamic row allocation will split all
    of the space between the cells and resize them all as the window or container
    changes size. With a static arrangement, the sizes of all cells will remain the
    same irrespective of the container size. Widgets added after a row is started
    will append to the row, until it's full; if further widgets are appended, then
    a new row will be created for the new widgets. This continues until `NkLayoutRowEnd()` is
    called, or a different row configuration is started using one of these alternative
    functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 布局的简单方法是从使用 `NkLayoutRowDynamic()` 或 `NkLayoutRowStatic()` 开始新的一行。这两个函数都指定了行中的单元格数量。两者之间的区别在于，动态行分配将分割单元格之间的所有空间，并在窗口或容器大小改变时调整它们的大小。使用静态排列时，所有单元格的大小将保持不变，无论容器大小如何。在开始一行后添加的部件将附加到该行，直到它填满；如果进一步添加部件，则将为新部件创建一个新的行。这会一直持续到调用
    `NkLayoutRowEnd()` 或使用这些替代函数之一开始不同的行配置。
- en: Some added control is made possible by using the `NkLayoutRowBegin()` function
    to start a row; this specifies the row height and number of columns, but not how
    the columns will be sized. Cells are added to the row before widgets are appended
    by calling `NkLayoutRowPush()`; this sets a size or ratio for the next cell and
    should be followed by the declaration of a widget to fill the cell. This type
    of row should also conclude by calling `NkLayoutRowEnd()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `NkLayoutRowBegin()` 函数开始一行，可以增加一些控制；这指定了行高和列数，但并不指定列的大小。在通过调用 `NkLayoutRowPush()`
    将部件附加到行之前，会向行中添加单元格；这为下一个单元格设置大小或比例，并且应该随后声明一个部件来填充该单元格。这种类型的行也应该通过调用 `NkLayoutRowEnd()`
    来结束。
- en: Lastly, it's possible to call `NkLayoutRow` directly to set up the parameters
    for the following rows, static or dynamic sizing, and specified height or ratio
    with a specified number of columns.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以直接调用 `NkLayoutRow` 来设置后续行的参数，静态或动态大小，以及指定高度或比例和指定列数。
- en: NkLayoutRowTemplate
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NkLayoutRowTemplate
- en: A more powerful way to lay out rows is to use the template mechanism available.
    By calling `NkLayoutRowTemplateBegin()`, it's possible to set the template for
    all rows that follow. Column sizing is defined using one of three template functions.
    Firstly, `NkLayoutRowTemplatePushStatic()` specifies that widgets in this column
    should be of a fixed width. `NkLayoutRowTemplatePushDynamic()`, like the definition
    of dynamic allocation without templates, will split the row width among dynamic
    columns (this could be as little as `0` if no space is available). Finally, there's
    an additional call to the `NkLayoutRowTemplatePushVariable()`function; this will
    ensure that widgets get their minimum required space and will take up any extra
    space available (or split evenly across other variable width columns).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板机制是一种更强大的排列行的方法。通过调用`NkLayoutRowTemplateBegin()`，可以为所有后续行设置模板。列的大小是通过三种模板函数之一定义的。首先，`NkLayoutRowTemplatePushStatic()`指定该列中的小部件应具有固定宽度。`NkLayoutRowTemplatePushDynamic()`，类似于没有模板的动态分配定义，将行宽分配给动态列（如果没有可用空间，这可能是`0`）。最后，还有一个额外的调用`NkLayoutRowTemplatePushVariable()`函数；这将确保小部件获得它们所需的最小空间，并将占用任何额外的空间（或者平均分配给其他可变宽度列）。
- en: At the end of the template specification, you must call `NkLayoutRowTemplateEnd()`;
    this will indicate that any widgets added will start the creation of layout rows
    that follow the declared template. As before, if there are more widgets that fit
    in a row, then a new row will automatically be created and widgets will start
    to be added on this new row. Unlike the regular row layout functions before that
    specified the number of columns in a row, using this method will add as many widgets
    to a row as items exist in the template definition.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板指定的末尾，您必须调用`NkLayoutRowTemplateEnd()`；这将指示添加的任何小部件将开始创建声明模板之后的布局行。与之前一样，如果有更多小部件适合一行，则将自动创建新行，并且小部件将开始添加到新行。与之前指定行中列数的常规行布局函数不同，使用此方法将在行中添加与模板定义中项目数量一样多的小部件。
- en: NkLayoutSpace
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NkLayoutSpace
- en: Lastly, the space layout offers full control over the positioning and size of
    the items in your Nuklear application. The layout is started and ended like the
    previous row-based layout; use `NkLayoutSpaceBegin()` to start a space-based layout
    and `NkLayoutSpaceEnd()` to finish the layout. Before each widget you wish to
    add to your interface, call the `NkLayoutSpacePush()` function, passing `NkRect`,
    which specifies the size and position for the next widget to be added.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，空间布局提供了对Nuklear应用程序中项目位置和大小的完全控制。布局的起始和结束方式与之前的基于行的布局相同；使用`NkLayoutSpaceBegin()`开始基于空间布局，使用`NkLayoutSpaceEnd()`完成布局。在您希望添加到界面中的每个小部件之前，调用`NkLayoutSpacePush()`函数，传递`NkRect`，它指定下一个要添加的小部件的大小和位置。
- en: As well as the layout control functions, there are a number of helper functions
    that use the `NkLayoutSpace` API prefix. The most useful is `NkLayoutSpaceBounds()`—if
    called within a space layout, it'll return the total space that's available to
    work within. This is important if you wish to right- or bottom-align or position
    your widgets centrally within available space.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了布局控制函数外，还有许多使用`NkLayoutSpace` API前缀的辅助函数。最有用的是`NkLayoutSpaceBounds()`——如果在空间布局中调用，它将返回可用于工作的总空间。如果您希望右对齐或底对齐或在小部件中居中定位，这很重要。
- en: Those are all of the layout options that the nk API provides; let's look now
    at the drawing capabilities of the library.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是nk API提供的所有布局选项；现在让我们看看库的绘图功能。
- en: Drawing
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图
- en: The drawing API presents a fairly standard **two**-**dimensional** (**2D**)
    vector graphics library that's mostly used by the higher level widgets. As it's
    part of the public API, it's also possible to use them in your application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图API提供了一个相当标准的**二维**（**2D**）矢量图形库，主要用于高级小部件。由于它是公共API的一部分，因此也可以在您的应用程序中使用它们。
- en: Command queue
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令队列
- en: To draw custom areas of an application, our application will be interacting
    directly with the Nuklear draw command queue (the list of items to draw for rendering
    a frame of the user interface) so care is recommended. You can get access to `nk.CommandBuffer`, which
    is needed for each draw command by using the `NkWindowGetCanvas()` function. It's
    important that this is only called when a window is active (after `NkBegin` and before `NkEnd`).
    The positional values will need to be aware of other widgets and layouts loaded,
    which can get complicated very fast—it's easiest to draw using these commands
    only in an otherwise empty window so that you avoid drawing over other widgets.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制应用程序的定制区域，我们的应用程序将直接与Nuklear绘制命令队列（用于渲染用户界面帧的绘制项列表）交互，因此建议小心操作。您可以通过使用`NkWindowGetCanvas()`函数来获取访问`nk.CommandBuffer`的权限，这是每个绘制命令所需的。重要的是，这只能在窗口活动时调用（在`NkBegin`之后和`NkEnd`之前）。位置值需要了解其他加载的控件和布局，这可能会很快变得复杂——在通常空白的窗口中使用这些命令绘制是最简单的，这样可以避免覆盖其他控件。
- en: Draw functions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制函数
- en: 'If you want to go ahead and make use of these draw commands directly, you can
    use the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想直接使用这些绘制命令，可以使用以下方法：
- en: '| **Stroke function** | **Fill function** | **Notes** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **描边函数** | **填充函数** | **注意事项** |'
- en: '| `NkStrokeLine()` |  | Draw a single line segment in the specified color.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `NkStrokeLine()` |  | 使用指定颜色绘制单个线段。|'
- en: '| `NkStrokeCurve()` |  | Draw a single curve segment in the specified color.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `NkStrokeCurve()` |  | 使用指定颜色绘制单个曲线段。|'
- en: '| `NkStrokeRect()` | `NkFillRect()`, `NkFillRectMultiColor()`   | Draw a rectangle
    (or square) outline, or solid rectangle in the specified color(s). To draw an
    outlined, filled rectangle, call `NkFillRect()` and then `NkStrokeRect()` using
    the same coordinates. `NkFillRectMultiColor()` is a quick way to draw gradients
    in a rectangle. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `NkStrokeRect()` | `NkFillRect()`, `NkFillRectMultiColor()`   | 使用指定颜色（或颜色组合）绘制矩形（或正方形）轮廓，或实心矩形。要绘制轮廓填充的矩形，请先调用`NkFillRect()`，然后使用相同坐标调用`NkStrokeRect()`。`NkFillRectMultiColor()`是快速在矩形中绘制渐变的方法。|'
- en: '| `NkStrokeCircle()` | `NkFillCircle()` | Draw a circle (or ellipse) outline
    or fill in the specified color. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `NkStrokeCircle()` | `NkFillCircle()` | 使用指定颜色绘制圆（或椭圆）轮廓或填充。|'
- en: '| `NkStrokeArc()` | `NkFillArc()` | Outline, or fill, an arc around a central
    point in the specified color. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `NkStrokeArc()` | `NkFillArc()` | 在指定颜色中围绕中心点绘制轮廓或填充圆弧。|'
- en: '| `NkStrokeTriangle()` | `NkFillTriangle()` | Draw a triangle outline or a
    solid triangle in the specified color. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `NkStrokeTriangle()` | `NkFillTriangle()` | 使用指定颜色绘制三角形轮廓或实心三角形。|'
- en: '| `NkStrokePolyline()` |  | Draw a series of line segments in the specified
    color. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `NkStrokePolyline()` |  | 使用指定颜色绘制一系列线段。|'
- en: '| `NkStrokePolygon()` | `NkFillPolygon()` | Outline or fill a shape with a
    list of points defining its boundary. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `NkStrokePolygon()` | `NkFillPolygon()` | 使用定义边界的点列表绘制轮廓或填充形状。|'
- en: '| `NkDrawImage()` |  | Draw an image into a specified rectangle and background
    color. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `NkDrawImage()` |  | 在指定的矩形和背景颜色中绘制图像。|'
- en: '| `NkDrawText()` |  | Draw a text string with the specified background and
    foreground colors. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `NkDrawText()` |  | 使用指定的背景和前景颜色绘制文本字符串。|'
- en: 'Now that we''ve explored all of the widgets and drawing capabilities, we could
    jump right in to building a full application. However, Nuklear has one other cool
    feature that we should look at: the ability to change the interface design using
    skinning.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了所有的小部件和绘图功能，我们可以直接开始构建一个完整的应用程序。然而，Nuklear还有一个很酷的功能值得我们关注：使用皮肤化来改变界面设计。
- en: Skinning
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 皮肤化
- en: As well as defining its own style for the widgets included, Nuklear supports
    **skinning**—loading a theme to change how applications look. This is a powerful
    feature—very similar to the themes that we saw with GTK+ and Qt, but selected
    by the application instead of the end user. Any nk application developer looking
    to set up skinning for their application may find that it isn't easy to do—this
    is due to the way that most configuration is expose through C structures from
    the underlying Nuklear API. While these elements are mostly available through
    the Go API binding, it requires a lot of pointer conversion and unsafe assignments
    that could affect the stability of your application. It would be possible, however,
    to write some C code and include it in your application using CGo.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为包含的组件定义自己的样式外，Nuklear还支持**皮肤化**——加载主题以改变应用程序的外观。这是一个强大的功能——与我们在GTK+和Qt中看到的主题非常相似，但由应用程序而不是最终用户选择。任何希望为他们的应用程序设置皮肤化的nk应用程序开发者可能会发现这并不容易做到——这是由于大多数配置都是通过底层的Nuklear
    API从C结构中暴露出来的方式。虽然这些元素大多可以通过Go API绑定获得，但它需要大量的指针转换和不安全的赋值，这可能会影响应用程序的稳定性。然而，通过CGo，在应用程序中包含一些C代码是可能的。
- en: 'The following C code is extracted from a Nuklear skinning example in case a
    developer wishes to include a custom skin in their application and is willing
    to embed C in their Go code. The example uses a single texture image that defines
    all of the different images that together define the theme. Firstly, the texture
    must be loaded into the current OpenGL context and then the individual areas identified
    within the loaded texture, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下C代码是从Nuklear皮肤化示例中提取的，以防开发者希望在他们的应用程序中包含自定义皮肤并且愿意在Go代码中嵌入C。该示例使用单个纹理图像，该图像定义了所有定义主题的不同图像。首先，必须将纹理加载到当前OpenGL上下文中，然后识别加载纹理中的各个区域，如下所示：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code excerpt specifies only two sub-textures where, in real-life
    usage, there would be many more. After the textures are loaded, we define a style
    struct pointer that matches the widget to theme (here, we''re skinning the checkbox).
    The value of this pointer is then set to the location of the loaded style configuration
    (this is where it becomes very difficult to re-create in pure Go code). For each
    field in the struct, an appropriate image or color should be set:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段仅指定了两个子纹理，而在实际使用中会有更多。在纹理加载后，我们定义一个与主题匹配的样式结构指针（在这里，我们正在皮肤化复选框）。然后，将此指针的值设置为加载的样式配置的位置（这就是为什么在纯Go代码中很难重新创建）。对于结构中的每个字段，应设置适当的图像或颜色：
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same technique should be applied for all widgets that will be used in the
    application to be skinned. This is a lot of work and even the toolkit author warns
    against it at this time due to its time-consuming nature! Following is the style
    texture for the *Gwen* skin and a screenshot of an application with this theme
    loaded:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将相同的技巧应用于所有将在皮肤化应用程序中使用的组件。这是一项大量工作，甚至工具包的作者也警告说，由于耗时性，现在应避免这样做！以下是*Gwen*皮肤的样式纹理以及加载了此主题的应用程序的截图：
- en: '![](img/22ba1c35-a47a-4830-91a1-40e9b580807e.png)  ![](img/8f767dfc-54eb-4edc-b580-d1fab9748683.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/22ba1c35-a47a-4830-91a1-40e9b580807e.png) ![图片2](img/8f767dfc-54eb-4edc-b580-d1fab9748683.png)'
- en: The Gwen skin is used to demonstrate Nuklear skin capabilities (left); The Gwen
    skin in action (right)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Gwen皮肤用于演示Nuklear皮肤功能（左）；Gwen皮肤的实际应用（右）
- en: A complete implementation can be found in the examples repository at [https://github.com/vurtun/nuklear/blob/master/example/skinning.c](https://github.com/vurtun/nuklear/blob/master/example/skinning.c).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的实现可以在[https://github.com/vurtun/nuklear/blob/master/example/skinning.c](https://github.com/vurtun/nuklear/blob/master/example/skinning.c)的示例存储库中找到。
- en: Building a user interface
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: Let's return to our GoMail application again to try out the nk API. Nuklear
    is an established toolkit with a lot of functionality so it should be able to
    build the user interface just as well as previous examples. What we'll see as
    we build out this user interface is how different an immediate mode toolkit is,
    in how the code is arranged and how event handling is managed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回到我们的GoMail应用程序，尝试使用nk API。Nuklear是一个功能丰富的成熟工具包，因此它应该能够像之前的示例一样构建用户界面。当我们构建用户界面时，我们将看到即时模式工具包是如何不同的，包括代码的排列方式和事件处理的管理方式。
- en: 'We can start by copying the hello world application so we don''t have to re-work
    all of the setup code and life cycle management. As this application is going
    to contain many more graphical elements, we need to increase the buffer sizes
    that set using `NkPlatformRender()`. Replace the original line with the following
    for this example. In your own applications, this may need to be higher still—if
    the number is too low, you may notice graphical elements not showing or disappearing
    when popups and menu items appear:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先复制hello world应用程序，这样我们就不必重新编写所有的设置代码和生命周期管理。由于这个应用程序将包含更多的图形元素，我们需要增加使用`NkPlatformRender()`设置的缓冲区大小。在这个例子中，用以下行替换原始行。在你的应用程序中，这个值可能需要更高——如果数字太低，你可能注意到当弹出窗口和菜单项出现时，图形元素不会显示或消失：
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Layout
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'We''ll begin with the basic application layout; to start with, we update our
    `draw()` function to call a separate `drawLayout()` function where we''ll add
    our new code. This new function will need to be passed the height of the window
    to correctly fill the vertical space, as you''ll see later:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基本的应用布局开始；首先，我们将更新我们的`draw()`函数，以便调用一个单独的`drawLayout()`函数，在那里我们将添加我们的新代码。这个新函数需要传递窗口的高度以正确填充垂直空间，正如你稍后将会看到的：
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code is fairly standard for painting a window with nk. Let's jump
    straight into our new layout code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对于使用nk绘制窗口来说是相当标准的。让我们直接进入我们的新布局代码。
- en: Main email window
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要电子邮件窗口
- en: 'We start with a simple layout function called `drawLayout()`. This will set
    up the basic application layout similar to the GoMail design we created in [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications*. The beginning of the code sets out space for the menu and toolbar
    that will expand to stretch the width of our window. We then start a template
    layout using `NkLayoutRowTemplateBegin()` to have a fixed size column on the left
    for our email list and a wider, variable width column on the right that will expand
    as our window resizes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的布局函数`drawLayout()`开始。这将设置类似于我们在[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，*Walk
    - 构建图形窗口应用程序*中创建的GoMail设计的基本应用程序布局。代码的开始为菜单和工具栏留出空间，这些空间将扩展以填充窗口的宽度。然后我们开始使用`NkLayoutRowTemplateBegin()`启动一个模板布局，以便在左侧有一个固定大小的列用于我们的电子邮件列表，以及一个更宽的、可变宽度的列，当窗口调整大小时将扩展：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that, while the width of our layout can adjust automatically, the height
    isn't quite as flexible. For this example, we pass in the height of the window
    and deduct from that the height we're allocating for the toolbar. This total is
    passed to our template layout so it'll expand to the remaining window height.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们布局的宽度可以自动调整，但高度并不那么灵活。在这个例子中，我们传递窗口的高度并从中减去我们分配给工具栏的高度。这个总数传递给我们的模板布局，以便它扩展到剩余的窗口高度。
- en: In the first column of the main layout, we add a new group named `"Inbox"` for
    our email list and add three simple label items that represent the loaded list.
    Next, we add another group that will occupy the second space in the template layout.
    This code sets up a mix of one and two column rows that will display email content.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在主布局的第一列中，我们添加一个名为`"Inbox"`的新组用于我们的电子邮件列表，并添加三个简单的标签项来表示加载的列表。接下来，我们添加另一个将占用模板布局第二个空间的组。此代码设置了一组一列和两列的行，将显示电子邮件内容。
- en: 'We open the group and set up a simple dynamic row with a single column using
    `NkLayoutRowDynamic()`, inserting the `NkLabel` subject in that cell. Next, we
    add another template layout so we can have a narrow, fixed width column for our
    labels and a variable width column for the values. After that, `NkLabel` for the label
    and value can be inserted to form a grid. Lastly, we start another single column
    dynamic row for the main email content:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开组并使用`NkLayoutRowDynamic()`设置一个简单的动态行，包含一个列，并在该单元格中插入`NkLabel`主题。接下来，我们添加另一个模板布局，以便我们可以有一个窄的、固定宽度的列用于标签，以及一个可变宽度的列用于值。之后，`NkLabel`可以插入标签和值以形成一个网格。最后，我们开始另一个单列动态行用于主要电子邮件内容：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running the preceding code, along with the necessary boilerplate code from
    our *Hello world* example, should show a single window, looking a lot like the
    following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码，以及从我们的*Hello world*示例中必要的样板代码，应该显示一个窗口，看起来很像以下这样：
- en: '![](img/206a2e16-ca11-47b3-934d-3b3d778f88c5.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/206a2e16-ca11-47b3-934d-3b3d778f88c5.png)'
- en: The basic GoMail layout created with the nk API
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nk API创建的基本GoMail布局
- en: Email compose dialog
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件编写对话框
- en: 'To start our compose window layout, we create a new `drawComposeLayout()` function that
    (for testing) we can call instead of `drawLayout()` from the `draw()` function.
    Before we can add the text edit widgets that the email compose UI will use, we
    need to create buffers to manage the content they''ll edit. Remember that this
    is an immediate mode toolkit so, to remember any state, we must provide the data
    storage. This is where the compose window will store the subject, email address,
    and content for a new email message:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的 compose 窗口布局，我们创建一个新的 `drawComposeLayout()` 函数（用于测试，我们可以调用它而不是从 `draw()`
    函数中调用 `drawLayout()`）。在我们能够添加电子邮件编写 UI 将使用的文本编辑小部件之前，我们需要创建缓冲区来管理它们将编辑的内容。记住，这是一个即时模式工具包，因此，为了记住任何状态，我们必须提供数据存储。这就是
    compose 窗口将存储新电子邮件的主题、电子邮件地址和内容的地方：
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It''s also helpful to our user to provide a hint (often called a placeholder)
    for the user—to do this, we need to copy some data into the buffers before the
    draw loop begins:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，提供提示（通常称为占位符）也很有帮助——为了做到这一点，我们需要在绘制循环开始之前将一些数据复制到缓冲区中：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s look at the layout for the email compose window. The layout is similar
    to the content of our email display group in the previous layout code, setting
    up a dynamic row for the subject widget followed by a row template for the *To* label
    and email address entry. Instead of `NkLabel()`, this time we''re creating a text
    entry widget using `NkEditStringZeroTerminated()` with a number of parameters.
    The `nk.EditBox|nk.EditSelectable|nk.EditClipboard` flags tell Nuklear that we''re
    setting up an edit box where the text can be selected and interact with the system
    clipboard. We also need to tell the widget which buffer it should edit (in this
    case `composeSubject`) and what the maximum number of characters should be (which
    we set to the length of the buffer `int32(len(composeSubject))`). This is then
    repeated for the email and content input widgets:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看电子邮件编写窗口的布局。布局与我们之前布局代码中电子邮件显示组的布局相似，设置了一个动态行用于主题小部件，然后是一个行模板用于 *To*
    标签和电子邮件地址输入。这次，我们不是使用 `NkLabel()`，而是使用 `NkEditStringZeroTerminated()` 创建一个文本输入小部件，并带有多个参数。`nk.EditBox|nk.EditSelectable|nk.EditClipboard`
    标志告诉 Nuklear 我们正在设置一个可以选中文本并与系统剪贴板交互的编辑框。我们还需要告诉小部件它应该编辑哪个缓冲区（在这种情况下是 `composeSubject`）以及字符的最大数量应该是多少（我们将其设置为缓冲区的长度
    `int32(len(composeSubject))`）。然后，对于电子邮件和内容输入小部件，我们重复这个过程：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lastly, we need to add the buttons to the bottom of the screen—we use another
    row template for this. The variable space in this layout is set to be the size
    of the row, minus the size of our buttons, so that the buttons will align to the
    right. We insert an empty `NkLabel` in the first cell to work as a spacer. The
    two `NkButtonLabel()` function calls set up the buttons at the bottom-right of
    the layout:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将按钮添加到屏幕底部——我们为此使用另一个行模板。在这个布局中，变量空间被设置为行的大小减去我们按钮的大小，这样按钮就会对齐到右边。我们在第一个单元格中插入一个空的
    `NkLabel` 作为填充物。两个 `NkButtonLabel()` 函数调用设置了布局右下角的按钮：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With that layout code created, we can show the window and see an email Compose
    window like the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了布局代码后，我们可以显示窗口并看到一个类似于以下截图的电子邮件 Compose 窗口：
- en: '![](img/66a55ee0-7102-41cd-ba7a-a424bceb9da1.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66a55ee0-7102-41cd-ba7a-a424bceb9da1.png)'
- en: The basic Compose layout with the nk toolkit
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 nk 工具包的基本 Compose 布局
- en: Toolbar and menu
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具栏和菜单
- en: Adding a menu to an nk window is accomplished using `NkMenubarBegin()`, `NkMenuBeginLabel()`,
    and `NkMenuItemLabel()`, among others. The only difficult step in setting up a
    menu is that we also need to add an appropriate layout for the bar and its items.
    It's important (in fact, mandatory) that the bar is in a layout where `y=0`, so
    we immediately add a new row layout using dynamic sizing with `NkLayoutRowBegin()`.
    Then, we push the cell size for this layout using `NLayoutRowPush()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NkMenubarBegin()`、`NkMenuBeginLabel()` 和 `NkMenuItemLabel()` 等函数，可以在 nk
    窗口中添加菜单。设置菜单的难点在于我们还需要为栏和其项目添加适当的布局。重要的是（实际上，是强制性的），栏必须在一个 `y=0` 的布局中，所以我们立即使用
    `NkLayoutRowBegin()` 添加一个新的行布局，并使用动态大小。然后，我们使用 `NLayoutRowPush()` 推送这个布局的单元格大小。
- en: A menu item is opened using `NkMenuBeginLabel()` and we must check the return
    value for this function—`0` means that the menu is hidden. If it returns a non-zero
    value then we should lay out the menu below the bar. We start a new dynamic row
    layout with a single column using `NkLayoutRowDynamic()` to contain each menu
    item. Each menu item is then added using `NkMenuItemLabel()` with the appropriate
    label `string`. The return value for this function indicates whether the item
    has been clicked. If we get a non-zero value, then we should action the item—as
    shown by the
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NkMenuBeginLabel()`打开一个菜单项，我们必须检查这个函数的返回值——`0`表示菜单被隐藏。如果它返回非零值，那么我们应该在栏下方布局菜单。我们使用`NkLayoutRowDynamic()`开始一个新的动态行布局，使用单个列来包含每个菜单项。然后使用`NkMenuItemLabel()`添加每个菜单项，并使用适当的`label`字符串。这个函数的返回值表示项目是否被点击。如果我们得到非零值，那么我们应该执行该操作——如所示
- en: '`Quit` item. Lastly, if the menu is open, we must close it again with `NkMenuEnd()`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Quit`项。最后，如果菜单已打开，我们必须再次使用`NkMenuEnd()`关闭它：'
- en: '[PRE15]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Further menus (`Edit` and `Help`, for example) can simply be added by starting
    another block with `NkMenuBeginLabel()`. For the complete listing, you can see
    the code repository for this book: `chapter9/gomail`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的菜单（例如`Edit`和`Help`）可以通过使用`NkMenuBeginLabel()`开始另一个块来简单地添加。对于完整的列表，你可以查看本书的代码库：`chapter9/gomail`。
- en: 'Adding a toolbar is less straightforward as the Nuklear toolkit has no direct
    toolbar support. We''ll simulate this by adding a row of buttons that are of fixed
    size and left-aligned in the bar. To do this, we open a new static row layout,
    specifying the desired size of the buttons as the cell width (and the correct
    number of columns). We then add each button with `NkButtonLabel()` passing a button
    label. Ideally, we would use `NkButtonImage()`, but there are no standard toolbar
    icons available. We could package the required icons ourselves and load the images,
    but there''s currently little support for loading an image from Go code; a proposal
    exists to add `NkImageFromRgba()`, but at the time of writing, this doesn''t exist.
    Implementing that image loading is out of scope for this chapter:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 添加工具栏不如使用`Nuklear`工具包没有直接的工具栏支持那么直接。我们将通过在栏中添加一行固定大小且左对齐的按钮来模拟。为此，我们打开一个新的静态行布局，指定按钮的期望大小为单元格宽度（以及正确的列数）。然后我们使用`NkButtonLabel()`添加每个按钮，传递一个按钮标签。理想情况下，我们会使用`NkButtonImage()`，但没有标准的工具栏图标可用。我们可以自己打包所需的图标并加载图像，但目前从Go代码中加载图像的支持很少；有一个提议要添加`NkImageFromRgba()`，但在撰写本文时，这还不存在。实现图像加载超出了本章的范围：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Each of these buttons returns, an `int` value, like the preceding menu items,
    that indicate whether it was clicked. We''ll add the button handling in the next
    section, *Communicating with the GUI*. With this code in place, we see a complete
    user interface for our email browse window:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮返回的，是一个`int`类型的值，就像前面的菜单项一样，表示它是否被点击。我们将在下一节中添加按钮处理，*与GUI通信*。有了这段代码，我们看到一个完整的电子邮件浏览窗口用户界面：
- en: '![](img/0dd22abe-c9db-4dc3-8961-3ca228b22e56.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0dd22abe-c9db-4dc3-8961-3ca228b22e56.png)'
- en: The completed layout of our compose window
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编辑窗口的完成布局
- en: Communicating with the GUI
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GUI通信
- en: 'Now that we have all of the layout completed, we need to connect up a data
    source and handle the appropriate interaction events. We start by importing the
    `client` email package used in the previous examples. Once imported, we set up
    a new test server and cache the current message (this will be changed later by
    clicking an item). As outlined before, we must save all state within the application
    code, not the user interface:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有布局，我们需要连接数据源并处理适当的交互事件。我们首先导入之前示例中使用的`client`电子邮件包。一旦导入，我们设置一个新的测试服务器并缓存当前消息（这将通过点击一个项目而稍后更改）。如前所述，我们必须在应用程序代码中而不是用户界面中保存所有状态：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Updating the email list group is as simple as wrapping the label creation in
    a `for` loop that iterates the range of `server.ListMessages()`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 更新电子邮件列表组就像在`for`循环中包装标签创建，该循环遍历`server.ListMessages()`的范围：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The content is loaded from the `client.EmailMessage` that we saved as `current`,
    as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 内容是从我们保存为`current`的`client.EmailMessage`加载的，如下所示：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the main interface, the last interaction is the menu and toolbar buttons;
    each of the relevant functions returns `> 0` when the item has been activated.
    We can add a click handler to the menu items as we did with the Quit item earlier:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主界面，最后的交互是菜单和工具栏按钮；当项目被激活时，每个相关功能都会返回`> 0`。我们可以像之前处理`Quit`项一样给菜单项添加点击处理程序：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The same pattern can be used for toolbar buttons. For the New button, we set
    a compose window to appear when it''s tapped. As we need to maintain all state
    locally, you''ll see that the button tap here is setting a `composeUI` instance
    (a custom type for the compose state); this will be used in the following to decide
    whether we should open a compose window:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的模式也可以用于工具栏按钮。对于“新建”按钮，我们设置一个撰写窗口在点击时出现。由于我们需要在本地维护所有状态，你将看到这里的按钮点击正在设置一个`composeUI`实例（一个用于撰写状态的定制类型）；这将在以下内容中使用，以决定是否应该打开撰写窗口：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As the Nuklear backends typically don''t support multiple native operating
    system windows, we need to load our compose window within the main GoMail user
    interface. After the main interface layout code has run, we can insert a new check
    for the `compose` value that we set before. When this value is `nil`, we have
    no compose window to show, but when it has been set, we''ll create a second window
    within the first:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Nuklear后端通常不支持多个原生操作系统窗口，我们需要在GoMail主用户界面中加载我们的撰写窗口。在主界面布局代码运行后，我们可以插入一个新的检查，检查我们之前设置的`compose`值。当这个值为`nil`时，我们没有撰写窗口可以显示，但当它被设置后，我们将在第一个窗口内创建第二个窗口：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code executes after the main window (marked by `NkEnd()`). If
    a compose state is set, we''ll need to call the new `drawCompose()` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在主窗口（由`NkEnd()`标记）之后执行。如果设置了撰写状态，我们需要调用新的`drawCompose()`函数：
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This new function sets up a sub-window and then calls the `drawComposeLayout()`
    that we defined earlier—now renamed `drawLayout()` within a new `composeUI` type.
    We need to encapsulate the compose state (the data buffers we declared earlier)
    in a separate type; this allows us to track changes made in multiple compose windows
    (as the compose window has no state).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新函数设置一个子窗口，然后调用我们之前定义的`drawComposeLayout()`——现在重命名为`drawLayout()`，在新的`composeUI`类型中。我们需要将撰写状态（我们之前声明的数据缓冲区）封装在单独的类型中；这允许我们跟踪多个撰写窗口中做出的更改（因为撰写窗口没有状态）。
- en: 'To change email based on the selected item in the list, we can change `NkLabel`
    to `NkSelectableLabel`. This widget takes an additional parameter for whether
    or not it''s selected and will return a non-zero value if the selection is changed
    to the specified item. The update list code should look like this (a little extra
    code is required to convert from `bool` into `int32`):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据列表中选定的项目更改电子邮件，我们可以将`NkLabel`更改为`NkSelectableLabel`。此小部件接受一个额外的参数，用于指定是否选中，如果将选择更改为指定项目，则将返回非零值。更新列表代码应如下所示（需要一些额外的代码将`bool`转换为`int32`）：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With all of our data loaded and the compose window opened from the New toolbar
    or menu item, we see something like the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有数据加载并从“新建”工具栏或菜单项打开撰写窗口后，我们看到如下内容：
- en: '![](img/31557268-0d77-48cb-885f-1d015103c922.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31557268-0d77-48cb-885f-1d015103c922.png)'
- en: Our completed GoMail app with nk showing a compose window
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成的GoMail应用，nk显示一个撰写窗口
- en: Background processing
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景处理
- en: One of the benefits of an immediate mode user interface toolkit is that there's
    no hidden state. When we see a new email arrive, we don't have to communicate
    the change to a list widget (or equivalent) to instruct it to add a new row. As
    long as the model data updates when an event occurs, there's no additional work
    to do. Our nk code will automatically add the new data on the next frame and so
    the user interface will refresh accordingly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 立即模式用户界面工具包的一个好处是没有隐藏状态。当我们看到新电子邮件到达时，我们不需要将更改通知给列表小部件（或等效的）以指示它添加新行。只要模型数据在事件发生时更新，就没有额外的工作要做。我们的nk代码将在下一帧自动添加新数据，因此用户界面将相应刷新。
- en: This also means that we don't have to handle multiple thread complications in
    our user interface code. If you ensure that any model data is thread-safe (using
    standard Go tools) then the user interface will continue to render from the main
    thread on each refresh. It's a requirement that all render code runs on the same
    thread, but that's unlikely to be a problem due to the way the toolkit is designed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们不需要在我们的用户界面代码中处理多个线程的复杂性。如果你确保任何模型数据是线程安全的（使用标准的Go工具），那么用户界面将始终在主线程上刷新。所有渲染代码必须在同一线程上运行是一个要求，但由于工具包的设计方式，这不太可能成为问题。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the second toolkit of three that were designed
    to break away from the traditional toolkits that we looked at in [Section *2*](36bfea00-c659-4569-864c-de2c460c7467.xhtml)*, Toolkits
    Using Existing Widgets.* The Nuklear project primarily targets embedded applications
    but we saw that, in many ways, it's a possible fit for desktop applications. Its
    bespoke widget design means that applications will look identical across all supported
    operating systems, which is a longer list than Shiny—including Android for mobile
    development.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了三个工具包中的第二个，这些工具包旨在摆脱我们在[第2节](36bfea00-c659-4569-864c-de2c460c7467.xhtml)*使用现有小部件的工具包*中探讨的传统工具包。Nuklear项目主要针对嵌入式应用，但我们看到，在许多方面，它也适合桌面应用。其定制的小部件设计意味着应用将在所有支持的操作系统上看起来完全相同，这个列表比Shiny更长——包括用于移动开发的Android。
- en: We explored how the Nuklear framework is designed and how it interacts with
    various backends that provide the actual drawing and user input implementation.
    We examined the main API features, including its drawing capabilities, the widgets
    it includes, and the layout algorithms that it provides for constructing user
    interfaces. We then implemented the same GoMail project that was created in [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications**,* through to [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml),
    *Go-Qt - Multiple Platforms with Qt*, working through the nk APIs and features
    to create a complete application. There were many differences when working with
    an immediate mode GUI framework but, in many ways, it was easier to implement
    our basic application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了Nuklear框架的设计以及它与提供实际绘图和用户输入实现的各个后端之间的交互。我们检查了主要的API功能，包括其绘图能力、它包含的控件以及它为构建用户界面提供的布局算法。然后，我们通过使用nk
    API和功能创建一个完整的应用程序，实现了在第4章[“Walk - 构建图形窗口应用程序”](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)和第7章[“Go-Qt
    - 使用Qt的多平台”](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)中创建的相同GoMail项目，从[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)到[第7章](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)。在处理即时模式GUI框架时有许多不同之处，但在许多方面，实现我们的基本应用程序更容易。
- en: In the next chapter, we'll look at **Fyne**, the last toolkit that we'll explore
    in detail. As with Shiny, it's a material design inspired widget library but,
    similar to Nuklear, its focus is on providing a complete widget toolkit.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨**Fyne**，这是我们将在详细探讨的最后一个工具包。与Shiny一样，它是一个受材料设计启发的控件库，但与Nuklear类似，它的重点是提供完整的控件工具包。
