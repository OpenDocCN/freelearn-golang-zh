- en: nk - Nuklear for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nuklear is a lightweight widget library that focuses purely on the graphical
    interface. It provides a rich widget toolkit that renders identically across all
    supported platforms. Originally designed for embedded systems, it avoids the complications
    of application life cycles and windows and managing user interaction to keep its
    API focused and completely platform-independent. Its implementation has no dependencies
    and achieves this by avoiding a platform-specific render library or operating
    system drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The design and purpose of the Nuklear project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting set up with Nuklear and the Go bindings, nk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a render context and use the toolkit widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a complete application using nk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have created an nk-based application using
    an OpenGL backend that will work across all mainstream desktop operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Background and design of Nuklear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nuklear was designed to build graphical user interfaces for embedded applications
    and games. It aims to be lightweight and completely platform agnostic. It manages
    this by leaving the window management, operating system-specific methods, and
    even the render driver to separate modules or the applications that use the library.
    Many of these features are provided by add-on modules; due to Nuklear's popularity,
    there are many render drivers to choose from (some are operating system-specific
    and others work across multiple platforms). Nuklear has been made available within
    the public domain, which also makes it an attractive option for embedding within
    commercial software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nuklear provides many widgets, layouts, and features for creating rich application
    GUIs that can also be skinned to suit the application design. The following screenshot
    is an example of the standard interface design: more can be found in the gallery
    section of the project website at [https://github.com/vurtun/nuklear#gallery](https://github.com/vurtun/nuklear#gallery):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10efe27e-4836-49a2-bea3-f559b6c40780.png)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of Nuklear widgets from the project website (Copyright: Micha Mettke)
  prefs: []
  type: TYPE_NORMAL
- en: Alongside the differences that the Nuklear design has to other toolkits we've
    explored, there's a larger distinction—Nuklear is an *immediate mode* GUI toolkit.
    In comparison, the other toolkits we've worked with in this book have all been
    *retained mode* user interfaces. With a retained mode API, the developer describes
    the application GUI by creating objects such as buttons and input boxes, arranging
    them in layouts, and then the toolkit will draw these features to screen. When
    an event occurs, the toolkit will change the state of an item and the resulting
    graphical changes will be reflected onscreen, optionally sending the changes to
    the application code.
  prefs: []
  type: TYPE_NORMAL
- en: When using an immediate mode library, there's no state retained. The application
    developer doesn't create buttons and widgets for later use; instead, these widgets
    are defined during the render process purely for the next graphical update. At
    a glance, this may seem inefficient but it's actually a very good match for how
    graphical render pipelines function and so can be far more efficient. It's also
    a less memory-intensive process as there's no additional structure in memory representing
    the whole application GUI. The main impact of this decision, as we'll see later,
    is how the code that creates a GUI is laid out and how events are handled. Rather
    than try and describe this further, you can see it in action later in this chapter
    (in the *Code* section of *Getting started with nk*).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering and platform support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of the Nuklear library's flexibility is its modular design. The library
    doesn't render to screen nor does it manage user input; such functionality is
    provided by modules that accompany the library. An application will typically
    utilize the core Nuklear library for widgets and layout as well as one of its
    render modules to control the opening of windows, rendering, and handling user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Nuklear project includes many rendering modules that provide support for
    various different environments or operating systems. At the time of writing, you
    can choose from the following backends:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphics Device Interface **(**GDI**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GDI+
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct3D **(**D3D**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux or Unix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: X11 OpenGL
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Games development:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allegro
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cross-platform development:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple DirectMedia Layer **(**SDL**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple and Fast Multimedia Library **(**SFML**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphics Library Framework **(**GLFW**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the renderers are 3D accelerated and others aren't, some focus on embedded
    and low power devices, others for desktop or smart phone type devices. As the
    GLFW module supports most desktop operating systems (and some smart phones), we'll
    use this module for the following chapter. If you choose to use a different module,
    then the application life cycle code should be adapted, but the nk code we'll
    explore remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Supported platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With such a wide range of renderers available for the toolkit, Nuklear offers
    exceptional coverage for various different operating systems. With support available
    for Windows, Linux, macOS, BSD, iPhone, and Android, it offers better support
    for multiple platforms than other libraries we've explored. By selecting the cross-platform
    GLFW Nuklear module, we've reduced the possible number of platforms slightly but
    it'll still support Windows, macOS, and Linux desktop applications as well as
    Android for mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: The GLFW library has Go bindings that work alongside the OpenGL Go bindings
    (both are by the same authors). For most platforms, they don't rely on any external
    packages or libraries being installed. This is a huge benefit to getting up and
    running fast with nk, as we don't need to install additional packages or configure
    our development environment. So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with nk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use GLFW and Go-GL, we'll need to link to some C APIs; however, these aren't
    (on most systems) external libraries. The fact that the only native dependency
    is the OpenGL native library (which is typically part of the operating system),
    and any intermediate libraries are embedded within the Go projects, means that
    all we need to prepare is CGo.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the renderer we'll use for nk requires access to native C APIs, we'll need
    CGo to be correctly functioning for our applications to build. On most platforms,
    this simply means installing a compatible C compiler. This is only a development
    dependency and there's no installation required for the users of applications
    that we build with nk (other than an OpenGL compatible system). If you've worked
    through previous chapters of this book, then you probably have this set up already.
    If not, or you're unsure, then follow the steps in the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml),
    *Installation Details*, in the *Setting up CGo* section.
  prefs: []
  type: TYPE_NORMAL
- en: Some platforms will require additional development files to be installed for
    the operating system-specific portions of the code to compile correctly. macOS
    and Windows developers can skip this section as the development environment for
    CGo provides all that's required. Linux or Android developers may require additional
    steps, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use nk on Linux, we need to ensure some additional development headers are
    installed. Due to the GLFW dependency on Xorg for window management and input
    handling, we'll need to be able to compile against its libraries. If your distribution
    packages development headers separately to the library, you'll need to ensure
    that they're installed for compilation to succeed. The required package is called
    `xorg-dev` on Debian or Ubuntu, `xorg-server-devel` for Arch Linux, and `xorg-x11-server-devel`
    on Fedora or CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, one of the following should correctly install the development dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian or Ubuntu, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo apt-get install xorg-dev`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For Arch Linux (this will probably already be installed), use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo pacman -S xorg-server-devel`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For Fedora or CentOS, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo yum install xorg-x11-server-devel`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the `sudo` command can't be found, then try `su -c` instead. Once this library
    is installed, you should be able to follow the setup steps in the next section
    and run an nk example application.
  prefs: []
  type: TYPE_NORMAL
- en: macOS and Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have Go and CGo set up on your computer, there are no additional prerequisites
    so you can jump to the following *Setup* section.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build an Android app using nk, there are some additional steps required.
    Development of mobile apps is out of scope for this book but, for the curious,
    these steps are included to get you started. First, you must have the Android
    **Software Development Kit **(**SDK**) and **Native Development Kit **(**NDK **)
    installed. The easiest way may be to install Android Studio (available from [https://developer.android.com/studio/](https://developer.android.com/studio/))
    and use the built-in SDK Manager (under SDK Tools) to install the `NDK` packages
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb9903a7-d7e3-4258-be96-205a2ee597be.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure that the NDK package is installed and up to date for Android nk development
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will be needed to complete the `nk-android` build, which
    should result in a complete development environment. Building the toolchain requires
    `ANDROID_HOME` and `NDK` environment variables to be set and your `PATH` to be
    updated correctly. You may not need to set up all of these environment variables
    as they may already be configured if you''ve completed previous Android projects.
    Further documentation is available at [https://github.com/golang-ui/nuklear#android-demo](https://github.com/golang-ui/nuklear#android-demo):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9c94378-c2be-4b60-9928-04b214c8a936.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up an Android environment and building the nk-android toolchain
  prefs: []
  type: TYPE_NORMAL
- en: This should prepare your desktop for Android development using nk and Go. The
    rest of this chapter focuses on desktop development, but if the tools are working
    correctly, you should be able to adapt the instructions to Android NDK-based deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the prerequisites for your platform are complete, let's set up nk and
    run our first example application.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up the `nk` package to use Nuklear from Go is as simple as installing
    the `github.com/golang-ui/nuklear/nk` package with the standard `go` tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69c2318b-b86b-4be3-a3f1-7444d9aee95e.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing nk is straightforward if you already have CGo up and running
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the library installed, let's run an example to see nk in action.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go Nuklear bindings project provides an example application to demonstrate
    some widgets; we can use this to quickly check that things are working. With the
    previous setup steps complete, running the demo is as simple as installing the
    Go project and running it. The code is located in the `cmd/nk-example` sub-project
    of [github.com/golang-ui/nuklear](https://github.com/golang-ui/nuklear); we can
    use `go install` to download and install the example and run it using `nk-example`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba9af3dc-3e4f-4d93-a306-0f784f6fea54.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing and running a nuklear example is trivial once CGo is set up
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding commands should result in the following example window
    appearing on your screen. This example shows some of the widgets provided by the
    Nuklear toolkit, including embedded windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f916d590-96f5-46fa-bf34-71abac948cbf.png)'
  prefs: []
  type: TYPE_IMG
- en: The nk-example application running on Linux
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with our first nk application, there''s a certain amount of
    setup code we need to write. Nuklear is focused on delivering a graphical toolkit
    API and not the operating system-specific code such as managing windows and user
    input. To avoid having to write all of that code ourselves, we''ll use the `glfw`
    Go bindings to create and show a window for our application. The following code
    will set up an application window and show it (without any content). We also need
    to call `runtime.LockOSThread()` as this setup code must all execute on the main
    thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After initializing `glfw`, we need to create a window, which `glfw.CreateWindow()`
    handles for us. We specify the window size and title in the first three parameters.
    The fourth parameter is used for fullscreen windows; by passing a `*glfw.Monitor`
    reference, we request a window that fills the specified monitor in its default
    video mode. The final parameter is related to *context sharing, *passing an existing
    `*glfw.Window` reference requests that this new window shares the same graphical
    context to reuse textures and other resources. We then make the new window current
    so that its context is used in the following code. Note that the window may not
    exactly match the requested parameters (exact window size or monitor modes may
    not be supported), so it's important to check these values after creation rather
    than assume the result.
  prefs: []
  type: TYPE_NORMAL
- en: The other setup we must do is to create an OpenGL context that the Nuklear code
    can utilize. For this task, we'll import the `go-gl` library (by the same authors
    as the `glfw` Go bindings). We initialize the OpenGL library ready to use the
    context from the window that was created by `glfw`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the `nk` package needs to be initialized and we need to set up
    a default font. Thankfully, Nuklear has a standard font packaged but we need to
    run some code to set it as the default (or load a custom one for our application):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of the setup done, the window still looks the same as we haven''t
    yet rendered any content. To actually run a Nuklear application, we need to add
    a run-loop that handles event management and GUI refreshing. The following code
    isn''t the simplest possible event loop (it would be possible to use `for !win.ShouldClose()
    { ... }`, but that would consume a whole CPU!), but it''s reasonably efficient
    for the brevity. It sets up a loop that will check for any events and then refresh
    the user interface 30 times a second. The following code block completes our basic
    nk `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will run our application, but we haven''t defined the user
    interface. The call to a `draw()` function in the preceding code is the secret,
    so we should implement that now. Let''s look at the method in two parts: first,
    the GUI layout and second, the actual rendering. To set up our interface, we create
    a new *frame* (imagine a single snapshot of a video) that will be drawn on the
    next refresh of the user interface. After calling `nk.NkPlatformNewFrame()`, we
    can set up our interface; any code between `nk.NkBegin()` and `nk.NkEnd()` will
    be part of our UI update for the frame we just started. We can find out whether
    re-drawing is needed by checking the returned `update` variable; if it''s `0`,
    then no changes have occurred and we can skip the UI code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `if update > 0 { ... }` block, we lay out the application interface,
    two rows each containing a single cell. In the first row (created with `nk.NkLayoutRowStatic()`),
    we add an `nk.NkLabel` containing the text *Hello World!*. In the second, we create
    a Quit button using `nk.NkButtonLabel()`. As this is an immediate mode user interface,
    we don''t retain a reference to the button to check its state, nor do we pass
    an on-click handler; we simply check the return value from the widget draw function.
    The value that''s returned will be greater than `0` if the button has been clicked;
    and so we can place code inline that will tell the window to close and thereby
    close the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, at the end of the `draw()` function, we need to ask our OpenGL viewport
    to render the created user interface. To do this, we set up the OpenGL viewport
    using `gl.Viewport()`—as you can see, we use the width and height parameters from
    the actual window size rather than assuming the size we requested at the beginning
    of this code is correct. Once the viewport is set up, we clear it and set a background
    color (using `gl.ClearColor()`). The main render work is handled by `nk.NkPlatformRender()`,
    which takes the frame that we defined previously and draws it into the current
    graphical context. This function requires that we specify buffer sizes for the
    vertex and element buffers. We pass numbers that will be large enough for our
    demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we cause the content to be shown by calling `win.SwapBuffers()`. As
    `glfw.Window` is *double buffered*, we''ve been drawing to a back buffer that''s
    currently off-screen. By calling swap, we''re moving the back buffer to the screen
    and setting the previously shown front buffer to be hidden, ready for the next
    frame to be drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That should complete the code for our *hello world* application. There was a
    lot of setup but the UI definition code was relatively succinct, so building more
    complex interfaces won't be much more work.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simply build or run `hello.go` and you''ll see the expected Hello World window.
    Clicking the Quit button will tell the window to close which in turn will exit
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b23b3b61-32a0-4f24-8a9b-1168cdc29e3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Hello world with nk
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compiling an nk-based application for a different operating system can be a
    complicated process due to its requirement to use CGo to communicate with native
    OpenGL libraries. However, if you've worked through [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml), *andlabs
    UI - Cross-platform Native UIs*, or [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    - Experimental Go GUI API*, this should already be set up. If you've jumped straight
    to this chapter, then you may need to follow the steps in the [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml),
    in the *Cross-Compiler Setup*. Once that's complete, you should have new compilers
    available (named `o32-clang` for macOS or `x86_64-w64-mingw32-gcc` for Windows)
    that are able to link to macOS Foundation APIs and Windows system calls respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the application, we now set up the `GOOS` and `CGO_ENABLED` flags
    as before, but also specify the compiler to use through an extra `CC` environment
    variable, setting it to `o32-clang` for the Darwin OS or `x86_64-w64-mingw32-gcc` for
    Windows. With that configuration complete, we can build our nk application for
    macOS and Windows from our Linux Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d60d7e5f-53e3-41b8-a37a-e3b7e1ea4390.png)'
  prefs: []
  type: TYPE_IMG
- en: Compiling for Linux, macOS, and Windows from a Linux Terminal
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've built our first nk application, let's look further into what
    the underlying Nuklear library supports for building application GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets, layout, and skinning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the Nuklear library focuses purely on the widget aspects of an application
    toolkit, its capability in this area is comparable to that of more established
    application libraries. As you'll see in the following, there's a long list of
    widgets that can be included in any Nuklear application. As the nk bindings expose
    all of the library functionality, these features are all available to an nk application
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GUI functionality is split into three broad areas: **widgets** (the main
    user interface elements), **drawing** (for drawing directly to the canvas), and
    **layout** (for arranging elements on screen). In this section, we''ll look at
    each area in turn, starting with the main widgets.'
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Nuklear widgets (and the nk API presenting them) should in many ways be
    familiar. Sensible naming allows for many of these features to be discovered while
    programming in your favorite IDE, but let''s explore the main widgets and how
    they function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Widget name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `NkButtonLabel` | A standard push button widget, the API reports when it
    has been clicked. See `NkButtonImage` also (to use an image instead of a text
    label) and `NkButtonImageLabel` to include both. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkCheckboxLabel` | A checkbox displays a familiar box next to the label
    that''s either checked or not. The API reports when its value has changed. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkColorPicker` | This is a special button that opens a color picker. This
    form returns the currently selected color, or you can use `NkColorPick`, which
    reports when the value changes. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkComboBox` | This is a combobox container for dropping down a selection.
    Each item within it can contain text, an image, or both (see the APIs beginning
    with `NkComboItem`). |'
  prefs: []
  type: TYPE_TB
- en: '| `NkGroup(Begin/End)` | This adds a grouping for widgets in an interface.
    A group has a title and a scrollbar, if required. To manually control the scroll
    behavior, you can instead use `NkGroupScrolledBegin.` The widgets declared between
    begin and end will be included. The begin function returns `> 0` if the contents
    should be drawn.  |'
  prefs: []
  type: TYPE_TB
- en: '| `NkImage` | This displays a simple image in the interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkMenubar(Begin/End)` | For add a menu bar to the user interface, this requires
    the use of the various APIs beginning with `NkMenu` and `NkMenuItem` as well. The
    begin function returns `> 0` if the contents should be drawn. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkPopup(Begin/End)` | This displays a popup over the current content; the
    widgets declared between begin and end will be included. The begin function returns
    `> 0` if the contents should be drawn. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkRadioLabel` | A radio selection is like a combobox but offers multiple
    possible values, each added using this function. The return value indicates whether
    the specified item has been selected. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkSlider(Int/Float)` | The `NkSlider` functions add a slide bar with specified
    minimum, maximum, and current values. The API reports when the value has changed.
    An alternative format, `NkSlide(Int/Float)`, returns the current value. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkTexteditString` | This is a text entry widget. This function requires
    a buffer to edit; this can more easily be set through `NkEditStringZeroTerminated()`.
    There are also many helpful APIs starting with `NkTextedit` that can be used to
    manage the text content. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkTree(Push/Pop)` | Tree widgets can be used to allow sections of the user
    interface to be expanded and collapsed or to present tree-based data on the screen.
    Functions beginning with `NkTreePush` mark the start of a new tree section and `NkTreePop`
    ends that section (or the root of the tree). The `TreeType` named `TreeNode` marks
    a user interface style tree and `TreeTab` is for data style tree. |'
  prefs: []
  type: TYPE_TB
- en: '| Window (`NkBegin`, `NkEnd`) | A window is required to contain all widgets
    within Nuklear (anything declared outside this scope will be ignored or cause
    an error). A window is declared with `NkBegin` or `NkBeginTitled` and marked as
    complete with `NkEnd`. Various window management functions are available and they
    start with `NkWindow`. |'
  prefs: []
  type: TYPE_TB
- en: As you can see, many of these widgets are straightforward. The more complex
    ones have semantics for opening and closing their definition that become familiar
    over time. This is due to the immediate mode nature of the API and its design
    to not retain any state. Common semantics are for containers to return a value
    greater than `0` when they need to be drawn. Similarly, items that respond to
    user events will return a non-zero value when they have been activated or changed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored the widgets available, let's look at how we can arrange
    elements in our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The layout system for Nuklear follows a simple rows and columns approach. To
    lay out widgets, each item should be within a row; columns are implicitly created
    when widgets are added according to the parameters set in the row configuration.
    When widgets are added to a row that's full, a new one will be automatically created
    with the same parameters as the previous. A new row may be started to change the
    parameters or to finish a previous row without filling the remaining columns.
    The basic layout is controlled by the NkLayoutRow API as described here; there's
    also a helpful template-based layout in `NkLayoutRowTemplate`, which we'll explore
    after that. Lastly, `NkLayoutSpace` allows directly setting widget locations and
    sizes—we'll explore that last.
  prefs: []
  type: TYPE_NORMAL
- en: NkLayoutRow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest approach to layout is to start a new row using `NkLayoutRowDynamic()`
    or `NkLayoutRowStatic()`. Both functions specify the number of cells in the row.
    The difference between the two is that the dynamic row allocation will split all
    of the space between the cells and resize them all as the window or container
    changes size. With a static arrangement, the sizes of all cells will remain the
    same irrespective of the container size. Widgets added after a row is started
    will append to the row, until it's full; if further widgets are appended, then
    a new row will be created for the new widgets. This continues until `NkLayoutRowEnd()` is
    called, or a different row configuration is started using one of these alternative
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Some added control is made possible by using the `NkLayoutRowBegin()` function
    to start a row; this specifies the row height and number of columns, but not how
    the columns will be sized. Cells are added to the row before widgets are appended
    by calling `NkLayoutRowPush()`; this sets a size or ratio for the next cell and
    should be followed by the declaration of a widget to fill the cell. This type
    of row should also conclude by calling `NkLayoutRowEnd()`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, it's possible to call `NkLayoutRow` directly to set up the parameters
    for the following rows, static or dynamic sizing, and specified height or ratio
    with a specified number of columns.
  prefs: []
  type: TYPE_NORMAL
- en: NkLayoutRowTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A more powerful way to lay out rows is to use the template mechanism available.
    By calling `NkLayoutRowTemplateBegin()`, it's possible to set the template for
    all rows that follow. Column sizing is defined using one of three template functions.
    Firstly, `NkLayoutRowTemplatePushStatic()` specifies that widgets in this column
    should be of a fixed width. `NkLayoutRowTemplatePushDynamic()`, like the definition
    of dynamic allocation without templates, will split the row width among dynamic
    columns (this could be as little as `0` if no space is available). Finally, there's
    an additional call to the `NkLayoutRowTemplatePushVariable()`function; this will
    ensure that widgets get their minimum required space and will take up any extra
    space available (or split evenly across other variable width columns).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the template specification, you must call `NkLayoutRowTemplateEnd()`;
    this will indicate that any widgets added will start the creation of layout rows
    that follow the declared template. As before, if there are more widgets that fit
    in a row, then a new row will automatically be created and widgets will start
    to be added on this new row. Unlike the regular row layout functions before that
    specified the number of columns in a row, using this method will add as many widgets
    to a row as items exist in the template definition.
  prefs: []
  type: TYPE_NORMAL
- en: NkLayoutSpace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, the space layout offers full control over the positioning and size of
    the items in your Nuklear application. The layout is started and ended like the
    previous row-based layout; use `NkLayoutSpaceBegin()` to start a space-based layout
    and `NkLayoutSpaceEnd()` to finish the layout. Before each widget you wish to
    add to your interface, call the `NkLayoutSpacePush()` function, passing `NkRect`,
    which specifies the size and position for the next widget to be added.
  prefs: []
  type: TYPE_NORMAL
- en: As well as the layout control functions, there are a number of helper functions
    that use the `NkLayoutSpace` API prefix. The most useful is `NkLayoutSpaceBounds()`—if
    called within a space layout, it'll return the total space that's available to
    work within. This is important if you wish to right- or bottom-align or position
    your widgets centrally within available space.
  prefs: []
  type: TYPE_NORMAL
- en: Those are all of the layout options that the nk API provides; let's look now
    at the drawing capabilities of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The drawing API presents a fairly standard **two**-**dimensional** (**2D**)
    vector graphics library that's mostly used by the higher level widgets. As it's
    part of the public API, it's also possible to use them in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Command queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To draw custom areas of an application, our application will be interacting
    directly with the Nuklear draw command queue (the list of items to draw for rendering
    a frame of the user interface) so care is recommended. You can get access to `nk.CommandBuffer`, which
    is needed for each draw command by using the `NkWindowGetCanvas()` function. It's
    important that this is only called when a window is active (after `NkBegin` and before `NkEnd`).
    The positional values will need to be aware of other widgets and layouts loaded,
    which can get complicated very fast—it's easiest to draw using these commands
    only in an otherwise empty window so that you avoid drawing over other widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Draw functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to go ahead and make use of these draw commands directly, you can
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Stroke function** | **Fill function** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `NkStrokeLine()` |  | Draw a single line segment in the specified color.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NkStrokeCurve()` |  | Draw a single curve segment in the specified color.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NkStrokeRect()` | `NkFillRect()`, `NkFillRectMultiColor()`   | Draw a rectangle
    (or square) outline, or solid rectangle in the specified color(s). To draw an
    outlined, filled rectangle, call `NkFillRect()` and then `NkStrokeRect()` using
    the same coordinates. `NkFillRectMultiColor()` is a quick way to draw gradients
    in a rectangle. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkStrokeCircle()` | `NkFillCircle()` | Draw a circle (or ellipse) outline
    or fill in the specified color. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkStrokeArc()` | `NkFillArc()` | Outline, or fill, an arc around a central
    point in the specified color. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkStrokeTriangle()` | `NkFillTriangle()` | Draw a triangle outline or a
    solid triangle in the specified color. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkStrokePolyline()` |  | Draw a series of line segments in the specified
    color. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkStrokePolygon()` | `NkFillPolygon()` | Outline or fill a shape with a
    list of points defining its boundary. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkDrawImage()` |  | Draw an image into a specified rectangle and background
    color. |'
  prefs: []
  type: TYPE_TB
- en: '| `NkDrawText()` |  | Draw a text string with the specified background and
    foreground colors. |'
  prefs: []
  type: TYPE_TB
- en: 'Now that we''ve explored all of the widgets and drawing capabilities, we could
    jump right in to building a full application. However, Nuklear has one other cool
    feature that we should look at: the ability to change the interface design using
    skinning.'
  prefs: []
  type: TYPE_NORMAL
- en: Skinning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as defining its own style for the widgets included, Nuklear supports
    **skinning**—loading a theme to change how applications look. This is a powerful
    feature—very similar to the themes that we saw with GTK+ and Qt, but selected
    by the application instead of the end user. Any nk application developer looking
    to set up skinning for their application may find that it isn't easy to do—this
    is due to the way that most configuration is expose through C structures from
    the underlying Nuklear API. While these elements are mostly available through
    the Go API binding, it requires a lot of pointer conversion and unsafe assignments
    that could affect the stability of your application. It would be possible, however,
    to write some C code and include it in your application using CGo.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following C code is extracted from a Nuklear skinning example in case a
    developer wishes to include a custom skin in their application and is willing
    to embed C in their Go code. The example uses a single texture image that defines
    all of the different images that together define the theme. Firstly, the texture
    must be loaded into the current OpenGL context and then the individual areas identified
    within the loaded texture, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code excerpt specifies only two sub-textures where, in real-life
    usage, there would be many more. After the textures are loaded, we define a style
    struct pointer that matches the widget to theme (here, we''re skinning the checkbox).
    The value of this pointer is then set to the location of the loaded style configuration
    (this is where it becomes very difficult to re-create in pure Go code). For each
    field in the struct, an appropriate image or color should be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The same technique should be applied for all widgets that will be used in the
    application to be skinned. This is a lot of work and even the toolkit author warns
    against it at this time due to its time-consuming nature! Following is the style
    texture for the *Gwen* skin and a screenshot of an application with this theme
    loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22ba1c35-a47a-4830-91a1-40e9b580807e.png)  ![](img/8f767dfc-54eb-4edc-b580-d1fab9748683.png)'
  prefs: []
  type: TYPE_IMG
- en: The Gwen skin is used to demonstrate Nuklear skin capabilities (left); The Gwen
    skin in action (right)
  prefs: []
  type: TYPE_NORMAL
- en: A complete implementation can be found in the examples repository at [https://github.com/vurtun/nuklear/blob/master/example/skinning.c](https://github.com/vurtun/nuklear/blob/master/example/skinning.c).
  prefs: []
  type: TYPE_NORMAL
- en: Building a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's return to our GoMail application again to try out the nk API. Nuklear
    is an established toolkit with a lot of functionality so it should be able to
    build the user interface just as well as previous examples. What we'll see as
    we build out this user interface is how different an immediate mode toolkit is,
    in how the code is arranged and how event handling is managed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by copying the hello world application so we don''t have to re-work
    all of the setup code and life cycle management. As this application is going
    to contain many more graphical elements, we need to increase the buffer sizes
    that set using `NkPlatformRender()`. Replace the original line with the following
    for this example. In your own applications, this may need to be higher still—if
    the number is too low, you may notice graphical elements not showing or disappearing
    when popups and menu items appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin with the basic application layout; to start with, we update our
    `draw()` function to call a separate `drawLayout()` function where we''ll add
    our new code. This new function will need to be passed the height of the window
    to correctly fill the vertical space, as you''ll see later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is fairly standard for painting a window with nk. Let's jump
    straight into our new layout code.
  prefs: []
  type: TYPE_NORMAL
- en: Main email window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start with a simple layout function called `drawLayout()`. This will set
    up the basic application layout similar to the GoMail design we created in [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications*. The beginning of the code sets out space for the menu and toolbar
    that will expand to stretch the width of our window. We then start a template
    layout using `NkLayoutRowTemplateBegin()` to have a fixed size column on the left
    for our email list and a wider, variable width column on the right that will expand
    as our window resizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, while the width of our layout can adjust automatically, the height
    isn't quite as flexible. For this example, we pass in the height of the window
    and deduct from that the height we're allocating for the toolbar. This total is
    passed to our template layout so it'll expand to the remaining window height.
  prefs: []
  type: TYPE_NORMAL
- en: In the first column of the main layout, we add a new group named `"Inbox"` for
    our email list and add three simple label items that represent the loaded list.
    Next, we add another group that will occupy the second space in the template layout.
    This code sets up a mix of one and two column rows that will display email content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We open the group and set up a simple dynamic row with a single column using
    `NkLayoutRowDynamic()`, inserting the `NkLabel` subject in that cell. Next, we
    add another template layout so we can have a narrow, fixed width column for our
    labels and a variable width column for the values. After that, `NkLabel` for the label
    and value can be inserted to form a grid. Lastly, we start another single column
    dynamic row for the main email content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code, along with the necessary boilerplate code from
    our *Hello world* example, should show a single window, looking a lot like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/206a2e16-ca11-47b3-934d-3b3d778f88c5.png)'
  prefs: []
  type: TYPE_IMG
- en: The basic GoMail layout created with the nk API
  prefs: []
  type: TYPE_NORMAL
- en: Email compose dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start our compose window layout, we create a new `drawComposeLayout()` function that
    (for testing) we can call instead of `drawLayout()` from the `draw()` function.
    Before we can add the text edit widgets that the email compose UI will use, we
    need to create buffers to manage the content they''ll edit. Remember that this
    is an immediate mode toolkit so, to remember any state, we must provide the data
    storage. This is where the compose window will store the subject, email address,
    and content for a new email message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also helpful to our user to provide a hint (often called a placeholder)
    for the user—to do this, we need to copy some data into the buffers before the
    draw loop begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at the layout for the email compose window. The layout is similar
    to the content of our email display group in the previous layout code, setting
    up a dynamic row for the subject widget followed by a row template for the *To* label
    and email address entry. Instead of `NkLabel()`, this time we''re creating a text
    entry widget using `NkEditStringZeroTerminated()` with a number of parameters.
    The `nk.EditBox|nk.EditSelectable|nk.EditClipboard` flags tell Nuklear that we''re
    setting up an edit box where the text can be selected and interact with the system
    clipboard. We also need to tell the widget which buffer it should edit (in this
    case `composeSubject`) and what the maximum number of characters should be (which
    we set to the length of the buffer `int32(len(composeSubject))`). This is then
    repeated for the email and content input widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to add the buttons to the bottom of the screen—we use another
    row template for this. The variable space in this layout is set to be the size
    of the row, minus the size of our buttons, so that the buttons will align to the
    right. We insert an empty `NkLabel` in the first cell to work as a spacer. The
    two `NkButtonLabel()` function calls set up the buttons at the bottom-right of
    the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With that layout code created, we can show the window and see an email Compose
    window like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66a55ee0-7102-41cd-ba7a-a424bceb9da1.png)'
  prefs: []
  type: TYPE_IMG
- en: The basic Compose layout with the nk toolkit
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar and menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a menu to an nk window is accomplished using `NkMenubarBegin()`, `NkMenuBeginLabel()`,
    and `NkMenuItemLabel()`, among others. The only difficult step in setting up a
    menu is that we also need to add an appropriate layout for the bar and its items.
    It's important (in fact, mandatory) that the bar is in a layout where `y=0`, so
    we immediately add a new row layout using dynamic sizing with `NkLayoutRowBegin()`.
    Then, we push the cell size for this layout using `NLayoutRowPush()`.
  prefs: []
  type: TYPE_NORMAL
- en: A menu item is opened using `NkMenuBeginLabel()` and we must check the return
    value for this function—`0` means that the menu is hidden. If it returns a non-zero
    value then we should lay out the menu below the bar. We start a new dynamic row
    layout with a single column using `NkLayoutRowDynamic()` to contain each menu
    item. Each menu item is then added using `NkMenuItemLabel()` with the appropriate
    label `string`. The return value for this function indicates whether the item
    has been clicked. If we get a non-zero value, then we should action the item—as
    shown by the
  prefs: []
  type: TYPE_NORMAL
- en: '`Quit` item. Lastly, if the menu is open, we must close it again with `NkMenuEnd()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Further menus (`Edit` and `Help`, for example) can simply be added by starting
    another block with `NkMenuBeginLabel()`. For the complete listing, you can see
    the code repository for this book: `chapter9/gomail`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a toolbar is less straightforward as the Nuklear toolkit has no direct
    toolbar support. We''ll simulate this by adding a row of buttons that are of fixed
    size and left-aligned in the bar. To do this, we open a new static row layout,
    specifying the desired size of the buttons as the cell width (and the correct
    number of columns). We then add each button with `NkButtonLabel()` passing a button
    label. Ideally, we would use `NkButtonImage()`, but there are no standard toolbar
    icons available. We could package the required icons ourselves and load the images,
    but there''s currently little support for loading an image from Go code; a proposal
    exists to add `NkImageFromRgba()`, but at the time of writing, this doesn''t exist.
    Implementing that image loading is out of scope for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these buttons returns, an `int` value, like the preceding menu items,
    that indicate whether it was clicked. We''ll add the button handling in the next
    section, *Communicating with the GUI*. With this code in place, we see a complete
    user interface for our email browse window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dd22abe-c9db-4dc3-8961-3ca228b22e56.png)'
  prefs: []
  type: TYPE_IMG
- en: The completed layout of our compose window
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all of the layout completed, we need to connect up a data
    source and handle the appropriate interaction events. We start by importing the
    `client` email package used in the previous examples. Once imported, we set up
    a new test server and cache the current message (this will be changed later by
    clicking an item). As outlined before, we must save all state within the application
    code, not the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating the email list group is as simple as wrapping the label creation in
    a `for` loop that iterates the range of `server.ListMessages()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The content is loaded from the `client.EmailMessage` that we saved as `current`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For the main interface, the last interaction is the menu and toolbar buttons;
    each of the relevant functions returns `> 0` when the item has been activated.
    We can add a click handler to the menu items as we did with the Quit item earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The same pattern can be used for toolbar buttons. For the New button, we set
    a compose window to appear when it''s tapped. As we need to maintain all state
    locally, you''ll see that the button tap here is setting a `composeUI` instance
    (a custom type for the compose state); this will be used in the following to decide
    whether we should open a compose window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As the Nuklear backends typically don''t support multiple native operating
    system windows, we need to load our compose window within the main GoMail user
    interface. After the main interface layout code has run, we can insert a new check
    for the `compose` value that we set before. When this value is `nil`, we have
    no compose window to show, but when it has been set, we''ll create a second window
    within the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code executes after the main window (marked by `NkEnd()`). If
    a compose state is set, we''ll need to call the new `drawCompose()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This new function sets up a sub-window and then calls the `drawComposeLayout()`
    that we defined earlier—now renamed `drawLayout()` within a new `composeUI` type.
    We need to encapsulate the compose state (the data buffers we declared earlier)
    in a separate type; this allows us to track changes made in multiple compose windows
    (as the compose window has no state).
  prefs: []
  type: TYPE_NORMAL
- en: 'To change email based on the selected item in the list, we can change `NkLabel`
    to `NkSelectableLabel`. This widget takes an additional parameter for whether
    or not it''s selected and will return a non-zero value if the selection is changed
    to the specified item. The update list code should look like this (a little extra
    code is required to convert from `bool` into `int32`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of our data loaded and the compose window opened from the New toolbar
    or menu item, we see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31557268-0d77-48cb-885f-1d015103c922.png)'
  prefs: []
  type: TYPE_IMG
- en: Our completed GoMail app with nk showing a compose window
  prefs: []
  type: TYPE_NORMAL
- en: Background processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the benefits of an immediate mode user interface toolkit is that there's
    no hidden state. When we see a new email arrive, we don't have to communicate
    the change to a list widget (or equivalent) to instruct it to add a new row. As
    long as the model data updates when an event occurs, there's no additional work
    to do. Our nk code will automatically add the new data on the next frame and so
    the user interface will refresh accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that we don't have to handle multiple thread complications in
    our user interface code. If you ensure that any model data is thread-safe (using
    standard Go tools) then the user interface will continue to render from the main
    thread on each refresh. It's a requirement that all render code runs on the same
    thread, but that's unlikely to be a problem due to the way the toolkit is designed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the second toolkit of three that were designed
    to break away from the traditional toolkits that we looked at in [Section *2*](36bfea00-c659-4569-864c-de2c460c7467.xhtml)*, Toolkits
    Using Existing Widgets.* The Nuklear project primarily targets embedded applications
    but we saw that, in many ways, it's a possible fit for desktop applications. Its
    bespoke widget design means that applications will look identical across all supported
    operating systems, which is a longer list than Shiny—including Android for mobile
    development.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how the Nuklear framework is designed and how it interacts with
    various backends that provide the actual drawing and user input implementation.
    We examined the main API features, including its drawing capabilities, the widgets
    it includes, and the layout algorithms that it provides for constructing user
    interfaces. We then implemented the same GoMail project that was created in [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications**,* through to [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml),
    *Go-Qt - Multiple Platforms with Qt*, working through the nk APIs and features
    to create a complete application. There were many differences when working with
    an immediate mode GUI framework but, in many ways, it was easier to implement
    our basic application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at **Fyne**, the last toolkit that we'll explore
    in detail. As with Shiny, it's a material design inspired widget library but,
    similar to Nuklear, its focus is on providing a complete widget toolkit.
  prefs: []
  type: TYPE_NORMAL
