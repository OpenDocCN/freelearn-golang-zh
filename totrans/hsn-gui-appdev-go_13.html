<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Fyne - Material Design-Based GUI</h1>
                </header>
            
            <article>
                
<p class="mce-root">Fyne is a UI toolkit and application API designed to be easy to use. Its interface design follows the material design principles, providing cross-platform graphics that appear identical on all supported platforms. This chapter explores how to write graphical applications for multiple platforms with Fyne.</p>
<p class="mce-root">We'll cover the following topics:</p>
<ul>
<li>The vision and design of the Fyne project</li>
<li>Building a simple Fyne-based application for multiple platforms</li>
<li>API design and the widgets provided by Fyne</li>
<li>How to create a complete application using Fyne</li>
</ul>
<p>By the end of this chapter, you should have an understanding of Fyne project's ambitions and will have built multiple cross-platform graphical applications using the toolkit.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background and vision for Fyne</h1>
                </header>
            
            <article>
                
<p>The Fyne project was created by Andrew Williams (the author of this book) in response to growing criticism of the complexity in existing graphical toolkits and application APIs. It was designed with the aim of being easy to use, and the Go language was chosen for its powerful simplicity. Like the Shiny project we explored in <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a>, <em>Shiny – Experimental Go GUI API</em>, its APIs benefit from being created specifically for the Go language.</p>
<p>As with the other widget toolkits in <a href="ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml">Section 3</a>, <em>Modern Graphical Toolkits,</em> it facilitates the building of graphical applications that look identical across all platforms, rather than adopting the look and feel of the <span>operating system</span>.</p>
<div class="packt_quote CDPAlignLeft CDPAlign"><span>"Fyne's APIs aim to be the best for developing beautiful, usable, and lightweight applications for desktop and beyond."<br/>
                                                                                                                                   -<a href="https://github.com/fyne-io/fyne/wiki/Vision">g</a></span><a href="https://github.com/fyne-io/fyne/wiki/Vision">ithub.com/fyne-io/fyne/wiki/Vision</a></div>
<p>The toolkit was initially built using the Enlightenment Foundation Libraries (EFL: <a href="https://www.enlightenment.org/about-efl">enlightenment.org/about-efl</a>) to facilitate cross-platform rendering. Since then, Fyne has moved to an OpenGL-based driver, much like the nk package from the previous chapter. This makes for a much simpler setup and means that there are no runtime dependencies for apps created with Fyne. Before we examine the toolkit in detail, let's see how to set up a simple Fyne application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started with Fyne</h1>
                </header>
            
            <article>
                
<p>Before we start building a Fyne application, we will step through the installation and run an example application. For most systems, the setup is as simple as installing the <kbd>fyne.io/fyne</kbd> package using standard Go tools. For some systems, however, there are development prerequisites to check, so let's start there.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p>For the majority of platforms, there are no installation requirements to begin using Fyne. On macOS and Windows, the toolkit uses built-in OpenGL capabilities, so you can skip straight to the following <em>Setup</em> section (however, if you are developing for the first time on macOS, examine the following notes). If you are working with Linux (or another Unix system), then it may be necessary to install a number of system header files.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linux</h1>
                </header>
            
            <article>
                
<p>To compile on Linux, you will need to have the Xorg and GL (<em>mesa</em> or similar) headers installed <span>(this is not required for running the applications)</span>. The specifics will vary from system to system, but the most common requirements are as follows:</p>
<ul>
<li>Debian / Ubuntu:<br/>
<span><kbd>libgl1-mesa-dev</kbd> and <kbd>xorg-dev</kbd></span></li>
</ul>
<ul>
<li>Fedora / CentOS:<br/>
<span><kbd>libX11-devel</kbd>, <kbd>libXcursor-devel</kbd>, <kbd>libXrandr-devel</kbd>, <kbd>libXinerama-devel</kbd>, <kbd>mesa-libGL-devel</kbd>, and <kbd>libXi-devel</kbd></span></li>
<li>Arch Linux:<br/>
<kbd>mesa</kbd></li>
</ul>
<p>On a development computer these packages may well already be installed, but if you have compile errors later in this chapter, the first thing to check would be that these packages, or their equivalent for your system, are installed correctly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">macOS</h1>
                </header>
            
            <article>
                
<p>For developing on macOS, you must have the Xcode command-line tools installed. If you've been working with C or CGo previously, then this is probably already set up; if not, then you may need to execute the <kbd><span>xcode-select --install</span></kbd> <span>command:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/9569940d-c5c1-4d39-b3da-63f83bd7a487.png" style="width:27.42em;height:10.42em;" width="875" height="332"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">If you don't already have the command-line tools installed, then xcode-select will display this prompt</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setup</h1>
                </header>
            
            <article>
                
<p>Setting up the Fyne API for use is as simple as downloading it using the <kbd>go get</kbd> command. The project is accessed from its base import name, <kbd>fyne.io/fyne</kbd>:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/142daf59-b48e-4740-aa96-f72150ff3dd9.png" style="width:38.92em;height:5.50em;" width="1110" height="157"/></div>
<p class="mce-root"/>
<div class="packt_figref CDPAlignCenter CDPAlign">Installing Fyne is easy once CGo is set up</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example</h1>
                </header>
            
            <article>
                
<p>The Fyne toolkit comes with an example application built in that can be used to explore its features and assets. We can use this to verify that the setup is working. Simply use the Go tools to install the application and then run it using the <kbd>fyne_demo</kbd> command:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/c05a4a8b-4994-442a-b39f-752141715fcf.png" style="width:38.83em;height:5.33em;" width="1110" height="154"/></div>
<p class="mce-root"/>
<div class="packt_figref CDPAlignCenter CDPAlign">Install and run the fyne_demo command from the project repository</div>
<p>Running the demo application opens a single window that offers various options to explore. If we tap on a few items, additional windows will open and you should see something like this:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/8cf3c5f8-e8fb-4d4c-b51d-dff87a681a41.png" style="width:36.00em;height:28.42em;" width="805" height="636"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Some of the features demonstrated in Fyne's example application</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code</h1>
                </header>
            
            <article>
                
<p>The basic <em>Hello World</em> application with Fyne is quite succinct, as the application setup is encapsulated in a single call. The entry point, <kbd>app.New()</kbd>, provided by the <kbd>app</kbd> sub-package, sets up a new application that we use to open a new window. The <kbd>widget</kbd> sub-package defines the various widgets available that we can add to our new window:</p>
<pre><span>package </span>main<br/><br/><span>import </span><span>"fyne.io/fyne/app"<br/></span><span>import </span><span>"fyne.io/fyne/widget"<br/></span><span><br/></span><span>func </span>main() {<br/>   app := app.New()<br/><br/>   win := app.NewWindow(<span>"Hello World"</span>)<br/>   win.SetContent(widget.NewVBox(<br/>      widget.NewLabel(<span>"Hello World!"</span>),<br/>      widget.NewButton(<span>"Quit"</span>, <span>func</span>() {<br/>         app.Quit()<br/>      }),<br/>   ))<br/><br/>   win.ShowAndRun()<br/>}</pre>
<p>As you can see in the preceding code block, the newly created <kbd>fyne.Window</kbd> has its content set to a new <kbd>widget.VBox</kbd> that provides the basic layout. Into this, we add a <em>Hello World</em>! label using <kbd>widget.NewLabel()</kbd> and a <span class="packt_screen">Quit</span> button using <kbd>widget.NewButton()</kbd>. The second parameter to the button is <kbd>func()</kbd>, which will be called when the button is tapped.</p>
<p>Lastly, we call <kbd>ShowAndRun()</kbd> on the window we created. This function will show the window and start the application <kbd>event</kbd> loop. It is shorthand for <kbd>win.Show(); app.Run()</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Build and run</h1>
                </header>
            
            <article>
                
<p>This simple application can be run directly with <kbd>go run hello.go</kbd>, or built using <kbd>go build hello.go</kbd> and then run using the compiled binary:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/41bfc04d-4c83-40d7-8518-ec246c5f55f5.png" style="width:25.67em;height:8.67em;" width="402" height="136"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Compiling or running directly works the same on any supported system</div>
<p>Running the code should produce a simple app that looks like the following. Clicking the <span class="packt_screen">Quit</span> button or closing the window will exit the application:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/bc83f9a8-9447-4a22-9dfb-d3c97c3d4d4f.png" style="width:5.50em;height:4.92em;" width="102" height="90"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Running Hello World on macOS</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross compiling</h1>
                </header>
            
            <article>
                
<p>Due to the dependency on CGo, compiling for a platform other than the one you are developing in is, unfortunately, not as simple as setting the <kbd>GOOS</kbd> environment variable. Building for a different platform requires an installation of the C compiler for the target operating system. If you've been working through the previous chapters, then this may already be set up, but if not, then the process is documented in <a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml">Appendix 2</a>, <em>Cross-Compiler Setup</em>.</p>
<p>Once you have the appropriate compiler installed, then the build process is configured by setting the <kbd>GOOS</kbd>, <kbd>CGO_ENABLED</kbd>, and <kbd>CC</kbd> environment variables. You may also need to update your path—it's advisable to put this in your Terminal or shell configuration:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/95877658-3203-477c-905d-42e4fe47359d.png" style="width:30.75em;height:14.00em;" width="1124" height="510"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Building from Linux for macOS and Windows is a case of using the correct compiler</div>
<p>Now that we've explored the details of getting up and running and compiling for multiple platforms, let's look more at how Fyne is designed and organized.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rendering and vector graphics</h1>
                </header>
            
            <article>
                
<p>The Fyne widgets (much like those in the Nuklear library in <a href="48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml">Chapter 9</a>, <em>nk – Nuklear for Go</em>) are made up of simple graphical objects that the render drivers are responsible for drawing. The driver is included as part of the package, and so no additional setup is required to start an application. Similar to the Shiny toolkit (that we explored in <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a>, <em><span>Shiny – Experimental Go GUI API</span></em>), the iconography is all vector-based, which Fyne uses to create scalable user interfaces that adapt to the device screen density.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Vector graphics</h1>
                </header>
            
            <article>
                
<p>Vector graphics refers to images that are made up of lines and shapes rather than a collection of pixels (referred to as raster graphics). Whilst these images can be slower to load, they're excellent for drawing perfect images at any scale. As computer screens and smart phones have continued to increase their pixel density, measured in <strong>Dots Per Inch</strong> (<strong>DPI</strong>), it has become more difficult to produce raster graphics that look good on all devices. Platforms such as iOS have historically approached this by requiring multiple files of the same content at different resolutions—such as <kbd>Icon.png</kbd>, <kbd>Icon@2x.png</kbd>, and <kbd>Icon@3x.png</kbd> (which could be, for example, 60 x 60, 120 x 120, or 180 x 180 pixels, respectively)—so that the closest match image for the screen can be used. With a vector icon, you would provide a single image, <kbd>Icon.svg</kbd> (<strong>Scalable Vector Graphics</strong>), that can be drawn at exactly the resolution required for a sharp image.</p>
<p>The Fyne toolkit uses vector graphics throughout so that applications built using it can scale appropriately for any computer screen. When an application starts, it calculates the pixel density (DPI) of the current screen and sets an appropriate scale for the application. Additionally, when a Fyne window is moved to a screen with a different resolution, the content (and window containing it) will re-size accordingly. This means that when an application running on a laptop (typically, a high-resolution screen) moves to an external monitor (usually a lower resolution), the window will be resized to a smaller number of pixels to try and maintain a consistent size for the user. If you wish to override the scale that's auto detected, then it is possible to set a <kbd>FYNE_SCALE</kbd> environment variable before launching the application.</p>
<p><span>An example of setting scale values—notice the crisp text and icons:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/814807d2-14b4-4bd6-8fd9-dd1a04d5dc98.png" style="width:2.33em;height:6.67em;" width="23" height="68"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>FYNE_SCALE=0.5</span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d1ed9bea-dd20-4113-a50a-c3036ee6ca7b.png" style="width:4.25em;height:7.50em;" width="108" height="192"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">FYNE_SCALE=2.5</div>
<p>In some situations, it may be appropriate to use a raster image instead of a vector. This is usually helpful if you want to draw exactly as many pixels as are visible in the space available. An example of this may be found in image manipulation programs or when drawing the result of a complex calculation. For these situations, there is a type of image within the Fyne API (created with <kbd>canvas.NewRaster()</kbd>) that provides this functionality. One of the examples provided by Fyne is a fractal viewer, where each pixel is calculated and drawn using the raster image feature:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/78962a72-b4cd-40b7-a867-c4a9fb0f31ea.png" style="width:53.83em;height:42.92em;" width="992" height="790"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A mandelbrot fractal calculated per-pixel for the output device. Observe the level of detail</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Drivers</h1>
                </header>
            
            <article>
                
<p>A driver in Fyne is responsible for rendering the text, canvas objects, and images, as well as handling window management and user input. The drivers are also required to handle any thread management behind the scenes. By adopting this design, it is possible for background processes or asynchronous events to update the user interface without any of the thread management code that is common in many graphical toolkits.</p>
<p>The default driver for Fyne uses Go-GL and the Go GLFW bindings, which means it has the same dependencies as the examples we worked through in the previous chapter, <em>nk – Nuklear for Go</em>. If your computer, and that of your target customers, supports OpenGL (which includes all recent desktop computers, most laptops, smart phones, and tablets, and beyond), then you don't need any additional libraries or support packages. Having the appropriate Go developer tools installed (see <em>Prerequisites</em> within the <em>Getting started with Fyne</em>, discussed earlier) is all you need, and there are no runtime requirements for users of your apps.</p>
<p>If you wish to build for an older computer, or one that does not have support for OpenGL, it is possible to use the alternative <kbd>efl</kbd> driver. This driver uses the Enlightenment Foundation Libraries to handle rendering, window management, and user input in a cross platform manner. Their years of development for a wide range of platforms (alongside desktop platforms, they support Playstation, Tizen, Samsung Gear watch, and various set-top boxes) means that applications could potentially run on a wider range of devices. To run using this driver, just add <kbd>-tags efl</kbd> to any go build or run command, such as <kbd>go run -tags efl hello.go</kbd>. While this driver does offer better multi-platform support, it also requires that the EFL libraries are installed both on the developer's computer and the target device. For this reason, it is often not the preferred approach when working with Fyne.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Supported platforms</h1>
                </header>
            
            <article>
                
<p>Although the different Fyne drivers have potentially different supported platforms, the core toolkit just supports a standard set of operating systems. At the time of writing, this covered macOS, Windows, Linux, and BSD variants. Any operating system-specific code understands how applications should function on each of these target. Unlike the other toolkits in <a href="ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml">Section 3</a>, <em>Modern Graphical Toolkits,</em> Fyne is designed to provide APIs for managing applications as well as their graphical interfaces. For example, <kbd>app.OpenURL()</kbd> allows an application to launch an external document in the default browser for each supported system.</p>
<p>Now that we've explored the Fyne project background, as well as its design and operating system support, let's explore the APIs it provides to application developers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Canvas, widgets, and layouts</h1>
                </header>
            
            <article>
                
<p>The Fyne API is divided into various sub-packages for basic drawing definition, container layout, high-level widgets, and theme description. In this section, we will look at each in turn. These packages provide the implementation details that are useful from an application developer point of view, and they typically implement generic interfaces. These interface definitions are at the top level of the hierarchy and include things such as <kbd>fyne.CanvasObject</kbd> (which is implemented by any object that can be added to a canvas), <kbd>fyne.Container</kbd> (that describes how multiple objects can be grouped and laid out), and <kbd>fyne.Resource</kbd> (representing an embedded application resource, such as an icon or font). Additionally, there are some math and geometry utilities as well as definitions for event and text handling.</p>
<p>There are additional packages that we will not cover, including <kbd>dialog</kbd> (helpful classes for common dialog windows), <kbd>driver</kbd> (which is where drivers are loaded from), and <kbd>test</kbd> (which provides helpful test facilities). Let's explore the other, more commonly used, packages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Canvas (drawing)</h1>
                </header>
            
            <article>
                
<p>The <kbd>canvas</kbd> package includes definitions of all of the basic drawing objects that Fyne understands. Each of these types defines a number of fields that represent the configuration, such as color, size, and visibility. These are the objects that a Fyne driver will iterate over, drawing each to create the rendered user interface:</p>
<table style="border-collapse: collapse;width: 93.9477%" border="1">
<tbody>
<tr>
<td style="width: 15%"><kbd>Circle</kbd></td>
<td style="width: 112.943%">
<p>This is a circle, or ellipse, defined by the bounding top-left to bottom-right rectangle. It could be created with <kbd>NewCircle()</kbd> or <kbd>&amp;Circle{}</kbd>. It isn't commonly used in most applications.</p>
</td>
</tr>
<tr>
<td style="width: 15%">
<p><kbd>Image</kbd></p>
</td>
<td style="width: 112.943%">
<p>An image may be a vector or bitmap-based image loaded from a file (with <kbd>NewImageFromFile()</kbd>) or embedded resource, or it may be an image generated dynamically to fill available space (using <kbd>NewRaster()</kbd> and a <kbd>func(w, h int) *image.Image</kbd> callback).</p>
</td>
</tr>
<tr>
<td style="width: 15%"><kbd>Line</kbd></td>
<td style="width: 112.943%">
<p><span>This is a </span>simple line that draws from one position to another. <span>It isn't </span>commonly used unless drawing diagrams.</p>
</td>
</tr>
<tr>
<td style="width: 15%">
<p><kbd>Rectangle</kbd></p>
</td>
<td style="width: 112.943%">
<p>The basic building block for widgets, a rectangle draws an area with a specified color. Create with <kbd>NewRectangle()</kbd> or <kbd>&amp;Rectangle{}</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 15%"><kbd>Text</kbd></td>
<td style="width: 112.943%">
<p>The text canvas primitive draws a single string to screen in a specified color and alignment. It does not handle any special characters or formatting. It can be created directly using <kbd>&amp;Text{}</kbd> or with the helper <kbd>NewText()</kbd> function.</p>
</td>
</tr>
</tbody>
</table>
<p>The preceding list makes up the primitive drawing elements of the Fyne canvas. Next, we look at how layouts can be used to position them within a container.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>Multiple objects in Fyne are grouped in a <kbd>fyne.Container</kbd> type and its child objects are laid out by <kbd>fyne.Layout</kbd>. Various standard layouts are provided, as detailed <span>in the following table</span>. A layout provides two functions: first, it manages the size and position for a list of <kbd>fyne.CanvasObject</kbd> objects; and second, it must define the minimum size required to fit all of the objects it arranges:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><kbd>BorderLayout</kbd></td>
<td>The border layout places a specific canvas object at each of the top, bottom, left, and right edges of a container. Any other objects in the container will fill the central space.</td>
</tr>
<tr>
<td><kbd>BoxLayout</kbd></td>
<td>The box layout is either vertical or horizontal (created with <kbd>NewVBoxLayout()</kbd> or <kbd>NewHBoxLayout()</kbd> functions). It will arrange items in a list, each at their minimum height (vertical) or width (horizontal), and the other dimension will expand to the container edge. A box layout may also contain a spacer that will expand to fill available space (normally created with <kbd>NewSpacer()</kbd>).</td>
</tr>
<tr>
<td><kbd>FixedGridLayout</kbd></td>
<td>The fixed grid layout specifies the size of every cell and then arranges them in rows within the available space. A new row is created when the next widget would have extended beyond the container width.</td>
</tr>
<tr>
<td><kbd>GridLayout</kbd></td>
<td>The grid layout has a specified number of columns and each child object will be the appropriate fraction of the container width. The height is defined similarly, depending on the number of child canvas objects. For example, with five objects in two columns, there will be three equal height rows.</td>
</tr>
<tr>
<td><kbd>MaxLayout</kbd></td>
<td>This is the simplest layout. Every item is set to the same size to fill the available space. Be careful to specify container objects in the correct order (the first will be drawn under any subsequent items). For example, a button may simply be a rectangle with text positioned above where both should expand equally.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>It is also possible to write a custom layout by implementing the <span><kbd>fyne.Layout</kbd> interface. The <kbd>MinSize()</kbd> function should determine the size required (probably respecting the <kbd>MinSize()</kbd> function of the child objects) and the <kbd>Layout()</kbd> function calls <kbd>Move()</kbd> and <kbd>Resize()</kbd> on child objects to configure the display for rendering.</span></p>
<p>Whilst containers and layouts are useful, most of our time will be spent with higher-level widget definitions, so let's see what is available.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Widgets</h1>
                </header>
            
            <article>
                
<p>Fyne widgets are divided into two parts: the behavior, which is what the main API exposes, and the renderer, which controls how a widget will look. Unless you are building a custom widget, it is not recommended to access the render functionality (hidden behind the <kbd>widget.Renderer()</kbd> utility function). Customization of the user interface, if required, should be managed using the <kbd>theme</kbd> package (refer to the next section).</p>
<p>All widgets can be created using their constructing function (such as <kbd>NewButton("text", callback)</kbd>) or using the initializer syntax, such as <kbd>&amp;Button{Text: "text", OnTapped: callback}</kbd>. If the latter is used, then fields can also be set immediately after the widget is initiated until it is first rendered. After a widget is shown, setter functions, such as <kbd>SetText()</kbd>, should be used to ensure that the GUI is updated to reflect the changes. Widget fields can still be useful—if you want to update multiple properties at once, you can set the appropriate fields to be applied in a single refresh. Just be sure to call <kbd>widget.Refresh(myObject)</kbd> once you've applied the changes.</p>
<p>The full list of widgets at the time of writing is as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 19.0083%"><kbd>Box</kbd></td>
<td style="width: 78.2369%">This is a simple widget that uses a <kbd>layout.BoxLayout</kbd> to arrange the child objects in horizontal or vertical lists.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>Button</kbd></td>
<td style="width: 78.2369%">The basic button contains text and/or an icon and will call a passed <kbd>func()</kbd> when it is tapped.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>Check</kbd></td>
<td style="width: 78.2369%">A check widget displays a label next to a check box and triggers a <kbd>func(bool)</kbd> callback if it is toggled.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>Entry</kbd></td>
<td style="width: 78.2369%">A text entry widget for single- or multiple-line input.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>Form</kbd></td>
<td style="width: 78.2369%">The form widget lays out a simple data form, with labels in one column and input widgets on the other. Setting <kbd>OnSubmit</kbd> or <kbd>OnCancel</kbd> fields for callbacks will include the appropriate buttons on an additional row.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>Group</kbd></td>
<td style="width: 78.2369%">A visual grouping of child objects. A line is drawn around the items and a title label is drawn above them.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>Icon</kbd></td>
<td style="width: 78.2369%">A simple widget for drawing a themed icon. Create it with an icon resource (refer to <em>Themes</em> in the following section), and it will adapt to the current theme configuration.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>Label</kbd></td>
<td style="width: 78.2369%"><span>This is a </span>simple text widget that draws using the current theme text color and updates if that changes.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>PasswordEntry</kbd></td>
<td style="width: 78.2369%">The same as for the preceding <kbd>Entry</kbd> widget, but the text is hidden as <kbd>*</kbd> characters.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>TabContainer</kbd></td>
<td style="width: 78.2369%">Similar to a standard container, except that it can display different contents. Each child container is associated with a tab button that, when pressed, will show the appropriate content.</td>
</tr>
<tr>
<td style="width: 19.0083%"><kbd>Toolbar</kbd></td>
<td style="width: 78.2369%">A toolbar widget shows a row of icon buttons, optionally separated with <kbd>NewToolbarSpacer()</kbd> (an invisible space) or <kbd>NewToolbarSeparator()</kbd> (a thin line to show the grouping).</td>
</tr>
</tbody>
</table>
<p>It is possible to implement your own widgets—all they need to do is implement the <kbd>fyne.Widget</kbd> interface. As well as the basic <kbd>fyne.CanvasObject</kbd> functions, a widget must also define a <kbd>CreateRenderer()</kbd> function returning a <kbd>fyne.WidgetRenderer</kbd> instance. A widget renderer is similar to a container object, but it also has a background color and should reflect the current theme (the required <kbd>ApplyTheme()</kbd> function will be called on all widgets if the theme is changed). As we've mentioned it many times, let's now explore more of what a Fyne theme provides.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Themes</h1>
                </header>
            
            <article>
                
<p>The <kbd>theme</kbd> package is an implementation of a material design inspired user interface. It provides the color palette, icons, font, and spacing information required to display the Fyne user interface:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/6f634169-9efc-449a-aa9b-bb3b408b1045.png" style="width:33.33em;height:29.08em;" width="1025" height="894"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The "baseline" material design color palette. Fyne uses a blue/gray variant by default</div>
<p>Widgets utilize the theme package extensively to match the current settings. For example, a button will be colored <kbd>theme.ButtonColor()</kbd> (unless it is a primary button, in which case it's <kbd>theme.PrimaryColor()</kbd>) and a label text is <kbd>theme.TextColor()</kbd>. Fyne also packages a standard font that can be accessed using <kbd>theme.TextFont()</kbd> (and variations), but these are not often needed. Instead, use <kbd>fyne.TextStyle</kbd> properties on a text object or label. However, <kbd>theme.TextSize()</kbd> and <kbd>theme.Padding()</kbd> are useful ways to match the user interface style in a custom widget.</p>
<p>Fyne themes also provide a collection of material design icons that can be used in any application, for example, <kbd>theme.ContentPasteIcon()</kbd>. Icons loaded from a theme will adapt to a new theme loading when used with any standard widgets. These icons are bundled with the toolkit and do not require any installation or additional items to be shipped with an application.</p>
<p>Any time you use a theme method, it's important to realize that the result may change over time—a new theme could be loaded or the user may change the configuration. To handle this <span>correctly, </span>you should implement <kbd>fyne.ThemedObject</kbd>, which requires a single function, <kbd>ApplyTheme()</kbd>. Inside this function, you should re-apply any theme-based values that were accessed. This functionality is handled automatically by widgets, so it is not commonly required that an application handles theme changes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaged themes</h1>
                </header>
            
            <article>
                
<p>The Fyne toolkit provides two themes to match a user's preference—a light theme and a dark theme. To change the theme for an application, the environment variable, <kbd>FYNE_THEME</kbd>, can be set to <em>light</em> or <em>dark</em>. If you are implementing a custom widget, it's advisable to test it with at least these two themes:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/7a3c5abd-2738-4a79-a741-189e46afb8b6.png" style="width:4.75em;height:4.58em;" width="101" height="99"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The default dark theme</div>
<div>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/6793a240-1c09-440d-801e-556769b1a86d.png" style="width:5.00em;height:4.58em;" width="101" height="94"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The alternative light theme</div>
</div>
<p>At the time of writing, Fyne does not provide the ability to download user-created custom themes, but this may change in the future. It is, however, possible for an application to be displayed using its own theme. After implementing the <kbd>fyne.Theme</kbd> interface, you should pass an instance of the type to your application configuration using <kbd>app.Settings().SetTheme()</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a user interface</h1>
                </header>
            
            <article>
                
<p>To explore the Fyne toolkit further, let's build our latest version of the GoMail application designed in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk – Building Graphical Windows Applications</em>. We will start by setting out the basic application layout.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>Creating a complex layout with Fyne is a case of combining multiple containers, each of which are using one of the layouts <span>provided</span>. It would be possible to write our own layout to set up the interface with a single container, but for this exploration, we will use only the built-in components. Let's start by creating the main application window.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Main email window</h1>
                </header>
            
            <article>
                
<p>To load the first window of a Fyne application, we must create a new application instance using <kbd>app.New()</kbd>. After that, we can call the <kbd>NewWindow()</kbd> function on this application object. The returned <kbd>fyne.Window</kbd> object allows us to control the window on screen and to set its content:</p>
<pre><span>import </span><span>"fyne.io/fyne/app"<br/></span><span><br/></span><span>func </span><span>main</span>() {<br/>   mailApp := app.New()<br/>   browse := mailApp.NewWindow(<span>"GoMail"</span>)<br/><br/>   ...<br/>}</pre>
<p>Next, we will create the required widgets for our GUI. This starts by adding the widget import line, and then we add the declarations to the <kbd>main()</kbd> function created previously. A toolbar is added using <kbd>widget.NewToolbar()</kbd> (we will add items to it later). For the email list on the left, we create a new titled group using <kbd>widget.NewGroup()</kbd> with the title <kbd>Inbox</kbd>. Into this group we add placeholder labels using <kbd>widget.NewLabel()</kbd>.</p>
<p>Then, we create new labels for the content and subject of the email to display. We set the text of the subject label using a <kbd>fyne.TextStyle</kbd> declaration. Lastly, we set up the grid layout for our email metadata using <kbd>widget.NewForm()</kbd>. A form widget matches our design of where we list rows with a bold text label next to the widget it describes. To the form, we append the <strong>To</strong>, <strong>From</strong>, and <strong>Date</strong> items, <span>shown </span>as follows:</p>
<pre><span>import "fyne.io/fyne/widget"</span><br/><span><br/></span><span>func </span><span>main</span>() {<br/>   ...<br/><br/>   toolbar := widget.NewToolbar()<br/>   list := widget.NewGroup(<span>"Inbox"</span><span>,<br/></span><span>      </span>widget.NewLabel(<span>"Item1"</span>)<span>,<br/></span><span>      </span>widget.NewLabel(<span>"Item2"</span>)<span>,<br/></span><span>      </span>widget.NewLabel(<span>"Item3"</span>)<span>,<br/></span><span>   </span>)<br/>   content := widget.NewLabel(<span>"Content"</span>)<br/>   subject := widget.NewLabel(<span>"subject"</span>)<br/>   subject.TextStyle = fyne.<span>TextStyle</span>{Bold:<span>true</span>}<br/><br/>   meta := widget.NewForm()<br/>   meta.Append(<span>"To"</span><span>, </span>widget.NewLabel(<span>"email"</span>))<br/>   meta.Append(<span>"From"</span><span>, </span>widget.NewLabel(<span>"email"</span>))<br/>   meta.Append(<span>"Date"</span><span>, </span>widget.NewLabel(<span>"date"</span>))<br/><br/>   ...<br/>}</pre>
<p>Now that we have defined all of the widgets, we need to lay them out appropriately. In Fyne, we typically use a <kbd>fyne.Container</kbd> object and optionally pass a layout to control how it is set up. There are also some helper widgets that provide easier-to-use APIs, such as <kbd>widget.NewVBox()</kbd> used in the following section (that sets up a container where items are arranged in a vertical list).</p>
<p>In both containers in this code snippet, we are using <kbd>BorderLayout</kbd>. When calling <kbd>layout.NewBorderLayout()</kbd>, we pass the objects that should be positioned in the top, bottom, left, and right positions of the layout (or <kbd>nil</kbd> if they are to be left empty). Any items that are included in the container not listed in a particular position will be arranged to fill the center of the layout, taking up all remaining space. Remember that items to be placed in one of the border sections should also be passed into the <kbd>fyne.NewContainerWithLayout()</kbd> function as subsequent parameters, as this controls which objects will be drawn within the container. Refer to the following section to see how <kbd>subject</kbd> and <kbd>box</kbd> are passed to the layout as well as the container, as we wish them to be positioned by the layout and drawn by the container.</p>
<p>In the first container (<kbd>detail</kbd>), we've set the <kbd>subject</kbd> label to stretch along the top and the <kbd>box</kbd> containing our metadata and content to be left-aligned within the container. The following container (<kbd>container</kbd>) is our overall application layout and it positions the <kbd>toolbar</kbd> at the top, the email <kbd>list</kbd> on the left, and the <kbd>detail</kbd> container fills the remaining space for the layout (since it is not specified as a border parameter):</p>
<pre><span>import </span><span>"fyne.io/fyne"<br/></span><span>import "fyne.io/fyne/layout"<br/></span><span><br/></span><span>func </span><span>main</span>() {<br/>   ...<br/><br/>   box := widget.NewVBox(meta<span>, </span>content)<br/>   detail := fyne.NewContainerWithLayout(<br/>      layout.NewBorderLayout(subject<span>, </span>nil<span>, </span>box<span>, </span>nil)<span>,<br/></span><span>      </span>subject<span>, </span>box)<br/>   container := fyne.NewContainerWithLayout(<br/>      layout.NewBorderLayout(toolbar, nil, list, nil),<br/>      toolbar, list, detail)<br/><br/>   ...<br/>}</pre>
<p>With all of the containers and layouts defined, we need to complete the window by setting its content and optionally specifying a size. You may not have to call the <kbd>Resize()</kbd> function on a window—its default size will be the appropriate size to fit all of the widgets and containers at their minimum size.</p>
<p>Finally, we call <kbd>ShowAndRun()</kbd> on the window, which will cause the window to appear and the application's main loop to start. Any subsequent windows can simply call <kbd>Show()</kbd> (since an application should only start once):</p>
<pre>   ...<br/> <br/>   browse.SetContent(container)<br/>   browse.Resize(fyne.NewSize(<span>600</span><span>, </span><span>400</span>))<br/>   browse.ShowAndRun()<br/>}</pre>
<p>Running the preceding code (which can be found in the source code repository for this book) should result in a window much like the following:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/2111f93c-7306-4e2c-a3ca-16df5e2be976.png" style="width:21.08em;height:12.83em;" width="648" height="394"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The basic application layout with Fyne. The bar at the top is an empty toolbar</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compose dialog</h1>
                </header>
            
            <article>
                
<p>To start our secondary window, the compose dialog, we could use the custom dialog feature in Fyne (created with <kbd>dialog.ShowCustom()</kbd>). However, all dialog windows in Fyne are of a fixed size, and we would like the compose window to be flexible. Instead, we will create a new window, as in our <kbd>main()</kbd> function, using <kbd>app.NewWindow()</kbd>. To do this, we will need to pass the app instance into a new <kbd>ShowCompose()</kbd> function (as windows are created from the app object):</p>
<pre><span>func </span><span>ShowCompose</span>(app fyne.<span>App</span>) {<br/>   compose := app.NewWindow(<span>"GoMail Compose"</span>)<br/><br/>   ...<br/>}</pre>
<p>Next, we create the widgets for the compose window. We will use <kbd>widget.NewEntry()</kbd> for each of the text entry components. For the multiple-line message widget, we could set <kbd>Entry.MultiLine</kbd> to <kbd>true</kbd>, but instead, we use the <kbd>widget.NewMultiLineEntry()</kbd> helper function. In each instance, we use <kbd>Entry.SetPlaceHolder()</kbd> to set a placeholder value (that will display as a hint, until the user enters their own text).</p>
<p>Two new buttons are created using <kbd>widget.NewButton()</kbd>, one with a <kbd>"Send"</kbd> label, and the other with <kbd>"Cancel"</kbd>. We keep a reference to the <kbd>send</kbd> button so that we can set <kbd>Button.Style</kbd> to <kbd>widget.PrimaryButton</kbd>. This highlights the button as the window default action. Lastly, we create a new horizontal box for the button bar using <kbd>widget.NewHBox()</kbd>. Into that, we first add a spacer to right-align the buttons (using <kbd>layout.NewSpacer()</kbd>), and then we include the <span class="packt_screen">Cancel</span> and <span class="packt_screen">Send</span> buttons:</p>
<pre><span>func </span><span>ShowCompose</span>(app fyne.<span>App</span>) {<br/>   ...<br/><br/>   subject := widget.NewEntry()<br/>   subject.SetPlaceHolder("subject")<br/>   toLabel := widget.NewLabel("To")<br/>   to := widget.NewEntry()<br/>   to.SetPlaceHolder("email")<br/><br/>   message := widget.NewMultiLineEntry()<br/>   message.SetPlaceHolder("content")<br/><br/>   send := widget.NewButton(<span>"Send"</span><span>, </span><span>func</span>() {})<br/>   send.Style = widget.<span>PrimaryButton<br/></span><span>   </span>buttons := widget.NewHBox(<br/>      layout.NewSpacer()<span>,<br/></span><span>      </span>widget.NewButton(<span>"Cancel"</span><span>, </span><span>func</span>() {<br/>         compose.Close()<br/>      })<span>,<br/></span><span>      </span>send)<br/><br/>   ...<br/>}</pre>
<p>Finally, we set up the layout of the window. Once again, this is a non-trivial layout due to Fyne's simple layout options. We use <kbd>layout.NewBorderLayout()</kbd> to specify which components should stretch and which should be placed around them. The <kbd>top</kbd> layout places the subject along its top edge and aligns the <kbd>to</kbd> field left of the expanding <kbd>toLabel</kbd>. The second layout, <kbd>content</kbd>, positions the <kbd>message</kbd> editor in the center, with the <kbd>top</kbd> layout above and the <kbd>buttons</kbd> bar below.</p>
<p>We then set the content of the new <kbd>compose</kbd> window, set it to a default size (larger than the <kbd>minSize()</kbd> calculated by the layouts), and call <kbd>Show()</kbd>. Remember that, this time, we do not use <kbd>ShowAndRun()</kbd>, since the application is already running:</p>
<pre><span>func </span><span>ShowCompose</span>(app fyne.<span>App</span>) {<br/>   ...<br/><br/>   top := fyne.NewContainerWithLayout(<br/>      layout.NewBorderLayout(subject, nil, toLabel, nil),<br/>      subject, toLabel, to)<br/><br/>   content := fyne.NewContainerWithLayout(<br/>      layout.NewBorderLayout(top<span>, </span>buttons<span>, </span>nil<span>, </span>nil)<span>,<br/></span><span>      </span>top<span>, </span>message<span>, </span>buttons)<br/><br/>   compose.SetContent(content)<br/>   compose.Resize(fyne.NewSize(<span>400</span><span>, </span><span>320</span>))<br/>   compose.Show()<br/>}</pre>
<p>Although we don't have a <kbd>compose</kbd> button yet, this code can be invoked from the <kbd>main()</kbd> function immediately before the <kbd>browse.ShowAndRun()</kbd> just for test purposes (remember to remove this line afterward). The result should be something like the following:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/3a1bf64c-1a2e-458c-b310-33d2002f2811.png" style="width:18.92em;height:10.92em;" width="600" height="347"/></div>
<p class="mce-root"/>
<div class="packt_figref CDPAlignCenter CDPAlign">Our compose dialog box using basic Fyne components</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Toolbar and menu</h1>
                </header>
            
            <article>
                
<p>Unfortunately, Fyne has no menu bar support (although it is proposed in the following project issue: <a href="https://github.com/fyne-io/fyne/issues/41">https://github.com/fyne-io/fyne/issues/41</a>)<a href="https://github.com/fyne-io/fyne/issues/41">.</a> We also cannot easily create one from simpler components, as there is currently no support for pop-over widgets. Therefore, we will just add a toolbar (as in some previous examples).</p>
<p>Using Fyne's built-in iconography (from the material design project), we can quickly create an attractive toolbar. To set up the toolbar, we will create a new function, <kbd>buildToolbar()</kbd>, that will create the toolbar and add the items to it. We pass in the application instance so that the <span class="packt_screen">Compose</span> item can pass it into the <kbd>ShowCompose()</kbd> function we created earlier.</p>
<p>The toolbar constructing function takes a list of <kbd>ToolbarItem</kbd> objects (any widget or type that implements <kbd>widget.ToolbarItem</kbd>). It is also possible to call <kbd>Append()</kbd> or <kbd>Prepend()</kbd> after the toolbar is created. For each item that should appear in the toolbar, we pass an action item using <kbd>widget.NewToolbarAction()</kbd>. A toolbar action takes a <kbd>fyne.Resource</kbd> parameter (the icon) and a <kbd>func()</kbd> that's called when the item is tapped. For resources, we use the theme API to access standard icons that are packaged in the framework. Additionally, we add a separator to group actions using <kbd>widget.NewToolbarSeparator()</kbd>:</p>
<pre><span>func </span><span>buildToolbar</span>(app fyne.<span>App</span>) *widget.<span>Toolbar </span>{<br/>   <span>return </span>widget.NewToolbar(<br/>      widget.NewToolbarAction(theme.MailComposeIcon()<span>, </span><span>func</span>() {<br/>         ShowCompose(app)<br/>      })<span>,<br/></span><span>      </span>widget.NewToolbarAction(theme.MailReplyIcon()<span>, </span><span>func</span>() {<br/>      })<span>,<br/></span><span>      </span>widget.NewToolbarAction(theme.MailReplyAllIcon()<span>, </span><span>func</span>() {<br/>      })<span>,<br/></span><span>      </span>widget.NewToolbarSeparator()<span>,<br/></span><span>      </span>widget.NewToolbarAction(theme.DeleteIcon()<span>, </span><span>func</span>() {<br/>      })<span>,<br/></span><span>      </span>widget.NewToolbarAction(theme.CutIcon()<span>, </span><span>func</span>() {<br/>      })<span>,<br/></span><span>      </span>widget.NewToolbarAction(theme.CopyIcon()<span>, </span><span>func</span>() {<br/>      })<span>,<br/></span><span>      </span>widget.NewToolbarAction(theme.PasteIcon()<span>, </span><span>func</span>() {<br/>      })<span>,<br/></span><span>   </span>)<br/>}</pre>
<p>To use this new method, we update the toolbar creation code in the <kbd>main()</kbd> method to read simply <kbd>toolbar := buildToolbar(mailApp)</kbd>. With these changes in place, we see a full toolbar using the material design icons at the top of the main window, shown as follows:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/56e8b97f-fc33-427f-99d7-0e7eabc9ddc4.png" style="width:15.50em;height:3.67em;" width="598" height="143"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The built-in Fyne toolbar provides default icons for many actions</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating with the GUI</h1>
                </header>
            
            <article>
                
<p>Setting up the user interface to show real data and perform the appropriate interactions is as simple as setting text values and filling in click handlers. To begin with, we will add two helper methods.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Loading emails</h1>
                </header>
            
            <article>
                
<p>The first new function, <kbd>setMessage()</kbd>, will simply call <kbd>SetText()</kbd> on each of our <kbd>widget.Label</kbd> elements. This requires saving a reference to the <kbd>to</kbd>, <kbd>from</kbd>, <kbd>date</kbd>, <kbd>subject</kbd>, and <kbd>content</kbd> label widgets that were created earlier in this section. Their content can be updated using the <kbd>SetText()</kbd> function as follows:</p>
<pre><br/><span>func </span><span>setMessage</span>(email *client.<span>EmailMessage</span>) {<br/>   subject.SetText(email.Subject)<br/><br/>   to.SetText(email.ToEmailString())<br/>   from.SetText(email.FromEmailString())<br/>   date.SetText(email.DateString())<br/><br/>   content.SetText(email.Content)<br/>}</pre>
<p>We will also create another helper function, <kbd>addEmail()</kbd>, to add a new email to the list. This is a change from the initial list of <kbd>widget.Labels</kbd> that we added to <kbd>widget.Group</kbd>—we are using buttons to utilize their built-in click handling. The button created in this function sets the label to be the email subject, as before, and calls the new <kbd>setMessage()</kbd> function if it is tapped:</p>
<pre><span>func </span><span>addEmail</span>(email *client.<span>EmailMessage</span>) fyne.<span>CanvasObject </span>{<br/>   <span>return </span>widget.NewButton(email.Subject<span>, </span><span>func</span>() {<br/>      setMessage(email)<br/>   })<br/>}</pre>
<p>Then, the list code is updated to call the new <kbd>addEmail()</kbd> function when we load the user interface:</p>
<pre>list := widget.NewGroup(<span>"Inbox"</span>)<br/><span>for </span>_<span>, e</span>mail := <span>range </span>server.ListMessages() {<br/>   list.Append(addEmail(email))<br/>}</pre>
<p>Those are the only changes that we need to implement in order to make the browser interface functional. Now, let's add the appropriate handling code to the compose window.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending email</h1>
                </header>
            
            <article>
                
<p>To complete the work on the compose view, we need to update the buttons callback. For the cancel button, all that's necessary is to call <kbd>Close()</kbd> on the window object. In the click handler for the send button, we will construct a new email and send it using the server object's <kbd>Send()</kbd> function. The <kbd>client.NewMessage()</kbd> function handles creation of the email object. All we need to do is use the <kbd>Entry.Text</kbd> field for each input in order to access the current state:</p>
<pre>send := widget.NewButton(<span>"Send"</span><span>, </span><span>func</span>() {<br/>   email := client.NewMessage(subject.Text<span>, </span>content.Text<span>,<br/></span><span>      </span>client.<span>Email</span>(to.Text)<span>, </span><span>""</span><span>, </span>time.Now())<br/>   server.Send(email)<br/>   compose.Close()<br/>})<br/>send.Style = widget.<span>PrimaryButton<br/></span>buttons := widget.NewHBox(<br/>   layout.NewSpacer()<span>,<br/></span><span>   </span>widget.NewButton(<span>"Cancel"</span><span>, </span><span>func</span>() {<br/>      compose.Close()<br/>   })<span>,<br/></span><span>   </span>send)</pre>
<p>With this code in place, the application should function in exactly the same way as the previous examples we've built. Although the compose window does not look any different, our email browser window now has some real data in that should look like this:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/c7280b53-4868-492e-a8b0-d20accbd3788.png" style="width:23.00em;height:12.75em;" width="677" height="374"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The completed GoMail interface in Fyne's default dark theme</div>
<p>As Fyne provides two built-in themes, we can also see how the application looks if users prefer a light colored theme. By setting the <kbd>FYNE_THEME</kbd> environment variable to "light", we can load the alternative theme, demonstrated as follows:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f43ebdf7-ea09-4023-82d9-b3354e38e929.png" style="width:26.92em;height:6.75em;" width="767" height="190"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">You can either set FYNE_THEME in the environment or pass it to the run command</div>
<p>Setting the correct theme value will result in a light version of the application loading instead:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/bc399f14-aaba-4b9a-ad89-5ce43ac3ad91.png" style="width:23.83em;height:13.50em;" width="679" height="385"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Our GoMail interface with the light Fyne theme</div>
<p>Before we complete this application, we should also cover the background processing portion—to handle when a new email arrives.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background processing</h1>
                </header>
            
            <article>
                
<p>Background processing that updates the user interface does not require any special thread handling code with Fyne. You can execute the full set of graphical and widget commands in any goroutine—the toolkit will take care of any system thread management.</p>
<p>To add incoming emails to the list in our application, all we need to do is call <kbd>addEmail()</kbd> for the new <kbd>client.EmailMessage</kbd> and pass that to the <kbd>list.Prepend()</kbd> function. The code is as straightforward as the following:</p>
<pre><span>go func</span>() {<br/>   <span>for </span>email := <span>range </span>server.Incoming() {<br/>      list.Prepend(addEmail(email))<br/>   }<br/>}()</pre>
<p>That completes our basic GoMail application. Given the Fyne project's similarities to the Shiny toolkit that we explored in <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a>, <em>Shiny – Experimental Go GUI API</em>, let's also see how we could rebuild the image viewer application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building an image viewer</h1>
                </header>
            
            <article>
                
<p>Since the Fyne toolkit includes a canvas API and image handling similar to the Shiny project, it makes sense to also compare with the image viewer application that we created in <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a><span>, </span><em>Shiny – Experimental Go GUI API</em>. Let's start, as usual, with the basic application layout.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>As we will be working with canvas APIs, as well as widgets and layouts, we will need to start by importing most of the Fyne sub-packages. In addition to <em>canvas</em>, where we get the basic image APIs, we will also use the <kbd>theme</kbd> package for accessing icons and the <kbd>app</kbd> package to launch our application. We don't need to import the image libraries, such as <kbd>image/jpeg</kbd>, because Fyne image widgets import them for us:</p>
<pre><span>import </span>(<br/><span>   "fyne.io/fyne"<br/></span><span>   "fyne.io/fyne/app"<br/></span><span>   "fyne.io/fyne/canvas"<br/></span><span>   "fyne.io/fyne/layout"<br/></span><span>   "fyne.io/fyne/theme"<br/></span><span>   "fyne.io/fyne/widget"<br/></span>)</pre>
<p>As with any Fyne application, we start by creating an application using <kbd>app.New()</kbd> and then create a window for the application by calling <kbd>NewWindow()</kbd> with an appropriate title:</p>
<pre><span>func </span><span>main</span>() {<br/>   imageApp := app.New()<br/>   win := imageApp.NewWindow(<span>"GoImages"</span>)<br/><br/>   ...<br/>}</pre>
<p>Next, we will create the widgets for the main layout. To achieve a visually distinct navigation bar, let's use a toolbar as in the GoMail application. In addition to standard icon buttons, we also add a spacer (with <kbd>widget.NewToolbarSpacer()</kbd>) so that the second button is right aligned in the bar. We will come back to the navigation later to add the filename display and functionality.</p>
<p>Next, we use the <kbd>widget.Group</kbd> widget to visually group the file listing (we could use the <kbd>widget.Box</kbd> widget if the border-less look is preferred). Into the group, we append various labels that will serve as file placeholders. Lastly, we load the image view to show the placeholder file. The <kbd>canvas.NewImageFromFile()</kbd> function handles all of the image loading for us, as can be seen in the following code block:</p>
<pre><span>func </span><span>main</span>() {<br/>   ...<br/><br/>   navBar := widget.NewToolbar(<br/>      widget.NewToolbarAction(theme.NavigateBackIcon()<span>, </span><span>func</span>() {})<span>,<br/></span><span>      </span>widget.NewToolbarSpacer()<span>,<br/></span><span>      </span>widget.NewToolbarAction(theme.NavigateNextIcon()<span>, </span><span>func</span>() {}))<br/>   fileList := widget.NewGroup(<span>"directory"</span><span>,<br/></span><span>      </span>widget.NewLabel(<span>"Image 1"</span>)<span>,<br/></span><span>      </span>widget.NewLabel(<span>"Image 2"</span>)<span>,<br/></span><span>      </span>widget.NewLabel(<span>"Image 3"</span>))<br/>   image := canvas.NewImageFromFile(<span>"shiny-hall.jpg"</span>)<br/><br/>   ...<br/>}</pre>
<p>For this application, a simple <kbd>layout.BorderLayout</kbd> will provide exactly the layout we are looking for. We create a new layout with <kbd>navBar</kbd> at the top and <kbd>fileList</kbd> on the left. The container also includes <kbd>image</kbd>, which will be stretched to fill the remaining space:</p>
<pre><span>func </span><span>main</span>() {<br/>   ...<br/><br/>   container := fyne.NewContainerWithLayout(<br/>      layout.NewBorderLayout(navBar<span>, </span>nil<span>, </span>fileList<span>, </span>nil)<span>,<br/></span><span>      </span>navBar<span>, </span>fileList<span>, </span>image<span>,<br/></span><span>   </span>)<br/><br/>   ...<br/>}</pre>
<p>Lastly, we set this container to be the content of our window, resize the whole window to be larger than the calculated minimum size, and show it. As before, we use <kbd>ShowAndRun()</kbd> as a shortcut to running the application with this first window:</p>
<pre><span>func </span><span>main</span>() {<br/>   ...<br/><br/>   win.SetContent(container)<br/>   win.Resize(fyne.NewSize(<span>640</span><span>, </span><span>480</span>))<br/><br/>   win.ShowAndRun()<br/>}</pre>
<p>With all of this code in place, the example can be run. You should see a window very much like the following (assuming you are using the default dark theme):</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4e10814f-2052-4dfc-8395-e1e4a3de9fae.png" style="width:32.00em;height:25.67em;" width="960" height="769"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A basic image viewer layout using default Fyne widgets</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Navigation</h1>
                </header>
            
            <article>
                
<p>To complete the navigation bar, we need to also display the filename in the middle of the bar. As you may have noticed, there is no toolbar widget that allows the showing of text, but we can create our own. Every item in a toolbar implements the <kbd>widget.ToolbarItem</kbd> interface, so we can create a new type that follows this pattern. By implementing <kbd>ToolbarObject()</kbd> (the only function this interface requires), we can return the appropriate label to display:</p>
<pre><span>type </span>toolbarLabel <span>struct </span>{<br/>}<br/><br/><span>func </span>(t *<span>toolbarLabel</span>) <span>ToolbarObject</span>() fyne.<span>CanvasObject </span>{<br/>   <span>return </span>widget.NewLabel(<span>"filename"</span>)<br/>}</pre>
<p>While we are updating the navigation bar, we should create placeholder functions that will handle the button presses for "previous" (left arrow) and "next" (right arrow). An empty parameter list matches the function type for a <kbd>widget.Button</kbd> callback, so these are simply as follows:</p>
<pre><span>func </span><span>previousImage</span>() {}<br/><br/><span>func </span><span>nextImage</span>() {}</pre>
<p>Lastly, we update the navigation bar creation to use the new <kbd>toolbarLabel</kbd> type that we created. By adding a second spacer widget, we are asking the layout to center the label as well as retain the right alignment of the <span class="packt_screen">next</span> button:</p>
<pre>navBar := widget.NewToolbar(<br/>   widget.NewToolbarAction(theme.NavigateBackIcon()<span>, </span><span>previousImage</span>)<span>,<br/></span><span>   </span>widget.NewToolbarSpacer()<span>,<br/></span><span>   </span>&amp;<span>toolbarLabel</span>{}<span>,<br/></span><span>   </span>widget.NewToolbarSpacer()<span>,<br/></span><span>   </span>widget.NewToolbarAction(theme.NavigateNextIcon()<span>, </span><span>nextImage</span>))</pre>
<p>With these changes in place, running the code should result in the following updated navigation bar. We will return to this later to set the correct filename, but for now, we shall move on to the file listing on the left of the interface:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/50885e41-fbc9-4dce-892b-2dda4ba901ba.png" style="width:30.92em;height:4.50em;" width="960" height="140"/></div>
<p class="mce-root"/>
<div class="packt_figref CDPAlignCenter CDPAlign">The navigation bar created using customized toolbar components</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">File listing</h1>
                </header>
            
            <article>
                
<p>As the Fyne list widgets do not support icon and text combinations, we will need to construct one from basic components. Within the file group, we update each item to call a new function, <kbd>makeRow()</kbd>, that will be defined later on. We pass the filename to this function so that it can load the image and display a suitable caption:</p>
<pre>fileList := widget.NewGroup(<span>"directory"</span><span>,<br/></span><span>   </span>makeRow(<span>"shiny-hall.jpg"</span>)<span>,<br/></span><span>   </span>makeRow(<span>"shiny-hall.jpg"</span>)<span>,<br/></span><span>   </span>makeRow("<span>shiny-hall.jpg"</span>))</pre>
<p>The new <kbd>makeRow()</kbd> function will return a horizontal box widget containing the image preview and caption text. The preview image is loaded using <kbd>canvas.NewImageFromFile()</kbd> and a suitable size is set using <kbd>SetMinSize()</kbd>. To be consistent in terms of sizing, <kbd>theme.IconInlineSize()</kbd> is used for height and a 50% larger width—assuming most pictures are landscape. Finally, this is returned in a horizontal box, along with a new label widget, using <kbd>widget.NewHBox()</kbd>:</p>
<pre><span>func </span><span>makeRow</span>(text <span>string</span><span>, </span>file <span>string</span>) fyne.<span>CanvasObject </span>{<br/>   preview := canvas.NewImageFromFile(file)<br/>   iconHeight := theme.IconInlineSize()<br/>   preview.SetMinSize(fyne.NewSize(<span>int</span>(<span>float32</span>(iconHeight)*<span>1.5</span>)<span>, </span>iconHeight))<br/><br/>   <span>return </span>widget.NewHBox(preview<span>, </span>widget.NewLabel(text))<br/>}</pre>
<p>With these changes in place, you should see the same interface with icon previews before each filename. Before we are done with the layout, let's polish the image view and see how we can maintain the image aspect ratio:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/ebab6d07-eddd-48f6-977d-48f6f84ffd29.png" style="width:32.08em;height:25.92em;" width="960" height="776"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Placeholder files and image thumbnails added to the interface</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Image view</h1>
                </header>
            
            <article>
                
<p>To complete the image viewer layout, we need to look at the main image view. The default behavior for images in Fyne is that they'll expand to fill the available space (this is the <kbd>canvas.ImageFillStretch</kbd> mode). However, we want the image to maintain its aspect ratio, as well as remain within the bounds of the viewing area. We will also add a background pattern as we did in the Shiny example in <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a>, <em>Shiny – Experimental Go GUI API</em>.</p>
<p>Firstly, we create a new image for the background pattern. Fyne provides a helper method to create an image that's drawn dynamically called <kbd>canvas.NewRasterWithPixels()</kbd>. It takes a single parameter, which is the pixel calculation function that returns <kbd>color.Color</kbd> for the pixel requested. Its parameters are <kbd>x, y, width, height</kbd> (all <kbd>int</kbd> variables). This means that we can use just the <kbd>x</kbd> and <kbd>y</kbd> coordinates, or we can perform calculations based on the width and height values (that specify the number of pixels on each axis).</p>
<p>In our checker pattern implementation, we simply return a light or dark gray color to make a pattern of squares. The blocks are 10 x 10 pixels in size and we calculate which square a pixel coordinate is within, as follows:</p>
<pre><span>func </span><span>checkerColor</span>(x<span>, </span>y<span>, </span>_<span>, </span>_ <span>int</span>) color.<span>Color </span>{<br/>   xr := x/<span>10<br/></span><span>   </span>yr := y/<span>10<br/></span><span><br/></span><span>   </span><span>if </span>xr%<span>2 </span>== yr%<span>2 </span>{<br/>      <span>return </span>color.<span>RGBA</span>{<span>0xc0</span><span>, </span><span>0xc0</span><span>, </span><span>0xc0</span><span>, </span><span>0xff</span>}<br/>   } <span>else </span>{<br/>      <span>return </span>color.<span>RGBA</span>{<span>0x99</span><span>, </span><span>0x99</span><span>, </span><span>0x99</span><span>, </span><span>0xff</span>}<br/>   }<br/>}</pre>
<p>The checker pattern image is created by passing our <kbd>checkerColor</kbd> function to the <kbd>canvas.NewRasterWithPixels()</kbd> function. This variable can now be used like any other <kbd>canvas.Image</kbd> type:</p>
<pre>checkers := canvas.NewRasterWithPixels(<span>checkerColor</span>)</pre>
<p>Additionally, the main image view should be set to maintain its aspect ratio within the available space. To do so, we set the <kbd>FillMode</kbd> field of the <kbd>image</kbd> variable to <kbd>canvas.ImageFillContain</kbd>. Like the CSS3 definition, this will center the image at the largest scaled size that fits within the space:</p>
<pre>image := canvas.NewImageFromFile(<span>"shiny-hall.jpg"</span>)<br/>image.FillMode = canvas.<span>ImageFillContain</span></pre>
<p>Lastly, the checker pattern image is added to our layout. By passing it before the main image object, we specify that it is layered lower in the draw order, and therefore set as a background. Notice that any item not listed as specifically positioned in a border position is sized to fill the remaining space. In this way, our image view is drawn above the background and both are set to fill the space inside our border widgets:</p>
<pre>container := fyne.NewContainerWithLayout(<br/>   layout.NewBorderLayout(navBar<span>, </span>nil<span>, </span>fileList<span>, </span>nil)<span>,<br/></span><span>   </span>navBar<span>, </span>fileList<span>, </span>checkers<span>, </span>image<span>,<br/></span>)</pre>
<p>Updating the code with these changes results in the completed image viewer layout, which should look like the following:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/3f44ffd6-b5b6-4252-bdca-2076819ba71b.png" style="width:32.58em;height:26.42em;" width="960" height="776"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Centering the image over a checkerboard pattern</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating with the GUI</h1>
                </header>
            
            <article>
                
<p>To add the code that handles updating the GUI and responding to user events, we will need to save references to some widgets that have been created; mainly the <kbd>widget.Label</kbd> <span>toolbar </span>and the main view, <kbd>canvas.Image</kbd>. By storing these references, we can update their content later.</p>
<p>Additionally, we will add a <kbd>[]string</kbd> to list <kbd>images</kbd> for the directory we are accessing and save <kbd>int</kbd> <kbd>index</kbd> of the current image so that we can calculate the previous and the next. Once those are created, we can fill in the content of our <kbd>previousImage()</kbd> and <kbd>nextImage()</kbd> functions to call a new <kbd>chooseImage()</kbd> function that will update the display:</p>
<pre><span>var </span>images []<span>string<br/></span><span>var </span>index <span>int<br/><br/>var image *canvas.Image<br/>var label *widget.Label</span><br/><br/><span>func </span><span>previousImage</span>() {<br/>   <span>if </span>index == <span>0 </span>{<br/>      <span>return<br/></span><span>   </span>}<br/><br/>   chooseImage(index-<span>1</span>)<br/>}<br/><br/><span>func </span><span>nextImage</span>() {<br/>   <span>if </span>index == len(images)-<span>1 </span>{<br/>      <span>return<br/></span><span>   </span>}<br/><br/>   chooseImage(index+<span>1</span>)<br/>}</pre>
<p>The <kbd>chooseImage()</kbd> function accesses the file path from the image list that will be loaded later and uses this information to update our user interface. From <kbd>path</kbd>, we call <kbd>label.SetText()</kbd> to show the filename and then set <kbd>image.File</kbd> to update the path for the main image display:</p>
<pre><span>func </span><span>chooseImage</span>(id <span>int</span>) {<br/>   path := images[id]<br/>   label.SetText(filepath.Base(path))<br/>   image.File = path<br/>   canvas.Refresh(image)<br/>   index = id<br/>}</pre>
<p>To most easily implement the click handling behavior in order to choose an image from the list, we will change from <kbd>widget.Label</kbd> to <kbd>widget.Button</kbd> items. As the buttons have a different color background, we should tidy up the display by using <kbd>layout.BorderLayout</kbd> so that the buttons fill the available space. Finally, because buttons are taller than labels, we update the <kbd>minSize()</kbd> <span>preview </span>code to be relative to the button's minimum height rather than the previous inline icon size defined by the theme:</p>
<pre><span>func </span><span>makeRow</span>(id <span>int</span><span>, </span>path <span>string</span>) fyne.<span>CanvasObject </span>{<br/>   filename := filepath.Base(path)<br/>   button := widget.NewButton(filename<span>, </span><span>func</span>() {<br/>      chooseImage(id)<br/>   })<br/><br/>   preview := canvas.NewImageFromFile(path)<br/>   iconHeight := button.MinSize().Height<br/>   preview.SetMinSize(fyne.NewSize(<span>int</span>(<span>float32</span>(iconHeight)*<span>1.5</span>)<span>,<br/></span>      iconHeight))<br/><br/>   <span>return </span>fyne.NewContainerWithLayout(<br/>      layout.NewBorderLayout(nil<span>, </span>nil<span>, </span>preview<span>, </span>nil)<span>,<br/></span><span>      </span>preview<span>, </span>button)<br/>}</pre>
<p class="mce-root">Next, we need to add a <kbd>getImageList()</kbd> function that will access the list of images in a directory. The contents of this function are identical to the same function in <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a>, <span><em>Shiny – Experimental Go GUI API</em>,</span> so it is omitted here for brevity. With that in place, we can update our <kbd>makeList()</kbd> function, which now takes a <kbd>dir</kbd> parameter, to load the image file list and create the new rows using <kbd>makeRow()</kbd>, as well as populating our stored <kbd>images</kbd> list:</p>
<pre><span>func </span><span>makeList</span>(dir <span>string</span>) *widget.<span>Group </span>{<br/>   files := getImageList(dir)<br/>   group := widget.NewGroup(filepath.Base(dir))<br/><br/>   <span>for </span>idx<span>, </span>name := <span>range </span>files {<br/>      path := filepath.Join(dir<span>, </span>name)<br/>      images = append(images<span>, </span>path)<br/><br/>      group.Append(makeRow(idx<span>, </span>path))<br/>   }<br/><br/>   <span>return </span>group<br/>}</pre>
<p>We then update the creation of the <kbd>fileList</kbd> in <kbd>main()</kbd> function to pass a directory path to load:</p>
<pre>fileList := makeList(dirpath)</pre>
<p>As with the previous GoImages code, we can use the built-in <kbd>flag</kbd> handling to allow users to specify the directory to display. The code is listed here and we can invoke it simply by setting the preceding <kbd>dirpath</kbd> variable to the result of <kbd>parseArgs()</kbd> (if you add this code, remember to import the <kbd>flag</kbd>, <kbd>fmt</kbd>, and <kbd>os</kbd> packages):</p>
<pre><span>func </span><span>parseArgs</span>() <span>string </span>{<br/>   dir<span>, </span>_ := os.Getwd()<br/><br/>   flag.Usage = <span>func</span>() {<br/>      fmt.Println(<span>"goimages takes a single, optional, directory parameter"</span>)<br/>   }<br/>   flag.Parse()<br/><br/>   <span>if </span>len(flag.Args()) &gt; <span>1 </span>{<br/>      flag.Usage()<br/>      os.Exit(<span>2</span>)<br/>   } <span>else if </span>len(flag.Args()) == <span>1 </span>{<br/>      dir = flag.Args()[<span>0</span>]<br/><br/>      <span>if </span>_<span>, </span>err := ioutil.ReadDir(dir)<span>; </span>os.IsNotExist(err) {<br/>         fmt.Println(<span>"Directory"</span><span>, </span>dir<span>, </span><span>"does not exist or could not be read"</span>)<br/>         os.Exit(<span>1</span>)<br/>      }<br/>   }<br/><br/>   <span>return </span>dir<br/>}</pre>
<p>Updating all of the preceding code should result in our complete image viewer application. If you'd prefer to access the complete code, this can be downloaded from this book's source code repository on GitHub:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/7d1157ad-a07c-4919-a039-7f1a8d88e503.png" style="width:33.33em;height:27.00em;" width="960" height="776"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Our completed image viewer showing a wallpaper directory</div>
<p>As with the previous GoMail example, we can load this interface using the light theme by specifying <kbd>FYNE_THEME=light</kbd> in the command-line environment:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/b5a2c58a-2b81-4e69-af86-aa614a2a8c61.png" style="width:29.83em;height:24.08em;" width="960" height="776"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The same app and directory with the Fyne light theme</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background processing</h1>
                </header>
            
            <article>
                
<p>With Fyne a lot of image handling is already processing on multiple threads, but that may not be enough for image-intensive applications. In this GoImages app, there are many images being loaded before the user interface is displayed. We can update the image handling to allow the GUI to display faster. To do so, we once again create a new <kbd>asyncImage</kbd> type, that loads the image on a background thread before displaying it. Whereas Shiny was passing the images directly to the rendering, here, we are providing them to a <kbd>canvas.Image</kbd> object, so the code is slightly different.</p>
<p><span>We start by creating the basic <kbd>asyncImage</kbd> type—its main work is in the <kbd>load()</kbd> function, which will run on a background thread. The <kbd>loadPath()</kbd> function sets up the path to the file to be loaded and starts the background processing. Notice that once we've changed the image data, we need to call <kbd>canvas.Refresh()</kbd> to ensure the interface updates—there is no need for any thread-handling code, since Fyne will deal with that for us:</span></p>
<pre><span>type </span>asyncImage <span>struct </span>{<br/>   path   <span>string<br/></span><span>   </span>image  *canvas.<span>Image<br/></span><span>   </span>pixels image.<span>Image<br/></span>}<br/><br/><span>func </span>(a *<span>asyncImage</span>) <span>load</span>() {<br/>   <span>if </span>a.path == <span>"" </span>{<br/>      <span>return<br/></span><span>   </span>}<br/>   reader<span>, </span>err := os.Open(a.path)<br/>   <span>if </span>err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   <span>defer </span>reader.Close()<br/><br/>   a.pixels<span>, </span>_<span>, </span>err = image.Decode(reader)<br/>   <span>if </span>err != nil {<br/>      log.Fatal(err)<br/>   }<br/><br/>   canvas.Refresh(a.image)<br/>}<br/><br/><span>func </span>(a *<span>asyncImage</span>) <span>loadPath</span>(path <span>string</span>) {<br/>   a.path = path<br/>   <span>go </span>a.load()<br/>}</pre>
<p>As this async image loader will be providing raw image data to the image widget, we also need to implement the <kbd>image.Image</kbd> API. In each of the methods, we check to see whether the <kbd>pixels</kbd> variable has been set (it will be <kbd>nil</kbd> until the image is loaded), returning the appropriate value or a sensible fallback:</p>
<pre><br/><span>func </span>(a *<span>asyncImage</span>) <span>ColorModel</span>() color.<span>Model </span>{<br/>   <span>if </span>a.pixels == nil {<br/>      <span>return </span>color.RGBAModel<br/>   }<br/><br/>   <span>return </span>a.pixels.ColorModel()<br/>}<br/><br/><span>func </span>(a *<span>asyncImage</span>) <span>Bounds</span>() image.<span>Rectangle </span>{<br/>   <span>if </span>a.pixels == nil {<br/>      <span>return </span>image.ZR<br/>   }<br/><br/>   <span>return </span>a.pixels.Bounds()<br/>}<br/><br/><span>func </span>(a *<span>asyncImage</span>) <span>At</span>(x<span>, </span>y <span>int</span>) color.<span>Color </span>{<br/>   <span>if </span>a.pixels == nil {<br/>      <span>return </span>color.Transparent<br/>   }<br/><br/>   <span>return </span>a.pixels.At(x<span>, </span>y)<br/>}</pre>
<p>Lastly, our <kbd>asyncImage</kbd> type would benefit from a convenience constructor to set up the <kbd>image</kbd> widget that will render. We also begin the loading of the first image file, <kbd>path</kbd>, on a background thread:</p>
<pre><span>func </span><span>newAsyncImage</span>(path <span>string</span>) *<span>asyncImage </span>{<br/>   async := &amp;<span>asyncImage</span>{}<br/>   async.image = canvas.NewImageFromImage(async)<br/>   async.loadPath(path)<br/><br/>   <span>return </span>async<br/>}</pre>
<p>To complete the use of our asynchronous image loader, we update the <kbd>chooseImage()</kbd> function to set the new path. With this change, the application will be loading all images on a background thread instead of on the main loop. Go will distribute this across our processors appropriately to make use of the available CPU:</p>
<pre><span>func </span><span>chooseImage</span>(id <span>int</span>) {<br/>   path := images[id]<br/>   label.SetText(filepath.Base(path))<br/>   async.loadPath(path)<br/>   index = id<br/>}</pre>
<p>Running this new version of the application will load noticeably faster. You'll also see the images appear as the loading of each file is completed. By using the simple <kbd>canvas.Refresh()</kbd> call after we load each image, we ensure that the user interface updates appropriately.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at the last of the toolkits to be explored in this book, Fyne. We learned how it was created specifically for Go so as to make it simple to build graphical applications. We quickly got set up with the toolkit and explored how to build applications that will run identically on macOS, Windows, and Linux.</p>
<p>We looked at the architecture of the Fyne toolkit and its use of vector graphics to provide scalable graphical interfaces. By learning the features of the <kbd>layout</kbd>, <kbd>canvas</kbd>, and <kbd>widget</kbd> packages, we saw how to quickly build basic user interfaces. We also saw how Fyne provides two different themes, <em>light</em> and <em>dark</em>, which will be used based on user settings or environment variables.</p>
<p>Applying this knowledge, we built the sixth version of our GoMail application, which included built-in material design icons and avoided any thread-handling complexities. We also explored the image APIs and background processing capabilities by re-building the GoImages application designed in <a href="9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml">Chapter 8</a>, <em>Shiny – Experimental Go GUI API</em>.</p>
<p>Now that we've explored the main toolkits available, we will move to <a href="935a315b-9890-4c6a-a126-3dda28108886.xhtml">Section 4</a>, <em>Growing and Distributing Your Application</em><em>.</em> In the final part of this book, we change focus to topics that apply to all graphical applications, regardless of the toolkit used. We will explore topics that help polish and distribute complete graphical user interfaces<em>,</em> starting with <a href="03c04362-6937-47f3-a2de-cd99d9ae9080.xhtml">Chapter 11</a>, <em>Navigation and Multiple Windows.</em></p>


            </article>

            
        </section>
    </div>



  </body></html>