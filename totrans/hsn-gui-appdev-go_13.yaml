- en: Fyne - Material Design-Based GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fyne is a UI toolkit and application API designed to be easy to use. Its interface
    design follows the material design principles, providing cross-platform graphics
    that appear identical on all supported platforms. This chapter explores how to
    write graphical applications for multiple platforms with Fyne.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The vision and design of the Fyne project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple Fyne-based application for multiple platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API design and the widgets provided by Fyne
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a complete application using Fyne
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have an understanding of Fyne project's
    ambitions and will have built multiple cross-platform graphical applications using
    the toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Background and vision for Fyne
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fyne project was created by Andrew Williams (the author of this book) in
    response to growing criticism of the complexity in existing graphical toolkits
    and application APIs. It was designed with the aim of being easy to use, and the
    Go language was chosen for its powerful simplicity. Like the Shiny project we
    explored in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny –
    Experimental Go GUI API*, its APIs benefit from being created specifically for
    the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: As with the other widget toolkits in [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits,* it facilitates the building of graphical applications that
    look identical across all platforms, rather than adopting the look and feel of
    the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '"Fyne''s APIs aim to be the best for developing beautiful, usable, and lightweight
    applications for desktop and beyond."'
  prefs: []
  type: TYPE_NORMAL
- en: -[g](https://github.com/fyne-io/fyne/wiki/Vision)[ithub.com/fyne-io/fyne/wiki/Vision](https://github.com/fyne-io/fyne/wiki/Vision)
  prefs: []
  type: TYPE_NORMAL
- en: The toolkit was initially built using the Enlightenment Foundation Libraries
    (EFL: [enlightenment.org/about-efl](https://www.enlightenment.org/about-efl))
    to facilitate cross-platform rendering. Since then, Fyne has moved to an OpenGL-based
    driver, much like the nk package from the previous chapter. This makes for a much
    simpler setup and means that there are no runtime dependencies for apps created
    with Fyne. Before we examine the toolkit in detail, let's see how to set up a
    simple Fyne application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Fyne
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start building a Fyne application, we will step through the installation
    and run an example application. For most systems, the setup is as simple as installing
    the `fyne.io/fyne` package using standard Go tools. For some systems, however,
    there are development prerequisites to check, so let's start there.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the majority of platforms, there are no installation requirements to begin
    using Fyne. On macOS and Windows, the toolkit uses built-in OpenGL capabilities,
    so you can skip straight to the following *Setup* section (however, if you are
    developing for the first time on macOS, examine the following notes). If you are
    working with Linux (or another Unix system), then it may be necessary to install
    a number of system header files.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile on Linux, you will need to have the Xorg and GL (*mesa* or similar)
    headers installed (this is not required for running the applications). The specifics
    will vary from system to system, but the most common requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Debian / Ubuntu:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libgl1-mesa-dev` and `xorg-dev`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fedora / CentOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libX11-devel`, `libXcursor-devel`, `libXrandr-devel`, `libXinerama-devel`,
    `mesa-libGL-devel`, and `libXi-devel`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Arch Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mesa`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On a development computer these packages may well already be installed, but
    if you have compile errors later in this chapter, the first thing to check would
    be that these packages, or their equivalent for your system, are installed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For developing on macOS, you must have the Xcode command-line tools installed.
    If you''ve been working with C or CGo previously, then this is probably already
    set up; if not, then you may need to execute the `xcode-select --install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9569940d-c5c1-4d39-b3da-63f83bd7a487.png)'
  prefs: []
  type: TYPE_IMG
- en: If you don't already have the command-line tools installed, then xcode-select
    will display this prompt
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up the Fyne API for use is as simple as downloading it using the `go
    get` command. The project is accessed from its base import name, `fyne.io/fyne`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/142daf59-b48e-4740-aa96-f72150ff3dd9.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing Fyne is easy once CGo is set up
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Fyne toolkit comes with an example application built in that can be used
    to explore its features and assets. We can use this to verify that the setup is
    working. Simply use the Go tools to install the application and then run it using
    the `fyne_demo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c05a4a8b-4994-442a-b39f-752141715fcf.png)'
  prefs: []
  type: TYPE_IMG
- en: Install and run the fyne_demo command from the project repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the demo application opens a single window that offers various options
    to explore. If we tap on a few items, additional windows will open and you should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cf3c5f8-e8fb-4d4c-b51d-dff87a681a41.png)'
  prefs: []
  type: TYPE_IMG
- en: Some of the features demonstrated in Fyne's example application
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic *Hello World* application with Fyne is quite succinct, as the application
    setup is encapsulated in a single call. The entry point, `app.New()`, provided
    by the `app` sub-package, sets up a new application that we use to open a new
    window. The `widget` sub-package defines the various widgets available that we
    can add to our new window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code block, the newly created `fyne.Window`
    has its content set to a new `widget.VBox` that provides the basic layout. Into
    this, we add a *Hello World*! label using `widget.NewLabel()` and a Quit button
    using `widget.NewButton()`. The second parameter to the button is `func()`, which
    will be called when the button is tapped.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we call `ShowAndRun()` on the window we created. This function will
    show the window and start the application `event` loop. It is shorthand for `win.Show();
    app.Run()`.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This simple application can be run directly with `go run hello.go`, or built
    using `go build hello.go` and then run using the compiled binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41bfc04d-4c83-40d7-8518-ec246c5f55f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Compiling or running directly works the same on any supported system
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code should produce a simple app that looks like the following.
    Clicking the Quit button or closing the window will exit the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc83f9a8-9447-4a22-9dfb-d3c97c3d4d4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Running Hello World on macOS
  prefs: []
  type: TYPE_NORMAL
- en: Cross compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the dependency on CGo, compiling for a platform other than the one you
    are developing in is, unfortunately, not as simple as setting the `GOOS` environment
    variable. Building for a different platform requires an installation of the C
    compiler for the target operating system. If you've been working through the previous
    chapters, then this may already be set up, but if not, then the process is documented
    in [Appendix 2](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler Setup*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the appropriate compiler installed, then the build process is
    configured by setting the `GOOS`, `CGO_ENABLED`, and `CC` environment variables.
    You may also need to update your path—it''s advisable to put this in your Terminal
    or shell configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95877658-3203-477c-905d-42e4fe47359d.png)'
  prefs: []
  type: TYPE_IMG
- en: Building from Linux for macOS and Windows is a case of using the correct compiler
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored the details of getting up and running and compiling
    for multiple platforms, let's look more at how Fyne is designed and organized.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering and vector graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fyne widgets (much like those in the Nuklear library in [Chapter 9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml),
    *nk – Nuklear for Go*) are made up of simple graphical objects that the render
    drivers are responsible for drawing. The driver is included as part of the package,
    and so no additional setup is required to start an application. Similar to the
    Shiny toolkit (that we explored in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    – Experimental Go GUI API*), the iconography is all vector-based, which Fyne uses
    to create scalable user interfaces that adapt to the device screen density.
  prefs: []
  type: TYPE_NORMAL
- en: Vector graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vector graphics refers to images that are made up of lines and shapes rather
    than a collection of pixels (referred to as raster graphics). Whilst these images
    can be slower to load, they're excellent for drawing perfect images at any scale.
    As computer screens and smart phones have continued to increase their pixel density,
    measured in **Dots Per Inch** (**DPI**), it has become more difficult to produce
    raster graphics that look good on all devices. Platforms such as iOS have historically
    approached this by requiring multiple files of the same content at different resolutions—such
    as `Icon.png`, `Icon@2x.png`, and `Icon@3x.png` (which could be, for example,
    60 x 60, 120 x 120, or 180 x 180 pixels, respectively)—so that the closest match
    image for the screen can be used. With a vector icon, you would provide a single
    image, `Icon.svg` (**Scalable Vector Graphics**), that can be drawn at exactly
    the resolution required for a sharp image.
  prefs: []
  type: TYPE_NORMAL
- en: The Fyne toolkit uses vector graphics throughout so that applications built
    using it can scale appropriately for any computer screen. When an application
    starts, it calculates the pixel density (DPI) of the current screen and sets an
    appropriate scale for the application. Additionally, when a Fyne window is moved
    to a screen with a different resolution, the content (and window containing it)
    will re-size accordingly. This means that when an application running on a laptop
    (typically, a high-resolution screen) moves to an external monitor (usually a
    lower resolution), the window will be resized to a smaller number of pixels to
    try and maintain a consistent size for the user. If you wish to override the scale
    that's auto detected, then it is possible to set a `FYNE_SCALE` environment variable
    before launching the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of setting scale values—notice the crisp text and icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/814807d2-14b4-4bd6-8fd9-dd1a04d5dc98.png)'
  prefs: []
  type: TYPE_IMG
- en: FYNE_SCALE=0.5
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1ed9bea-dd20-4113-a50a-c3036ee6ca7b.png)'
  prefs: []
  type: TYPE_IMG
- en: FYNE_SCALE=2.5
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, it may be appropriate to use a raster image instead of
    a vector. This is usually helpful if you want to draw exactly as many pixels as
    are visible in the space available. An example of this may be found in image manipulation
    programs or when drawing the result of a complex calculation. For these situations,
    there is a type of image within the Fyne API (created with `canvas.NewRaster()`)
    that provides this functionality. One of the examples provided by Fyne is a fractal
    viewer, where each pixel is calculated and drawn using the raster image feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78962a72-b4cd-40b7-a867-c4a9fb0f31ea.png)'
  prefs: []
  type: TYPE_IMG
- en: A mandelbrot fractal calculated per-pixel for the output device. Observe the
    level of detail
  prefs: []
  type: TYPE_NORMAL
- en: Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A driver in Fyne is responsible for rendering the text, canvas objects, and
    images, as well as handling window management and user input. The drivers are
    also required to handle any thread management behind the scenes. By adopting this
    design, it is possible for background processes or asynchronous events to update
    the user interface without any of the thread management code that is common in
    many graphical toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: The default driver for Fyne uses Go-GL and the Go GLFW bindings, which means
    it has the same dependencies as the examples we worked through in the previous
    chapter, *nk – Nuklear for Go*. If your computer, and that of your target customers,
    supports OpenGL (which includes all recent desktop computers, most laptops, smart
    phones, and tablets, and beyond), then you don't need any additional libraries
    or support packages. Having the appropriate Go developer tools installed (see
    *Prerequisites* within the *Getting started with Fyne*, discussed earlier) is
    all you need, and there are no runtime requirements for users of your apps.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to build for an older computer, or one that does not have support
    for OpenGL, it is possible to use the alternative `efl` driver. This driver uses
    the Enlightenment Foundation Libraries to handle rendering, window management,
    and user input in a cross platform manner. Their years of development for a wide
    range of platforms (alongside desktop platforms, they support Playstation, Tizen,
    Samsung Gear watch, and various set-top boxes) means that applications could potentially
    run on a wider range of devices. To run using this driver, just add `-tags efl` to
    any go build or run command, such as `go run -tags efl hello.go`. While this driver
    does offer better multi-platform support, it also requires that the EFL libraries
    are installed both on the developer's computer and the target device. For this
    reason, it is often not the preferred approach when working with Fyne.
  prefs: []
  type: TYPE_NORMAL
- en: Supported platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the different Fyne drivers have potentially different supported platforms,
    the core toolkit just supports a standard set of operating systems. At the time
    of writing, this covered macOS, Windows, Linux, and BSD variants. Any operating
    system-specific code understands how applications should function on each of these
    target. Unlike the other toolkits in [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits,* Fyne is designed to provide APIs for managing applications
    as well as their graphical interfaces. For example, `app.OpenURL()` allows an
    application to launch an external document in the default browser for each supported
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored the Fyne project background, as well as its design and
    operating system support, let's explore the APIs it provides to application developers.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas, widgets, and layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fyne API is divided into various sub-packages for basic drawing definition,
    container layout, high-level widgets, and theme description. In this section,
    we will look at each in turn. These packages provide the implementation details
    that are useful from an application developer point of view, and they typically
    implement generic interfaces. These interface definitions are at the top level
    of the hierarchy and include things such as `fyne.CanvasObject` (which is implemented
    by any object that can be added to a canvas), `fyne.Container` (that describes
    how multiple objects can be grouped and laid out), and `fyne.Resource` (representing
    an embedded application resource, such as an icon or font). Additionally, there
    are some math and geometry utilities as well as definitions for event and text
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: There are additional packages that we will not cover, including `dialog` (helpful
    classes for common dialog windows), `driver` (which is where drivers are loaded
    from), and `test` (which provides helpful test facilities). Let's explore the
    other, more commonly used, packages.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas (drawing)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `canvas` package includes definitions of all of the basic drawing objects
    that Fyne understands. Each of these types defines a number of fields that represent
    the configuration, such as color, size, and visibility. These are the objects
    that a Fyne driver will iterate over, drawing each to create the rendered user
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Circle` | This is a circle, or ellipse, defined by the bounding top-left
    to bottom-right rectangle. It could be created with `NewCircle()` or `&Circle{}`.
    It isn''t commonly used in most applications. |'
  prefs: []
  type: TYPE_TB
- en: '| `Image` | An image may be a vector or bitmap-based image loaded from a file
    (with `NewImageFromFile()`) or embedded resource, or it may be an image generated
    dynamically to fill available space (using `NewRaster()` and a `func(w, h int)
    *image.Image` callback). |'
  prefs: []
  type: TYPE_TB
- en: '| `Line` | This is a simple line that draws from one position to another. It
    isn''t commonly used unless drawing diagrams. |'
  prefs: []
  type: TYPE_TB
- en: '| `Rectangle` | The basic building block for widgets, a rectangle draws an
    area with a specified color. Create with `NewRectangle()` or `&Rectangle{}`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Text` | The text canvas primitive draws a single string to screen in a specified
    color and alignment. It does not handle any special characters or formatting.
    It can be created directly using `&Text{}` or with the helper `NewText()` function.
    |'
  prefs: []
  type: TYPE_TB
- en: The preceding list makes up the primitive drawing elements of the Fyne canvas.
    Next, we look at how layouts can be used to position them within a container.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multiple objects in Fyne are grouped in a `fyne.Container` type and its child
    objects are laid out by `fyne.Layout`. Various standard layouts are provided,
    as detailed in the following table. A layout provides two functions: first, it
    manages the size and position for a list of `fyne.CanvasObject` objects; and second,
    it must define the minimum size required to fit all of the objects it arranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `BorderLayout` | The border layout places a specific canvas object at each
    of the top, bottom, left, and right edges of a container. Any other objects in
    the container will fill the central space. |'
  prefs: []
  type: TYPE_TB
- en: '| `BoxLayout` | The box layout is either vertical or horizontal (created with
    `NewVBoxLayout()` or `NewHBoxLayout()` functions). It will arrange items in a
    list, each at their minimum height (vertical) or width (horizontal), and the other
    dimension will expand to the container edge. A box layout may also contain a spacer
    that will expand to fill available space (normally created with `NewSpacer()`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FixedGridLayout` | The fixed grid layout specifies the size of every cell
    and then arranges them in rows within the available space. A new row is created
    when the next widget would have extended beyond the container width. |'
  prefs: []
  type: TYPE_TB
- en: '| `GridLayout` | The grid layout has a specified number of columns and each
    child object will be the appropriate fraction of the container width. The height
    is defined similarly, depending on the number of child canvas objects. For example,
    with five objects in two columns, there will be three equal height rows. |'
  prefs: []
  type: TYPE_TB
- en: '| `MaxLayout` | This is the simplest layout. Every item is set to the same
    size to fill the available space. Be careful to specify container objects in the
    correct order (the first will be drawn under any subsequent items). For example,
    a button may simply be a rectangle with text positioned above where both should
    expand equally. |'
  prefs: []
  type: TYPE_TB
- en: It is also possible to write a custom layout by implementing the `fyne.Layout`
    interface. The `MinSize()` function should determine the size required (probably
    respecting the `MinSize()` function of the child objects) and the `Layout()` function
    calls `Move()` and `Resize()` on child objects to configure the display for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Whilst containers and layouts are useful, most of our time will be spent with
    higher-level widget definitions, so let's see what is available.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fyne widgets are divided into two parts: the behavior, which is what the main
    API exposes, and the renderer, which controls how a widget will look. Unless you
    are building a custom widget, it is not recommended to access the render functionality
    (hidden behind the `widget.Renderer()` utility function). Customization of the
    user interface, if required, should be managed using the `theme` package (refer
    to the next section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'All widgets can be created using their constructing function (such as `NewButton("text",
    callback)`) or using the initializer syntax, such as `&Button{Text: "text", OnTapped:
    callback}`. If the latter is used, then fields can also be set immediately after
    the widget is initiated until it is first rendered. After a widget is shown, setter
    functions, such as `SetText()`, should be used to ensure that the GUI is updated
    to reflect the changes. Widget fields can still be useful—if you want to update
    multiple properties at once, you can set the appropriate fields to be applied
    in a single refresh. Just be sure to call `widget.Refresh(myObject)` once you''ve
    applied the changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The full list of widgets at the time of writing is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Box` | This is a simple widget that uses a `layout.BoxLayout` to arrange
    the child objects in horizontal or vertical lists. |'
  prefs: []
  type: TYPE_TB
- en: '| `Button` | The basic button contains text and/or an icon and will call a
    passed `func()` when it is tapped. |'
  prefs: []
  type: TYPE_TB
- en: '| `Check` | A check widget displays a label next to a check box and triggers
    a `func(bool)` callback if it is toggled. |'
  prefs: []
  type: TYPE_TB
- en: '| `Entry` | A text entry widget for single- or multiple-line input. |'
  prefs: []
  type: TYPE_TB
- en: '| `Form` | The form widget lays out a simple data form, with labels in one
    column and input widgets on the other. Setting `OnSubmit` or `OnCancel` fields
    for callbacks will include the appropriate buttons on an additional row. |'
  prefs: []
  type: TYPE_TB
- en: '| `Group` | A visual grouping of child objects. A line is drawn around the
    items and a title label is drawn above them. |'
  prefs: []
  type: TYPE_TB
- en: '| `Icon` | A simple widget for drawing a themed icon. Create it with an icon
    resource (refer to *Themes* in the following section), and it will adapt to the
    current theme configuration. |'
  prefs: []
  type: TYPE_TB
- en: '| `Label` | This is a simple text widget that draws using the current theme
    text color and updates if that changes. |'
  prefs: []
  type: TYPE_TB
- en: '| `PasswordEntry` | The same as for the preceding `Entry` widget, but the text
    is hidden as `*` characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `TabContainer` | Similar to a standard container, except that it can display
    different contents. Each child container is associated with a tab button that,
    when pressed, will show the appropriate content. |'
  prefs: []
  type: TYPE_TB
- en: '| `Toolbar` | A toolbar widget shows a row of icon buttons, optionally separated
    with `NewToolbarSpacer()` (an invisible space) or `NewToolbarSeparator()` (a thin
    line to show the grouping). |'
  prefs: []
  type: TYPE_TB
- en: It is possible to implement your own widgets—all they need to do is implement
    the `fyne.Widget` interface. As well as the basic `fyne.CanvasObject` functions,
    a widget must also define a `CreateRenderer()` function returning a `fyne.WidgetRenderer`
    instance. A widget renderer is similar to a container object, but it also has
    a background color and should reflect the current theme (the required `ApplyTheme()`
    function will be called on all widgets if the theme is changed). As we've mentioned
    it many times, let's now explore more of what a Fyne theme provides.
  prefs: []
  type: TYPE_NORMAL
- en: Themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `theme` package is an implementation of a material design inspired user
    interface. It provides the color palette, icons, font, and spacing information
    required to display the Fyne user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f634169-9efc-449a-aa9b-bb3b408b1045.png)'
  prefs: []
  type: TYPE_IMG
- en: The "baseline" material design color palette. Fyne uses a blue/gray variant
    by default
  prefs: []
  type: TYPE_NORMAL
- en: Widgets utilize the theme package extensively to match the current settings.
    For example, a button will be colored `theme.ButtonColor()` (unless it is a primary
    button, in which case it's `theme.PrimaryColor()`) and a label text is `theme.TextColor()`.
    Fyne also packages a standard font that can be accessed using `theme.TextFont()`
    (and variations), but these are not often needed. Instead, use `fyne.TextStyle`
    properties on a text object or label. However, `theme.TextSize()` and `theme.Padding()`
    are useful ways to match the user interface style in a custom widget.
  prefs: []
  type: TYPE_NORMAL
- en: Fyne themes also provide a collection of material design icons that can be used
    in any application, for example, `theme.ContentPasteIcon()`. Icons loaded from
    a theme will adapt to a new theme loading when used with any standard widgets.
    These icons are bundled with the toolkit and do not require any installation or
    additional items to be shipped with an application.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you use a theme method, it's important to realize that the result may
    change over time—a new theme could be loaded or the user may change the configuration.
    To handle this correctly, you should implement `fyne.ThemedObject`, which requires
    a single function, `ApplyTheme()`. Inside this function, you should re-apply any
    theme-based values that were accessed. This functionality is handled automatically
    by widgets, so it is not commonly required that an application handles theme changes.
  prefs: []
  type: TYPE_NORMAL
- en: Packaged themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Fyne toolkit provides two themes to match a user''s preference—a light
    theme and a dark theme. To change the theme for an application, the environment
    variable, `FYNE_THEME`, can be set to *light* or *dark*. If you are implementing
    a custom widget, it''s advisable to test it with at least these two themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a3c5abd-2738-4a79-a741-189e46afb8b6.png)'
  prefs: []
  type: TYPE_IMG
- en: The default dark theme
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6793a240-1c09-440d-801e-556769b1a86d.png)'
  prefs: []
  type: TYPE_IMG
- en: The alternative light theme
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Fyne does not provide the ability to download user-created
    custom themes, but this may change in the future. It is, however, possible for
    an application to be displayed using its own theme. After implementing the `fyne.Theme`
    interface, you should pass an instance of the type to your application configuration
    using `app.Settings().SetTheme()`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore the Fyne toolkit further, let's build our latest version of the GoMail
    application designed in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    *Walk – Building Graphical Windows Applications*. We will start by setting out
    the basic application layout.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a complex layout with Fyne is a case of combining multiple containers,
    each of which are using one of the layouts provided. It would be possible to write
    our own layout to set up the interface with a single container, but for this exploration,
    we will use only the built-in components. Let's start by creating the main application
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Main email window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To load the first window of a Fyne application, we must create a new application
    instance using `app.New()`. After that, we can call the `NewWindow()` function
    on this application object. The returned `fyne.Window` object allows us to control
    the window on screen and to set its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will create the required widgets for our GUI. This starts by adding
    the widget import line, and then we add the declarations to the `main()` function
    created previously. A toolbar is added using `widget.NewToolbar()` (we will add
    items to it later). For the email list on the left, we create a new titled group
    using `widget.NewGroup()` with the title `Inbox`. Into this group we add placeholder
    labels using `widget.NewLabel()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create new labels for the content and subject of the email to display.
    We set the text of the subject label using a `fyne.TextStyle` declaration. Lastly,
    we set up the grid layout for our email metadata using `widget.NewForm()`. A form
    widget matches our design of where we list rows with a bold text label next to
    the widget it describes. To the form, we append the **To**, **From**, and **Date** items, shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined all of the widgets, we need to lay them out appropriately.
    In Fyne, we typically use a `fyne.Container` object and optionally pass a layout
    to control how it is set up. There are also some helper widgets that provide easier-to-use
    APIs, such as `widget.NewVBox()` used in the following section (that sets up a
    container where items are arranged in a vertical list).
  prefs: []
  type: TYPE_NORMAL
- en: In both containers in this code snippet, we are using `BorderLayout`. When calling
    `layout.NewBorderLayout()`, we pass the objects that should be positioned in the
    top, bottom, left, and right positions of the layout (or `nil` if they are to
    be left empty). Any items that are included in the container not listed in a particular
    position will be arranged to fill the center of the layout, taking up all remaining
    space. Remember that items to be placed in one of the border sections should also
    be passed into the `fyne.NewContainerWithLayout()` function as subsequent parameters,
    as this controls which objects will be drawn within the container. Refer to the
    following section to see how `subject` and `box` are passed to the layout as well
    as the container, as we wish them to be positioned by the layout and drawn by
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first container (`detail`), we''ve set the `subject` label to stretch
    along the top and the `box` containing our metadata and content to be left-aligned
    within the container. The following container (`container`) is our overall application
    layout and it positions the `toolbar` at the top, the email `list` on the left,
    and the `detail` container fills the remaining space for the layout (since it
    is not specified as a border parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With all of the containers and layouts defined, we need to complete the window
    by setting its content and optionally specifying a size. You may not have to call
    the `Resize()` function on a window—its default size will be the appropriate size
    to fit all of the widgets and containers at their minimum size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call `ShowAndRun()` on the window, which will cause the window
    to appear and the application''s main loop to start. Any subsequent windows can
    simply call `Show()` (since an application should only start once):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code (which can be found in the source code repository
    for this book) should result in a window much like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2111f93c-7306-4e2c-a3ca-16df5e2be976.png)'
  prefs: []
  type: TYPE_IMG
- en: The basic application layout with Fyne. The bar at the top is an empty toolbar
  prefs: []
  type: TYPE_NORMAL
- en: Compose dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start our secondary window, the compose dialog, we could use the custom
    dialog feature in Fyne (created with `dialog.ShowCustom()`). However, all dialog
    windows in Fyne are of a fixed size, and we would like the compose window to be
    flexible. Instead, we will create a new window, as in our `main()` function, using
    `app.NewWindow()`. To do this, we will need to pass the app instance into a new
    `ShowCompose()` function (as windows are created from the app object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create the widgets for the compose window. We will use `widget.NewEntry()`
    for each of the text entry components. For the multiple-line message widget, we
    could set `Entry.MultiLine` to `true`, but instead, we use the `widget.NewMultiLineEntry()`
    helper function. In each instance, we use `Entry.SetPlaceHolder()` to set a placeholder
    value (that will display as a hint, until the user enters their own text).
  prefs: []
  type: TYPE_NORMAL
- en: 'Two new buttons are created using `widget.NewButton()`, one with a `"Send"`
    label, and the other with `"Cancel"`. We keep a reference to the `send` button
    so that we can set `Button.Style` to `widget.PrimaryButton`. This highlights the
    button as the window default action. Lastly, we create a new horizontal box for
    the button bar using `widget.NewHBox()`. Into that, we first add a spacer to right-align
    the buttons (using `layout.NewSpacer()`), and then we include the Cancel and Send
    buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we set up the layout of the window. Once again, this is a non-trivial
    layout due to Fyne's simple layout options. We use `layout.NewBorderLayout()`
    to specify which components should stretch and which should be placed around them.
    The `top` layout places the subject along its top edge and aligns the `to` field
    left of the expanding `toLabel`. The second layout, `content`, positions the `message`
    editor in the center, with the `top` layout above and the `buttons` bar below.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then set the content of the new `compose` window, set it to a default size
    (larger than the `minSize()` calculated by the layouts), and call `Show()`. Remember
    that, this time, we do not use `ShowAndRun()`, since the application is already
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we don''t have a `compose` button yet, this code can be invoked from
    the `main()` function immediately before the `browse.ShowAndRun()` just for test
    purposes (remember to remove this line afterward). The result should be something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a1bf64c-1a2e-458c-b310-33d2002f2811.png)'
  prefs: []
  type: TYPE_IMG
- en: Our compose dialog box using basic Fyne components
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar and menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, Fyne has no menu bar support (although it is proposed in the
    following project issue: [https://github.com/fyne-io/fyne/issues/41](https://github.com/fyne-io/fyne/issues/41))[.](https://github.com/fyne-io/fyne/issues/41)
    We also cannot easily create one from simpler components, as there is currently
    no support for pop-over widgets. Therefore, we will just add a toolbar (as in
    some previous examples).
  prefs: []
  type: TYPE_NORMAL
- en: Using Fyne's built-in iconography (from the material design project), we can
    quickly create an attractive toolbar. To set up the toolbar, we will create a
    new function, `buildToolbar()`, that will create the toolbar and add the items
    to it. We pass in the application instance so that the Compose item can pass it
    into the `ShowCompose()` function we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolbar constructing function takes a list of `ToolbarItem` objects (any
    widget or type that implements `widget.ToolbarItem`). It is also possible to call
    `Append()` or `Prepend()` after the toolbar is created. For each item that should
    appear in the toolbar, we pass an action item using `widget.NewToolbarAction()`.
    A toolbar action takes a `fyne.Resource` parameter (the icon) and a `func()` that''s
    called when the item is tapped. For resources, we use the theme API to access
    standard icons that are packaged in the framework. Additionally, we add a separator
    to group actions using `widget.NewToolbarSeparator()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this new method, we update the toolbar creation code in the `main()`
    method to read simply `toolbar := buildToolbar(mailApp)`. With these changes in
    place, we see a full toolbar using the material design icons at the top of the
    main window, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56e8b97f-fc33-427f-99d7-0e7eabc9ddc4.png)'
  prefs: []
  type: TYPE_IMG
- en: The built-in Fyne toolbar provides default icons for many actions
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up the user interface to show real data and perform the appropriate
    interactions is as simple as setting text values and filling in click handlers.
    To begin with, we will add two helper methods.
  prefs: []
  type: TYPE_NORMAL
- en: Loading emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first new function, `setMessage()`, will simply call `SetText()` on each
    of our `widget.Label` elements. This requires saving a reference to the `to`,
    `from`, `date`, `subject`, and `content` label widgets that were created earlier
    in this section. Their content can be updated using the `SetText()` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also create another helper function, `addEmail()`, to add a new email
    to the list. This is a change from the initial list of `widget.Labels` that we
    added to `widget.Group`—we are using buttons to utilize their built-in click handling.
    The button created in this function sets the label to be the email subject, as
    before, and calls the new `setMessage()` function if it is tapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the list code is updated to call the new `addEmail()` function when we
    load the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Those are the only changes that we need to implement in order to make the browser
    interface functional. Now, let's add the appropriate handling code to the compose
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Sending email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the work on the compose view, we need to update the buttons callback.
    For the cancel button, all that''s necessary is to call `Close()` on the window
    object. In the click handler for the send button, we will construct a new email
    and send it using the server object''s `Send()` function. The `client.NewMessage()`
    function handles creation of the email object. All we need to do is use the `Entry.Text`
    field for each input in order to access the current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code in place, the application should function in exactly the same
    way as the previous examples we''ve built. Although the compose window does not
    look any different, our email browser window now has some real data in that should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7280b53-4868-492e-a8b0-d20accbd3788.png)'
  prefs: []
  type: TYPE_IMG
- en: The completed GoMail interface in Fyne's default dark theme
  prefs: []
  type: TYPE_NORMAL
- en: 'As Fyne provides two built-in themes, we can also see how the application looks
    if users prefer a light colored theme. By setting the `FYNE_THEME` environment
    variable to "light", we can load the alternative theme, demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f43ebdf7-ea09-4023-82d9-b3354e38e929.png)'
  prefs: []
  type: TYPE_IMG
- en: You can either set FYNE_THEME in the environment or pass it to the run command
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the correct theme value will result in a light version of the application
    loading instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc399f14-aaba-4b9a-ad89-5ce43ac3ad91.png)'
  prefs: []
  type: TYPE_IMG
- en: Our GoMail interface with the light Fyne theme
  prefs: []
  type: TYPE_NORMAL
- en: Before we complete this application, we should also cover the background processing
    portion—to handle when a new email arrives.
  prefs: []
  type: TYPE_NORMAL
- en: Background processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Background processing that updates the user interface does not require any special
    thread handling code with Fyne. You can execute the full set of graphical and
    widget commands in any goroutine—the toolkit will take care of any system thread
    management.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add incoming emails to the list in our application, all we need to do is
    call `addEmail()` for the new `client.EmailMessage` and pass that to the `list.Prepend()`
    function. The code is as straightforward as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That completes our basic GoMail application. Given the Fyne project's similarities
    to the Shiny toolkit that we explored in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    – Experimental Go GUI API*, let's also see how we could rebuild the image viewer
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Building an image viewer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the Fyne toolkit includes a canvas API and image handling similar to the
    Shiny project, it makes sense to also compare with the image viewer application
    that we created in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    – Experimental Go GUI API*. Let's start, as usual, with the basic application
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we will be working with canvas APIs, as well as widgets and layouts, we
    will need to start by importing most of the Fyne sub-packages. In addition to
    *canvas*, where we get the basic image APIs, we will also use the `theme` package
    for accessing icons and the `app` package to launch our application. We don''t
    need to import the image libraries, such as `image/jpeg`, because Fyne image widgets
    import them for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As with any Fyne application, we start by creating an application using `app.New()`
    and then create a window for the application by calling `NewWindow()` with an
    appropriate title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will create the widgets for the main layout. To achieve a visually
    distinct navigation bar, let's use a toolbar as in the GoMail application. In
    addition to standard icon buttons, we also add a spacer (with `widget.NewToolbarSpacer()`)
    so that the second button is right aligned in the bar. We will come back to the
    navigation later to add the filename display and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the `widget.Group` widget to visually group the file listing (we
    could use the `widget.Box` widget if the border-less look is preferred). Into
    the group, we append various labels that will serve as file placeholders. Lastly,
    we load the image view to show the placeholder file. The `canvas.NewImageFromFile()`
    function handles all of the image loading for us, as can be seen in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For this application, a simple `layout.BorderLayout` will provide exactly the
    layout we are looking for. We create a new layout with `navBar` at the top and
    `fileList` on the left. The container also includes `image`, which will be stretched
    to fill the remaining space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we set this container to be the content of our window, resize the whole
    window to be larger than the calculated minimum size, and show it. As before,
    we use `ShowAndRun()` as a shortcut to running the application with this first
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of this code in place, the example can be run. You should see a window
    very much like the following (assuming you are using the default dark theme):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e10814f-2052-4dfc-8395-e1e4a3de9fae.png)'
  prefs: []
  type: TYPE_IMG
- en: A basic image viewer layout using default Fyne widgets
  prefs: []
  type: TYPE_NORMAL
- en: Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the navigation bar, we need to also display the filename in the
    middle of the bar. As you may have noticed, there is no toolbar widget that allows
    the showing of text, but we can create our own. Every item in a toolbar implements
    the `widget.ToolbarItem` interface, so we can create a new type that follows this
    pattern. By implementing `ToolbarObject()` (the only function this interface requires),
    we can return the appropriate label to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'While we are updating the navigation bar, we should create placeholder functions
    that will handle the button presses for "previous" (left arrow) and "next" (right
    arrow). An empty parameter list matches the function type for a `widget.Button`
    callback, so these are simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we update the navigation bar creation to use the new `toolbarLabel`
    type that we created. By adding a second spacer widget, we are asking the layout
    to center the label as well as retain the right alignment of the next button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes in place, running the code should result in the following
    updated navigation bar. We will return to this later to set the correct filename,
    but for now, we shall move on to the file listing on the left of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50885e41-fbc9-4dce-892b-2dda4ba901ba.png)'
  prefs: []
  type: TYPE_IMG
- en: The navigation bar created using customized toolbar components
  prefs: []
  type: TYPE_NORMAL
- en: File listing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the Fyne list widgets do not support icon and text combinations, we will
    need to construct one from basic components. Within the file group, we update
    each item to call a new function, `makeRow()`, that will be defined later on.
    We pass the filename to this function so that it can load the image and display
    a suitable caption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `makeRow()` function will return a horizontal box widget containing
    the image preview and caption text. The preview image is loaded using `canvas.NewImageFromFile()` and
    a suitable size is set using `SetMinSize()`. To be consistent in terms of sizing,
    `theme.IconInlineSize()` is used for height and a 50% larger width—assuming most
    pictures are landscape. Finally, this is returned in a horizontal box, along with
    a new label widget, using `widget.NewHBox()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes in place, you should see the same interface with icon previews
    before each filename. Before we are done with the layout, let''s polish the image
    view and see how we can maintain the image aspect ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebab6d07-eddd-48f6-977d-48f6f84ffd29.png)'
  prefs: []
  type: TYPE_IMG
- en: Placeholder files and image thumbnails added to the interface
  prefs: []
  type: TYPE_NORMAL
- en: Image view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the image viewer layout, we need to look at the main image view.
    The default behavior for images in Fyne is that they'll expand to fill the available
    space (this is the `canvas.ImageFillStretch` mode). However, we want the image
    to maintain its aspect ratio, as well as remain within the bounds of the viewing
    area. We will also add a background pattern as we did in the Shiny example in
    [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny – Experimental
    Go GUI API*.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we create a new image for the background pattern. Fyne provides a helper
    method to create an image that's drawn dynamically called `canvas.NewRasterWithPixels()`.
    It takes a single parameter, which is the pixel calculation function that returns `color.Color`
    for the pixel requested. Its parameters are `x, y, width, height` (all `int` variables).
    This means that we can use just the `x` and `y` coordinates, or we can perform
    calculations based on the width and height values (that specify the number of
    pixels on each axis).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our checker pattern implementation, we simply return a light or dark gray
    color to make a pattern of squares. The blocks are 10 x 10 pixels in size and
    we calculate which square a pixel coordinate is within, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The checker pattern image is created by passing our `checkerColor` function
    to the `canvas.NewRasterWithPixels()` function. This variable can now be used
    like any other `canvas.Image` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the main image view should be set to maintain its aspect ratio
    within the available space. To do so, we set the `FillMode` field of the `image` variable
    to `canvas.ImageFillContain`. Like the CSS3 definition, this will center the image
    at the largest scaled size that fits within the space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the checker pattern image is added to our layout. By passing it before
    the main image object, we specify that it is layered lower in the draw order,
    and therefore set as a background. Notice that any item not listed as specifically
    positioned in a border position is sized to fill the remaining space. In this
    way, our image view is drawn above the background and both are set to fill the
    space inside our border widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating the code with these changes results in the completed image viewer
    layout, which should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f44ffd6-b5b6-4252-bdca-2076819ba71b.png)'
  prefs: []
  type: TYPE_IMG
- en: Centering the image over a checkerboard pattern
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add the code that handles updating the GUI and responding to user events,
    we will need to save references to some widgets that have been created; mainly
    the `widget.Label` toolbar and the main view, `canvas.Image`. By storing these
    references, we can update their content later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we will add a `[]string` to list `images` for the directory we
    are accessing and save `int` `index` of the current image so that we can calculate
    the previous and the next. Once those are created, we can fill in the content
    of our `previousImage()` and `nextImage()` functions to call a new `chooseImage()`
    function that will update the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `chooseImage()` function accesses the file path from the image list that
    will be loaded later and uses this information to update our user interface. From
    `path`, we call `label.SetText()` to show the filename and then set `image.File` to
    update the path for the main image display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To most easily implement the click handling behavior in order to choose an
    image from the list, we will change from `widget.Label` to `widget.Button` items.
    As the buttons have a different color background, we should tidy up the display
    by using `layout.BorderLayout` so that the buttons fill the available space. Finally,
    because buttons are taller than labels, we update the `minSize()` preview code
    to be relative to the button''s minimum height rather than the previous inline
    icon size defined by the theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a `getImageList()` function that will access the list
    of images in a directory. The contents of this function are identical to the same
    function in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny –
    Experimental Go GUI API*, so it is omitted here for brevity. With that in place,
    we can update our `makeList()` function, which now takes a `dir` parameter, to
    load the image file list and create the new rows using `makeRow()`, as well as
    populating our stored `images` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then update the creation of the `fileList` in `main()` function to pass
    a directory path to load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the previous GoImages code, we can use the built-in `flag` handling
    to allow users to specify the directory to display. The code is listed here and
    we can invoke it simply by setting the preceding `dirpath` variable to the result
    of `parseArgs()` (if you add this code, remember to import the `flag`, `fmt`,
    and `os` packages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating all of the preceding code should result in our complete image viewer
    application. If you''d prefer to access the complete code, this can be downloaded
    from this book''s source code repository on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d1157ad-a07c-4919-a039-7f1a8d88e503.png)'
  prefs: []
  type: TYPE_IMG
- en: Our completed image viewer showing a wallpaper directory
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous GoMail example, we can load this interface using the light
    theme by specifying `FYNE_THEME=light` in the command-line environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5a2c58a-2b81-4e69-af86-aa614a2a8c61.png)'
  prefs: []
  type: TYPE_IMG
- en: The same app and directory with the Fyne light theme
  prefs: []
  type: TYPE_NORMAL
- en: Background processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Fyne a lot of image handling is already processing on multiple threads,
    but that may not be enough for image-intensive applications. In this GoImages
    app, there are many images being loaded before the user interface is displayed.
    We can update the image handling to allow the GUI to display faster. To do so,
    we once again create a new `asyncImage` type, that loads the image on a background
    thread before displaying it. Whereas Shiny was passing the images directly to
    the rendering, here, we are providing them to a `canvas.Image` object, so the
    code is slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating the basic `asyncImage` type—its main work is in the `load()`
    function, which will run on a background thread. The `loadPath()` function sets
    up the path to the file to be loaded and starts the background processing. Notice
    that once we''ve changed the image data, we need to call `canvas.Refresh()` to
    ensure the interface updates—there is no need for any thread-handling code, since
    Fyne will deal with that for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As this async image loader will be providing raw image data to the image widget,
    we also need to implement the `image.Image` API. In each of the methods, we check
    to see whether the `pixels` variable has been set (it will be `nil` until the
    image is loaded), returning the appropriate value or a sensible fallback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, our `asyncImage` type would benefit from a convenience constructor
    to set up the `image` widget that will render. We also begin the loading of the
    first image file, `path`, on a background thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete the use of our asynchronous image loader, we update the `chooseImage()`
    function to set the new path. With this change, the application will be loading
    all images on a background thread instead of on the main loop. Go will distribute
    this across our processors appropriately to make use of the available CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Running this new version of the application will load noticeably faster. You'll
    also see the images appear as the loading of each file is completed. By using
    the simple `canvas.Refresh()` call after we load each image, we ensure that the
    user interface updates appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the last of the toolkits to be explored in this
    book, Fyne. We learned how it was created specifically for Go so as to make it
    simple to build graphical applications. We quickly got set up with the toolkit
    and explored how to build applications that will run identically on macOS, Windows,
    and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the architecture of the Fyne toolkit and its use of vector graphics
    to provide scalable graphical interfaces. By learning the features of the `layout`,
    `canvas`, and `widget` packages, we saw how to quickly build basic user interfaces.
    We also saw how Fyne provides two different themes, *light* and *dark*, which
    will be used based on user settings or environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Applying this knowledge, we built the sixth version of our GoMail application,
    which included built-in material design icons and avoided any thread-handling
    complexities. We also explored the image APIs and background processing capabilities
    by re-building the GoImages application designed in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml),
    *Shiny – Experimental Go GUI API*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored the main toolkits available, we will move to [Section
    4](935a315b-9890-4c6a-a126-3dda28108886.xhtml), *Growing and Distributing Your
    Application**.* In the final part of this book, we change focus to topics that
    apply to all graphical applications, regardless of the toolkit used. We will explore
    topics that help polish and distribute complete graphical user interfaces*,* starting
    with [Chapter 11](03c04362-6937-47f3-a2de-cd99d9ae9080.xhtml), *Navigation and
    Multiple Windows.*
  prefs: []
  type: TYPE_NORMAL
