<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Navigation and Multiple Windows</h1>
                </header>
            
            <article>
                
<p>Through the last seven chapters, we've explored how to build a fairly simple graphical user interface using different toolkits and technologies. In each example, we saw benefits to the widget and API design but also challenges that are often faced when picking a toolkit. In this chapter, we're shifting focus to the planning and implementation of a more complex GUI—the sorts of challenges that will be encountered irrespective of the toolkit and technology selected.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Planning the workflow of a more complex GUI</li>
<li>Window management and notifications for a clean user experience</li>
<li>Operating system-specific details and how to adapt a cross-platform application</li>
</ul>
<p>At the end of this chapter, you'll have examined the bigger picture questions of application flow and navigation in a more complex graphical application. You'll have thought about how your GUI will fit within the current platform's flow and how to notify or engage the user as appropriate. So, let's get started by looking at the navigation of a complex application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Planning application layout</h1>
                </header>
            
            <article>
                
<p>Planning a large graphical application can seem like a daunting task, if you're thinking about all of the different users of your software and the varied devices it'll be used on. Or, it may seem quite straightforward if your ambitions can be realized by using standard design applications (such as Qt Creator or Glade for GTK+) that can generate code from a drag-and-drop interface. Unsurprisingly, creating a great user experience for your application interface will probably take a while to explore, plan, and design for the best result. The largest complexity is likely the navigation or overall layout of the application<span>—</span>we'll look first at layout techniques across multiple platforms.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Standard layouts</h1>
                </header>
            
            <article>
                
<p>Each of the toolkits we've explored provide standard layout components that help to organize widgets and interface elements in neat, standardized arrangements. When you think about the naming of these layouts, however (for example, VBox, Border, and Frame), they typically describe fine-grained control rather than higher-level design concepts. For this section, we need to step back a little and think about the overall flow of an application, what will be the most used parts of the application, and what should the user see when they first load the user interface.</p>
<p>As discussed in <a href="d5375343-5332-4374-9297-dfbb256a5d91.xhtml">Chapter 2</a>, <em>Graphical User Interface Challenges</em>, desktop applications have been  standardized around a fairly common layout: menu, toolbar, palettes, and content. As applications have grown more complicated, there have been attempts to fit more functions and features into this space to allow users to gain access to the full feature set of these increasingly powerful applications. Since the rise in popularity of smart phones and mobile applications, there has been a lot of discussion about better use of screen real estate and how to make a great user experience with limited resources.</p>
<p>Research into the use of screens, readability of content, and related topics is now commonplace in relation to web design as well. Topics such as <em>How eye scanning impacts visual hierarchy in UX design</em> are often seen on recommended reading lists for those looking to improve their site's usability or user retention. With this in mind, we, as desktop or cross-platform application creators, should probably be thinking much more carefully about how our software is presented and whether the traditional methods fit with our specific use cases.</p>
<p><span>Some GUI toolkits are beginning to provide higher-level layouts that reflect intention rather than a static visual layout. For example, <kbd>UISplitViewController</kbd> in Apple's iOS presents a list view and detail view side by side when space is available or one view at a time (the detail view slides on when the list is tapped) when screens are</span> smaller<span>:</span></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign"><img src="Images/0152c420-9201-4487-b56d-ada73f0cfc6f.png" style="width:47.50em;height:35.33em;" width="628" height="467"/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">An iOS split pane used for iPad settings app<br/>
(Image copyright: Apple)</div>
<div>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/a2a775b7-e9f1-40d0-8eaa-d29d89afcd03.jpg" style="width:19.08em;height:37.25em;" width="411" height="805"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The same split pane on an iPhone<br/>
(Image copyright: Apple)</div>
</div>
<p><span>Where possible, these should be used in your application so your interface is configured appropriately for the current device, but there may be further customization needed. Let's look at some of the factors that impact more complex layout design.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Device form factors</h1>
                </header>
            
            <article>
                
<p>While primarily a consideration for mobile and modern portable devices, an application layout should be designed with the physical design of the device in mind. Visual and interaction technologies on the desktop have remained largely consistent for 25 years, leading to standardized interface designs<span>—</span>but this too is changing. Computers are now more commonly shipping with ultra high definition screens, many of which are also touch surfaces. If your approach to cross-platform application development is to also include mobile devices, you will need to consider the small screen sizes as well as orientation of the device.</p>
<p>Of course, the screen isn't the only factor to consider; it's now also common for input devices to vary. A mouse and keyboard is probably the main configuration for user input but many portable computers now have a <em>tablet mode</em> where touch input is a replacement for the mouse and a virtual keyboard can appear for text input. If this is a configuration you want to support, then your layout will need to work when parts of the screen (probably the bottom edge) is covered with the virtual keyboard. More importantly, finger-based input (most commonly called <em>multi-touch</em>) is far richer than a point and click approach; will your application aim to support <em>pinch to zoom</em> or <em>touch rotation</em>? If you intend to support these sorts of features, then make sure your chosen framework supports <em>input gestures</em>. Each toolkit is evolving rapidly and so the details have been omitted from this book as it would be out of date by publication.</p>
<p>In addition to the full device capabilities, a traditional desktop application can be moved around and made different sizes or orientations by many user actions<span>—</span>should your design aim to accommodate these changes in configuration? When displaying applications side by side on a tablet device, you'll see how powerful the different layouts can be when implemented correctly. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Responsive or adaptive design</h1>
                </header>
            
            <article>
                
<p>To be able to suit a wide variety of devices, it normally won't be possible to use a single user interface design. Therefore, some form of adaptation to the current environment will probably be necessary. There are two main schools of thought with regard to adapting to variations in screen and device capability: responsive and adaptive designs. Both aim to provide an appropriate user experience with an interface that feels native to the current device. While these principles currently refer mostly to web application design, they can also be applied to native applications, especially if designing for multiple platforms.</p>
<p>When following adaptive principles, application designers will choose a limited set of device configurations to design for, typically a mobile device (possibly in multiple orientations), a tablet device, and a regular desktop. By designing for these categories, the amount of time spent designing for specific devices is reduced, focusing only on these defined configurations. When focusing on a small number of variations, the design can be perfected for these different use cases, creating a very smooth experience. When implemented this way, an application will detect which category of device it's running on and load the appropriate layout (sometimes this is handled automatically by the framework). This approach has been exemplified by Apple's iOS SDK (user interfaces are defined for iPhone, iPhone Plus, and iPad), the correct user interface will be loaded and a single application can execute with any configuration. The limitation of the adaptive approach is that <em>intermediate</em> devices, ones that are smaller or larger than expected (or with unusual configurations), will probably not look or function as the user may expect.</p>
<p>Responsive design, on the other hand, aims to define a single user interface that responds to the current device configuration. Layouts created in this manner will typically have certain trigger values or inflection points that determine the visibility of elements or the positioning and sizing of items that should always be shown (in CSS, this is usually done with <em>media queries</em>). The responsive technique is becoming more popular in designing websites that wish to provide a good experience on a huge range of different devices; it probably won't provide the perfect user interface that adaptive design aims for, but it does cater for every device from the smallest, least capable to the full desktop experience. This approach maps well to the cross-platform approach that's likely part of the intention of a team developing application GUIs with Go because we don't usually know the devices that our software will be run on ahead of time.</p>
<p>The toolkits explored in this book offer some amount of support for responsive layouts. Grids that lay out the content according to the space available and the screen layout are a good place to start. Some are pushing further into this space by providing semantic layouts that'll adapt correctly to the current device:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/9fbcb119-1372-4675-b596-4e429bb620fc.png" style="width:15.75em;height:23.92em;" width="476" height="724"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">An example of a possible responsive layout at three different sizes</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Custom layouts</h1>
                </header>
            
            <article>
                
<p><span>It's likely that your application has requirements that are different to standard layouts or more complicated than the toolkit's API supports. Using standard layouts where possible is recommended but that doesn't have to mean giving up on your ideal application design. Every toolkit supports custom layouts in some manner that you can make use of to fill the gaps in the available standard layouts. When implementing a custom layout in this manner, the basic approach is to set a fixed position for each component within the parent container. To better adapt to the available screen space, remember to factor in the current width and height of the interface; it's often easier to implement using ratios or percentages rather than absolute values (for example, a list component is 25% of the screen width or content columns are 1/3 of the available space).</span></p>
<p>In more advanced toolkits, there's also a <em>constraints-based</em> layout available, one that lays out components based on configured equations instead of hardcode values. The standard algorithm for constraints layouts is named Cassowary and is fully documented at <a href="http://overconstrained.io/">http://overconstrained.io/</a>. The basic principle is that each layout value can be defined as the result of an equation in the form <kbd>item1.attr1 = item2.attr2 × multiplier + constant</kbd> (such as <kbd>button.top = content.bottom × 1.0 + 25</kbd>). Constraints-based layouts (also known as <strong>auto layouts</strong>) are standard in iOS and Android but not so common in desktop toolkits. Modern GUIs often include this functionality as standard but using this functionality in others such as Qt and GTK will require the integration of third-party projects (as these aren't currently available through Go bindings, the integration is out of scope for this chapter):</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4cc931b4-d7e1-4cf5-b684-cf8a94a7ef64.png" style="width:52.92em;height:18.75em;" width="1524" height="540"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Adding constraints to a label with Xcode (image copyright: <span>Big Nerd Ranch, LLC)</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Navigating your application</h1>
                </header>
            
            <article>
                
<p>Consistent and easy-to-follow navigation through a complex application is hard to attain but doing it well can lead to dramatically improved user experience. A typical application has a core set of functionality<span>—which </span>should always be easy to access<span>—</span>and a larger set of additional tools and helpful features that are used less frequently. Keeping the balance between core features and additional functionality is something that many applications haven't yet solved. Overcrowded toolbars and very long menus are problems we encounter on a regular basis:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/d1b58816-896a-4fec-8621-ad2a566718a2.jpg" style="width:56.67em;height:11.08em;" width="771" height="151"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Menus, toolbars, shortcuts, and drop-down lists all above a document in Microsoft Office 2007</div>
<p>Finding ways to limit the various options onscreen should lead to less user confusion. It's the responsibility of an application designer to make a clear and easy-to-use interface, not to present all of the options and expect users to learn how to navigate. There are various methods for adjusting a user interface to focus on the essential or most useful features; we'll explore them in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Progressive disclosure</h1>
                </header>
            
            <article>
                
<p>In larger applications (as previously illustrated), it's likely that the number of features available can't easily be presented in a minimal user interface. When that's the case, application designers will have a new challenge in creating a smooth learning curve for new users. How can an application's user interface be designed both for a complex feature set and to be easy to learn by people who are new to the product?</p>
<p>Progressive disclosure is a technique for helping to focus a user's attention and facilitate learning a complex system. This is achieved by hiding functionality or data that isn't necessary to support the task at hand. Commonly, this is implemented by starting with a basic set of functionality visible and expanding as the user explores areas beyond the basics. Triggers to expand the functionality available may be accessing a new menu item, an <span class="packt_screen">Advanced</span> button, or simply using the application for a certain time or adding sufficient data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example 1 – Microsoft Edge</h1>
                </header>
            
            <article>
                
<p>A standard feature of popular web browsers is the developer tools that they include<span>—</span>but this isn't core functionality. When building their new web browser, Edge, Microsoft decided to focus on the core features, hiding more advanced functionality, such as developer tools, from the average user.</p>
<p>If enabled through a single menu item (the <span class="packt_screen">...</span> menu, then <span class="packt_screen">F12 Developer Tools</span>) or the <em>F12</em> keyboard shortcut, the developer features are switched on. From then on, the browser will present developer features in all of the expected places, creating a much richer application feature set:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/423fbed2-8a2e-45cd-b959-447774d8fc2e.png" style="width:22.25em;height:10.92em;" width="490" height="241"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">The default Edge context menu</div>
<p>F12 or Developer Tools menu item:</p>
<p class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/ca583515-75b8-49f5-8d7e-b91152f9e143.png" style="width:21.42em;height:12.33em;" width="491" height="283"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">After developer tools are enabled</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example 2 – Skyscanner flight search</h1>
                </header>
            
            <article>
                
<p>The main functionality of the Skyscanner service (<a href="https://www.skyscanner.net/">https://www.skyscanner.net/</a>) is to search through the many flights available, matching a certain criteria based on price, time, location, and so forth. After finding a suitable journey in the (initially minimal looking) mobile app, a user would normally go through a booking process to purchase their flights.</p>
<p>If they aren't ready to make the purchase, a user of the application can <em>favorite</em> a flight combination for later. Upon doing this, a menu will appear in the application from which favorite searches can be returned to. If these searches are visited many times, then another new feature called <em>watched flights</em> appears, which allows more advanced holiday planners to monitor the varying prices of their searches.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Menus and toolbars</h1>
                </header>
            
            <article>
                
<p>When there are many items that you wish to provide to users of your application, a menu or toolbar are convenient options, but should be used carefully and sparingly. Too many options added to a toolbar can add to the cluttered <em>ribbon</em> user interface from Microsoft Office, as previously displayed. Likewise, adding a menu item for every feature will probably lead to cognitive overload as users spend too much time trying to find an item or remember where it's located.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Toolbar</h1>
                </header>
            
            <article>
                
<p>A toolbar is ideally suited for actions that'll be used on a regular basis. For example, in our email application <span class="packt_screen">Reply</span> will be a popular action, as will <span class="packt_screen">New</span> and <span class="packt_screen">Delete</span>. Grouping toolbar items together by similarity (for example, <span class="packt_screen">Reply</span> and <span class="packt_screen">Reply All</span> or <span class="packt_screen">Cut</span>, <span class="packt_screen">Copy</span>, and <span class="packt_screen">Paste</span>) will help users to find your shortcuts quickly. Ordering these groups by likelihood of use will mean that, if the user interface is smaller than expected, then the most useful features will still be visible. To provide access to tools that don't fit onto the screen, you can use an overflow item (where it pops out a list of not-visible items), make the tool bar scrollable, or provide access in a different place, such as a menu or second row.</p>
<p>Toolbars are popular in most form factors of devices, from small phones up to large desktop applications. The main difference is clearly the number of items that can be included. If you're including toolbars in a responsive or adaptive layout, you may consider a more complex strategy than leftmost-visible. For example, in an email application, if only five items can be displayed, then removing <span class="packt_screen">Reply All</span> so <span class="packt_screen">Delete</span> can be seen might be a good approach; the user could always choose to reply to all in the compose window after pressing <span class="packt_screen">Reply</span>.</p>
<p>Many applications choose to allow items in the toolbar to be rearranged, a feature that's provided by some graphical toolkits (for example, UIKit for Apple's iOS devices and AppKit for their desktop applications):</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/80718ee3-df87-412a-bdcf-c07842aa8917.png" style="width:53.83em;height:36.92em;" width="934" height="641"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A sample user interface for customizing toolbars in macOS (image copyright: Apple)</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Menu </h1>
                </header>
            
            <article>
                
<p>Menu bars have traditionally been thought of as the right location to place all otherwise absent feature access in an application. With a long list of items in a growing number of menu headings, an application menu can quickly become hard to navigate. This is generally considered to be due to the number of items that an average human can hold in their short-term memory. Experiments by George Miller in 1956 suggested that the number of objects that can typically be held in working memory is between five and nine (seven plus or minus two<span>—</span>Miller's "Magical Number"). More recent estimates have shown that this number is typically lower, closer to just four or five items.</p>
<p>Taking this into consideration, we can understand why it's important to keep menus fewer and shorter<span>—</span>at every step of navigating, there should be no more than nine options available<span>—</span>and far less, if possible.</p>
<p>The presentation of a menu varies from one platform to another with the standard top of the window or top of the screen being most common on the desktop, and an icon at the top-left of the screen (known as the hamburger) most prevalent on mobile layouts. What you'll notice, regardless of the layout, is that the top-level list will be around five items and, if further options are required, the menus that cascade down won't be much longer than that. If you find your menus becoming overwhelmingly long, perhaps consider task-specific toolbars or other grouping of context-relevant shortcuts, possibly opened from a single menu item.</p>
<p>Whatever design you choose for making features available, please remember the user's main focus or the current context.</p>
<p>You don't want to end up overwhelming them to the point that there's significant thinking required at every step of the way:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/9fac0744-14e6-442b-9095-b10cc6cf2527.jpg" style="width:41.58em;height:29.42em;" width="1101" height="779"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Visual Studio with all of its viewers and toolbars switched on (copyright Dylan Beattie)</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Multiple windows</h1>
                </header>
            
            <article>
                
<p>One more approach that can help your application to be easier to navigate is to split the content into multiple windows. Each will be a different view of your application, within which the appropriate toolbars or menus can be presented for the current context. As shown in our GoMail examples, we compose new messages in a separate window; this allows us to group editing-related items close to the input fields and allows us to simultaneously be drafting multiple messages without cluttering our email browse window.</p>
<p>Of course, multiple windows won't necessarily have the same semantics on different platforms. If we were to take the same approach on a smart phone device, it would be common for the compose window to be presented as an overlay to the existing application. Whether the user can switch between that mode and the browse window may be down to the operating system's design or we may decide that, when running on a smaller device, the compose window should be a <em>modal</em> window (that is, it blocks access to the parent window. This is discussed further later). </p>
<p>Yet another approach that we saw in <a href="d5375343-5332-4374-9297-dfbb256a5d91.xhtml">Chapter 2</a>, <em>Graphical User Interface Challenges</em>, was to have multiple windows for the main focus of the applications. These peripheral windows are typically for toolbars or detailed information/control of the content in the main window and can be particularly helpful in content creation-based applications. With the content expanding to fill the whole of the main window, the toolbars and context actions have been placed in separate windows to keep the user focused. This type of layout and navigation is usually adopted in <em>pro</em> applications where the user knows the domain well. The added complexity of this approach can lead to confusion for early users of a product and so we, as application designers and developers, should be mindful of the number of windows or different layouts and contexts we present in our user interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Window types and keeping things clean</h1>
                </header>
            
            <article>
                
<p>Managing multiple windows will become essential for any application, either through part of a layout design like the preceding, or for presenting important information to the user to gain their attention or receive their input. For each window that's displayed in your application, it's important to know whether its appearance should attract their immediate attention, support what's already onscreen, or simply be something that can be attended to later. Knowing the intention of each window shown will help to support, rather than impede, the user workflow and keep your application's user experience clean.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Standard dialogs</h1>
                </header>
            
            <article>
                
<p>The most common reason to show an additional window during application flow is to ask the user for additional input or confirmation, or to alert them of (typically unexpected) events. These are standard interactions and so it's usually most effective to use, where possible, the provided dialog windows defined by the toolkit being used. Using the provided APIs will generally provide the most consistent user experience and will almost certainly lead to less code in your application as well.</p>
<p>The types of standard dialogs provided by a toolkit will normally include file handling (open and save), progress (when the user must wait), message (to show warnings or errors), and a confirmation dialog (to ask an immediate question). On more advanced toolkits, you can also expect to find dialog APIs to help with color selection, font selection, document printing, and even a standardized <span class="packt_screen">About</span> window. The following APIs are great places to get started with some of the toolkits we covered earlier in this book (with namespace included if it's not the default):</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td/>
<td><strong>walk</strong></td>
<td><strong>andlabs UI</strong></td>
<td><strong>GoGTK</strong></td>
<td><strong>qt</strong></td>
<td><strong>Fyne</strong></td>
</tr>
<tr>
<td><strong>open</strong></td>
<td>
<p><kbd>ShowOpen</kbd></p>
</td>
<td>
<p><kbd>OpenFile</kbd></p>
</td>
<td>
<p><kbd>NewFileChooserDialog</kbd></p>
</td>
<td>
<p><kbd>widgets.NewQFileDialog</kbd></p>
</td>
<td/>
</tr>
<tr>
<td><strong>save</strong></td>
<td>
<p><kbd>ShowSave</kbd></p>
</td>
<td>
<p><kbd>SaveFile</kbd></p>
</td>
<td>
<p><kbd>NewFileChooserDialog</kbd></p>
</td>
<td>
<p><kbd>widgets.NewQFileDialog</kbd></p>
</td>
<td/>
</tr>
<tr>
<td><strong>progress</strong></td>
<td/>
<td/>
<td/>
<td>
<p><kbd>widgets.NewQProgressDialog</kbd></p>
</td>
<td>
<p><kbd>dialog.NewProgress</kbd></p>
</td>
</tr>
<tr>
<td>
<p><strong>message</strong></p>
</td>
<td/>
<td>
<p><kbd>MsgBox</kbd></p>
<p><kbd>MsgBoxError</kbd></p>
</td>
<td>
<p><kbd>NewMessageDialog</kbd></p>
</td>
<td>
<p><kbd>widgets.NewQMessageBox</kbd></p>
<p><kbd>widgets.NewErrorMessage</kbd></p>
</td>
<td>
<p><kbd>dialog.ShowInformation</kbd></p>
<p><kbd>dialog.ShowError</kbd></p>
</td>
</tr>
<tr>
<td><strong>confirm</strong></td>
<td/>
<td/>
<td/>
<td>
<p><kbd><span>widgets.NewQMessageBox</span></kbd></p>
</td>
<td>
<p><kbd><span>dialog.ShowConfirmation</span></kbd></p>
</td>
</tr>
<tr>
<td>
<p><strong>input</strong></p>
</td>
<td/>
<td/>
<td/>
<td>
<p><kbd>widgets.NewQInputDialog</kbd></p>
</td>
<td/>
</tr>
<tr>
<td><strong>color</strong></td>
<td/>
<td/>
<td/>
<td>
<p><kbd>widgets.NewQColorDialog</kbd></p>
</td>
<td/>
</tr>
<tr>
<td><strong>font</strong></td>
<td/>
<td/>
<td>
<p><kbd>FontSelection</kbd></p>
</td>
<td>
<p><kbd>widgets.NewQFontDialog</kbd></p>
</td>
<td/>
</tr>
<tr>
<td><strong>print</strong></td>
<td/>
<td/>
<td/>
<td>
<p><kbd>printsupport.NewQPrintDialog</kbd></p>
</td>
<td/>
</tr>
<tr>
<td><strong>about</strong></td>
<td/>
<td/>
<td>
<p><kbd>NewAboutDialog</kbd></p>
</td>
<td/>
<td/>
</tr>
<tr>
<td><strong>custom</strong></td>
<td>
<p><kbd>NewDialog</kbd></p>
</td>
<td/>
<td>
<p><kbd><span>NewDialog</span></kbd></p>
</td>
<td>
<p><kbd>widgets.NewQDialog</kbd></p>
</td>
<td>
<p><kbd>dialog.ShowCustom</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>It's often useful to show a small selection or confirmation window that isn't in the preceding list (either because your requirements are different or the toolkit hasn't implemented that feature). This can be achieved by creating a new window, packing the content, and showing it, but the recommended method is to use the custom dialog API instead. Showing a dialog instead of a standard window allows the toolkit to configure the window to best effect. This typically involves setting it to be a non-resizable, topmost window that's <em>modal</em> (meaning the user can't interact with the window underneath until the dialog is dismissed).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modal windows</h1>
                </header>
            
            <article>
                
<p>As suggested previously, a modal window is one that blocks user input to the window that it's above. This typically means it's placed in the center of a parent window and the window below will be disabled or grayed out, focusing the user interaction on the new dialog window. This is typical of dialog windows as they're designed to appear only when the user can't continue with the current task until the information, confirmation, or progress is completed (at which point the dialog disappears and control returns).</p>
<p>To function in this way, a modal window is usually passed the parent window that it should occlude. The input will be forced to the new modal window (depending on the desktop environment and configuration, this may not be the case if the parent window isn't currently the topmost application) to interact with the new interface. Different platforms can present modal windows using various styles; some will look like a regular window (often with maximize and minimize buttons disabled), others will present the content embedded within the current window, and others (such as macOS) can present them appearing from the title bar of the parent window. Using the built-in API for custom dialogs will mean that these visual styles are consistent within your application.</p>
<p>There may be a reason, however, that your application requires a new window to take focus in a different type of workflow. For these cases, a toolkit often allows the <em>modality</em> of a window to be set directly. This can be a powerful feature but be sure to consider whether there isn't a better API to manage this flow, or whether a custom dialog window may be a better fit.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Window hints</h1>
                </header>
            
            <article>
                
<p>The properties of a window (referred to as <em>hints</em> on many systems) allow an application to indicate certain desired attributes to the operating system that'll control how a window is presented. For various reasons (including user experience and even security), an application can't mandate how and when a window will be presented in most situations; therefore, it's important to remember that these hints may not be enforced.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sizes</h1>
                </header>
            
            <article>
                
<p>The most common hints set are related to size<span>—</span>the minimum and possibly maximum size that your user interface should occupy. Minimum size is almost universally supported; every graphical system will try to allow an application to use as much space as it claims to need. Be sure to have sensible sizes though as, especially when targeting multiple different platform types, the minimum size shouldn't be bigger than the screen available! To avoid this situation, the operating system will probably show your application windows smaller than requested so that the user doesn't have the problem of accessing portions of the user interface that are off-screen. For this reason alone, it's recommended that the minimum size set is truly the smallest size that your GUI will operate correctly. </p>
<p>So that an application is proportioned correctly when first loaded, it's common to set a default or preferred size (typically through <kbd>SetDefaultSize()</kbd>, <kbd>SetSize()</kbd>, or <kbd>Resize()</kbd>). This means that, as much as possible, your application will load at a sensible size, but smaller if the screen isn't large enough. In the example of our <em>New GoMail</em> email compose window, we can set a good default for typing a large email while having a sensible minimum size (probably calculated by the toolkit) that allows access to all of the input fields.</p>
<p>Additionally, it may be helpful to set a maximum size for your window; while not used as often as minimum or default sized, this can be helpful. Most commonly, this is helpful if you want your window to remain small (such as a toolbox or information window) or expand only in one direction (to allow only height adjustments, or set the minimum and maximum width to the same value). It's also helpful in presenting custom dialog boxes to set the minimum and maximum size to the same value, hence requesting that the window be a fixed size. Some toolkits make this easier by providing a <kbd>SetFixedSize()</kbd> function.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other hints</h1>
                </header>
            
            <article>
                
<p>There are many other types of properties or hints that can be set on windows to help guide users through an application. Depending on the toolkit, it may be possible to set the window type. This is usually handled automatically when displaying a dialog window (as they can have special properties) but may not be handled for other types of window creation. Check out the window API in your chosen toolkit to see whether you can set the type of window when doing things such as creating a toolbox window or information panel that should belong to a parent window somehow.</p>
<p>The most instructive window hint is the icon that's displayed in places such as the task bar, application switcher, and possibly the window border. On some systems, the default icon is that of the application, and in others it's a window specific image. Generally, it's a good idea to set the same icon on your application windows and application icon, which may be handled by the toolkit you're using. Setting a different icon for a window should be reserved for times when the window serves a different purpose to the main window. To avoid user confusion, window icons that differ from the main one should indicate through style or content which main icon they relate to. Setting a window icon is usually achieved by calling <kbd>window.SetIcon()</kbd> or <kbd>widget.SetWindowIcon()</kbd> (for top-level widgets). In some cases, <kbd>application.SetDefaultIcon()</kbd> may allow you to set the icon for all windows with a single call.</p>
<p>Setting the application icon is platform-specific and is explored further in <a href="8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml">Chapter 14</a>, <em>Distributing Your Application</em>. It's important to be aware that some systems allow custom icon themes to be loaded. In this case, a custom application or window icon may be less familiar to the user, so you may consider including some branding within the application itself.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Notifications and task status</h1>
                </header>
            
            <article>
                
<p>As we saw earlier, it's part of most toolkit APIs to provide easy ways to open dialog windows for displaying information, progress reports, and errors to gain a user's attention. However, with great power comes great responsibility; it's important to not interrupt the workflow unless it's really necessary. Think of the many <span class="packt_screen">File download complete!</span> or <span class="packt_screen">Please wait for update to download...</span> dialog windows you've had to wait for or dismiss and you'll be thinking in the right direction.</p>
<p>So what's the solution? Let's look at how to present non-critical alerts or background progress to the user in a less obstructive manner.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Minor alerts</h1>
                </header>
            
            <article>
                
<p>Many messages that should be presented to the user probably aren't crucial and so should probably not interrupt their flow. The information may not be important enough to warrant displaying another window or it may be time-based, and so if the app isn't active, it may no longer be relevant when they come back. A better approach to this sort of information is present in most operating systems: a notification area.</p>
<p>Initially presented as part of a system tray, notifications are displayed as a bubble or call-out area that can catch a user's attention if they're ready to be distracted or could be ignored otherwise. The more modern way for this to be presented is a notification area (which may not always be visible) in which all application notifications are placed. This provides a way to group all messages for later processing at a more convenient time. A preview is normally shown so it's a good idea to keep the message short.</p>
<p>Notifications can be created using built-in APIs for many of the frameworks we've discussed, such as <kbd>NewQSystemTrayIcon().ShowMessage()</kbd> in Qt or <kbd>NewNotifyIcon().ShowMessage()</kbd> in Walk. Using these functions will typically display the notification in the current platform's default notification area, leading to a consistent user experience. This, however, means that even on GUI toolkits that aim to be completely consistent across multiple platforms, this code will behave differently, so be sure to test all supported platforms and bear the differences in mind when writing documentation:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/b883a70e-496d-4c19-8d77-76be65546bea.png" style="width:28.17em;height:15.17em;" width="520" height="280"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Notifications appear in the Action Center on Windows 10 (Image copyright: Microsoft)</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Background progress</h1>
                </header>
            
            <article>
                
<p>The progress dialog windows provided by Qt, Fyne, and others are ideal for showing the user how much longer they need to wait for a critical process to complete (such as opening a large file, buffering a movie, or loading the required data from a website). What they aren't suitable for is reporting the progress of a task that can run while the user continues their task in the application. For that purpose, we should consider displaying the information elsewhere on the application or screen.</p>
<p><span>Many systems are starting to add support for reporting task progress in a standard area, such as the notification space described earlier. Unfortunately, this isn't yet commonplace across enough operating systems for toolkits such as those we've explored to provide support; therefore, we must use another approach. There are two common strategies to communicating task progress for such background processes, and it probably depends on whether you expect multiple tasks to be running concurrently or not.</span></p>
<p>For applications where a single background task may run (such as an IDE running a build, or a to-do list synchronizing with its server), the traditional approach is to embed a progress bar in the application somewhere. This would be shown when the background task starts and then disappear once it's completed. Such visual queues are usually in a status bar or other information area where the user's eye typically travels when looking for ancillary information.</p>
<p>If your application is regularly going to have multiple background events running, such as file downloads or image conversions, it's usual to see a new window or tool panel appear when tasks are running. This user interface addition would normally list all of the active tasks with their progress and hide them once complete. As these are non-critical to the current workflow, it's important not to show the elements over the current work<span>—</span>indeed, some applications (such as Apple's Safari web browser) don't even show this window unless the user requests detailed information on the download progress:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4c7d61d7-e854-491e-8a69-8ab310c44123.png" style="width:38.75em;height:10.08em;" width="577" height="150"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The download list in Safari isn't visible by default but will provide details if requested (image copyright: Apple)</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Platform-specific considerations</h1>
                </header>
            
            <article>
                
<p>Despite the broad similarities in how most widget toolkits work across the platforms they support, there are some differences in operating system behavior. Whether due to a desire to stand out against the competition or through a belief that their approach is a better user experience, these distinctions should be taken into consideration. In this section, we'll explore some significant differences in platform approaches.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Window grouping</h1>
                </header>
            
            <article>
                
<p>In the taskbar of Windows 10 and most versions of macOS, all of an application's windows are grouped under a single icon. This makes the user interface less cluttered, but it does mean that an application that opens many windows may be a little harder to navigate as there isn't a simple icon click to show a specific window. Add to this the behavior of macOS and Ubuntu Linux (or other distributions using the Gnome desktop) to group windows under a single icon in the task switcher (keyboard <em>Alt</em> + <em>Tab)</em> as well. With Gnome, you can explore the windows under an icon by pressing the down arrow key or using the mouse, but on macOS, you need to use an alternative <span>keyboard combination</span> (<em>Alt </em>+~) to cycle <span>the </span>windows of an application.</p>
<p>This trend to group windows may impact the design of applications that present multiple windows; if every time you launch the application, it opens three windows, then; after opening three documents, you could have nine windows open. The most common approach in this situation is to have supporting windows open just once, making their tools or information assume the context of the current document (probably the topmost window). However, this may add complexity to your application as it would need to communicate with other instances of the software that are already open.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application instances</h1>
                </header>
            
            <article>
                
<p>Although somewhat hidden in a modern task switcher, it can be noticed that some operating systems prefer to have just one instance of an application open rather than launching many (for example, one per document). When developing applications for macOS, it's encouraged to only have one copy running at any time-attempting to run a second instance of the same application will normally result in the original window being brought to the front. If your application is aiming to support platforms where the <em>concurrent instances</em> semantics are different, time should be spent deciding how your application should behave. Will your design work the same way on all platforms or adapt to the current environment?</p>
<p>To change behavior according to platform, it's possible to detect the operating system at runtime, but normally the operating system is the defining factor, and so you can make use of Go's built in build tags discussed in <a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml">Chapter 3</a>, <em>Go to the Rescue!</em>. For example, we could have two different files that control how an application is opened: <kbd>launch_darwin.go</kbd> will be used when compiling for macOS and <kbd>launch_other.go</kbd> will run on other platforms. An example of setting this up may go as follows.</p>
<p>Firstly, we create a file that handles the standard mechanism (called <kbd>launch_other.go</kbd>);  opening a file or a new document will create a window with an appropriate document and show it:</p>
<pre>// +build !darwin<br/>package main<br/><br/>type app struct {<br/>}<br/><br/>func (a *app) openFile(file string) {<br/>   newWindow(openDocument(file)).Show()<br/>}<br/><br/>func (a *app) openBlank() {<br/>   newWindow(newDocument()).Show()<br/>}</pre>
<p>Then, we make a version for macOS (named <kbd>launch_darwin.go</kbd>), which first checks for a running instance. If one is found, we call some <strong>RPC</strong> (<strong>remote proceedure call</strong>) functions to open files in the running application, otherwise we load the window as before:</p>
<pre>package main<br/><br/>import (<br/>   "log"<br/>   "os"<br/>)<br/><br/>type app struct {<br/>}<br/><br/>func (a *app) openFile(file string) {<br/>   running := getFirstInstance(a)<br/>   if running != nil {<br/>      log.Println("Found running app, opening document", file)<br/>      running.openFile(file)<br/>      os.Exit(0)<br/>   } else {<br/>      newWindow(openDocument(file)).Show()<br/>   }<br/>}<br/><br/>func (a *app) openBlank() {<br/>   running := getFirstInstance(a)<br/>   if running != nil {<br/>      log.Println("Found running app, opening blank document")<br/>      running.openBlank()<br/>      os.Exit(0)<br/>   } else {<br/>      newWindow(newDocument()).Show()<br/>   }<br/>}</pre>
<p>The main function of the app that launches this will probably be to parse the command-line parameters to determine whether a filename has been passed, such as the following:</p>
<pre><span>func </span>main() {<br/>   app := &amp;app{}<br/><br/>   <span>if </span>len(os.Args) &lt;= <span>1 </span>{<br/>      app.openBlank()<br/>   } <span>else </span>{<br/>      app.openFile(os.Args[<span>1</span>])<br/>   }<br/>}</pre>
<p>The details of <kbd>getFirstInstance()</kbd> and the RPC code are out of scope for this chapter but can be found in the <kbd>chapter11/singleapp</kbd> folder in this book's code repository. This model may be supported by some toolkits, but there are also projects that aim to make this easier, such as <a href="https://github.com/marcsauter/single">https://github.com/marcsauter/single</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Extra features</h1>
                </header>
            
            <article>
                
<p>In some cases, it isn't possible to find equivalent behavior or user interface elements on every platform your application or toolkit supports. In these cases, you may find the toolkit providing operating system-specific extensions that can be used in your application code. If you make use of these platform-specific items, you'll need to ensure that your code still functions correctly on other target systems. This would normally be handled by the build constraints such as the preceding, where some implementations may have no or reduced <span>functionality </span>to match the lowest common denominator.</p>
<p>Such a platform extension is Qt Windows Extras, which provides the taskbar icon progress API and a method for providing a <em>jump list</em> (a set of shortcuts from the application icon). This project can be found at <a href="http://doc.qt.io/qt-5/qtwinextras-index.html">http://doc.qt.io/qt-5/qtwinextras-index.html</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored techniques for designing and programming more complex graphical applications. While looking at principles for complex layouts and deep navigation structures, we compared how common applications deal with these challenges and noted the types of complex user interfaces to avoid. To provide a richer, consistent user experience in these applications, we investigated the APIs that provide standard dialog windows and allow developers to configure application windows to be consistent with the application workflow.</p>
<p>Background task progress and system notifications should be visible but not interrupt the user's workflow. We explored how to use toolkit widgets and common techniques to provide this balanced communication. To further integrate with the current operating system, we explored the differences between, and additional features provided by, desktop platforms so that applications can match system semantics while maintaining a single code base for cross-platform development.</p>
<p>In the next chapter, we'll turn our attention to the background operations and networking features provided by Go and how to use them effectively in graphical application. We'll return to our GoMail examples and extend them using cloud services for a richer user experience.</p>


            </article>

            
        </section>
    </div>



  </body></html>