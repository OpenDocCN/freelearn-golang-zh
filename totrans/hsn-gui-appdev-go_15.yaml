- en: Navigation and Multiple Windows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航和多个窗口
- en: Through the last seven chapters, we've explored how to build a fairly simple
    graphical user interface using different toolkits and technologies. In each example,
    we saw benefits to the widget and API design but also challenges that are often
    faced when picking a toolkit. In this chapter, we're shifting focus to the planning
    and implementation of a more complex GUI—the sorts of challenges that will be
    encountered irrespective of the toolkit and technology selected.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的七个章节中，我们探讨了如何使用不同的工具包和技术构建相对简单的图形用户界面。在每个例子中，我们都看到了小部件和API设计的优势，但也看到了在选择工具包时经常面临的挑战。在本章中，我们将重点转向更复杂GUI的计划和实施——无论选择哪个工具包和技术，都会遇到的挑战。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Planning the workflow of a more complex GUI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划更复杂GUI的工作流程
- en: Window management and notifications for a clean user experience
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口管理和通知，以提供干净的用户体验
- en: Operating system-specific details and how to adapt a cross-platform application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统特定的细节以及如何适应跨平台应用程序
- en: At the end of this chapter, you'll have examined the bigger picture questions
    of application flow and navigation in a more complex graphical application. You'll
    have thought about how your GUI will fit within the current platform's flow and
    how to notify or engage the user as appropriate. So, let's get started by looking
    at the navigation of a complex application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将检查更复杂图形应用程序中的应用流程和导航的更大图景问题。你将思考你的GUI如何适应当前平台的流程，以及如何适当地通知或吸引用户。因此，让我们从查看复杂应用程序的导航开始。
- en: Planning application layout
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划应用程序布局
- en: Planning a large graphical application can seem like a daunting task, if you're
    thinking about all of the different users of your software and the varied devices
    it'll be used on. Or, it may seem quite straightforward if your ambitions can
    be realized by using standard design applications (such as Qt Creator or Glade
    for GTK+) that can generate code from a drag-and-drop interface. Unsurprisingly,
    creating a great user experience for your application interface will probably
    take a while to explore, plan, and design for the best result. The largest complexity
    is likely the navigation or overall layout of the application—we'll look first
    at layout techniques across multiple platforms.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 规划大型图形应用程序可能是一项艰巨的任务，如果你在考虑你软件的不同用户以及它将在哪些不同的设备上使用。或者，如果你的雄心可以通过使用标准设计应用程序（如Qt
    Creator或Glade for GTK+）来实现，这些应用程序可以从拖放界面生成代码，那么它可能看起来相当直接。不出所料，为你的应用程序界面创造一个出色的用户体验可能需要一段时间来探索、规划和设计以获得最佳结果。最大的复杂性可能是导航或应用程序的整体布局——我们将首先查看跨多个平台的布局技术。
- en: Standard layouts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准布局
- en: Each of the toolkits we've explored provide standard layout components that
    help to organize widgets and interface elements in neat, standardized arrangements.
    When you think about the naming of these layouts, however (for example, VBox,
    Border, and Frame), they typically describe fine-grained control rather than higher-level
    design concepts. For this section, we need to step back a little and think about
    the overall flow of an application, what will be the most used parts of the application,
    and what should the user see when they first load the user interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所探讨的每个工具包都提供标准的布局组件，有助于以整洁、标准化的方式组织小部件和界面元素。然而，当你考虑这些布局的命名时（例如，VBox、Border和Frame），它们通常描述的是细粒度控制，而不是更高层次的设计概念。对于本节，我们需要稍微退后一步，思考应用程序的整体流程，应用程序最常用的部分是什么，以及用户首次加载用户界面时应该看到什么。
- en: 'As discussed in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml), *Graphical
    User Interface Challenges*, desktop applications have been  standardized around
    a fairly common layout: menu, toolbar, palettes, and content. As applications
    have grown more complicated, there have been attempts to fit more functions and
    features into this space to allow users to gain access to the full feature set
    of these increasingly powerful applications. Since the rise in popularity of smart
    phones and mobile applications, there has been a lot of discussion about better
    use of screen real estate and how to make a great user experience with limited
    resources.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](d5375343-5332-4374-9297-dfbb256a5d91.xhtml)“图形用户界面挑战”中所述，桌面应用程序已经围绕一个相当常见的布局进行标准化：菜单、工具栏、调色板和内容。随着应用程序变得更加复杂，人们试图将更多功能和特性放入这个空间，以便用户能够访问这些越来越强大的应用程序的全部功能集。随着智能手机和移动应用程序的普及，关于如何更好地利用屏幕空间以及如何利用有限的资源创造出色的用户体验的讨论也很多。
- en: Research into the use of screens, readability of content, and related topics
    is now commonplace in relation to web design as well. Topics such as *How eye
    scanning impacts visual hierarchy in UX design* are often seen on recommended
    reading lists for those looking to improve their site's usability or user retention.
    With this in mind, we, as desktop or cross-platform application creators, should
    probably be thinking much more carefully about how our software is presented and
    whether the traditional methods fit with our specific use cases.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于屏幕使用、内容可读性及相关主题的研究现在在网页设计方面也很普遍。例如，*如何眼动扫描影响UX设计中的视觉层次*这类主题常常出现在那些希望提高网站可用性或用户保留率的推荐阅读列表上。考虑到这一点，作为桌面或跨平台应用程序的创作者，我们可能需要更加仔细地思考我们的软件是如何呈现的，以及传统方法是否适合我们的特定用例。
- en: 'Some GUI toolkits are beginning to provide higher-level layouts that reflect
    intention rather than a static visual layout. For example, `UISplitViewController` in
    Apple''s iOS presents a list view and detail view side by side when space is available
    or one view at a time (the detail view slides on when the list is tapped) when
    screens are smaller:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些GUI工具包开始提供更高层次的布局，这些布局反映意图而不是静态视觉布局。例如，当空间可用时，Apple的iOS中的`UISplitViewController`会并排显示列表视图和详细视图，或者当屏幕较小时（当列表被点击时，详细视图会滑动出来）：
- en: '![](img/0152c420-9201-4487-b56d-ada73f0cfc6f.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0152c420-9201-4487-b56d-ada73f0cfc6f.png)'
- en: An iOS split pane used for iPad settings app
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用于iPad设置应用的iOS分割视图
- en: '(Image copyright: Apple)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: （图片版权：Apple）
- en: '![](img/a2a775b7-e9f1-40d0-8eaa-d29d89afcd03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2a775b7-e9f1-40d0-8eaa-d29d89afcd03.jpg)'
- en: The same split pane on an iPhone
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone上的相同分割视图
- en: '(Image copyright: Apple)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: （图片版权：Apple）
- en: Where possible, these should be used in your application so your interface is
    configured appropriately for the current device, but there may be further customization
    needed. Let's look at some of the factors that impact more complex layout design.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，应在您的应用程序中使用这些元素，以便您的界面根据当前设备进行适当配置，但可能需要进一步的定制。让我们看看影响更复杂布局设计的一些因素。
- en: Device form factors
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备形态因素
- en: While primarily a consideration for mobile and modern portable devices, an application
    layout should be designed with the physical design of the device in mind. Visual
    and interaction technologies on the desktop have remained largely consistent for
    25 years, leading to standardized interface designs—but this too is changing.
    Computers are now more commonly shipping with ultra high definition screens, many
    of which are also touch surfaces. If your approach to cross-platform application
    development is to also include mobile devices, you will need to consider the small
    screen sizes as well as orientation of the device.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然主要考虑的是移动和现代便携式设备，但应用程序布局应考虑到设备的物理设计。桌面上的视觉和交互技术在过去25年中基本保持一致，导致标准化了界面设计——但这也在发生变化。现在，计算机更常见地配备超高分辨率屏幕，其中许多也是触摸表面。如果您的方法是跨平台应用程序开发，包括移动设备，您需要考虑屏幕尺寸以及设备的方向。
- en: Of course, the screen isn't the only factor to consider; it's now also common
    for input devices to vary. A mouse and keyboard is probably the main configuration
    for user input but many portable computers now have a *tablet mode* where touch
    input is a replacement for the mouse and a virtual keyboard can appear for text
    input. If this is a configuration you want to support, then your layout will need
    to work when parts of the screen (probably the bottom edge) is covered with the
    virtual keyboard. More importantly, finger-based input (most commonly called *multi-touch*)
    is far richer than a point and click approach; will your application aim to support
    *pinch to zoom* or *touch rotation*? If you intend to support these sorts of features,
    then make sure your chosen framework supports *input gestures*. Each toolkit is
    evolving rapidly and so the details have been omitted from this book as it would
    be out of date by publication.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，屏幕并不是唯一需要考虑的因素；现在输入设备的变化也很常见。鼠标和键盘可能是用户输入的主要配置，但许多便携式电脑现在都有*平板模式*，其中触摸输入可以替代鼠标，并且可以出现虚拟键盘进行文字输入。如果你想要支持这种配置，那么你的布局需要在屏幕的一部分（可能是底部边缘）被虚拟键盘覆盖时仍然有效。更重要的是，基于手指的输入（通常称为*多点触控*）比点击和点选的方法要丰富得多；你的应用程序是否旨在支持*捏合缩放*或*触摸旋转*？如果你打算支持这些类型的特性，那么请确保你选择的框架支持*输入手势*。每个工具包都在快速发展，因此，为了避免出版时过时，本书中省略了这些细节。
- en: In addition to the full device capabilities, a traditional desktop application
    can be moved around and made different sizes or orientations by many user actions—should
    your design aim to accommodate these changes in configuration? When displaying
    applications side by side on a tablet device, you'll see how powerful the different
    layouts can be when implemented correctly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了完整的设备功能外，传统的桌面应用程序可以通过许多用户操作进行移动和调整大小或方向——你的设计是否旨在适应这些配置的变化？当在平板设备上并排显示应用程序时，你会看到当正确实现时，不同的布局可以有多么强大。
- en: Responsive or adaptive design
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式或自适应设计
- en: 'To be able to suit a wide variety of devices, it normally won''t be possible
    to use a single user interface design. Therefore, some form of adaptation to the
    current environment will probably be necessary. There are two main schools of
    thought with regard to adapting to variations in screen and device capability:
    responsive and adaptive designs. Both aim to provide an appropriate user experience
    with an interface that feels native to the current device. While these principles
    currently refer mostly to web application design, they can also be applied to
    native applications, especially if designing for multiple platforms.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够适应广泛的设备，通常不可能使用单一的用户界面设计。因此，可能需要对当前环境进行某种形式的适应。关于适应屏幕和设备功能的变化，有两种主要的思想流派：响应式和自适应设计。两者都旨在提供一个适合当前设备的适当用户体验。虽然这些原则目前主要指的是网络应用程序设计，但它们也可以应用于原生应用程序，尤其是当设计针对多个平台时。
- en: When following adaptive principles, application designers will choose a limited
    set of device configurations to design for, typically a mobile device (possibly
    in multiple orientations), a tablet device, and a regular desktop. By designing
    for these categories, the amount of time spent designing for specific devices
    is reduced, focusing only on these defined configurations. When focusing on a
    small number of variations, the design can be perfected for these different use
    cases, creating a very smooth experience. When implemented this way, an application
    will detect which category of device it's running on and load the appropriate
    layout (sometimes this is handled automatically by the framework). This approach
    has been exemplified by Apple's iOS SDK (user interfaces are defined for iPhone,
    iPhone Plus, and iPad), the correct user interface will be loaded and a single
    application can execute with any configuration. The limitation of the adaptive
    approach is that *intermediate* devices, ones that are smaller or larger than
    expected (or with unusual configurations), will probably not look or function
    as the user may expect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当遵循适应性原则时，应用程序设计师会选择一个有限的设备配置集来设计，通常是一个移动设备（可能具有多个方向），一个平板设备，和一个常规桌面。通过为这些类别设计，为特定设备设计所花费的时间将减少，只需关注这些定义的配置。当专注于少数几种变化时，设计可以针对这些不同的用例进行优化，从而创造一个非常流畅的体验。当以这种方式实施时，应用程序将检测其正在运行的设备类别，并加载相应的布局（有时这由框架自动处理）。这种方法已被苹果的iOS
    SDK（用户界面为iPhone、iPhone Plus和iPad）所证实，正确的用户界面将被加载，单个应用程序可以以任何配置执行。适应性方法的局限性在于，*中间*设备，即比预期小或大的设备（或具有不寻常的配置），可能不会以用户期望的方式看起来或运行。
- en: Responsive design, on the other hand, aims to define a single user interface
    that responds to the current device configuration. Layouts created in this manner
    will typically have certain trigger values or inflection points that determine
    the visibility of elements or the positioning and sizing of items that should
    always be shown (in CSS, this is usually done with *media queries*). The responsive
    technique is becoming more popular in designing websites that wish to provide
    a good experience on a huge range of different devices; it probably won't provide
    the perfect user interface that adaptive design aims for, but it does cater for
    every device from the smallest, least capable to the full desktop experience.
    This approach maps well to the cross-platform approach that's likely part of the
    intention of a team developing application GUIs with Go because we don't usually
    know the devices that our software will be run on ahead of time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，响应式设计旨在定义一个单一的用户界面，使其能够响应当前设备的配置。以这种方式创建的布局通常会有某些触发值或拐点，这些值或拐点决定了元素的可见性或始终应显示的项目（在CSS中，这通常是通过*媒体查询*来实现的）。响应式技术在设计旨在为各种不同设备提供良好体验的网站中越来越受欢迎；它可能无法提供适应性设计所追求的完美用户界面，但它确实为从最小、最不具能力的设备到完整的桌面体验的每一款设备都提供了支持。这种方法很好地映射到跨平台方法，这可能是使用Go开发应用程序GUI的团队意图的一部分，因为我们通常不知道我们的软件将在哪些设备上运行。
- en: 'The toolkits explored in this book offer some amount of support for responsive
    layouts. Grids that lay out the content according to the space available and the
    screen layout are a good place to start. Some are pushing further into this space
    by providing semantic layouts that''ll adapt correctly to the current device:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本书探讨的工具包为响应式布局提供了一定程度的支持。根据可用空间和屏幕布局来布局内容的网格是一个良好的起点。一些工具包正在进一步探索这个领域，通过提供能够正确适应当前设备的语义布局：
- en: '![](img/9fbcb119-1372-4675-b596-4e429bb620fc.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fbcb119-1372-4675-b596-4e429bb620fc.png)'
- en: An example of a possible responsive layout at three different sizes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 三种不同尺寸的可能响应式布局示例
- en: Custom layouts
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义布局
- en: It's likely that your application has requirements that are different to standard
    layouts or more complicated than the toolkit's API supports. Using standard layouts
    where possible is recommended but that doesn't have to mean giving up on your
    ideal application design. Every toolkit supports custom layouts in some manner
    that you can make use of to fill the gaps in the available standard layouts. When
    implementing a custom layout in this manner, the basic approach is to set a fixed
    position for each component within the parent container. To better adapt to the
    available screen space, remember to factor in the current width and height of
    the interface; it's often easier to implement using ratios or percentages rather
    than absolute values (for example, a list component is 25% of the screen width
    or content columns are 1/3 of the available space).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可能具有与标准布局不同的要求，或者比工具包的API支持的更复杂。尽可能使用标准布局是推荐的，但这并不意味着必须放弃您理想的应用程序设计。每个工具包都以某种方式支持自定义布局，您可以利用它来填补可用标准布局的空白。以这种方式实现自定义布局时，基本方法是设置父容器内每个组件的固定位置。为了更好地适应可用的屏幕空间，请记住考虑界面的当前宽度和高度；使用比率或百分比而不是绝对值（例如，列表组件是屏幕宽度的25%或内容列是可用空间的1/3）通常更容易实现。
- en: 'In more advanced toolkits, there''s also a *constraints-based* layout available,
    one that lays out components based on configured equations instead of hardcode
    values. The standard algorithm for constraints layouts is named Cassowary and
    is fully documented at [http://overconstrained.io/](http://overconstrained.io/).
    The basic principle is that each layout value can be defined as the result of
    an equation in the form `item1.attr1 = item2.attr2 × multiplier + constant` (such
    as `button.top = content.bottom × 1.0 + 25`). Constraints-based layouts (also
    known as **auto layouts**) are standard in iOS and Android but not so common in
    desktop toolkits. Modern GUIs often include this functionality as standard but
    using this functionality in others such as Qt and GTK will require the integration
    of third-party projects (as these aren''t currently available through Go bindings,
    the integration is out of scope for this chapter):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高级的工具包中，还有一个基于约束的布局可用，它根据配置的方程而不是硬编码的值来布局组件。约束布局的标准算法名为Cassowary，并在[http://overconstrained.io/](http://overconstrained.io/)上进行了全面文档记录。基本原理是每个布局值都可以定义为形式为`item1.attr1
    = item2.attr2 × multiplier + constant`的方程的结果（例如，`button.top = content.bottom ×
    1.0 + 25`）。基于约束的布局（也称为**自动布局**）在iOS和Android中是标准的，但在桌面工具包中并不常见。现代GUI通常包括这项功能作为标准，但在Qt和GTK等其他工具包中使用此功能将需要集成第三方项目（因为这些目前无法通过Go绑定获得，因此集成超出了本章的范围）：
- en: '![](img/4cc931b4-d7e1-4cf5-b684-cf8a94a7ef64.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cc931b4-d7e1-4cf5-b684-cf8a94a7ef64.png)'
- en: Adding constraints to a label with Xcode (image copyright: Big Nerd Ranch, LLC)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Xcode向标签添加约束（图片版权：Big Nerd Ranch, LLC）
- en: Navigating your application
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航您的应用程序
- en: 'Consistent and easy-to-follow navigation through a complex application is hard
    to attain but doing it well can lead to dramatically improved user experience.
    A typical application has a core set of functionality—which should always be easy
    to access—and a larger set of additional tools and helpful features that are used
    less frequently. Keeping the balance between core features and additional functionality
    is something that many applications haven''t yet solved. Overcrowded toolbars
    and very long menus are problems we encounter on a regular basis:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的应用程序中实现一致且易于遵循的导航是困难的，但做得好可以显著提高用户体验。典型的应用程序有一个核心功能集——这些功能应该始终容易访问——以及一个更大的辅助工具和功能集，这些工具和功能使用频率较低。在核心功能和附加功能之间保持平衡是许多应用程序尚未解决的问题。过于拥挤的工具栏和非常长的菜单是我们经常遇到的问题：
- en: '![](img/d1b58816-896a-4fec-8621-ad2a566718a2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1b58816-896a-4fec-8621-ad2a566718a2.jpg)'
- en: Menus, toolbars, shortcuts, and drop-down lists all above a document in Microsoft
    Office 2007
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Office 2007中，菜单、工具栏、快捷方式和下拉列表都位于文档上方
- en: Finding ways to limit the various options onscreen should lead to less user
    confusion. It's the responsibility of an application designer to make a clear
    and easy-to-use interface, not to present all of the options and expect users
    to learn how to navigate. There are various methods for adjusting a user interface
    to focus on the essential or most useful features; we'll explore them in the following
    sections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找限制屏幕上各种选项的方法应该会导致用户困惑减少。应用设计师的责任是创建一个清晰且易于使用的界面，而不是展示所有选项并期望用户学习如何导航。调整用户界面以关注基本或最有用功能的方法有很多；我们将在以下章节中探讨它们。
- en: Progressive disclosure
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渐进式披露
- en: In larger applications (as previously illustrated), it's likely that the number
    of features available can't easily be presented in a minimal user interface. When
    that's the case, application designers will have a new challenge in creating a
    smooth learning curve for new users. How can an application's user interface be
    designed both for a complex feature set and to be easy to learn by people who
    are new to the product?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的应用程序（如之前所示），可能无法轻松地在最小用户界面中展示所有可用功能。在这种情况下，应用设计师将面临一个新的挑战，即为新用户提供平滑的学习曲线。如何设计一个应用程序的用户界面，既能满足复杂的功能集，又易于产品新手学习？
- en: Progressive disclosure is a technique for helping to focus a user's attention
    and facilitate learning a complex system. This is achieved by hiding functionality
    or data that isn't necessary to support the task at hand. Commonly, this is implemented
    by starting with a basic set of functionality visible and expanding as the user
    explores areas beyond the basics. Triggers to expand the functionality available
    may be accessing a new menu item, an Advanced button, or simply using the application
    for a certain time or adding sufficient data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进式披露是一种帮助集中用户注意力并促进学习复杂系统的技术。这是通过隐藏对完成当前任务不必要的功能或数据来实现的。通常，这是通过从可见的基本功能集开始，并在用户探索超出基本范围的区域时扩展来实现的。扩展可用功能的触发器可能包括访问新的菜单项、高级按钮，或者简单地使用应用程序一段时间或添加足够的数据。
- en: Example 1 – Microsoft Edge
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 1 – Microsoft Edge
- en: A standard feature of popular web browsers is the developer tools that they
    include—but this isn't core functionality. When building their new web browser,
    Edge, Microsoft decided to focus on the core features, hiding more advanced functionality,
    such as developer tools, from the average user.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 流行网络浏览器的一个标准功能是它们包含的开发者工具，但这不是核心功能。当构建新的网络浏览器Edge时，微软决定专注于核心功能，将更高级的功能，如开发者工具，隐藏在普通用户之外。
- en: 'If enabled through a single menu item (the ... menu, then F12 Developer Tools)
    or the *F12* keyboard shortcut, the developer features are switched on. From then
    on, the browser will present developer features in all of the expected places,
    creating a much richer application feature set:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过单个菜单项（...菜单，然后按F12开发者工具）或*F12*键盘快捷键启用，开发者功能将被激活。从那时起，浏览器将在所有预期位置展示开发者功能，创建一个功能更丰富的应用程序功能集：
- en: '![](img/423fbed2-8a2e-45cd-b959-447774d8fc2e.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/423fbed2-8a2e-45cd-b959-447774d8fc2e.png)'
- en: The default Edge context menu
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认Edge上下文菜单
- en: 'F12 or Developer Tools menu item:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: F12或开发者工具菜单项：
- en: '![](img/ca583515-75b8-49f5-8d7e-b91152f9e143.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca583515-75b8-49f5-8d7e-b91152f9e143.png)'
- en: After developer tools are enabled
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用开发者工具后
- en: Example 2 – Skyscanner flight search
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 2 – Skyscanner航班搜索
- en: The main functionality of the Skyscanner service ([https://www.skyscanner.net/](https://www.skyscanner.net/))
    is to search through the many flights available, matching a certain criteria based
    on price, time, location, and so forth. After finding a suitable journey in the
    (initially minimal looking) mobile app, a user would normally go through a booking
    process to purchase their flights.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Skyscanner服务的主要功能([https://www.skyscanner.net/](https://www.skyscanner.net/))是搜索众多航班，根据价格、时间、位置等标准进行匹配。在（最初看起来最小的）移动应用中找到合适的旅程后，用户通常会通过预订流程购买他们的航班。
- en: If they aren't ready to make the purchase, a user of the application can *favorite* a
    flight combination for later. Upon doing this, a menu will appear in the application
    from which favorite searches can be returned to. If these searches are visited
    many times, then another new feature called *watched flights* appears, which allows
    more advanced holiday planners to monitor the varying prices of their searches.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户还没有准备好购买，应用程序用户可以将航班组合*收藏*起来以备后用。完成此操作后，应用程序中会出现一个菜单，用户可以从中返回收藏的搜索。如果这些搜索被访问多次，则会出现另一个新功能，称为*关注的航班*，允许更高级的假日规划者监控搜索价格的变动。
- en: Menus and toolbars
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单和工具栏
- en: When there are many items that you wish to provide to users of your application,
    a menu or toolbar are convenient options, but should be used carefully and sparingly.
    Too many options added to a toolbar can add to the cluttered *ribbon* user interface
    from Microsoft Office, as previously displayed. Likewise, adding a menu item for
    every feature will probably lead to cognitive overload as users spend too much
    time trying to find an item or remember where it's located.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望向应用程序用户提供许多项目时，菜单或工具栏是方便的选择，但应谨慎且适度地使用。将太多选项添加到工具栏可能会增加类似于微软Office的杂乱无章的*功能区*用户界面，如之前所示。同样，为每个功能添加菜单项可能会导致认知过载，因为用户会花费太多时间试图找到项目或记住它们的位置。
- en: Toolbar
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具栏
- en: A toolbar is ideally suited for actions that'll be used on a regular basis.
    For example, in our email application Reply will be a popular action, as will
    New and Delete. Grouping toolbar items together by similarity (for example, Reply
    and Reply All or Cut, Copy, and Paste) will help users to find your shortcuts
    quickly. Ordering these groups by likelihood of use will mean that, if the user
    interface is smaller than expected, then the most useful features will still be
    visible. To provide access to tools that don't fit onto the screen, you can use
    an overflow item (where it pops out a list of not-visible items), make the tool
    bar scrollable, or provide access in a different place, such as a menu or second
    row.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏非常适合用于日常操作。例如，在我们的电子邮件应用程序中，回复将是一个常用的操作，同样还有新建和删除。通过将工具栏项目按相似性分组（例如，回复和全部回复或剪切、复制和粘贴），可以帮助用户快速找到您的快捷方式。按使用频率对这些组进行排序意味着，如果用户界面小于预期，则最有用的功能仍然可见。为了提供无法放入屏幕的工具的访问权限，您可以使用溢出项（其中弹出不可见项目的列表），使工具栏可滚动，或在不同的地方提供访问权限，例如菜单或第二行。
- en: Toolbars are popular in most form factors of devices, from small phones up to
    large desktop applications. The main difference is clearly the number of items
    that can be included. If you're including toolbars in a responsive or adaptive
    layout, you may consider a more complex strategy than leftmost-visible. For example,
    in an email application, if only five items can be displayed, then removing Reply
    All so Delete can be seen might be a good approach; the user could always choose
    to reply to all in the compose window after pressing Reply.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏在大多数设备形态中都很受欢迎，从小型手机到大型桌面应用程序。主要区别是可包含的项目数量。如果您在响应式或自适应布局中包含工具栏，您可能需要考虑比最左侧可见更复杂的策略。例如，在电子邮件应用程序中，如果只能显示五个项目，那么删除全部回复以便显示删除可能是一个好方法；用户可以在按下回复后，在撰写窗口中选择全部回复。
- en: 'Many applications choose to allow items in the toolbar to be rearranged, a
    feature that''s provided by some graphical toolkits (for example, UIKit for Apple''s
    iOS devices and AppKit for their desktop applications):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序选择允许工具栏中的项目重新排列，这是某些图形工具包提供的一项功能（例如，苹果iOS设备的UIKit和桌面应用程序的AppKit）：
- en: '![](img/80718ee3-df87-412a-bdcf-c07842aa8917.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80718ee3-df87-412a-bdcf-c07842aa8917.png)'
- en: 'A sample user interface for customizing toolbars in macOS (image copyright:
    Apple)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: macOS中自定义工具栏的示例用户界面（图片版权：苹果）
- en: Menu
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单
- en: Menu bars have traditionally been thought of as the right location to place
    all otherwise absent feature access in an application. With a long list of items
    in a growing number of menu headings, an application menu can quickly become hard
    to navigate. This is generally considered to be due to the number of items that
    an average human can hold in their short-term memory. Experiments by George Miller
    in 1956 suggested that the number of objects that can typically be held in working
    memory is between five and nine (seven plus or minus two—Miller's "Magical Number").
    More recent estimates have shown that this number is typically lower, closer to
    just four or five items.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单栏传统上被认为是放置应用程序中所有其他缺失功能访问的最佳位置。随着菜单标题中项目数量的不断增加，应用程序菜单很快就会变得难以导航。这通常被认为是由于平均人类在短期记忆中可以保持的项目数量。乔治·米勒在1956年的实验表明，通常可以保持在工作记忆中的项目数量在五到九之间（七加减二——米勒的“神奇数字”）。更近期的估计显示，这个数字通常更低，接近四到五个项目。
- en: Taking this into consideration, we can understand why it's important to keep
    menus fewer and shorter—at every step of navigating, there should be no more than
    nine options available—and far less, if possible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以理解为什么保持菜单数量少且简短很重要——在导航的每一步，应该不超过九个选项，如果可能的话，则更少。
- en: The presentation of a menu varies from one platform to another with the standard
    top of the window or top of the screen being most common on the desktop, and an
    icon at the top-left of the screen (known as the hamburger) most prevalent on
    mobile layouts. What you'll notice, regardless of the layout, is that the top-level
    list will be around five items and, if further options are required, the menus
    that cascade down won't be much longer than that. If you find your menus becoming
    overwhelmingly long, perhaps consider task-specific toolbars or other grouping
    of context-relevant shortcuts, possibly opened from a single menu item.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单的呈现方式因平台而异，标准的是窗口顶部或屏幕顶部，在桌面应用中最为常见，而在移动布局中，屏幕左上角的图标（被称为汉堡菜单）最为普遍。无论布局如何，你都会注意到顶级列表大约有五个项目，如果需要更多选项，下拉菜单不会比这更长。如果你发现你的菜单变得过长，也许可以考虑任务特定的工具栏或其他与上下文相关的快捷方式分组，可能从单个菜单项打开。
- en: Whatever design you choose for making features available, please remember the
    user's main focus or the current context.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种设计来提供功能，请记住用户的主要焦点或当前上下文。
- en: 'You don''t want to end up overwhelming them to the point that there''s significant
    thinking required at every step of the way:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望它们变得如此复杂，以至于每一步都需要进行大量的思考：
- en: '![](img/9fac0744-14e6-442b-9095-b10cc6cf2527.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fac0744-14e6-442b-9095-b10cc6cf2527.jpg)'
- en: Visual Studio with all of its viewers and toolbars switched on (copyright Dylan
    Beattie)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: （版权所有：Dylan Beattie）Visual Studio的所有视图和工具栏都已开启
- en: Multiple windows
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个窗口
- en: One more approach that can help your application to be easier to navigate is
    to split the content into multiple windows. Each will be a different view of your
    application, within which the appropriate toolbars or menus can be presented for
    the current context. As shown in our GoMail examples, we compose new messages
    in a separate window; this allows us to group editing-related items close to the
    input fields and allows us to simultaneously be drafting multiple messages without
    cluttering our email browse window.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助你的应用程序更容易导航的另一种方法是将内容分割成多个窗口。每个窗口都将是你应用程序的不同视图，其中可以展示适合当前上下文的适当工具栏或菜单。正如我们的GoMail示例所示，我们在单独的窗口中编写新消息；这允许我们将与编辑相关的项目分组在输入字段附近，并允许我们同时草拟多个消息，而不会使我们的电子邮件浏览窗口变得杂乱。
- en: Of course, multiple windows won't necessarily have the same semantics on different
    platforms. If we were to take the same approach on a smart phone device, it would
    be common for the compose window to be presented as an overlay to the existing
    application. Whether the user can switch between that mode and the browse window
    may be down to the operating system's design or we may decide that, when running
    on a smaller device, the compose window should be a *modal* window (that is, it
    blocks access to the parent window. This is discussed further later).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不同的平台上的多个窗口不一定具有相同的语义。如果我们在一个智能手机设备上采取同样的方法，将合成窗口作为现有应用的叠加显示是很常见的。用户是否可以在该模式和浏览窗口之间切换，可能取决于操作系统的设计，或者我们可能决定，在较小的设备上运行时，合成窗口应该是一个**模态**窗口（即，它阻止对父窗口的访问。这一点将在稍后进一步讨论）。
- en: Yet another approach that we saw in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml), *Graphical
    User Interface Challenges*, was to have multiple windows for the main focus of
    the applications. These peripheral windows are typically for toolbars or detailed
    information/control of the content in the main window and can be particularly
    helpful in content creation-based applications. With the content expanding to
    fill the whole of the main window, the toolbars and context actions have been
    placed in separate windows to keep the user focused. This type of layout and navigation
    is usually adopted in *pro* applications where the user knows the domain well.
    The added complexity of this approach can lead to confusion for early users of
    a product and so we, as application designers and developers, should be mindful
    of the number of windows or different layouts and contexts we present in our user
    interface.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](d5375343-5332-4374-9297-dfbb256a5d91.xhtml)，*图形用户界面挑战*中看到的一种另一种方法是为主应用程序的焦点提供多个窗口。这些外围窗口通常是工具栏或主窗口中内容详细信息/控制的详细信息，在基于内容创建的应用程序中尤其有帮助。随着内容扩展以填充整个主窗口，工具栏和上下文操作已被放置在单独的窗口中，以保持用户专注。这种布局和导航通常在*专业*应用程序中采用，其中用户对领域非常了解。这种方法的附加复杂性可能导致产品早期用户感到困惑，因此作为应用程序的设计师和开发者，我们应该注意我们在用户界面中呈现的窗口数量或不同的布局和上下文。
- en: Window types and keeping things clean
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口类型和保持整洁
- en: Managing multiple windows will become essential for any application, either
    through part of a layout design like the preceding, or for presenting important
    information to the user to gain their attention or receive their input. For each
    window that's displayed in your application, it's important to know whether its
    appearance should attract their immediate attention, support what's already onscreen,
    or simply be something that can be attended to later. Knowing the intention of
    each window shown will help to support, rather than impede, the user workflow
    and keep your application's user experience clean.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 管理多个窗口对于任何应用程序都将成为必要，无论是通过像前面那样的布局设计的一部分，还是为了向用户展示重要信息以吸引他们的注意或接收他们的输入。对于您应用程序中显示的每个窗口，了解其外观是否应该立即吸引他们的注意，支持屏幕上已有的内容，或者只是可以稍后关注的事情，这一点很重要。了解显示的每个窗口的意图将有助于支持而不是阻碍用户的工作流程，并保持您应用程序的用户体验整洁。
- en: Standard dialogs
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准对话框
- en: The most common reason to show an additional window during application flow
    is to ask the user for additional input or confirmation, or to alert them of (typically
    unexpected) events. These are standard interactions and so it's usually most effective
    to use, where possible, the provided dialog windows defined by the toolkit being
    used. Using the provided APIs will generally provide the most consistent user
    experience and will almost certainly lead to less code in your application as
    well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序流程中显示额外窗口的最常见原因是请求用户输入或确认，或提醒他们（通常是意外的）事件。这些是标准交互，因此通常最有效的方法是尽可能使用所使用的工具包提供的对话框窗口。使用提供的API通常将提供最一致的用户体验，并且几乎肯定会导致您的应用程序中的代码更少。
- en: 'The types of standard dialogs provided by a toolkit will normally include file
    handling (open and save), progress (when the user must wait), message (to show
    warnings or errors), and a confirmation dialog (to ask an immediate question).
    On more advanced toolkits, you can also expect to find dialog APIs to help with
    color selection, font selection, document printing, and even a standardized About
    window. The following APIs are great places to get started with some of the toolkits
    we covered earlier in this book (with namespace included if it''s not the default):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 工具包提供的标准对话框类型通常包括文件处理（打开和保存）、进度（当用户必须等待时）、消息（显示警告或错误）以及确认对话框（立即提问）。在更高级的工具包中，您还可以期待找到用于颜色选择、字体选择、文档打印甚至标准关于窗口的对话框API。以下API是开始使用本书前面提到的某些工具包的绝佳起点（如果它不是默认的，则包括命名空间）：
- en: '|  | **walk** | **andlabs UI** | **GoGTK** | **qt** | **Fyne** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  | **遍历** | **andlabs UI** | **GoGTK** | **qt** | **Fyne** |'
- en: '| **open** | `ShowOpen` | `OpenFile` | `NewFileChooserDialog` | `widgets.NewQFileDialog`
    |  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **打开** | `ShowOpen` | `OpenFile` | `NewFileChooserDialog` | `widgets.NewQFileDialog`
    |  |'
- en: '| **save** | `ShowSave` | `SaveFile` | `NewFileChooserDialog` | `widgets.NewQFileDialog`
    |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **保存** | `ShowSave` | `SaveFile` | `NewFileChooserDialog` | `widgets.NewQFileDialog`
    |  |'
- en: '| **progress** |  |  |  | `widgets.NewQProgressDialog` | `dialog.NewProgress`
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **进度** |  |  |  | `widgets.NewQProgressDialog` | `dialog.NewProgress` |'
- en: '| **message** |  | `MsgBox``MsgBoxError` | `NewMessageDialog` | `widgets.NewQMessageBox``widgets.NewErrorMessage`
    | `dialog.ShowInformation``dialog.ShowError` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **消息** |  | `MsgBox` `MsgBoxError` | `NewMessageDialog` | `widgets.NewQMessageBox`
    `widgets.NewErrorMessage` | `dialog.ShowInformation` `dialog.ShowError` |'
- en: '| **confirm** |  |  |  | `widgets.NewQMessageBox` | `dialog.ShowConfirmation`
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **确认** |  |  |  | `widgets.NewQMessageBox` | `dialog.ShowConfirmation` |'
- en: '| **input** |  |  |  | `widgets.NewQInputDialog` |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **输入** |  |  |  | `widgets.NewQInputDialog` |  |'
- en: '| **color** |  |  |  | `widgets.NewQColorDialog` |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **颜色** |  |  |  | `widgets.NewQColorDialog` |  |'
- en: '| **font** |  |  | `FontSelection` | `widgets.NewQFontDialog` |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **字体** |  |  | `FontSelection` | `widgets.NewQFontDialog` |  |'
- en: '| **print** |  |  |  | `printsupport.NewQPrintDialog` |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **打印** |  |  |  | `printsupport.NewQPrintDialog` |  |'
- en: '| **about** |  |  | `NewAboutDialog` |  |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **关于** |  |  | `NewAboutDialog` |  |  |'
- en: '| **custom** | `NewDialog` |  | `NewDialog` | `widgets.NewQDialog` | `dialog.ShowCustom`
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **自定义** | `NewDialog` |  | `NewDialog` | `widgets.NewQDialog` | `dialog.ShowCustom`
    |'
- en: It's often useful to show a small selection or confirmation window that isn't
    in the preceding list (either because your requirements are different or the toolkit
    hasn't implemented that feature). This can be achieved by creating a new window,
    packing the content, and showing it, but the recommended method is to use the
    custom dialog API instead. Showing a dialog instead of a standard window allows
    the toolkit to configure the window to best effect. This typically involves setting
    it to be a non-resizable, topmost window that's *modal* (meaning the user can't
    interact with the window underneath until the dialog is dismissed).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时显示一个小型的选择或确认窗口，而不在先前的列表中（要么是因为你的需求不同，要么是因为工具包尚未实现该功能）。这可以通过创建一个新窗口，打包内容并显示它来实现，但推荐的方法是使用自定义对话框API。显示对话框而不是标准窗口允许工具包将窗口配置为最佳效果。这通常涉及将其设置为不可调整大小的、最顶层的模态窗口（意味着用户在对话框关闭之前不能与下面的窗口交互）。
- en: Modal windows
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态窗口
- en: As suggested previously, a modal window is one that blocks user input to the
    window that it's above. This typically means it's placed in the center of a parent
    window and the window below will be disabled or grayed out, focusing the user
    interaction on the new dialog window. This is typical of dialog windows as they're
    designed to appear only when the user can't continue with the current task until
    the information, confirmation, or progress is completed (at which point the dialog
    disappears and control returns).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所述，模态窗口是一种阻止用户向其上方的窗口输入的窗口。这通常意味着它被放置在父窗口的中心，下面的窗口将被禁用或变灰，将用户交互集中在新的对话框窗口上。这是对话框窗口的典型特征，因为它们设计为仅在用户无法继续当前任务（直到信息、确认或进度完成）时出现（此时对话框消失，控制权返回）。 '
- en: To function in this way, a modal window is usually passed the parent window
    that it should occlude. The input will be forced to the new modal window (depending
    on the desktop environment and configuration, this may not be the case if the
    parent window isn't currently the topmost application) to interact with the new
    interface. Different platforms can present modal windows using various styles;
    some will look like a regular window (often with maximize and minimize buttons
    disabled), others will present the content embedded within the current window,
    and others (such as macOS) can present them appearing from the title bar of the
    parent window. Using the built-in API for custom dialogs will mean that these
    visual styles are consistent within your application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以这种方式运行，模态窗口通常会被传递一个父窗口，该窗口应该被遮挡。输入将被强制导向新的模态窗口（根据桌面环境和配置，如果父窗口当前不是最顶层应用程序，则可能不会这样）以与新的界面交互。不同的平台可以使用各种样式来显示模态窗口；一些看起来像普通窗口（通常禁用最大化和小化按钮），其他则将内容嵌入到当前窗口中，还有一些（如macOS）可以从父窗口的标题栏中显示它们。使用内置的API进行自定义对话框将意味着这些视觉风格在你的应用程序中是一致的。
- en: There may be a reason, however, that your application requires a new window
    to take focus in a different type of workflow. For these cases, a toolkit often
    allows the *modality* of a window to be set directly. This can be a powerful feature
    but be sure to consider whether there isn't a better API to manage this flow,
    or whether a custom dialog window may be a better fit.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能存在某种原因，使得你的应用程序需要在不同的工作流程中打开一个新窗口以获取焦点。在这些情况下，工具包通常允许直接设置窗口的**模态**。这可能是一个强大的功能，但请确保考虑是否没有更好的API来管理此流程，或者是否自定义对话框窗口可能更适合。
- en: Window hints
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口提示
- en: The properties of a window (referred to as *hints* on many systems) allow an
    application to indicate certain desired attributes to the operating system that'll
    control how a window is presented. For various reasons (including user experience
    and even security), an application can't mandate how and when a window will be
    presented in most situations; therefore, it's important to remember that these
    hints may not be enforced.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的属性（在许多系统中被称为*提示*）允许应用程序向操作系统指示某些期望的属性，这将控制窗口的展示方式。由于各种原因（包括用户体验甚至安全性），在大多数情况下，应用程序不能强制规定窗口如何以及何时展示；因此，重要的是要记住，这些提示可能不会被强制执行。
- en: Sizes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尺寸
- en: The most common hints set are related to size—the minimum and possibly maximum
    size that your user interface should occupy. Minimum size is almost universally
    supported; every graphical system will try to allow an application to use as much
    space as it claims to need. Be sure to have sensible sizes though as, especially
    when targeting multiple different platform types, the minimum size shouldn't be
    bigger than the screen available! To avoid this situation, the operating system
    will probably show your application windows smaller than requested so that the
    user doesn't have the problem of accessing portions of the user interface that
    are off-screen. For this reason alone, it's recommended that the minimum size
    set is truly the smallest size that your GUI will operate correctly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的提示设置与大小相关——即用户界面应占用的最小和可能的最大尺寸。最小尺寸几乎在所有图形系统中都得到支持；每个图形系统都会尽量允许应用程序使用它声称需要的空间。但是，请确保尺寸合理，因为，尤其是当针对多种不同的平台类型时，最小尺寸不应大于可用的屏幕！为了避免这种情况，操作系统可能会显示比请求的更小的应用程序窗口，这样用户就不会遇到访问屏幕外用户界面部分的问题。仅出于这个原因，建议设置的最低尺寸确实是GUI能够正确运行的最低尺寸。
- en: So that an application is proportioned correctly when first loaded, it's common
    to set a default or preferred size (typically through `SetDefaultSize()`, `SetSize()`,
    or `Resize()`). This means that, as much as possible, your application will load
    at a sensible size, but smaller if the screen isn't large enough. In the example
    of our *New GoMail* email compose window, we can set a good default for typing
    a large email while having a sensible minimum size (probably calculated by the
    toolkit) that allows access to all of the input fields.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应用程序在首次加载时比例正确，通常设置一个默认或首选的大小（通常通过`SetDefaultSize()`、`SetSize()`或`Resize()`实现）。这意味着，尽可能多的情况下，应用程序将以一个合理的尺寸加载，但如果屏幕不够大，则可能更小。在我们的*新GoMail*电子邮件编写窗口的例子中，我们可以设置一个良好的默认值，以便在保持合理的最小尺寸（可能由工具包计算得出）的同时，允许访问所有输入字段。
- en: Additionally, it may be helpful to set a maximum size for your window; while
    not used as often as minimum or default sized, this can be helpful. Most commonly,
    this is helpful if you want your window to remain small (such as a toolbox or
    information window) or expand only in one direction (to allow only height adjustments,
    or set the minimum and maximum width to the same value). It's also helpful in
    presenting custom dialog boxes to set the minimum and maximum size to the same
    value, hence requesting that the window be a fixed size. Some toolkits make this
    easier by providing a `SetFixedSize()` function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为您的窗口设置一个最大尺寸可能也有帮助；虽然不像最小或默认尺寸那样常用，但这可能很有帮助。最常见的情况是，如果您希望窗口保持较小（例如工具箱或信息窗口）或仅向一个方向扩展（仅允许高度调整，或将最小和最大宽度设置为相同的值）。在展示自定义对话框时，将最小和最大尺寸设置为相同的值也很有帮助，因此请求窗口为固定大小。一些工具包通过提供`SetFixedSize()`函数使这变得更容易。
- en: Other hints
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他提示
- en: There are many other types of properties or hints that can be set on windows
    to help guide users through an application. Depending on the toolkit, it may be
    possible to set the window type. This is usually handled automatically when displaying
    a dialog window (as they can have special properties) but may not be handled for
    other types of window creation. Check out the window API in your chosen toolkit
    to see whether you can set the type of window when doing things such as creating
    a toolbox window or information panel that should belong to a parent window somehow.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在窗口上设置许多其他类型的属性或提示，以帮助用户在应用程序中导航。根据工具包的不同，可能可以设置窗口类型。这通常在显示对话框窗口时自动处理（因为它们可以具有特殊属性），但对于其他类型的窗口创建可能不会处理。请检查您选择的工具包中的窗口API，以查看您是否可以在创建工具箱窗口或信息面板等应属于父窗口的窗口时设置窗口类型。
- en: The most instructive window hint is the icon that's displayed in places such
    as the task bar, application switcher, and possibly the window border. On some
    systems, the default icon is that of the application, and in others it's a window
    specific image. Generally, it's a good idea to set the same icon on your application
    windows and application icon, which may be handled by the toolkit you're using.
    Setting a different icon for a window should be reserved for times when the window
    serves a different purpose to the main window. To avoid user confusion, window
    icons that differ from the main one should indicate through style or content which
    main icon they relate to. Setting a window icon is usually achieved by calling
    `window.SetIcon()` or `widget.SetWindowIcon()` (for top-level widgets). In some
    cases, `application.SetDefaultIcon()` may allow you to set the icon for all windows
    with a single call.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最有指导意义的窗口提示是在任务栏、应用程序切换器以及可能窗口边框中显示的图标。在某些系统中，默认图标是应用程序的图标，而在其他系统中则是特定于窗口的图像。通常，将相同图标设置在您的应用程序窗口和应用程序图标上是一个好主意，这可能由您使用的工具包处理。为窗口设置不同的图标应仅保留在窗口服务于与主窗口不同目的时。为了避免用户混淆，与主图标不同的窗口图标应通过样式或内容表明它们与哪个主图标相关。设置窗口图标通常是通过调用`window.SetIcon()`或`widget.SetWindowIcon()`（对于顶级小部件）来实现的。在某些情况下，`application.SetDefaultIcon()`可能允许您通过单个调用为所有窗口设置图标。
- en: Setting the application icon is platform-specific and is explored further in
    [Chapter 14](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml), *Distributing Your Application*.
    It's important to be aware that some systems allow custom icon themes to be loaded.
    In this case, a custom application or window icon may be less familiar to the
    user, so you may consider including some branding within the application itself.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 设置应用程序图标是平台特定的，并在[第14章](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml)，*分发您的应用程序*中进一步探讨。重要的是要意识到，一些系统允许加载自定义图标主题。在这种情况下，自定义应用程序或窗口图标可能对用户来说不太熟悉，因此您可能考虑在应用程序本身中包含一些品牌元素。
- en: Notifications and task status
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知和任务状态
- en: As we saw earlier, it's part of most toolkit APIs to provide easy ways to open
    dialog windows for displaying information, progress reports, and errors to gain
    a user's attention. However, with great power comes great responsibility; it's
    important to not interrupt the workflow unless it's really necessary. Think of
    the many File download complete! or Please wait for update to download... dialog
    windows you've had to wait for or dismiss and you'll be thinking in the right
    direction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，大多数工具包API提供方便的方式来打开对话框窗口，显示信息、进度报告和错误以吸引用户的注意。然而，权力越大，责任越大；除非真的有必要，否则不要打断工作流程。想想看，你不得不等待或关闭的许多“文件下载完成！”或“请等待下载更新...”对话框窗口，你就会明白正确的方向。
- en: So what's the solution? Let's look at how to present non-critical alerts or
    background progress to the user in a less obstructive manner.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，解决方案是什么？让我们看看如何以不太妨碍的方式向用户呈现非关键警报或后台进度。
- en: Minor alerts
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小型警报
- en: 'Many messages that should be presented to the user probably aren''t crucial
    and so should probably not interrupt their flow. The information may not be important
    enough to warrant displaying another window or it may be time-based, and so if
    the app isn''t active, it may no longer be relevant when they come back. A better
    approach to this sort of information is present in most operating systems: a notification
    area.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 应向用户呈现的许多消息可能并不重要，因此可能不需要中断他们的流程。信息可能不足以证明显示另一个窗口，或者可能是基于时间的，因此如果应用程序不活跃，当用户回来时可能就不再相关。大多数操作系统中的更好方法是通知区域。
- en: Initially presented as part of a system tray, notifications are displayed as
    a bubble or call-out area that can catch a user's attention if they're ready to
    be distracted or could be ignored otherwise. The more modern way for this to be
    presented is a notification area (which may not always be visible) in which all
    application notifications are placed. This provides a way to group all messages
    for later processing at a more convenient time. A preview is normally shown so
    it's a good idea to keep the message short.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最初作为系统托盘的一部分呈现，通知以气泡或呼出区域的形式显示，如果用户准备好分心，则可以吸引他们的注意力；否则，可以忽略。更现代的呈现方式是在通知区域（可能并不总是可见）中放置所有应用程序通知。这提供了一种方法，可以在更方便的时间对所有消息进行分组处理。通常显示预览，因此保持消息简短是一个好主意。
- en: 'Notifications can be created using built-in APIs for many of the frameworks
    we''ve discussed, such as `NewQSystemTrayIcon().ShowMessage()` in Qt or `NewNotifyIcon().ShowMessage()`
    in Walk. Using these functions will typically display the notification in the
    current platform''s default notification area, leading to a consistent user experience.
    This, however, means that even on GUI toolkits that aim to be completely consistent
    across multiple platforms, this code will behave differently, so be sure to test
    all supported platforms and bear the differences in mind when writing documentation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用我们讨论过的许多框架的内置API来创建通知，例如Qt中的`NewQSystemTrayIcon().ShowMessage()`或Walk中的`NewNotifyIcon().ShowMessage()`。使用这些函数通常会在当前平台的默认通知区域显示通知，从而提供一致的用户体验。然而，这意味着即使在旨在跨多个平台完全一致的用户界面工具包中，此代码的行为也可能不同，因此在编写文档时务必测试所有支持的平台，并牢记这些差异：
- en: '![](img/b883a70e-496d-4c19-8d77-76be65546bea.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b883a70e-496d-4c19-8d77-76be65546bea.png)'
- en: 'Notifications appear in the Action Center on Windows 10 (Image copyright: Microsoft)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通知出现在Windows 10的操作中心（图片版权：微软）
- en: Background progress
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景进度
- en: The progress dialog windows provided by Qt, Fyne, and others are ideal for showing
    the user how much longer they need to wait for a critical process to complete
    (such as opening a large file, buffering a movie, or loading the required data
    from a website). What they aren't suitable for is reporting the progress of a
    task that can run while the user continues their task in the application. For
    that purpose, we should consider displaying the information elsewhere on the application
    or screen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Qt、Fyne和其他提供的进度对话框窗口非常适合显示用户还需要等待多长时间才能完成关键过程（例如打开大文件、缓冲电影或从网站加载数据）。它们不适合报告用户在应用程序中继续任务时可以运行的任务的进度。为此，我们应该考虑在应用程序或屏幕的其他位置显示信息。
- en: Many systems are starting to add support for reporting task progress in a standard
    area, such as the notification space described earlier. Unfortunately, this isn't
    yet commonplace across enough operating systems for toolkits such as those we've
    explored to provide support; therefore, we must use another approach. There are
    two common strategies to communicating task progress for such background processes,
    and it probably depends on whether you expect multiple tasks to be running concurrently
    or not.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统开始添加在标准区域报告任务进度的支持，例如前面描述的通知空间。不幸的是，这还没有在足够的操作系统上普及，以至于我们探索的工具包可以提供支持；因此，我们必须使用另一种方法。对于此类后台进程，有两种常见的策略来传达任务进度，这可能取决于您是否期望同时运行多个任务。
- en: For applications where a single background task may run (such as an IDE running
    a build, or a to-do list synchronizing with its server), the traditional approach
    is to embed a progress bar in the application somewhere. This would be shown when
    the background task starts and then disappear once it's completed. Such visual
    queues are usually in a status bar or other information area where the user's
    eye typically travels when looking for ancillary information.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能运行单个后台任务的应用程序（例如运行构建的IDE或与服务器同步的任务列表），传统的做法是在应用程序的某个位置嵌入进度条。这将显示在后台任务开始时，并在完成后消失。这样的视觉提示通常位于状态栏或其他用户通常寻找辅助信息的信息区域。
- en: 'If your application is regularly going to have multiple background events running,
    such as file downloads or image conversions, it''s usual to see a new window or
    tool panel appear when tasks are running. This user interface addition would normally
    list all of the active tasks with their progress and hide them once complete.
    As these are non-critical to the current workflow, it''s important not to show
    the elements over the current work—indeed, some applications (such as Apple''s
    Safari web browser) don''t even show this window unless the user requests detailed
    information on the download progress:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序经常需要运行多个后台事件，例如文件下载或图像转换，那么在任务运行时通常会看到一个新窗口或工具面板出现。这个用户界面新增功能通常会列出所有正在进行的任务及其进度，并在完成后隐藏它们。由于这些对当前工作流程不是关键，因此很重要的一点是不要在当前工作之上显示这些元素——实际上，一些应用程序（如苹果的Safari网络浏览器）甚至不会显示此窗口，除非用户请求有关下载进度的详细信息：
- en: '![](img/4c7d61d7-e854-491e-8a69-8ab310c44123.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c7d61d7-e854-491e-8a69-8ab310c44123.png)'
- en: 'The download list in Safari isn''t visible by default but will provide details
    if requested (image copyright: Apple)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Safari中的下载列表默认情况下不可见，但如果请求将提供详细信息（图片版权：苹果）
- en: Platform-specific considerations
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台特定考虑事项
- en: Despite the broad similarities in how most widget toolkits work across the platforms
    they support, there are some differences in operating system behavior. Whether
    due to a desire to stand out against the competition or through a belief that
    their approach is a better user experience, these distinctions should be taken
    into consideration. In this section, we'll explore some significant differences
    in platform approaches.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数小部件工具包在它们支持的平台上工作方式相似，但在操作系统行为上仍有一些差异。这些差异可能是由于希望与竞争对手区分开来，或者认为他们的方法提供了更好的用户体验。这些区别应该被考虑进去。在本节中，我们将探讨平台方法中的一些显著差异。
- en: Window grouping
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口分组
- en: In the taskbar of Windows 10 and most versions of macOS, all of an application's
    windows are grouped under a single icon. This makes the user interface less cluttered,
    but it does mean that an application that opens many windows may be a little harder
    to navigate as there isn't a simple icon click to show a specific window. Add
    to this the behavior of macOS and Ubuntu Linux (or other distributions using the
    Gnome desktop) to group windows under a single icon in the task switcher (keyboard
    *Alt* + *Tab)* as well. With Gnome, you can explore the windows under an icon
    by pressing the down arrow key or using the mouse, but on macOS, you need to use
    an alternative keyboard combination (*Alt *+~) to cycle the windows of an application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 10的任务栏和大多数macOS版本中，一个应用程序的所有窗口都聚集在单个图标下。这使得用户界面不那么杂乱，但也意味着打开许多窗口的应用程序可能更难导航，因为没有简单的图标点击来显示特定窗口。再加上macOS和Ubuntu
    Linux（或使用Gnome桌面的其他发行版）在任务切换器中将窗口聚集在单个图标下的行为（键盘*Alt* + *Tab*）。在Gnome中，你可以通过按向下箭头键或使用鼠标来探索图标下的窗口，但在macOS上，你需要使用替代的键盘组合（*Alt*
    *+~）来循环应用程序的窗口。
- en: This trend to group windows may impact the design of applications that present
    multiple windows; if every time you launch the application, it opens three windows,
    then; after opening three documents, you could have nine windows open. The most
    common approach in this situation is to have supporting windows open just once,
    making their tools or information assume the context of the current document (probably
    the topmost window). However, this may add complexity to your application as it
    would need to communicate with other instances of the software that are already
    open.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将窗口分组的趋势可能会影响展示多个窗口的应用程序的设计；如果你每次启动应用程序时都打开三个窗口，那么；在打开三个文档之后，你可能会打开九个窗口。在这种情况下最常见的方法是只打开一次支持窗口，使它们的工具或信息假设当前文档的上下文（可能是最顶层的窗口）。然而，这可能会增加你应用程序的复杂性，因为它需要与其他已经打开的软件实例进行通信。
- en: Application instances
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序实例
- en: Although somewhat hidden in a modern task switcher, it can be noticed that some
    operating systems prefer to have just one instance of an application open rather
    than launching many (for example, one per document). When developing applications
    for macOS, it's encouraged to only have one copy running at any time-attempting
    to run a second instance of the same application will normally result in the original
    window being brought to the front. If your application is aiming to support platforms
    where the *concurrent instances* semantics are different, time should be spent
    deciding how your application should behave. Will your design work the same way
    on all platforms or adapt to the current environment?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在现代任务切换器中有些隐藏，但可以注意到一些操作系统更倾向于只打开一个应用程序实例，而不是打开多个（例如，每个文档一个）。在为macOS开发应用程序时，建议在任何时候只运行一个副本-尝试运行同一应用程序的第二个实例通常会导致原始窗口被带到前台。如果你的应用程序旨在支持*并发实例*语义不同的平台，应该花时间决定你的应用程序应该如何表现。你的设计是否会在所有平台上以相同的方式工作，还是适应当前的环境？
- en: To change behavior according to platform, it's possible to detect the operating
    system at runtime, but normally the operating system is the defining factor, and
    so you can make use of Go's built in build tags discussed in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go
    to the Rescue!*. For example, we could have two different files that control how
    an application is opened: `launch_darwin.go` will be used when compiling for macOS
    and `launch_other.go` will run on other platforms. An example of setting this
    up may go as follows.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据平台更改行为，可以在运行时检测操作系统，但通常操作系统是决定性因素，因此您可以使用在第 3 章中讨论的 Go 内置构建标签，*Go to the
    Rescue!*。例如，我们可以有两个不同的文件来控制应用程序的打开方式：`launch_darwin.go` 将在为 macOS 编译时使用，而 `launch_other.go`
    将在其他平台上运行。设置此示例可能如下所示。
- en: 'Firstly, we create a file that handles the standard mechanism (called `launch_other.go`); 
    opening a file or a new document will create a window with an appropriate document
    and show it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个处理标准机制（称为 `launch_other.go`）的文件；打开文件或新文档将创建一个带有适当文档的窗口并显示它：
- en: '[PRE0]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we make a version for macOS (named `launch_darwin.go`), which first checks
    for a running instance. If one is found, we call some **RPC** (**remote proceedure
    call**) functions to open files in the running application, otherwise we load
    the window as before:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为 macOS 创建一个版本（命名为 `launch_darwin.go`），它首先检查是否有正在运行的实例。如果找到，我们将调用一些 **RPC**（**远程过程调用**）函数在运行的应用程序中打开文件，否则我们像以前一样加载窗口：
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The main function of the app that launches this will probably be to parse the
    command-line parameters to determine whether a filename has been passed, such
    as the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 启动此应用程序的主函数可能主要是解析命令行参数以确定是否传递了文件名，如下所示：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The details of `getFirstInstance()` and the RPC code are out of scope for this
    chapter but can be found in the `chapter11/singleapp` folder in this book's code
    repository. This model may be supported by some toolkits, but there are also projects
    that aim to make this easier, such as [https://github.com/marcsauter/single](https://github.com/marcsauter/single).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFirstInstance()` 和 RPC 代码的详细信息超出了本章的范围，但可以在本书的代码仓库中的 `chapter11/singleapp`
    文件夹中找到。这种模型可能被某些工具包支持，但也有项目旨在使其更容易，例如 [https://github.com/marcsauter/single](https://github.com/marcsauter/single)。'
- en: Extra features
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外功能
- en: In some cases, it isn't possible to find equivalent behavior or user interface
    elements on every platform your application or toolkit supports. In these cases,
    you may find the toolkit providing operating system-specific extensions that can
    be used in your application code. If you make use of these platform-specific items,
    you'll need to ensure that your code still functions correctly on other target
    systems. This would normally be handled by the build constraints such as the preceding,
    where some implementations may have no or reduced functionality to match the lowest
    common denominator.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能无法在您的应用程序或工具包支持的所有平台上找到等效的行为或用户界面元素。在这些情况下，您可能会发现工具包提供了特定于操作系统的扩展，这些扩展可以在您的应用程序代码中使用。如果您使用这些特定平台的项，您需要确保您的代码在其他目标系统上仍然能够正确运行。这通常由构建约束来处理，如前面的示例，其中某些实现可能没有或减少了功能以匹配最低的共同基数。
- en: Such a platform extension is Qt Windows Extras, which provides the taskbar icon
    progress API and a method for providing a *jump list* (a set of shortcuts from
    the application icon). This project can be found at [http://doc.qt.io/qt-5/qtwinextras-index.html](http://doc.qt.io/qt-5/qtwinextras-index.html).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的平台扩展是 Qt Windows Extras，它提供了任务栏图标进度 API 和提供 *跳转列表*（来自应用程序图标的快捷方式集）的方法。该项目可以在
    [http://doc.qt.io/qt-5/qtwinextras-index.html](http://doc.qt.io/qt-5/qtwinextras-index.html)
    找到。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored techniques for designing and programming more complex
    graphical applications. While looking at principles for complex layouts and deep
    navigation structures, we compared how common applications deal with these challenges
    and noted the types of complex user interfaces to avoid. To provide a richer,
    consistent user experience in these applications, we investigated the APIs that
    provide standard dialog windows and allow developers to configure application
    windows to be consistent with the application workflow.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了设计和编程更复杂图形应用程序的技术。在查看复杂布局和深层导航结构的原则时，我们比较了常见应用程序如何处理这些挑战，并注意到了要避免的复杂用户界面类型。为了在这些应用程序中提供更丰富、一致的用户体验，我们研究了提供标准对话框窗口并允许开发者配置应用程序窗口以与应用程序工作流程保持一致的
    API。
- en: Background task progress and system notifications should be visible but not
    interrupt the user's workflow. We explored how to use toolkit widgets and common
    techniques to provide this balanced communication. To further integrate with the
    current operating system, we explored the differences between, and additional
    features provided by, desktop platforms so that applications can match system
    semantics while maintaining a single code base for cross-platform development.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 后台任务进度和系统通知应该是可见的，但不能打断用户的操作流程。我们探讨了如何使用工具包小部件和常见技术来提供这种平衡的通信。为了进一步与当前操作系统集成，我们探讨了桌面平台之间的差异以及它们提供的附加功能，以便应用程序可以在保持单一代码库的同时进行跨平台开发。
- en: In the next chapter, we'll turn our attention to the background operations and
    networking features provided by Go and how to use them effectively in graphical
    application. We'll return to our GoMail examples and extend them using cloud services
    for a richer user experience.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注Go提供的后台操作和网络功能，以及如何在图形应用程序中有效地使用它们。我们将回到我们的GoMail示例，并利用云服务来扩展它们，以提供更丰富的用户体验。
