- en: Navigation and Multiple Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through the last seven chapters, we've explored how to build a fairly simple
    graphical user interface using different toolkits and technologies. In each example,
    we saw benefits to the widget and API design but also challenges that are often
    faced when picking a toolkit. In this chapter, we're shifting focus to the planning
    and implementation of a more complex GUI—the sorts of challenges that will be
    encountered irrespective of the toolkit and technology selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning the workflow of a more complex GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Window management and notifications for a clean user experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system-specific details and how to adapt a cross-platform application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you'll have examined the bigger picture questions
    of application flow and navigation in a more complex graphical application. You'll
    have thought about how your GUI will fit within the current platform's flow and
    how to notify or engage the user as appropriate. So, let's get started by looking
    at the navigation of a complex application.
  prefs: []
  type: TYPE_NORMAL
- en: Planning application layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning a large graphical application can seem like a daunting task, if you're
    thinking about all of the different users of your software and the varied devices
    it'll be used on. Or, it may seem quite straightforward if your ambitions can
    be realized by using standard design applications (such as Qt Creator or Glade
    for GTK+) that can generate code from a drag-and-drop interface. Unsurprisingly,
    creating a great user experience for your application interface will probably
    take a while to explore, plan, and design for the best result. The largest complexity
    is likely the navigation or overall layout of the application—we'll look first
    at layout techniques across multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Standard layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the toolkits we've explored provide standard layout components that
    help to organize widgets and interface elements in neat, standardized arrangements.
    When you think about the naming of these layouts, however (for example, VBox,
    Border, and Frame), they typically describe fine-grained control rather than higher-level
    design concepts. For this section, we need to step back a little and think about
    the overall flow of an application, what will be the most used parts of the application,
    and what should the user see when they first load the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml), *Graphical
    User Interface Challenges*, desktop applications have been  standardized around
    a fairly common layout: menu, toolbar, palettes, and content. As applications
    have grown more complicated, there have been attempts to fit more functions and
    features into this space to allow users to gain access to the full feature set
    of these increasingly powerful applications. Since the rise in popularity of smart
    phones and mobile applications, there has been a lot of discussion about better
    use of screen real estate and how to make a great user experience with limited
    resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Research into the use of screens, readability of content, and related topics
    is now commonplace in relation to web design as well. Topics such as *How eye
    scanning impacts visual hierarchy in UX design* are often seen on recommended
    reading lists for those looking to improve their site's usability or user retention.
    With this in mind, we, as desktop or cross-platform application creators, should
    probably be thinking much more carefully about how our software is presented and
    whether the traditional methods fit with our specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some GUI toolkits are beginning to provide higher-level layouts that reflect
    intention rather than a static visual layout. For example, `UISplitViewController` in
    Apple''s iOS presents a list view and detail view side by side when space is available
    or one view at a time (the detail view slides on when the list is tapped) when
    screens are smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0152c420-9201-4487-b56d-ada73f0cfc6f.png)'
  prefs: []
  type: TYPE_IMG
- en: An iOS split pane used for iPad settings app
  prefs: []
  type: TYPE_NORMAL
- en: '(Image copyright: Apple)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2a775b7-e9f1-40d0-8eaa-d29d89afcd03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same split pane on an iPhone
  prefs: []
  type: TYPE_NORMAL
- en: '(Image copyright: Apple)'
  prefs: []
  type: TYPE_NORMAL
- en: Where possible, these should be used in your application so your interface is
    configured appropriately for the current device, but there may be further customization
    needed. Let's look at some of the factors that impact more complex layout design.
  prefs: []
  type: TYPE_NORMAL
- en: Device form factors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While primarily a consideration for mobile and modern portable devices, an application
    layout should be designed with the physical design of the device in mind. Visual
    and interaction technologies on the desktop have remained largely consistent for
    25 years, leading to standardized interface designs—but this too is changing.
    Computers are now more commonly shipping with ultra high definition screens, many
    of which are also touch surfaces. If your approach to cross-platform application
    development is to also include mobile devices, you will need to consider the small
    screen sizes as well as orientation of the device.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the screen isn't the only factor to consider; it's now also common
    for input devices to vary. A mouse and keyboard is probably the main configuration
    for user input but many portable computers now have a *tablet mode* where touch
    input is a replacement for the mouse and a virtual keyboard can appear for text
    input. If this is a configuration you want to support, then your layout will need
    to work when parts of the screen (probably the bottom edge) is covered with the
    virtual keyboard. More importantly, finger-based input (most commonly called *multi-touch*)
    is far richer than a point and click approach; will your application aim to support
    *pinch to zoom* or *touch rotation*? If you intend to support these sorts of features,
    then make sure your chosen framework supports *input gestures*. Each toolkit is
    evolving rapidly and so the details have been omitted from this book as it would
    be out of date by publication.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the full device capabilities, a traditional desktop application
    can be moved around and made different sizes or orientations by many user actions—should
    your design aim to accommodate these changes in configuration? When displaying
    applications side by side on a tablet device, you'll see how powerful the different
    layouts can be when implemented correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive or adaptive design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to suit a wide variety of devices, it normally won''t be possible
    to use a single user interface design. Therefore, some form of adaptation to the
    current environment will probably be necessary. There are two main schools of
    thought with regard to adapting to variations in screen and device capability:
    responsive and adaptive designs. Both aim to provide an appropriate user experience
    with an interface that feels native to the current device. While these principles
    currently refer mostly to web application design, they can also be applied to
    native applications, especially if designing for multiple platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: When following adaptive principles, application designers will choose a limited
    set of device configurations to design for, typically a mobile device (possibly
    in multiple orientations), a tablet device, and a regular desktop. By designing
    for these categories, the amount of time spent designing for specific devices
    is reduced, focusing only on these defined configurations. When focusing on a
    small number of variations, the design can be perfected for these different use
    cases, creating a very smooth experience. When implemented this way, an application
    will detect which category of device it's running on and load the appropriate
    layout (sometimes this is handled automatically by the framework). This approach
    has been exemplified by Apple's iOS SDK (user interfaces are defined for iPhone,
    iPhone Plus, and iPad), the correct user interface will be loaded and a single
    application can execute with any configuration. The limitation of the adaptive
    approach is that *intermediate* devices, ones that are smaller or larger than
    expected (or with unusual configurations), will probably not look or function
    as the user may expect.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive design, on the other hand, aims to define a single user interface
    that responds to the current device configuration. Layouts created in this manner
    will typically have certain trigger values or inflection points that determine
    the visibility of elements or the positioning and sizing of items that should
    always be shown (in CSS, this is usually done with *media queries*). The responsive
    technique is becoming more popular in designing websites that wish to provide
    a good experience on a huge range of different devices; it probably won't provide
    the perfect user interface that adaptive design aims for, but it does cater for
    every device from the smallest, least capable to the full desktop experience.
    This approach maps well to the cross-platform approach that's likely part of the
    intention of a team developing application GUIs with Go because we don't usually
    know the devices that our software will be run on ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolkits explored in this book offer some amount of support for responsive
    layouts. Grids that lay out the content according to the space available and the
    screen layout are a good place to start. Some are pushing further into this space
    by providing semantic layouts that''ll adapt correctly to the current device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fbcb119-1372-4675-b596-4e429bb620fc.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of a possible responsive layout at three different sizes
  prefs: []
  type: TYPE_NORMAL
- en: Custom layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's likely that your application has requirements that are different to standard
    layouts or more complicated than the toolkit's API supports. Using standard layouts
    where possible is recommended but that doesn't have to mean giving up on your
    ideal application design. Every toolkit supports custom layouts in some manner
    that you can make use of to fill the gaps in the available standard layouts. When
    implementing a custom layout in this manner, the basic approach is to set a fixed
    position for each component within the parent container. To better adapt to the
    available screen space, remember to factor in the current width and height of
    the interface; it's often easier to implement using ratios or percentages rather
    than absolute values (for example, a list component is 25% of the screen width
    or content columns are 1/3 of the available space).
  prefs: []
  type: TYPE_NORMAL
- en: 'In more advanced toolkits, there''s also a *constraints-based* layout available,
    one that lays out components based on configured equations instead of hardcode
    values. The standard algorithm for constraints layouts is named Cassowary and
    is fully documented at [http://overconstrained.io/](http://overconstrained.io/).
    The basic principle is that each layout value can be defined as the result of
    an equation in the form `item1.attr1 = item2.attr2 × multiplier + constant` (such
    as `button.top = content.bottom × 1.0 + 25`). Constraints-based layouts (also
    known as **auto layouts**) are standard in iOS and Android but not so common in
    desktop toolkits. Modern GUIs often include this functionality as standard but
    using this functionality in others such as Qt and GTK will require the integration
    of third-party projects (as these aren''t currently available through Go bindings,
    the integration is out of scope for this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cc931b4-d7e1-4cf5-b684-cf8a94a7ef64.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding constraints to a label with Xcode (image copyright: Big Nerd Ranch, LLC)
  prefs: []
  type: TYPE_NORMAL
- en: Navigating your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consistent and easy-to-follow navigation through a complex application is hard
    to attain but doing it well can lead to dramatically improved user experience.
    A typical application has a core set of functionality—which should always be easy
    to access—and a larger set of additional tools and helpful features that are used
    less frequently. Keeping the balance between core features and additional functionality
    is something that many applications haven''t yet solved. Overcrowded toolbars
    and very long menus are problems we encounter on a regular basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1b58816-896a-4fec-8621-ad2a566718a2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Menus, toolbars, shortcuts, and drop-down lists all above a document in Microsoft
    Office 2007
  prefs: []
  type: TYPE_NORMAL
- en: Finding ways to limit the various options onscreen should lead to less user
    confusion. It's the responsibility of an application designer to make a clear
    and easy-to-use interface, not to present all of the options and expect users
    to learn how to navigate. There are various methods for adjusting a user interface
    to focus on the essential or most useful features; we'll explore them in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive disclosure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In larger applications (as previously illustrated), it's likely that the number
    of features available can't easily be presented in a minimal user interface. When
    that's the case, application designers will have a new challenge in creating a
    smooth learning curve for new users. How can an application's user interface be
    designed both for a complex feature set and to be easy to learn by people who
    are new to the product?
  prefs: []
  type: TYPE_NORMAL
- en: Progressive disclosure is a technique for helping to focus a user's attention
    and facilitate learning a complex system. This is achieved by hiding functionality
    or data that isn't necessary to support the task at hand. Commonly, this is implemented
    by starting with a basic set of functionality visible and expanding as the user
    explores areas beyond the basics. Triggers to expand the functionality available
    may be accessing a new menu item, an Advanced button, or simply using the application
    for a certain time or adding sufficient data.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – Microsoft Edge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A standard feature of popular web browsers is the developer tools that they
    include—but this isn't core functionality. When building their new web browser,
    Edge, Microsoft decided to focus on the core features, hiding more advanced functionality,
    such as developer tools, from the average user.
  prefs: []
  type: TYPE_NORMAL
- en: 'If enabled through a single menu item (the ... menu, then F12 Developer Tools)
    or the *F12* keyboard shortcut, the developer features are switched on. From then
    on, the browser will present developer features in all of the expected places,
    creating a much richer application feature set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/423fbed2-8a2e-45cd-b959-447774d8fc2e.png)'
  prefs: []
  type: TYPE_IMG
- en: The default Edge context menu
  prefs: []
  type: TYPE_NORMAL
- en: 'F12 or Developer Tools menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca583515-75b8-49f5-8d7e-b91152f9e143.png)'
  prefs: []
  type: TYPE_IMG
- en: After developer tools are enabled
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – Skyscanner flight search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main functionality of the Skyscanner service ([https://www.skyscanner.net/](https://www.skyscanner.net/))
    is to search through the many flights available, matching a certain criteria based
    on price, time, location, and so forth. After finding a suitable journey in the
    (initially minimal looking) mobile app, a user would normally go through a booking
    process to purchase their flights.
  prefs: []
  type: TYPE_NORMAL
- en: If they aren't ready to make the purchase, a user of the application can *favorite* a
    flight combination for later. Upon doing this, a menu will appear in the application
    from which favorite searches can be returned to. If these searches are visited
    many times, then another new feature called *watched flights* appears, which allows
    more advanced holiday planners to monitor the varying prices of their searches.
  prefs: []
  type: TYPE_NORMAL
- en: Menus and toolbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When there are many items that you wish to provide to users of your application,
    a menu or toolbar are convenient options, but should be used carefully and sparingly.
    Too many options added to a toolbar can add to the cluttered *ribbon* user interface
    from Microsoft Office, as previously displayed. Likewise, adding a menu item for
    every feature will probably lead to cognitive overload as users spend too much
    time trying to find an item or remember where it's located.
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A toolbar is ideally suited for actions that'll be used on a regular basis.
    For example, in our email application Reply will be a popular action, as will
    New and Delete. Grouping toolbar items together by similarity (for example, Reply
    and Reply All or Cut, Copy, and Paste) will help users to find your shortcuts
    quickly. Ordering these groups by likelihood of use will mean that, if the user
    interface is smaller than expected, then the most useful features will still be
    visible. To provide access to tools that don't fit onto the screen, you can use
    an overflow item (where it pops out a list of not-visible items), make the tool
    bar scrollable, or provide access in a different place, such as a menu or second
    row.
  prefs: []
  type: TYPE_NORMAL
- en: Toolbars are popular in most form factors of devices, from small phones up to
    large desktop applications. The main difference is clearly the number of items
    that can be included. If you're including toolbars in a responsive or adaptive
    layout, you may consider a more complex strategy than leftmost-visible. For example,
    in an email application, if only five items can be displayed, then removing Reply
    All so Delete can be seen might be a good approach; the user could always choose
    to reply to all in the compose window after pressing Reply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many applications choose to allow items in the toolbar to be rearranged, a
    feature that''s provided by some graphical toolkits (for example, UIKit for Apple''s
    iOS devices and AppKit for their desktop applications):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80718ee3-df87-412a-bdcf-c07842aa8917.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A sample user interface for customizing toolbars in macOS (image copyright:
    Apple)'
  prefs: []
  type: TYPE_NORMAL
- en: Menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Menu bars have traditionally been thought of as the right location to place
    all otherwise absent feature access in an application. With a long list of items
    in a growing number of menu headings, an application menu can quickly become hard
    to navigate. This is generally considered to be due to the number of items that
    an average human can hold in their short-term memory. Experiments by George Miller
    in 1956 suggested that the number of objects that can typically be held in working
    memory is between five and nine (seven plus or minus two—Miller's "Magical Number").
    More recent estimates have shown that this number is typically lower, closer to
    just four or five items.
  prefs: []
  type: TYPE_NORMAL
- en: Taking this into consideration, we can understand why it's important to keep
    menus fewer and shorter—at every step of navigating, there should be no more than
    nine options available—and far less, if possible.
  prefs: []
  type: TYPE_NORMAL
- en: The presentation of a menu varies from one platform to another with the standard
    top of the window or top of the screen being most common on the desktop, and an
    icon at the top-left of the screen (known as the hamburger) most prevalent on
    mobile layouts. What you'll notice, regardless of the layout, is that the top-level
    list will be around five items and, if further options are required, the menus
    that cascade down won't be much longer than that. If you find your menus becoming
    overwhelmingly long, perhaps consider task-specific toolbars or other grouping
    of context-relevant shortcuts, possibly opened from a single menu item.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever design you choose for making features available, please remember the
    user's main focus or the current context.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t want to end up overwhelming them to the point that there''s significant
    thinking required at every step of the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fac0744-14e6-442b-9095-b10cc6cf2527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Visual Studio with all of its viewers and toolbars switched on (copyright Dylan
    Beattie)
  prefs: []
  type: TYPE_NORMAL
- en: Multiple windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more approach that can help your application to be easier to navigate is
    to split the content into multiple windows. Each will be a different view of your
    application, within which the appropriate toolbars or menus can be presented for
    the current context. As shown in our GoMail examples, we compose new messages
    in a separate window; this allows us to group editing-related items close to the
    input fields and allows us to simultaneously be drafting multiple messages without
    cluttering our email browse window.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, multiple windows won't necessarily have the same semantics on different
    platforms. If we were to take the same approach on a smart phone device, it would
    be common for the compose window to be presented as an overlay to the existing
    application. Whether the user can switch between that mode and the browse window
    may be down to the operating system's design or we may decide that, when running
    on a smaller device, the compose window should be a *modal* window (that is, it
    blocks access to the parent window. This is discussed further later).
  prefs: []
  type: TYPE_NORMAL
- en: Yet another approach that we saw in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml), *Graphical
    User Interface Challenges*, was to have multiple windows for the main focus of
    the applications. These peripheral windows are typically for toolbars or detailed
    information/control of the content in the main window and can be particularly
    helpful in content creation-based applications. With the content expanding to
    fill the whole of the main window, the toolbars and context actions have been
    placed in separate windows to keep the user focused. This type of layout and navigation
    is usually adopted in *pro* applications where the user knows the domain well.
    The added complexity of this approach can lead to confusion for early users of
    a product and so we, as application designers and developers, should be mindful
    of the number of windows or different layouts and contexts we present in our user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Window types and keeping things clean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing multiple windows will become essential for any application, either
    through part of a layout design like the preceding, or for presenting important
    information to the user to gain their attention or receive their input. For each
    window that's displayed in your application, it's important to know whether its
    appearance should attract their immediate attention, support what's already onscreen,
    or simply be something that can be attended to later. Knowing the intention of
    each window shown will help to support, rather than impede, the user workflow
    and keep your application's user experience clean.
  prefs: []
  type: TYPE_NORMAL
- en: Standard dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common reason to show an additional window during application flow
    is to ask the user for additional input or confirmation, or to alert them of (typically
    unexpected) events. These are standard interactions and so it's usually most effective
    to use, where possible, the provided dialog windows defined by the toolkit being
    used. Using the provided APIs will generally provide the most consistent user
    experience and will almost certainly lead to less code in your application as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of standard dialogs provided by a toolkit will normally include file
    handling (open and save), progress (when the user must wait), message (to show
    warnings or errors), and a confirmation dialog (to ask an immediate question).
    On more advanced toolkits, you can also expect to find dialog APIs to help with
    color selection, font selection, document printing, and even a standardized About
    window. The following APIs are great places to get started with some of the toolkits
    we covered earlier in this book (with namespace included if it''s not the default):'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **walk** | **andlabs UI** | **GoGTK** | **qt** | **Fyne** |'
  prefs: []
  type: TYPE_TB
- en: '| **open** | `ShowOpen` | `OpenFile` | `NewFileChooserDialog` | `widgets.NewQFileDialog`
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| **save** | `ShowSave` | `SaveFile` | `NewFileChooserDialog` | `widgets.NewQFileDialog`
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| **progress** |  |  |  | `widgets.NewQProgressDialog` | `dialog.NewProgress`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **message** |  | `MsgBox``MsgBoxError` | `NewMessageDialog` | `widgets.NewQMessageBox``widgets.NewErrorMessage`
    | `dialog.ShowInformation``dialog.ShowError` |'
  prefs: []
  type: TYPE_TB
- en: '| **confirm** |  |  |  | `widgets.NewQMessageBox` | `dialog.ShowConfirmation`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **input** |  |  |  | `widgets.NewQInputDialog` |  |'
  prefs: []
  type: TYPE_TB
- en: '| **color** |  |  |  | `widgets.NewQColorDialog` |  |'
  prefs: []
  type: TYPE_TB
- en: '| **font** |  |  | `FontSelection` | `widgets.NewQFontDialog` |  |'
  prefs: []
  type: TYPE_TB
- en: '| **print** |  |  |  | `printsupport.NewQPrintDialog` |  |'
  prefs: []
  type: TYPE_TB
- en: '| **about** |  |  | `NewAboutDialog` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **custom** | `NewDialog` |  | `NewDialog` | `widgets.NewQDialog` | `dialog.ShowCustom`
    |'
  prefs: []
  type: TYPE_TB
- en: It's often useful to show a small selection or confirmation window that isn't
    in the preceding list (either because your requirements are different or the toolkit
    hasn't implemented that feature). This can be achieved by creating a new window,
    packing the content, and showing it, but the recommended method is to use the
    custom dialog API instead. Showing a dialog instead of a standard window allows
    the toolkit to configure the window to best effect. This typically involves setting
    it to be a non-resizable, topmost window that's *modal* (meaning the user can't
    interact with the window underneath until the dialog is dismissed).
  prefs: []
  type: TYPE_NORMAL
- en: Modal windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As suggested previously, a modal window is one that blocks user input to the
    window that it's above. This typically means it's placed in the center of a parent
    window and the window below will be disabled or grayed out, focusing the user
    interaction on the new dialog window. This is typical of dialog windows as they're
    designed to appear only when the user can't continue with the current task until
    the information, confirmation, or progress is completed (at which point the dialog
    disappears and control returns).
  prefs: []
  type: TYPE_NORMAL
- en: To function in this way, a modal window is usually passed the parent window
    that it should occlude. The input will be forced to the new modal window (depending
    on the desktop environment and configuration, this may not be the case if the
    parent window isn't currently the topmost application) to interact with the new
    interface. Different platforms can present modal windows using various styles;
    some will look like a regular window (often with maximize and minimize buttons
    disabled), others will present the content embedded within the current window,
    and others (such as macOS) can present them appearing from the title bar of the
    parent window. Using the built-in API for custom dialogs will mean that these
    visual styles are consistent within your application.
  prefs: []
  type: TYPE_NORMAL
- en: There may be a reason, however, that your application requires a new window
    to take focus in a different type of workflow. For these cases, a toolkit often
    allows the *modality* of a window to be set directly. This can be a powerful feature
    but be sure to consider whether there isn't a better API to manage this flow,
    or whether a custom dialog window may be a better fit.
  prefs: []
  type: TYPE_NORMAL
- en: Window hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The properties of a window (referred to as *hints* on many systems) allow an
    application to indicate certain desired attributes to the operating system that'll
    control how a window is presented. For various reasons (including user experience
    and even security), an application can't mandate how and when a window will be
    presented in most situations; therefore, it's important to remember that these
    hints may not be enforced.
  prefs: []
  type: TYPE_NORMAL
- en: Sizes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common hints set are related to size—the minimum and possibly maximum
    size that your user interface should occupy. Minimum size is almost universally
    supported; every graphical system will try to allow an application to use as much
    space as it claims to need. Be sure to have sensible sizes though as, especially
    when targeting multiple different platform types, the minimum size shouldn't be
    bigger than the screen available! To avoid this situation, the operating system
    will probably show your application windows smaller than requested so that the
    user doesn't have the problem of accessing portions of the user interface that
    are off-screen. For this reason alone, it's recommended that the minimum size
    set is truly the smallest size that your GUI will operate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: So that an application is proportioned correctly when first loaded, it's common
    to set a default or preferred size (typically through `SetDefaultSize()`, `SetSize()`,
    or `Resize()`). This means that, as much as possible, your application will load
    at a sensible size, but smaller if the screen isn't large enough. In the example
    of our *New GoMail* email compose window, we can set a good default for typing
    a large email while having a sensible minimum size (probably calculated by the
    toolkit) that allows access to all of the input fields.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it may be helpful to set a maximum size for your window; while
    not used as often as minimum or default sized, this can be helpful. Most commonly,
    this is helpful if you want your window to remain small (such as a toolbox or
    information window) or expand only in one direction (to allow only height adjustments,
    or set the minimum and maximum width to the same value). It's also helpful in
    presenting custom dialog boxes to set the minimum and maximum size to the same
    value, hence requesting that the window be a fixed size. Some toolkits make this
    easier by providing a `SetFixedSize()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Other hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other types of properties or hints that can be set on windows
    to help guide users through an application. Depending on the toolkit, it may be
    possible to set the window type. This is usually handled automatically when displaying
    a dialog window (as they can have special properties) but may not be handled for
    other types of window creation. Check out the window API in your chosen toolkit
    to see whether you can set the type of window when doing things such as creating
    a toolbox window or information panel that should belong to a parent window somehow.
  prefs: []
  type: TYPE_NORMAL
- en: The most instructive window hint is the icon that's displayed in places such
    as the task bar, application switcher, and possibly the window border. On some
    systems, the default icon is that of the application, and in others it's a window
    specific image. Generally, it's a good idea to set the same icon on your application
    windows and application icon, which may be handled by the toolkit you're using.
    Setting a different icon for a window should be reserved for times when the window
    serves a different purpose to the main window. To avoid user confusion, window
    icons that differ from the main one should indicate through style or content which
    main icon they relate to. Setting a window icon is usually achieved by calling
    `window.SetIcon()` or `widget.SetWindowIcon()` (for top-level widgets). In some
    cases, `application.SetDefaultIcon()` may allow you to set the icon for all windows
    with a single call.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the application icon is platform-specific and is explored further in
    [Chapter 14](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml), *Distributing Your Application*.
    It's important to be aware that some systems allow custom icon themes to be loaded.
    In this case, a custom application or window icon may be less familiar to the
    user, so you may consider including some branding within the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: Notifications and task status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw earlier, it's part of most toolkit APIs to provide easy ways to open
    dialog windows for displaying information, progress reports, and errors to gain
    a user's attention. However, with great power comes great responsibility; it's
    important to not interrupt the workflow unless it's really necessary. Think of
    the many File download complete! or Please wait for update to download... dialog
    windows you've had to wait for or dismiss and you'll be thinking in the right
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: So what's the solution? Let's look at how to present non-critical alerts or
    background progress to the user in a less obstructive manner.
  prefs: []
  type: TYPE_NORMAL
- en: Minor alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many messages that should be presented to the user probably aren''t crucial
    and so should probably not interrupt their flow. The information may not be important
    enough to warrant displaying another window or it may be time-based, and so if
    the app isn''t active, it may no longer be relevant when they come back. A better
    approach to this sort of information is present in most operating systems: a notification
    area.'
  prefs: []
  type: TYPE_NORMAL
- en: Initially presented as part of a system tray, notifications are displayed as
    a bubble or call-out area that can catch a user's attention if they're ready to
    be distracted or could be ignored otherwise. The more modern way for this to be
    presented is a notification area (which may not always be visible) in which all
    application notifications are placed. This provides a way to group all messages
    for later processing at a more convenient time. A preview is normally shown so
    it's a good idea to keep the message short.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notifications can be created using built-in APIs for many of the frameworks
    we''ve discussed, such as `NewQSystemTrayIcon().ShowMessage()` in Qt or `NewNotifyIcon().ShowMessage()`
    in Walk. Using these functions will typically display the notification in the
    current platform''s default notification area, leading to a consistent user experience.
    This, however, means that even on GUI toolkits that aim to be completely consistent
    across multiple platforms, this code will behave differently, so be sure to test
    all supported platforms and bear the differences in mind when writing documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b883a70e-496d-4c19-8d77-76be65546bea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notifications appear in the Action Center on Windows 10 (Image copyright: Microsoft)'
  prefs: []
  type: TYPE_NORMAL
- en: Background progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The progress dialog windows provided by Qt, Fyne, and others are ideal for showing
    the user how much longer they need to wait for a critical process to complete
    (such as opening a large file, buffering a movie, or loading the required data
    from a website). What they aren't suitable for is reporting the progress of a
    task that can run while the user continues their task in the application. For
    that purpose, we should consider displaying the information elsewhere on the application
    or screen.
  prefs: []
  type: TYPE_NORMAL
- en: Many systems are starting to add support for reporting task progress in a standard
    area, such as the notification space described earlier. Unfortunately, this isn't
    yet commonplace across enough operating systems for toolkits such as those we've
    explored to provide support; therefore, we must use another approach. There are
    two common strategies to communicating task progress for such background processes,
    and it probably depends on whether you expect multiple tasks to be running concurrently
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: For applications where a single background task may run (such as an IDE running
    a build, or a to-do list synchronizing with its server), the traditional approach
    is to embed a progress bar in the application somewhere. This would be shown when
    the background task starts and then disappear once it's completed. Such visual
    queues are usually in a status bar or other information area where the user's
    eye typically travels when looking for ancillary information.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your application is regularly going to have multiple background events running,
    such as file downloads or image conversions, it''s usual to see a new window or
    tool panel appear when tasks are running. This user interface addition would normally
    list all of the active tasks with their progress and hide them once complete.
    As these are non-critical to the current workflow, it''s important not to show
    the elements over the current work—indeed, some applications (such as Apple''s
    Safari web browser) don''t even show this window unless the user requests detailed
    information on the download progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c7d61d7-e854-491e-8a69-8ab310c44123.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The download list in Safari isn''t visible by default but will provide details
    if requested (image copyright: Apple)'
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite the broad similarities in how most widget toolkits work across the platforms
    they support, there are some differences in operating system behavior. Whether
    due to a desire to stand out against the competition or through a belief that
    their approach is a better user experience, these distinctions should be taken
    into consideration. In this section, we'll explore some significant differences
    in platform approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Window grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the taskbar of Windows 10 and most versions of macOS, all of an application's
    windows are grouped under a single icon. This makes the user interface less cluttered,
    but it does mean that an application that opens many windows may be a little harder
    to navigate as there isn't a simple icon click to show a specific window. Add
    to this the behavior of macOS and Ubuntu Linux (or other distributions using the
    Gnome desktop) to group windows under a single icon in the task switcher (keyboard
    *Alt* + *Tab)* as well. With Gnome, you can explore the windows under an icon
    by pressing the down arrow key or using the mouse, but on macOS, you need to use
    an alternative keyboard combination (*Alt *+~) to cycle the windows of an application.
  prefs: []
  type: TYPE_NORMAL
- en: This trend to group windows may impact the design of applications that present
    multiple windows; if every time you launch the application, it opens three windows,
    then; after opening three documents, you could have nine windows open. The most
    common approach in this situation is to have supporting windows open just once,
    making their tools or information assume the context of the current document (probably
    the topmost window). However, this may add complexity to your application as it
    would need to communicate with other instances of the software that are already
    open.
  prefs: []
  type: TYPE_NORMAL
- en: Application instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although somewhat hidden in a modern task switcher, it can be noticed that some
    operating systems prefer to have just one instance of an application open rather
    than launching many (for example, one per document). When developing applications
    for macOS, it's encouraged to only have one copy running at any time-attempting
    to run a second instance of the same application will normally result in the original
    window being brought to the front. If your application is aiming to support platforms
    where the *concurrent instances* semantics are different, time should be spent
    deciding how your application should behave. Will your design work the same way
    on all platforms or adapt to the current environment?
  prefs: []
  type: TYPE_NORMAL
- en: To change behavior according to platform, it's possible to detect the operating
    system at runtime, but normally the operating system is the defining factor, and
    so you can make use of Go's built in build tags discussed in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go
    to the Rescue!*. For example, we could have two different files that control how
    an application is opened: `launch_darwin.go` will be used when compiling for macOS
    and `launch_other.go` will run on other platforms. An example of setting this
    up may go as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we create a file that handles the standard mechanism (called `launch_other.go`); 
    opening a file or a new document will create a window with an appropriate document
    and show it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we make a version for macOS (named `launch_darwin.go`), which first checks
    for a running instance. If one is found, we call some **RPC** (**remote proceedure
    call**) functions to open files in the running application, otherwise we load
    the window as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The main function of the app that launches this will probably be to parse the
    command-line parameters to determine whether a filename has been passed, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The details of `getFirstInstance()` and the RPC code are out of scope for this
    chapter but can be found in the `chapter11/singleapp` folder in this book's code
    repository. This model may be supported by some toolkits, but there are also projects
    that aim to make this easier, such as [https://github.com/marcsauter/single](https://github.com/marcsauter/single).
  prefs: []
  type: TYPE_NORMAL
- en: Extra features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, it isn't possible to find equivalent behavior or user interface
    elements on every platform your application or toolkit supports. In these cases,
    you may find the toolkit providing operating system-specific extensions that can
    be used in your application code. If you make use of these platform-specific items,
    you'll need to ensure that your code still functions correctly on other target
    systems. This would normally be handled by the build constraints such as the preceding,
    where some implementations may have no or reduced functionality to match the lowest
    common denominator.
  prefs: []
  type: TYPE_NORMAL
- en: Such a platform extension is Qt Windows Extras, which provides the taskbar icon
    progress API and a method for providing a *jump list* (a set of shortcuts from
    the application icon). This project can be found at [http://doc.qt.io/qt-5/qtwinextras-index.html](http://doc.qt.io/qt-5/qtwinextras-index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored techniques for designing and programming more complex
    graphical applications. While looking at principles for complex layouts and deep
    navigation structures, we compared how common applications deal with these challenges
    and noted the types of complex user interfaces to avoid. To provide a richer,
    consistent user experience in these applications, we investigated the APIs that
    provide standard dialog windows and allow developers to configure application
    windows to be consistent with the application workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Background task progress and system notifications should be visible but not
    interrupt the user's workflow. We explored how to use toolkit widgets and common
    techniques to provide this balanced communication. To further integrate with the
    current operating system, we explored the differences between, and additional
    features provided by, desktop platforms so that applications can match system
    semantics while maintaining a single code base for cross-platform development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll turn our attention to the background operations and
    networking features provided by Go and how to use them effectively in graphical
    application. We'll return to our GoMail examples and extend them using cloud services
    for a richer user experience.
  prefs: []
  type: TYPE_NORMAL
