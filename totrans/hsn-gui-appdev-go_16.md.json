["```go\npackage main\n\nimport (\n   \"fmt\"\n   \"time\"\n)\n\nfunc tick() {\n   fmt.Println(\"Started\")\n\n   for _ = range time.NewTicker(time.Second).C {\n      fmt.Print(\".\")\n   }\n\n   fmt.Println(\"Ended\")\n}\n\nfunc main() {\n   go tick()\n   go tick()\n   go tick()\n\n   time.Sleep(5 * time.Second)\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"time\"\n)\n\nfunc tickUntil(stop chan(struct{})) {\n   fmt.Println(\"Started\")\n\n   ticker := time.NewTicker(time.Second).C\n   for {\n      select {\n      case <-ticker:\n         fmt.Print(\".\")\n      case <-stop:\n         fmt.Println(\"Ended\")\n         return\n      }\n   }\n}\n\nfunc main() {\n   stop := make(chan(struct{}))\n\n   go tickUntil(stop)\n   go tickUntil(stop)\n   go tickUntil(stop)\n\n   time.Sleep(5 * time.Second)\n   close(stop)\n\n   time.Sleep(10 * time.Millisecond)\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"sync\"\n   \"time\"\n)\n\nfunc tickAndEnd(stop chan (struct{}), wg *sync.WaitGroup) {\n   wg.Add(1)\n   go func() {\n      fmt.Println(\"Started\")\n\n      ticker := time.NewTicker(time.Second).C\n      for {\n         select {\n         case <-ticker:\n            fmt.Print(\".\")\n         case <-stop:\n            fmt.Println(\"Ended\")\n            wg.Done()\n            return\n         }\n      }\n   }()\n}\n\nfunc main() {\n   stop := make(chan (struct{}))\n   wg := &sync.WaitGroup{}\n\n   tickAndEnd(stop, wg)\n   tickAndEnd(stop, wg)\n   tickAndEnd(stop, wg)\n\n   time.Sleep(5 * time.Second)\n   close(stop)\n\n   wg.Wait()\n}\n```", "```go\npackage main\n\nimport (\n   \"fmt\"\n   \"os\"\n   \"path/filepath\"\n)\n\ntype sizeInfo struct {\n   name string\n   size int64\n}\n\nfunc dirSize(path string, result chan sizeInfo) {\n   var size int64\n\n   filepath.Walk(path, func(_ string, file os.FileInfo, err error) error {\n      if err == nil {\n         size += file.Size()\n      }\n\n      return nil\n   })\n\n   result <- sizeInfo{filepath.Base(path), size}\n}\n```", "```go\nfunc reportUsage(path string) {\n   f, _ := os.Open(path)\n   files, _ := f.Readdir(-1)\n   f.Close()\n\n   result := make(chan sizeInfo)\n   for _, file := range files {\n      go dirSize(filepath.Join(path, file.Name()), result)\n   }\n\n   var total int64\n   results := 0\n   for info := range result {\n      total += info.size\n      fmt.Printf(\"%s:\\t%d\\n\", info.name, info.size)\n\n      results++\n      if results == len(files) {\n         break\n      }\n   }\n   fmt.Printf(\"\\nTotal:\\t\\t%d\\n\", total)\n}\n```", "```go\nfunc main() {\n   path, _ := os.Getwd()\n\n   if len(os.Args) == 2 {\n      path = os.Args[1]\n   }\n\n   fmt.Println(\"Scanning\", path)\n   reportUsage(path)\n}\n```", "```go\nfunc gtkReportUsage(path string, list *gtk.ListStore, totalLabel *gtk.Label) {\n   f, _ := os.Open(path)\n   files, _ := f.Readdir(-1)\n   f.Close()\n\n   result := make(chan sizeInfo)\n   for _, file := range files {\n      go dirSize(filepath.Join(path, file.Name()), result)\n   }\n\n   var total int64\n   results := 0\n   for info := range result {\n      var listIter gtk.TreeIter\n      total += info.size\n\n      gdk.ThreadsEnter()\n      list.Append(&listIter)\n      list.SetValue(&listIter, 0, info.name)\n      list.SetValue(&listIter, 1, formatSize(info.size))\n      gdk.ThreadsLeave()\n\n      results++\n      if results == len(files) {\n         break\n      }\n   }\n\n   gdk.ThreadsEnter()\n   totalLabel.SetText(fmt.Sprintf(\"Total: %s\", formatSize(total)))\n   gdk.ThreadsLeave()\n}\n```", "```go\nfunc main() {\n   glib.ThreadInit(nil)\n   gdk.ThreadsInit()\n   gdk.ThreadsEnter()\n   gtk.Init(nil)\n\n   window := gtk.NewWindow(gtk.WINDOW_TOPLEVEL)\n\n...\n\n   gtk.Main()\n}\n\n```", "```go\npackage main\n\nimport (\n   \"image\"\n   _ \"image/png\"\n   \"io\"\n   \"log\"\n   \"net/http\"\n\n   \"fyne.io/fyne\"\n   \"fyne.io/fyne/app\"\n   \"fyne.io/fyne/canvas\"\n)\n\nfunc readStream(url string) io.ReadCloser {\n   res, err := http.Get(url)\n   if err != nil || res.StatusCode != 200 {\n      log.Fatal(\"Error reading URL\", err)\n   }\n\n   return res.Body\n}\n\nfunc remoteImage(url string) image.Image {\n   stream := readStream(url)\n   defer stream.Close()\n\n   m, _, err := image.Decode(stream)\n   if err != nil {\n      log.Fatal(\"Error reading image\", err)\n   }\n\n   return m\n}\n\nfunc main() {\n   app := app.New()\n   w := app.NewWindow(\"Remote Image\")\n\n   img := canvas.NewImageFromImage(remoteImage(\"https://golang.org/doc/gopher/frontpage.png\"))\n   img.SetMinSize(fyne.Size{180, 250})\n   w.SetContent(img)\n   w.ShowAndRun()\n}\n```", "```go\ntype Person struct {\n   Title     string `json:\"title,omitempty\"`\n   Firstname string `json:\"firstname\"`\n   Surname   string `json:\"surname\"`\n\n   Username string `json:\"username\"`\n   Password string `json:\"-\"`\n}\n\nfunc main() {\n   fmt.Println(\"Downloading...\")\n   stream := remote.ReadStream(\"http://echo.jsontest.com/title/Sir/\" +\n      \"firstname/Tom/surname/Jones/username/singer1/\")\n   defer stream.Close()\n\n   person := &Person{}\n   json.NewDecoder(stream).Decode(person)\n   fmt.Println(\"Decoded:\", person)\n}\n```", "```go\nfunc cacheFileName(u string) string {\n   id, _ := url.Parse(u)\n   file := filepath.Base(id.Path)\n   return path.Join(\"/tmp/\", fmt.Sprintf(\"%s:%s\", id.Hostname(), file))\n}\n\nfunc cacheStream(url string) io.ReadCloser {\n   cacheFile := cacheFileName(url)\n   if _, err := os.Stat(cacheFile); !os.IsNotExist(err) {\n      fmt.Println(\"Found cached file at\", cacheFile)\n      file, _ := os.Open(cacheFile)\n      return file\n   }\n\n   fmt.Println(\"No cache found, downloading\")\n   stream := readStream(url)\n   writer, _ := os.Create(cacheFile)\n   io.Copy(writer, stream)\n   stream.Close()\n   writer.Close()\n\n   fmt.Println(\"Saved to\", cacheFile)\n   stream, _ = os.Open(cacheFile)\n   return stream\n}\n```", "```go\ntype EmailMessage struct {\n   Subject string    `json:\"subject\"`\n   Content string    `json:\"content\"`\n   To      Email     `json:\"to\"`\n   From    Email     `json:\"from\"`\n   Date    time.Time `json:\"sent\"`\n}\n```", "```go\nfunc (e *EmailMessage) String() string {\n   format := \"EmailMessage{\\n  To:%s\\n  From:%s\\n  Subject:%s\\n  Date:%s\\n}\"\n   return fmt.Sprintf(format, e.To, e.From, e.Subject, e.Date.String())\n}\n```", "```go\nfmt.Println(\"To JSON:\")\nencoder := json.NewEncoder(os.Stdout)\nencoder.SetIndent(\"\", \"  \")\nencoder.Encode(email)\n```", "```go\nstream := readStream(urlOmitted)\ndefer stream.Close()\n\nemail := &EmailMessage{}\njson.NewDecoder(stream).Decode(email)\nfmt.Println(\"Downloaded:\", email)\n```", "```go\ntype EmailMessage struct {\n   Subject string\n   Content string\n   To      Email\n   From    Email\n   Date    time.Time `xml:\"Sent\"`\n}\n```", "```go\nfmt.Println(\"To XML:\")\nencoder := xml.NewEncoder(os.Stdout)\nencoder.Indent(\"\", \"  \")\nencoder.Encode(email)\n```", "```go\nstream := readStream(urlOmitted)\ndefer stream.Close()\n\nemail := &EmailMessage{}\nxml.NewDecoder(stream).Decode(email)\nfmt.Println(\"Downloaded:\", email)\n```", "```go\nfunc authStream(url string) io.ReadCloser {\n   ret, err := client.Get(url)\n\n   if err == nil && ret.StatusCode != 401 {\n      return ret.Body\n   }\n\n   fmt.Println(\"Requesting authorization\")\n   openbrowser(conf.AuthCodeURL(\"state\", oauth2.AccessTypeOffline))\n\n   http.HandleFunc(\"/oauth/callback\", callbackHandler)\n   server = &http.Server{Addr: \":19999\", Handler: nil}\n   server.ListenAndServe()\n\n   return retReader\n}\n```", "```go\nfunc callbackHandler(w http.ResponseWriter, r *http.Request) {\n   queryParts, _ := url.ParseQuery(r.URL.RawQuery)\n\n   authCode := queryParts[\"code\"][0]\n   tok, err := conf.Exchange(ctx, authCode)\n   if err != nil {\n      log.Fatal(err)\n   }\n   client = conf.Client(ctx, tok)\n\n   ret, err := client.Get(\"https://www.googleapis.com/gmail/v1/users/me/messages\")\n   if err != nil {\n      fmt.Fprint(w, \"<p><strong>Authentication Failed</strong></p>\")\n      fmt.Fprintf(w, \"<p style=\\\"color: red\\\">%s</p>\", err.Error())\n      fmt.Fprint(w, \"<p>Please close this window and try again.</p>\")\n      log.Fatal(err)\n   } else {\n      fmt.Fprint(w, \"<p><strong>Authentication Completed</strong></p>\")\n      fmt.Fprint(w, \"<p>Please close this window.</p>\")\n\n      retReader = ret.Body\n   }\n\n   server.Shutdown(context.Background())\n}\n```", "```go\nfunc setupOAuth() {\n   // Your credentials should be obtained from the Google Developer Console\n   // (https://console.developers.google.com).\n   conf = &oauth2.Config{\n      ClientID:     \"CLIENT_ID\",\n      ClientSecret: \"CLIENT_SECRET\",\n      Scopes:       []string{\"https://www.googleapis.com/auth/gmail.readonly\"},\n      Endpoint:     google.Endpoint,\n      RedirectURL:  \"http://127.0.0.1:19999/oauth/callback\",\n   }\n   ctx = context.WithValue(context.Background(), oauth2.HTTPClient, client)\n}\n```", "```go\n   if err != nil {\n      log.Fatal(err)\n   }\n   saveToken(tok)\n   client = conf.Client(ctx, tok)\n```", "```go\nfunc main() {\n   setupOAuth()\n   token = loadToken()\n\n...\n}\n```", "```go\nfunc authStream(url string) io.ReadCloser {\n   if token != nil {\n      fmt.Println(\"Reusing stored token\")\n      client = conf.Client(ctx, token)\n   }\n   ret, err := client.Get(url)\n\n...\n}\n```", "```go\nfunc countMessages() {\n   in := authStream(\"https://www.googleapis.com/gmail/v1/users/me/messages\")\n   defer in.Close()\n\n   var content interface{}\n   decoder := json.NewDecoder(in)\n   decoder.Decode(&content)\n\n   if body, ok := content.(map[string]interface{}); ok {\n      list := body[\"messages\"].([]interface{})\n      fmt.Println(len(list), \"messages found\")\n   }\n}\n```", "```go\nfunc (e *EmailMessage) ToGMailEncoding() string {\n   m := mime.NewMultipartMessage(\"alternative\", \"\")\n   m.SetHeader(\"Subject\", mime.EncodeWord(e.Subject))\n   m.SetHeader(\"From\", mime.EncodeWord(\"Demo\") + \" <\" + string(e.From) + \">\")\n   m.SetHeader(\"To\", mime.EncodeWord(\"Demo\") + \" <\" + string(e.To) + \">\")\n   plain := mime.NewTextMessage(qprintable.UnixTextEncoding, bytes.NewBufferString(e.Content))\n   plain.SetHeader(\"Content-Type\", \"text/plain\")\n   m.AddPart(plain)\n\n   var buf bytes.Buffer\n   io.Copy(&buf, m)\n   return base64.URLEncoding.EncodeToString(buf.Bytes())\n}\n```", "```go\nfunc postMessage(msg *EmailMessage) {\n   raw := msg.ToGMailEncoding()\n   body := fmt.Sprintf(\"{\\\"raw\\\": \\\"%s\\\"}\", raw)\n\n   ret := authPost(\"https://www.googleapis.com/gmail/v1/users/me/messages/send\",\n      \"application/json\", strings.NewReader(body))\n   io.Copy(os.Stdout, ret)\n   ret.Close()\n}\n```", "```go\n   Scopes: []string{\"https://www.googleapis.com/auth/gmail.readonly\",\n      \"https://www.googleapis.com/auth/gmail.compose\"},\n```", "```go\nfunc main() {\n   setupOAuth()\n   token = loadToken()\n\n   msg := &EmailMessage{\n      \"GoMail Test Email\",\n      \"This is a test email sent from a Go example\",\n      \"test@example.com\",\n      \"me@example.com\",\n      time.Now()}\n   postMessage(msg)\n}\n```", "```go\n{\n  \"errors\" => [\n    {\n      \"message\" => \"Temporary storage failure\",\n      \"retry\" => true,\n      \"path\" => [\"user\", \"add\"],\n    }\n  ]\n}\n```", "```go\nfunc cacheFallbackStream(url string) io.ReadCloser {\n   stream := cacheStream(url)\n   if stream != nil {\n      return stream\n   }\n\n   stream = resourceStream(url)\n   if stream != nil {\n      return stream\n   }\n\n   return readStream(url)\n}\n```"]