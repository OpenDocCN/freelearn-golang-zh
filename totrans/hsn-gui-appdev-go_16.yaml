- en: Concurrency, Networking, and Cloud Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been focusing on designing and building the graphical elements
    of applications. Most modern software isn't complete without a solid connection
    to internet services and networking features. Adding dependencies to remote services
    could affect the stability of an application if it isn't correctly managed. Concurrency
    is also a key part of managing an interaction with remote services; we'll need
    to add more advanced task handling to manage these various communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread handling and managing the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including remote resources in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to cloud services and handling error cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining user experience when the network disconnects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to integrate remote resources
    and cloud services into your application. You'll also see how to maintain a responsive
    user interface despite this new functionality relying on network connections that
    may be unreliable or unavailable. The addition of long-running background processes
    and the communication challenges they can cause will be completely solved as your
    application is updated to manage data from a multitude of sources.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency, threads, and GUI updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Goroutines are a very powerful tool for running concurrent operations and background
    tasks, especially if they're short-running. As we move more application logic
    and data handling to background processes, we need to add appropriate safeguards
    to ensure that errors are handled and that the user interface is kept up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Managing long-running processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A goroutine is typically created so that code flow continues while another task
    completes in the background. If these tasks start to be used for application-critical
    tasks or to handle important data, especially if these tasks could take a long
    time, we need to manage them more carefully. The main consideration is how to
    shut down background tasks gracefully if the application exits. This may not seem
    essential, and for some tasks it may not be, but if the process is involved in
    data integrity, we want to be certain that early termination doesn't cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: Signaling shutdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate the problem, let''s start with a simple goroutine demo; we''ll
    launch three threads that print progress. For each thread, we''ll print `Started` followed
    by `.` until the thread stops, at which point `Ended` will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, you''ll see the following output. The threads start and
    tick as expected and, after a `5` second timeout, the program exits. No `Ended` messages
    are seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac958baf-0554-4a72-910b-2c719f22641c.png)'
  prefs: []
  type: TYPE_IMG
- en: The output of unterminated goroutines
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this simple demo, the goroutines aren't gracefully terminated;
    they simply stop running. If we're writing complex data, sending a message to
    a remote server, or waiting for an important response, this would probably result
    in data corruption or other unexpected results. Let's look at how to signal goroutines
    to stop when our application terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a simple channel called `stop` that''s passed into each
    goroutine. When the application is ready to exit, we''ll signal each thread so
    it can finish its work by closing this channel. We update the tick function to
    check whether this new channel is closed and if so, it''ll exit. To allow the
    code to complete before the application exits, we must add a new pause at the
    end of `main()` for the cleanup. The updated code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this should display the following output, which is what we were looking
    for in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfd5e764-bd47-4678-8427-e92fbb82982b.png)'
  prefs: []
  type: TYPE_IMG
- en: With a signal channel, our threads can end just before the program exits
  prefs: []
  type: TYPE_NORMAL
- en: Checking completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example technically works, but depending on a timer to wait for
    threads to complete isn't reliable. If the threads need to wait for a response
    or are part way through a long calculation, we'll still have potential corruption
    if the timer elapses. The solution is to have the goroutine signal once the cleanup
    is complete. This can be done with `sync.WaitGroup` or by using another channel.
  prefs: []
  type: TYPE_NORMAL
- en: For our completed thread example, we create `sync.WaitGroup`, which is passed
    to each of the tick threads. Before we start the goroutine, we increment the number
    of threads to wait on using `wg.Add(1)`. Once each thread is complete, they mark
    that using `wg.Done()`. Our application is then free to call `wg.Wait()` immediately
    before exiting, safe in the knowledge that it won't prematurely terminate any
    of the grouped background processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates signaling and waiting for multiple goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is almost exactly the same as the previous version, but
    the specific timing of the threads ending is slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e175e59c-936b-44f5-81bb-b10881ddff2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Waiting for our goroutines to complete instead of waiting a set time
  prefs: []
  type: TYPE_NORMAL
- en: Communicating through channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen in earlier chapters, goroutines offer powerful but simple concurrent
    operation. Most of these examples have been generating output or responding to
    user requests, but long running processes are often generating data that needs
    to be utilized by the application. In this example, we see how a channel can be
    used to effectively gather data from multiple threads to aggregate and report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example is a simple tool that''ll get the disk usage of a directory. For
    each element within this directory, we''ll start a goroutine (`dirSize()`) that''ll
    calculate the space used by the directory and the files it contains. This function
    returns the result through a channel so the application can use the information
    once it''s available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `reportUsage()` function, we start as many goroutines as there are
    files reported in the specified directory. The code then prints the usage result
    from each goroutine when it completes using `for info := range result`, and then
    terminates when every result is returned (`if results == len(files) {break}`),
    adding a simple total before we exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we add a `main()` function that simply parses arguments to initialize
    the `reportUsage()` function. If no argument is specified, we''ll report for the
    current directory reported by `os.Getwd()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this example may return immediately, but if you invoke it on a large
    directory, it may take some time to complete. By doing this, you can see that
    each printed appears as soon as the related goroutine completes, and the total
    is always last to appear. The preceding listing doesn''t include some boilerplate
    number formatting seen in the resulting screenshot (that can be found in this
    book''s code repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12a868a5-a3bd-4202-8373-f3bc1ad82f47.png)'
  prefs: []
  type: TYPE_IMG
- en: Reporting the usage of a directory; typically smaller items appear first as
    they're faster to calculate
  prefs: []
  type: TYPE_NORMAL
- en: Graphical updates from goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communicating with the graphical interface (in most frameworks) means managing
    threads correctly. In the preceding example, we could have updated a GUI within
    the `dirSize()` method, adding a row to a table, for instance. In theory, that
    would have avoided the need for a channel and the struct that we passed back to
    the `reportUsage()` function. However, changing threads is a (relatively) slow
    process depending on other application activities, and moreover we should try
    to separate our logic and processing from the user interface code. Doing so will
    make it easier to reuse code later and possibly to change toolkit if our requirements
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our design to handle most of the user interaction in a single function means
    that our actual directory usage code is completely separate from our user interface.
    Let''s update the preceding example to generate a graphical output instead. We''ll
    use Go-GTK this time, as its thread handling is quite explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our replacement usage reporting method has two instances of `gdk.ThreadsEnter()`
    and `gdk.ThreadsLeave()`; each time we update the user interface, we must switch
    to the `gdk` main thread. As in previous Go-GTK examples, we need to also update
    the main method to correctly initialize thread handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The full user interface creation is omitted from this chapter for brevity,
    but can be found in this book''s source code (in `chapter12/goroutines/gtkdiskusage.go`).
    It''s a requirement of most graphical toolkits that background processes switch
    to the main or graphics thread when updating the user interface. Some, such as
    Fyne, don''t have this requirement, which you can see in an alternative version
    of the example (also available in this book''s code repository at `chapter12/goroutines/fynediskusage.go`).
    Instead of wrapping GUI calls in thread handling code, we simply call `list.Append()`
    or `label.SetText()` from the background code and the interface will update accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef0f0cb4-f2c7-4110-ae17-c9b403eda9ea.png)'
  prefs: []
  type: TYPE_IMG
- en: A GTK interface for the disk usage example
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e66deffd-88fc-40a2-b83f-26083d0e1f1a.png)'
  prefs: []
  type: TYPE_IMG
- en: The same disk usage example using Fyne
  prefs: []
  type: TYPE_NORMAL
- en: Network resources and caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Accessing remote resources, on a local network or from a server across the
    internet, is likely to play a part in most applications. Unfortunately, it''s
    also the source of a significant number of potential issues: slow responses, unexpected
    data, or no data at all. Let''s look at some ways we can work to create a robust
    application even when we need to use the network and integrate cloud services.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading remote resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing resources in Go is normally through a byte stream, either locally
    (for embedded resources or file system access) or remotely (for HTTP requests
    and data from a remote server). As the method for reading local and remote data
    is similar, we can load remote resources in most of the places where local or
    embedded assets have been used.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following the stream-based design, the Go `image` package decodes images from
    a stream. By connecting to a remote stream and reading the bytes from the request,
    we can easily render an image from a web server. The following code uses the Fyne `canvas.NewImageFromImage()` function
    to render a Go decoded image, which we''ve loaded from the [https://golang.org/doc/gopher/frontpage.png](https://golang.org/doc/gopher/frontpage.png) URL
    using `image.Decode()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you would expect, this application opens a single window with the image
    loaded as its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71afb2b1-5e52-4d3a-a18d-96c1d4b2ddaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Loading a file from the internet
  prefs: []
  type: TYPE_NORMAL
- en: But this only works appropriately when the internet connection is behaving correctly
    and, even then, may take longer than the user expects to load. Before we look
    at strategies to improve this, let's see how to do the same for data downloaded
    from a web service.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To explore how to work with remote data from a web service, we shall start
    by adapting our web service example from [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml),
    *Go to the Rescue!*. The code is slimmed down and updated to use the same `readStream()`
    function as created for the preceding image example. The resulting code is very
    basic but demonstrates how easily we can decode JSON data into a struct using
    built-in Go features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a single method for our resource loading enables us to put more robust
    error handling in a central place. Until we''ve made those improvements, our application
    will crash if the request fails (no internet or server error, for example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfaf7f47-d26d-4367-a7f4-e1006dcd73ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Image failure when there's no network connection
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3492757b-c8aa-40d4-a532-694465b75930.png)'
  prefs: []
  type: TYPE_IMG
- en: JSON can't be accessed when offline either
  prefs: []
  type: TYPE_NORMAL
- en: While these errors could be handled better, we would still have downloaded no
    content. An image not loading may not matter, situations when the connection but
    missing JSON data would probably reduce the functionality of our application.
    What we should aim for is to better handle situations where the connection isn't
    present or isn't responding correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Caching resource data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first approach to providing a better experience when an internet connection
    is slow or unreliable is to implement a caching mechanism for our remote resources.
    With this in place, a single online run of the application would be sufficient
    to defend against connectivity problems as it'll populate the cache data. The
    bonus is that, on repeated runs of the application, it'll be much faster to load
    these resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on the previous image example, we implement a new function, `cacheStream()`,
    which we''ll call instead of `readStream()`. A helper function called `cacheFileName()`
    establishes a file location to use for the cache based on a `url` parameter. Every
    time we request a URL using this function, it''ll attempt to load a cached copy
    from that location; if it''s present, then `io.ReadCloser` to this location will
    be returned directly. If the cache file isn''t present, then we use the original
    `readStream()` function to download the content into the cache file and then return
    a stream to the cache file as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is just an illustration of how this can be done; if it were
    to be used in a production application, you would need to use a better cache location and
    handle potential thread issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1.11 release of Go, there's a new `os.UserCacheDir()` function. However,
    it's often wise to wait for a while before relying on new functionality as not
    everyone will have upgraded yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of the stream-based approach is that we can use it for assets other
    than images. Just like the image example, we can update our JSON code to use `cacheStream()`
    instead of `readStream()`, and our data will be downloaded once and then read
    from the local file by the cache code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa2ff163-efdf-4517-86fe-0d3f225667ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Caching our remote image means better resilience of the application
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47120207-bee3-4bde-b4f4-105e0f218f53.png)'
  prefs: []
  type: TYPE_IMG
- en: By caching the JSON, our application can function if the network fails
  prefs: []
  type: TYPE_NORMAL
- en: These examples should help to work with remote resources in your application,
    but are relatively simple examples. How do we work with more complicated cloud
    services?
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to cloud services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many frameworks and libraries available that aim to help you to work
    with cloud services in Go. However, if you ask the Go community which is best,
    they'll probably suggest that you stick with the built-in packages. Doing so may
    seem strange for anyone coming from C or Java (or many other languages created
    before internet connected applications became commonplace), but the standard library
    for Go is very capable. We'll explore here how to work with the provided tools
    and add cloud service-based functionality to our code without additional dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start looking at this, we'll return to the `EmailMessage` model defined in
    the `client` package at [https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/tree/master/client](https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/tree/master/client),
    which was imported in previous chapters. By adding simple hints to this object,
    we can correctly serialize and deserialize in both JSON and XML formats with ease.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the convention in JSON is for map keys to be in lowercase, we add hints
    to our struct of the `` `json:"subject"` `` form that tell the `json` package
    how to handle the field names within the struct. The updated definition should
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To aid in testing, let''s also add a `String()` function to the definition
    for easier debugging later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is in place, we can add some code that demonstrates the usage. Firstly,
    let''s construct a new `EmailMessage` object and encode it to JSON. The encoding
    is very simple, and is illustrated as follows. We just create a new `json.Encoder` instance
    (that will output to the standard output), set the indent values (for improved
    readability), and ask it to encode our struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Decoding a struct from JSON is also simple. We connect to a URL, open a stream
    using code from earlier in this chapter (the URL is omitted here for brevity),
    and defer the closing of the stream. Then, a new `json.Decoder` instance is created
    from this stream and we ask it to decode into the email struct. We''ll then output
    the data (using the preceding helpful `String()` function) to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Running all of that''ll result in some pretty easy-to-read output that shows
    we''ve successfully created, encoded, and then decoded JSON data for our struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7554c724-fbfc-4a81-a2d7-c51f49da445a.png)'
  prefs: []
  type: TYPE_IMG
- en: JSON data from a struct and from a WebService
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with XML is very similar to JSON. In fact, as XML and Go share the
    semantics of capitalizing their public variable names, there''s less mapping annotation
    required, so the struct only requires a single mapping tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Encoding and decoding are almost identical; obviously, we need to create `xml.Encoder`
    and `xml.Decoder` rather than the JSON counterparts. The only other difference
    is the method call to set the indenting (only required for pretty printing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we can use a web service to provide us with XML to decode (the URL is
    omitted here for brevity but can be found in this book''s source code repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing all of the preceding code will give a similar output to the JSON
    example but with a different format when encoded. Note also that the variable
    names start with uppercase letters, which is common in XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a851fd81-508d-4ea3-85a5-8bfa32054e5d.png)'
  prefs: []
  type: TYPE_IMG
- en: XML data can just as easily be used when communicating with WebServices
  prefs: []
  type: TYPE_NORMAL
- en: Authentication – OAuth 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is often a requirement for accessing a service over the web—not
    always for the entire API, but certainly to access privileged user data. Most
    web-based authentication currently utilizes OAuth 2.0, a framework that allows
    applications to gain partial access to user data after permission is granted by
    the user. The authentication will need to show a web page the first time a resource
    is accessed to explain the request. As a GUI-based application, this workflow
    is often presented using an embedded browser window to hide the complexity of
    going to a web page for the permission request. Unfortunately, such functionality
    isn't built into many of the toolkits we've covered and so we'll instead simply
    open an external web browser for illustrating the workflow. This should only be
    required for first usage and, after that, the access granted should be remembered
    across application runs.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate authentication, we'll further progress the client code used in
    each GoMail example. We'll extend it to read from the Gmail APIs to download messages.
    For this, you'll need to have a Gmail account and to have created a project in
    the Google Developer Console and enabled API access, which will generate `CLIENT_ID`
    and `CLIENT_SECRET`. First of all, we'll create a new function called `authStream()`
    that'll take a URL `string` parameter and return an `io.ReadCloser` stream like
    the previous `readStream()` and `cacheStream()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: First request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To return an authenticated stream, we need to check whether authentication is
    required (a status code of 401 on an HTTP request means just that). If we've already
    authenticated, then the request will complete as normal and we can just return
    the request body. If authentication is required, then we must initiate the process
    by loading a web browser at the correct URL to ask the user for permission; this
    is completed by a helper function, `openBrowser()`, which can be found in this
    book's source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: When the browser window opens, the user will be told about the permission being
    requested and, assuming they accept, the page will redirect to a callback URL.
    We need to set up a simple web server locally to handle this redirect. To do so,
    we register a handler at the `/oauth/callback` path and wait for a connection
    on port 19999.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server is started, which will cause the function to block until we shut
    it down later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback handler is relatively simple. It''s responsible for extracting
    the authorization code from the redirection and, using this code, requesting a
    reusable token from the server that sent the single-use code (this is handled
    by `conf.Exchange()`). Upon the exchange completing, we try once again to connect
    to the URL originally specified; if we, succeed, then the return stream is set
    and if not, we fail with the appropriate error. Whatever the outcome, we prompt
    the user to close the browser window (as web page security dictates this can''t
    be done automatically). After we''ve returned this content to the user, we''ll
    shut down the server. This returns control to the original `authStream()` function,
    which will return the newly authenticated request stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of this puzzle is to set up the OAuth2 configuration and context.
    We''ll be requesting `read-only` authentication scope from the Gmail API and specifying
    our local server for the callback URL. You''ll need to provide values for `CLIENT_ID`
    and `CLIENT_SECRET` for this to operate correctly. Much of the configuration is
    helpfully provided by the `google.Endpoint` definition from the `golang.org/x/oauth2/google` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Storing tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a repeat request, we can avoid having the user go through a permission workflow
    again by reusing the token we've been issued. The token that's returned by `conf.Exchange()`
    can be persisted and used in subsequent requests. This token contains a reference
    to refresh the token, which means that, even if the token has expired, the application
    can probably request a new token automatically.
  prefs: []
  type: TYPE_NORMAL
- en: To store and retrieve the token, we shall use a JSON serialization that's already
    set up on the `oauth2.Token` type. When the token is originally issued, we'll
    save it to a file (this could be a database or any other persistence your application
    has access to). As the `client` object we're using to issue `Get()` requests is
    shared; we don't need to reload the token for each request. Instead, we can simply
    load it the next time the application starts. This should mean that, upon a second
    launch of an example, you'll immediately see the results rather than having to
    go through the permission request a second time.
  prefs: []
  type: TYPE_NORMAL
- en: 'And so we update the `callbackHandler()` function to store the token, if it
    was successfully returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And in our application''s `main()` function, we add the token load line immediately
    after setting up the OAuth configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This loads the stored token (if one exists) into a global variable to be accessed
    later by the `authStream()` function, which should be updated to check for the
    token to see whether it has been loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple implementations of `saveToken()` and `loadToken()` are available in
    the source code repository. For testing purposes, it''s sufficient to print the
    content to the system output and then copy and paste it into the `loadToken()`
    function before the next run. With all of this together, we can implement a simple
    request that''ll count the messages in a user''s inbox. This function requests
    a Gmail API that requires authentication and counts the number of items in the
    resulting JSON message list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this twice, we see that the first request required the browser
    to open and confirm the authorization. On the second run, that token is reused
    and the same content is returned without interrupting the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f613915a-66d4-4845-92e8-a9f9049a3a02.png)'
  prefs: []
  type: TYPE_IMG
- en: Requesting OAuth2 authorization the first time opens a browser window; repeat
    calls use the token we saved
  prefs: []
  type: TYPE_NORMAL
- en: Posting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Posting data to a web service should be just as easy as changing a `Get()`
    function call to a `Post()` but there are often complications. Consider our email
    example and the task of connecting to Gmail. The API is straightforward and we
    can easily make the request, but the data must be appropriately formatted. Emails
    have complex encodings when sent to mail servers and we need to implement that
    to work with the API. The Gmail service requires an RFC 2822 encoded email (which
    the Go standard library doesn''t provide), which is then base64url encoded (the
    standard library can handle this). Before we can post any email messages, we need
    to add an encoder to our `EmailMessage` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This code makes use of an external library, `github.com/sloonz/go-mime-message`, and
    it has been imported as `mime` for convenience. We''re using the name `Demo` as
    we haven''t recorded people''s names in these examples; you could omit that part
    if you prefer. To implement the sending of emails, we can check the Google documentation
    at [https://developers.google.com/gmail/api/v1/reference/users/messages/send](https://developers.google.com/gmail/api/v1/reference/users/messages/send)
    to find out that we need to pass a JSON payload with the encoded data as a value
    associated with the `raw` key. A simple method should be able to package that
    and send it to the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For this code, we need just one more function, `authPost()`. This function
    will make an authenticated post to our URL passing the content type and request
    body as the second and third parameters. This method could save the URL, content
    type, and payload to re-submit if the authorization workflow is required, but
    often this is unwise or impossible for an HTTP post request and so we simply re-use
    the token that was generated in the previous `authStream()` function. If you do
    reuse this token, then you''ll need to remember to update the code to request
    additional permissions; the updated scope should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this changed, a new token is issued and, with the preceding code in place,
    we can execute a simple method to send an email using the `postMessage()` function
    listed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `postMessage()` function outputs useful debug information, but
    that can clearly be switched off and the email can send handle failures in a more
    appropriate manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72e90d90-fe54-4347-9251-59f40952a9a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The debug from our email post example; Gmail returns the message and thread
    ID along with label information
  prefs: []
  type: TYPE_NORMAL
- en: GUI integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous *Concurrency, threads, and GUI updates* section, we looked at
    thread management and how to update the user interface from background tasks.
    Now that we're working with real cloud services, let's look at additional complications
    that we may need to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Incoming messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client API that has been used to simulate a connection to an email server
    included the `Incoming()` function, which returned a channel of `EmailMessage`
    objects. A new message would be sent to this channel each time a new email arrived,
    and we can use this same model for a real email server connection as well. The
    email message abstraction works to communicate a standard structure and so all
    a new email connection (such as the preceding Gmail examples) needs to do is package
    the incoming data into an `EmailMessage` struct and add it to the channel.
  prefs: []
  type: TYPE_NORMAL
- en: This means the only additional work that we need to do is update the code in
    the server connection package to monitor for new messages and add some JSON decoding
    when a new message is detected. All of this can be done without changing a single
    line of our GoMail example application GUIs. In fact, to activate a real Gmail
    account instead of our test server "we need to change the `client.NewTestServer()`
    function call to `client.NewGmailServer()` (a full description of this Gmail provider
    is available in the final [Appendix](e0ad4219-5c9a-4d4b-87ce-5bc4b7baa67c.xhtml),
    *Connecting GoMail to a Real Email Server*).
  prefs: []
  type: TYPE_NORMAL
- en: Activity notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be helpful for users to know when an application is executing code in
    the background. If, for example, you wanted to include a Check Email button in
    your application, then it may be helpful to indicate when email is being checked
    so the user knows that pressing the button won't do anything. As a developer,
    this is most commonly seen in an IDE status bar, indicating that a build is in
    progress or a packaging task is running. If working on a laptop and fans start
    to spin, it's useful to know what's executing in the background so that any potential
    concerns can be put to one side for a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support this type of interface update, we need to track when tasks start
    and stop. Depending on the type of visual design, there are two strategies we
    could use: a simple counter of background tasks or a list of running tasks. The
    former is far easier to implement but the latter is able to report more information
    to the application user. If you''ll just use a spinner or an infinite progress
    bar, then the first strategy will work well. If, however, you want to add a status
    bar that shows the current running task, you''ll need to go with the second.'
  prefs: []
  type: TYPE_NORMAL
- en: Spinner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A spinner (or other simple activity indicator) can be a helpful visualization
    of whether or not there's background activity. It'll be visible if the number
    of background tasks is non-zero. To track this, we can implement a simple counter
    in the application and update it using the `StartTask()` and `StopTask()` functions.
    A listener or channel would then tell the user interface element that the number
    of running tasks had changed so it can update the GUI by showing or hiding the
    visual element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a cloud-based application where a background task is using network connections,
    there''s an added benefit: we can insert these task tracking function calls into
    the network request code. For example, we could update `readStream()` to call
    `StartTask()` and all of the background tasks will increment the counter. To signal
    that the task had ended, we would return a wrapper to the stream so that, when
    `Close()` is called, it can correctly call `StopTask()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Status panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A status panel, which displays the current (or most recent) task, will need
    us to track the name of a task when it starts. To accurately display which task
    is still running, we'll also need to track which task ends (otherwise a quick
    task that starts after a long running one and then stops won't correctly update
    the status display).
  prefs: []
  type: TYPE_NORMAL
- en: An example implementation would be for the appropriate start function to return
    a task reference, which is then stopped directly, for example, `task := StartTask("My
    task name")`, which is then stopped later using `task.Stop()`. A similar listener
    or channel would be needed, but this time the data would be a task reference instead
    of the count of background tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent user experience when offline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern graphical applications, a good user experience is clearly dependent
    upon great design and a high level of quality, but it's also important to handle
    network and service failures. In the *Network resources and caching* section of
    this chapter, we covered, caching of server responses to be more fault tolerant
    and to speed up application loading, but that's a small portion of a larger strategy
    for great offline support.
  prefs: []
  type: TYPE_NORMAL
- en: Caching responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The response caching code introduced earlier in this chapter can be applied
    to almost all HTTP requests, but we only used it for HTTP GET. Of the many different
    types of HTTP requests, only three are deemed to be cacheable (GET, HEAD, and
    POST), and the HEAD request doesn't return a body and so isn't useful in our application.
    The POST method is indicative of an action being performed, so in our context
    (and most others), it's more important to know that it completed, rather than
    to save the response it caused (see the *Queuing actions* section next). To learn
    more about the types of HTTP requests, see [https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, it may not be suitable to cache the response to every GET
    request. While HTTP is a stateless protocol, the server that you're communicating
    with may be tracking state that could affect the response to your request. If
    your application knows that the response to a request will be time sensitive,
    you could make sure that it skips the cache or set a timeout on that cache entry.
    Unfortunately, it may not always be possible to know this in advance; this is
    where HTTP headers (and the HEAD method) can be helpful. By examining the headers
    of a response, you may see Last-Modified or ETag metadata (by issuing a HEAD request,
    you can access this information without the full response data being sent). If
    the Last-Modified header contains a time that's earlier than the creation of your
    cache entry, then your cache can still be used, otherwise you should remove the
    cached item and replace it with a fresh request. Using ETag is usually more efficient
    as it doesn't require any date parsing, but you'll need to store the appropriate
    tag for each cached response. This metadata is used as a unique identity for the
    response content and, if the data were to be changed in any way, the ETag would
    change as well (at which point you would reset the cache, as mentioned earlier).
  prefs: []
  type: TYPE_NORMAL
- en: If implementing a complete HTTP cache, there are other headers to be aware of
    as well, most notably `Cache-Control`. If this value is set to `no-cache` or `no-store` (or
    a combination including those values), the server is indicating that the response
    must never be cached. This is probably an indication that the content is specific
    to that request and the time of request, or that there's another reason that issuing
    the same request again would return a different response body.
  prefs: []
  type: TYPE_NORMAL
- en: With all of these considerations properly addressed, the code to manage a response
    cache is a lot more complicated than illustrated earlier in this chapter, which
    is why various Go packages exist to manage the details. Searching in your favorite
    search engine for *golang http cache* will probably return the most popular results.
  prefs: []
  type: TYPE_NORMAL
- en: Queuing actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other HTTP methods, such as POST, PUT, or DELETE, are typically indicative of
    a user action whereby confirmation that it has been communicated is the main requirement.
    In these situations, a cache isn't helpful; if requested a second time, the cache
    could stop our action from reaching the server at all. For this reason, it's uncommon
    to cache these requests. Moreover, if we're to build a resilient application,
    we need to plan for unsuccessful requests. In these situations, the server may
    or may not have received our request and the action may or may not have been processed.
  prefs: []
  type: TYPE_NORMAL
- en: The usual approach to this challenge is to build a queue of outgoing responses.
    Adding a request to such a queue could be done using  *fire and forget*, whereby
    the user doesn't care when the request is completed, or to add a callback so that
    appropriate notifications (such as *Email sent*) can be communicated upon completion.
    Building queues like this with Go is well documented; support for multi-threading,
    channels, and wait groups makes it a relatively simple task so we'll not go into
    the details of how this could be executed. What's important, however, is determining
    whether a request succeeded or failed.
  prefs: []
  type: TYPE_NORMAL
- en: If an HTTP POST (for example) times out or returns with an error of 500 (or
    above), we must assume it failed. Re-issuing the same request is safe as re-issuing
    an identical POST shouldn't cause any additional state change if it was successfully
    completed the first time. A response code from 400 to 499 means that there was
    a fault with the request and re-trying won't fix the issue. In these cases, it's
    likely that the user needs to be informed of the failure (and the code should
    probably log the error to your team somehow).
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful not to blindly accept a status code of 200 (OK) as success; many
    protocols communicate certain failure conditions within the body of a successful
    HTTP response. Be sure to read the documentation for the API you''re using to
    see how to check for additional errors. For example, a typical `graphql` response
    may return an HTTP status code 200 but have failed internally; knowing whether
    to retry in the background or to communicate the error to the application user
    will be specific to the service and the error encountered. In the following example,
    the server response helpfully indicated that a retry may help to resolve the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Starting offline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding strategies help to deal with intermittent internet connections,
    or continuing to work with an application in offline mode after some time online.
    But what if your application is designed to work offline right from the first
    usage? If a login isn't required immediately, then you may be able to support
    an initial offline state; probably not ideal for an email client but it may be
    expected for a collaborative documentation platform or entertainment system. How
    can we make use of the techniques we've explored already to provide a great first-use
    experience if there's no network available?
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest approach to this problem is probably to package data with the
    application so that it can be used as a cache if no recently cached data is available.
    In this manner, the application could attempt to use a local cache if one exists,
    then fall back to the application data otherwise, and if neither is available,
    then attempt to make the remote connection, like the following prototypical function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we re-use the `cacheStream()` and `readStream()` functions
    before and  use a new (hypothetical) function named `resourceStream()`, which
    would encode the URL, look up some bundled resources in the application, and return
    a stream to one if it's found. An alternative approach is for the first run of
    an application to extract all of the cached resources it has packaged and set
    up a local cache, then later code could simply use `cacheStream()` as before.
    For more information about bundling resources for distribution, see [Chapter 14](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml),
    *Distributing your Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, whichever strategy you use, be sure to consider how important it
    is for the data to be up to date; is falling back to an old cache that's bundled
    in the application a good strategy for your data? Do you want to update the local
    copy of this information on a regular basis? If it's important that the data be
    as fresh as possible, then the preceding function should probably be changed so
    that `readStream()` is attempted before `resourceStream()` or even `cacheStream()` and
    a *live* request is attempted if possible. If you take this approach, be sure
    to consider timeouts and other failure conditions, and handle user expectations
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored some of the more complex aspects of developing
    a rich application with long-running background threads and a reliance on remote
    resources or web services. We first looked at multi-threading and the management
    of long-running processes, building on the basics of goroutines and thread handling
    from earlier chapters. We looked at how background processes can be designed to
    minimize the impact of the code overhead required by some graphical toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the complexity discussed in this chapter covered working with remote
    resources and web services. We saw how to implement caching strategies and how
    they can work to create a more resilient application when network conditions aren't
    optimal. We also explored authentication of requests (using the common OAuth2
    workflow) and connected the GoMail examples to a live Gmail account to read and
    send emails.
  prefs: []
  type: TYPE_NORMAL
- en: All of these topics help to build robustness into an application and maintain
    a high quality user experience even when required resources aren't available.
    In the next chapter, [Chapter 13](fae83854-5529-4783-a6a4-b019dc45f831.xhtml),
    *Best Practices in Go GUI Development*, we'll move our focus from user experience
    to great source code and look into best practices for GUI development with Go.
    We'll also cover how to set up your code for ease of development and collaboration,
    as well as the tools and processes that'll help along the way.
  prefs: []
  type: TYPE_NORMAL
