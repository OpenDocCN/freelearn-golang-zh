<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Best Practices in Go GUI Development</h1>
                </header>
            
            <article>
                
<p>The Go language has well-defined practices for formatting, documentation, and code structure. You can find these referenced in many places, for example, <a href="https://golang.org/doc/effective_go.html#formatting">https://golang.org/doc/effective_go.html#formatting</a> and <a href="https://github.com/golang/go/wiki/CodeReviewComments">https://github.com/golang/go/wiki/CodeReviewComments</a>. Additionally, there is a strong community drive to encourage writing idiomatic Go, such as <a href="https://dmitri.shuralyov.com/idiomatic-go">https://dmitri.shuralyov.com/idiomatic-go</a>. Many of these design decisions are encoded in tools such as <kbd>gofmt</kbd> and <kbd>golint</kbd>, which makes it easy for people to learn and maintain standardized code.</p>
<p><span>In this chapter, we will look beyond these code standards and common conventions to focus on the aspects of best practice that make it easier to maintain and grow GUI-based applications. We will cover the following topics:</span></p>
<ul>
<li>Separation of concerns</li>
<li class="h1">Test-driving UI development</li>
<li class="h1">Continuous integration for GUIs</li>
<li class="h1">Managing platform specifics</li>
</ul>
<p>The addition of graphical elements to an application often makes it harder to test. In this chapter, we will see that with the correct preparation and structure, we can overcome these challenges and make our code robust and easy to change. Let's start by looking at how to structure a GUI-based application for maintainability.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Separation of concerns</h1>
                </header>
            
            <article>
                
<p>The concept is closely related to the <em>Single Responsibility Principle</em> introduced by Robert C. Martin in his principles of Object Oriented Design (<a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</a>), which state that:</p>
<div class="packt_quote CDPAlignLeft CDPAlign">"A class should have one, and only one, reason to change."<br/>
                                                                                                                                                                          –<span>Robert C. Martin</span></div>
<p>In this respect, <em>concerns</em> have a wider scope than <em>responsibilities</em>, typically influencing your application's design and architecture rather than individual classes or interfaces. Separation of concerns is essential in a graphical application to correctly detach your easily-tested logic from the presentation code, which manages user interaction.</p>
<p>By separating the concerns of an application, it is easier to test subcomponents and check the validity of our software without even needing to run the application. In doing so, we create more robust applications that can adapt to changes in requirements or technology over time. For example, the graphical toolkit that you choose for your application should not be incorporated into, or impact the design of, your business logic. Consider the GoMail examples that we built in previous chapters; we were able to use different toolkits to display our emails, but the code to manage accessing them was never changed. In this way, we kept the software open to change without a huge impact on unrelated areas.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Suggested application structure</h1>
                </header>
            
            <article>
                
<p>As you plan the development of your application, consider how the core concerns could be separated to maintain flexibility. The following suggested structure should provide some inspiration:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 25.4821%"><kbd>project/</kbd></td>
<td style="width: 69.2837%">The root of the project structure. This package should define the interfaces and utility functions used by the rest of the project. These files should not depend on any sub-packages.</td>
</tr>
<tr>
<td style="width: 25.4821%"><kbd>project/logic/</kbd></td>
<td style="width: 69.2837%">This package will contain most of your application logic. Careful consideration should be given to which functions and types are exposed, as they will form the API that the rest of your application will depend upon. There may be multiple packages that contain application logic as you separate the application's concerns. An alternative, domain-specific term may be preferred to <kbd>logic</kbd>.</td>
</tr>
<tr>
<td style="width: 25.4821%"><kbd>project/storage/</kbd></td>
<td style="width: 69.2837%">Most applications will rely upon a data source of some kind. This package will define one or many possible data sources. They will conform to an interface in the top-level project so that data access can be passed between packages of the project.</td>
</tr>
<tr>
<td style="width: 25.4821%"><kbd>project/gui/</kbd></td>
<td style="width: 69.2837%">This package is the only place where your graphical toolkit should be imported. It is responsible for loading your application GUI and responding to user events. It will probably access data provided by a storage package set from the application runner.</td>
</tr>
<tr>
<td style="width: 25.4821%"><kbd>project/cmd/appname/</kbd></td>
<td style="width: 69.2837%">The Go convention for application binaries is that they reside within a <kbd>cmd/appname</kbd> sub-package. The actual package for this directory will be <kbd>main</kbd>, and it will contain, minimal code that is required to load and run the main application defined within the other packages. It will probably initialize a storage system, load the application logic, and instruct the graphical interface to load.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>When writing tests in each of these packages, they will focus on the functionality of the current package. The <kbd>logic</kbd> package should have very high unit-test coverage, whereas the <kbd>storage</kbd> package may rely more on integration testing (for a refresher on the different types of testing see <a href="https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing">www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing</a>). The <kbd>gui</kbd> package, which is often considered the hardest to test, could directly import the logic package in its tests, but should probably not include the main storage package to validate its functionality. You can read more about the recommended package structure at <a href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1">medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1</a>.</p>
<p>Following a sensible structure will aid significantly in making your application testable, as many developers are probably already aware. It is often much harder, however, to test the graphical portions of an application. Designing your application to be unit-testable from the beginning will often result in a code base that is better organized and will naturally lead to code that is easier to understand and change. Let's take a look at what <strong>Test-driven Development</strong> (<strong>TDD</strong>) can teach us about building graphical interfaces.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test-driving UI development</h1>
                </header>
            
            <article>
                
<p>The effort required to automatically test user interfaces or frontend software is often debated as being far too expensive for the value it returns in avoiding future bugs. However, this is largely rooted in the toolkits being utilized or even the presentation technologies chosen. Without full support for testing in the development tools or graphical APIs, it can indeed be difficult to create simple unit tests without a huge effort. As seen frequently in web-based environments (and some native test frameworks), the only remaining possibility is to run the application and execute test scripts that will perform the validation. They will typically control the user input, simulating mouse actions and keyboard taps, and monitor the resulting behavior of the application under test. If, however, your application and GUI toolkit are architected with testing in mind (for example, using separation of concerns), automated tests should be possible with far less overhead.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designed to be testable</h1>
                </header>
            
            <article>
                
<p class="mce-root">When setting out the components within a project's UI code (as illustrated in the <kbd>gui</kbd> sub-package), care should be taken to define types and classes that have a single responsibility and a clear API. Doing so will make it easier to load and test individual components with the standard Go testing tools. If smaller components can be tested, we we can avoid launching the whole application and the required test runners, therefore making the testing process much faster. When a test suite runs quickly, it can be run more frequently and extended more easily, leading to higher test coverage and greater confidence in the software quality.</p>
<p>For a practical example, let's look at the GoMail compose dialog and its <span class="packt_screen">Send</span> button. Clearly, the dialog box should perform all sorts of validation before sending, and if they pass then send the email. Validation can easily be tested with normal unit tests, but verifying that the send button correctly sends a new email will require the user interface to be tested. In the following example, we will load the compose window, enter some data, and simulate the <span class="packt_screen">Send</span> button being pressed. By using a test email server, as used through each of the GoMail examples, we can check that the email has been sent by the user interface without needing to communicate with a real email server.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example application test</h1>
                </header>
            
            <article>
                
<p><span>We return to the GoMail code of <a href="2476a1b6-0915-496b-8290-7a673f533aca.xhtml">Chapter 10</a>, <em>Fyne – Material-design-based GUI</em> and create a new file, <kbd>compose_test.go</kbd>. As the tests are in the same package, we can test internal function definitions rather than relying on exported APIs—this is common with UI code as long as the application is not large enough to warrant separate packages or libraries. We start by adding the test imports;</span> <kbd>testing</kbd> <span>is required for go test code and </span><kbd>github.com/stretchr/testify/assert</kbd><span> provides helpful assertion functionality. We also import the client email library created for our GoMail examples and finally the Fyne test package, <kbd>fyne.io/fyne/test</kbd>:</span></p>
<pre><span>package </span>main<br/><br/><span>import </span>(<br/>   <span>"testing"<br/></span><span><br/></span><span>   "fyne.io/fyne/test"<br/><br/></span><span>   "github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client"<br/></span><span>   "github.com/stretchr/testify/assert"<br/></span>)</pre>
<p>Now we can add a test method using the recommended naming pattern of <kbd>Test&lt;type&gt;_&lt;function&gt;()</kbd>; normally, the function would be a function name, but here we refer to the button title or its action. In the first part of the function, we set up the compose window for testing by calling <kbd>newCompose()</kbd> and passing it a test application (returned from <kbd>test.NewApp()</kbd>). We then prepare the state for our test—we record the size of the server outbox and set up an <kbd>OnClosed</kbd> handler that will report when the window is closed. Finally, we simulate typing an email address into the <kbd>compose.to</kbd> field using <kbd>test.Type()</kbd>:</p>
<pre><span>func </span>TestCompose_Send(t *testing.T) {<br/>   server := client.NewTestServer()<br/>   compose := newCompose(test.NewApp(), server)<br/>   ui := compose.loadUI()<br/><br/>   pending := len(server.Outbox)<br/>   closed := false<br/>   ui.SetOnClosed(<span>func</span>() {<br/>      closed = <span>true<br/></span><span>   </span>})<br/>   address := <span>"test@example.com"<br/></span><span>   </span>test.Type(compose.to, address)<br/><br/>   ...<br/>}</pre>
<p>Once the setup code is complete, we can implement the main test. This starts by using <kbd>test.Tap()</kbd> to tap the <kbd>compose.send</kbd> button, which should cause an email to be sent. We first verify that the window was <kbd>closed</kbd> after the email send completes (the <kbd>OnClosed</kbd> handler we added records this). Then we check that there is one more email in the <kbd>server.Outbox</kbd> than before.</p>
<p>If these tests pass, we will move to the final check. The email that was sent is extracted from the outbox so we can examine its content. With one final assertion, we verify that the email address matched what we typed into the <em>To</em> input box:</p>
<pre><span>func </span>TestCompose_Send(t *testing.T) {<br/>   ...<br/><br/>   test.Tap(compose.send)<br/>   assert.True(t, closed)<br/>   assert.Equal(t, pending + <span>1</span>, len(server.Outbox))<br/><br/>   email := server.Outbox[len(server.Outbox)-<span>1</span>]<br/>   assert.Equal(t, address, email.ToEmailString())<br/>}</pre>
<p>Running the preceding test will load the user interface in memory, execute the setup code, and run the tests, and then exit with the results. We run the following test with <kbd>-v</kbd> to see each test that is run rather than just a summary. You will notice that testing in this way takes very little time (<kbd>go test</kbd> reports 0.00 seconds for the test and 0.004 seconds in total); therefore, many more tests could be run on a regular basis to verify the application's behavior:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/001ab68e-1d3b-49a8-bf1e-078b52d52720.png" style="width:35.25em;height:10.42em;" width="1110" height="326"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Running the user interface test took very little time</div>
<p>When running the tests, you may notice that this test does not cause any window to be displayed on your computer screen. This is a design feature of many test frameworks for GUI toolkits <span>–</span> it is much faster to run the application without displaying it for test purposes. This is often called <strong>headless</strong> mode and is very useful when running automated tests as part of a <strong>continuous integration</strong> process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Continuous integration for GUIs</h1>
                </header>
            
            <article>
                
<p>Continuous integration (the regular merging of a team's work-in-progress code to be automatically tested) has become commonplace in software-development teams. Adding this process to your team workflow is shown to highlight issues earlier in the development process, which leads to fixing issues faster and, ultimately, better-quality software. A critical part of this is the automation of tests that exercise the whole of the source code, which includes the graphical user interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Approaches to GUI test automation</h1>
                </header>
            
            <article>
                
<p>It is important to organize your code into logical components for development and testing. Using the framework test features (or external support libraries) smaller components can more easily be verified through simple tests. The Go language's built-in support for testing has meant that test coverage is improving; in fact, the popular Go library list, <a href="http://awesome-go.com">awesome-go.com</a>, asks that libraries have a test coverage of at least 80%! GUI toolkits, especially those newer ones discussed in <a href="ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml">Section 3</a>, <em>Modern Graphical Toolkits</em>, need to meet these expectations and allow developers using them to do so as well.</p>
<p>If your chosen framework does not provide the necessary support, it is still possible to automate functional testing. The technique involves running the application from a test script that then performs simulated user actions on the host computer. This is not ideal as it requires the application to be visible on the screen and for the test script to take control of the keyboard and mouse <span>–</span> but it is better than having no GUI testing in place. To work around this inconvenience, it is possible to load a virtual frame buffer (an off-screen display area) in which to run the application. This technique basically creates an invisible <em>screen</em> to which the application can draw. Such approaches are typically supported by commercial continuous-integration servers, but setting them up is outside the scope of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Avoiding external dependencies</h1>
                </header>
            
            <article>
                
<p>One thing to be aware of when testing an application, or portions of it, is that there may be external systems involved. A file browser may rely on network connections for some of its work, or an instant messenger app is going to need a server to handle sending and receiving messages. If your code has been organized carefully to separate its concerns, you will already have used interfaces to define the interactions between different components. If this approach is taken, we can use <em>dependency injection</em> to provide alternative implementations for areas of an application that should not be included in automated testing.</p>
<div class="packt_quote CDPAlignLeft CDPAlign"><span>"One of the main goals of decomposing complex problems into smaller modules and implementing these modules are dependencies. A module that relies heavily on a underlying technology or platform is less reusable and makes changes to software complex and expensive."<br/>
                         –<a href="http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dependency_injection.html">http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dependency_injection.html</a></span></div>
<p>When code is properly decoupled from the components that it relies on, it's possible to load different versions of an application for testing. In this manner, we can avoid relying on any external systems or causing permanent changes to a data store. Let's look at a trivial example, a <kbd>Storage interface</kbd> is defined that will be used to read and write files from a disk:</p>
<pre><span>type </span>Storage <span>interface </span>{<br/>   Read(name string) string<br/>   Write(name, content string)<br/>}</pre>
<p>There is an application runner that invokes a permanent storage and uses it to write and then read a file:</p>
<pre><span>func </span>runApp(storage Storage) {<br/>   log.Println(<span>"Writing README.txt"</span>)<br/>   storage.Write(<span>"README.txt"</span>, <span>"overwrite"</span>)<br/><br/>   log.Println(<span>"Reading README.txt"</span>)<br/>   log.Println(storage.Read(<span>"README.txt"</span>))<br/>}<br/><br/><span>func </span>main() {<br/>   runApp(NewPermanentStorage())<br/>}</pre>
<p>Clearly, this application will cause whatever was in an existing <kbd>README.txt</kbd> file to be overwritten with the contents of <kbd>overwrite</kbd>. If we assume, for example, that this is the desired behavior, we probably don't want this external system (the disk) to be affected by our tests. Because we have designed the storage to conform to an interface, our test code can include a different storage system that we can use in tests, as follows:</p>
<pre><span>type </span>testStorage <span>struct </span>{<br/>   items <span>map</span>[string]string<br/>}<br/><br/><span>func </span>(t *testStorage) Read(name string) string {<br/>   <span>return </span>t.items[name]<br/>}<br/><br/><span>func </span>(t *testStorage) Write(name, content string) {<br/>   t.items[name] = content<br/>}<br/><br/><span>func </span>newTestStorage() Storage {<br/>   store := &amp;testStorage{}<br/>   store.items = make(<span>map</span>[string]string)<br/>   <span>return </span>store<br/>}</pre>
<p>Following this addition, we can test our application's <kbd>runApp</kbd> function without the risk of overwriting real files:</p>
<pre><span>import </span>(<br/>   <span>"testing"<br/></span><span><br/></span><span>   "github.com/stretchr/testify/assert"<br/></span>)<br/><br/><span>func </span>TestMain_RunApp(t *testing.T) {<br/>   testStore := newTestStorage()<br/>   runApp(testStore)<br/><br/>   newFile := testStore.Read(<span>"README.txt"</span>)<br/>   assert.Equal(t, <span>"overwrite"</span>, newFile)<br/>}</pre>
<p>When running this test, you will see that we get the expected result, and should also notice that no real files have changed. The code from this sample is also available in the book's source code repository in the <kbd>chapter13/ci</kbd> folder:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/5cc2f1a0-41b4-4e06-af21-da3ef77b0ad3.png" style="width:33.42em;height:15.92em;" width="1110" height="528"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">See that our TestMain_RunApp completed successfully without writing to our disk</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing platform specifics</h1>
                </header>
            
            <article>
                
<p>Back in <a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml">Chapter 3</a>, <em>Go to the Rescue!</em>, we saw that the Go compiler has built-in support for the conditional inclusion of source files based on a system of environment variables and build tags. As an application adds more functionality, especially from a platform-integration perspective, it is possible that the toolkit you have chosen will not provide all of the functionality you are looking for. When this happens, the code will need to be updated to handle platform-specific functionality. To do so, we will use a variation of the conditional build <span>–</span> using well-named files instead of build tags (as used in <a href="03c04362-6937-47f3-a2de-cd99d9ae9080.xhtml">Chapter 11</a>, <em>Navigation and Multiple Windows</em>). This is easier to read at the project level and should indicate clearly which files will be compiled for which platform.</p>
<p>Let's create a simple example: we want to show a notification, but our code only has the ability to do so on macOS (darwin). We will set up a simple <kbd>notify()</kbd> function that does what we want in the <kbd>notification_darwin.go</kbd> file:</p>
<pre>package main<br/><br/>import (<br/>   "log"<br/>   "os/exec"<br/>)<br/><br/>func notify(title, content string) {<br/>   cmd := exec.Command("osascript", "-e", "display notification \""+content+<br/>      "\" with title \""+title+"\"")<br/>   err := cmd.Run()<br/><br/>   if err != nil {<br/>      log.Printf("Error showing notification: %v", err)<br/>   }<br/>}</pre>
<p>This simple function calls out to the <kbd>osascript</kbd> tool, a command-line application bundled with macOS that allows the execution of system scripts. As this file ends with the name <kbd>_darwin.go</kbd>, it will only be compiled when we are building for macOS. To compile correctly when building on other platforms, we need to create another file that will be loaded instead, we will call it <kbd>notification_other.go</kbd>:</p>
<pre>// +build !darwin<br/><br/>package main<br/><br/>import "log"<br/><br/>func notify(title, content string) {<br/>   log.Println("Notifications not supported")<br/>}</pre>
<p>In this file, we must specify the build condition, as there is no special filename format for <em>all other</em> <em>platforms</em>; here, <kbd>// +build !darwin</kbd> means that the file will be included on any platform other than macOS. The method we provide in this file simply logs that the feature is not supported. Finally, we create a simple application launcher named <kbd>main.go</kbd> that will call the <kbd>notify()</kbd> function:</p>
<pre>package main<br/><br/>func main() {<br/>   notify("Email", "A new email arrived")<br/>}</pre>
<p>Running this code on macOS will result in the expected notification appearing:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d2702c7d-ca30-46bb-8063-9c3275add060.png" style="width:24.08em;height:5.25em;" width="620" height="135"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Our simple notification appearing on macOS</div>
<p>On any other operating system, it will log the fallback error message:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/2a765143-4c9d-4125-8c85-811d72dc25ab.png" style="width:24.92em;height:6.08em;" width="754" height="186"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">When run on Linux (or Windows or others) we just see the log message</div>
<p>We can handle platform-specific code in a way that should be clear to anyone learning the source code. Another developer could decide to add a <kbd>notification_windows.go</kbd> file to add support for notifications on Windows. As long as they also update the build rules in <kbd>notification_other.go</kbd>, the application will continue to work as expected but with the addition of Windows-based notifications. The benefit of this approach is that it did not require any modifications of existing code to add this new functionality.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored some of the tips and techniques for managing a GUI-based application written with Go. By carefully planning the modules of an application and how they interact, we saw that we can make it easier to test and maintain. As higher test coverage is a factor in increasing the quality of software applications, we looked at how we can use these techniques to test our graphical code, which is a notoriously difficult topic. We stepped through an example of writing test code for a simple GUI application that could be run automatically.</p>
<p>From these basic concepts, we looked at how to prepare an application for regular automated testing to constantly check the code for errors (a technique called <strong>Continuous Integration</strong>). By leveraging a well-modularized code base, we can avoid relying on external services or creating accidental side effects when testing our software. We saw how <strong>Dependency Injection</strong> can improve our test reliability and speed up the process for more immediate feedback. Finally, we saw how to apply our knowledge to handling operating-system-specific functionality within our graphical apps.</p>
<p>In the next, and final, chapter, we will look into the last step of the development process: packaging and sharing the compiled application. We will explore the various options available for each platform and how these channels can benefit, or complicate, our cross-platform strategy.</p>


            </article>

            
        </section>
    </div>



  </body></html>