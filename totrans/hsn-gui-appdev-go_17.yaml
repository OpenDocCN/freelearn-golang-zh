- en: Best Practices in Go GUI Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go GUI开发的最佳实践
- en: The Go language has well-defined practices for formatting, documentation, and
    code structure. You can find these referenced in many places, for example, [https://golang.org/doc/effective_go.html#formatting](https://golang.org/doc/effective_go.html#formatting)
    and [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments).
    Additionally, there is a strong community drive to encourage writing idiomatic
    Go, such as [https://dmitri.shuralyov.com/idiomatic-go](https://dmitri.shuralyov.com/idiomatic-go).
    Many of these design decisions are encoded in tools such as `gofmt` and `golint`,
    which makes it easy for people to learn and maintain standardized code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有明确的格式化、文档和代码结构实践。您可以在许多地方找到这些参考，例如，[https://golang.org/doc/effective_go.html#formatting](https://golang.org/doc/effective_go.html#formatting)
    和 [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)。此外，有一个强大的社区推动编写惯用的Go语言，例如
    [https://dmitri.shuralyov.com/idiomatic-go](https://dmitri.shuralyov.com/idiomatic-go)。许多这些设计决策都编码在工具如`gofmt`和`golint`中，这使得人们学习并维护标准化代码变得容易。
- en: 'In this chapter, we will look beyond these code standards and common conventions
    to focus on the aspects of best practice that make it easier to maintain and grow
    GUI-based applications. We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将超越这些代码标准和常见约定，专注于使基于GUI的应用程序更容易维护和扩展的最佳实践方面。我们将涵盖以下主题：
- en: Separation of concerns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: Test-driving UI development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动UI开发的测试
- en: Continuous integration for GUIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI的持续集成
- en: Managing platform specifics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理平台特定性
- en: The addition of graphical elements to an application often makes it harder to
    test. In this chapter, we will see that with the correct preparation and structure,
    we can overcome these challenges and make our code robust and easy to change.
    Let's start by looking at how to structure a GUI-based application for maintainability.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中添加图形元素通常会使其测试变得更加困难。在本章中，我们将看到，通过正确的准备和结构，我们可以克服这些挑战，并使我们的代码更加健壮和易于更改。让我们首先看看如何为可维护性构建基于GUI的应用程序的结构。
- en: Separation of concerns
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: 'The concept is closely related to the *Single Responsibility Principle* introduced
    by Robert C. Martin in his principles of Object Oriented Design ([butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)),
    which state that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念与罗伯特·C·马丁在其面向对象设计原则中引入的*单一责任原则*密切相关 ([butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod))，该原则指出：
- en: '"A class should have one, and only one, reason to change."'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “一个类应该只有一个，且仅有一个，改变的理由。”
- en: –Robert C. Martin
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: –罗伯特·C·马丁
- en: In this respect, *concerns* have a wider scope than *responsibilities*, typically
    influencing your application's design and architecture rather than individual
    classes or interfaces. Separation of concerns is essential in a graphical application
    to correctly detach your easily-tested logic from the presentation code, which
    manages user interaction.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，*关注点*比*责任*具有更广泛的范围，通常影响您的应用程序的设计和架构，而不是单个类或接口。在图形应用程序中，分离关注点是必要的，以便正确地将易于测试的逻辑与处理用户交互的表示代码分离。
- en: By separating the concerns of an application, it is easier to test subcomponents
    and check the validity of our software without even needing to run the application.
    In doing so, we create more robust applications that can adapt to changes in requirements
    or technology over time. For example, the graphical toolkit that you choose for
    your application should not be incorporated into, or impact the design of, your
    business logic. Consider the GoMail examples that we built in previous chapters;
    we were able to use different toolkits to display our emails, but the code to
    manage accessing them was never changed. In this way, we kept the software open
    to change without a huge impact on unrelated areas.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离应用程序的关注点，我们可以更容易地测试子组件并验证我们软件的有效性，甚至不需要运行应用程序。这样做，我们创建了更健壮的应用程序，这些应用程序可以随着时间的推移适应需求或技术的变化。例如，您为应用程序选择图形工具包时，不应将其纳入或影响您的业务逻辑设计。考虑我们在前几章中构建的GoMail示例；我们能够使用不同的工具包来显示我们的电子邮件，但管理访问它们的代码从未更改。这样，我们在不影响相关区域的情况下，保持了软件的开放性，易于更改。
- en: Suggested application structure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议的应用结构
- en: 'As you plan the development of your application, consider how the core concerns
    could be separated to maintain flexibility. The following suggested structure
    should provide some inspiration:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划应用程序的开发时，考虑如何将核心关注点分离以保持灵活性。以下建议的结构应提供一些灵感：|
- en: '| `project/` | The root of the project structure. This package should define
    the interfaces and utility functions used by the rest of the project. These files
    should not depend on any sub-packages. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `project/` | 项目结构的根目录。此包应定义其余项目使用的接口和实用函数。这些文件不应依赖于任何子包。|'
- en: '| `project/logic/` | This package will contain most of your application logic.
    Careful consideration should be given to which functions and types are exposed,
    as they will form the API that the rest of your application will depend upon.
    There may be multiple packages that contain application logic as you separate
    the application''s concerns. An alternative, domain-specific term may be preferred
    to `logic`. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `project/logic/` | 此包将包含大部分应用程序逻辑。应仔细考虑哪些函数和类型被暴露，因为它们将形成其余应用程序所依赖的 API。随着你将应用程序的关注点分离，可能会有多个包含应用程序逻辑的包。可能更倾向于使用特定领域的术语来代替
    `logic`。|'
- en: '| `project/storage/` | Most applications will rely upon a data source of some
    kind. This package will define one or many possible data sources. They will conform
    to an interface in the top-level project so that data access can be passed between
    packages of the project. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `project/storage/` | 大多数应用程序都将依赖于某种类型的数据源。此包将定义一个或多个可能的数据源。它们将符合顶级项目中的接口，以便在项目中的包之间传递数据访问。|'
- en: '| `project/gui/` | This package is the only place where your graphical toolkit
    should be imported. It is responsible for loading your application GUI and responding
    to user events. It will probably access data provided by a storage package set
    from the application runner. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `project/gui/` | 此包是唯一导入图形工具包的地方。它负责加载应用程序的 GUI 并响应用户事件。它可能会访问由应用程序运行器设置的存储包提供的数据。|'
- en: '| `project/cmd/appname/` | The Go convention for application binaries is that
    they reside within a `cmd/appname` sub-package. The actual package for this directory
    will be `main`, and it will contain, minimal code that is required to load and
    run the main application defined within the other packages. It will probably initialize
    a storage system, load the application logic, and instruct the graphical interface
    to load. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `project/cmd/appname/` | Go 语言中应用程序二进制的约定是它们位于 `cmd/appname` 子包中。该目录的实际包将是
    `main`，它将包含加载和运行其他包中定义的主要应用程序所需的最低限度的代码。它可能会初始化一个存储系统，加载应用程序逻辑，并指示图形界面进行加载。|'
- en: When writing tests in each of these packages, they will focus on the functionality
    of the current package. The `logic` package should have very high unit-test coverage,
    whereas the `storage` package may rely more on integration testing (for a refresher
    on the different types of testing see [www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing](https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing)).
    The `gui` package, which is often considered the hardest to test, could directly
    import the logic package in its tests, but should probably not include the main
    storage package to validate its functionality. You can read more about the recommended
    package structure at [medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在为这些包中的每一个编写测试时，它们将关注当前包的功能。`logic` 包应该有非常高的单元测试覆盖率，而 `storage` 包可能更多地依赖于集成测试（关于不同类型测试的复习，请参阅
    [www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing](https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing)）。通常被认为最难测试的
    `gui` 包可以在其测试中直接导入逻辑包，但可能不应该包含主存储包以验证其功能。您可以在 [medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1)
    上了解更多关于推荐包结构的建议。|
- en: Following a sensible structure will aid significantly in making your application
    testable, as many developers are probably already aware. It is often much harder,
    however, to test the graphical portions of an application. Designing your application
    to be unit-testable from the beginning will often result in a code base that is
    better organized and will naturally lead to code that is easier to understand
    and change. Let's take a look at what **Test-driven Development** (**TDD**) can
    teach us about building graphical interfaces.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循合理的结构将极大地帮助使你的应用程序可测试，正如许多开发者可能已经意识到的。然而，测试应用程序的图形部分通常要困难得多。从一开始就设计你的应用程序以便进行单元测试，通常会得到一个组织得更好的代码库，并自然地导致代码更容易理解和修改。让我们看看**测试驱动开发**（**TDD**）能教给我们关于构建图形界面的哪些东西。
- en: Test-driving UI development
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动UI开发
- en: The effort required to automatically test user interfaces or frontend software
    is often debated as being far too expensive for the value it returns in avoiding
    future bugs. However, this is largely rooted in the toolkits being utilized or
    even the presentation technologies chosen. Without full support for testing in
    the development tools or graphical APIs, it can indeed be difficult to create
    simple unit tests without a huge effort. As seen frequently in web-based environments
    (and some native test frameworks), the only remaining possibility is to run the
    application and execute test scripts that will perform the validation. They will
    typically control the user input, simulating mouse actions and keyboard taps,
    and monitor the resulting behavior of the application under test. If, however,
    your application and GUI toolkit are architected with testing in mind (for example,
    using separation of concerns), automated tests should be possible with far less
    overhead.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自动测试用户界面或前端软件所需付出的努力常常被争论为代价过高，因为它在避免未来错误方面所提供的价值。然而，这很大程度上源于所使用的工具包或甚至所选择的表现技术。如果没有开发工具或图形API对测试的全面支持，确实很难在没有巨大努力的情况下创建简单的单元测试。正如在基于Web的环境（以及一些本地测试框架）中经常看到的那样，唯一剩下的可能性就是运行应用程序并执行测试脚本，这些脚本将执行验证。它们通常会控制用户输入，模拟鼠标动作和键盘敲击，并监控被测试应用程序的结果行为。然而，如果你的应用程序和GUI工具包在设计时考虑了测试（例如，使用关注点分离），那么使用更少的开销进行自动化测试应该是可能的。
- en: Designed to be testable
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计为可测试
- en: When setting out the components within a project's UI code (as illustrated in
    the `gui` sub-package), care should be taken to define types and classes that
    have a single responsibility and a clear API. Doing so will make it easier to
    load and test individual components with the standard Go testing tools. If smaller
    components can be tested, we we can avoid launching the whole application and
    the required test runners, therefore making the testing process much faster. When
    a test suite runs quickly, it can be run more frequently and extended more easily,
    leading to higher test coverage and greater confidence in the software quality.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置项目UI代码中的组件（如图`gui`子包所示）时，应小心定义具有单一责任和清晰API的类型和类。这样做将使使用标准的Go测试工具加载和测试单个组件变得更容易。如果可以测试较小的组件，我们就可以避免启动整个应用程序和所需的测试运行器，从而使测试过程更快。当测试套件运行得快时，它可以更频繁地运行并更容易扩展，从而导致更高的测试覆盖率和更大的软件质量信心。
- en: For a practical example, let's look at the GoMail compose dialog and its Send
    button. Clearly, the dialog box should perform all sorts of validation before
    sending, and if they pass then send the email. Validation can easily be tested
    with normal unit tests, but verifying that the send button correctly sends a new
    email will require the user interface to be tested. In the following example,
    we will load the compose window, enter some data, and simulate the Send button
    being pressed. By using a test email server, as used through each of the GoMail
    examples, we can check that the email has been sent by the user interface without
    needing to communicate with a real email server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个实际的例子，让我们看看GoMail的撰写对话框及其发送按钮。显然，对话框在发送之前应该执行各种验证，如果验证通过，则发送电子邮件。验证可以通过正常的单元测试轻松测试，但验证发送按钮是否正确发送新电子邮件则需要测试用户界面。在下面的示例中，我们将加载撰写窗口，输入一些数据，并模拟按下发送按钮。通过使用GoMail示例中使用的测试电子邮件服务器，我们可以检查用户界面是否已发送电子邮件，而无需与真实的电子邮件服务器通信。
- en: Example application test
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用程序测试
- en: 'We return to the GoMail code of [Chapter 10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml),
    *Fyne – Material-design-based GUI* and create a new file, `compose_test.go`. As
    the tests are in the same package, we can test internal function definitions rather
    than relying on exported APIs—this is common with UI code as long as the application
    is not large enough to warrant separate packages or libraries. We start by adding
    the test imports; `testing` is required for go test code and `github.com/stretchr/testify/assert` provides
    helpful assertion functionality. We also import the client email library created
    for our GoMail examples and finally the Fyne test package, `fyne.io/fyne/test`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到[第10章](2476a1b6-0915-496b-8290-7a673f533aca.xhtml)的GoMail代码，*Fyne – 基于 Material-design
    的 GUI*，并创建一个新文件，`compose_test.go`。由于测试在同一个包中，我们可以测试内部函数定义，而不是依赖于导出的API——只要应用程序足够小，不需要单独的包或库，这种情况在UI代码中很常见。我们首先添加测试导入；`testing`
    是 go test 代码所必需的，而 `github.com/stretchr/testify/assert` 提供了有用的断言功能。我们还导入了为我们的
    GoMail 示例创建的客户端电子邮件库，最后是 Fyne 测试包，`fyne.io/fyne/test`：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can add a test method using the recommended naming pattern of `Test<type>_<function>()`;
    normally, the function would be a function name, but here we refer to the button
    title or its action. In the first part of the function, we set up the compose
    window for testing by calling `newCompose()` and passing it a test application
    (returned from `test.NewApp()`). We then prepare the state for our test—we record
    the size of the server outbox and set up an `OnClosed` handler that will report
    when the window is closed. Finally, we simulate typing an email address into the
    `compose.to` field using `test.Type()`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个测试方法，使用推荐的命名模式 `Test<type>_<function>()`；通常，函数名会是函数名，但在这里我们指的是按钮标题或其动作。在函数的第一部分，我们通过调用
    `newCompose()` 并传递一个测试应用程序（由 `test.NewApp()` 返回）来设置测试的编辑窗口。然后我们为测试准备状态——我们记录服务器发件箱的大小，并设置一个
    `OnClosed` 处理器，当窗口关闭时会报告。最后，我们使用 `test.Type()` 模拟在 `compose.to` 字段中输入电子邮件地址：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the setup code is complete, we can implement the main test. This starts
    by using `test.Tap()` to tap the `compose.send` button, which should cause an
    email to be sent. We first verify that the window was `closed` after the email
    send completes (the `OnClosed` handler we added records this). Then we check that
    there is one more email in the `server.Outbox` than before.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置代码完成，我们就可以实现主要的测试。这首先是通过使用 `test.Tap()` 点击 `compose.send` 按钮，这将导致发送电子邮件。我们首先验证在电子邮件发送完成后窗口是否已
    `关闭`（我们添加的 `OnClosed` 处理器记录了这一点）。然后我们检查 `server.Outbox` 中的电子邮件比之前多一个。
- en: 'If these tests pass, we will move to the final check. The email that was sent
    is extracted from the outbox so we can examine its content. With one final assertion,
    we verify that the email address matched what we typed into the *To* input box:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些测试通过，我们将进行最终检查。发送的电子邮件是从发件箱中提取出来的，这样我们可以检查其内容。通过一个最终的断言，我们验证电子邮件地址与我们输入到
    *To* 输入框中的内容相匹配：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the preceding test will load the user interface in memory, execute
    the setup code, and run the tests, and then exit with the results. We run the
    following test with `-v` to see each test that is run rather than just a summary.
    You will notice that testing in this way takes very little time (`go test` reports
    0.00 seconds for the test and 0.004 seconds in total); therefore, many more tests
    could be run on a regular basis to verify the application''s behavior:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的测试将在内存中加载用户界面，执行设置代码，并运行测试，然后退出并显示结果。我们使用 `-v` 运行以下测试，以便查看每个运行的测试，而不仅仅是总结。您会注意到以这种方式进行测试花费的时间非常少（`go
    test` 报告测试耗时为 0.00 秒，总耗时为 0.004 秒）；因此，可以定期运行更多测试以验证应用程序的行为：
- en: '![](img/001ab68e-1d3b-49a8-bf1e-078b52d52720.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/001ab68e-1d3b-49a8-bf1e-078b52d52720.png)'
- en: Running the user interface test took very little time
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行用户界面测试花费的时间非常少
- en: When running the tests, you may notice that this test does not cause any window
    to be displayed on your computer screen. This is a design feature of many test
    frameworks for GUI toolkits – it is much faster to run the application without
    displaying it for test purposes. This is often called **headless** mode and is
    very useful when running automated tests as part of a **continuous integration**
    process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，您可能会注意到这个测试不会在您的计算机屏幕上显示任何窗口。这是许多 GUI 工具包测试框架的设计特性——对于测试目的，不显示应用程序运行要快得多。这通常被称为
    **无头** 模式，当作为 **持续集成** 过程的一部分运行自动化测试时非常有用。
- en: Continuous integration for GUIs
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI的持续集成
- en: Continuous integration (the regular merging of a team's work-in-progress code
    to be automatically tested) has become commonplace in software-development teams.
    Adding this process to your team workflow is shown to highlight issues earlier
    in the development process, which leads to fixing issues faster and, ultimately,
    better-quality software. A critical part of this is the automation of tests that
    exercise the whole of the source code, which includes the graphical user interface.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（定期将团队的工作进行中的代码合并以自动测试）已成为软件开发团队的常态。将此过程添加到您的团队工作流程中已被证明可以更早地突出显示开发过程中的问题，这有助于更快地修复问题，并最终产生高质量的软件。这部分的关键是自动化测试，这些测试会测试整个源代码，包括图形用户界面。
- en: Approaches to GUI test automation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI测试自动化的方法
- en: It is important to organize your code into logical components for development
    and testing. Using the framework test features (or external support libraries)
    smaller components can more easily be verified through simple tests. The Go language's
    built-in support for testing has meant that test coverage is improving; in fact,
    the popular Go library list, [awesome-go.com](http://awesome-go.com), asks that
    libraries have a test coverage of at least 80%! GUI toolkits, especially those
    newer ones discussed in [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits*, need to meet these expectations and allow developers using
    them to do so as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码组织成逻辑组件以进行开发和测试是很重要的。使用框架测试功能（或外部支持库），较小的组件可以通过简单的测试更容易地得到验证。Go语言内置的测试支持意味着测试覆盖率正在提高；事实上，流行的Go库列表[awesome-go.com](http://awesome-go.com)要求库至少有80%的测试覆盖率！GUI工具包，尤其是[第3节](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml)中讨论的新工具包，需要满足这些期望，并允许使用它们的开发者也能做到这一点。
- en: If your chosen framework does not provide the necessary support, it is still
    possible to automate functional testing. The technique involves running the application
    from a test script that then performs simulated user actions on the host computer.
    This is not ideal as it requires the application to be visible on the screen and
    for the test script to take control of the keyboard and mouse – but it is better
    than having no GUI testing in place. To work around this inconvenience, it is
    possible to load a virtual frame buffer (an off-screen display area) in which
    to run the application. This technique basically creates an invisible *screen*
    to which the application can draw. Such approaches are typically supported by
    commercial continuous-integration servers, but setting them up is outside the
    scope of this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择的框架不提供必要的支持，仍然可以自动化功能测试。这种技术涉及从测试脚本中运行应用程序，然后在该主机计算机上执行模拟用户操作。这并不是理想的做法，因为它要求应用程序在屏幕上可见，并且测试脚本需要控制键盘和鼠标——但比没有GUI测试要好。为了克服这种不便，可以在其中运行应用程序的虚拟帧缓冲区（一个离屏显示区域）。这种技术基本上创建了一个不可见的*屏幕*，应用程序可以将其绘制。这些方法通常由商业持续集成服务器支持，但设置它们超出了本书的范围。
- en: Avoiding external dependencies
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免外部依赖
- en: One thing to be aware of when testing an application, or portions of it, is
    that there may be external systems involved. A file browser may rely on network
    connections for some of its work, or an instant messenger app is going to need
    a server to handle sending and receiving messages. If your code has been organized
    carefully to separate its concerns, you will already have used interfaces to define
    the interactions between different components. If this approach is taken, we can
    use *dependency injection* to provide alternative implementations for areas of
    an application that should not be included in automated testing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试应用程序或其部分时，需要注意的一点是可能涉及外部系统。文件浏览器可能依赖于网络连接来完成一些工作，或者即时通讯应用将需要一个服务器来处理发送和接收消息。如果您的代码已经精心组织以分离其关注点，您已经使用了接口来定义不同组件之间的交互。如果采取这种方法，我们可以使用*依赖注入*来为不应包含在自动化测试中的应用程序区域提供替代实现。
- en: '"One of the main goals of decomposing complex problems into smaller modules
    and implementing these modules are dependencies. A module that relies heavily
    on a underlying technology or platform is less reusable and makes changes to software
    complex and expensive."'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “将复杂问题分解成更小的模块并实现这些模块的主要目标之一是依赖。一个高度依赖于底层技术或平台的模块可重用性较低，并且使软件的更改变得复杂和昂贵。”
- en: –[http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dependency_injection.html](http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dependency_injection.html)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: –[http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dependency_injection.html](http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dependency_injection.html)
- en: 'When code is properly decoupled from the components that it relies on, it''s
    possible to load different versions of an application for testing. In this manner,
    we can avoid relying on any external systems or causing permanent changes to a
    data store. Let''s look at a trivial example, a `Storage interface` is defined
    that will be used to read and write files from a disk:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码正确地与它所依赖的组件解耦时，就有可能为测试加载应用程序的不同版本。以这种方式，我们可以避免依赖任何外部系统或对数据存储造成永久性更改。让我们看看一个简单的例子，定义了一个`Storage接口`，它将被用来从磁盘读取和写入文件：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is an application runner that invokes a permanent storage and uses it
    to write and then read a file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个应用程序运行器调用一个永久存储，并使用它来写入然后读取一个文件：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Clearly, this application will cause whatever was in an existing `README.txt`
    file to be overwritten with the contents of `overwrite`. If we assume, for example,
    that this is the desired behavior, we probably don''t want this external system
    (the disk) to be affected by our tests. Because we have designed the storage to
    conform to an interface, our test code can include a different storage system
    that we can use in tests, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个应用程序将会覆盖现有的`README.txt`文件中的内容，将其替换为`overwrite`的内容。如果我们假设，例如，这是期望的行为，我们可能不希望这个外部系统（磁盘）受到我们的测试的影响。因为我们已经设计存储来符合接口，我们的测试代码可以包含一个不同的存储系统，我们可以在测试中使用它，如下所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Following this addition, we can test our application''s `runApp` function without
    the risk of overwriting real files:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此添加之后，我们可以测试应用程序的`runApp`函数，而不会覆盖真实文件的风险：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When running this test, you will see that we get the expected result, and should
    also notice that no real files have changed. The code from this sample is also
    available in the book''s source code repository in the `chapter13/ci` folder:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这个测试时，你会看到我们得到了预期的结果，同时也应该注意到没有任何实际文件被更改。这个示例中的代码也包含在书的源代码仓库中的`chapter13/ci`文件夹里：
- en: '![](img/5cc2f1a0-41b4-4e06-af21-da3ef77b0ad3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5cc2f1a0-41b4-4e06-af21-da3ef77b0ad3.png)'
- en: See that our TestMain_RunApp completed successfully without writing to our disk
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 确认我们的TestMain_RunApp测试成功完成，没有写入我们的磁盘
- en: Managing platform specifics
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理平台特定性
- en: Back in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the
    Rescue!*, we saw that the Go compiler has built-in support for the conditional
    inclusion of source files based on a system of environment variables and build
    tags. As an application adds more functionality, especially from a platform-integration
    perspective, it is possible that the toolkit you have chosen will not provide
    all of the functionality you are looking for. When this happens, the code will
    need to be updated to handle platform-specific functionality. To do so, we will
    use a variation of the conditional build – using well-named files instead of build
    tags (as used in [Chapter 11](03c04362-6937-47f3-a2de-cd99d9ae9080.xhtml), *Navigation
    and Multiple Windows*). This is easier to read at the project level and should
    indicate clearly which files will be compiled for which platform.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml)，*Go to the Rescue!*中，我们看到了Go编译器内置了对基于环境变量和构建标签的源文件条件包含的支持。随着应用程序功能的增加，尤其是从平台集成角度来看，你选择的工具包可能无法提供你所需的所有功能。当这种情况发生时，代码需要更新以处理特定平台的功能。为此，我们将使用条件构建的变体——使用命名良好的文件而不是构建标签（如[第11章](03c04362-6937-47f3-a2de-cd99d9ae9080.xhtml)，*Navigation
    and Multiple Windows*中使用的那样）。这在项目级别上更容易阅读，并且应该清楚地表明哪些文件将被编译用于哪个平台。
- en: 'Let''s create a simple example: we want to show a notification, but our code
    only has the ability to do so on macOS (darwin). We will set up a simple `notify()`
    function that does what we want in the `notification_darwin.go` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的例子：我们想要显示一个通知，但我们的代码只能在macOS（darwin）上这样做。我们将在`notification_darwin.go`文件中设置一个简单的`notify()`函数，以实现我们想要的功能：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This simple function calls out to the `osascript` tool, a command-line application
    bundled with macOS that allows the execution of system scripts. As this file ends
    with the name `_darwin.go`, it will only be compiled when we are building for
    macOS. To compile correctly when building on other platforms, we need to create
    another file that will be loaded instead, we will call it `notification_other.go`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数调用了`osascript`工具，这是一个与macOS捆绑的命令行应用程序，允许执行系统脚本。由于此文件以名称`_darwin.go`结尾，它只有在为macOS构建时才会被编译。为了在其他平台上正确编译，我们需要创建另一个将被加载的文件，我们将称之为`notification_other.go`：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this file, we must specify the build condition, as there is no special filename
    format for *all other* *platforms*; here, `// +build !darwin` means that the file
    will be included on any platform other than macOS. The method we provide in this
    file simply logs that the feature is not supported. Finally, we create a simple
    application launcher named `main.go` that will call the `notify()` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们必须指定构建条件，因为没有为所有其他平台指定特殊的文件名格式；这里，`// +build !darwin`表示该文件将包含在任何除macOS以外的平台上。我们在这个文件中提供的简单方法只是记录该功能不受支持。最后，我们创建了一个名为`main.go`的简单应用程序启动器，它将调用`notify()`函数：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running this code on macOS will result in the expected notification appearing:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上运行此代码将导致出现预期的通知：
- en: '![](img/d2702c7d-ca30-46bb-8063-9c3275add060.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2702c7d-ca30-46bb-8063-9c3275add060.png)'
- en: Our simple notification appearing on macOS
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的通知出现在macOS上
- en: 'On any other operating system, it will log the fallback error message:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他操作系统上，它将记录回退错误信息：
- en: '![](img/2a765143-4c9d-4125-8c85-811d72dc25ab.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a765143-4c9d-4125-8c85-811d72dc25ab.png)'
- en: When run on Linux (or Windows or others) we just see the log message
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Linux（或Windows或其他操作系统）上运行时，我们只看到日志消息
- en: We can handle platform-specific code in a way that should be clear to anyone
    learning the source code. Another developer could decide to add a `notification_windows.go` file
    to add support for notifications on Windows. As long as they also update the build
    rules in `notification_other.go`, the application will continue to work as expected
    but with the addition of Windows-based notifications. The benefit of this approach
    is that it did not require any modifications of existing code to add this new
    functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以一种对学习源代码的人来说清晰易懂的方式处理特定平台的代码。另一位开发者可以选择添加一个`notification_windows.go`文件来支持Windows上的通知。只要他们也更新了`notification_other.go`中的构建规则，应用程序将继续按预期工作，但会添加基于Windows的通知。这种方法的优点是，它不需要对现有代码进行任何修改来添加这个新功能。
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored some of the tips and techniques for managing a
    GUI-based application written with Go. By carefully planning the modules of an
    application and how they interact, we saw that we can make it easier to test and
    maintain. As higher test coverage is a factor in increasing the quality of software
    applications, we looked at how we can use these techniques to test our graphical
    code, which is a notoriously difficult topic. We stepped through an example of
    writing test code for a simple GUI application that could be run automatically.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用Go编写的基于GUI的应用程序的一些管理和技巧。通过仔细规划应用程序的模块及其交互方式，我们看到了我们可以使其更容易测试和维护。由于更高的测试覆盖率是提高软件应用程序质量的因素之一，我们探讨了如何使用这些技术来测试我们的图形代码，这是一个众所周知难以处理的话题。我们逐步分析了为简单GUI应用程序编写测试代码的示例，该代码可以自动运行。
- en: From these basic concepts, we looked at how to prepare an application for regular
    automated testing to constantly check the code for errors (a technique called
    **Continuous Integration**). By leveraging a well-modularized code base, we can
    avoid relying on external services or creating accidental side effects when testing
    our software. We saw how **Dependency Injection** can improve our test reliability
    and speed up the process for more immediate feedback. Finally, we saw how to apply
    our knowledge to handling operating-system-specific functionality within our graphical
    apps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些基本概念出发，我们探讨了如何为常规自动化测试准备应用程序，以不断检查代码中的错误（称为**持续集成**）。通过利用良好的模块化代码库，我们可以避免在测试软件时依赖外部服务或产生意外的副作用。我们看到了**依赖注入**如何提高我们的测试可靠性和加快反馈过程。最后，我们看到了如何将我们的知识应用于处理图形应用程序中的操作系统特定功能。
- en: 'In the next, and final, chapter, we will look into the last step of the development
    process: packaging and sharing the compiled application. We will explore the various
    options available for each platform and how these channels can benefit, or complicate,
    our cross-platform strategy.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的，也是最后一章中，我们将探讨开发过程的最后一步：打包和共享编译后的应用程序。我们将研究每个平台可用的各种选项，以及这些渠道如何有助于，或复杂化，我们的跨平台策略。
