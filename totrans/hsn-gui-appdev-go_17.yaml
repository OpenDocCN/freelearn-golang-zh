- en: Best Practices in Go GUI Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go language has well-defined practices for formatting, documentation, and
    code structure. You can find these referenced in many places, for example, [https://golang.org/doc/effective_go.html#formatting](https://golang.org/doc/effective_go.html#formatting)
    and [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments).
    Additionally, there is a strong community drive to encourage writing idiomatic
    Go, such as [https://dmitri.shuralyov.com/idiomatic-go](https://dmitri.shuralyov.com/idiomatic-go).
    Many of these design decisions are encoded in tools such as `gofmt` and `golint`,
    which makes it easy for people to learn and maintain standardized code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look beyond these code standards and common conventions
    to focus on the aspects of best practice that make it easier to maintain and grow
    GUI-based applications. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driving UI development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration for GUIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing platform specifics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The addition of graphical elements to an application often makes it harder to
    test. In this chapter, we will see that with the correct preparation and structure,
    we can overcome these challenges and make our code robust and easy to change.
    Let's start by looking at how to structure a GUI-based application for maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept is closely related to the *Single Responsibility Principle* introduced
    by Robert C. Martin in his principles of Object Oriented Design ([butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)),
    which state that:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A class should have one, and only one, reason to change."'
  prefs: []
  type: TYPE_NORMAL
- en: –Robert C. Martin
  prefs: []
  type: TYPE_NORMAL
- en: In this respect, *concerns* have a wider scope than *responsibilities*, typically
    influencing your application's design and architecture rather than individual
    classes or interfaces. Separation of concerns is essential in a graphical application
    to correctly detach your easily-tested logic from the presentation code, which
    manages user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: By separating the concerns of an application, it is easier to test subcomponents
    and check the validity of our software without even needing to run the application.
    In doing so, we create more robust applications that can adapt to changes in requirements
    or technology over time. For example, the graphical toolkit that you choose for
    your application should not be incorporated into, or impact the design of, your
    business logic. Consider the GoMail examples that we built in previous chapters;
    we were able to use different toolkits to display our emails, but the code to
    manage accessing them was never changed. In this way, we kept the software open
    to change without a huge impact on unrelated areas.
  prefs: []
  type: TYPE_NORMAL
- en: Suggested application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you plan the development of your application, consider how the core concerns
    could be separated to maintain flexibility. The following suggested structure
    should provide some inspiration:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `project/` | The root of the project structure. This package should define
    the interfaces and utility functions used by the rest of the project. These files
    should not depend on any sub-packages. |'
  prefs: []
  type: TYPE_TB
- en: '| `project/logic/` | This package will contain most of your application logic.
    Careful consideration should be given to which functions and types are exposed,
    as they will form the API that the rest of your application will depend upon.
    There may be multiple packages that contain application logic as you separate
    the application''s concerns. An alternative, domain-specific term may be preferred
    to `logic`. |'
  prefs: []
  type: TYPE_TB
- en: '| `project/storage/` | Most applications will rely upon a data source of some
    kind. This package will define one or many possible data sources. They will conform
    to an interface in the top-level project so that data access can be passed between
    packages of the project. |'
  prefs: []
  type: TYPE_TB
- en: '| `project/gui/` | This package is the only place where your graphical toolkit
    should be imported. It is responsible for loading your application GUI and responding
    to user events. It will probably access data provided by a storage package set
    from the application runner. |'
  prefs: []
  type: TYPE_TB
- en: '| `project/cmd/appname/` | The Go convention for application binaries is that
    they reside within a `cmd/appname` sub-package. The actual package for this directory
    will be `main`, and it will contain, minimal code that is required to load and
    run the main application defined within the other packages. It will probably initialize
    a storage system, load the application logic, and instruct the graphical interface
    to load. |'
  prefs: []
  type: TYPE_TB
- en: When writing tests in each of these packages, they will focus on the functionality
    of the current package. The `logic` package should have very high unit-test coverage,
    whereas the `storage` package may rely more on integration testing (for a refresher
    on the different types of testing see [www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing](https://www.atlassian.com/continuous-delivery/software-testing/types-of-software-testing)).
    The `gui` package, which is often considered the hardest to test, could directly
    import the logic package in its tests, but should probably not include the main
    storage package to validate its functionality. You can read more about the recommended
    package structure at [medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1).
  prefs: []
  type: TYPE_NORMAL
- en: Following a sensible structure will aid significantly in making your application
    testable, as many developers are probably already aware. It is often much harder,
    however, to test the graphical portions of an application. Designing your application
    to be unit-testable from the beginning will often result in a code base that is
    better organized and will naturally lead to code that is easier to understand
    and change. Let's take a look at what **Test-driven Development** (**TDD**) can
    teach us about building graphical interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving UI development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The effort required to automatically test user interfaces or frontend software
    is often debated as being far too expensive for the value it returns in avoiding
    future bugs. However, this is largely rooted in the toolkits being utilized or
    even the presentation technologies chosen. Without full support for testing in
    the development tools or graphical APIs, it can indeed be difficult to create
    simple unit tests without a huge effort. As seen frequently in web-based environments
    (and some native test frameworks), the only remaining possibility is to run the
    application and execute test scripts that will perform the validation. They will
    typically control the user input, simulating mouse actions and keyboard taps,
    and monitor the resulting behavior of the application under test. If, however,
    your application and GUI toolkit are architected with testing in mind (for example,
    using separation of concerns), automated tests should be possible with far less
    overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Designed to be testable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When setting out the components within a project's UI code (as illustrated in
    the `gui` sub-package), care should be taken to define types and classes that
    have a single responsibility and a clear API. Doing so will make it easier to
    load and test individual components with the standard Go testing tools. If smaller
    components can be tested, we we can avoid launching the whole application and
    the required test runners, therefore making the testing process much faster. When
    a test suite runs quickly, it can be run more frequently and extended more easily,
    leading to higher test coverage and greater confidence in the software quality.
  prefs: []
  type: TYPE_NORMAL
- en: For a practical example, let's look at the GoMail compose dialog and its Send
    button. Clearly, the dialog box should perform all sorts of validation before
    sending, and if they pass then send the email. Validation can easily be tested
    with normal unit tests, but verifying that the send button correctly sends a new
    email will require the user interface to be tested. In the following example,
    we will load the compose window, enter some data, and simulate the Send button
    being pressed. By using a test email server, as used through each of the GoMail
    examples, we can check that the email has been sent by the user interface without
    needing to communicate with a real email server.
  prefs: []
  type: TYPE_NORMAL
- en: Example application test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We return to the GoMail code of [Chapter 10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml),
    *Fyne – Material-design-based GUI* and create a new file, `compose_test.go`. As
    the tests are in the same package, we can test internal function definitions rather
    than relying on exported APIs—this is common with UI code as long as the application
    is not large enough to warrant separate packages or libraries. We start by adding
    the test imports; `testing` is required for go test code and `github.com/stretchr/testify/assert` provides
    helpful assertion functionality. We also import the client email library created
    for our GoMail examples and finally the Fyne test package, `fyne.io/fyne/test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add a test method using the recommended naming pattern of `Test<type>_<function>()`;
    normally, the function would be a function name, but here we refer to the button
    title or its action. In the first part of the function, we set up the compose
    window for testing by calling `newCompose()` and passing it a test application
    (returned from `test.NewApp()`). We then prepare the state for our test—we record
    the size of the server outbox and set up an `OnClosed` handler that will report
    when the window is closed. Finally, we simulate typing an email address into the
    `compose.to` field using `test.Type()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once the setup code is complete, we can implement the main test. This starts
    by using `test.Tap()` to tap the `compose.send` button, which should cause an
    email to be sent. We first verify that the window was `closed` after the email
    send completes (the `OnClosed` handler we added records this). Then we check that
    there is one more email in the `server.Outbox` than before.
  prefs: []
  type: TYPE_NORMAL
- en: 'If these tests pass, we will move to the final check. The email that was sent
    is extracted from the outbox so we can examine its content. With one final assertion,
    we verify that the email address matched what we typed into the *To* input box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding test will load the user interface in memory, execute
    the setup code, and run the tests, and then exit with the results. We run the
    following test with `-v` to see each test that is run rather than just a summary.
    You will notice that testing in this way takes very little time (`go test` reports
    0.00 seconds for the test and 0.004 seconds in total); therefore, many more tests
    could be run on a regular basis to verify the application''s behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/001ab68e-1d3b-49a8-bf1e-078b52d52720.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the user interface test took very little time
  prefs: []
  type: TYPE_NORMAL
- en: When running the tests, you may notice that this test does not cause any window
    to be displayed on your computer screen. This is a design feature of many test
    frameworks for GUI toolkits – it is much faster to run the application without
    displaying it for test purposes. This is often called **headless** mode and is
    very useful when running automated tests as part of a **continuous integration**
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration for GUIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous integration (the regular merging of a team's work-in-progress code
    to be automatically tested) has become commonplace in software-development teams.
    Adding this process to your team workflow is shown to highlight issues earlier
    in the development process, which leads to fixing issues faster and, ultimately,
    better-quality software. A critical part of this is the automation of tests that
    exercise the whole of the source code, which includes the graphical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Approaches to GUI test automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to organize your code into logical components for development
    and testing. Using the framework test features (or external support libraries)
    smaller components can more easily be verified through simple tests. The Go language's
    built-in support for testing has meant that test coverage is improving; in fact,
    the popular Go library list, [awesome-go.com](http://awesome-go.com), asks that
    libraries have a test coverage of at least 80%! GUI toolkits, especially those
    newer ones discussed in [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits*, need to meet these expectations and allow developers using
    them to do so as well.
  prefs: []
  type: TYPE_NORMAL
- en: If your chosen framework does not provide the necessary support, it is still
    possible to automate functional testing. The technique involves running the application
    from a test script that then performs simulated user actions on the host computer.
    This is not ideal as it requires the application to be visible on the screen and
    for the test script to take control of the keyboard and mouse – but it is better
    than having no GUI testing in place. To work around this inconvenience, it is
    possible to load a virtual frame buffer (an off-screen display area) in which
    to run the application. This technique basically creates an invisible *screen*
    to which the application can draw. Such approaches are typically supported by
    commercial continuous-integration servers, but setting them up is outside the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding external dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing to be aware of when testing an application, or portions of it, is
    that there may be external systems involved. A file browser may rely on network
    connections for some of its work, or an instant messenger app is going to need
    a server to handle sending and receiving messages. If your code has been organized
    carefully to separate its concerns, you will already have used interfaces to define
    the interactions between different components. If this approach is taken, we can
    use *dependency injection* to provide alternative implementations for areas of
    an application that should not be included in automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: '"One of the main goals of decomposing complex problems into smaller modules
    and implementing these modules are dependencies. A module that relies heavily
    on a underlying technology or platform is less reusable and makes changes to software
    complex and expensive."'
  prefs: []
  type: TYPE_NORMAL
- en: –[http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dependency_injection.html](http://best-practice-software-engineering.ifs.tuwien.ac.at/patterns/dependency_injection.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'When code is properly decoupled from the components that it relies on, it''s
    possible to load different versions of an application for testing. In this manner,
    we can avoid relying on any external systems or causing permanent changes to a
    data store. Let''s look at a trivial example, a `Storage interface` is defined
    that will be used to read and write files from a disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an application runner that invokes a permanent storage and uses it
    to write and then read a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, this application will cause whatever was in an existing `README.txt`
    file to be overwritten with the contents of `overwrite`. If we assume, for example,
    that this is the desired behavior, we probably don''t want this external system
    (the disk) to be affected by our tests. Because we have designed the storage to
    conform to an interface, our test code can include a different storage system
    that we can use in tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this addition, we can test our application''s `runApp` function without
    the risk of overwriting real files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this test, you will see that we get the expected result, and should
    also notice that no real files have changed. The code from this sample is also
    available in the book''s source code repository in the `chapter13/ci` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cc2f1a0-41b4-4e06-af21-da3ef77b0ad3.png)'
  prefs: []
  type: TYPE_IMG
- en: See that our TestMain_RunApp completed successfully without writing to our disk
  prefs: []
  type: TYPE_NORMAL
- en: Managing platform specifics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the
    Rescue!*, we saw that the Go compiler has built-in support for the conditional
    inclusion of source files based on a system of environment variables and build
    tags. As an application adds more functionality, especially from a platform-integration
    perspective, it is possible that the toolkit you have chosen will not provide
    all of the functionality you are looking for. When this happens, the code will
    need to be updated to handle platform-specific functionality. To do so, we will
    use a variation of the conditional build – using well-named files instead of build
    tags (as used in [Chapter 11](03c04362-6937-47f3-a2de-cd99d9ae9080.xhtml), *Navigation
    and Multiple Windows*). This is easier to read at the project level and should
    indicate clearly which files will be compiled for which platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple example: we want to show a notification, but our code
    only has the ability to do so on macOS (darwin). We will set up a simple `notify()`
    function that does what we want in the `notification_darwin.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple function calls out to the `osascript` tool, a command-line application
    bundled with macOS that allows the execution of system scripts. As this file ends
    with the name `_darwin.go`, it will only be compiled when we are building for
    macOS. To compile correctly when building on other platforms, we need to create
    another file that will be loaded instead, we will call it `notification_other.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, we must specify the build condition, as there is no special filename
    format for *all other* *platforms*; here, `// +build !darwin` means that the file
    will be included on any platform other than macOS. The method we provide in this
    file simply logs that the feature is not supported. Finally, we create a simple
    application launcher named `main.go` that will call the `notify()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code on macOS will result in the expected notification appearing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2702c7d-ca30-46bb-8063-9c3275add060.png)'
  prefs: []
  type: TYPE_IMG
- en: Our simple notification appearing on macOS
  prefs: []
  type: TYPE_NORMAL
- en: 'On any other operating system, it will log the fallback error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a765143-4c9d-4125-8c85-811d72dc25ab.png)'
  prefs: []
  type: TYPE_IMG
- en: When run on Linux (or Windows or others) we just see the log message
  prefs: []
  type: TYPE_NORMAL
- en: We can handle platform-specific code in a way that should be clear to anyone
    learning the source code. Another developer could decide to add a `notification_windows.go` file
    to add support for notifications on Windows. As long as they also update the build
    rules in `notification_other.go`, the application will continue to work as expected
    but with the addition of Windows-based notifications. The benefit of this approach
    is that it did not require any modifications of existing code to add this new
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored some of the tips and techniques for managing a
    GUI-based application written with Go. By carefully planning the modules of an
    application and how they interact, we saw that we can make it easier to test and
    maintain. As higher test coverage is a factor in increasing the quality of software
    applications, we looked at how we can use these techniques to test our graphical
    code, which is a notoriously difficult topic. We stepped through an example of
    writing test code for a simple GUI application that could be run automatically.
  prefs: []
  type: TYPE_NORMAL
- en: From these basic concepts, we looked at how to prepare an application for regular
    automated testing to constantly check the code for errors (a technique called
    **Continuous Integration**). By leveraging a well-modularized code base, we can
    avoid relying on external services or creating accidental side effects when testing
    our software. We saw how **Dependency Injection** can improve our test reliability
    and speed up the process for more immediate feedback. Finally, we saw how to apply
    our knowledge to handling operating-system-specific functionality within our graphical
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next, and final, chapter, we will look into the last step of the development
    process: packaging and sharing the compiled application. We will explore the various
    options available for each platform and how these channels can benefit, or complicate,
    our cross-platform strategy.'
  prefs: []
  type: TYPE_NORMAL
