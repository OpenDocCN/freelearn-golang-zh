<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Distributing Your Application</h1>
                </header>
            
            <article>
                
<p>By now, you should be familiar with how to build graphical user interfaces for applications using the Go language. The last step of any journey in building a graphical application is distribution. The process of packaging and releasing your completed product can be challenging, especially if you are publishing to multiple platforms, and we will explore these details in this chapter.</p>
<p>While the Go language and the libraries that we've utilized so far in this book make it easy to write software for multiple platforms, there is no escaping the fact that different operating systems require native graphical applications to be in different formats. For developers, it is often easy to forget this, as Go tools build from the source code in a way that's consistent across different systems. To prepare an application for release, we will look at the following topics:</p>
<ul>
<li>Preparing metadata and icons for our application</li>
<li>Bundling assets to fit with Go's <em>single binary</em> distribution</li>
<li>Packaging a completed application for different operating systems</li>
<li>Uploading to platform marketplaces and app stores</li>
</ul>
<p>By the end of this chapter, you should be able to package and distribute graphical applications ready to share with your target audience. You'll have worked through the steps to create application packages that can be downloaded or installed exactly as users on each of your distribution platforms expect. We start by gathering all of the information that you will need to complete a distribution for any system marketplace.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Metadata and icons</h1>
                </header>
            
            <article>
                
<p>Before we start on the technical aspects of creating an application release, there are a few prerequisites to consider. The application name is probably set by now, but do you have a great description for it? Do you know how to articulate the key features of your software in a way that will grab the attention of potential users? Have you (or your design team) created a great app icon that will be memorable and somehow indicative of its functionality?</p>
<p>If you will not be distributing through a managed channel such as an app store, you should consider how the application will be discovered by your target audience. There's a lot of discussion and information online about <strong>Search Engine Optimization</strong> (<strong>SEO</strong>) and a growing amount about <strong>App Store Optimization</strong> (<strong>ASO</strong>), so we will not go into detail here. What's clear in the current software climate is that ease of discovery and memorability are now more important than ever before.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application icon</h1>
                </header>
            
            <article>
                
<p>Picking your icon is probably the single most important part of preparing an application for release. It needs to be memorable and evoke some idea of what the software is for. A great icon should look good when displayed either large or small, and in general, tiny details should be avoided or only used for unimportant aspects of the design. Make sure that your icon is created at a high resolution; 1024 x 1024 pixels is the minimum requirement for an icon to look great on the widest variety of devices. It's also important to consider the use of transparency—depending on the platforms you wish to distribute to, this may or may not be recommended. Most desktop systems allow the use of shaped icons, but not all will allow <em>semi-transparent</em> areas.</p>
<p>Take some time to look at popular or commonplace icons on each of the operating systems or desktop environments where you expect your application to be used. Can you match your icon style to each of them successfully? Does it seem like a particular shape or style will be expected by users of these systems? It may be best, or necessary, to create different versions of the graphic for different platforms. Doing so is not a problem, and can be accommodated by passing different icons to the build tools we work with later.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Describing your app</h1>
                </header>
            
            <article>
                
<p>At this stage of development, it's not uncommon to have a little marketing material ready for the software you have created. This is the time to think about how your description could best attract new users. Whether it's through a web search engine or an application marketplace, the text you use is critical for convincing anyone to install your application. As well as the name of the application and its main functionality, make sure you consider how it could benefit your users. What tasks do you expect they'll be trying to complete when searching for the solution you have built? Don't worry about making this text long, but do try to include these important points.</p>
<p>Whether you intend to ship your application via an online store or a simple website, it's advisable to make sure you've completed the metadata before you continue to the release process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bundling assets</h1>
                </header>
            
            <article>
                
<p>Go applications are designed to run from a single binary file. This means they can be easily distributed and do not rely on installation scripts. Unfortunately, this benefit results in a cost for developers—we cannot rely on resources being found next to our applications in the way that web or mobile app developers can (as we have been doing during development). To ensure that our applications conform to this design, we must embed any required assets into the application binary. This includes fonts, images, and any other static content that's needed for the application to operate correctly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">go-bindata</h1>
                </header>
            
            <article>
                
<p>GUI-based applications are not alone in needing to solve this challenge so there are many solutions already available. The most commonly utilized tool is called <kbd>go-bindata</kbd> and is available from <a href="https://github.com/jteeuwen/go-bindata">github.com/jteeuwen/go-bindata</a>. It is a simple utility that converts static files in to Go source code so they can be compiled into an application. This approach is the easiest to work with as the embedded assets become part of the source code and would therefore be checked out and built with the rest of the project. Unfortunately, that package is no longer maintained, even though it is still heavily used in the community. New, actively-maintained versions do exist, but are less popular at this time.</p>
<p>To use this asset packager, we install it from GitHub with <kbd>go get -u github.com/jteeuwen/go-bindata/...</kbd> and then run the <kbd>go-bindata</kbd> command passing in the name of the <kbd>asset</kbd> directory:</p>
<p class="CDPAlignCenter CDPAlign packt_figref"><img src="Images/18371b99-8594-442a-af39-0324e1113cd5.png" style="width:39.00em;height:11.08em;" width="1124" height="319"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Running go-bindata creates a new file named bindata.go</div>
<p>By including the generated Go file, we have access to a number of newly exported methods. The most important of these are <kbd>Asset()</kbd> and <kbd>MustAsset()</kbd>, which each take the name of an <kbd>asset</kbd> file from the directory that was bundled. The first method looks up the asset and returns the data if it is found or otherwise an error. The latter returns the data but will panic if the named resource cannot be found. With this new functionality, we can load the desired resource from the code, as follows:</p>
<p><kbd>data, err := Asset("shiny-hall.jpg")</kbd></p>
<p>You can also get the list of assets available using the <kbd>AssetNames()</kbd> command, or load more information about an asset using the <kbd>AssetInfo()</kbd> command.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">packr</h1>
                </header>
            
            <article>
                
<p>An alternative approach is provided by the packr project, hosted at <a href="https://github.com/gobuffalo/packr">github.com/gobuffalo/packr</a>. This utility provides additional functionality over <kbd>go-bindata</kbd> and other similar tools— the ability to load assets directly from the filesystem while in development. This flexibility can speed up working with many assets, as you no longer have to re-generate the packaged source code after every change. This flexibility, however, requires a slight change in workflow, and it is necessary to use the <kbd>packr</kbd> command in place of <kbd>go</kbd> when building the application for installation or release.</p>
<p>To use this bundle technique, we need to install the <kbd>packr</kbd> tool (using <kbd><span>go get -u github.com/gobuffalo/packr/packr</span></kbd>), which will also ensure the library is installed.  Before we can run the build, we need to write the code that looks up our resources, as follows:</p>
<pre>package main<br/><br/>import "log"<br/>import "github.com/gobuffalo/packr"<br/><br/>func main() {<br/>   box := packr.NewBox("./data")<br/>   data, err := box.Find("shiny-hall.jpg")<br/><br/>   log.Println("datLen", len(data), "err", err)<br/>}</pre>
<p>After saving this code, we can run as normal, for example, <kbd>go run main.go</kbd>, and it will load the resources from the filesystem. When we want to install the app or build for release, we have to use the <kbd>packr</kbd> command instead, such as <kbd>packr install</kbd>. This command will find all of the resource directories we reference, bundle them into Go code, and then build the application including the additional code:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/2446b9f1-30ca-4f1f-aeaa-8901891f367c.png" style="width:30.92em;height:12.42em;" width="930" height="373"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">We can run code as normal but must use packr at build time.</div>
<p><span>As you can see in the preceding screenshot, there was no extra step when developing and it works just like any other Go code. When building the application for release, we use the <kbd>packr</kbd> command to bundle the <kbd>assets</kbd> into the executable during the build process.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">rsrc</h1>
                </header>
            
            <article>
                
<p>If your application is built using Walk or another Windows-specific toolkit, you may consider the <kbd>rsrc</kbd> tool. <kbd>rsrc</kbd> is used to bundle manifest files and icon files within an executable file. The process involves running the tool to generate a <kbd>.syso</kbd> file, which is then compiled into the final binary output when running <kbd>go build</kbd>. This is the same process described in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk – Building Graphical Windows Applications,</em> for embedding the applications manifest file. We also use the tool later in this chapter to embed an application icon for distributing to Windows.</p>
<p>To package icons into the application, you can run <kbd>rsrc -ico myicon.ico,anothericon.ico</kbd>, and then re-build your app. Resources embedded in this way can be accessed using <kbd>walk.NewIconFromResource("myicon.ico")</kbd>. This is a helpful method of embedding icon resources if you are writing applications specifically for Windows. If you intend to work with multiple target platforms, it is less likely to be useful as your macOS or Linux executable will not be able to access these icons.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">fyne bundle</h1>
                </header>
            
            <article>
                
<p>The previous tools will work with any of the Go GUI frameworks, but if you are using the Fyne toolkit, you can make use of its own bundling utility (within the <kbd>fyne</kbd> command that is part of the Fyne project). The benefit of using this specific tool when working with a Fyne-based application is that it generates <kbd>fyne.Resource</kbd> definitions for each of the embedded resources. This makes it easier to pass an asset into various Fyne APIs. The process for <kbd>fyne bundle</kbd> is similar to <kbd>go-bindata</kbd>—running the utility converts assets from the filesystem into the Go source code, which can then be compiled into applications. The biggest difference is how we then reference the assets, that is, through declared variables instead of a lookup system.</p>
<p>The <kbd>bundle</kbd> command is part of the <kbd>fyne</kbd> executable and takes the file to embed as its main parameter. It prints the result to the system output so we use console redirection (<kbd>&gt;</kbd>) to send the generated Go source code to a suitable file:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/7eccd93f-99ca-45e8-a408-f305474db51c.png" style="width:38.50em;height:10.50em;" width="1124" height="307"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The Fyne bundle command outputs to stdout so we redirect output to a Go file</div>
<p>Once the file is generated (or appended to an existing file), we can reference it using the created symbol (of the <kbd>*fyne.StaticResource</kbd> type, which implements <kbd>fyne.Resource</kbd>). This can be used like any other resource, so we can load it as an image in the following way:</p>
<p><kbd>image := canvas.NewImageFromResource(resourceShinyHallJpg)</kbd></p>
<p>The generated variable name may not be ideal for your usage, but it can be changed using an additional command parameter. For example, if you wanted to export this new symbol, you could uppercase the name using <kbd>-name ShinyHall</kbd>. To bundle a directory, you can either pass the directory name instead of a filename or run the command repeatedly for individual files with an additional <kbd>-append</kbd> parameter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a release</h1>
                </header>
            
            <article>
                
<p>Now that your code is complete, you have all of the metadata prepared, and you've embedded the asset files, it's time to actually build the release. We will look at this process in three stages, as follows:</p>
<ol>
<li>Deciding which platforms to release for and setting up the tools</li>
<li>Building the binary files for release</li>
<li>Preparing the actual packages that you will distribute</li>
</ol>
<p>Assuming that you will be distributing to multiple operating systems, there may be some preparatory stages to go through before you can build all of the release binaries.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Preparing</h1>
                </header>
            
            <article>
                
<p>If you've got to this chapter with the intention of using the Walk framework and therefore distribute only to the Windows operating system, you can skip this preparation step as you don't need any additional compilation tools. All of the other toolkits that we have explored in this book require CGo for some functionality. The C compiler to enable CGo should already be set up for the platform you are developing on, but there is additional work needed to enable cross-compilation to other platforms. If you have a separate operating system installation for the development of each of your target platforms, then you can skip this step.</p>
<p>For this section, we assume development on a preferred operating system, and therefore the need to cross-compile for additional target platforms. Doing this will require installing a GCC compatible compiler for each target platform (for example, a Linux-based developer may need to install compilers for Windows and macOS).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compiler installation</h1>
                </header>
            
            <article>
                
<p>Each additional platform (with a different operating system to the current one) will require a C compiler to be installed. The ones recommended throughout this book are as follows (along with the CC environment variable to use them with CGo):</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Target Platform</strong></td>
<td><strong>CC=</strong></td>
<td><strong>Download</strong></td>
<td><strong>Notes</strong></td>
</tr>
<tr>
<td>
<p>macOS (darwin)</p>
</td>
<td>
<p>o32-clang</p>
</td>
<td><a href="https://github.com/tpoechtrager/osxcross/">github.com/tpoechtrager/osxcross/</a></td>
<td>
<p>You will also need the macOS SDK</p>
<p>(see osxcross documentation)</p>
</td>
</tr>
<tr>
<td>
<p>Windows</p>
</td>
<td>
<p>x86_64-w64-mingw32-gcc</p>
</td>
<td>
<p>On macOS: <a href="https://brew.sh/">brew.sh/</a></p>
<p>On Linux: use your package manager</p>
</td>
<td>
<p>macOS: install <kbd>mingw-w64</kbd> package</p>
<p>Linux: package names vary</p>
</td>
</tr>
<tr>
<td>
<p>Linux/BSD</p>
</td>
<td>
<p>gcc-linux</p>
</td>
<td>
<p>On macOS: <a href="https://brew.sh/">brew.sh/</a></p>
<p>On Windows: <a href="https://cygwin.com/install.html">cygwin.com/install.html</a></p>
</td>
<td>
<p>macOS: Install <kbd><span>FiloSottile/musl-cross/musl-cross</span></kbd></p>
<p>Windows: Install <kbd>gcc-linux</kbd> package</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_infobox">Installing cross-compilation tools can be complicated—be sure to read the documentation on each download page and check your environment configuration after installing.<br/>
Full details of how to install and set up each of these compilers can be found in <a href="4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml">Appendix 2</a>, <em>Cross-Compiler Setup</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building</h1>
                </header>
            
            <article>
                
<p>With all of the appropriate compilers and libraries installed, we can continue to the build phase. For each of the target operating systems, you will need to run through these steps with the correct environment variables set. It is recommended to build for one platform and then complete the packaging step listed in the following table before changing to the next configuration. This is because the release binary for one platform may overwrite another (for example, macOS and Linux binaries have the same name when compiled). Note that when building a release for the current platform, you can omit the <kbd>CGO_ENABLED</kbd> and <kbd>CC</kbd> environment variables:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Target Platform</strong></td>
<td><strong>GOOS=</strong></td>
<td><strong>CGO_ENABLED=</strong></td>
<td><strong>CC=</strong></td>
<td><strong>Notes</strong></td>
</tr>
<tr>
<td>
<p>macOS</p>
</td>
<td>
<p>darwin</p>
</td>
<td>1</td>
<td>
<p><span>o32-clang</span></p>
</td>
<td>
<p>Make sure you've prepared the SDK and copied it to the osxcross <span><kbd>tarballs/</kbd> directory.</span></p>
</td>
</tr>
<tr>
<td>
<p>Windows</p>
</td>
<td>
<p>windows</p>
</td>
<td>1</td>
<td>
<p><span>x86_64-w64-mingw32-gcc</span></p>
</td>
<td>
<p class="mce-root">A different CC or compiler may be required if you change <kbd>GOARCH</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p>Linux</p>
</td>
<td>
<p>linux</p>
</td>
<td>1</td>
<td>
<p><span>gcc-linux</span></p>
</td>
<td>
<p>On macOS you may need to use <span>x86_64-linux-musl-gcc for CC.</span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>With these environment variables set appropriately, we can execute the build command. You may also want to set <kbd>GOARCH</kbd> to specify a different CPU architecture, but doing so is beyond the scope of this chapter. If you are using the Packr asset bundler, then you will need to use the <kbd>packr build</kbd> command, otherwise the <kbd>go build</kbd> command can be executed. This will typically take longer than a normal run or build, as all of the application dependencies may have to be built for the new target platform before your application can be compiled.</p>
<p>To see this in action, we can open a Linux Terminal and set up the environment for each build. When compiling for the current platform, we don't need to specify the <kbd>CGO_ENABLED</kbd> or <kbd>CC</kbd> variables as these have correct defaults. After each build, we have a single application binary for the desired platform that we will put to one side and use in the next step (for instance, packaging):</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/3692794e-4e07-412c-b502-a825197a053b.png" style="width:37.92em;height:23.92em;" width="562" height="354"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Compiling with CGo for Linux, macOS, and Windows</div>
<p><span>Once the binary files have been compiled, we could distribute the application – this would be the normal process for command line utilities or web applications. However, with GUI-based applications, a user will expect visual elements, such as icons and integration with application launchers for their platform. That information is added in the packaging phase and varies for each platform and toolkit.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging</h1>
                </header>
            
            <article>
                
<p>To finish creating the release files for a graphical application, we have to add extra imagery and metadata alongside the binary that was just compiled. These need to be in specific formats, which are different for each operating system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linux</h1>
                </header>
            
            <article>
                
<p>The format for an application package on Linux varies between distributions (<kbd>.rpm</kbd>, <kbd>.deb</kbd>, and <kbd>.tar.gz</kbd> are common formats for distribution), but they all require the same assets, which we will build now. As well as the compiled application, we need an <kbd>icon</kbd> file and a <kbd>desktop entry</kbd> file (a standard defined by FreeDesktop.org: <a href="https://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html">standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html</a>). The <kbd>icon</kbd> file is a simple image file in one of the supported formats: PNG, XPM, and SVG. PNG is recommended for a bitmap icon and SVG is the format to use if your icon is vector-based.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Create metadata files</h1>
                </header>
            
            <article>
                
<p>The <kbd>.desktop</kbd> file is a simple text file in a standard key-value format with grouping. There are certain keys that are required as well as many optional ones (which we will not cover here). A basic desktop entry file may look like this:</p>
<pre class="programlisting">[Desktop Entry]
Type=Application
Name=My Application
Exec=myapp %f
Icon=myapp.png<br/>Categories=Utility</pre>
<p>Save the content to a suitably named file, such as <kbd>myapp.desktop</kbd>, next to your compiled binary file. This file sets out the basic application information—the type of executable it describes (<kbd>Application</kbd>) and the name that will be used for display (you can add additional information with <kbd>Comment</kbd> if required). The name can be localized (displayed in different languages) as well—for this, use the <kbd>Name[fr]=French Name</kbd> format. We then specify the executable (this can be just the filename, in which case the location will be looked up, or an absolute path to the installed binary). The <kbd>%f</kbd> parameter indicates that the executable can accept a single file parameter and is useful for things such as dragging and dropping files onto your application icon (omit this if you do not support command arguments). We need to specify the <kbd>icon</kbd> parameter to tell the system the how to find the icon for this application (in this case, it will look for <kbd>myapp.png</kbd> in the theme icon paths). Optionally, we can specify categories that this application should appear within— excluding this element may mean the icon does not appear in system menus. A full list of supported categories is available online at <a href="https://specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry">specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry</a>.</p>
<div class="packt_tip">To make it easier for users to find your software once it's installed, be sure to choose a clear name and set the right category for your application. You can use the <kbd>Comment</kbd> property to provide more information, but that may not always be shown.<br/>
On some systems, the category is more than a menu grouping. For example, items in the <em>Settings</em> category may be placed into a control panel rather than the main application list.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging release</h1>
                </header>
            
            <article>
                
<p>Linux packages are distributed in one of two ways: as source code or as a binary (compiled) package. When shipped as source code, a makefile, or similar, would be included to instruct the compiler on how to create the executable. With Go, this is different due to the standard structure and build tools, so we don't need to include a make file. As developers, we simply invoke <kbd>go install</kbd> for the current project or <kbd>go get</kbd> for one that is not yet downloaded. Anyone familiar with Go will know this process and so there is no required build information in this case.</p>
<p>However, we are packaging for distribution to regular users, not developers. For this to work , we could use distribution-specific packaging (which we will look at later in this chapter) or build a package that could work for any Linux system. To do the latter, we can prepare a structured package that can simply be expanded onto a user's system. The standard installation location for non-system packages is <kbd>/usr/local</kbd>, so we start at that location for our files (we mirror this structure in the current directory). The expected tree of files should look like the following (<em>hicolor</em> is the name of the fallback theme for looking up icons):</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>File path</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>usr/local/share/applications/myapp.desktop</kbd></td>
<td><kbd>Desktop Entry</kbd> metadata </td>
</tr>
<tr>
<td><kbd>usr/local/share/icons/hicolor/512x512/apps/myapp.png</kbd></td>
<td>Application icon (for a 512 x 512 px bitmap image)</td>
</tr>
<tr>
<td><kbd>usr/local/share/icons/hicolor/scalable/apps/myapp.svg</kbd></td>
<td>Application icon (for a vector image)</td>
</tr>
<tr>
<td><kbd>usr/local/bin/myapp</kbd></td>
<td>Executable file (from go build)</td>
</tr>
</tbody>
</table>
<p>With all of these files in the right folder we can build an application package using the <kbd>tar</kbd> utility. The full command to create a new file with this content is <kbd>tar -cf myapp.tar.gz usr</kbd>, as shown in the following screenshot:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/3d37e635-4d31-4b0c-b1d7-12a3a8416ab8.png" style="width:36.33em;height:19.17em;" width="1138" height="601"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Packaging the contents of our usr/local directory structure</div>
<p>The resulting package can be shared for installation, and the recipient should use <kbd>sudo tar -xf myapp.tar.gz</kbd> from the root of their filesystem. In this example, we pass the additional <kbd>-C /</kbd> to avoid having to change directory, as indicated in the following screenshot:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/c0c0c13d-726b-4bef-961f-ae41ce15d3ab.png" style="width:36.58em;height:7.25em;" width="1138" height="225"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">After installing the packaged application we can run it from $PATH</div>
<p>This package format will work for all Linux distributions, but packaging for package managers is additional work. We will look at distribution tools later in this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">macOS</h1>
                </header>
            
            <article>
                
<p>Applications to be distributed for macOS also require a particular directory structure and associated metadata. These files will not be installed like the previously shown Linux example, but instead run from the directory we are creating. This format is called an <strong>application bundle</strong> and requires certain metadata files that we must create to describe the application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating metadata files</h1>
                </header>
            
            <article>
                
<p>The main metadata file for macOS applications is called <kbd>Info.plist</kbd> and, like the desktop entry for Linux, it is a structured text file. For a Go project, it is best to edit the text directly rather than using the installed Xcode tools. This file contains a list of key-value pairs that describe the application we've built. It's important that you do not change the values for <kbd>CFBundlePackageType</kbd> or <kbd>CFBundleInfoDictionaryVersion</kbd> as these identify the file to macOS as an application.</p>
<p>The main keys for customization are <kbd>CFBundleExecutable</kbd>, which sets the name of the executable file; <kbd>CFBundleName</kbd>, for the human-visible name of the application; and <kbd>CFBundleIconFile</kbd>, to specify the icon filename. It's important to set sensible values for <kbd>CFBundleIdentifier</kbd> as this uniquely identifies this application, and <kbd>CFBundleShortVersionString</kbd>, which specifies what version of the application is included. Putting all of these values into the <kbd>plist</kbd> format, you should have a file similar to the following:</p>
<pre>&lt;!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" <br/>      \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;<br/>&lt;plist version=\"1.0\"&gt;<br/>   &lt;dict&gt;<br/>      &lt;key&gt;CFBundleExecutable&lt;/key&gt;<br/>      &lt;string&gt;myapp&lt;/string&gt;<br/>      &lt;key&gt;CFBundleIdentifier&lt;/key&gt;<br/>      &lt;string&gt;com.example.myapp&lt;/string&gt;<br/>      &lt;key&gt;CFBundleName&lt;/key&gt;<br/>      &lt;string&gt;MyApp&lt;/string&gt;<br/>      &lt;key&gt;CFBundleIconFile&lt;/key&gt;<br/>      &lt;string&gt;myapp.icns&lt;/string&gt;<br/>      &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;<br/>      &lt;string&gt;1.0&lt;/string&gt;<br/>      &lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;<br/>      &lt;string&gt;6.0&lt;/string&gt;<br/>      &lt;key&gt;CFBundlePackageType&lt;/key&gt;</pre>
<pre>      &lt;string&gt;APPL&lt;/string&gt;<br/>   &lt;/dict&gt;<br/>&lt;/plist&gt;</pre>
<div class="packt_tip">Be sure to set a globally unique <kbd>CFBundleIdentifier</kbd> value – typically by using the reverse domain name format illustrated previously. This configuration is used to associate file types with your application, and the App Store will not accept applications where this is not set correctly. </div>
<p>One additional step when creating a macOS package is that the icon must be in the <kbd>ICNS</kbd> format. <kbd>ICNS</kbd> files contain many different sized icons so that macOS can display a clear graphic at various resolutions. There are many graphical tools to manipulate these files (search <kbd>create icns file</kbd> online), but the XCode command-line tools include <kbd>iconutil</kbd>, a simple utility that can create these files from a set of icons.</p>
<p>When invoking <kbd>iconutil</kbd>, we specify that it should convert to <kbd>icns</kbd> with the <kbd>-c icns</kbd> parameter, and provide the output file name using <kbd>-o &lt;filename&gt;</kbd>. The last parameter is the <kbd>iconset</kbd> input—a directory of appropriately named files that will be included. For our 1024 x 1024 pixels icon, we call it <kbd>icon_512x512@2x.png</kbd>, but it is recommended to provide multiple different resolutions. Running the command will create the <kbd>.icns</kbd> file we need for our application icon, as follows:</p>
<pre class="p1"><span class="s1"><strong>iconutil -c icns -o Chapter14.app/Contents/Resources/chapter14.icns chapter14.iconset/</strong></span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging release</h1>
                </header>
            
            <article>
                
<p>Now that the metadata has been created, we can create the directory structure required for a macOS application bundle. The location of the files is important, and is set out as follows:</p>
<p class="mce-root">File <kbd>pathDescription</kbd></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><kbd>myapp.app/Contents/Info.plist</kbd></td>
<td>The application metadata outlined in the preceding</td>
</tr>
<tr>
<td><kbd>myapp.app/Contents/Resources/myapp.icns</kbd></td>
<td>The application icon in ICNS format</td>
</tr>
<tr>
<td><kbd>myapp.app/Contents/MacOS/myapp</kbd></td>
<td>The application executable</td>
</tr>
</tbody>
</table>
<p>After creating these directories and moving files to the correct location, you have a complete application bundle. This can be executed by double-clicking the icon and it can be distributed in this state. Installation consists of dragging this icon into the <kbd>Applications</kbd> folder of the computer, as follows:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/8cb89486-99ae-4c56-a8aa-351e51eee3c6.png" style="width:34.08em;height:17.42em;" width="490" height="251"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Creating the .app directory structure and adding metadata creates a macOS application</div>
<p>Looking at the result in Finder, we see the new directory as an application, its <kbd>.app</kbd> extension is hidden, and the icon is the same we set up before. You can launch, install, or remove this app like any other:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/2de161ae-7a61-4c3e-a13c-55e908e02b82.png" style="width:19.67em;height:6.50em;" width="288" height="95"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Our .app directory shows as the application it describes</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Windows</h1>
                </header>
            
            <article>
                
<p>Metadata for applications in Windows is embedded into the executable file rather than in additional files. To do this, we create metadata files and then use a resource tool to include them in the final executable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating metadata files</h1>
                </header>
            
            <article>
                
<p>To include application metadata, we create an application manifest file like those used in <a href="62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml">Chapter 3</a>, <em>Go to the Rescue!,</em> and <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a>, <em>Walk – Building Graphical Windows Applications, </em>when we were building applications using the Common Controls widget set (via Walk and andlabs UI). The contents of the <span><kbd>assemblyIdentity</kbd> instance </span>is used to determine the metadata about the executable. For a platform-independent GUI, the file should look like the following:</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;<br/>&lt;assembly  manifestVersion="1.0" &gt;<br/>   &lt;assemblyIdentity version="1.0.0.0" processorArchitecture="*" name="Chapter14" type="win32"/&gt;<br/>&lt;/assembly&gt;</pre>
<p>Don't, however, remove the <kbd>&lt;dependency&gt;</kbd> section if you are using Walk, andlabs UI, or another toolkit that needs to have a dependency listed in its manifest file.</p>
<div class="packt_tip">To add more metadata that may be useful to users (for example, product name and version) you will need to manually set extra values. The goversioninfo tool from <a href="https://github.com/josephspurrier/goversioninfo/">github.com/josephspurrier/goversioninfo/</a> is the easiest way to add these values. Be aware that you can only write to the <kbd>.syso</kbd> file once, as running these tools again will overwrite the previous content.</div>
<p>To prepare our icon for Windows, it must be converted into a <kbd>.ico</kbd> file (the Microsoft icon format). While there are no icon conversion tools pre-installed with Windows, there are many paid-for applications available that will work. If you prefer a free solution, there are websites that offer image conversion services for no cost. If your development platform is Linux or macOS, you could install <kbd>icotool</kbd>, which supports the <kbd>.ico</kbd> format.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging release</h1>
                </header>
            
            <article>
                
<p>To package the data for release, we will embed this metadata into the application binary. Doing so requires creating a binary resource file (ending in <kbd>.syso</kbd>) that will encapsulate the manifest and icon files. The easiest way to do this is with the <kbd>rsrc</kbd> tool that was used in <a href="3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml">Chapter 4</a><span>, </span><em>Walk – Building Graphical Windows Applications</em>. If you have not yet installed <kbd>rsrc</kbd>, you can do so with <kbd>go get github.com/akavel/rsrc</kbd>. We tell the tool where to find the manifest and icon files and it will output an <kbd>rsrc.syso</kbd> file in the current directory, as follows:</p>
<pre><strong>rsrc -manifest myapp.exe.manifest -ico myapp.ico</strong></pre>
<p>If you are compiling for a 64 bit target, you will need to specify an additional <kbd>-arch amd64</kbd> parameter. It is important that the resource file generated is for the same architecture (either i386 or amd64) as the application you are compiling.</p>
<p>Now that the metadata has been bundled into a resource file, we have to re-build our project. Make sure that, this time, you add the <kbd>-ldflags="-H windowsgui"</kbd> parameter, otherwise the resulting application will display a Terminal window when starting:</p>
<pre><strong>go build -ldflags="-H windowsgui"</strong></pre>
<p>Once the build is complete, we will have created a Windows executable with the icon and metadata included. You can now launch this from the command line or by double-clicking the icon:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f542c0d7-062a-4c72-a6be-5c430f8ca308.png" style="width:52.92em;height:25.25em;" width="1098" height="525"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Building the application after generating a resource bundle will automatically include the data</div>
<p>Here, we see the same directory in Windows Explorer. The application is on the left in the screenshot that follows, displayed using the icon we included:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/e2c1e3b0-cf5b-4aef-8f20-12b27dd19789.png" style="width:35.42em;height:9.83em;" width="802" height="223"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Our Windows application with the icon embedded</div>
<p>These processes are slow and can be prone to errors. To avoid doing this process manually, we will explore tools that could automate this.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-platform packaging tools</h1>
                </header>
            
            <article>
                
<p>As you can see, each operating system requires very different packaging. Additionally, the tools that would normally make the process simple are typically platform-specific, making it more difficult to build from a single system. The distribution of GUI applications is an area in which Go tools are also lacking. The Go language is great for rapidly creating cross-platform software, but it is not designed to handle the complication of graphical application packaging.</p>
<p>In <a href="36bfea00-c659-4569-864c-de2c460c7467.xhtml">Section 2</a>,  <em>Toolkits Using Existing Widgets,</em> we explored toolkits that are very mature, but as they are either not written for Go, or are not designed to be cross-platform, they do not provide the tools we could use. <a href="ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml">Section 3</a>,<em>  Modern Graphical Toolkits,</em> looked at toolkits that are more focused on providing graphical capabilities rather than application life cycle, and so do not provide suitable tools either.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">fyne package</h1>
                </header>
            
            <article>
                
<p>One exception is the Fyne project as it aims to provide APIs for full application life cycle, and so the tools support distributing complete desktop apps across multiple platforms. While the project is still early it does have a tool that can help with application packaging (even if you've not used Fyne in your code). The <kbd>fyne package</kbd> command is designed to generate and package all the required metadata for an application to distribute on macOS, Linux, or Windows. Invoking with the <kbd>-os &lt;platform&gt;</kbd> parameter (using one of "darwin", "linux", or "windows") will create a fully packaged application in the current directory. Before executing this command the application should already be compiled for release.</p>
<p>For example, we can create a macOS application bundle from a Linux computer using <kbd>fyne package -os linux</kbd>. There are many additional parameters that can change the contents of the application, and the most useful will be the <kbd>-icon &lt;filename&gt;</kbd> parameter (which is required). If you were not already using Fyne, then the command should be installed using <kbd>go get fyne.io/fyne/cmd/fyne</kbd>, as follows:</p>
<p class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/9dae04be-79a5-43c1-b541-4f4151be752c.png" style="width:37.33em;height:23.25em;" width="562" height="350"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Building a macOS application bundle on Linux with "fyne package"</div>
<p>As you can see in the preceding screenshot, the tool generated an <kbd>.app</kbd> directory structure (which defines a macOS application) from a Linux Terminal. We used the same platform name for the <kbd>GOOS</kbd> environment and the <kbd>-os</kbd> parameter to <kbd>fyne package</kbd>. It's recommended to build for one platform and then package it before changing the target operating system to avoid potential errors in the output package.</p>
<p>The applications we have built in this section could be distributed right away. Uploading to a website or sharing the files in some other manner would work, but we want to make the process completely seamless for users. Let's wrap up this chapter by looking at the various distribution channels that exist for desktop application delivery directly to end users.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Distributing to platform marketplaces</h1>
                </header>
            
            <article>
                
<p>Most operating systems now have a central location for discovering and installing applications. Apple created the Mac App Store, Windows has the Microsoft Store, and each Linux distribution has its preferred package manager. Having an application listed in (and hosted by) a platform marketplace significantly increases the number of users you can expect and also reduces associated hosting costs. When paired with carefully prepared metadata (as described at the beginning of this chapter), a marketplace can easily become your largest distribution channel. <span>How to get applications included in these directories is specific to each platform, so we will look at the process for each in turn.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mac App Store</h1>
                </header>
            
            <article>
                
<p>The Mac App Store is the desktop version of Apple's famous iOS App Store. It provides many thousands of applications available to buy and download, or gift to others. There is also curated content, which includes listings of the most popular apps in various categories, as well as staff picks and recommended software. Apple provides education discounts as well as free copies to family members if one person makes a purchase. You can also redeem gift cards towards making purchases of apps or subscriptions. Unfortunately, the Mac App Store cannot be browsed online as it requires the App Store software, which is pre-installed on compatible Mac computers.</p>
<p>As well as having the development tools installed, you will also need to sign up to the Apple Developer Program. If you are not already a member you can sign up on their website here: <a href="https://developer.apple.com/programs/enroll/">developer.apple.com/programs/enroll/</a>. The development resources are free to access, but there is an annual subscription charge for access to the code signing tools, which are required to publish software to any of their App Stores.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging</h1>
                </header>
            
            <article>
                
<p>Packaging applications for submission are managed by the XCode tools (which you should already have installed). The process is optimized for submitting apps that have been built with XCode and, as it does not support Go, we have some manual steps to complete.</p>
<p><span>The application package that we created earlier (for macOS distribution) will have to be signed before we can upload to the App Store. Code signing is a complicated process to set up, so for the purpose of this description, it is assumed that you already have a distribution certificate installed. You need to note the name of the certificate (use Keychain Access to find your developer certificates) and then use that name in the following command:</span></p>
<pre><strong>codesign -s "CertificateName" /path/to/MyApp.app</strong></pre>
<p>The resulting app package is ready to be uploaded to the App Store Connect website for validation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Uploading</h1>
                </header>
            
            <article>
                
<p>App Store applications are managed through the App Store Connect website (at <a href="https://appstoreconnect.apple.com/">appstoreconnect.apple.com/</a>). Log in using your Apple developer account and create a new application (if you have not already done so). This is where you add the metadata that will be displayed in the store—be sure to check the information carefully as some data cannot be changed after release. Well-chosen descriptions and screenshots will help your application to be more easily discovered. Within this app definition, you need to start preparing a new release, with an appropriate version number and supporting information. You will probably notice that you are not yet able to select a build—to enable this, we first need to upload the compiled package.</p>
<p><span>The application loader tool is the easiest way to upload a new build: open the app and log in with your Apple ID. Once logged in, you will be asked to choose the application to upload; select the matching application and progress to the upload. Once complete, the build will appear in the App Store Connect website (you may need to refresh the page). If you prefer command-line tools for managing the progress, you can use</span> <kbd>xcrun altool</kbd>, which provides the same capability. Once you've chosen this new build, you can press the <span class="packt_screen">Submit for Review</span> button to start the review process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reviewing</h1>
                </header>
            
            <article>
                
<p>As soon as an app is submitted for review, it goes through an automated set of code checks. This process verifies that the application does not contain obvious errors in metadata or code signing and performs code analysis to ensure you are not using APIs that are private to Apple or otherwise restricted. Assuming that these automated checks pass, then the application will be sent for final acceptance by a member of the App Store review team.</p>
<p>The review team checks your application for quality, reliability, compliance with the <strong>Human Interface Guidelines</strong> (<strong>HIG</strong> –<strong> </strong><a href="https://developer.apple.com/app-store/review/">developer.apple.com/app-store/review/</a>), and that it meets other criteria for inclusion on the store. This process typically takes a day or two, but can be longer for the first release of a new application. Once the process is complete your software will be available to purchase or download on the App Store. In your first week of distribution, it may even be included in the <em>New and Noteworthy</em> section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Microsoft Store</h1>
                </header>
            
            <article>
                
<p>The Microsoft Store is the official location for finding and installing software, apps, and games for all of the current Windows, Windows Phone, and Xbox devices. As well as offering hosting and search facilities it handles payments for non-free software and supports discounts and vouchers as well. You can browse the contents of the Microsoft Store online (at <a href="https://www.microsoft.com/store/apps">www.microsoft.com/store/apps</a>) or by using the store apps on each of the systems it supports.</p>
<p>To submit an application to the Microsoft Store, you will require a Microsoft account (which you may already have if you signed in to Windows, Xbox, or Office 365). You will also have to start an annual subscription to access the relevant portions of the developer portal. You can log in and sign up at <a href="https://appdev.microsoft.com/StorePortals">appdev.microsoft.com/StorePortals</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging</h1>
                </header>
            
            <article>
                
<p>The tools required to create an application package for uploading to the Microsoft Store are included as part of the Windows Software Development Kit. If you have not already installed this you can download it from <a href="https://developer.microsoft.com/en-us/windows/downloads">developer.microsoft.com/en-us/windows/downloads</a>, either as part of Visual Studio, or as a separate package.</p>
<p>To upload an application to the store we must create a <kbd>.appx</kbd> file (an application package). This requires an additional manifest file, named <span><kbd>AppxManifest.xml</kbd>, which contains the metadata about the application being packaged. Its contents are documented on the Microsoft website at <a href="https://docs.microsoft.com/en-us/uwp/schemas/appxpackage/how-to-create-a-basic-package-manifest">docs.microsoft.com/en-us/uwp/schemas/appxpackage/how-to-create-a-basic-package-manifest</a>. The resulting manifest file should have at least one <kbd>Application</kbd> element within the <kbd>Applications</kbd> section.</span></p>
<p>To create the package from our source files, we use a <kbd>MakeAppx.exe</kbd> command, as indicated in the following code snippet. By using the <kbd>/d</kbd> parameter, we can specify a directory of files to package – if you want to use a subset of the files, you can create a mapping file and specify that with the <kbd>/f</kbd> parameter instead:</p>
<pre><strong>MakeAppx.exe bundle /d sourcedir /p myapp.appx</strong></pre>
<p>Once the <kbd>.appx</kbd> file has been created, it must be signed. The <kbd>SignTool.exe</kbd> command can be used to sign an application package. Setting up the certification to support application signing is outside the scope of this chapter, but the documentation on the Microsoft developer portal will take you through the process. Ensure that the publisher listed in the manifest file matches the certificate that you create to sign the package.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Uploading</h1>
                </header>
            
            <article>
                
<p>The completed package should be uploaded to the developer portal within the <kbd>Packages</kbd> page. When preparing for upload, make sure that all of your application metadata has been added to the correct locations so that people will find your software easily.</p>
<p>Once the package is uploaded, it will be checked for various errors that could stop it from being released. Should you encounter any warnings, you will need to remove the uploaded build from the portal and fix the issue. Once resolved, you will need to fully re-package, re-sign, and upload the new package for re-testing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reviewing</h1>
                </header>
            
            <article>
                
<p>Once your package is uploaded and has passed the initial validation it will be added to a queue to be reviewed. The Microsoft staff will review your application for correctness and suitability, and validate that it is of high enough quality for inclusion in the store. Assuming that these checks all pass, they will publish it for distribution across the devices that you specified during the submission process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linux package manager</h1>
                </header>
            
            <article>
                
<p>For many years, Linux distributions have had a reputation for handling package distribution well. A desktop system will likely have a graphical package management application that provides easily searchable indexes containing thousands of packages. More recently, various applications have been created to help with software discovery (to make finding new packages easier).</p>
<p>Applications such as <em>Discover</em> (more information on this can be found at <a href="https://userbase.kde.org/Discover">userbase.kde.org/Discover</a>) can be used on most systems by working with many different package managers. Others, such as <em>Ubuntu Software Center</em>, aim to make it easier to find applications for specific systems based on categories, ratings, and other enhanced metadata.</p>
<p>Despite there being hundreds of different Linux distributions only a handful of packaging formats are needed to support them. In this section we look at the three most popular formats: <em>Debian</em>, <em>Red Hat,</em> and <em>Tarball</em>. Once packages have been created for a system the application developer can submit it to a package list. As Linux is an open source system, however, you may find that an existing package maintainer may be happy to do that for you! </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Debian (.deb)</h1>
                </header>
            
            <article>
                
<p>Distribution for Debian is very similar to the <kbd>.tar.gz</kbd> distribution we created earlier, with the addition of specific metadata that allow the Debian tools to search and correctly install the software. Packaging for Debian is described in detail on their website (<a href="https://wiki.debian.org/HowToPackageForDebian">wiki.debian.org/HowToPackageForDebian</a>), but the basic process is to add the metadata (<em>Debianization</em>), build the package to conform to their filesystem layout, and then (optionally) sign the package so that users know they can trust the content.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging</h1>
                </header>
            
            <article>
                
<p>The <span><kbd>dh_make</kbd> command is provided to automate the creation of required metadata files, and running it inside the existing Linux packaging directory structure will add the necessary files. Once run, you should check all the files in the <kbd>debian/</kbd> directory to update information as appropriate. The <kbd>debuild</kbd> command will create a Debian package for our software once the metadata has been added. After it's creation, you should use the <kbd>lintian</kbd> command to check the package for a number of common errors.</span></p>
<p>Although not required, you could then sign the package using the <kbd>debsigs</kbd> tool. This creates a signed package, which provides cryptographic proof that the package contains what the developers intended. As mentioned earlier, setting up certificates and signing is complex and not covered by this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Distribution</h1>
                </header>
            
            <article>
                
<p><span>Once your package is prepared you can distribute the file directly to other Debian users. However, the aim was to include it in the package listing. To do so requires a process that starts by filing <span class="packt_screen">Intent to Package</span> in their bug tracker (<a href="https://bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=wnpp;dist=unstable">bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=wnpp;dist=unstable</a>). To complete the process, you will need to find a sponsor for your package or become a Debian developer. Either of which will require you to contact the development community to learn more; full details can be found at <a href="https://wiki.debian.org/DebianMentorsFaq">wiki.debian.org/DebianMentorsFaq</a>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Red Hat (.rpm)</h1>
                </header>
            
            <article>
                
<p>RPM files are very similar to Debian packages but with a different set of metadata. Once again, there are standard tools that can help with the creation of these files and to create the final package. To start with, you should install the <kbd>rpm</kbd> or <kbd>rpm-build</kbd> package in your Linux distribution, which should include the necessary commands.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Packaging</h1>
                </header>
            
            <article>
                
<p>First, we must create a <kbd>.spec</kbd> file to describe the package. The <kbd>rpmdev-newspec</kbd> command can provide one from the templates option to get you started. Update the contents according to your application information. This file will contain all the metadata about your software (including its source location, the license, and authors). The spec file also provides the build information required to assemble the package, as well as instructions for installation scripts, and more.</p>
<p>Once the metadata is complete, the package can be built using the <kbd>rpmbuild</kbd> command. It is normal that this will not succeed on the first attempt. Read the output and update the <kbd>.spec</kbd> file accordingly, then re-run the build command. The finished output will be your completed <kbd>.rpm</kbd> file ready for testing. At this time, you can test the file by installing it manually (on a compatible Linux computer) and verifying that the software works as expected.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Distribution</h1>
                </header>
            
            <article>
                
<p>Now that the package is prepared, it can be distributed using your website – an RPM file can be downloaded and installed relatively easily. Inclusion in Linux distributions is a complicated process and the details are different for each variant. CentOS, Fedora, and Red Hat Enterprise Linux all use the RPM package format, as do many others, but the process of submission is not well-documented. The Fedora project has comprehensive documentation, which you can refer to at <a href="https://fedoraproject.org/wiki/Package_Review_Process">fedoraproject.org/wiki/Package_Review_Process</a>. For most package inquiries, the best approach is to contact the current distribution maintainers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tarball (.tar.gz)</h1>
                </header>
            
            <article>
                
<p>The tarball is a generic packaging for binary (and source-based) distribution of applications. The <kbd>.tar.gz</kbd> package that we built earlier in this chapter is an example of a possible tarball distribution. With Linux, most applications are open source, meaning that packaging is typically done from the source code rather than from the compiled output. It is possible to use a binary release, as we have built, but bear in mind that some distributions may push back on including such a package based on their own policies.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Arch Linux</h1>
                </header>
            
            <article>
                
<p>The Arch Linux package manager, pacman, relies on <kbd>PKGBUILD</kbd> files to understand how to locate and install software packages. The <kbd>PKGBUILD</kbd> file is a specific format of shell script (executable text file for the command line) that describes the package metadata, any dependencies that it must install first, and the installation process for a package. Full details of the <kbd>PKGBUILD</kbd> file can be found at <a href="https://wiki.archlinux.org/index.php/PKGBUILD">wiki.archlinux.org/index.php/PKGBUILD</a>. A valid file must contain at least <kbd>pkgname</kbd>, <kbd>pkgver</kbd>, <kbd>pkgrel</kbd>, and <kbd>arch</kbd> variables.</p>
<p>To create a package once the <kbd>PKGBUILD</kbd> file is created, you run the <kbd>makepkg</kbd> command. This will execute the steps defined in the script file and prepare the resulting package. It is recommended to check the finished package file using the <kbd>namcap</kbd> command which validates that certain common mistakes have not been made.</p>
<p>Newly created packages can be submitted to the <em>Arch User Repository</em> where other Arch Linux users will be able to install it. Notable packages can be promoted from this location to the official repository over time. Details for submitting your package can be found at <a href="https://wiki.archlinux.org/index.php/Arch_User_Repository#Submitting_packages">wiki.archlinux.org/index.php/Arch_User_Repository#Submitting_packages</a>. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Gentoo Linux</h1>
                </header>
            
            <article>
                
<p>Gentoo Linux is (not uniquely) a source-based distribution. This means that the package system contains just instruction files that describe how to download and install software. This file is called an <kbd>ebuild</kbd> file and, like the <kbd>PKGBUILD</kbd> file previously, contains information about metadata, dependencies, and build instructions. Unlike Arch Linux, this descriptor file is the complete distribution – packagers do not build a binary distribution package using the metadata file.</p>
<p>The process for submitting a new package to Gentoo Linux (once you have created the <kbd>ebuild</kbd> file) is described on their community documentation <a href="https://wiki.gentoo.org/wiki/Submitting_ebuilds">https://wiki.gentoo.org/wiki/Submitting_ebuilds</a>. As with other distributions, you will need to become part of the development community to add the package yourself, but you may convince an existing developer to maintain the package for you.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Others</h1>
                </header>
            
            <article>
                
<p>Many other Linux distributions use similar packaging systems, but to mention them all would be too lengthy for this chapter. Each of their websites will provide information about how to complete a package and submit to their application listings.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Containers</h1>
                </header>
            
            <article>
                
<p>An increasingly popular approach to application distribution is that of <strong>application containerization</strong>. This approach means that each application is packaged into a <em>container</em>, similar to how Docker and other tools are doing for server-based software. An application container is a single file that simulates a filesystem, into which an application is installed. Applications can be downloaded from a website or through a package manager and do not need to be installed to run. The same container file will run on any Linux distribution; there are even some container formats that aim to support multiple operating systems as well. AppImage, Snap, and Zero Install are some popular formats, each with particular benefits or target audiences. If you want to distribute a single Linux package for your application and are not so concerned about including it in the platform software lists, this approach may be right for you.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this final chapter, we looked at how to package and distribute Go-based graphical applications. Unlike the distribution of command-line or system utilities, the process of delivering a GUI application requires additional metadata and packaging. Users of graphical apps expect to find and install software in a particular manner that varies based on their operating system. We started by looking at the importance of good metadata and how to select an icon and description that will attract potential users to try out our new software. We then learned how to package assets into our Go-based applications. As the language is designed for single binary distribution, we had to incorporate all supporting files into the executable before distributing. </p>
<p>Packaging for different platforms can be complicated, so we walked through the steps required to build native-looking graphical packages for macOS, Windows, and Linux. Each package has its own metadata format and package structure but we were able to package our simple application for each of the specific formats. The packages that resulted from this step could be distributed through a website or other file sharing mechanism. However, we wanted to deliver the app where our users would expect to find it—in the system app store. And so we worked through the process of preparing and distributing the packages for each platform's marketplace. The Windows and macOS stores provide an opportunity for applications to earn revenue following release and the Linux software listings will help to increase visibility of our software package.</p>
<p>Having learned the various approaches to building GUIs with Go and exploring the toolkits available, we've made it all of the way to a complete and published graphical application. Hopefully, you've learned a lot along the way and have managed to create the app that you had been aiming to build—using only Go to support a performant, maintainable, and beautiful user interface.</p>


            </article>

            
        </section>
    </div>



  </body></html>