- en: Distributing Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发您的应用程序
- en: By now, you should be familiar with how to build graphical user interfaces for
    applications using the Go language. The last step of any journey in building a
    graphical application is distribution. The process of packaging and releasing
    your completed product can be challenging, especially if you are publishing to
    multiple platforms, and we will explore these details in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该已经熟悉了如何使用Go语言构建应用程序的图形用户界面。构建图形应用程序的任何旅程的最后一步是分发。打包和发布您完成的产品可能具有挑战性，尤其是如果您正在向多个平台发布，我们将在本章中探讨这些细节。
- en: 'While the Go language and the libraries that we''ve utilized so far in this
    book make it easy to write software for multiple platforms, there is no escaping
    the fact that different operating systems require native graphical applications
    to be in different formats. For developers, it is often easy to forget this, as
    Go tools build from the source code in a way that''s consistent across different
    systems. To prepare an application for release, we will look at the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go语言以及我们在本书中迄今为止使用的库使得为多个平台编写软件变得容易，但不同操作系统要求原生图形应用程序以不同格式存在的事实是无法回避的。对于开发者来说，往往很容易忘记这一点，因为Go工具以在不同系统上一致的方式从源代码构建。为了准备应用程序发布，我们将探讨以下主题：
- en: Preparing metadata and icons for our application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序准备元数据和图标
- en: Bundling assets to fit with Go's *single binary* distribution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将资源捆绑以适应Go的*单个二进制*分发
- en: Packaging a completed application for different operating systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同的操作系统打包完成的应用程序
- en: Uploading to platform marketplaces and app stores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传到平台市场和应用商店
- en: By the end of this chapter, you should be able to package and distribute graphical
    applications ready to share with your target audience. You'll have worked through
    the steps to create application packages that can be downloaded or installed exactly
    as users on each of your distribution platforms expect. We start by gathering
    all of the information that you will need to complete a distribution for any system
    marketplace.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够打包和分发准备与目标受众分享的图形应用程序。您将完成创建应用程序包的步骤，这些包可以像您每个分发平台上的用户期望的那样下载或安装。我们首先收集您完成任何系统市场分发的所有必要信息。
- en: Metadata and icons
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元数据和图标
- en: Before we start on the technical aspects of creating an application release,
    there are a few prerequisites to consider. The application name is probably set
    by now, but do you have a great description for it? Do you know how to articulate
    the key features of your software in a way that will grab the attention of potential
    users? Have you (or your design team) created a great app icon that will be memorable
    and somehow indicative of its functionality?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建应用程序发布的技术细节之前，有一些先决条件需要考虑。应用程序的名称可能已经确定，但您是否有一个出色的描述？您知道如何以吸引潜在用户注意的方式阐述您软件的关键特性吗？您（或您的设计团队）是否创建了一个令人难忘且能体现其功能的优秀应用程序图标？
- en: If you will not be distributing through a managed channel such as an app store,
    you should consider how the application will be discovered by your target audience.
    There's a lot of discussion and information online about **Search Engine Optimization**
    (**SEO**) and a growing amount about **App Store Optimization** (**ASO**), so
    we will not go into detail here. What's clear in the current software climate
    is that ease of discovery and memorability are now more important than ever before.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不会通过如应用商店这样的管理渠道进行分发，您应该考虑您的应用程序如何被目标受众发现。关于**搜索引擎优化**（**SEO**）和越来越多的关于**应用商店优化**（**ASO**）的讨论和信息在网上有很多，所以我们不会在这里详细介绍。在当前的软件环境中，显而易见的是，易于发现和记忆现在比以往任何时候都更加重要。
- en: Application icon
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序图标
- en: Picking your icon is probably the single most important part of preparing an
    application for release. It needs to be memorable and evoke some idea of what
    the software is for. A great icon should look good when displayed either large
    or small, and in general, tiny details should be avoided or only used for unimportant
    aspects of the design. Make sure that your icon is created at a high resolution;
    1024 x 1024 pixels is the minimum requirement for an icon to look great on the
    widest variety of devices. It's also important to consider the use of transparency—depending
    on the platforms you wish to distribute to, this may or may not be recommended.
    Most desktop systems allow the use of shaped icons, but not all will allow *semi-transparent* areas.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 选择您的图标可能是准备发布应用程序最重要的单个部分。它需要令人难忘，并激发一些关于软件用途的想法。一个优秀的图标在显示大或小尺寸时都应该看起来很好，并且通常应避免或仅用于设计的不重要方面。确保您的图标以高分辨率创建；1024
    x 1024像素是图标在各种设备上看起来出色的最低要求。同时，考虑透明度的使用也很重要——根据您希望分发的平台，这可能或可能不被推荐。大多数桌面系统允许使用形状图标，但并非所有都允许*半透明*区域。
- en: Take some time to look at popular or commonplace icons on each of the operating
    systems or desktop environments where you expect your application to be used.
    Can you match your icon style to each of them successfully? Does it seem like
    a particular shape or style will be expected by users of these systems? It may
    be best, or necessary, to create different versions of the graphic for different
    platforms. Doing so is not a problem, and can be accommodated by passing different
    icons to the build tools we work with later.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间查看您预期应用程序将在其中使用的每个操作系统或桌面环境中的流行或常见图标。您能否成功地将您的图标风格与它们匹配？这些系统的用户是否期望特定的形状或风格？可能最好，或者必要的是，为不同的平台创建不同的图形版本。这样做没有问题，并且可以通过传递不同的图标给我们在稍后工作的构建工具来适应。
- en: Describing your app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述您的应用程序
- en: At this stage of development, it's not uncommon to have a little marketing material
    ready for the software you have created. This is the time to think about how your
    description could best attract new users. Whether it's through a web search engine
    or an application marketplace, the text you use is critical for convincing anyone
    to install your application. As well as the name of the application and its main
    functionality, make sure you consider how it could benefit your users. What tasks
    do you expect they'll be trying to complete when searching for the solution you
    have built? Don't worry about making this text long, but do try to include these
    important points.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个开发阶段，为所创建的软件准备一些营销材料并不罕见。这是考虑如何最好地吸引新用户描述的时候。无论是通过网络搜索引擎还是应用程序市场，您使用的文本对于说服任何人安装您的应用程序至关重要。除了应用程序的名称和其主要功能外，请确保您考虑它如何为您的用户带来好处。您预计他们在搜索您构建的解决方案时将尝试完成哪些任务？不用担心使这段文字很长，但请尽量包括这些重要观点。
- en: Whether you intend to ship your application via an online store or a simple
    website, it's advisable to make sure you've completed the metadata before you
    continue to the release process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您打算通过在线商店还是简单的网站发布您的应用程序，在继续到发布流程之前，确保您已经完成了元数据是明智的。
- en: Bundling assets
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包资源
- en: Go applications are designed to run from a single binary file. This means they
    can be easily distributed and do not rely on installation scripts. Unfortunately,
    this benefit results in a cost for developers—we cannot rely on resources being
    found next to our applications in the way that web or mobile app developers can
    (as we have been doing during development). To ensure that our applications conform
    to this design, we must embed any required assets into the application binary.
    This includes fonts, images, and any other static content that's needed for the
    application to operate correctly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go应用程序被设计为从单个二进制文件运行。这意味着它们可以轻松分发，并且不依赖于安装脚本。不幸的是，这种好处给开发者带来了成本——我们不能像网络或移动应用开发者那样（在我们开发过程中所做的那样）依赖资源紧邻我们的应用程序。为了确保我们的应用程序符合这种设计，我们必须将任何所需的资产嵌入到应用程序的二进制文件中。这包括字体、图像以及任何其他应用程序正确运行所需的静态内容。
- en: go-bindata
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: go-bindata
- en: GUI-based applications are not alone in needing to solve this challenge so there
    are many solutions already available. The most commonly utilized tool is called `go-bindata` and
    is available from [github.com/jteeuwen/go-bindata](https://github.com/jteeuwen/go-bindata).
    It is a simple utility that converts static files in to Go source code so they
    can be compiled into an application. This approach is the easiest to work with
    as the embedded assets become part of the source code and would therefore be checked
    out and built with the rest of the project. Unfortunately, that package is no
    longer maintained, even though it is still heavily used in the community. New,
    actively-maintained versions do exist, but are less popular at this time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 基于GUI的应用程序并非唯一需要解决这个挑战的，因此已经有许多解决方案可用。最常用的工具被称为 `go-bindata`，可在 [github.com/jteeuwen/go-bindata](https://github.com/jteeuwen/go-bindata)
    获取。这是一个简单的实用工具，可以将静态文件转换为 Go 源代码，以便它们可以被编译到应用程序中。这种方法是最容易工作的，因为嵌入的资源成为源代码的一部分，因此将与项目中的其余部分一起检出和构建。不幸的是，该包已不再维护，尽管它在社区中仍然被广泛使用。虽然存在新的、积极维护的版本，但在此时的受欢迎程度较低。
- en: 'To use this asset packager, we install it from GitHub with `go get -u github.com/jteeuwen/go-bindata/...`
    and then run the `go-bindata` command passing in the name of the `asset` directory:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个资源打包器，我们使用 `go get -u github.com/jteeuwen/go-bindata/...` 从 GitHub 安装它，然后运行
    `go-bindata` 命令，传入 `asset` 目录的名称：
- en: '![](img/18371b99-8594-442a-af39-0324e1113cd5.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18371b99-8594-442a-af39-0324e1113cd5.png)'
- en: Running go-bindata creates a new file named bindata.go
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 go-bindata 会创建一个名为 bindata.go 的新文件
- en: 'By including the generated Go file, we have access to a number of newly exported
    methods. The most important of these are `Asset()` and `MustAsset()`, which each
    take the name of an `asset` file from the directory that was bundled. The first
    method looks up the asset and returns the data if it is found or otherwise an
    error. The latter returns the data but will panic if the named resource cannot
    be found. With this new functionality, we can load the desired resource from the
    code, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含生成的 Go 文件，我们可以访问到许多新导出的方法。其中最重要的方法是 `Asset()` 和 `MustAsset()`，它们各自接受从捆绑目录中
    `asset` 文件的名称。第一个方法查找资源，如果找到则返回数据，否则返回错误。后者返回数据，但如果找不到指定的资源则会引发恐慌。有了这个新功能，我们可以从代码中加载所需的资源，如下所示：
- en: '`data, err := Asset("shiny-hall.jpg")`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`data, err := Asset("shiny-hall.jpg")`'
- en: You can also get the list of assets available using the `AssetNames()` command,
    or load more information about an asset using the `AssetInfo()` command.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `AssetNames()` 命令获取可用资源的列表，或使用 `AssetInfo()` 命令获取有关资源的更多信息。
- en: packr
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: packr
- en: An alternative approach is provided by the packr project, hosted at [github.com/gobuffalo/packr](https://github.com/gobuffalo/packr).
    This utility provides additional functionality over `go-bindata` and other similar
    tools— the ability to load assets directly from the filesystem while in development.
    This flexibility can speed up working with many assets, as you no longer have
    to re-generate the packaged source code after every change. This flexibility,
    however, requires a slight change in workflow, and it is necessary to use the
    `packr` command in place of `go` when building the application for installation
    or release.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由托管在 [github.com/gobuffalo/packr](https://github.com/gobuffalo/packr) 的 packr
    项目提供了一种替代方法。这个实用工具在 `go-bindata` 和其他类似工具的基础上提供了额外的功能——在开发过程中能够直接从文件系统中加载资源。这种灵活性可以加快处理多个资源的工作，因为您不再需要在每次更改后重新生成打包的源代码。然而，这种灵活性需要稍微改变工作流程，并且在构建用于安装或发布的应用程序时，必须使用
    `packr` 命令代替 `go` 命令。
- en: 'To use this bundle technique, we need to install the `packr` tool (using `go
    get -u github.com/gobuffalo/packr/packr`), which will also ensure the library
    is installed.  Before we can run the build, we need to write the code that looks
    up our resources, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种捆绑技术，我们需要安装 `packr` 工具（使用 `go get -u github.com/gobuffalo/packr/packr`），这将确保库也被安装。在我们可以运行构建之前，我们需要编写查找我们资源的代码，如下所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After saving this code, we can run as normal, for example, `go run main.go`,
    and it will load the resources from the filesystem. When we want to install the
    app or build for release, we have to use the `packr` command instead, such as `packr
    install`. This command will find all of the resource directories we reference,
    bundle them into Go code, and then build the application including the additional
    code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此代码后，我们可以像平常一样运行，例如，`go run main.go`，它将从文件系统加载资源。当我们想要安装应用程序或构建用于发布时，我们必须使用
    `packr` 命令，例如 `packr install`。此命令将找到我们引用的所有资源目录，将它们捆绑到 Go 代码中，然后构建包括附加代码的应用程序：
- en: '![](img/2446b9f1-30ca-4f1f-aeaa-8901891f367c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2446b9f1-30ca-4f1f-aeaa-8901891f367c.png)'
- en: We can run code as normal but must use packr at build time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像平常一样运行代码，但在构建时必须使用 packr。
- en: As you can see in the preceding screenshot, there was no extra step when developing
    and it works just like any other Go code. When building the application for release,
    we use the `packr` command to bundle the `assets` into the executable during the
    build process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，在开发过程中没有额外的步骤，它的工作方式与任何其他 Go 代码一样。当构建用于发布的应用程序时，我们使用 `packr` 命令在构建过程中将
    `assets` 捆绑到可执行文件中。
- en: rsrc
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rsrc
- en: If your application is built using Walk or another Windows-specific toolkit,
    you may consider the `rsrc` tool. `rsrc` is used to bundle manifest files and
    icon files within an executable file. The process involves running the tool to
    generate a `.syso` file, which is then compiled into the final binary output when
    running `go build`. This is the same process described in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    *Walk – Building Graphical Windows Applications,* for embedding the applications
    manifest file. We also use the tool later in this chapter to embed an application
    icon for distributing to Windows.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序是使用 Walk 或其他特定于 Windows 的工具包构建的，你可能需要考虑 `rsrc` 工具。`rsrc` 用于将清单文件和图标文件捆绑到可执行文件中。这个过程涉及运行工具以生成一个
    `.syso` 文件，然后在运行 `go build` 时将其编译到最终的二进制输出中。这是在 [第 4 章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)
    中描述的相同过程，*Walk – 构建图形 Windows 应用程序*，用于嵌入应用程序的清单文件。我们还在本章的后面使用此工具嵌入应用程序图标以供 Windows
    分发。
- en: To package icons into the application, you can run `rsrc -ico myicon.ico,anothericon.ico`,
    and then re-build your app. Resources embedded in this way can be accessed using
    `walk.NewIconFromResource("myicon.ico")`. This is a helpful method of embedding
    icon resources if you are writing applications specifically for Windows. If you
    intend to work with multiple target platforms, it is less likely to be useful
    as your macOS or Linux executable will not be able to access these icons.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图标打包到应用程序中，你可以运行 `rsrc -ico myicon.ico,anothericon.ico`，然后重新构建你的应用程序。以这种方式嵌入的资源可以使用
    `walk.NewIconFromResource("myicon.ico")` 访问。如果你专门为 Windows 编写应用程序，这是一种嵌入图标资源的有用方法。如果你打算与多个目标平台一起工作，它可能不太有用，因为你的
    macOS 或 Linux 可执行文件将无法访问这些图标。
- en: fyne bundle
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fyne bundle
- en: The previous tools will work with any of the Go GUI frameworks, but if you are
    using the Fyne toolkit, you can make use of its own bundling utility (within the
    `fyne` command that is part of the Fyne project). The benefit of using this specific
    tool when working with a Fyne-based application is that it generates `fyne.Resource` definitions
    for each of the embedded resources. This makes it easier to pass an asset into
    various Fyne APIs. The process for `fyne bundle` is similar to `go-bindata`—running
    the utility converts assets from the filesystem into the Go source code, which
    can then be compiled into applications. The biggest difference is how we then
    reference the assets, that is, through declared variables instead of a lookup
    system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的工具可以与任何 Go GUI 框架一起使用，但如果你正在使用 Fyne 工具包，你可以利用它自己的捆绑工具（在 Fyne 项目的一部分 `fyne`
    命令中）。在使用基于 Fyne 的应用程序时使用此特定工具的好处是它会为每个嵌入的资源生成 `fyne.Resource` 定义。这使得将资产传递到各种 Fyne
    API 上变得更加容易。`fyne bundle` 的过程与 `go-bindata` 类似——运行此实用程序将资产从文件系统转换为 Go 源代码，然后可以在构建过程中将其编译到应用程序中。最大的区别是我们如何引用这些资产，即通过声明的变量而不是查找系统。
- en: 'The `bundle` command is part of the `fyne` executable and takes the file to
    embed as its main parameter. It prints the result to the system output so we use
    console redirection (`>`) to send the generated Go source code to a suitable file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`bundle` 命令是 `fyne` 可执行文件的一部分，它将嵌入的文件作为其主要参数。它将结果打印到系统输出，因此我们使用控制台重定向（`>`）将生成的
    Go 源代码发送到合适的文件：'
- en: '![](img/7eccd93f-99ca-45e8-a408-f305474db51c.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7eccd93f-99ca-45e8-a408-f305474db51c.png)'
- en: The Fyne bundle command outputs to stdout so we redirect output to a Go file
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 打包命令输出到 stdout，因此我们将输出重定向到 Go 文件
- en: 'Once the file is generated (or appended to an existing file), we can reference
    it using the created symbol (of the `*fyne.StaticResource` type, which implements
    `fyne.Resource`). This can be used like any other resource, so we can load it
    as an image in the following way:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件生成（或附加到现有文件中），我们可以使用创建的符号（`*fyne.StaticResource` 类型，实现了 `fyne.Resource`
    接口）来引用它。这可以像使用任何其他资源一样使用，因此我们可以以下这种方式将其加载为图像：
- en: '`image := canvas.NewImageFromResource(resourceShinyHallJpg)`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`image := canvas.NewImageFromResource(resourceShinyHallJpg)`'
- en: The generated variable name may not be ideal for your usage, but it can be changed
    using an additional command parameter. For example, if you wanted to export this
    new symbol, you could uppercase the name using `-name ShinyHall`. To bundle a
    directory, you can either pass the directory name instead of a filename or run
    the command repeatedly for individual files with an additional `-append` parameter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的变量名可能不适合您的使用，但可以使用额外的命令参数进行更改。例如，如果您想导出这个新符号，可以使用 `-name ShinyHall` 将名称大写。要打包目录，您可以选择传递目录名而不是文件名，或者使用额外的
    `-append` 参数重复运行命令。
- en: Building a release
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建发布版本
- en: 'Now that your code is complete, you have all of the metadata prepared, and
    you''ve embedded the asset files, it''s time to actually build the release. We
    will look at this process in three stages, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的代码已经完成，您已经准备好了所有元数据，并且已经嵌入资产文件，现在是时候实际构建发布版本了。我们将按以下三个阶段来查看这个过程：
- en: Deciding which platforms to release for and setting up the tools
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定要发布哪些平台并设置工具
- en: Building the binary files for release
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建发布版本的二进制文件
- en: Preparing the actual packages that you will distribute
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备您将要分发的实际软件包
- en: Assuming that you will be distributing to multiple operating systems, there
    may be some preparatory stages to go through before you can build all of the release
    binaries.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您将分发到多个操作系统，在您能够构建所有发布版本的二进制文件之前，可能需要经过一些准备阶段。
- en: Preparing
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you've got to this chapter with the intention of using the Walk framework
    and therefore distribute only to the Windows operating system, you can skip this
    preparation step as you don't need any additional compilation tools. All of the
    other toolkits that we have explored in this book require CGo for some functionality.
    The C compiler to enable CGo should already be set up for the platform you are
    developing on, but there is additional work needed to enable cross-compilation
    to other platforms. If you have a separate operating system installation for the
    development of each of your target platforms, then you can skip this step.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是为了使用 Walk 框架并因此仅针对 Windows 操作系统进行分发而进入这一章节，您可以跳过这个准备步骤，因为您不需要任何额外的编译工具。本书中我们探索的所有其他工具包都需要
    CGo 来实现某些功能。启用 CGo 的 C 编译器应该已经为您的开发平台设置好了，但还需要进行额外的工作以启用对其他平台的交叉编译。如果您为每个目标平台都有一个单独的操作系统安装，则可以跳过此步骤。
- en: For this section, we assume development on a preferred operating system, and
    therefore the need to cross-compile for additional target platforms. Doing this
    will require installing a GCC compatible compiler for each target platform (for
    example, a Linux-based developer may need to install compilers for Windows and
    macOS).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们假设在首选操作系统上进行开发，因此需要为额外的目标平台进行交叉编译。这样做将需要为每个目标平台安装一个 GCC 兼容的编译器（例如，基于
    Linux 的开发者可能需要安装 Windows 和 macOS 的编译器）。
- en: Compiler installation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器安装
- en: 'Each additional platform (with a different operating system to the current
    one) will require a C compiler to be installed. The ones recommended throughout
    this book are as follows (along with the CC environment variable to use them with
    CGo):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个额外的平台（与当前操作系统不同）都需要安装一个 C 编译器。本书中推荐的使用如下（以及与 CGo 一起使用的 CC 环境变量）：
- en: '| **Target Platform** | **CC=** | **Download** | **Notes** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **目标平台** | **CC=** | **下载** | **备注** |'
- en: '| macOS (darwin) | o32-clang | [github.com/tpoechtrager/osxcross/](https://github.com/tpoechtrager/osxcross/)
    | You will also need the macOS SDK(see osxcross documentation) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| macOS (darwin) | o32-clang | [github.com/tpoechtrager/osxcross/](https://github.com/tpoechtrager/osxcross/)
    | 您还需要 macOS SDK（参见 osxcross 文档）|'
- en: '| Windows | x86_64-w64-mingw32-gcc | On macOS: [brew.sh/](https://brew.sh/)On
    Linux: use your package manager | macOS: install `mingw-w64` packageLinux: package
    names vary |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Windows | x86_64-w64-mingw32-gcc | 在 macOS 上: [brew.sh/](https://brew.sh/)
    在 Linux 上: 使用您的包管理器 | macOS: 安装 `mingw-w64` 软件包 Linux: 包名可能不同 |'
- en: '| Linux/BSD | gcc-linux | On macOS: [brew.sh/](https://brew.sh/)On Windows:
    [cygwin.com/install.html](https://cygwin.com/install.html) | macOS: Install `FiloSottile/musl-cross/musl-cross`Windows:
    Install `gcc-linux` package |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| Linux/BSD | gcc-linux | 在 macOS 上: [brew.sh/](https://brew.sh/) 在 Windows
    上: [cygwin.com/install.html](https://cygwin.com/install.html) | macOS: 安装 `FiloSottile/musl-cross/musl-cross`
    Windows: 安装 `gcc-linux` 软件包 |'
- en: Installing cross-compilation tools can be complicated—be sure to read the documentation
    on each download page and check your environment configuration after installing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 安装交叉编译工具可能很复杂——请务必阅读每个下载页面的文档，并在安装后检查您的环境配置。
- en: Full details of how to install and set up each of these compilers can be found
    in [Appendix 2](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler Setup*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安装和设置这些编译器的详细信息可以在 [附录 2](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml)，*交叉编译器设置*
    中找到。
- en: Building
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'With all of the appropriate compilers and libraries installed, we can continue
    to the build phase. For each of the target operating systems, you will need to
    run through these steps with the correct environment variables set. It is recommended
    to build for one platform and then complete the packaging step listed in the following
    table before changing to the next configuration. This is because the release binary
    for one platform may overwrite another (for example, macOS and Linux binaries
    have the same name when compiled). Note that when building a release for the current
    platform, you can omit the `CGO_ENABLED` and `CC` environment variables:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了所有适当的编译器和库之后，我们可以继续到构建阶段。对于每个目标操作系统，您需要设置正确的环境变量并执行这些步骤。建议先为某个平台构建，然后完成下表中列出的包装步骤，再切换到下一个配置。这是因为一个平台的发布二进制文件可能会覆盖另一个（例如，当编译时，macOS
    和 Linux 的二进制文件具有相同的名称）。请注意，当为当前平台构建发布版本时，可以省略 `CGO_ENABLED` 和 `CC` 环境变量：
- en: '| **Target Platform** | **GOOS=** | **CGO_ENABLED=** | **CC=** | **Notes**
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **目标平台** | **GOOS=** | **CGO_ENABLED=** | **CC=** | **备注** |'
- en: '| macOS | darwin | 1 | o32-clang | Make sure you''ve prepared the SDK and copied
    it to the osxcross `tarballs/` directory. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| macOS | darwin | 1 | o32-clang | 确保您已准备好 SDK 并将其复制到 osxcross 的 `tarballs/`
    目录。 |'
- en: '| Windows | windows | 1 | x86_64-w64-mingw32-gcc | A different CC or compiler
    may be required if you change `GOARCH`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| Windows | windows | 1 | x86_64-w64-mingw32-gcc | 如果您更改 `GOARCH`，可能需要不同的 CC
    或编译器。 |'
- en: '| Linux | linux | 1 | gcc-linux | On macOS you may need to use x86_64-linux-musl-gcc
    for CC. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Linux | linux | 1 | gcc-linux | 在 macOS 上，您可能需要使用 x86_64-linux-musl-gcc 作为
    CC。 |'
- en: With these environment variables set appropriately, we can execute the build
    command. You may also want to set `GOARCH` to specify a different CPU architecture,
    but doing so is beyond the scope of this chapter. If you are using the Packr asset
    bundler, then you will need to use the `packr build` command, otherwise the `go
    build` command can be executed. This will typically take longer than a normal
    run or build, as all of the application dependencies may have to be built for
    the new target platform before your application can be compiled.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置适当的这些环境变量后，我们可以执行构建命令。您可能还想设置 `GOARCH` 以指定不同的 CPU 架构，但这超出了本章的范围。如果您使用 Packr
    资产打包器，则需要使用 `packr build` 命令，否则可以执行 `go build` 命令。这通常会比正常运行或构建花费更长的时间，因为可能需要在编译您的应用程序之前为新的目标平台构建所有应用程序依赖项。
- en: 'To see this in action, we can open a Linux Terminal and set up the environment
    for each build. When compiling for the current platform, we don''t need to specify
    the `CGO_ENABLED` or `CC` variables as these have correct defaults. After each
    build, we have a single application binary for the desired platform that we will
    put to one side and use in the next step (for instance, packaging):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实际操作，我们可以打开 Linux 终端并为每个构建设置环境。当为当前平台编译时，我们不需要指定 `CGO_ENABLED` 或 `CC` 变量，因为这些变量有正确的默认值。每次构建后，我们都有一个为所需平台生成的单个应用程序二进制文件，我们将将其放在一边并在下一步中使用（例如，包装）：
- en: '![](img/3692794e-4e07-412c-b502-a825197a053b.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3692794e-4e07-412c-b502-a825197a053b.png)'
- en: Compiling with CGo for Linux, macOS, and Windows
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Linux、macOS 和 Windows 编译带有 CGo
- en: Once the binary files have been compiled, we could distribute the application
    – this would be the normal process for command line utilities or web applications.
    However, with GUI-based applications, a user will expect visual elements, such
    as icons and integration with application launchers for their platform. That information
    is added in the packaging phase and varies for each platform and toolkit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译了二进制文件，我们就可以分发应用程序——这将是命令行工具或网络应用程序的正常流程。然而，对于基于GUI的应用程序，用户将期望有视觉元素，例如图标，以及与平台应用程序启动器的集成。这些信息在打包阶段添加，并且因平台和工具包而异。
- en: Packaging
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包
- en: To finish creating the release files for a graphical application, we have to
    add extra imagery and metadata alongside the binary that was just compiled. These
    need to be in specific formats, which are different for each operating system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成创建图形应用程序的发布文件，我们必须在刚刚编译的二进制文件旁边添加额外的图像和元数据。这些需要以特定格式存在，每种操作系统的格式都不同。
- en: Linux
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'The format for an application package on Linux varies between distributions
    (`.rpm`, `.deb`, and `.tar.gz` are common formats for distribution), but they
    all require the same assets, which we will build now. As well as the compiled
    application, we need an `icon` file and a `desktop entry` file (a standard defined
    by FreeDesktop.org: [standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html](https://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html)).
    The `icon` file is a simple image file in one of the supported formats: PNG, XPM,
    and SVG. PNG is recommended for a bitmap icon and SVG is the format to use if
    your icon is vector-based.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上应用程序包的格式因发行版而异（`.rpm`、`.deb`和`.tar.gz`是常见的格式），但它们都需要相同的资产，我们现在将构建这些资产。除了编译的应用程序外，我们还需要一个`icon`文件和一个`desktop
    entry`文件（由FreeDesktop.org定义的标准：[standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html](https://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html)）。`icon`文件是支持格式之一（PNG、XPM和SVG）的简单图像文件。对于位图图标，建议使用PNG，如果您的图标是矢量图，则应使用SVG格式。
- en: Create metadata files
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建元数据文件
- en: 'The `.desktop` file is a simple text file in a standard key-value format with
    grouping. There are certain keys that are required as well as many optional ones
    (which we will not cover here). A basic desktop entry file may look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`.desktop`文件是一个具有分组的标准键值格式简单文本文件。有一些键是必需的，还有很多可选的（我们在这里不会介绍）。一个基本的桌面条目文件可能看起来像这样：'
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the content to a suitably named file, such as `myapp.desktop`, next to
    your compiled binary file. This file sets out the basic application information—the
    type of executable it describes (`Application`) and the name that will be used
    for display (you can add additional information with `Comment` if required). The
    name can be localized (displayed in different languages) as well—for this, use
    the `Name[fr]=French Name` format. We then specify the executable (this can be
    just the filename, in which case the location will be looked up, or an absolute
    path to the installed binary). The `%f` parameter indicates that the executable
    can accept a single file parameter and is useful for things such as dragging and
    dropping files onto your application icon (omit this if you do not support command
    arguments). We need to specify the `icon` parameter to tell the system the how
    to find the icon for this application (in this case, it will look for `myapp.png` in
    the theme icon paths). Optionally, we can specify categories that this application
    should appear within— excluding this element may mean the icon does not appear
    in system menus. A full list of supported categories is available online at [specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry](https://specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将内容保存到合适命名的文件中，例如与编译的二进制文件相邻的`myapp.desktop`。此文件概述了基本的应用程序信息——它描述的可执行文件类型（`应用程序`）以及用于显示的名称（如果需要，您可以使用`Comment`添加附加信息）。名称可以进行本地化（以不同语言显示）——为此，请使用`Name[fr]=French
    Name`格式。然后我们指定可执行文件（这可以是文件名，在这种情况下，将查找位置，或者指向已安装二进制文件的绝对路径）。`%f`参数表示可执行文件可以接受单个文件参数，这对于诸如将文件拖放到应用程序图标上之类的操作很有用（如果不支持命令参数，则省略此参数）。我们需要指定`icon`参数以告诉系统如何找到此应用程序的图标（在这种情况下，它将在主题图标路径中查找`myapp.png`）。可选地，我们可以指定此应用程序应出现在其中的类别——省略此元素可能意味着图标不会出现在系统菜单中。支持的所有类别完整列表可在网上找到，地址为[specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry](https://specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry)。
- en: To make it easier for users to find your software once it's installed, be sure
    to choose a clear name and set the right category for your application. You can
    use the `Comment` property to provide more information, but that may not always
    be shown.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用户在安装软件后更容易找到它，请确保选择一个清晰的名字并为您的应用程序设置正确的类别。您可以使用 `Comment` 属性提供更多信息，但这可能并不总是显示。
- en: On some systems, the category is more than a menu grouping. For example, items
    in the *Settings* category may be placed into a control panel rather than the
    main application list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，类别不仅仅是菜单分组。例如，*设置* 类别中的项目可能被放置在控制面板而不是主应用程序列表中。
- en: Packaging release
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件包发布
- en: 'Linux packages are distributed in one of two ways: as source code or as a binary
    (compiled) package. When shipped as source code, a makefile, or similar, would
    be included to instruct the compiler on how to create the executable. With Go,
    this is different due to the standard structure and build tools, so we don''t
    need to include a make file. As developers, we simply invoke `go install` for
    the current project or `go get` for one that is not yet downloaded. Anyone familiar
    with Go will know this process and so there is no required build information in
    this case.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 软件包以两种方式之一分发：作为源代码或作为二进制（编译）软件包。当以源代码形式提供时，会包含一个 makefile 或类似的文件，以指导编译器如何创建可执行文件。由于
    Go 的标准结构和构建工具，所以在这种情况下我们不需要包含 makefile。作为开发者，我们只需为当前项目调用 `go install` 或为尚未下载的项目调用
    `go get`。任何熟悉 Go 的人都会知道这个过程，所以在这种情况下不需要构建信息。
- en: 'However, we are packaging for distribution to regular users, not developers.
    For this to work , we could use distribution-specific packaging (which we will
    look at later in this chapter) or build a package that could work for any Linux
    system. To do the latter, we can prepare a structured package that can simply
    be expanded onto a user''s system. The standard installation location for non-system
    packages is `/usr/local`, so we start at that location for our files (we mirror
    this structure in the current directory). The expected tree of files should look
    like the following (*hicolor* is the name of the fallback theme for looking up
    icons):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们是为普通用户分发软件包，而不是为开发者。为了使其工作，我们可以使用特定于发行版的软件包打包（我们将在本章后面讨论）或构建一个适用于任何 Linux
    系统的软件包。为了做到后者，我们可以准备一个结构化的软件包，可以简单地展开到用户的系统中。非系统软件包的标准安装位置是 `/usr/local`，因此我们从该位置开始放置我们的文件（我们在当前目录中镜像这个结构）。预期的文件树应如下所示（*hicolor*
    是查找图标的备用主题名称）：
- en: '| **File path** | **Description** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **文件路径** | **描述** |'
- en: '| `usr/local/share/applications/myapp.desktop` | `Desktop Entry` metadata 
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `usr/local/share/applications/myapp.desktop` | `Desktop Entry` 元数据 |'
- en: '| `usr/local/share/icons/hicolor/512x512/apps/myapp.png` | Application icon
    (for a 512 x 512 px bitmap image) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `usr/local/share/icons/hicolor/512x512/apps/myapp.png` | 应用程序图标（512 x 512
    像素的位图图像）|'
- en: '| `usr/local/share/icons/hicolor/scalable/apps/myapp.svg` | Application icon
    (for a vector image) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `usr/local/share/icons/hicolor/scalable/apps/myapp.svg` | 应用程序图标（矢量图像）|'
- en: '| `usr/local/bin/myapp` | Executable file (from go build) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `usr/local/bin/myapp` | 可执行文件（来自 go build）|'
- en: 'With all of these files in the right folder we can build an application package
    using the `tar` utility. The full command to create a new file with this content
    is `tar -cf myapp.tar.gz usr`, as shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些文件都放在正确的文件夹中后，我们可以使用 `tar` 工具构建一个应用程序包。创建包含此内容的新文件的完整命令是 `tar -cf myapp.tar.gz
    usr`，如下面的截图所示：
- en: '![](img/3d37e635-4d31-4b0c-b1d7-12a3a8416ab8.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d37e635-4d31-4b0c-b1d7-12a3a8416ab8.png)'
- en: Packaging the contents of our usr/local directory structure
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打包我们的 usr/local 目录结构的内容
- en: 'The resulting package can be shared for installation, and the recipient should
    use `sudo tar -xf myapp.tar.gz` from the root of their filesystem. In this example,
    we pass the additional `-C /` to avoid having to change directory, as indicated
    in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的软件包可以共享用于安装，接收者应从文件系统的根目录使用 `sudo tar -xf myapp.tar.gz` 进行解压。在这个例子中，我们传递了额外的
    `-C /` 参数以避免需要更改目录，如下面的截图所示：
- en: '![](img/c0c0c13d-726b-4bef-961f-ae41ce15d3ab.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0c0c13d-726b-4bef-961f-ae41ce15d3ab.png)'
- en: After installing the packaged application we can run it from $PATH
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件包后，我们可以从 $PATH 中运行它
- en: This package format will work for all Linux distributions, but packaging for
    package managers is additional work. We will look at distribution tools later
    in this chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种软件包格式适用于所有 Linux 发行版，但为软件包管理器打包是额外的工作。我们将在本章后面讨论发行版工具。
- en: macOS
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: Applications to be distributed for macOS also require a particular directory
    structure and associated metadata. These files will not be installed like the
    previously shown Linux example, but instead run from the directory we are creating.
    This format is called an **application bundle** and requires certain metadata
    files that we must create to describe the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 macOS 上分发的应用程序还需要特定的目录结构和相关的元数据。这些文件不会像前面展示的 Linux 示例那样安装，而是从我们创建的目录中运行。这种格式称为
    **应用程序包**，需要我们创建一些元数据文件来描述应用程序。
- en: Creating metadata files
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建元数据文件
- en: The main metadata file for macOS applications is called `Info.plist` and, like
    the desktop entry for Linux, it is a structured text file. For a Go project, it
    is best to edit the text directly rather than using the installed Xcode tools.
    This file contains a list of key-value pairs that describe the application we've
    built. It's important that you do not change the values for `CFBundlePackageType`
    or `CFBundleInfoDictionaryVersion` as these identify the file to macOS as an application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 应用程序的主要元数据文件称为 `Info.plist`，就像 Linux 的桌面条目一样，它是一个结构化文本文件。对于 Go 项目，最好直接编辑文本，而不是使用已安装的
    Xcode 工具。此文件包含一个键值对列表，描述了我们构建的应用程序。重要的是不要更改 `CFBundlePackageType` 或 `CFBundleInfoDictionaryVersion`
    的值，因为这些值将文件标识为 macOS 的应用程序。
- en: 'The main keys for customization are `CFBundleExecutable`, which sets the name
    of the executable file; `CFBundleName`, for the human-visible name of the application;
    and `CFBundleIconFile`, to specify the icon filename. It''s important to set sensible
    values for `CFBundleIdentifier` as this uniquely identifies this application,
    and `CFBundleShortVersionString`, which specifies what version of the application
    is included. Putting all of these values into the `plist` format, you should have
    a file similar to the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 定制的主要键是 `CFBundleExecutable`，它设置可执行文件名；`CFBundleName`，用于应用程序的人类可见名称；以及 `CFBundleIconFile`，用于指定图标文件名。设置
    `CFBundleIdentifier` 的合理值很重要，因为这唯一地标识了此应用程序，以及 `CFBundleShortVersionString`，它指定了包含的应用程序版本。将这些值全部放入
    `plist` 格式，你应该有一个类似以下文件：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Be sure to set a globally unique `CFBundleIdentifier` value – typically by using
    the reverse domain name format illustrated previously. This configuration is used
    to associate file types with your application, and the App Store will not accept
    applications where this is not set correctly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要设置一个全局唯一的 `CFBundleIdentifier` 值——通常通过使用前面展示的逆向域名格式来实现。此配置用于将文件类型与您的应用程序关联起来，并且
    App Store 不会接受未正确设置此值的应用程序。
- en: One additional step when creating a macOS package is that the icon must be in
    the `ICNS` format. `ICNS` files contain many different sized icons so that macOS
    can display a clear graphic at various resolutions. There are many graphical tools
    to manipulate these files (search `create icns file` online), but the XCode command-line
    tools include `iconutil`, a simple utility that can create these files from a
    set of icons.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 macOS 软件包时，还需要额外的一步，即图标必须是 `ICNS` 格式。`ICNS` 文件包含许多不同尺寸的图标，这样 macOS 就可以在各种分辨率下显示清晰的图形。有许多图形工具可以操作这些文件（网上搜索
    `create icns file`），但 XCode 命令行工具包括 `iconutil`，这是一个简单的实用程序，可以从一组图标创建这些文件。
- en: 'When invoking `iconutil`, we specify that it should convert to `icns` with
    the `-c icns` parameter, and provide the output file name using `-o <filename>`.
    The last parameter is the `iconset` input—a directory of appropriately named files
    that will be included. For our 1024 x 1024 pixels icon, we call it `icon_512x512@2x.png`,
    but it is recommended to provide multiple different resolutions. Running the command
    will create the `.icns` file we need for our application icon, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `iconutil` 时，我们使用 `-c icns` 参数指定它应该转换为 `icns` 格式，并使用 `-o <filename>` 提供输出文件名。最后一个参数是
    `iconset` 输入——一个包含适当命名文件的目录，这些文件将被包含在内。对于我们的 1024 x 1024 像素的图标，我们称之为 `icon_512x512@2x.png`，但建议提供多个不同分辨率的版本。运行该命令将创建我们应用程序图标所需的
    `.icns` 文件，如下所示：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Packaging release
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包发布
- en: 'Now that the metadata has been created, we can create the directory structure
    required for a macOS application bundle. The location of the files is important,
    and is set out as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在元数据已经创建，我们可以创建 macOS 应用程序包所需的目录结构。文件的位置很重要，如下所示：
- en: File `pathDescription`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `pathDescription`
- en: '| `myapp.app/Contents/Info.plist` | The application metadata outlined in the
    preceding |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `myapp.app/Contents/Info.plist` | 前面概述的应用程序元数据 |'
- en: '| `myapp.app/Contents/Resources/myapp.icns` | The application icon in ICNS
    format |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `myapp.app/Contents/Resources/myapp.icns` | ICNS 格式的应用程序图标 |'
- en: '| `myapp.app/Contents/MacOS/myapp` | The application executable |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `myapp.app/Contents/MacOS/myapp` | 应用程序的可执行文件 |'
- en: 'After creating these directories and moving files to the correct location,
    you have a complete application bundle. This can be executed by double-clicking
    the icon and it can be distributed in this state. Installation consists of dragging
    this icon into the `Applications` folder of the computer, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这些目录并将文件移动到正确的位置后，你就拥有了一个完整的应用程序包。可以通过双击图标来执行它，并且可以以这种状态进行分发。安装过程是将此图标拖动到计算机的
    `Applications` 文件夹中，如下所示：
- en: '![](img/8cb89486-99ae-4c56-a8aa-351e51eee3c6.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cb89486-99ae-4c56-a8aa-351e51eee3c6.png)'
- en: Creating the .app directory structure and adding metadata creates a macOS application
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `.app` 目录结构和添加元数据可以创建一个 macOS 应用程序
- en: 'Looking at the result in Finder, we see the new directory as an application,
    its `.app` extension is hidden, and the icon is the same we set up before. You
    can launch, install, or remove this app like any other:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Finder 中查看结果，我们看到新目录被识别为应用程序，其 `.app` 扩展名被隐藏，图标与我们之前设置的一样。你可以像其他任何应用程序一样启动、安装或删除此应用程序：
- en: '![](img/2de161ae-7a61-4c3e-a13c-55e908e02b82.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2de161ae-7a61-4c3e-a13c-55e908e02b82.png)'
- en: Our .app directory shows as the application it describes
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `.app` 目录显示为它所描述的应用程序
- en: Windows
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: Metadata for applications in Windows is embedded into the executable file rather
    than in additional files. To do this, we create metadata files and then use a
    resource tool to include them in the final executable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 中的应用程序元数据嵌入到可执行文件中，而不是在附加文件中。为此，我们创建元数据文件，然后使用资源工具将它们包含在最终的执行文件中。
- en: Creating metadata files
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建元数据文件
- en: 'To include application metadata, we create an application manifest file like
    those used in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to
    the Rescue!,* and [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    – Building Graphical Windows Applications, *when we were building applications
    using the Common Controls widget set (via Walk and andlabs UI). The contents of
    the `assemblyIdentity` instance is used to determine the metadata about the executable.
    For a platform-independent GUI, the file should look like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含应用程序元数据，我们创建一个类似于 [第 3 章](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml)，“Go
    to the Rescue!” 和 [第 4 章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，“Walk –
    Building Graphical Windows Applications” 中使用的应用程序清单文件，当时我们使用 Common Controls 小部件集（通过
    Walk 和 andlabs UI）构建应用程序。`assemblyIdentity` 实例的内容用于确定有关可执行文件的元数据。对于平台无关的 GUI，文件应如下所示：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don't, however, remove the `<dependency>` section if you are using Walk, andlabs
    UI, or another toolkit that needs to have a dependency listed in its manifest
    file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用 Walk、andlabs UI 或其他需要在清单文件中列出依赖项的工具集，请不要删除 `<dependency>` 部分。
- en: To add more metadata that may be useful to users (for example, product name
    and version) you will need to manually set extra values. The goversioninfo tool from
    [github.com/josephspurrier/goversioninfo/](https://github.com/josephspurrier/goversioninfo/)
    is the easiest way to add these values. Be aware that you can only write to the
    `.syso` file once, as running these tools again will overwrite the previous content.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加可能对用户有用的更多元数据（例如，产品名称和版本），你需要手动设置额外的值。来自 [github.com/josephspurrier/goversioninfo/](https://github.com/josephspurrier/goversioninfo/)
    的 goversioninfo 工具是添加这些值的简单方法。请注意，你只能写入 `.syso` 文件一次，因为再次运行这些工具将覆盖之前的内容。
- en: To prepare our icon for Windows, it must be converted into a `.ico` file (the
    Microsoft icon format). While there are no icon conversion tools pre-installed
    with Windows, there are many paid-for applications available that will work. If
    you prefer a free solution, there are websites that offer image conversion services
    for no cost. If your development platform is Linux or macOS, you could install
    `icotool`, which supports the `.ico` format.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备我们的图标以供 Windows 使用，它必须被转换成 `.ico` 文件（微软图标格式）。虽然 Windows 中没有预安装的图标转换工具，但有许多付费应用程序可以工作。如果你更喜欢免费解决方案，有一些网站提供免费图像转换服务。如果你的开发平台是
    Linux 或 macOS，你可以安装 `icotool`，它支持 `.ico` 格式。
- en: Packaging release
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包发布
- en: 'To package the data for release, we will embed this metadata into the application
    binary. Doing so requires creating a binary resource file (ending in `.syso`)
    that will encapsulate the manifest and icon files. The easiest way to do this
    is with the `rsrc` tool that was used in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    – Building Graphical Windows Applications*. If you have not yet installed `rsrc`,
    you can do so with `go get github.com/akavel/rsrc`. We tell the tool where to
    find the manifest and icon files and it will output an `rsrc.syso` file in the
    current directory, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打包发布的数据，我们将此元数据嵌入到应用程序二进制文件中。这样做需要创建一个二进制资源文件（以`.syso`结尾），它将封装清单和图标文件。最简单的方法是使用[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，*Walk
    – 构建图形Windows应用程序*中使用的`rsrc`工具。如果您尚未安装`rsrc`，可以使用`go get github.com/akavel/rsrc`进行安装。我们告诉工具在哪里找到清单和图标文件，它将在当前目录中输出一个`rsrc.syso`文件，如下所示：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you are compiling for a 64 bit target, you will need to specify an additional
    `-arch amd64` parameter. It is important that the resource file generated is for
    the same architecture (either i386 or amd64) as the application you are compiling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为64位目标编译，您需要指定一个额外的`-arch amd64`参数。重要的是生成的资源文件与您正在编译的应用程序具有相同的架构（i386或amd64）。
- en: 'Now that the metadata has been bundled into a resource file, we have to re-build
    our project. Make sure that, this time, you add the `-ldflags="-H windowsgui"`
    parameter, otherwise the resulting application will display a Terminal window
    when starting:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在元数据已经打包到资源文件中，我们必须重新构建我们的项目。确保这次，您添加了`-ldflags="-H windowsgui"`参数，否则生成的应用程序在启动时将显示终端窗口：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the build is complete, we will have created a Windows executable with
    the icon and metadata included. You can now launch this from the command line
    or by double-clicking the icon:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，我们将创建一个包含图标和元数据的Windows可执行文件。现在您可以从命令行或通过双击图标来启动它：
- en: '![](img/f542c0d7-062a-4c72-a6be-5c430f8ca308.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f542c0d7-062a-4c72-a6be-5c430f8ca308.png)'
- en: Building the application after generating a resource bundle will automatically
    include the data
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成资源包之后构建应用程序将自动包含数据
- en: 'Here, we see the same directory in Windows Explorer. The application is on
    the left in the screenshot that follows, displayed using the icon we included:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到Windows资源管理器中的相同目录。在下面的屏幕截图中，应用程序位于左侧，使用我们包含的图标显示：
- en: '![](img/e2c1e3b0-cf5b-4aef-8f20-12b27dd19789.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2c1e3b0-cf5b-4aef-8f20-12b27dd19789.png)'
- en: Our Windows application with the icon embedded
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们嵌入图标的Windows应用程序
- en: These processes are slow and can be prone to errors. To avoid doing this process
    manually, we will explore tools that could automate this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程很慢，并且可能容易出错。为了避免手动执行此过程，我们将探讨可以自动化此过程的工具。
- en: Cross-platform packaging tools
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台打包工具
- en: As you can see, each operating system requires very different packaging. Additionally,
    the tools that would normally make the process simple are typically platform-specific,
    making it more difficult to build from a single system. The distribution of GUI
    applications is an area in which Go tools are also lacking. The Go language is
    great for rapidly creating cross-platform software, but it is not designed to
    handle the complication of graphical application packaging.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个操作系统都需要非常不同的打包方式。此外，通常使过程变得简单的工具通常是平台特定的，这使得从单个系统构建变得更加困难。GUI应用程序的发行是一个Go工具也缺乏的领域。Go语言非常适合快速创建跨平台软件，但它并不是为了处理图形应用程序打包的复杂性而设计的。
- en: In [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml),  *Toolkits Using
    Existing Widgets,* we explored toolkits that are very mature, but as they are
    either not written for Go, or are not designed to be cross-platform, they do not
    provide the tools we could use. [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml),* 
    Modern Graphical Toolkits,* looked at toolkits that are more focused on providing
    graphical capabilities rather than application life cycle, and so do not provide
    suitable tools either.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2节](36bfea00-c659-4569-864c-de2c460c7467.xhtml)，*使用现有小部件的工具包*中，我们探讨了非常成熟的工具包，但它们要么不是为Go编写的，要么不是为跨平台设计的，因此它们不提供我们可以使用的工具。[第3节](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml)，*现代图形工具包*则研究了更专注于提供图形功能而不是应用程序生命周期的工具包，因此也不提供合适的工具。
- en: fyne package
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fyne打包
- en: One exception is the Fyne project as it aims to provide APIs for full application
    life cycle, and so the tools support distributing complete desktop apps across
    multiple platforms. While the project is still early it does have a tool that
    can help with application packaging (even if you've not used Fyne in your code).
    The `fyne package` command is designed to generate and package all the required
    metadata for an application to distribute on macOS, Linux, or Windows. Invoking
    with the `-os <platform>` parameter (using one of "darwin", "linux", or "windows")
    will create a fully packaged application in the current directory. Before executing
    this command the application should already be compiled for release.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例外是 Fyne 项目，因为它旨在提供全应用生命周期的 API，因此工具支持在多个平台上分发完整的桌面应用程序。虽然该项目仍处于早期阶段，但它确实有一个可以帮助应用打包的工具（即使你尚未在代码中使用
    Fyne）。`fyne package` 命令旨在生成并打包应用程序在 macOS、Linux 或 Windows 上分发的所有必需元数据。使用 `-os
    <platform>` 参数（使用 "darwin"、"linux" 或 "windows" 之一）将在当前目录中创建一个完整打包的应用程序。在执行此命令之前，应用程序应该已经编译为发布版本。
- en: 'For example, we can create a macOS application bundle from a Linux computer
    using `fyne package -os linux`. There are many additional parameters that can
    change the contents of the application, and the most useful will be the `-icon
    <filename>` parameter (which is required). If you were not already using Fyne,
    then the command should be installed using `go get fyne.io/fyne/cmd/fyne`, as
    follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 `fyne package -os linux` 从 Linux 计算机创建 macOS 应用程序包。有许多其他参数可以更改应用程序的内容，其中最有用的是
    `-icon <filename>` 参数（这是必需的）。如果你之前没有使用 Fyne，那么应该使用以下命令安装：`go get fyne.io/fyne/cmd/fyne`。
- en: '![](img/9dae04be-79a5-43c1-b541-4f4151be752c.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9dae04be-79a5-43c1-b541-4f4151be752c.png)'
- en: Building a macOS application bundle on Linux with "fyne package"
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上使用 "fyne package" 构建 macOS 应用程序包
- en: As you can see in the preceding screenshot, the tool generated an `.app` directory
    structure (which defines a macOS application) from a Linux Terminal. We used the
    same platform name for the `GOOS` environment and the `-os` parameter to `fyne
    package`. It's recommended to build for one platform and then package it before
    changing the target operating system to avoid potential errors in the output package.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，该工具从 Linux 终端生成了一个 `.app` 目录结构（它定义了一个 macOS 应用程序）。我们为 `GOOS` 环境和 `fyne
    package` 的 `-os` 参数使用了相同的平台名称。建议为单个平台构建并打包，然后再更改目标操作系统，以避免输出包中可能出现的错误。
- en: The applications we have built in this section could be distributed right away.
    Uploading to a website or sharing the files in some other manner would work, but
    we want to make the process completely seamless for users. Let's wrap up this
    chapter by looking at the various distribution channels that exist for desktop
    application delivery directly to end users.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中构建的应用程序可以立即分发。上传到网站或以其他方式共享文件都可以，但我们希望为用户提供一个完全无缝的过程。让我们通过查看直接向最终用户交付桌面应用程序的各种分发渠道来结束本章。
- en: Distributing to platform marketplaces
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发到平台市场
- en: Most operating systems now have a central location for discovering and installing
    applications. Apple created the Mac App Store, Windows has the Microsoft Store,
    and each Linux distribution has its preferred package manager. Having an application
    listed in (and hosted by) a platform marketplace significantly increases the number
    of users you can expect and also reduces associated hosting costs. When paired
    with carefully prepared metadata (as described at the beginning of this chapter),
    a marketplace can easily become your largest distribution channel. How to get
    applications included in these directories is specific to each platform, so we
    will look at the process for each in turn.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统现在都有一个中心位置用于发现和安装应用程序。苹果创建了 Mac App Store，Windows 有微软商店，每个 Linux 发行版都有自己的首选包管理器。在平台市场中列出（并由其托管）的应用程序可以显著增加你预期的用户数量，并降低相关的托管成本。当与精心准备的元数据（如本章开头所述）相结合时，市场可以轻松成为你最大的分发渠道。如何将这些目录中的应用程序包含在内，每个平台都有其特定的方法，因此我们将依次查看每个平台的过程。
- en: Mac App Store
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mac App Store
- en: The Mac App Store is the desktop version of Apple's famous iOS App Store. It
    provides many thousands of applications available to buy and download, or gift
    to others. There is also curated content, which includes listings of the most
    popular apps in various categories, as well as staff picks and recommended software.
    Apple provides education discounts as well as free copies to family members if
    one person makes a purchase. You can also redeem gift cards towards making purchases
    of apps or subscriptions. Unfortunately, the Mac App Store cannot be browsed online
    as it requires the App Store software, which is pre-installed on compatible Mac
    computers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Mac App Store是苹果著名的iOS App Store的桌面版本。它提供了成千上万的应用程序可供购买、下载或赠送给他人。此外，还有精选内容，包括各种类别中最受欢迎的应用程序列表，以及员工精选和推荐软件。如果有人购买，苹果还提供教育折扣以及免费提供给家庭成员的副本。您还可以使用礼品卡兑换购买应用程序或订阅的费用。不幸的是，Mac
    App Store不能在线浏览，因为它需要预安装在兼容Mac电脑上的App Store软件。
- en: As well as having the development tools installed, you will also need to sign
    up to the Apple Developer Program. If you are not already a member you can sign
    up on their website here: [developer.apple.com/programs/enroll/](https://developer.apple.com/programs/enroll/).
    The development resources are free to access, but there is an annual subscription
    charge for access to the code signing tools, which are required to publish software
    to any of their App Stores.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装开发工具之外，您还需要注册苹果开发者计划。如果您还不是会员，可以在此网站上注册：[developer.apple.com/programs/enroll/](https://developer.apple.com/programs/enroll/)。开发资源可以免费访问，但访问代码签名工具需要支付年度订阅费用，这些工具是发布软件到其任何App
    Store所必需的。
- en: Packaging
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包
- en: Packaging applications for submission are managed by the XCode tools (which
    you should already have installed). The process is optimized for submitting apps
    that have been built with XCode and, as it does not support Go, we have some manual
    steps to complete.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 提交应用程序的打包由XCode工具（您应该已经安装了）管理。该过程针对使用XCode构建的应用程序提交进行了优化，因为它不支持Go，所以我们有一些手动步骤需要完成。
- en: 'The application package that we created earlier (for macOS distribution) will
    have to be signed before we can upload to the App Store. Code signing is a complicated
    process to set up, so for the purpose of this description, it is assumed that
    you already have a distribution certificate installed. You need to note the name
    of the certificate (use Keychain Access to find your developer certificates) and
    then use that name in the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的应用程序包（针对macOS分发）在我们可以上传到App Store之前必须进行签名。代码签名是一个复杂的设置过程，因此在本描述中，我们假设您已经安装了分发证书。您需要记下证书的名称（使用“密钥链访问”查找您的开发者证书），然后在以下命令中使用该名称：
- en: '[PRE7]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The resulting app package is ready to be uploaded to the App Store Connect website
    for validation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的应用程序包已准备好上传到App Store Connect网站进行验证。
- en: Uploading
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传
- en: App Store applications are managed through the App Store Connect website (at [appstoreconnect.apple.com/](https://appstoreconnect.apple.com/)).
    Log in using your Apple developer account and create a new application (if you
    have not already done so). This is where you add the metadata that will be displayed
    in the store—be sure to check the information carefully as some data cannot be
    changed after release. Well-chosen descriptions and screenshots will help your
    application to be more easily discovered. Within this app definition, you need
    to start preparing a new release, with an appropriate version number and supporting
    information. You will probably notice that you are not yet able to select a build—to
    enable this, we first need to upload the compiled package.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: App Store应用程序通过App Store Connect网站（在[appstoreconnect.apple.com/](https://appstoreconnect.apple.com/)）进行管理。使用您的苹果开发者账户登录并创建一个新的应用程序（如果您还没有这样做）。这是您添加将在商店中显示的元数据的地方——务必仔细检查信息，因为一些数据发布后无法更改。精心挑选的描述和截图将有助于您的应用程序更容易被发现。在此应用程序定义中，您需要开始准备一个新的版本，包括适当的版本号和相关支持信息。您可能会注意到您还不能选择构建版本——为了启用此功能，我们首先需要上传编译包。
- en: 'The application loader tool is the easiest way to upload a new build: open
    the app and log in with your Apple ID. Once logged in, you will be asked to choose
    the application to upload; select the matching application and progress to the
    upload. Once complete, the build will appear in the App Store Connect website
    (you may need to refresh the page). If you prefer command-line tools for managing
    the progress, you can use `xcrun altool`, which provides the same capability.
    Once you''ve chosen this new build, you can press the Submit for Review button
    to start the review process.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序加载工具是上传新构建的最简单方法：打开应用并使用您的Apple ID登录。登录后，您将被要求选择要上传的应用程序；选择匹配的应用程序并继续上传。完成后，构建将出现在App
    Store Connect网站上（您可能需要刷新页面）。如果您更喜欢用于管理进度的命令行工具，可以使用`xcrun altool`，它提供相同的功能。一旦您选择了这个新构建，您就可以点击“提交审核”按钮开始审核流程。
- en: Reviewing
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审核过程
- en: As soon as an app is submitted for review, it goes through an automated set
    of code checks. This process verifies that the application does not contain obvious
    errors in metadata or code signing and performs code analysis to ensure you are
    not using APIs that are private to Apple or otherwise restricted. Assuming that
    these automated checks pass, then the application will be sent for final acceptance
    by a member of the App Store review team.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序提交审核，它将经过一系列自动的代码检查。此过程验证应用程序不包含元数据或代码签名中的明显错误，并执行代码分析以确保您没有使用苹果公司专有的或受限制的API。假设这些自动检查通过，则应用程序将被发送给App
    Store审核团队的一员进行最终接受。
- en: The review team checks your application for quality, reliability, compliance
    with the **Human Interface Guidelines** (**HIG** –[developer.apple.com/app-store/review/](https://developer.apple.com/app-store/review/)),
    and that it meets other criteria for inclusion on the store. This process typically
    takes a day or two, but can be longer for the first release of a new application.
    Once the process is complete your software will be available to purchase or download
    on the App Store. In your first week of distribution, it may even be included
    in the *New and Noteworthy* section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 审核团队会检查您的应用程序的质量、可靠性、是否符合**人类界面指南**（**HIG** - [developer.apple.com/app-store/review/](https://developer.apple.com/app-store/review/)），以及它是否符合商店收录的其他标准。此过程通常需要一两天，但新应用程序的首次发布可能需要更长的时间。一旦过程完成，您的软件将在App
    Store上可供购买或下载。在您的第一周分发中，它甚至可能被包括在“新功能和值得注意”部分。
- en: Microsoft Store
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微软商店
- en: The Microsoft Store is the official location for finding and installing software,
    apps, and games for all of the current Windows, Windows Phone, and Xbox devices.
    As well as offering hosting and search facilities it handles payments for non-free
    software and supports discounts and vouchers as well. You can browse the contents
    of the Microsoft Store online (at [www.microsoft.com/store/apps](https://www.microsoft.com/store/apps))
    or by using the store apps on each of the systems it supports.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 微软商店是查找和安装所有当前Windows、Windows Phone和Xbox设备的软件、应用程序和游戏的官方位置。除了提供托管和搜索功能外，它还处理非免费软件的支付，并支持折扣和优惠券。您可以通过在线浏览微软商店的内容（在[www.microsoft.com/store/apps](https://www.microsoft.com/store/apps)）或使用它支持的每个系统上的商店应用程序。
- en: To submit an application to the Microsoft Store, you will require a Microsoft
    account (which you may already have if you signed in to Windows, Xbox, or Office
    365). You will also have to start an annual subscription to access the relevant
    portions of the developer portal. You can log in and sign up at [appdev.microsoft.com/StorePortals](https://appdev.microsoft.com/StorePortals).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序提交到微软商店，您需要一个微软账户（如果您已登录Windows、Xbox或Office 365，您可能已经有了）。您还必须开始年度订阅以访问开发者门户的相关部分。您可以在[appdev.microsoft.com/StorePortals](https://appdev.microsoft.com/StorePortals)登录和注册。
- en: Packaging
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包
- en: The tools required to create an application package for uploading to the Microsoft
    Store are included as part of the Windows Software Development Kit. If you have
    not already installed this you can download it from [developer.microsoft.com/en-us/windows/downloads](https://developer.microsoft.com/en-us/windows/downloads),
    either as part of Visual Studio, or as a separate package.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于上传到微软商店的应用程序包所需的工具包含在Windows软件开发工具包中。如果您尚未安装，可以从[developer.microsoft.com/en-us/windows/downloads](https://developer.microsoft.com/en-us/windows/downloads)下载，无论是作为Visual
    Studio的一部分还是作为单独的包。
- en: To upload an application to the store we must create a `.appx` file (an application
    package). This requires an additional manifest file, named `AppxManifest.xml`,
    which contains the metadata about the application being packaged. Its contents
    are documented on the Microsoft website at [docs.microsoft.com/en-us/uwp/schemas/appxpackage/how-to-create-a-basic-package-manifest](https://docs.microsoft.com/en-us/uwp/schemas/appxpackage/how-to-create-a-basic-package-manifest).
    The resulting manifest file should have at least one `Application` element within
    the `Applications` section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序上传到商店，我们必须创建一个`.appx`文件（一个应用程序包）。这需要一个额外的清单文件，名为`AppxManifest.xml`，其中包含正在打包的应用程序的元数据。其内容在微软网站上进行了文档化，网址为[docs.microsoft.com/en-us/uwp/schemas/appxpackage/how-to-create-a-basic-package-manifest](https://docs.microsoft.com/en-us/uwp/schemas/appxpackage/how-to-create-a-basic-package-manifest)。生成的清单文件应在`Applications`部分至少包含一个`Application`元素。
- en: 'To create the package from our source files, we use a `MakeAppx.exe` command,
    as indicated in the following code snippet. By using the `/d` parameter, we can
    specify a directory of files to package – if you want to use a subset of the files,
    you can create a mapping file and specify that with the `/f` parameter instead:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的源文件创建软件包时，我们使用`MakeAppx.exe`命令，如下面的代码片段所示。通过使用`/d`参数，我们可以指定要打包的文件目录 - 如果您只想使用文件的一部分，您可以使用映射文件并通过`/f`参数指定它：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once the `.appx` file has been created, it must be signed. The `SignTool.exe`
    command can be used to sign an application package. Setting up the certification
    to support application signing is outside the scope of this chapter, but the documentation
    on the Microsoft developer portal will take you through the process. Ensure that
    the publisher listed in the manifest file matches the certificate that you create
    to sign the package.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建`.appx`文件，它必须进行签名。可以使用`SignTool.exe`命令对应用程序包进行签名。设置用于应用程序签名的证书超出了本章的范围，但微软开发者门户上的文档将指导您完成此过程。请确保清单文件中列出的发布者与您创建用于签名包的证书相匹配。
- en: Uploading
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传
- en: The completed package should be uploaded to the developer portal within the
    `Packages` page. When preparing for upload, make sure that all of your application
    metadata has been added to the correct locations so that people will find your
    software easily.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的软件包应上传到开发者门户中的“软件包”页面。在准备上传时，请确保您的所有应用程序元数据都已添加到正确的位置，以便人们可以轻松找到您的软件。
- en: Once the package is uploaded, it will be checked for various errors that could
    stop it from being released. Should you encounter any warnings, you will need
    to remove the uploaded build from the portal and fix the issue. Once resolved,
    you will need to fully re-package, re-sign, and upload the new package for re-testing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦软件包上传，它将检查各种可能导致其无法发布的错误。如果您遇到任何警告，您需要从门户中删除已上传的构建版本并修复问题。一旦解决，您需要重新打包、重新签名并上传新的软件包以进行重新测试。
- en: Reviewing
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查
- en: Once your package is uploaded and has passed the initial validation it will
    be added to a queue to be reviewed. The Microsoft staff will review your application
    for correctness and suitability, and validate that it is of high enough quality
    for inclusion in the store. Assuming that these checks all pass, they will publish
    it for distribution across the devices that you specified during the submission
    process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的软件包上传并通过初步验证，它将被添加到队列中等待审查。微软的工作人员将审查您的应用程序的正确性和适用性，并验证其质量是否足够高，可以包含在商店中。假设所有这些检查都通过，他们将发布它以便在您在提交过程中指定的设备上分发。
- en: Linux package manager
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 软件包管理器
- en: For many years, Linux distributions have had a reputation for handling package
    distribution well. A desktop system will likely have a graphical package management
    application that provides easily searchable indexes containing thousands of packages.
    More recently, various applications have been created to help with software discovery
    (to make finding new packages easier).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Linux 发行版在处理软件包分发方面享有良好声誉。桌面系统可能有一个图形化的软件包管理应用程序，它提供易于搜索的索引，包含数千个软件包。最近，各种应用程序被创建出来，以帮助软件发现（使查找新软件包更容易）。
- en: Applications such as *Discover* (more information on this can be found at [userbase.kde.org/Discover](https://userbase.kde.org/Discover))
    can be used on most systems by working with many different package managers. Others,
    such as *Ubuntu Software Center*, aim to make it easier to find applications for
    specific systems based on categories, ratings, and other enhanced metadata.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 *Discover*（更多关于此的信息可以在 [userbase.kde.org/Discover](https://userbase.kde.org/Discover)
    找到）这样的应用可以在大多数系统上使用，通过配合许多不同的包管理器工作。其他一些，如 *Ubuntu 软件中心*，旨在通过类别、评分和其他增强元数据使特定系统的应用程序查找更加容易。
- en: Despite there being hundreds of different Linux distributions only a handful
    of packaging formats are needed to support them. In this section we look at the
    three most popular formats: *Debian*, *Red Hat,* and *Tarball*. Once packages
    have been created for a system the application developer can submit it to a package
    list. As Linux is an open source system, however, you may find that an existing
    package maintainer may be happy to do that for you!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有数百种不同的 Linux 发行版，但只需要少数几种打包格式来支持它们。在本节中，我们将探讨三种最流行的格式：*Debian*、*Red Hat*
    和 *Tarball*。一旦为系统创建了软件包，应用程序开发者就可以将其提交到包列表中。然而，由于 Linux 是一个开源系统，你可能发现现有的包维护者可能很乐意为你做这件事！
- en: Debian (.deb)
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Debian (.deb)
- en: Distribution for Debian is very similar to the `.tar.gz` distribution we created
    earlier, with the addition of specific metadata that allow the Debian tools to
    search and correctly install the software. Packaging for Debian is described in
    detail on their website ([wiki.debian.org/HowToPackageForDebian](https://wiki.debian.org/HowToPackageForDebian)),
    but the basic process is to add the metadata (*Debianization*), build the package
    to conform to their filesystem layout, and then (optionally) sign the package
    so that users know they can trust the content.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 的分发与我们在前面创建的 `.tar.gz` 分发非常相似，只是增加了特定的元数据，这使得 Debian 工具能够搜索和正确安装软件。Debian
    的打包在他们的网站上详细描述（[wiki.debian.org/HowToPackageForDebian](https://wiki.debian.org/HowToPackageForDebian)），但基本过程是添加元数据（*Debian化*），构建符合其文件系统布局的软件包，然后（可选）对软件包进行签名，以便用户知道他们可以信任内容。
- en: Packaging
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包
- en: The `dh_make` command is provided to automate the creation of required metadata
    files, and running it inside the existing Linux packaging directory structure
    will add the necessary files. Once run, you should check all the files in the
    `debian/` directory to update information as appropriate. The `debuild` command
    will create a Debian package for our software once the metadata has been added.
    After it's creation, you should use the `lintian` command to check the package
    for a number of common errors.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了 `dh_make` 命令来自动创建所需的元数据文件，并在现有的 Linux 打包目录结构中运行它将添加必要的文件。一旦运行，你应该检查 `debian/`
    目录中的所有文件，根据需要更新信息。一旦添加了元数据，`debuild` 命令将为我们的软件创建一个 Debian 软件包。创建后，你应该使用 `lintian`
    命令检查软件包是否存在许多常见错误。
- en: Although not required, you could then sign the package using the `debsigs` tool.
    This creates a signed package, which provides cryptographic proof that the package
    contains what the developers intended. As mentioned earlier, setting up certificates
    and signing is complex and not covered by this book.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需的，但你可以使用 `debsigs` 工具对软件包进行签名。这会创建一个签名的软件包，它提供了加密证明，表明软件包包含开发者所期望的内容。如前所述，设置证书和签名是复杂的过程，本书不涉及。
- en: Distribution
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发
- en: Once your package is prepared you can distribute the file directly to other
    Debian users. However, the aim was to include it in the package listing. To do
    so requires a process that starts by filing Intent to Package in their bug tracker
    ([bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=wnpp;dist=unstable](https://bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=wnpp;dist=unstable)).
    To complete the process, you will need to find a sponsor for your package or become
    a Debian developer. Either of which will require you to contact the development
    community to learn more; full details can be found at [wiki.debian.org/DebianMentorsFaq](https://wiki.debian.org/DebianMentorsFaq).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的软件包准备就绪，你可以直接将其文件分发给其他 Debian 用户。然而，目标是将其包含在软件包列表中。为此，需要开始于在他们的错误跟踪器中提交“打包意图”([bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=wnpp;dist=unstable](https://bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=wnpp;dist=unstable)))。要完成这个过程，你需要为你的软件包找到一个赞助者或成为
    Debian 开发者。无论哪种情况，你都需要联系开发社区以了解更多信息；详细信息可以在 [wiki.debian.org/DebianMentorsFaq](https://wiki.debian.org/DebianMentorsFaq)
    找到。
- en: Red Hat (.rpm)
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Red Hat (.rpm)
- en: RPM files are very similar to Debian packages but with a different set of metadata.
    Once again, there are standard tools that can help with the creation of these
    files and to create the final package. To start with, you should install the `rpm` or
    `rpm-build` package in your Linux distribution, which should include the necessary
    commands.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: RPM 文件与 Debian 软件包非常相似，但具有不同的元数据集。同样，有一些标准工具可以帮助创建这些文件，并创建最终的软件包。首先，你应该在你的 Linux
    发行版中安装 `rpm` 或 `rpm-build` 软件包，它应该包括必要的命令。
- en: Packaging
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包
- en: First, we must create a `.spec` file to describe the package. The `rpmdev-newspec`
    command can provide one from the templates option to get you started. Update the
    contents according to your application information. This file will contain all
    the metadata about your software (including its source location, the license,
    and authors). The spec file also provides the build information required to assemble
    the package, as well as instructions for installation scripts, and more.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个 `.spec` 文件来描述这个软件包。`rpmdev-newspec` 命令可以从模板选项中提供一个，帮助你开始。根据你的应用程序信息更新内容。这个文件将包含关于你的软件的所有元数据（包括其源位置、许可证和作者）。spec
    文件还提供了组装软件包所需的构建信息，以及安装脚本和更多内容。
- en: Once the metadata is complete, the package can be built using the `rpmbuild` command.
    It is normal that this will not succeed on the first attempt. Read the output
    and update the `.spec` file accordingly, then re-run the build command. The finished
    output will be your completed `.rpm` file ready for testing. At this time, you
    can test the file by installing it manually (on a compatible Linux computer) and
    verifying that the software works as expected.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦元数据完成，就可以使用 `rpmbuild` 命令构建软件包。第一次尝试不成功是正常的。阅读输出并根据需要更新 `.spec` 文件，然后重新运行构建命令。完成后的输出将是你的完成
    `.rpm` 文件，准备进行测试。此时，你可以通过手动安装（在兼容的 Linux 计算机上）并验证软件是否按预期工作来测试该文件。
- en: Distribution
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发
- en: Now that the package is prepared, it can be distributed using your website –
    an RPM file can be downloaded and installed relatively easily. Inclusion in Linux
    distributions is a complicated process and the details are different for each
    variant. CentOS, Fedora, and Red Hat Enterprise Linux all use the RPM package
    format, as do many others, but the process of submission is not well-documented. The Fedora
    project has comprehensive documentation, which you can refer to at [fedoraproject.org/wiki/Package_Review_Process](https://fedoraproject.org/wiki/Package_Review_Process).
    For most package inquiries, the best approach is to contact the current distribution
    maintainers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在软件包已经准备好了，可以通过你的网站进行分发——RPM 文件可以相对容易地下载和安装。Linux 发行版的包含是一个复杂的过程，每个变种的细节都不同。CentOS、Fedora
    和 Red Hat Enterprise Linux 都使用 RPM 软件包格式，许多其他发行版也是如此，但提交过程并没有很好地记录。Fedora 项目有全面的文档，你可以在
    [fedoraproject.org/wiki/Package_Review_Process](https://fedoraproject.org/wiki/Package_Review_Process)
    上参考。对于大多数软件包查询，最好的方法是联系当前的发行版维护者。
- en: Tarball (.tar.gz)
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包文件 (.tar.gz)
- en: The tarball is a generic packaging for binary (and source-based) distribution
    of applications. The `.tar.gz` package that we built earlier in this chapter is
    an example of a possible tarball distribution. With Linux, most applications are
    open source, meaning that packaging is typically done from the source code rather
    than from the compiled output. It is possible to use a binary release, as we have
    built, but bear in mind that some distributions may push back on including such
    a package based on their own policies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 打包文件是对应用程序的二进制（和基于源）分发的通用打包。我们在本章前面构建的 `.tar.gz` 软件包是一个可能的打包文件分发的例子。在 Linux
    中，大多数应用程序是开源的，这意味着打包通常是从源代码而不是从编译输出进行的。我们可以使用二进制发布版，就像我们构建的那样，但请记住，一些发行版可能会根据它们自己的政策反对包含这样的软件包。
- en: Arch Linux
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arch Linux
- en: The Arch Linux package manager, pacman, relies on `PKGBUILD` files to understand
    how to locate and install software packages. The `PKGBUILD` file is a specific
    format of shell script (executable text file for the command line) that describes
    the package metadata, any dependencies that it must install first, and the installation
    process for a package. Full details of the `PKGBUILD` file can be found at [wiki.archlinux.org/index.php/PKGBUILD](https://wiki.archlinux.org/index.php/PKGBUILD).
    A valid file must contain at least `pkgname`, `pkgver`, `pkgrel`, and `arch` variables.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Arch Linux 的包管理器 pacman 依赖于 `PKGBUILD` 文件来了解如何定位和安装软件包。`PKGBUILD` 文件是一种特定的 shell
    脚本格式（命令行可执行文本文件），它描述了包的元数据、必须首先安装的任何依赖项以及包的安装过程。`PKGBUILD` 文件的完整详情可以在 [wiki.archlinux.org/index.php/PKGBUILD](https://wiki.archlinux.org/index.php/PKGBUILD)
    找到。一个有效的文件必须至少包含 `pkgname`、`pkgver`、`pkgrel` 和 `arch` 变量。
- en: To create a package once the `PKGBUILD` file is created, you run the `makepkg`
    command. This will execute the steps defined in the script file and prepare the
    resulting package. It is recommended to check the finished package file using
    the `namcap` command which validates that certain common mistakes have not been
    made.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包的过程是在创建 `PKGBUILD` 文件后运行 `makepkg` 命令。这将执行脚本文件中定义的步骤并准备生成的包。建议使用 `namcap`
    命令检查完成的包文件，以确保没有犯下某些常见的错误。
- en: Newly created packages can be submitted to the *Arch User Repository* where
    other Arch Linux users will be able to install it. Notable packages can be promoted
    from this location to the official repository over time. Details for submitting
    your package can be found at [wiki.archlinux.org/index.php/Arch_User_Repository#Submitting_packages](https://wiki.archlinux.org/index.php/Arch_User_Repository#Submitting_packages).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的包可以提交到 *Arch 用户仓库*，其他 Arch Linux 用户将能够安装它。随着时间的推移，值得注意的包可以从该位置提升到官方仓库。有关提交您的包的详细信息可以在
    [wiki.archlinux.org/index.php/Arch_User_Repository#Submitting_packages](https://wiki.archlinux.org/index.php/Arch_User_Repository#Submitting_packages)
    找到。
- en: Gentoo Linux
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gentoo Linux
- en: Gentoo Linux is (not uniquely) a source-based distribution. This means that
    the package system contains just instruction files that describe how to download
    and install software. This file is called an `ebuild` file and, like the `PKGBUILD`
    file previously, contains information about metadata, dependencies, and build
    instructions. Unlike Arch Linux, this descriptor file is the complete distribution
    – packagers do not build a binary distribution package using the metadata file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Gentoo Linux 是（并非唯一）基于源的分发版。这意味着包系统仅包含描述如何下载和安装软件的指令文件。此文件称为 `ebuild` 文件，类似于之前的
    `PKGBUILD` 文件，包含有关元数据、依赖项和构建指令的信息。与 Arch Linux 不同，此描述文件是完整的分发版 – 打包者不使用元数据文件构建二进制分发包。
- en: The process for submitting a new package to Gentoo Linux (once you have created
    the `ebuild` file) is described on their community documentation [https://wiki.gentoo.org/wiki/Submitting_ebuilds](https://wiki.gentoo.org/wiki/Submitting_ebuilds).
    As with other distributions, you will need to become part of the development community
    to add the package yourself, but you may convince an existing developer to maintain
    the package for you.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将新包提交给 Gentoo Linux 的过程（一旦创建了 `ebuild` 文件）可以在他们的社区文档 [https://wiki.gentoo.org/wiki/Submitting_ebuilds](https://wiki.gentoo.org/wiki/Submitting_ebuilds)
    中找到。与其他发行版一样，您需要成为开发社区的一部分才能自己添加包，但您可以说服现有的开发者为您维护该包。
- en: Others
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他
- en: Many other Linux distributions use similar packaging systems, but to mention
    them all would be too lengthy for this chapter. Each of their websites will provide
    information about how to complete a package and submit to their application listings.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他 Linux 发行版使用类似的打包系统，但在此章节中提及所有这些会过于冗长。每个网站都会提供有关如何完成包并将其提交到其应用程序列表的信息。
- en: Containers
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: An increasingly popular approach to application distribution is that of **application
    containerization**. This approach means that each application is packaged into
    a *container*, similar to how Docker and other tools are doing for server-based
    software. An application container is a single file that simulates a filesystem,
    into which an application is installed. Applications can be downloaded from a
    website or through a package manager and do not need to be installed to run. The
    same container file will run on any Linux distribution; there are even some container
    formats that aim to support multiple operating systems as well. AppImage, Snap,
    and Zero Install are some popular formats, each with particular benefits or target
    audiences. If you want to distribute a single Linux package for your application
    and are not so concerned about including it in the platform software lists, this
    approach may be right for you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序分发的越来越流行的方法是**应用容器化**。这种方法意味着每个应用程序都被打包成一个*容器*，类似于 Docker 和其他工具为基于服务器的软件所做的那样。应用程序容器是一个模拟文件系统的单个文件，应用程序被安装在其中。应用程序可以从网站或通过包管理器下载，并且不需要安装即可运行。相同的容器文件可以在任何
    Linux 发行版上运行；甚至还有一些容器格式旨在支持多个操作系统。AppImage、Snap 和 Zero Install 是一些流行的格式，每个都有其特定的优势或目标受众。如果您想为您的应用程序分发单个
    Linux 软件包，并且不太关心将其包含在平台软件列表中，这种方法可能适合您。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we looked at how to package and distribute Go-based graphical
    applications. Unlike the distribution of command-line or system utilities, the
    process of delivering a GUI application requires additional metadata and packaging.
    Users of graphical apps expect to find and install software in a particular manner
    that varies based on their operating system. We started by looking at the importance
    of good metadata and how to select an icon and description that will attract potential
    users to try out our new software. We then learned how to package assets into
    our Go-based applications. As the language is designed for single binary distribution,
    we had to incorporate all supporting files into the executable before distributing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们探讨了如何打包和分发基于 Go 的图形应用程序。与命令行或系统工具的分发不同，交付 GUI 应用程序的过程需要额外的元数据和打包。图形应用程序的用户期望以特定方式找到和安装软件，这取决于他们的操作系统。我们首先探讨了良好元数据的重要性以及如何选择一个图标和描述来吸引潜在用户尝试我们的新软件。然后我们学习了如何将资源打包到基于
    Go 的应用程序中。由于该语言是为单二进制分发而设计的，我们必须在分发之前将所有支持文件合并到可执行文件中。
- en: Packaging for different platforms can be complicated, so we walked through the
    steps required to build native-looking graphical packages for macOS, Windows,
    and Linux. Each package has its own metadata format and package structure but
    we were able to package our simple application for each of the specific formats.
    The packages that resulted from this step could be distributed through a website
    or other file sharing mechanism. However, we wanted to deliver the app where our
    users would expect to find it—in the system app store. And so we worked through
    the process of preparing and distributing the packages for each platform's marketplace.
    The Windows and macOS stores provide an opportunity for applications to earn revenue
    following release and the Linux software listings will help to increase visibility
    of our software package.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为不同平台打包可能会很复杂，因此我们介绍了构建原生外观的图形包所需的步骤，包括 macOS、Windows 和 Linux。每个包都有自己的元数据格式和包结构，但我们能够为每种特定格式打包我们的简单应用程序。这一步骤产生的包可以通过网站或其他文件共享机制进行分发。然而，我们希望将应用程序分发到用户期望找到的地方——系统应用商店。因此，我们完成了为每个平台市场准备和分发包的过程。Windows
    和 macOS 商店为应用程序在发布后赚取收入提供了机会，而 Linux 软件列表将有助于提高我们的软件包的可见性。
- en: Having learned the various approaches to building GUIs with Go and exploring
    the toolkits available, we've made it all of the way to a complete and published
    graphical application. Hopefully, you've learned a lot along the way and have
    managed to create the app that you had been aiming to build—using only Go to support
    a performant, maintainable, and beautiful user interface.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习使用 Go 语言构建 GUI 的各种方法并探索可用的工具包，我们已经完成了从零到有、从有到完整的图形应用程序的构建。希望你在学习过程中学到了很多，并且成功创建了原本想要构建的应用程序——仅使用
    Go 语言来支持高效、可维护且美观的用户界面。
