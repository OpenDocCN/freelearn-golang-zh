- en: Distributing Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should be familiar with how to build graphical user interfaces for
    applications using the Go language. The last step of any journey in building a
    graphical application is distribution. The process of packaging and releasing
    your completed product can be challenging, especially if you are publishing to
    multiple platforms, and we will explore these details in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the Go language and the libraries that we''ve utilized so far in this
    book make it easy to write software for multiple platforms, there is no escaping
    the fact that different operating systems require native graphical applications
    to be in different formats. For developers, it is often easy to forget this, as
    Go tools build from the source code in a way that''s consistent across different
    systems. To prepare an application for release, we will look at the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing metadata and icons for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling assets to fit with Go's *single binary* distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging a completed application for different operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading to platform marketplaces and app stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to package and distribute graphical
    applications ready to share with your target audience. You'll have worked through
    the steps to create application packages that can be downloaded or installed exactly
    as users on each of your distribution platforms expect. We start by gathering
    all of the information that you will need to complete a distribution for any system
    marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata and icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start on the technical aspects of creating an application release,
    there are a few prerequisites to consider. The application name is probably set
    by now, but do you have a great description for it? Do you know how to articulate
    the key features of your software in a way that will grab the attention of potential
    users? Have you (or your design team) created a great app icon that will be memorable
    and somehow indicative of its functionality?
  prefs: []
  type: TYPE_NORMAL
- en: If you will not be distributing through a managed channel such as an app store,
    you should consider how the application will be discovered by your target audience.
    There's a lot of discussion and information online about **Search Engine Optimization**
    (**SEO**) and a growing amount about **App Store Optimization** (**ASO**), so
    we will not go into detail here. What's clear in the current software climate
    is that ease of discovery and memorability are now more important than ever before.
  prefs: []
  type: TYPE_NORMAL
- en: Application icon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Picking your icon is probably the single most important part of preparing an
    application for release. It needs to be memorable and evoke some idea of what
    the software is for. A great icon should look good when displayed either large
    or small, and in general, tiny details should be avoided or only used for unimportant
    aspects of the design. Make sure that your icon is created at a high resolution;
    1024 x 1024 pixels is the minimum requirement for an icon to look great on the
    widest variety of devices. It's also important to consider the use of transparency—depending
    on the platforms you wish to distribute to, this may or may not be recommended.
    Most desktop systems allow the use of shaped icons, but not all will allow *semi-transparent* areas.
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to look at popular or commonplace icons on each of the operating
    systems or desktop environments where you expect your application to be used.
    Can you match your icon style to each of them successfully? Does it seem like
    a particular shape or style will be expected by users of these systems? It may
    be best, or necessary, to create different versions of the graphic for different
    platforms. Doing so is not a problem, and can be accommodated by passing different
    icons to the build tools we work with later.
  prefs: []
  type: TYPE_NORMAL
- en: Describing your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage of development, it's not uncommon to have a little marketing material
    ready for the software you have created. This is the time to think about how your
    description could best attract new users. Whether it's through a web search engine
    or an application marketplace, the text you use is critical for convincing anyone
    to install your application. As well as the name of the application and its main
    functionality, make sure you consider how it could benefit your users. What tasks
    do you expect they'll be trying to complete when searching for the solution you
    have built? Don't worry about making this text long, but do try to include these
    important points.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you intend to ship your application via an online store or a simple
    website, it's advisable to make sure you've completed the metadata before you
    continue to the release process.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go applications are designed to run from a single binary file. This means they
    can be easily distributed and do not rely on installation scripts. Unfortunately,
    this benefit results in a cost for developers—we cannot rely on resources being
    found next to our applications in the way that web or mobile app developers can
    (as we have been doing during development). To ensure that our applications conform
    to this design, we must embed any required assets into the application binary.
    This includes fonts, images, and any other static content that's needed for the
    application to operate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: go-bindata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GUI-based applications are not alone in needing to solve this challenge so there
    are many solutions already available. The most commonly utilized tool is called `go-bindata` and
    is available from [github.com/jteeuwen/go-bindata](https://github.com/jteeuwen/go-bindata).
    It is a simple utility that converts static files in to Go source code so they
    can be compiled into an application. This approach is the easiest to work with
    as the embedded assets become part of the source code and would therefore be checked
    out and built with the rest of the project. Unfortunately, that package is no
    longer maintained, even though it is still heavily used in the community. New,
    actively-maintained versions do exist, but are less popular at this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this asset packager, we install it from GitHub with `go get -u github.com/jteeuwen/go-bindata/...`
    and then run the `go-bindata` command passing in the name of the `asset` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18371b99-8594-442a-af39-0324e1113cd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Running go-bindata creates a new file named bindata.go
  prefs: []
  type: TYPE_NORMAL
- en: 'By including the generated Go file, we have access to a number of newly exported
    methods. The most important of these are `Asset()` and `MustAsset()`, which each
    take the name of an `asset` file from the directory that was bundled. The first
    method looks up the asset and returns the data if it is found or otherwise an
    error. The latter returns the data but will panic if the named resource cannot
    be found. With this new functionality, we can load the desired resource from the
    code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data, err := Asset("shiny-hall.jpg")`'
  prefs: []
  type: TYPE_NORMAL
- en: You can also get the list of assets available using the `AssetNames()` command,
    or load more information about an asset using the `AssetInfo()` command.
  prefs: []
  type: TYPE_NORMAL
- en: packr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative approach is provided by the packr project, hosted at [github.com/gobuffalo/packr](https://github.com/gobuffalo/packr).
    This utility provides additional functionality over `go-bindata` and other similar
    tools— the ability to load assets directly from the filesystem while in development.
    This flexibility can speed up working with many assets, as you no longer have
    to re-generate the packaged source code after every change. This flexibility,
    however, requires a slight change in workflow, and it is necessary to use the
    `packr` command in place of `go` when building the application for installation
    or release.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this bundle technique, we need to install the `packr` tool (using `go
    get -u github.com/gobuffalo/packr/packr`), which will also ensure the library
    is installed.  Before we can run the build, we need to write the code that looks
    up our resources, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving this code, we can run as normal, for example, `go run main.go`,
    and it will load the resources from the filesystem. When we want to install the
    app or build for release, we have to use the `packr` command instead, such as `packr
    install`. This command will find all of the resource directories we reference,
    bundle them into Go code, and then build the application including the additional
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2446b9f1-30ca-4f1f-aeaa-8901891f367c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can run code as normal but must use packr at build time.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, there was no extra step when developing
    and it works just like any other Go code. When building the application for release,
    we use the `packr` command to bundle the `assets` into the executable during the
    build process.
  prefs: []
  type: TYPE_NORMAL
- en: rsrc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application is built using Walk or another Windows-specific toolkit,
    you may consider the `rsrc` tool. `rsrc` is used to bundle manifest files and
    icon files within an executable file. The process involves running the tool to
    generate a `.syso` file, which is then compiled into the final binary output when
    running `go build`. This is the same process described in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    *Walk – Building Graphical Windows Applications,* for embedding the applications
    manifest file. We also use the tool later in this chapter to embed an application
    icon for distributing to Windows.
  prefs: []
  type: TYPE_NORMAL
- en: To package icons into the application, you can run `rsrc -ico myicon.ico,anothericon.ico`,
    and then re-build your app. Resources embedded in this way can be accessed using
    `walk.NewIconFromResource("myicon.ico")`. This is a helpful method of embedding
    icon resources if you are writing applications specifically for Windows. If you
    intend to work with multiple target platforms, it is less likely to be useful
    as your macOS or Linux executable will not be able to access these icons.
  prefs: []
  type: TYPE_NORMAL
- en: fyne bundle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous tools will work with any of the Go GUI frameworks, but if you are
    using the Fyne toolkit, you can make use of its own bundling utility (within the
    `fyne` command that is part of the Fyne project). The benefit of using this specific
    tool when working with a Fyne-based application is that it generates `fyne.Resource` definitions
    for each of the embedded resources. This makes it easier to pass an asset into
    various Fyne APIs. The process for `fyne bundle` is similar to `go-bindata`—running
    the utility converts assets from the filesystem into the Go source code, which
    can then be compiled into applications. The biggest difference is how we then
    reference the assets, that is, through declared variables instead of a lookup
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bundle` command is part of the `fyne` executable and takes the file to
    embed as its main parameter. It prints the result to the system output so we use
    console redirection (`>`) to send the generated Go source code to a suitable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7eccd93f-99ca-45e8-a408-f305474db51c.png)'
  prefs: []
  type: TYPE_IMG
- en: The Fyne bundle command outputs to stdout so we redirect output to a Go file
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is generated (or appended to an existing file), we can reference
    it using the created symbol (of the `*fyne.StaticResource` type, which implements
    `fyne.Resource`). This can be used like any other resource, so we can load it
    as an image in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image := canvas.NewImageFromResource(resourceShinyHallJpg)`'
  prefs: []
  type: TYPE_NORMAL
- en: The generated variable name may not be ideal for your usage, but it can be changed
    using an additional command parameter. For example, if you wanted to export this
    new symbol, you could uppercase the name using `-name ShinyHall`. To bundle a
    directory, you can either pass the directory name instead of a filename or run
    the command repeatedly for individual files with an additional `-append` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Building a release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that your code is complete, you have all of the metadata prepared, and
    you''ve embedded the asset files, it''s time to actually build the release. We
    will look at this process in three stages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Deciding which platforms to release for and setting up the tools
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the binary files for release
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preparing the actual packages that you will distribute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming that you will be distributing to multiple operating systems, there
    may be some preparatory stages to go through before you can build all of the release
    binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've got to this chapter with the intention of using the Walk framework
    and therefore distribute only to the Windows operating system, you can skip this
    preparation step as you don't need any additional compilation tools. All of the
    other toolkits that we have explored in this book require CGo for some functionality.
    The C compiler to enable CGo should already be set up for the platform you are
    developing on, but there is additional work needed to enable cross-compilation
    to other platforms. If you have a separate operating system installation for the
    development of each of your target platforms, then you can skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we assume development on a preferred operating system, and
    therefore the need to cross-compile for additional target platforms. Doing this
    will require installing a GCC compatible compiler for each target platform (for
    example, a Linux-based developer may need to install compilers for Windows and
    macOS).
  prefs: []
  type: TYPE_NORMAL
- en: Compiler installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each additional platform (with a different operating system to the current
    one) will require a C compiler to be installed. The ones recommended throughout
    this book are as follows (along with the CC environment variable to use them with
    CGo):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Target Platform** | **CC=** | **Download** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| macOS (darwin) | o32-clang | [github.com/tpoechtrager/osxcross/](https://github.com/tpoechtrager/osxcross/)
    | You will also need the macOS SDK(see osxcross documentation) |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | x86_64-w64-mingw32-gcc | On macOS: [brew.sh/](https://brew.sh/)On
    Linux: use your package manager | macOS: install `mingw-w64` packageLinux: package
    names vary |'
  prefs: []
  type: TYPE_TB
- en: '| Linux/BSD | gcc-linux | On macOS: [brew.sh/](https://brew.sh/)On Windows:
    [cygwin.com/install.html](https://cygwin.com/install.html) | macOS: Install `FiloSottile/musl-cross/musl-cross`Windows:
    Install `gcc-linux` package |'
  prefs: []
  type: TYPE_TB
- en: Installing cross-compilation tools can be complicated—be sure to read the documentation
    on each download page and check your environment configuration after installing.
  prefs: []
  type: TYPE_NORMAL
- en: Full details of how to install and set up each of these compilers can be found
    in [Appendix 2](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler Setup*.
  prefs: []
  type: TYPE_NORMAL
- en: Building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the appropriate compilers and libraries installed, we can continue
    to the build phase. For each of the target operating systems, you will need to
    run through these steps with the correct environment variables set. It is recommended
    to build for one platform and then complete the packaging step listed in the following
    table before changing to the next configuration. This is because the release binary
    for one platform may overwrite another (for example, macOS and Linux binaries
    have the same name when compiled). Note that when building a release for the current
    platform, you can omit the `CGO_ENABLED` and `CC` environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Target Platform** | **GOOS=** | **CGO_ENABLED=** | **CC=** | **Notes**
    |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | darwin | 1 | o32-clang | Make sure you''ve prepared the SDK and copied
    it to the osxcross `tarballs/` directory. |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | windows | 1 | x86_64-w64-mingw32-gcc | A different CC or compiler
    may be required if you change `GOARCH`. |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | linux | 1 | gcc-linux | On macOS you may need to use x86_64-linux-musl-gcc
    for CC. |'
  prefs: []
  type: TYPE_TB
- en: With these environment variables set appropriately, we can execute the build
    command. You may also want to set `GOARCH` to specify a different CPU architecture,
    but doing so is beyond the scope of this chapter. If you are using the Packr asset
    bundler, then you will need to use the `packr build` command, otherwise the `go
    build` command can be executed. This will typically take longer than a normal
    run or build, as all of the application dependencies may have to be built for
    the new target platform before your application can be compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, we can open a Linux Terminal and set up the environment
    for each build. When compiling for the current platform, we don''t need to specify
    the `CGO_ENABLED` or `CC` variables as these have correct defaults. After each
    build, we have a single application binary for the desired platform that we will
    put to one side and use in the next step (for instance, packaging):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3692794e-4e07-412c-b502-a825197a053b.png)'
  prefs: []
  type: TYPE_IMG
- en: Compiling with CGo for Linux, macOS, and Windows
  prefs: []
  type: TYPE_NORMAL
- en: Once the binary files have been compiled, we could distribute the application
    – this would be the normal process for command line utilities or web applications.
    However, with GUI-based applications, a user will expect visual elements, such
    as icons and integration with application launchers for their platform. That information
    is added in the packaging phase and varies for each platform and toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To finish creating the release files for a graphical application, we have to
    add extra imagery and metadata alongside the binary that was just compiled. These
    need to be in specific formats, which are different for each operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The format for an application package on Linux varies between distributions
    (`.rpm`, `.deb`, and `.tar.gz` are common formats for distribution), but they
    all require the same assets, which we will build now. As well as the compiled
    application, we need an `icon` file and a `desktop entry` file (a standard defined
    by FreeDesktop.org: [standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html](https://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html)).
    The `icon` file is a simple image file in one of the supported formats: PNG, XPM,
    and SVG. PNG is recommended for a bitmap icon and SVG is the format to use if
    your icon is vector-based.'
  prefs: []
  type: TYPE_NORMAL
- en: Create metadata files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `.desktop` file is a simple text file in a standard key-value format with
    grouping. There are certain keys that are required as well as many optional ones
    (which we will not cover here). A basic desktop entry file may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Save the content to a suitably named file, such as `myapp.desktop`, next to
    your compiled binary file. This file sets out the basic application information—the
    type of executable it describes (`Application`) and the name that will be used
    for display (you can add additional information with `Comment` if required). The
    name can be localized (displayed in different languages) as well—for this, use
    the `Name[fr]=French Name` format. We then specify the executable (this can be
    just the filename, in which case the location will be looked up, or an absolute
    path to the installed binary). The `%f` parameter indicates that the executable
    can accept a single file parameter and is useful for things such as dragging and
    dropping files onto your application icon (omit this if you do not support command
    arguments). We need to specify the `icon` parameter to tell the system the how
    to find the icon for this application (in this case, it will look for `myapp.png` in
    the theme icon paths). Optionally, we can specify categories that this application
    should appear within— excluding this element may mean the icon does not appear
    in system menus. A full list of supported categories is available online at [specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry](https://specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry).
  prefs: []
  type: TYPE_NORMAL
- en: To make it easier for users to find your software once it's installed, be sure
    to choose a clear name and set the right category for your application. You can
    use the `Comment` property to provide more information, but that may not always
    be shown.
  prefs: []
  type: TYPE_NORMAL
- en: On some systems, the category is more than a menu grouping. For example, items
    in the *Settings* category may be placed into a control panel rather than the
    main application list.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux packages are distributed in one of two ways: as source code or as a binary
    (compiled) package. When shipped as source code, a makefile, or similar, would
    be included to instruct the compiler on how to create the executable. With Go,
    this is different due to the standard structure and build tools, so we don''t
    need to include a make file. As developers, we simply invoke `go install` for
    the current project or `go get` for one that is not yet downloaded. Anyone familiar
    with Go will know this process and so there is no required build information in
    this case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we are packaging for distribution to regular users, not developers.
    For this to work , we could use distribution-specific packaging (which we will
    look at later in this chapter) or build a package that could work for any Linux
    system. To do the latter, we can prepare a structured package that can simply
    be expanded onto a user''s system. The standard installation location for non-system
    packages is `/usr/local`, so we start at that location for our files (we mirror
    this structure in the current directory). The expected tree of files should look
    like the following (*hicolor* is the name of the fallback theme for looking up
    icons):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `usr/local/share/applications/myapp.desktop` | `Desktop Entry` metadata 
    |'
  prefs: []
  type: TYPE_TB
- en: '| `usr/local/share/icons/hicolor/512x512/apps/myapp.png` | Application icon
    (for a 512 x 512 px bitmap image) |'
  prefs: []
  type: TYPE_TB
- en: '| `usr/local/share/icons/hicolor/scalable/apps/myapp.svg` | Application icon
    (for a vector image) |'
  prefs: []
  type: TYPE_TB
- en: '| `usr/local/bin/myapp` | Executable file (from go build) |'
  prefs: []
  type: TYPE_TB
- en: 'With all of these files in the right folder we can build an application package
    using the `tar` utility. The full command to create a new file with this content
    is `tar -cf myapp.tar.gz usr`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d37e635-4d31-4b0c-b1d7-12a3a8416ab8.png)'
  prefs: []
  type: TYPE_IMG
- en: Packaging the contents of our usr/local directory structure
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting package can be shared for installation, and the recipient should
    use `sudo tar -xf myapp.tar.gz` from the root of their filesystem. In this example,
    we pass the additional `-C /` to avoid having to change directory, as indicated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0c0c13d-726b-4bef-961f-ae41ce15d3ab.png)'
  prefs: []
  type: TYPE_IMG
- en: After installing the packaged application we can run it from $PATH
  prefs: []
  type: TYPE_NORMAL
- en: This package format will work for all Linux distributions, but packaging for
    package managers is additional work. We will look at distribution tools later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications to be distributed for macOS also require a particular directory
    structure and associated metadata. These files will not be installed like the
    previously shown Linux example, but instead run from the directory we are creating.
    This format is called an **application bundle** and requires certain metadata
    files that we must create to describe the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating metadata files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main metadata file for macOS applications is called `Info.plist` and, like
    the desktop entry for Linux, it is a structured text file. For a Go project, it
    is best to edit the text directly rather than using the installed Xcode tools.
    This file contains a list of key-value pairs that describe the application we've
    built. It's important that you do not change the values for `CFBundlePackageType`
    or `CFBundleInfoDictionaryVersion` as these identify the file to macOS as an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main keys for customization are `CFBundleExecutable`, which sets the name
    of the executable file; `CFBundleName`, for the human-visible name of the application;
    and `CFBundleIconFile`, to specify the icon filename. It''s important to set sensible
    values for `CFBundleIdentifier` as this uniquely identifies this application,
    and `CFBundleShortVersionString`, which specifies what version of the application
    is included. Putting all of these values into the `plist` format, you should have
    a file similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to set a globally unique `CFBundleIdentifier` value – typically by using
    the reverse domain name format illustrated previously. This configuration is used
    to associate file types with your application, and the App Store will not accept
    applications where this is not set correctly.
  prefs: []
  type: TYPE_NORMAL
- en: One additional step when creating a macOS package is that the icon must be in
    the `ICNS` format. `ICNS` files contain many different sized icons so that macOS
    can display a clear graphic at various resolutions. There are many graphical tools
    to manipulate these files (search `create icns file` online), but the XCode command-line
    tools include `iconutil`, a simple utility that can create these files from a
    set of icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'When invoking `iconutil`, we specify that it should convert to `icns` with
    the `-c icns` parameter, and provide the output file name using `-o <filename>`.
    The last parameter is the `iconset` input—a directory of appropriately named files
    that will be included. For our 1024 x 1024 pixels icon, we call it `icon_512x512@2x.png`,
    but it is recommended to provide multiple different resolutions. Running the command
    will create the `.icns` file we need for our application icon, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Packaging release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the metadata has been created, we can create the directory structure
    required for a macOS application bundle. The location of the files is important,
    and is set out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: File `pathDescription`
  prefs: []
  type: TYPE_NORMAL
- en: '| `myapp.app/Contents/Info.plist` | The application metadata outlined in the
    preceding |'
  prefs: []
  type: TYPE_TB
- en: '| `myapp.app/Contents/Resources/myapp.icns` | The application icon in ICNS
    format |'
  prefs: []
  type: TYPE_TB
- en: '| `myapp.app/Contents/MacOS/myapp` | The application executable |'
  prefs: []
  type: TYPE_TB
- en: 'After creating these directories and moving files to the correct location,
    you have a complete application bundle. This can be executed by double-clicking
    the icon and it can be distributed in this state. Installation consists of dragging
    this icon into the `Applications` folder of the computer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cb89486-99ae-4c56-a8aa-351e51eee3c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the .app directory structure and adding metadata creates a macOS application
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the result in Finder, we see the new directory as an application,
    its `.app` extension is hidden, and the icon is the same we set up before. You
    can launch, install, or remove this app like any other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2de161ae-7a61-4c3e-a13c-55e908e02b82.png)'
  prefs: []
  type: TYPE_IMG
- en: Our .app directory shows as the application it describes
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metadata for applications in Windows is embedded into the executable file rather
    than in additional files. To do this, we create metadata files and then use a
    resource tool to include them in the final executable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating metadata files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To include application metadata, we create an application manifest file like
    those used in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to
    the Rescue!,* and [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    – Building Graphical Windows Applications, *when we were building applications
    using the Common Controls widget set (via Walk and andlabs UI). The contents of
    the `assemblyIdentity` instance is used to determine the metadata about the executable.
    For a platform-independent GUI, the file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Don't, however, remove the `<dependency>` section if you are using Walk, andlabs
    UI, or another toolkit that needs to have a dependency listed in its manifest
    file.
  prefs: []
  type: TYPE_NORMAL
- en: To add more metadata that may be useful to users (for example, product name
    and version) you will need to manually set extra values. The goversioninfo tool from
    [github.com/josephspurrier/goversioninfo/](https://github.com/josephspurrier/goversioninfo/)
    is the easiest way to add these values. Be aware that you can only write to the
    `.syso` file once, as running these tools again will overwrite the previous content.
  prefs: []
  type: TYPE_NORMAL
- en: To prepare our icon for Windows, it must be converted into a `.ico` file (the
    Microsoft icon format). While there are no icon conversion tools pre-installed
    with Windows, there are many paid-for applications available that will work. If
    you prefer a free solution, there are websites that offer image conversion services
    for no cost. If your development platform is Linux or macOS, you could install
    `icotool`, which supports the `.ico` format.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To package the data for release, we will embed this metadata into the application
    binary. Doing so requires creating a binary resource file (ending in `.syso`)
    that will encapsulate the manifest and icon files. The easiest way to do this
    is with the `rsrc` tool that was used in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    – Building Graphical Windows Applications*. If you have not yet installed `rsrc`,
    you can do so with `go get github.com/akavel/rsrc`. We tell the tool where to
    find the manifest and icon files and it will output an `rsrc.syso` file in the
    current directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you are compiling for a 64 bit target, you will need to specify an additional
    `-arch amd64` parameter. It is important that the resource file generated is for
    the same architecture (either i386 or amd64) as the application you are compiling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the metadata has been bundled into a resource file, we have to re-build
    our project. Make sure that, this time, you add the `-ldflags="-H windowsgui"`
    parameter, otherwise the resulting application will display a Terminal window
    when starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build is complete, we will have created a Windows executable with
    the icon and metadata included. You can now launch this from the command line
    or by double-clicking the icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f542c0d7-062a-4c72-a6be-5c430f8ca308.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the application after generating a resource bundle will automatically
    include the data
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see the same directory in Windows Explorer. The application is on
    the left in the screenshot that follows, displayed using the icon we included:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2c1e3b0-cf5b-4aef-8f20-12b27dd19789.png)'
  prefs: []
  type: TYPE_IMG
- en: Our Windows application with the icon embedded
  prefs: []
  type: TYPE_NORMAL
- en: These processes are slow and can be prone to errors. To avoid doing this process
    manually, we will explore tools that could automate this.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform packaging tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, each operating system requires very different packaging. Additionally,
    the tools that would normally make the process simple are typically platform-specific,
    making it more difficult to build from a single system. The distribution of GUI
    applications is an area in which Go tools are also lacking. The Go language is
    great for rapidly creating cross-platform software, but it is not designed to
    handle the complication of graphical application packaging.
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml),  *Toolkits Using
    Existing Widgets,* we explored toolkits that are very mature, but as they are
    either not written for Go, or are not designed to be cross-platform, they do not
    provide the tools we could use. [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml),* 
    Modern Graphical Toolkits,* looked at toolkits that are more focused on providing
    graphical capabilities rather than application life cycle, and so do not provide
    suitable tools either.
  prefs: []
  type: TYPE_NORMAL
- en: fyne package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One exception is the Fyne project as it aims to provide APIs for full application
    life cycle, and so the tools support distributing complete desktop apps across
    multiple platforms. While the project is still early it does have a tool that
    can help with application packaging (even if you've not used Fyne in your code).
    The `fyne package` command is designed to generate and package all the required
    metadata for an application to distribute on macOS, Linux, or Windows. Invoking
    with the `-os <platform>` parameter (using one of "darwin", "linux", or "windows")
    will create a fully packaged application in the current directory. Before executing
    this command the application should already be compiled for release.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a macOS application bundle from a Linux computer
    using `fyne package -os linux`. There are many additional parameters that can
    change the contents of the application, and the most useful will be the `-icon
    <filename>` parameter (which is required). If you were not already using Fyne,
    then the command should be installed using `go get fyne.io/fyne/cmd/fyne`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dae04be-79a5-43c1-b541-4f4151be752c.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a macOS application bundle on Linux with "fyne package"
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the tool generated an `.app` directory
    structure (which defines a macOS application) from a Linux Terminal. We used the
    same platform name for the `GOOS` environment and the `-os` parameter to `fyne
    package`. It's recommended to build for one platform and then package it before
    changing the target operating system to avoid potential errors in the output package.
  prefs: []
  type: TYPE_NORMAL
- en: The applications we have built in this section could be distributed right away.
    Uploading to a website or sharing the files in some other manner would work, but
    we want to make the process completely seamless for users. Let's wrap up this
    chapter by looking at the various distribution channels that exist for desktop
    application delivery directly to end users.
  prefs: []
  type: TYPE_NORMAL
- en: Distributing to platform marketplaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most operating systems now have a central location for discovering and installing
    applications. Apple created the Mac App Store, Windows has the Microsoft Store,
    and each Linux distribution has its preferred package manager. Having an application
    listed in (and hosted by) a platform marketplace significantly increases the number
    of users you can expect and also reduces associated hosting costs. When paired
    with carefully prepared metadata (as described at the beginning of this chapter),
    a marketplace can easily become your largest distribution channel. How to get
    applications included in these directories is specific to each platform, so we
    will look at the process for each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Mac App Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Mac App Store is the desktop version of Apple's famous iOS App Store. It
    provides many thousands of applications available to buy and download, or gift
    to others. There is also curated content, which includes listings of the most
    popular apps in various categories, as well as staff picks and recommended software.
    Apple provides education discounts as well as free copies to family members if
    one person makes a purchase. You can also redeem gift cards towards making purchases
    of apps or subscriptions. Unfortunately, the Mac App Store cannot be browsed online
    as it requires the App Store software, which is pre-installed on compatible Mac
    computers.
  prefs: []
  type: TYPE_NORMAL
- en: As well as having the development tools installed, you will also need to sign
    up to the Apple Developer Program. If you are not already a member you can sign
    up on their website here: [developer.apple.com/programs/enroll/](https://developer.apple.com/programs/enroll/).
    The development resources are free to access, but there is an annual subscription
    charge for access to the code signing tools, which are required to publish software
    to any of their App Stores.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging applications for submission are managed by the XCode tools (which
    you should already have installed). The process is optimized for submitting apps
    that have been built with XCode and, as it does not support Go, we have some manual
    steps to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application package that we created earlier (for macOS distribution) will
    have to be signed before we can upload to the App Store. Code signing is a complicated
    process to set up, so for the purpose of this description, it is assumed that
    you already have a distribution certificate installed. You need to note the name
    of the certificate (use Keychain Access to find your developer certificates) and
    then use that name in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The resulting app package is ready to be uploaded to the App Store Connect website
    for validation.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: App Store applications are managed through the App Store Connect website (at [appstoreconnect.apple.com/](https://appstoreconnect.apple.com/)).
    Log in using your Apple developer account and create a new application (if you
    have not already done so). This is where you add the metadata that will be displayed
    in the store—be sure to check the information carefully as some data cannot be
    changed after release. Well-chosen descriptions and screenshots will help your
    application to be more easily discovered. Within this app definition, you need
    to start preparing a new release, with an appropriate version number and supporting
    information. You will probably notice that you are not yet able to select a build—to
    enable this, we first need to upload the compiled package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application loader tool is the easiest way to upload a new build: open
    the app and log in with your Apple ID. Once logged in, you will be asked to choose
    the application to upload; select the matching application and progress to the
    upload. Once complete, the build will appear in the App Store Connect website
    (you may need to refresh the page). If you prefer command-line tools for managing
    the progress, you can use `xcrun altool`, which provides the same capability.
    Once you''ve chosen this new build, you can press the Submit for Review button
    to start the review process.'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As soon as an app is submitted for review, it goes through an automated set
    of code checks. This process verifies that the application does not contain obvious
    errors in metadata or code signing and performs code analysis to ensure you are
    not using APIs that are private to Apple or otherwise restricted. Assuming that
    these automated checks pass, then the application will be sent for final acceptance
    by a member of the App Store review team.
  prefs: []
  type: TYPE_NORMAL
- en: The review team checks your application for quality, reliability, compliance
    with the **Human Interface Guidelines** (**HIG** –[developer.apple.com/app-store/review/](https://developer.apple.com/app-store/review/)),
    and that it meets other criteria for inclusion on the store. This process typically
    takes a day or two, but can be longer for the first release of a new application.
    Once the process is complete your software will be available to purchase or download
    on the App Store. In your first week of distribution, it may even be included
    in the *New and Noteworthy* section.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Microsoft Store is the official location for finding and installing software,
    apps, and games for all of the current Windows, Windows Phone, and Xbox devices.
    As well as offering hosting and search facilities it handles payments for non-free
    software and supports discounts and vouchers as well. You can browse the contents
    of the Microsoft Store online (at [www.microsoft.com/store/apps](https://www.microsoft.com/store/apps))
    or by using the store apps on each of the systems it supports.
  prefs: []
  type: TYPE_NORMAL
- en: To submit an application to the Microsoft Store, you will require a Microsoft
    account (which you may already have if you signed in to Windows, Xbox, or Office
    365). You will also have to start an annual subscription to access the relevant
    portions of the developer portal. You can log in and sign up at [appdev.microsoft.com/StorePortals](https://appdev.microsoft.com/StorePortals).
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tools required to create an application package for uploading to the Microsoft
    Store are included as part of the Windows Software Development Kit. If you have
    not already installed this you can download it from [developer.microsoft.com/en-us/windows/downloads](https://developer.microsoft.com/en-us/windows/downloads),
    either as part of Visual Studio, or as a separate package.
  prefs: []
  type: TYPE_NORMAL
- en: To upload an application to the store we must create a `.appx` file (an application
    package). This requires an additional manifest file, named `AppxManifest.xml`,
    which contains the metadata about the application being packaged. Its contents
    are documented on the Microsoft website at [docs.microsoft.com/en-us/uwp/schemas/appxpackage/how-to-create-a-basic-package-manifest](https://docs.microsoft.com/en-us/uwp/schemas/appxpackage/how-to-create-a-basic-package-manifest).
    The resulting manifest file should have at least one `Application` element within
    the `Applications` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the package from our source files, we use a `MakeAppx.exe` command,
    as indicated in the following code snippet. By using the `/d` parameter, we can
    specify a directory of files to package – if you want to use a subset of the files,
    you can create a mapping file and specify that with the `/f` parameter instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once the `.appx` file has been created, it must be signed. The `SignTool.exe`
    command can be used to sign an application package. Setting up the certification
    to support application signing is outside the scope of this chapter, but the documentation
    on the Microsoft developer portal will take you through the process. Ensure that
    the publisher listed in the manifest file matches the certificate that you create
    to sign the package.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The completed package should be uploaded to the developer portal within the
    `Packages` page. When preparing for upload, make sure that all of your application
    metadata has been added to the correct locations so that people will find your
    software easily.
  prefs: []
  type: TYPE_NORMAL
- en: Once the package is uploaded, it will be checked for various errors that could
    stop it from being released. Should you encounter any warnings, you will need
    to remove the uploaded build from the portal and fix the issue. Once resolved,
    you will need to fully re-package, re-sign, and upload the new package for re-testing.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once your package is uploaded and has passed the initial validation it will
    be added to a queue to be reviewed. The Microsoft staff will review your application
    for correctness and suitability, and validate that it is of high enough quality
    for inclusion in the store. Assuming that these checks all pass, they will publish
    it for distribution across the devices that you specified during the submission
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Linux package manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many years, Linux distributions have had a reputation for handling package
    distribution well. A desktop system will likely have a graphical package management
    application that provides easily searchable indexes containing thousands of packages.
    More recently, various applications have been created to help with software discovery
    (to make finding new packages easier).
  prefs: []
  type: TYPE_NORMAL
- en: Applications such as *Discover* (more information on this can be found at [userbase.kde.org/Discover](https://userbase.kde.org/Discover))
    can be used on most systems by working with many different package managers. Others,
    such as *Ubuntu Software Center*, aim to make it easier to find applications for
    specific systems based on categories, ratings, and other enhanced metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Despite there being hundreds of different Linux distributions only a handful
    of packaging formats are needed to support them. In this section we look at the
    three most popular formats: *Debian*, *Red Hat,* and *Tarball*. Once packages
    have been created for a system the application developer can submit it to a package
    list. As Linux is an open source system, however, you may find that an existing
    package maintainer may be happy to do that for you!
  prefs: []
  type: TYPE_NORMAL
- en: Debian (.deb)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distribution for Debian is very similar to the `.tar.gz` distribution we created
    earlier, with the addition of specific metadata that allow the Debian tools to
    search and correctly install the software. Packaging for Debian is described in
    detail on their website ([wiki.debian.org/HowToPackageForDebian](https://wiki.debian.org/HowToPackageForDebian)),
    but the basic process is to add the metadata (*Debianization*), build the package
    to conform to their filesystem layout, and then (optionally) sign the package
    so that users know they can trust the content.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `dh_make` command is provided to automate the creation of required metadata
    files, and running it inside the existing Linux packaging directory structure
    will add the necessary files. Once run, you should check all the files in the
    `debian/` directory to update information as appropriate. The `debuild` command
    will create a Debian package for our software once the metadata has been added.
    After it's creation, you should use the `lintian` command to check the package
    for a number of common errors.
  prefs: []
  type: TYPE_NORMAL
- en: Although not required, you could then sign the package using the `debsigs` tool.
    This creates a signed package, which provides cryptographic proof that the package
    contains what the developers intended. As mentioned earlier, setting up certificates
    and signing is complex and not covered by this book.
  prefs: []
  type: TYPE_NORMAL
- en: Distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once your package is prepared you can distribute the file directly to other
    Debian users. However, the aim was to include it in the package listing. To do
    so requires a process that starts by filing Intent to Package in their bug tracker
    ([bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=wnpp;dist=unstable](https://bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=wnpp;dist=unstable)).
    To complete the process, you will need to find a sponsor for your package or become
    a Debian developer. Either of which will require you to contact the development
    community to learn more; full details can be found at [wiki.debian.org/DebianMentorsFaq](https://wiki.debian.org/DebianMentorsFaq).
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat (.rpm)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RPM files are very similar to Debian packages but with a different set of metadata.
    Once again, there are standard tools that can help with the creation of these
    files and to create the final package. To start with, you should install the `rpm` or
    `rpm-build` package in your Linux distribution, which should include the necessary
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we must create a `.spec` file to describe the package. The `rpmdev-newspec`
    command can provide one from the templates option to get you started. Update the
    contents according to your application information. This file will contain all
    the metadata about your software (including its source location, the license,
    and authors). The spec file also provides the build information required to assemble
    the package, as well as instructions for installation scripts, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Once the metadata is complete, the package can be built using the `rpmbuild` command.
    It is normal that this will not succeed on the first attempt. Read the output
    and update the `.spec` file accordingly, then re-run the build command. The finished
    output will be your completed `.rpm` file ready for testing. At this time, you
    can test the file by installing it manually (on a compatible Linux computer) and
    verifying that the software works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the package is prepared, it can be distributed using your website –
    an RPM file can be downloaded and installed relatively easily. Inclusion in Linux
    distributions is a complicated process and the details are different for each
    variant. CentOS, Fedora, and Red Hat Enterprise Linux all use the RPM package
    format, as do many others, but the process of submission is not well-documented. The Fedora
    project has comprehensive documentation, which you can refer to at [fedoraproject.org/wiki/Package_Review_Process](https://fedoraproject.org/wiki/Package_Review_Process).
    For most package inquiries, the best approach is to contact the current distribution
    maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: Tarball (.tar.gz)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tarball is a generic packaging for binary (and source-based) distribution
    of applications. The `.tar.gz` package that we built earlier in this chapter is
    an example of a possible tarball distribution. With Linux, most applications are
    open source, meaning that packaging is typically done from the source code rather
    than from the compiled output. It is possible to use a binary release, as we have
    built, but bear in mind that some distributions may push back on including such
    a package based on their own policies.
  prefs: []
  type: TYPE_NORMAL
- en: Arch Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arch Linux package manager, pacman, relies on `PKGBUILD` files to understand
    how to locate and install software packages. The `PKGBUILD` file is a specific
    format of shell script (executable text file for the command line) that describes
    the package metadata, any dependencies that it must install first, and the installation
    process for a package. Full details of the `PKGBUILD` file can be found at [wiki.archlinux.org/index.php/PKGBUILD](https://wiki.archlinux.org/index.php/PKGBUILD).
    A valid file must contain at least `pkgname`, `pkgver`, `pkgrel`, and `arch` variables.
  prefs: []
  type: TYPE_NORMAL
- en: To create a package once the `PKGBUILD` file is created, you run the `makepkg`
    command. This will execute the steps defined in the script file and prepare the
    resulting package. It is recommended to check the finished package file using
    the `namcap` command which validates that certain common mistakes have not been
    made.
  prefs: []
  type: TYPE_NORMAL
- en: Newly created packages can be submitted to the *Arch User Repository* where
    other Arch Linux users will be able to install it. Notable packages can be promoted
    from this location to the official repository over time. Details for submitting
    your package can be found at [wiki.archlinux.org/index.php/Arch_User_Repository#Submitting_packages](https://wiki.archlinux.org/index.php/Arch_User_Repository#Submitting_packages).
  prefs: []
  type: TYPE_NORMAL
- en: Gentoo Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gentoo Linux is (not uniquely) a source-based distribution. This means that
    the package system contains just instruction files that describe how to download
    and install software. This file is called an `ebuild` file and, like the `PKGBUILD`
    file previously, contains information about metadata, dependencies, and build
    instructions. Unlike Arch Linux, this descriptor file is the complete distribution
    – packagers do not build a binary distribution package using the metadata file.
  prefs: []
  type: TYPE_NORMAL
- en: The process for submitting a new package to Gentoo Linux (once you have created
    the `ebuild` file) is described on their community documentation [https://wiki.gentoo.org/wiki/Submitting_ebuilds](https://wiki.gentoo.org/wiki/Submitting_ebuilds).
    As with other distributions, you will need to become part of the development community
    to add the package yourself, but you may convince an existing developer to maintain
    the package for you.
  prefs: []
  type: TYPE_NORMAL
- en: Others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many other Linux distributions use similar packaging systems, but to mention
    them all would be too lengthy for this chapter. Each of their websites will provide
    information about how to complete a package and submit to their application listings.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An increasingly popular approach to application distribution is that of **application
    containerization**. This approach means that each application is packaged into
    a *container*, similar to how Docker and other tools are doing for server-based
    software. An application container is a single file that simulates a filesystem,
    into which an application is installed. Applications can be downloaded from a
    website or through a package manager and do not need to be installed to run. The
    same container file will run on any Linux distribution; there are even some container
    formats that aim to support multiple operating systems as well. AppImage, Snap,
    and Zero Install are some popular formats, each with particular benefits or target
    audiences. If you want to distribute a single Linux package for your application
    and are not so concerned about including it in the platform software lists, this
    approach may be right for you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we looked at how to package and distribute Go-based graphical
    applications. Unlike the distribution of command-line or system utilities, the
    process of delivering a GUI application requires additional metadata and packaging.
    Users of graphical apps expect to find and install software in a particular manner
    that varies based on their operating system. We started by looking at the importance
    of good metadata and how to select an icon and description that will attract potential
    users to try out our new software. We then learned how to package assets into
    our Go-based applications. As the language is designed for single binary distribution,
    we had to incorporate all supporting files into the executable before distributing.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging for different platforms can be complicated, so we walked through the
    steps required to build native-looking graphical packages for macOS, Windows,
    and Linux. Each package has its own metadata format and package structure but
    we were able to package our simple application for each of the specific formats.
    The packages that resulted from this step could be distributed through a website
    or other file sharing mechanism. However, we wanted to deliver the app where our
    users would expect to find it—in the system app store. And so we worked through
    the process of preparing and distributing the packages for each platform's marketplace.
    The Windows and macOS stores provide an opportunity for applications to earn revenue
    following release and the Linux software listings will help to increase visibility
    of our software package.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned the various approaches to building GUIs with Go and exploring
    the toolkits available, we've made it all of the way to a complete and published
    graphical application. Hopefully, you've learned a lot along the way and have
    managed to create the app that you had been aiming to build—using only Go to support
    a performant, maintainable, and beautiful user interface.
  prefs: []
  type: TYPE_NORMAL
