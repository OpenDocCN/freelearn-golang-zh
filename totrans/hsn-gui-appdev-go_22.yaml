- en: Connecting GoMail to a Real Email Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将GoMail连接到真实电子邮件服务器
- en: In many chapters of this book, we've explored ways of building a Go-based email
    application called **GoMail**. All of these examples have used a dummy email server—some
    code in the `client` package, which allows us to build the GUI portions of a mail
    client without needing to manage server communication. In this final appendix,
    we step through adding code to connect to a real email server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的许多章节中，我们探讨了构建基于Go的电子邮件应用**GoMail**的方法。所有这些示例都使用了虚拟电子邮件服务器——`client`包中的某些代码，这使得我们能够在不需要管理服务器通信的情况下构建邮件客户端的GUI部分。在本附录的最后部分，我们将逐步添加代码以连接到真实电子邮件服务器。
- en: Building on the exploration in [Chapter 12](7d70ada3-8bc9-4c54-b15d-8707e43fc0ce.xhtml), *Concurrency,
    Networking, and Cloud Services* (particularly the authentication—*OAuth 2.0* example),
    we'll use the Gmail public API and the built-in capabilities of the Go language
    to bring this together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](7d70ada3-8bc9-4c54-b15d-8707e43fc0ce.xhtml)的探索基础上，*并发、网络和云服务*（特别是认证—*OAuth
    2.0*示例），我们将使用Gmail公共API和Go语言的内置功能来实现这一点。
- en: Download Gmail credentials
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载Gmail凭证
- en: In [Chapter 12](https://cdp.packtpub.com/hands_on_gui_application_development_in_go/wp-admin/post.php?post=709&action=edit#post_35), *Concurrency,
    Networking, and Cloud Services*, we wrote the OAuth2 handlers and Gmail integration
    using only the standard library. For this final code exploration, we'll use the
    helpful library that Google has created for interacting with Gmail servers. To
    use this library, we need the client credentials in a different format (`credentials.json`).
    To access this, log in to your Google account and go to the Go quickstart page
    at [https://developers.google.com/gmail/api/quickstart/go](https://developers.google.com/gmail/api/quickstart/go).
    Once here, you'll need to click on ENABLE THE GMAIL API and then DOWNLOAD CLIENT
    CONFIGURATION. This will download the `credentials.json` file that we'll need
    to initialize the library in the next section, *Creating server provider*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](https://cdp.packtpub.com/hands_on_gui_application_development_in_go/wp-admin/post.php?post=709&action=edit#post_35)，*并发、网络和云服务*中，我们仅使用标准库编写了OAuth2处理程序和Gmail集成。对于这次最后的代码探索，我们将使用Google为与Gmail服务器交互而创建的有用库。要使用此库，我们需要以不同的格式（`credentials.json`）的客户端凭证。要访问此文件，请登录您的Google账户，并转到Go快速入门页面[https://developers.google.com/gmail/api/quickstart/go](https://developers.google.com/gmail/api/quickstart/go)。在此处，您需要点击“启用Gmail
    API”，然后下载“客户端配置”。这将下载我们将在下一节*创建服务器提供者*中初始化库所需的`credentials.json`文件。
- en: Once you've downloaded the credentials file, you'll need to install the two
    required libraries using `go get -u google.golang.org/api/gmail/v1` and `go get
    -u golang.org/x/oauth2/google`. You're then ready to add the code to connect to
    Gmail and access your emails.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 下载凭证文件后，您需要使用`go get -u google.golang.org/api/gmail/v1`和`go get -u golang.org/x/oauth2/google`安装两个必需的库。然后，您就可以添加代码来连接到Gmail并访问您的电子邮件了。
- en: Creating a server provider
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器提供者
- en: The following code outlines the contents of the `gmail.go` file that's available
    in the `client` package of the repository for this book. If you want to jump straight
    to trying out this functionality, then simply copy your `credentials.json` file
    to the current directory and skip to the next section, *Update an example to use
    Gmail*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码概述了位于本书仓库`client`包中的`gmail.go`文件的包含内容。如果您想直接尝试此功能，只需将您的`credentials.json`文件复制到当前目录，然后跳到下一节*更新示例以使用Gmail*。
- en: We start by adding the necessary OAuth2 setup and token storage by copying the
    `getClient()`, `getTokenFromWeb()`, `tokenFromFile()`, and `saveToken()` functions
    from Google's Gmail quickstart Go file at [github.com/gsuitedevs/go-samples/blob/master/gmail/quickstart/quickstart.go](https://github.com/gsuitedevs/go-samples/blob/master/gmail/quickstart/quickstart.go).
    These are very similar to the OAuth2 code that was created before but works better
    with the Google libraries.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过复制来自Google的Gmail快速入门Go文件中的`getClient()`、`getTokenFromWeb()`、`tokenFromFile()`和`saveToken()`函数来添加必要的OAuth2设置和令牌存储。这些函数与之前创建的OAuth2代码非常相似，但与Google库配合得更好。
- en: Downloading inbox messages
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载收件箱消息
- en: 'Next, we need to set up the client from the credentials file that has been
    saved (in the current directory). We add a new function to parse the data, set
    up the authentication, and configure `*gmail.Service` using the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从已保存的凭证文件（在当前目录中）设置客户端。我们添加了一个新函数来解析数据，设置身份验证，并使用以下代码配置 `*gmail.Service`：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The service returned from this function will be used for each subsequent call
    to the Gmail API as it contains the authentication configuration and credentials.
    Next, we need to prepare the email list by downloading all of the messages in
    the user''s inbox. The `INBOX` LabelID is used to filter messages that haven''t
    been archived. This function requests the message list and iterates through the
    metadata to initiate the full download of each message. For a full implementation,
    we would need to add paging support (the response contains `nextPageToken`, which
    indicates when more data is available), but this example will handle up to 100
    messages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从此函数返回的服务将用于对 Gmail API 的每次后续调用，因为它包含身份验证配置和凭证。接下来，我们需要通过下载用户收件箱中的所有消息来准备电子邮件列表。使用
    `INBOX` 标签ID来过滤未存档的消息。此函数请求消息列表并遍历元数据以启动每个消息的完整下载。对于完整实现，我们需要添加分页支持（响应包含 `nextPageToken`，它指示更多数据何时可用），但此示例将处理多达
    100 条消息：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To download each individual message, we need to implement the `downloadMessage()`
    function referenced previously. For the specified message, we download the full
    content using the Gmail Go API. From the resulting data, we extract the information
    we need from the message headers. As well as parsing the `Date` header, we need
    to decode the message body, which is in a serialized, Base64 encoded format:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载每条单独的消息，我们需要实现之前提到的 `downloadMessage()` 函数。对于指定的消息，我们使用 Gmail Go API 下载完整内容。从结果数据中，我们从消息头中提取所需信息。除了解析
    `Date` 头之外，我们还需要解码消息正文，它是以序列化、Base64 编码的格式：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `decodeBody()` function is as shown in the following. For plain text emails,
    the content is in the `Body.Data` field. For multi-part messages (where the body
    is empty), we access the first of the multiple parts and decode that instead.
    Decoding the Base64 content is handled by the standard library decoder:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodeBody()` 函数如下所示。对于纯文本电子邮件，内容位于 `Body.Data` 字段。对于多部分消息（其中正文为空），我们访问多个部分中的第一个并对其进行解码。解码
    Base64 内容由标准库解码器处理：'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The final step in preparing this code is to complete the `EmailServer` interface
    methods. The `ListMessages()` function will return the result of `downloadMessages()`,
    and we can set up `CurrentMessage()` to return the email at the top of the list.
    Full implementation is in this book's code repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 准备此代码的最终步骤是完成 `EmailServer` 接口方法。`ListMessages()` 函数将返回 `downloadMessages()`
    的结果，我们可以设置 `CurrentMessage()` 以返回列表顶部的电子邮件。完整实现见本书的代码库。
- en: Sending messages
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送消息
- en: 'To send a message, we have to package up the data in a raw format to send through
    the API. We''ll re-use the `ToGMailEncoding()` function from the `Post` example
    in [Chapter 12](7d70ada3-8bc9-4c54-b15d-8707e43fc0ce.xhtml), *Concurrency, Networking,
    and Cloud Services*. Before encoding the email, we set an appropriate "From" email address
    (be sure to use the email address of the account you are signed in with or a registered
    alias) and the current date for the time of sending. After encoding, we set the
    data to the `Raw` field of a `gmail.Message` type and pass it to the Gmail `Send()`
    function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送消息，我们必须将数据打包成原始格式以通过 API 发送。我们将重新使用 [第 12 章](7d70ada3-8bc9-4c54-b15d-8707e43fc0ce.xhtml)
    中的 `Post` 示例的 `ToGMailEncoding()` 函数，*并发、网络和云服务*。在编码电子邮件之前，我们设置适当的 "From" 电子邮件地址（务必使用您登录的电子邮件地址或已注册的别名）和发送时的当前日期。编码后，我们将数据设置为
    `gmail.Message` 类型的 `Raw` 字段，并将其传递给 Gmail 的 `Send()` 函数：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This minimal code will be enough to implement sending a message. All of the
    hard work has been done by the earlier setup code—which provided the `srv` object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段最小代码足以实现发送消息。所有艰苦的工作都由之前的设置代码完成——它提供了 `srv` 对象。
- en: Listening for new messages
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听新消息
- en: 'Although Google provides the ability to use push messaging, the setup is very
    complicated—so instead, we''ll poll for new messages. Every 10 seconds, we should
    download any new messages that have arrived. To do this, we can use the history
    API, which returns any messages that appeared after a specific point in history
    (set using `StartHistoryId()`). `HistoryId` is a chronological number that marks
    the order that messages arrived in. Before we can use the history API, we need
    to have a valid `HistoryId`—we can do this by adding the following line to the `downloadMessage()`
    function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管谷歌提供了使用推送消息的能力，但设置非常复杂——因此，我们将改为轮询新消息。每10秒，我们应该下载任何到达的新消息。为此，我们可以使用历史API，该API返回自历史特定点（使用`StartHistoryId()`设置）之后出现的任何消息。`HistoryId`是一个按时间顺序标记消息到达顺序的数字。在我们可以使用历史API之前，我们需要一个有效的`HistoryId`——我们可以通过在`downloadMessage()`函数中添加以下行来实现：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we have a point in history to query from, we need a new function that
    can download any messages since this point in time. The following code is similar
    to `downloadMessages()` in the preceding code but will only download new messages:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个历史点来查询，我们需要一个新的函数，可以下载从这个时间点以来的任何消息。以下代码与前面代码中的`downloadMessages()`类似，但只会下载新消息：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To complete the functionality, we update our `Incoming()` method so that it
    sets up the channel and starts a thread to poll for new messages. Every `10` seconds,
    we''ll download any new messages that have appeared and pass each to the `in`
    channel that was created:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成功能，我们更新我们的`Incoming()`方法，使其设置通道并启动一个线程来轮询新消息。每`10`秒，我们将下载任何出现的新消息并将每个消息传递到创建的`in`通道：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complete code can be found in the `client` package of this book's code repository.
    Let's look at how to use this new email server in our previous examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在本书代码仓库的`client`包中找到。让我们看看如何在之前的示例中使用这个新的电子邮件服务器。
- en: Updating an example to use Gmail
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新示例以使用Gmail
- en: In any one of the GoMail example apps, you'll need to edit the main server setup
    in `main.go`. Replace the server initiation by changing `client.NewTestServer()`
    to `client.NewGMailServer()`. With the `credentials.json` file in place, running
    this new code will obtain a connection to your Gmail account for reading and sending
    emails. Note that, for this example, you'll need to run from the command line
    and follow the OAuth2 setup steps. To make a better user experience, you can provide
    a more sophisticated implementation of the `getTokenFromWeb()` function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在GoMail示例应用中的任何一个，你都需要编辑`main.go`中的主要服务器设置。将服务器初始化更改为将`client.NewTestServer()`更改为`client.NewGMailServer()`。在放置了`credentials.json`文件后，运行此新代码将获得连接到你的Gmail账户以读取和发送电子邮件。请注意，对于此示例，你需要从命令行运行并遵循OAuth2设置步骤。为了提供更好的用户体验，你可以提供一个更复杂的`getTokenFromWeb()`函数实现。
