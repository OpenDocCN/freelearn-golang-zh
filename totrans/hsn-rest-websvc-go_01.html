<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with REST API Development</h1>
                </header>
            
            <article>
                
<p class="mce-root">A web service is a communication mechanism defined between various computer systems. Without web services, custom peer-to-peer communication becomes cumbersome and platform-specific. The web needs to understand and interpret a hundred different things in the form of protocols. If computer systems can align with the protocols that the web can understand easily, it is a great help.</p>
<p>A web service is a software system designed to support interoperable machine-to-machine interaction over a network, as defined by the <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>) at <a href="https://www.w3.org/TR/ws-arch/" target="_blank">https://www.w3.org/TR/ws-arch/</a>.</p>
<p>Now, in simple words, a web service is a road between two endpoints where messages are transferred smoothly. The message transfer is usually one way. Two individual programmable entities can also communicate with each other through their own APIs. Two people communicate through language, two applications communicate through an <strong>Application Programming Interface </strong>(<strong>API</strong>).</p>
<p>The reader might be wondering; what is the importance of the API in the current digital world? The rise of the <strong>Internet of Things </strong>(<strong>IoT</strong>) made API usage heavier than before. Awareness of APIs is growing day by day, and there are hundreds of APIs that are being developed and documented all over the world every day. Notable major businesses are seeing the future in the <strong>API as a Service</strong> (<strong>AaS</strong>). A bright example in recent times is <strong>Amazon Web Services</strong> (<strong>AWS</strong>). AWS is a huge success in the cloud world. Developers write their own applications using the <span><strong>Representational State Transfer</strong> (<strong>REST</strong>)</span> API provided by AWS and access it via <strong>Command-Line Interface</strong> (<strong><span>CLI</span></strong>). </p>
<p>A few more hidden use cases are from travel sites such as <a href="http://Booking.com" target="_blank">http://Booking.com</a> and <a href="https://www.expedia.com/" target="_blank">https://www.expedia.com/</a>, which fetch real-time prices by calling the APIs of third-party gateways and data vendors. Web service usage is often charged these days by the amount of data requests.</p>
<p>In this chapter, we will focus on the following topics:</p>
<ul>
<li>The different web services available</li>
<li><span>REST</span> architecture in detail</li>
<li>The rise of <strong>Single-page applications</strong> (<strong><span>SPAs</span></strong>) with REST</li>
<li>Setting up a Go project and running a development server</li>
<li>Building our first service for finding the fastest mirror site from a list of Debian servers hosted worldwide</li>
<li>The Open API specification and Swagger documentation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The following are the pieces of software that should be pre-installed for running the code samples in this chapter:</p>
<ul>
<li>OS: Linux (Ubuntu 18.04)/ Windows 10/Mac OS X &gt;=10.13</li>
<li>Software: Docker &gt;= 18 (Docker Desktop for Windows and Mac OS X)</li>
<li>The latest version of the Go compiler == 1.13.5</li>
</ul>
<p>We use Docker in this book to run a few sandbox environments. Docker is a virtualization platform that imitates an OS in a sandbox. Using it, we can cleanly run an application or service without affecting the host system.</p>
<p>You can find the code used in this chapter on the book's GitHub repository at <a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter1" target="_blank">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter1</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of web services</h1>
                </header>
            
            <article>
                
<p>There are many types of web services that have evolved over time. Some of the more prominent ones are as follows:</p>
<ul>
<li><strong><span>Simple Object Access Protocol</span></strong> (<strong><span>SOAP</span></strong><span>)</span></li>
<li><strong><span>Universal Description</span></strong>, <strong><span>Discovery, and Integration</span></strong> (<strong><span>UDDI</span></strong>)</li>
</ul>
<ul>
<li><strong><span>Web Services Description Language</span></strong> (<strong><span>WSDL</span></strong><span>)</span></li>
<li><strong><span>Representational State Transfer</span></strong> (<strong><span>REST</span></strong><span>)</span></li>
</ul>
<p>Out of these, SOAP became popular in the early 2000s, when XML riding on a high wave. The XML data format is used by various distributed systems to communicate with each other.</p>
<p>A <kbd>SOAP</kbd> request usually consists of these three basic components:</p>
<ul>
<li>The envelope</li>
<li>The header</li>
<li>The body</li>
</ul>
<p>Just to perform an HTTP request and response cycle, we have to attach a lot of additio<span>nal data in SOAP. A sample SOAP request to a fictional book server, </span><kbd>www.example.org</kbd><span>, looks like this:</span></p>
<pre><span>POST /Books HTTP/1.1<br/>Host: www.example.org<br/>Content-Type: application/soap+xml; charset=utf-8<br/>Content-Length: 299<br/>SOAPAction: "https://www.w3.org/2003/05/soap-envelope"<br/><br/>&lt;?xml version="1.0"?&gt;<br/>&lt;soap:Envelope  &gt;<br/>  &lt;soap:Header&gt;<br/>  &lt;/soap:Header&gt;<br/>  &lt;soap:Body&gt;<br/>    &lt;m:GetBook&gt;<br/>      &lt;m:BookName&gt;Alice in the wonderland&lt;/m:BookName&gt;<br/>    &lt;/m:GetBook&gt;<br/>  &lt;/soap:Body&gt;<br/>&lt;/soap:Envelope&gt;</span></pre>
<p>This is a standard example of a SOAP request for getting book data. If we observe carefully, it is in XML format, with special tags specifying the envelope and body. Since XML works by defining a lot of namespaces, the response gets bulky.</p>
<p>The main drawback of SOAP is that it is too complex for implementing web services and is a heavyweight framework. A SOAP HTTP request can get very bulky and can cause bandwidth wastage. The experts looked for a simple alternative, and in came <span>REST</span>. In the next section, we will briefly <span>discuss</span> REST.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The REST API</h1>
                </header>
            
            <article>
                
<p>The name <strong>Representational state transfer</strong><span> (</span><strong>REST</strong><span>) </span>was coined by Roy Fielding from the University of California. It is a very simplified and lightweight web service compared to SOAP. Performance, scalability, simplicity, portability, and flexibility are the main principles behind the REST design. </p>
<p>The REST API allows different systems to communicate and send/receive data in a very simple way. Each and every REST API call has a relation between an HTTP verb and the URL. The resources in the database in an application can be mapped with an API endpoint in the REST architecture.</p>
<p>When you are using a mobile app on your phone, your phone might be talking to many cloud services to retrieve, update, or delete your data. REST services have a huge impact on our daily lives.</p>
<p>REST is a stateless, cacheable, and simple architecture that is not a protocol, but a pattern. This pattern allows different endpoints to communicate with each other over HTTP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Characteristics of REST services</h1>
                </header>
            
            <article>
                
<p>These are the main properties that make REST simple and unique compared to its predecessors:</p>
<ul>
<li><strong>Client-server based architecture</strong>: This architecture is most essential for the modern web to communicate over HTTP. A single client-server may look naive initially, but many hybrid architectures are evolving. We will discuss more of these shortly.</li>
<li><strong>Stateless</strong>: This is the most important characteristic of a REST service. A REST HTTP request consists of all the data needed by the server to understand and return the response. Once a request is served, the server doesn't remember whether the request arrived after a while. So, the operation will be a stateless one.</li>
<li><strong>Cacheable</strong>: In order to scale an application well, we need to cache certain responses. REST services can be cached for better throughput.</li>
<li><strong>Representation of resources</strong>: The REST API provides the uniform interface to talk to. It uses a <strong>Uniform Resource Identifier</strong> (<strong>URI</strong>) to map the resources (data). It also has the advantage of requesting a specific data</li>
<li><strong>Implementation freedom</strong>: REST is just a mechanism to define your web services. It is an architectural style that can be implemented in multiple ways. Because of this flexibility, you can create REST services in the way you wish to. As long as it follows the principles of REST, you have the freedom to choose the platform or technology for your server.<strong><strong> </strong></strong></li>
</ul>
<div class="packt_tip"><span> Thoughtful caching is essential for REST services to scale.<br/></span></div>
<p class="mce-root">We have seen the types of web services and understood what is REST API. We also looked at the characteristics that make REST services unique. In the next section, we will take a look at REST verbs and status code and cover a few examples of path parameters. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST verbs and status codes</h1>
                </header>
            
            <article>
                
<p>REST verbs specify an action to be performed on a specific resource or a collection of resources. When a request is made by the client, it should send the following information in the HTTP request:</p>
<ul>
<li>The REST verb</li>
<li>Header information</li>
<li>The body (optional)</li>
</ul>
<p>As we mentioned previously, REST uses the URI to decode the resource to be handled. There are quite a few REST verbs available, but six of them are used particularly frequently. They are presented, along with their expected actions, in the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>REST Verb</strong></td>
<td><strong>Action</strong></td>
</tr>
<tr>
<td><kbd>GET</kbd></td>
<td>Fetches a record or set of resources from the server</td>
</tr>
<tr>
<td><kbd>OPTIONS</kbd></td>
<td>Fetches all available REST operations </td>
</tr>
<tr>
<td><kbd>POST</kbd></td>
<td>Creates <span>a resource or </span>a new set of resources</td>
</tr>
<tr>
<td><kbd>PUT</kbd></td>
<td>Updates or replaces the given record</td>
</tr>
<tr>
<td><kbd>PATCH</kbd></td>
<td>Modifies the given record</td>
</tr>
<tr>
<td><kbd>DELETE</kbd></td>
<td>Deletes the given resource </td>
</tr>
</tbody>
</table>
<p> </p>
<p>The status of these operations can be known from HTTP status codes. Whenever a client initiates a REST operation, since REST is stateless, the client should know a way to find out whether the operation was successful or not. For that reason, HTTP responses have a status code. REST defines a few standard status code types for a given operation. This means a REST API should strictly follow the following rules to achieve stable results in client-server communication. There are three important ranges available based on the types of error. See the following table for error ranges:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Status Code Type</strong></td>
<td><strong>Number Range</strong></td>
<td><strong>Action</strong></td>
</tr>
<tr>
<td><kbd>Success</kbd></td>
<td>200 - 226</td>
<td> The 2xx family is used for successful responses.</td>
</tr>
<tr>
<td><kbd>Error</kbd></td>
<td>400 - 499 (client), 500 - 599 (server)</td>
<td>The 4xx family is used for indicating client errors. The 5xx is for server failures to process the request.</td>
</tr>
<tr>
<td><kbd>Redirect</kbd></td>
<td>300 - 308</td>
<td>The 3xx family is for URL redirection.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The detail of what each status code does is very precisely defined, and the overall count of codes increases every year. We mention the important ones in the upcoming section. <a href="https://httpstatuses.com/"/></p>
<p>All requests to REST services have the following format. It consists of the host and the API endpoint. The API endpoint is the URL path that is predefined by the server. It can also include optional query parameters.</p>
<div class="packt_tip">A trivial REST API URI looks like the following: <kbd>http://HostName/APIEndpoint/?key=value(optional)</kbd></div>
<p>Let's look at all the verbs in more detail. The REST API design starts with the defining of operations and API endpoints. Before implementing the API, the design document should list all the endpoints for the given resources.</p>
<p>In the following section, we carefully observe the REST API endpoints using PayPal's REST API as a use case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GET</h1>
                </header>
            
            <article>
                
<p>A <kbd>GET</kbd> method fetches the given resource from the server. To specify a resource, <kbd>GET</kbd> uses a few types of URI queries:</p>
<ul>
<li>Query parameters</li>
<li>Path-based parameters</li>
</ul>
<p>In case you didn't know, most of your browsing of the web is done by performing a <kbd>GET</kbd> request to the server. For example, if you type <a href="http://www.google.com">www.google.com</a>, you are actually making a <kbd>GET</kbd> request to fetch the search page. Here, your browser is the client and Google's web server is the backend implementer of web services. A successful <kbd>GET</kbd> operation returns a <kbd>200</kbd> status code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Examples of path parameters</h1>
                </header>
            
            <article>
                
<p>Everyone knows <strong>PayPal</strong>. PayPal creates billing agreements with companies. If you register with PayPal for a payment system, they provide you with a REST API for all your billing needs. The sample <kbd>GET</kbd> request for getting the information of a billing agreement looks like this: <kbd><span>/v1/payments/billing-agreements/agreement_id</span></kbd><span>.</span></p>
<p>Here, the resource query is with the path parameter. When the server sees this line, it interprets it as <em>I got an HTTP request with a need for</em> <kbd>agreement_id</kbd> <em>from the billing agreements</em>. Then it searches through the database, goes to the <kbd>billing-agreements</kbd> table, and finds an agreement with the given <kbd>agreement_id</kbd>. If that resource exists, it sends back a copy of the details in response (<kbd>200 OK</kbd>), or else it sends a response saying, "resource not found" (<kbd>404</kbd>).</p>
<p>Using <kbd>GET</kbd>, you can also query a list of resources, instead of a single one as in the preceding example. PayPal's API for getting billing transactions related to an agreement can be fetched with <kbd><span>/v1/payments/billing-agreements/transactions</span></kbd>. This line fetches all transactions that occurred on that billing agreement. In both instances, the data is retrieved in the form of a JSON response. The response format should be designed beforehand so that the client can consume it in the agreement.</p>
<p>Examples of query parameters are as follows:</p>
<ul>
<li>Query parameters are intended to add detailed information to identify a resource from the server. For example, imagine a sample fictitious API. Let's assume this API is created for fetching, creating, and updating the details of the book. A query parameter based <kbd>GET</kbd> request will be in this format:<strong> </strong></li>
</ul>
<pre style="padding-left: 60px"><strong>/v1/books/?category=fiction&amp;publish_date=2017</strong></pre>
<ul>
<li>The preceding URI has a couple of query parameters. The URI is requesting a book from the <kbd>books</kbd> resource that satisfies the following conditions:</li>
<li style="padding-left: 30px">It should be a fiction book</li>
<li style="padding-left: 30px">The book should have been published in the year 2017</li>
</ul>
<p><em>Get all the fiction books that are released in the year 2017</em> is the question the client is posing to the server. </p>
<p><kbd>Path</kbd> vs <kbd>Query</kbd> parameters<span>—</span>When to use them? It is a common rule of thumb that <kbd>Query</kbd> parameters are used to fetch multiple resources based on the <kbd>Query</kbd> parameters. If a client needs a single resource with exact URI information, it can use <kbd>Path</kbd> parameters to specify the resource. For example, a user dashboard can be requested with <kbd>Path</kbd> parameters, and fetch data on filtering can be modeled with <kbd>Query</kbd> parameters.</p>
<div class="packt_tip"><span>Use <kbd>Path</kbd> parameters for a single resource and <kbd>Query</kbd> parameters for multiple resources in a <kbd>GET</kbd> request.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">POST, PUT, and PATCH </h1>
                </header>
            
            <article>
                
<p>The <kbd>POST</kbd> method is used to create a resource on the server. In the previous <kbd>books</kbd> API, this operation creates a new book with the given details. A successful <kbd>POST</kbd> operation returns a 2xx status code. The <kbd>POST</kbd> request can update multiple resources: <kbd><span>/v1/books</span></kbd><span>.</span></p>
<p>The <kbd>POST</kbd> request can have a JSON body like the following: </p>
<pre>{"name" : "Lord of the rings", "year": 1954, "author" : "<span>J. R. R. Tolkien</span>"}</pre>
<p>This actually creates a new book in the database. An ID is assigned to this record so that when we <kbd>GET</kbd> the resource, the URL is created. So, <kbd>POST</kbd> should be done only once, in the beginning. In fact, <em>Lord of the Rings</em> was published in <em>1955</em>. So, we entered the published date incorrectly. In order to update the resource, let's use the <kbd>PUT</kbd> request.</p>
<p>The <kbd>PUT</kbd> method is similar to <kbd>POST</kbd>. It is used to replace the resource that already exists. The main difference is that <kbd>PUT</kbd> is an idempotent operation. A <kbd>POST</kbd> call creates two instances with the same data. But <kbd>PUT</kbd> updates a single resource that already exists:</p>
<pre><strong>/v1/books/1256</strong></pre>
<p><kbd>PUT</kbd> does this using a body containing JSON syntax, as follows:</p>
<pre><strong>{"name" : "Lord of the rings", "year": 1955, "author" : "J. R. R. Tolkien"}</strong></pre>
<p><kbd>1256</kbd> is the ID of the book. It updates the preceding book with <kbd>year:1955</kbd>. Did you observe the drawback of <kbd>PUT</kbd>? It actually replaced the entire old record with the new one. We needed to change a single column. But <kbd>PUT</kbd> replaced the whole record. That is bad. For this reason, the <kbd>PATCH</kbd> request was introduced. </p>
<p>The <kbd>PATCH</kbd> method is similar to <kbd>PUT</kbd>, except it won't replace the whole record. <kbd>PATCH</kbd>, as the name suggests, patches the column that is being modified. Let's update the book <kbd>1256</kbd> with a new column called <kbd>ISBN</kbd>:</p>
<pre><strong>/v1/books/1256</strong></pre>
<p>Let's use put the following JSON in the body:</p>
<pre><strong>{"isbn" : "0618640150"}</strong></pre>
<p>It tells the server, "<em>search for the book with ID</em> <kbd>1256</kbd><em>. Then add/modify this column with the given value</em>."</p>
<div class="packt_tip"> <kbd>PUT</kbd> and <kbd>PATCH</kbd> both return a 2xx status for success and 404 for not found.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DELETE and OPTIONS</h1>
                </header>
            
            <article>
                
<p>The <kbd>DELETE</kbd> API method is used to delete a resource from the database. It is similar to <kbd>PUT</kbd> but without a body. It just needs an ID of the resource to be deleted. Once a resource gets deleted, subsequent <kbd>GET</kbd> requests return a 404 not found status. </p>
<div class="packt_infobox"><span>Responses to this method are</span> <em>not cacheable</em> (should caching be implemented) because the <kbd>DELETE</kbd> method is idempotent.</div>
<p>The <kbd>OPTIONS</kbd> API method is the most underrated in API development. Given the resource, this method tries to find all possible methods (<kbd>GET</kbd>, <kbd>POST</kbd>, and so on) defined on the server. It is like looking at the menu card at a restaurant and then ordering an item that is available (whereas if you randomly order a dish, the waiter will tell you it is not available). It is best practice to implement the <kbd>OPTIONS</kbd> method on the server. From the client, make sure <kbd>OPTIONS</kbd> is called first, and if the method is available, then proceed with it. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross-Origin Resource Sharing (CORS)</h1>
                </header>
            
            <article>
                
<p>The most important application of this <kbd>OPTIONS</kbd> method is <strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>). Initially, browser security prevented the client from making cross-origin requests. It means a site loaded with the <kbd>www.foo.com</kbd> <span>URL </span>can only make API calls to that host. If the client code needs to request files or data from <kbd>www.bar.com</kbd>, then the second server, <kbd>bar.com</kbd>, should have a mechanism to recognize <kbd>foo.com</kbd> to get its resources.</p>
<p>The following is the diagram depicting the CORS process:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/07f80e14-0814-48e4-945f-eee3fc018de1.png" style="width:32.50em;height:32.00em;"/></p>
<p>Let's examine the steps followed in the preceding CORS diagram:</p>
<ol>
<li><kbd>foo.com</kbd> requests the <kbd>OPTIONS</kbd> method on <kbd>bar.com</kbd></li>
<li><kbd>bar.com</kbd> sends a header like <kbd>Access-Control-Allow-Origin: http://foo.com</kbd> in response to the client</li>
<li>Next, <kbd>foo.com</kbd> can access the resources on <kbd>bar.com</kbd> without any restrictions that call any <kbd>REST</kbd> method</li>
</ol>
<p>If <kbd>bar.com</kbd> feels like supplying resources to any host after one initial request, it can set the access control to <kbd>*</kbd><span>.</span></p>
<p>In the next section, we see why the REST API plays such a major role in the next generation of web services. SPAs made it possible to leverage APIs for all purposes, including the UI, clients, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The rise of the REST API with SPAs</h1>
                </header>
            
            <article>
                
<p><span>Let's try to understand why SPAs are already standards of today's web. Instead of building a UI in the traditional way (that is, requesting rendered web pages), SPA designs allow developers to write code in a totally different way. There are many <strong>Model-View-Controller</strong> (<strong>MVC</strong>) frameworks, including Angular, React, Vue.js, and so on, for developing web UIs rapidly, but the essence of each of them is pretty simple. All MVC frameworks help us to implement one design pattern. That design pattern is</span> <em>no requesting of web pages, only REST API usage.</em></p>
<p class="graf graf--p graf-after--blockquote">Modern frontend <span>web </span>development has advanced a lot in the last decade (2010-2020). In order to exploit the features of<strong> </strong>the MVC architecture, we have to consider the frontend as a separate entity that talks to the backend only using the REST API (preferably using JSON data).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Old and new methods of data flow in SPA</h1>
                </header>
            
            <article>
                
<p class="graf graf--p graf-after--p">In the traditional flow of serving requests, the order looks like this:</p>
<ol class="postList">
<li class="graf graf--li graf-after--p">The client requests a web page from the server</li>
<li class="graf graf--li graf-after--li">The server authenticates and returns a rendered response</li>
<li class="graf graf--li graf-after--li">Every rendered response is in HTML with embedded data</li>
</ol>
<p class="graf graf--p graf-after--li">With SPAs, however, the flow is quite different:</p>
<ol class="postList">
<li class="graf graf--li graf-after--p">Request the HTML templates with the browser in one single go</li>
<li class="graf graf--li graf-after--li">Then, query the JSON REST API to fill a model (the data object)</li>
<li class="graf graf--li graf-after--li">Adjust the UI according to the data in the model (in JSON)</li>
<li class="graf graf--li graf-after--li">From the browser, push back the changes to the server via an API call</li>
</ol>
<p>In this way, communication happens only in the form of the REST API. The client takes care of logically representing the data. This causes systems to move from <strong>Response-Oriented Architecture</strong> (<strong>ROA</strong>) to <strong>Service-Oriented Architecture</strong> (<strong>SOA</strong>). Take a look at the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/32cf1a89-be4d-47fd-9af6-138118491a8d.png" style="width:36.00em;height:38.58em;"/></p>
<p class="mce-root">SPAs reduce bandwidth usage and improve site performance. SPAs are a major boost for API-centric server development because now a server can satisfy requirements for both browser and API clients.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why use Go for REST API development?</h1>
                </header>
            
            <article>
                
<p>REST services are trivial in the modern web. SOA (which we discuss in more detail later) created an activity space for REST services to take web development to the next level. <strong>Go</strong> is a programming language from the house of Google for solving the bigger problems they have. It has been over ten years since its first appearance. It matured along the way with the developer community jumping in and creating huge-scale systems in it.</p>
<div class="packt_infobox">Go is the darling of the web. It solves bigger problems in an easy way.</div>
<p>We could choose Python or JavaScript (<em>Node.js</em>) for our REST API development, but the main advantage of Go lies in its speed and compile-time error detection. Go has been proven to be faster than dynamic programming languages in terms of computational performance according to various benchmarks. These are the three reasons why a company should write their next API in Go:</p>
<ul>
<li>To scale your API for a wider audience</li>
<li>To enable your developers to build robust systems</li>
<li>To start simple and go big</li>
</ul>
<p>As we progress through this book, we learn how to build efficient REST services in Go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the project and running the development server</h1>
                </header>
            
            <article>
                
<p>This is a building series book. It assumes you already know the basics of Go. If not, no worries. You can get a jump-start and learn the basics quickly from Go's official site at <a href="https://golang.org/">https://golang.org/</a>. Writing a simple <span>standalone </span>program with Go is straightforward. But for big projects, we have to set up a clean project layout. For that reason, as a Go developer, you should know how Go projects are laid out and the best practices to keep your code clean.</p>
<p>Make sure you have done the following things before proceeding:</p>
<ul>
<li>Install the Go compiler on your machine</li>
<li>Set the <kbd>GOROOT</kbd> and <kbd>GOPATH</kbd> environment variables</li>
</ul>
<p>There are many online references from which you can get to know the preceding details. Depending on your machine type (Windows, Linux, or <span>Mac OS X </span>), set up a working Go compiler. We will see more details about <kbd>GOPATH</kbd> in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Demystifying GOPATH </h1>
                </header>
            
            <article>
                
<p><kbd>GOPATH</kbd> is nothing but the current appointed workspace on your machine. It is an environment variable that tells the Go compiler where your source code, binaries, and packages are placed.</p>
<p>The programmers coming from a Python background may be familiar with the <kbd>Virtualenv</kbd> tool for creating multiple projects (with different Python interpreter versions) at the same time. But at a given time, you can activate the environment for the project that you wish to work on and develop your project. Similarly, you can have any number of Go projects on your machine. While developing, set the <kbd>GOPATH</kbd> to one of your projects. The Go compiler now activates that project.</p>
<p>It is a common practice to create a project under the <span><kbd>home</kbd></span> directory and set the <kbd>GOPATH</kbd> environment variable as follows:</p>
<pre class="graf graf--pre graf-after--p"><strong>mkdir /home/user/workspace</strong><br/><strong>export GOPATH=/home/user/workspace</strong></pre>
<p>Now, we install external packages like this:</p>
<pre><strong>go get -u -v github.com/gorilla/mux</strong></pre>
<p> Go copies a project called <kbd>mux</kbd> from GitHub into the currently activated project <kbd>workspace</kbd>.</p>
<div class="packt_tip">For <kbd>go get</kbd>, use the <kbd>-u</kbd> flag to install the updated dependencies of the external package, and <kbd>-v</kbd> to see the verbose details of the installation.</div>
<p>A typical Go project, <kbd>hello</kbd>, should reside in the <kbd>src</kbd> directory in <kbd>GOPATH</kbd>, as mentioned on the official Go website:</p>
<p class="CDPAlignCenter CDPAlign"> <img src="assets/9131a9e3-2370-4186-b5bf-643b42b2287a.png" style="width:29.00em;height:11.33em;"/> </p>
<p>Let's understand this structure before digging further:</p>
<ul>
<li><kbd>bin</kbd>: Stores the binary of our project; a shippable binary that can be run directly</li>
<li><kbd>pkg</kbd>: Contains the package objects; a compiled program that supplies package methods</li>
<li><kbd>src</kbd>: The place for your project source code, tests, and user packages</li>
</ul>
<p>In Go, all the packages imported into the main program have an identical structure, <kbd>github.com/user/project</kbd>. But who creates all these directories? Should the developer do that? Yes. It is the developer's responsibility to create directories for their project. It means they only create the <kbd>src/github.com/user/hello</kbd> <span>directory. </span></p>
<p>When a developer runs the <kbd>install</kbd> command, t<span>he <kbd>bin</kbd> and <kbd>package</kbd> directories are created if they did not exist before. </span><kbd>.bin</kbd><span> consists of the binary of our project source code and </span><kbd>.pkg</kbd><span> consists of all internal and external packages we use in our Go programs:</span></p>
<pre><strong> go install github.com/user/project<br/></strong></pre>
<p>Let's build a small service to brush up on our Go language skills. Operating systems such as Debian and Ubuntu host their release images on multiple FTP servers. These are called mirrors. Mirrors are helpful in serving an OS image from the closest point to a client. Let's build a service that finds the fastest mirror from a list of mirrors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building our first service – finding the fastest mirror site from a list</h1>
                </header>
            
            <article>
                
<p>With the concepts we have built up to now, let's write our first REST service. Many mirror sites exist for hosting operating system images including Ubuntu and Debian. The mirror sites here are nothing but websites on which OS images are hosted to be geographically close to the downloading machines.</p>
<p>Let's look at how we can create our first service:</p>
<p><strong>Problem</strong>:</p>
<p>Build a REST service that returns the information of the fastest mirror to download a given OS from a huge list of mirrors. Let's take the Debian OS mirror list for this service. You can find the list at <a href="https://www.debian.org/mirror/list" target="_blank">https://www.debian.org/mirror/list</a>.<a href="https://www.debian.org/mirror/list"/></p>
<p>We use that list as input when implementing our service.</p>
<p><strong>Design</strong>:</p>
<p>Our REST API should return the URL of the fastest mirror.</p>
<p>The block of the API design document may look like this:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>HTTP Verb</strong></td>
<td><strong>PATH</strong></td>
<td><strong>Action</strong></td>
<td><strong>Resource</strong></td>
</tr>
<tr>
<td><kbd>GET</kbd></td>
<td><kbd>/fastest-mirror</kbd></td>
<td>fetch</td>
<td><kbd>URL: string</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Implementation</strong>:</p>
<p>Now we are going to implement the preceding API step by step:</p>
<div class="packt_infobox">The code for this project is available at <a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go</a> in the <kbd>chapter1</kbd> subdirectory.</div>
<ol>
<li>As we previously discussed, you should set the <kbd>GOPATH</kbd> variable first. Let's assume the <kbd>GOPATH</kbd> <span>variable </span>is <kbd>/home/user/workspace</kbd>. Create a directory called <kbd>mirrorFinder</kbd> in the following path. <kbd>git-user</kbd><em> </em>should be replaced with your GitHub username under which this project resides:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir -p $GOPATH/src/github.com/git-user/chapter1/mirrorFinder</strong></pre>
<ol start="2">
<li>Our project is ready. We don't have any data store configured yet. Create an empty file called <kbd>main.go</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch $GOPATH/src/github.com/git-user/chapter1/mirrorFinder/main.go</strong></pre>
<ol start="3">
<li>Our main logic for the API server goes into this file. For now, we can create a data file that works as a data service for our main program. Create one more directory for packaging the mirror list data: </li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir $GOPATH/src/github.com/git-user/chapter1/mirrors</strong></pre>
<ol start="4">
<li>Now, create an empty file called <kbd>data.go</kbd> in the <kbd>mirrors</kbd> directory. The <kbd>src</kbd> directory structure so far looks like this:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">github.com \<br/>-- git-user \<br/>    -- chapter1 <br/>       -- mirrorFinder \<br/>           -- main.go<br/>       -- mirrors \<br/>           -- data.go</pre>
<ol start="5">
<li>Let's start adding code to the files. Create an input data file called <kbd>data.go</kbd> for our API to use:</li>
</ol>
<div>
<pre style="padding-left: 60px"><span>package mirrors<br/><br/>// MirrorList is list of Debian mirror sites<br/>var MirrorList = [...]string{<br/>  "http://ftp.am.debian.org/debian/", "http://ftp.au.debian.org/debian/",<br/>  "http://ftp.at.debian.org/debian/", "http://ftp.by.debian.org/debian/",<br/>  "http://ftp.be.debian.org/debian/", "http://ftp.br.debian.org/debian/",<br/>  "http://ftp.bg.debian.org/debian/", "http://ftp.ca.debian.org/debian/",<br/>  "http://ftp.cl.debian.org/debian/", "http://ftp2.cn.debian.org/debian/",<br/>  "http://ftp.cn.debian.org/debian/", "http://ftp.hr.debian.org/debian/",<br/>  "http://ftp.cz.debian.org/debian/", "http://ftp.dk.debian.org/debian/",<br/>  "http://ftp.sv.debian.org/debian/", "http://ftp.ee.debian.org/debian/",<br/>  "http://ftp.fr.debian.org/debian/", "http://ftp2.de.debian.org/debian/",<br/>  "http://ftp.de.debian.org/debian/", "http://ftp.gr.debian.org/debian/",<br/>  "http://ftp.hk.debian.org/debian/", "http://ftp.hu.debian.org/debian/",<br/>  "http://ftp.is.debian.org/debian/", "http://ftp.it.debian.org/debian/",<br/>  "http://ftp.jp.debian.org/debian/", "http://ftp.kr.debian.org/debian/",<br/>  "http://ftp.lt.debian.org/debian/", "http://ftp.mx.debian.org/debian/",<br/>  "http://ftp.md.debian.org/debian/", "http://ftp.nl.debian.org/debian/",<br/>  "http://ftp.nc.debian.org/debian/", "http://ftp.nz.debian.org/debian/",<br/>  "http://ftp.no.debian.org/debian/", "http://ftp.pl.debian.org/debian/",<br/>  "http://ftp.pt.debian.org/debian/", "http://ftp.ro.debian.org/debian/",<br/>  "http://ftp.ru.debian.org/debian/", "http://ftp.sg.debian.org/debian/",<br/>  "http://ftp.sk.debian.org/debian/", "http://ftp.si.debian.org/debian/",<br/>  "http://ftp.es.debian.org/debian/", "http://ftp.fi.debian.org/debian/",<br/>  "http://ftp.se.debian.org/debian/", "http://ftp.ch.debian.org/debian/",<br/>  "http://ftp.tw.debian.org/debian/", "http://ftp.tr.debian.org/debian/",<br/>  "http://ftp.uk.debian.org/debian/", "http://ftp.us.debian.org/debian/",<br/>}</span></pre></div>
<p style="padding-left: 60px">We create a map of strings called <kbd>MirrorList</kbd>. This map holds information on the URL to reach the mirror site. We are going to import this information into our main program to serve the request from the client.</p>
<ol start="6">
<li>Open <kbd>main.go</kbd> <span>and add the following code:</span></li>
</ol>
<pre style="padding-left: 60px">import (<br/>  "encoding/json"<br/>  "fmt"<br/>  "log"<br/>  "net/http"<br/>  "time"<br/><br/>  "github.com/git-user/chapter1/mirrors"<br/>)<br/><br/><br/>type response struct {<br/>  FastestURL string `json:"fastest_url"`<br/>  Latency time.Duration `json:"latency"`<br/>}<br/><br/><br/>func main() {<br/>  http.HandleFunc("/fastest-mirror", func(w http.ResponseWriter,<br/>  r *http.Request) {<br/>    response := findFastest(mirrors.MirrorList)<br/>    respJSON, _ := json.Marshal(response)<br/>    w.Header().Set("Content-Type", "application/json")<br/>    w.Write(respJSON)<br/>  })<br/>  port := ":8000"<br/>  server :=<span> </span><span class="pl-c1">&amp;</span><span>http</span>.Server{<br/>    Addr: port,<br/>    ReadTimeout: 10 * time.Second,<br/>    WriteTimeout: 10 * time.Second,<br/>    MaxHeaderBytes: 1 &lt;&lt; 20,<br/>  }<br/>  fmt.Printf("Starting server on port %sn", port)<br/>  log.Fatal(server.ListenAndServe())<br/>}</pre>
<p style="padding-left: 60px">We created the main function that runs an HTTP server. Go provides the <kbd>net/http</kbd> package for that purpose. The response of our API is a struct with two fields:</p>
<ul>
<li style="padding-left: 30px"><kbd>fastest_url</kbd>: The fastest mirror site</li>
<li style="padding-left: 30px"><kbd>latency</kbd>: The time it takes to download the README from the Debian OS repository</li>
</ul>
<ol start="7">
<li>We will code a function called <kbd>findFastest</kbd> to make requests to all the mirrors and calculate the fastest of all. To do this, instead of making sequential API calls to each and every URL one after the other, we use Go routines to parallelly request the URLs and once a goroutine returns, we stop there and return that data back.:</li>
</ol>
<pre style="padding-left: 60px">func findFastest(urls []string) response {<br/>  urlChan := make(chan string)<br/>  latencyChan := make(chan time.Duration)<br/><br/>  for _, url := range urls {<br/>    mirrorURL := url<br/>    go func() {<br/>      start := time.Now()<br/>      _, err := http.Get(mirrorURL + "/README")<br/>      latency := time.Now().Sub(start) / time.Millisecond<br/>      if err == nil {<br/>        urlChan &lt;- mirrorURL<br/>        latencyChan &lt;- latency<br/>      }<br/>    }()<br/>  }<br/>  return response{&lt;-urlChan, &lt;-latencyChan}<br/>}</pre>
<p style="padding-left: 60px">The <kbd>findFastest</kbd> function is taking a list of URLs and returning the response struct. The function creates a goroutine per mirror site URL. It also creates two channels, <kbd>urlChan</kbd> and <kbd>latencyChan</kbd>, which are passed to the goroutines. In the goroutines, we calculate the latency (time taken for the request).</p>
<p style="padding-left: 60px">The smart logic here is, whenever a goroutine receives a response, it writes data into two channels with the URL and latency information respectively. Upon receiving data, the two channels make the response struct and return from the <kbd>findFastest</kbd> function. When that function is returned, all goroutines spawned from that are stopped from whatever they are doing. So, we will have the shortest URL in <kbd>urlChan</kbd> and the smallest latency in <kbd>latencyChan</kbd>.</p>
<ol start="8">
<li>Now if you add this function to the main file (<kbd>main.go</kbd>), our code is complete for the task:</li>
</ol>
<div class="packt_tip">Always use the Go <kbd>fmt</kbd> tool to format your Go code. Some example <span>usage of <kbd>fmt</kbd> </span>looks like the following: <kbd>go fmt github.com/narenaryan/romanserver</kbd></div>
<ol start="9">
<li>Now, install this project with the Go command, <kbd>install</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>go install github.com/git-user/chapter1/mirrorFinder</strong></pre>
<p style="padding-left: 60px">This step does two things:</p>
<ul>
<li style="padding-left: 30px">Compiles <span>the packag</span><span>e</span> <kbd>mirrors</kbd><span> and places a copy in the </span><kbd>$GOPATH/pkg</kbd> <span>directory</span></li>
<li style="padding-left: 30px">Places a binary in the <kbd>$GOPATH/bin</kbd></li>
</ul>
<ol start="10">
<li>We can run the preceding API server like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>$GOPATH/bin/mirrorFinder</strong></pre>
<p style="padding-left: 60px">The server is up and running on <kbd>http://localhost:8000</kbd>. Now we can make a <kbd>GET</kbd> request to the API using a client such as a browser or a <span>curl</span> command. Let's fire a <kbd>curl</kbd> command with a proper API <kbd>GET</kbd> request.</p>
<p style="padding-left: 60px">Request one is as follows:</p>
<pre style="padding-left: 60px"><strong>curl -i -X GET "http://localhost:8000/fastest-mirror" # Valid request</strong></pre>
<p style="padding-left: 60px">The response is as follows:</p>
<pre style="padding-left: 60px">HTTP/1.1 200 OK<br/>Content-Type: application/json<br/>Date: Wed, 27 Mar 2019 23:13:42 GMT<br/>Content-Length: 64<br/><br/>{"fastest_url":"http://ftp.sk.debian.org/debian/","latency":230}</pre>
<p>Our fastest-mirror-finding API is working great. The right status code is being returned. The output may change with each API call, but it fetches the lowest-latency link at any given moment. This example also shows where goroutines and channels shine.</p>
<p>In the next section, we'll look at an API specification called Open API. An API specification is for documenting the REST API. To visualize the specification, we will use the Swagger UI tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Open API and Swagger</h1>
                </header>
            
            <article>
                
<p>Because APIs are very common, t<span>he Open API Specification is a community-driven open specification within the </span><a href="https://www.openapis.org/">OpenAPI Initiative</a><span>, a Linux Foundation Collaborative Project.</span></p>
<p>The <strong>OpenAPI Specification</strong> (<strong>OAS</strong>), formerly called the <kbd>Swagger</kbd> Specification, is an API description format for REST APIs. An Open API file allows you to describe your entire API, including the following:</p>
<ul>
<li>Available endpoints </li>
<li>Endpoint operations (GET, PUT, DELETE, and so on)</li>
<li>Parameter input and output for each operation</li>
<li>Authentication methods</li>
<li>Contact information, license, terms of use, and other information.</li>
</ul>
<p>Open API has many versions and is rapidly developing. The current stable version is <kbd>3.0</kbd>.</p>
<p>There are two formats, <strong>JSON</strong> and <strong>YAML</strong>, that are supported by <kbd>OAS</kbd>. Swagger and Open API both are different. Swagger has many products, including the following:</p>
<ul>
<li>Swagger UI (for validating Open API files and interactive docs)</li>
<li>Swagger Codegen (for generating server stubs)</li>
</ul>
<p>Whenever we develop a REST API, it is a better practice to create an Open API/Swagger file that captures all the necessary details and descriptions of the API. The file can then be used in Swagger UI to create interactive documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Swagger UI</h1>
                </header>
            
            <article>
                
<p>Swagger UI can be installed/downloaded on various operating systems, but the best way could be using Docker. A Swagger UI Docker image is available on the Docker Hub. Then we can pass our Open API/Swagger file to the Docker container we run out of the image. Before that, we need to create a JSON file. The Swagger JSON file has few sections:</p>
<ul>
<li><kbd>info</kbd></li>
<li><kbd>servers</kbd></li>
<li><kbd>paths</kbd></li>
</ul>
<p>Let's create a Swagger file with the preceding sections for the first service we built. Let's name it <kbd>openapi.json</kbd>:</p>
<pre>{<br/>  "openapi": "3.0.0",<br/>  "info": {<br/>    "title": "Mirror Finder Service",<br/>    "description": "API service for finding the fastest mirror from the<br/>     list of given mirror sites",<br/>    "version": "0.1.1"<br/>  },<br/>  "servers": [<br/>    {<br/>      "url": "http://localhost:8000",<br/>      "description": "Development server[Staging/Production are different<br/>       from this]"<br/>    }<br/>  ],<br/>  "paths": {<br/>    "/fastest-mirror": {<br/>      "get": {<br/>        "summary": "Returns a fastest mirror site.",<br/>        "description": "This call returns data of fastest reachable mirror<br/>         site",<br/>        "responses": {<br/>          "200": {<br/>            "description": "A JSON object of details",<br/>            "content": {<br/>              "application/json": {<br/>                "schema": {<br/>                  "type": "object",<br/>                  "properties": {<br/>                    "fastest_mirror": {<br/>                      "type": "string"<br/>                    },<br/>                    "latency": {<br/>                      "type": "integer"<br/>                    }<br/>                  }<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p>Please notice how we defined the <kbd>info</kbd>, <kbd>servers</kbd>, and <kbd>paths</kbd> <span>sections.</span></p>
<p>The <kbd>openapi</kbd> tag specifies the version of the API document we are using.</p>
<p>The <kbd>info</kbd> section has a service-related description. The <kbd>servers</kbd> section has the URL of the server where the application/server is running. We used <kbd>localhost:8000</kbd> as we are running it locally. The <kbd>paths</kbd> section has information about all the API endpoints a service provides. It also has information about the request body, response type, and body structure. Even the possible error codes can be encapsulated into <kbd>paths</kbd>. </p>
<p>Now let's install Swagger UI and make use of our Swagger file:</p>
<ol>
<li>To install Swagger UI via Docker, run this command from your shell:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker pull swaggerapi/swagger-ui</strong></pre>
<p style="padding-left: 60px"><span>If you are on Windows 10/Mac OS X , make sure Docker Desktop is running. On Linux, Docker is available all the time once installed.</span></p>
<ol start="2">
<li>This pulls the image from the Docker Hub to your local machine. Now we can run a container that can take an <kbd>openapi.json</kbd> <span>file </span>and launch Swagger UI. Assuming that you have this file in the <kbd>chapter1</kbd> <span>directory, let's use the following command:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>docker run --rm -p 80:8080 -e SWAGGER_JSON=/app/openapi.json -v $GOPATH/github.com/git-user/chapter1:/app swaggerapi/swagger-ui</strong></pre>
<p style="padding-left: 60px">This command tells Docker to do the following things:</p>
<ul>
<li style="padding-left: 30px">Run a container using the <kbd>swaggerapi/swagger-ui</kbd> image</li>
<li style="padding-left: 30px">Mount <kbd>chapter1</kbd> (where <kbd>openapi.json</kbd> resides) to the <kbd>/app</kbd> directory in the container</li>
<li style="padding-left: 30px">Expose host port <span><kbd>80</kbd> </span>to container port <kbd><span>8080</span></kbd></li>
<li style="padding-left: 30px">Set the <kbd>SWAGGER_JSON</kbd> environment variable to <kbd>/app/openapi.json</kbd></li>
</ul>
<p>When the container starts, launch <kbd>http://locahost</kbd> in the browser. You will see nice documentation for your API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0ece99df-f5f1-44b0-85d8-2ef5dd1d7170.png" style="width:36.83em;height:40.00em;"/></p>
<p>In this way, without any cost, we can create instant documentation of our REST API using Swagger UI and Open API 3.0.</p>
<div class="packt_infobox">For testing an API within Swagger UI, the REST API server needs to be accessible to the Docker container (for example,<span> via a network bridge).</span></div>
<p>From now on, in all chapters, we will try to create Swagger files to document our API design. It is a wise decision to start API development by creating API specifications first and then jumping into implementation. I hope this chapter helped you to brush up on the basics of REST API fundamentals. In the following chapters, we will go deeply into many diverse topics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we gave an introduction to the REST API. We saw that REST is not a protocol, but an architectural pattern. HTTP is the actual protocol on which we can implement our REST service. We jumped into the fundamentals of the REST API to be clear about what they actually are. Then we explored types of web services. Before REST, we had something called SOAP, which used XML as its data format. REST operates on JSON as its primary format. REST has verbs and status codes. We saw what these status codes refer to.</p>
<p>We designed and implemented a simple service that finds the fastest mirror site to download OS images from all Debian mirror sites hosted worldwide. In this process, we also saw how to package a Go project into a binary. We understood the <kbd>GOPATH</kbd> environment variable, which is a workspace definition in Go. We now know that all packages and projects reside on that path.</p>
<p>Next, we jumped into the world of OpenAPI specification by introducing Swagger UI and Swagger files. The structure of these files and how to run Swagger UI with the help of Docker were discussed briefly. We also saw why a developer should start API development by writing down the specifications in the form of a Swagger file.</p>
<p>In the next chapter, we will dig deeper into URL routing. Starting from the built-in router, we will explore Gorilla Mux, a powerful URL routing library.</p>


            </article>

            
        </section>
    </body></html>