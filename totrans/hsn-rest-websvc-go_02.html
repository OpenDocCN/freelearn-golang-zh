<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Handling Routing for our REST Services</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will discuss routing for a REST application. To create an API, the first step is to define routes. To define routes, we have to figure out the available system packages in Go. We'll begin this chapter by exploring the basic internal routing mechanism in Go. We then see how to create a custom multiplexer, an entity that matches a given URL to a registered pattern. <span>A multiplexer basically allows a developer to create a route to listen to client requests and attaches handlers that hold the business logic of the application. </span><span>The</span> <kbd>ServeMux</kbd> package is the basic multiplexer provided by Go. We'll then explore a few other frameworks as <kbd>ServeMux</kbd> capabilities are very limited.</p>
<p>This chapter also includes the likes of third-party libraries such as <kbd>httprouter</kbd> and <kbd>gorilla/mux</kbd>. Then, we'll discuss topics such as SQL injection. The crux of this chapter is to teach you how to create elegant HTTP routers in Go using <kbd>gorilla/mux</kbd>. We'll also <span>briefly </span>discuss designing a URL shortening service.</p>
<p>We will cover the following topics:</p>
<ul>
<li>Understanding Go's  <kbd>net/http</kbd> package</li>
<li><kbd>ServeMux</kbd>—a basic router in Go</li>
<li>Understanding <kbd>httprouter</kbd>—a lightweight HTTP router</li>
<li>Introducing<kbd> gorilla/mux</kbd>—a powerful HTTP router</li>
<li>Reader's challenge: an API for URL shortening</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements </h1>
                </header>
            
            <article>
                
<p>The following are the software that should be pre-installed for running code samples:</p>
<ul>
<li>OS: Linux (Ubuntu 18.04)/Windows 10/<span>Mac OS X </span>&gt;=10.13</li>
<li>Go latest version compiler &gt;= 1.13.5</li>
</ul>
<p>You can download the code for this chapter from <a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter2" target="_blank">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter2</a>. Clone the code and use the code samples in the <kbd>chapter2</kbd> directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Go's net/http package</h1>
                </header>
            
            <article>
                
<p>Accepting HTTP requests is the primary goal of a web server. In Go, there is a <kbd>system-level</kbd> package that helps developers create HTTP servers and clients. The name of the package is <kbd>net/http</kbd>. We can understand the functionality of the <kbd>net/http</kbd> package by creating a small example. The example accepts an incoming request and returns the timestamp of the server. Let us see the steps for creating such a server:</p>
<ol>
<li>Create the program file as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter2/healthCheck/main.go</strong></pre>
<p style="padding-left: 60px">Now, we have a file where we can develop a server with a Health Check API that returns a date/time string.</p>
<ol start="2">
<li>Import the <kbd>net/http</kbd> package and create a function handler called <kbd>HealthCheck</kbd>. The <kbd>http.HandleFunc</kbd> is a method that takes a route and a function handler as its arguments. This function handler has to return an <kbd>http.ResponseWriter</kbd> object:</li>
</ol>
<div>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/> "io"<br/>  "log"<br/>  "net/http"<br/>  "time"<br/>)<br/><br/>// HealthCheck API returns date time to client<br/>func HealthCheck(w http.ResponseWriter, req *http.Request) {<br/>  currentTime := time.Now()<br/>  io.WriteString(w, currentTime.String())<br/>}<br/><br/>func main() {<br/>  http.HandleFunc("/health", HealthCheck)<br/>  log.Fatal(http.ListenAndServe(":8000", nil))<br/>}</pre></div>
<p style="padding-left: 60px">The preceding code creates a <kbd>HealthCheck</kbd> function and attaches it to an HTTP route. <kbd>HandleFunc</kbd> is used to attach a route pattern to a handler function. <kbd>ListenAndServe</kbd> starts a new HTTP server. It returns an error if the server launch is unsuccessful. It takes <kbd>address:port</kbd> as the first argument and the second argument is <kbd>nil</kbd>, which says use the default multiplexer. We will see multiplexers in detail in the upcoming sections.</p>
<div class="packt_tip">Use the <kbd>log</kbd> function to debug potential errors. The <kbd>ListenAndServe</kbd> function returns an error if there is one.</div>
<ol start="3">
<li>Now, we can start the web server using this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter2/healthCheck/main.go<br/></strong></pre>
<p style="padding-left: 60px"><span>Run the </span><kbd>healthCheck.go</kbd><span> file from a shell.</span></p>
<ol start="4">
<li>Now, fire up a shell or browser to see the server in action. Here, we use the <kbd>curl</kbd> request:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET http://localhost:8000/health</strong></pre>
<p style="padding-left: 60px">The response is as follows:</p>
<pre style="padding-left: 60px"><strong>2019-04-10 17:54:05.450783 +0200 CEST m=+6.612810181</strong></pre>
<p>Go has a different concept for handling request and response. We used the <kbd>io</kbd> library to write to the response. For web development, we can use a template to automatically fill in the details. Go's internal URL handlers use a ServeMux<strong> </strong>multiplexer. In the next section, we will discuss more on ServeMux, a built-in URL router in Go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ServeMux – a basic router in Go</h1>
                </header>
            
            <article>
                
<p><span>ServeMux is an HTTP request multiplexer. </span>The <kbd>HandleFunc</kbd> we used in the preceding section is actually a method of ServeMux. By using ServeMux, we can handle multiple routes. We can also create our own multiplexer. A multiplexer handles the logic of separating routes with a function called <kbd>ServeHTTP</kbd>. So, if we create a Go struct with the <kbd>ServeHTTP</kbd> method, it can do the job as the in-built multiplexer.</p>
<p>Consider a route as a key in a Go dictionary (map) and a multiplexer as its value. Go finds the multiplexer from the route and tries to execute the <kbd>ServeHTTP</kbd> function. In the following section, we will see the usage of ServeMux by creating an API that generates UUID strings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a UUID generation API using ServeMux</h1>
                </header>
            
            <article>
                
<p>A UUID is a unique identifier for a resource or a transaction. UUIDs are widely used for identifying an HTTP request. Let us develop an API for generating a UUID. Please follow these steps:</p>
<ol>
<li>Create the program file as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter2/uuidGenerator/main.go</strong></pre>
<ol start="2">
<li>Any Go struct with a few dedicated HTTP methods is qualified to be a ServeMux. For example, we can create a custom <kbd>UUID struct</kbd> and implement the <strong><kbd>ServeHTTP</kbd></strong> function in order to make it a <kbd>ServeMux</kbd> object. Following is the implementation for the <kbd>uuidGenerator.go</kbd> module:</li>
</ol>
<pre style="padding-left: 60px">import (<br/>  "crypto/rand"<br/>  "fmt"<br/>)<br/><br/>// UUID is a custom multiplexer<br/>type UUID struct {<br/>}<br/><br/>func (p *UUID) ServeHTTP(w http.ResponseWriter, r *http.Request) {<br/>  if r.URL.Path == "/" {<br/>    giveRandomUUID(w, r)<br/>    return<br/>  }<br/>  http.NotFound(w, r)<br/>  return<br/>}<br/><br/>func giveRandomUUID(w http.ResponseWriter, r *http.Request) {<br/> c := 10<br/>  b := make([]byte, c)<br/>  _, err := rand.Read(b)<br/>  if err != nil {<br/>    panic(err)<br/>  }<br/>  fmt.Fprintf(w, fmt.Sprintf("%x", b))<br/>}</pre>
<p style="padding-left: 60px"><span>It consists of the <kbd>UUID struct</kbd> that acts as a <kbd>ServeMux</kbd> object. We can access the </span><span>URL path in the handler function and use that information to manually route the requests to different response generators.</span></p>
<p style="padding-left: 60px"><kbd>giveRandomUUID</kbd> is a response generator function that sets a random UUID string to response. Go's <kbd>crypto</kbd> package has a <kbd>Read</kbd> function that fills random characters into a byte array.</p>
<ol start="3">
<li>Now add a main function to the module using the <kbd>ServeMux</kbd> object. We should pass our ServeMux to the  <kbd>http.ListenAndServe</kbd> function to get our content served. We are serving our content on port <kbd>8000</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "net/http"<br/>)<br/><br/>func main() {<br/>  mux := &amp;UUID{}<br/>  http.ListenAndServe(":8000", mux)<br/>}</pre>
<p style="padding-left: 60px">We use UUID as a multiplexer in the <kbd>ListenAndServe</kbd> function, which starts an HTTP server. The server executes the <kbd>ServeHTTP</kbd> method that is defined preceding on the <kbd>mux</kbd> object.</p>
<ol start="4">
<li>Run the following command from your shell/Terminal:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter2/uuidGenerator/main.go</strong></pre>
<ol start="5">
<li>We can make a <kbd>curl</kbd> request like this to make a request to the web server that is listening on port <kbd>8000</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET http://localhost:8000/</strong></pre>
<p style="padding-left: 60px">The response that is returned will be a random string:</p>
<pre style="padding-left: 60px"><strong>544f5519592ac25bb2c0</strong></pre>
<div class="packt_tip">Use <em>Ctrl</em> + <em>C</em> or <em>Cmd</em> + <em>C</em> to stop your Go server. If you are running it as a background process, use <kbd>sudo kill `sudo lsof -t -i:8000`</kbd> to kill a process running on port <kbd>8000</kbd>.</div>
<p>Until now, we have worked with a single handler. Let us see how we can add multiple handlers to route to different function handlers using ServeMux.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding multiple handlers using ServeMux</h1>
                </header>
            
            <article>
                
<p>Let us say we have an API requirement that generates random numbers of different types such as int, float, and so on. The custom <strong>multiplexer</strong> (<strong>mux</strong>) we <span><span>developed</span></span> can be cumbersome when there are multiple endpoints with different functionalities. To add that logic, we need to add multiple <kbd>if/else</kbd> conditions to manually check the URL route. To overcome that complex code structure, we can instantiate a new in-built <kbd>ServeMux</kbd> object and define many handlers. Let's look at the code with <kbd>ServeMux</kbd>:</p>
<pre>newMux := http.NewServeMux()<br/><br/>newMux.HandleFunc("/randomFloat", func(w http.ResponseWriter,<br/>r *http.Request) {<br/> fmt.Fprintln(w, rand.Float64())<br/>})<br/><br/>newMux.HandleFunc("/randomInt", func(w http.ResponseWriter, <br/>r *http.Request) {<br/> fmt.Fprintln(w, rand.Int(100))<br/>})</pre>
<p>This code snippet shows how to create a <kbd>ServeMux</kbd> and attach multiple handlers to it.</p>
<p><kbd>randomFloat</kbd> and <kbd>randomInt</kbd> are the two routes we create for returning a random <kbd>float</kbd> and random <kbd>int</kbd>, respectively. Now, we pass that to the <kbd>ListenAndServe</kbd> function. <kbd>Int(100)</kbd> returns a random integer number from the range 0-100.</p>
<div class="packt_infobox">For more details on random functions, visit the Go random package page at: <a href="http://golang.org" target="_blank">http://golang.org</a>.</div>
<p>Let us see a complete example:</p>
<ol>
<li>Create a file to hold our program and call it <kbd>multipleHandlers.go</kbd> in the following path:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter2/multipleHandlers/main.go<br/></strong></pre>
<ol start="2">
<li>Now create a main function and add the code for creating the <kbd>ServeMux</kbd> object and function handlers.</li>
<li>Finally, run the server with the <kbd>http.ListenAndServe</kbd> method:</li>
</ol>
<div>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>    "fmt"<br/>    "math/rand"<br/>    "net/http"<br/>)<br/><br/>func main() {<br/>    newMux := http.NewServeMux()<br/>    newMux.HandleFunc("/randomFloat", func(w http.ResponseWriter,<br/>    r *http.Request) {<br/>        fmt.Fprintln(w, rand.Float64())<br/>    })<br/>    newMux.HandleFunc("/randomInt", func(w http.ResponseWriter,<br/>    r *http.Request) {<br/>        fmt.Fprintln(w, rand.Intn(100))<br/>    })<br/>    http.ListenAndServe(":8000", newMux)<br/>}</pre></div>
<ol start="4">
<li>We can run the program directly using the <kbd>run</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter2/multipleHandlers/main.go</strong></pre>
<ol start="5">
<li> Now, let us fire two <kbd>curl</kbd> commands and see the output:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET http://localhost:8000/randomFloat</strong><br/><strong>curl -X GET http://localhost:8000/randomInt</strong></pre>
<p style="padding-left: 60px">The responses will be:</p>
<pre style="padding-left: 60px"><strong>0.6046602879796196</strong><br/><strong>87</strong></pre>
<p>We saw how we can create a URL router with basic Go constructs. Let us have a look at a few popular URL routing frameworks that are widely used by the Go community for their API servers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding httprouter – a lightweight HTTP router</h1>
                </header>
            
            <article>
                
<p> <kbd>httprouter</kbd><strong>,</strong> as the name suggests, routes the HTTP requests to particular handlers. <kbd>httprouter</kbd> is a well-known package in Go for creating simple routers with an elegant API. The developers coming from the Python/Django community are very familiar with a full-blown URL dispatcher in the Django framework. <kbd>httprouter</kbd> provides similar features:</p>
<ul>
<li>Allows variables in the route paths</li>
<li>Matches the REST methods (<kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and so on)</li>
<li>No compromise of performance</li>
</ul>
<p>We are going to discuss these qualities in more detail in the following section. Before that, there are a few noteworthy points that make <kbd>httprouter</kbd> an even better URL router:</p>
<ul>
<li><kbd>httprouter</kbd> plays well with the in-built <kbd>http.Handler</kbd></li>
<li><kbd>httprouter</kbd> explicitly says that a request can only match to one route or no route</li>
<li><span>The router's design encourages building sensible, hierarchical RESTful APIs</span></li>
<li> You can build simple and efficient static file servers</li>
</ul>
<p>In the next section, we see the installation of <kbd>httprouter</kbd> and its basic usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing httprouter</h1>
                </header>
            
            <article>
                
<p> <kbd>httprouter</kbd> is an open source Go package and can be installed using the <kbd>go get</kbd> command. Let us see the installation and basic usage in the steps given as follows:</p>
<ol>
<li>Install <kbd>httprouter</kbd> using this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>go get github.com/julienschmidt/httprouter</strong></pre>
<p style="padding-left: 60px">We can import the library in our source code, like this:</p>
<pre style="padding-left: 60px"><strong><span class="pl-s"><span class="pl-pds">import "</span>github.com/julienschmidt/httprouter<span class="pl-pds">"</span></span></strong></pre>
<ol start="2">
<li>The basic usage of <kbd>httprouter</kbd> can be understood through an example.<br/>
Let us write a REST service in Go that provides two things:</li>
</ol>
<ul>
<li style="padding-left: 30px">Gets the Go compiler version</li>
<li style="padding-left: 30px">Gets the content of a given file</li>
</ul>
<p style="padding-left: 60px">We need to use a system package called <kbd>os/exec</kbd> to fetch the preceding details.</p>
<ol start="3">
<li>The <kbd>os/exec</kbd> package has a <kbd>Command</kbd> function, using which we can make any system call and the function signature is this:</li>
</ol>
<pre style="padding-left: 60px">/<strong>/ arguments... means an array of strings unpacked as arguments<br/>// in Go</strong><br/><strong>cmd := exec.Command(command, arguments...)</strong></pre>
<ol start="4">
<li>The <strong><kbd>exec.Command</kbd></strong> function takes the command and an additional argument's array. Additional arguments are the options or input for the command. It can then be executed by calling the <kbd>Output</kbd> function, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>out, err := cmd.Output()</strong></pre>
<ol start="5">
<li>This program uses <kbd>httprouter</kbd> to create the service. Let us create it at the following path:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter2/httprouterExample/main.go</strong></pre>
<p style="padding-left: 60px">The program's main function creates two routes and two function handlers. The responsibilities of function handlers are:</p>
<ul>
<li style="padding-left: 30px">To get the current Go compiler version</li>
<li style="padding-left: 30px">To get the contents of a file</li>
</ul>
<p style="padding-left: 60px">The program is trying to<span> </span>implement<span> </span>a REST service using<span> </span><kbd>httprouter</kbd><strong>.</strong><span> </span>We are defining two routes here:</p>
<ul>
<li style="padding-left: 30px"><kbd>/api/v1/go-version</kbd></li>
<li style="padding-left: 30px"><kbd>/api/v1/show-file/:name</kbd></li>
</ul>
<div>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "fmt"<br/>  "io"<br/>  "log"<br/>  "net/http"<br/>  "os/exec"<br/><br/>  "github.com/julienschmidt/httprouter"<br/>)<br/><br/><br/>func main() {<br/>  router := httprouter.New()<br/>  router.GET("/api/v1/go-version", goVersion)<br/>  router.GET("/api/v1/show-file/:name", getFileContent)<br/>  log.Fatal(http.ListenAndServe(":8000", router))<br/>}</pre></div>
<p> <kbd>:name</kbd> is a path parameter. The basic Go router cannot define these special parameters. By using <kbd>httprouter</kbd>, we can match the REST methods. In the main block, we are matching <kbd>GET</kbd> requests to their respective routes.</p>
<p>Now we are coming to the implementation of three handler functions:</p>
<pre style="padding-left: 30px">func getCommandOutput(command string, arguments ...string) string {<br/>  out, _ := exec.Command(command, arguments...).Output()<br/>  return string(out)<br/>}<br/><br/>func goVersion(w http.ResponseWriter, r *http.Request, params httprouter.Params) {<br/>  response := getCommandOutput("/usr/local/go/bin/go", "version")<br/>  io.WriteString(w, response)<br/>  return<br/>}<br/><br/>func getFileContent(w http.ResponseWriter, r *http.Request, params httprouter.Params) {<br/>  fmt.Fprintf(w, getCommandOutput("/bin/cat", params.ByName("name")))<br/>}</pre>
<p><kbd>exec.Command</kbd> takes the <kbd>bash</kbd> command and respective options as its arguments and returns an object. That object has an <kbd>Output</kbd> method that returns the output result of command execution. We are utilizing this utility <kbd>getCommandOutput</kbd>  function in both <kbd>goVersion</kbd> and <kbd>getFileContent</kbd> handlers. We use shell command formats such as <kbd>go --version</kbd> and <kbd>cat file_name</kbd> in handlers.</p>
<div class="packt_infobox">If you observe the code, we used <kbd>/usr/local/go/bin/go</kbd> as the Go executable location because it is the Go compiler location in <span>Mac OS X</span>. While executing <kbd>exec.Command</kbd>, you should give the absolute path of the executable. So, if you are working on an Ubuntu machine or Windows, use the path to your installed Go executable. On Linux machines, you can easily find that out by using the <kbd>$ which go</kbd> command.</div>
<p>Now create two new files in the same directory. These files will be served by our file server program. You can create any custom files in this directory for testing:</p>
<p><kbd>Latin.txt</kbd>:</p>
<pre>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu.</pre>
<p><kbd>Greek.txt</kbd>:</p>
<pre>Οἱ δὲ Φοίνιϰες οὗτοι οἱ σὺν Κάδμῳ ἀπιϰόμενοι.. ἐσήγαγον διδασϰάλια ἐς τοὺς ῞Ελληνας ϰαὶ δὴ ϰαὶ γράμματα, οὐϰ ἐόντα πρὶν ῞Ελλησι ὡς ἐμοὶ δοϰέειν, πρῶτα μὲν τοῖσι ϰαὶ ἅπαντες χρέωνται Φοίνιϰες· μετὰ δὲ χρόνου προβαίνοντος ἅμα τῇ ϕωνῇ μετέβαλον ϰαὶ τὸν ϱυϑμὸν τῶν γραμμάτων. Περιοίϰεον δέ σϕεας τὰ πολλὰ τῶν χώρων τοῦτον τὸν χρόνον ῾Ελλήνων ῎Ιωνες· οἳ παραλαβόντες διδαχῇ παρὰ τῶν Φοινίϰων τὰ γράμματα, μεταρρυϑμίσαντές σϕεων ὀλίγα ἐχρέωντο, χρεώμενοι δὲ ἐϕάτισαν, ὥσπερ ϰαὶ τὸ δίϰαιον ἔϕερε ἐσαγαγόντων Φοινίϰων ἐς τὴν ῾Ελλάδα, ϕοινιϰήια ϰεϰλῆσϑαι.</pre>
<p>Now run the program with this command. This time, instead of firing a <kbd>curl</kbd> command, let us use the browser as our output for <kbd>GET</kbd>. Windows users may not have curl as the first-hand application. They can use API testing software such as the Postman client while developing the REST API. Take a look at the following command:</p>
<pre><strong>go run $GOPATH/src/github.com/git-user/chapter2/httprouterExample/main.go</strong></pre>
<p>The output for the first <kbd>GET</kbd> request looks like this:</p>
<pre><strong>curl -X GET http://localhost:8000/api/v1/go-version</strong></pre>
<p>The result will be this:</p>
<pre><strong>go version go1.13.5 darwin/amd64</strong></pre>
<p class="mce-root">The second <kbd>GET</kbd> request requesting <kbd>Greek.txt</kbd> is:</p>
<pre class="mce-root"><strong>curl -X GET http://localhost:8000/api/v1/show-file/greek.txt</strong></pre>
<p>Now, we will see the file output in Greek:</p>
<pre>Οἱ δὲ Φοίνιϰες οὗτοι οἱ σὺν Κάδμῳ ἀπιϰόμενοι.. ἐσήγαγον διδασϰάλια ἐς τοὺς ῞Ελληνας ϰαὶ δὴ ϰαὶ γράμματα, οὐϰ ἐόντα πρὶν ῞Ελλησι ὡς ἐμοὶ δοϰέειν, πρῶτα μὲν τοῖσι ϰαὶ ἅπαντες χρέωνται Φοίνιϰες· μετὰ δὲ χρόνου προβαίνοντος ἅμα τῇ ϕωνῇ μετέβαλον ϰαὶ τὸν ϱυϑμὸν τῶν γραμμάτων. Περιοίϰεον δέ σϕεας τὰ πολλὰ τῶν χώρων τοῦτον τὸν χρόνον ῾Ελλήνων ῎Ιωνες· οἳ παραλαβόντες διδαχῇ παρὰ τῶν Φοινίϰων τὰ γράμματα, μεταρρυϑμίσαντές σϕεων ὀλίγα ἐχρέωντο, χρεώμενοι δὲ ἐϕάτισαν, ὥσπερ ϰαὶ τὸ δίϰαιον ἔϕερε ἐσαγαγόντων Φοινίϰων ἐς τὴν ῾Ελλάδα, ϕοινιϰήια ϰεϰλῆσϑαι.</pre>
<div class="packt_infobox">Never give the user the power to execute system commands over the REST API. In the <kbd>exec</kbd> example, we made handlers use a <kbd>getCommandOutput</kbd> helper function to execute system commands.</div>
<p>The endpoint <kbd>/api/v1/show-file/</kbd> we defined in the <kbd>exec</kbd> example is not so efficient. Using <kbd>httprouter</kbd>, we can build advanced and performance-optimized file servers. In the next section, we'll learn how to do that. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a simple static file server in minutes</h1>
                </header>
            
            <article>
                
<p>Sometimes, an API can serve files. The other application of <kbd>httprouter</kbd>, apart from routing, is building an efficient file server. It means that we can build a content delivery platform of our own. Some clients need static files from the server. Traditionally, we use Apache2 or Nginx for that purpose. If one has to create something similar purely in Go, they can leverage <kbd>httprouter.</kbd></p>
<p>Let us build one. From the Go server, in order to serve the static files, we need to route them through a universal route, like this:</p>
<pre><strong>/static/*</strong></pre>
<p>The plan is to use <kbd>http</kbd> package's <kbd>Dir</kbd> method to load the filesystem, and pass filesystem handler it returns to <kbd>httprouter</kbd>. We can use the <strong><kbd>ServeFiles</kbd> </strong>function of the <kbd>httprouter</kbd> instance to attach a router to the filesystem handler. It should serve all the files in the given public directory. Usually, static files are kept in the <strong><kbd>/var/public/www</kbd> </strong>folder<strong> </strong>on a Linux machine. Create a folder called <kbd>static</kbd> in your home directory:</p>
<pre><strong>mkdir -p /users/git-user/static</strong></pre>
<p>Now, copy the <kbd>Latin.txt</kbd> and <kbd>Greek.txt</kbd> files,<strong> </strong>which we created for the previous example, to the preceding static directory. After doing that, let us write the program for the file server using the following steps. You will be amazed at the simplicity of <kbd>httprouter</kbd>:</p>
<ol>
<li>Create a program at the following path:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter2/fileServer/main.go</strong></pre>
<ol start="2">
<li>Update the code like the following. You have to add a route that links a static file path route to a filesystem handler:</li>
</ol>
<div>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "log"<br/>  "net/http"<br/><br/>  "github.com/julienschmidt/httprouter"<br/>)<br/><br/>func main() {<br/>  router := httprouter.New()<br/>  // Mapping to methods is possible with HttpRouter<br/>  router.ServeFiles("/static/*filepath", <br/>   http.Dir("/Users/git-user/static"))<br/>  log.Fatal(http.ListenAndServe(":8000", router))<br/>}<br/><br/></pre></div>
<ol start="3">
<li>Now run the server and see the output:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter2/fileServer/main.go</strong></pre>
<ol start="4">
<li class="mce-root">Open another Terminal and fire this <kbd>curl</kbd> request:</li>
</ol>
<pre style="padding-left: 60px"><strong>http://localhost:8000/static/latin.txt</strong></pre>
<ol start="5">
<li class="mce-root CDPAlignLeft CDPAlign">Now, the output will be a static file content server from our file server:</li>
</ol>
<pre style="padding-left: 60px"><strong>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu.<br/></strong></pre>
<p class="mce-root">In the next section, we discuss about a widely used HTTP router called <kbd>gorilla/mux</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing gorilla/mux – a powerful HTTP router</h1>
                </header>
            
            <article>
                
<p class="graf graf--p graf-after--p">The word <kbd>Mux</kbd> stands for the multiplexer. <kbd>gorilla/mux</kbd> is a multiplexer designed to multiplex HTTP routes (URLs) to different handlers. Handlers are the functions that can handle the given requests. <kbd><span>g</span>orilla/mux</kbd> is a wonderful package for writing beautiful routes for our API servers.</p>
<p class="graf graf--p graf-after--p"><kbd><span>g</span><span>orilla/mux</span></kbd> provides tons of options to control how routing is done to your web application. It allows a lot of features, such as:</p>
<ul class="postList">
<li class="graf graf--li graf-after--p">Path-based matching</li>
<li class="graf graf--li graf-after--li">Query-based matching</li>
<li class="graf graf--li graf-after--li">Domain-based matching</li>
<li class="graf graf--li graf-after--li">Sub-domain-based matching</li>
<li class="graf graf--li graf-after--li">Reverse URL generation</li>
</ul>
<p>Which type of routing to use depends on the types of clients requesting the server. We first see the installation and then a basic example to understand the <kbd>gorilla/mux</kbd> package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing gorilla/mux</h1>
                </header>
            
            <article>
                
<p class="graf graf--p graf-after--h3">Follow these steps to install the mux package:</p>
<ol>
<li class="graf graf--p graf-after--h3">You need to run this command in the Terminal (<span>Mac OS X </span>and Linux):</li>
</ol>
<pre class="graf graf--pre graf-after--p" style="padding-left: 60px"><strong>go get -u github.com/gorilla/mux</strong></pre>
<ol start="2">
<li class="graf graf--p graf-after--pre">If you get any errors saying <kbd>package github.com/gorilla/mux: cannot download, $GOPATH not set. For more details see--go help gopath</kbd>, set the <kbd>$GOPATH</kbd> environment variable using the following command:</li>
</ol>
<pre class="graf graf--pre graf-after--p" style="padding-left: 60px"><strong>export GOPATH=~/go</strong></pre>
<ol start="3">
<li class="graf graf--p graf-after--pre">As we discussed in <a href="eb93f11e-bb80-40dc-873c-e350560467db.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started with REST API Development</em>, all the packages and programs go into GOPATH. It has three folders: <kbd>bin</kbd>, <strong><kbd>pkg</kbd></strong>, and <kbd>src</kbd>. Now, add <kbd>GOPATH</kbd> to the <kbd>PATH</kbd> variable to use the installed bin files as system utilities that have no <kbd>./executable</kbd> style. Refer to the following command:</li>
</ol>
<pre class="graf graf--pre graf-after--p" style="padding-left: 60px"><strong>PATH="$GOPATH/bin:$PATH"</strong></pre>
<ol start="4">
<li class="graf graf--p graf-after--pre">These settings stay until you turn off your machine. So, to make it a permanent change, add the preceding line to your <kbd>bash/zsh</kbd> profile file:</li>
</ol>
<pre class="graf graf--pre graf-after--p" style="padding-left: 60px"><strong>vi ~/.profile</strong><br/>(or)<br/><strong>vi ~/.zshrc </strong></pre>
<p>We can import <kbd>gorilla/mux</kbd> in our programs, like this:</p>
<pre><strong>import "github.com/gorilla/mux"</strong></pre>
<p class="graf graf--p graf-after--pre">Now, we are ready to go. Assuming <kbd><span>g</span><span>orilla/mux</span></kbd> is installed, we can now explore its basics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fundamentals of gorilla/mux</h1>
                </header>
            
            <article>
                
<p class="graf graf--p graf-after--h3">The <kbd>gorilla/mux</kbd> package primarily helps to create routers, similar to <kbd>httprouter</kbd>. The difference between both is the attachment of a handler function to a given URL. If we observe, the <kbd>gorilla/mux</kbd> way of attaching a handler is similar to that of basic ServeMux. Unlike <kbd>httprouter</kbd>, <kbd>gorilla/mux</kbd> wraps all the information of an HTTP request into a single request object.</p>
<p>The three important tools provided in the <kbd>gorilla/mux</kbd> API are:</p>
<ul>
<li>The <kbd>mux.NewRouter</kbd> method</li>
<li>The <kbd>*http.Request</kbd> object</li>
<li>The <kbd>*http.ResponseWriter</kbd> object</li>
</ul>
<p>The <kbd>NewRouter</kbd> method creates a <kbd>new router</kbd> object. That object basically maps a route to a function handler. <kbd>gorilla/mux</kbd> passes a modified <kbd>*http.Request</kbd> and <kbd>*http.ResponseWriter</kbd> object to the function handler. These special objects have lots of additional information about headers, path parameters, request body, and query parameters. Let us explain how to define and use different routers in <kbd>gorilla/mux</kbd> with two common types:</p>
<ul>
<li>Path-based matching</li>
<li>Query-based matching</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Path-based matching</h1>
                </header>
            
            <article>
                
<p class="graf graf--p graf-after--h3">A path parameter in the URL of an HTTP <kbd>GET</kbd> request looks like this:</p>
<pre><strong>https://example.org/articles/books/123</strong></pre>
<p>Since it is passed after the base URL and API endpoint, in this case <kbd>https://example.org/articles/</kbd>, they are called path parameters. In the preceding URL, <kbd>books</kbd> and <kbd>123</kbd> are path parameters. Let us see an example of how to create routes that can consume data supplied as path parameters. Follow these steps: </p>
<ol>
<li><span>Create a new file for our program at the following path:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter2/muxRouter/main.go</strong></pre>
<ol start="2">
<li>The idea is to create a new router, <kbd>mux.NewRouter</kbd>, and use it as a handler with in-built <kbd>http.Server</kbd>. We can attach URL endpoints to handler functions on this router object. The URL endpoints attached can also be regular expressions. The simple program to collect path parameters from a client HTTP request and return back the same looks like this:</li>
</ol>
<div>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "fmt"<br/>  "log"<br/>  "net/http"<br/>  "time"<br/><br/>  "github.com/gorilla/mux"<br/>)<br/><br/>func ArticleHandler(w http.ResponseWriter, r *http.Request) {<br/>  vars := mux.Vars(r)<br/>  w.WriteHeader(http.StatusOK)<br/>  fmt.Fprintf(w, "Category is: %v\n", vars["category"])<br/>  fmt.Fprintf(w, "ID is: %v\n", vars["id"])<br/>}<br/><br/>func main() {<br/>  r := mux.NewRouter()<br/>  r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler)<br/>  srv := &amp;http.Server{<br/>    Handler: r,<br/>    Addr: "127.0.0.1:8000",<br/>    WriteTimeout: 15 * time.Second,<br/>    ReadTimeout: 15 * time.Second,<br/>  }<br/>  log.Fatal(srv.ListenAndServe())<br/>}</pre></div>
<ol start="3">
<li class="graf graf--p graf-after--pre">Now run the server using the following command in a shell:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter2/muxRouter/main.go</strong></pre>
<div class="aspectRatioPlaceholder is-locked">
<ol start="4">
<li class="progressiveMedia js-progressiveMedia graf-image is-canvasLoaded is-imageLoaded">Make a <kbd>curl</kbd> request from another shell and we can get the output as follows:</li>
</ol>
</div>
<pre style="padding-left: 60px"><strong>curl http://localhost:8000/articles/books/123<br/><br/></strong><strong>Category is: books ID is: 123</strong></pre>
<p class="graf graf--p graf-after--figure">This example shows how to match and parse path parameters. There is one more popular way to collect variable information from an HTTP request and that is with query parameters. In the next section, we see how to create routes that match HTTP requests with query parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Query-based matching</h1>
                </header>
            
            <article>
                
<p class="graf graf--p graf-after--h3">Query parameters are variables that get passed along with the URL in an HTTP request. This is what we commonly see in a REST <kbd>GET</kbd> request. The <kbd>gorilla/mux</kbd> route can match and collect query parameters. See this following URL, for example:</p>
<pre class="graf graf--pre graf-after--p">http://localhost:8000/articles?id=123&amp;category=books</pre>
<p>It has <kbd>id</kbd> and <kbd>category</kbd> as query parameters. All query parameters begin after the <kbd>?</kbd> character.</p>
<p class="graf graf--p graf-after--pre">Let us modify our copy of our previous example into a new one with the name <kbd>queryParameters/main.go</kbd>. Modify the route object to point to a new handler called <kbd>QueryHandler</kbd>, like this:</p>
<pre class="graf graf--pre graf-after--p">// Add this in your main program<br/>r := mux.NewRouter()<br/>r.HandleFunc("/articles", QueryHandler)</pre>
<p class="graf graf--p graf-after--pre">In <kbd>QueryHandler</kbd>, we<span> can use </span><kbd>request.URL.Query()</kbd><span> to obtain query parameters from the HTTP request. </span><kbd>QueryHandler</kbd> looks like this:</p>
<pre>// QueryHandler handles the given query parameters<br/>func QueryHandler(w http.ResponseWriter, r *http.Request) {<br/>  queryParams := r.URL.Query()<br/>  w.WriteHeader(http.StatusOK)<br/>  fmt.Fprintf(w, "Got parameter id:%s!\n", queryParams["id"][0])<br/>  fmt.Fprintf(w, "Got parameter category:%s!", queryParams["category"][0])<br/>}</pre>
<p class="graf graf--p graf-after--pre">This program is similar to the previous example, but processes query parameters instead of path parameters.</p>
<p class="graf graf--p graf-after--pre">Run the new program:</p>
<pre><strong>go run $GOPATH/src/github.com/git-user/chapter2/queryParameters/main.go</strong></pre>
<p class="aspectRatioPlaceholder is-locked CDPAlignLeft CDPAlign">Fire a <kbd>curl</kbd> request in this format in a Terminal:</p>
<pre><strong>curl -X GET http://localhost:8000/articles\?id\=1345\&amp;category\=birds</strong></pre>
<p>We need to escape special characters in the shell. If it is in the browser, there is no problem of escaping. The output looks like this:</p>
<pre><strong>Got parameter id:1345! </strong><br/><strong>Got parameter category:birds!</strong></pre>
<p class="aspectRatioPlaceholder is-locked">The <strong><kbd>r.URL.Query()</kbd> </strong>function returns a map with all the parameter and value pairs. They are basically strings and, in order to use them in our program logic, we need to convert the number strings to integers. We can use Go's <kbd>strconv</kbd> package to convert a string to an integer, and vice versa.</p>
<div class="packt_tip">We have used <kbd>http.StatusOK</kbd> to write a successful HTTP response. Similarly, use appropriate status codes for different REST operations. For example, 404 – Not found, 500 – Server error, and so on.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other notable features of gorilla/mux</h1>
                </header>
            
            <article>
                
<p>We have seen two basic examples. What next? The <kbd>gorilla/mux</kbd> package provides many handy features that makes an API developer's life easy. It gives a lot of flexibility while creating routes. In this section, we try to discuss a few important features. The first feature of interest is generating a dynamic URL with the <strong>reverse mapping</strong> technique.</p>
<p class="graf graf--p graf-after--h3">In simple words, reverse mapping a URL is getting the complete API route for an API resource. Reverse mapping is quite useful when we share links to our web application or API. However, in order to create a URL from data, we should associate a <kbd>Name</kbd> with the <kbd>gorilla/mux</kbd> route. You can name a multiplexer route, like this:</p>
<pre class="graf graf--pre graf-after--p">r.HandlerFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler).<br/>  Name("articleRoute")</pre>
<p class="graf graf--p graf-after--pre">Now, we can get a dynamically generated API route by using the <kbd>url</kbd> method:</p>
<pre class="graf graf--pre graf-after--p">url, err := r.Get("articleRoute").URL("category", "books", "id", "123")<br/>fmt.Printf(url.Path) // prints /articles/books/123</pre>
<p>If a route consists of the additional path parameters defined, we should pass that data as arguments to the <kbd>URL</kbd> method.</p>
<p>The next important feature of a URL router is <strong>path prefix</strong>. A path prefix is a wildcard route for matching all possible paths. It matches all the routes to the API server, post a root word. The general use case of path prefixes is a static file server. Then, when we serve files from a static folder, the API paths should match to filesystem paths to successfully return file content.</p>
<p class="graf graf--p graf-after--h4">For example, if we define <kbd>/static/</kbd> as a path prefix, every API route that has this root word as a prefix is routed to the handler attached.</p>
<p>These paths are matched:</p>
<ul>
<li><kbd>http://localhost:8000/static/js/jquery.min.js</kbd></li>
<li><kbd>http://localhost:8000/static/index.html</kbd></li>
<li><kbd>http://localhost:8000/static/some_file.extension</kbd></li>
</ul>
<p>Using gorilla/mux's <kbd>PathPrefix</kbd> and <kbd>StripPefix</kbd> methods, we can write a static file server, like this:</p>
<pre class="graf graf--pre graf-after--p">r.PathPrefix("/static/").Handler(http.StripPrefix("/static/", http.FileServer(http.Dir("/tmp/static"))))</pre>
<p>The next important feature is <strong>strict slash</strong>. A strict slash activated on a <kbd>gorilla/mux</kbd> router allows a URL to redirect to the same URL with <kbd>/</kbd> appended at the end and vice versa.</p>
<p class="graf graf--p graf-after--h4">For example, let us say we have an <strong><kbd>/articles/</kbd></strong> route that is attached to an <kbd>ArticleHandler</kbd> handler:</p>
<pre class="graf graf--pre graf-after--p">r.StrictSlash(true)<br/>r.Path("/articles/").Handler(ArticleHandler)</pre>
<p class="graf graf--p graf-after--pre">In the preceding case, strict slash is set to <kbd>true</kbd>. The router then redirects even <kbd>/articles</kbd> (without '/' at the end) to the <kbd>ArticleHandler</kbd>. If it is set to <kbd>false</kbd>, the router treats both <kbd>/articles/</kbd> and <kbd>/articles</kbd> as different paths.</p>
<p>The next important feature of a URL router is to match encoded path parameters. The <kbd>gorilla/mux UseEncodedPath</kbd> method can be called on a router to match encoded path parameters.</p>
<p class="graf graf--p graf-after--h4">A server can receive encoded paths from a few clients. We can match the encoded path parameter, we can even match the encoded URL route and forward it to the given handler:</p>
<pre class="graf graf--pre graf-after--p">r.UseEncodedPath()<br/>r.NewRoute().Path("/category/id")</pre>
<p class="graf graf--p graf-after--pre">This can match the following URL:</p>
<pre class="graf graf--pre graf-after--p"><strong>http://localhost:8000/books/2</strong></pre>
<p>As well as this:</p>
<pre><strong>http://localhost:8000/books%2F2</strong></pre>
<p class="graf graf--p graf-after--pre">Where <kbd>%2F2</kbd> stands for <kbd>/2</kbd> in encoded form.</p>
<div class="aspectRatioPlaceholder is-locked packt_infobox">Its pattern-matching features and simplicity push <kbd>gorilla/mux</kbd> as a popular choice for an HTTP router in projects. Many successful projects worldwide are already using mux for their routing needs.</div>
<p>We are free to define routes for our application. Since routes are entry points to any API, developers should be careful about how they process the data received from a client. Clients can be attackers too, who can inject malicious scripts into the path or query parameters. That situation is called a <strong>security vulnerability</strong>. APIs are prone to a common application vulnerability called SQL injection. In the next section, we introduce it briefly and see possible countermeasure steps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SQL injection in URLs and ways to avoid them</h1>
                </header>
            
            <article>
                
<p class="aspectRatioPlaceholder is-locked"><strong>SQL injection</strong> is a process of attacking a database with malicious scripts. If one is not careful when defining URL routes, there may be an opportunity for SQL injection. These attacks can happen for all kinds of REST operations. For example, if we are allowing the client to pass parameters to the server, then there is a chance for an attacker to append an ill-formed string to those parameters. If we are using those variables/parameters directly into an SQL query executing on our database, it could lead to a potential vulnerability.</p>
<p class="aspectRatioPlaceholder is-locked">Look at the following Go code snippet that inserts <kbd>username</kbd> and <kbd>password</kbd> details into the database. It collects values from an HTTP <kbd>POST</kbd> request and appends raw values to the SQL query:</p>
<pre class="aspectRatioPlaceholder is-locked">username := r.Form.Get("id")<br/>password := r.Form.Get("category")<br/>sql := "SELECT * FROM article WHERE id='" + username + "' AND category='" + password + "'"<br/>Db.Exec(sql)</pre>
<p class="aspectRatioPlaceholder is-locked">In the snippet, we are executing a database SQL query, but since we are appending the values directly, we may include malicious SQL statements such as <kbd>--</kbd> comments and <kbd>ORDER BY n</kbd> range clauses in the query:</p>
<pre><strong>?category=books&amp;id=10 ORDER BY 10--</strong></pre>
<p>If the application returns the database response directly to the client, it can leak information about the columns the table has. An attacker can change the <kbd>ORDER BY</kbd> to another number and extract sensitive information:</p>
<pre><strong>Unknown column '10' in 'order clause'</strong></pre>
<p> We will see more about this in our upcoming chapters where we build fully-fledged REST services with other methods, such as <kbd>POST</kbd>, <kbd>PUT</kbd>, and so on:</p>
<p>Now, how to avoid these injections. There are several precautions:</p>
<ul>
<li>Set the user level permissions to various tables in the database</li>
<li>Log the requests and find the suspicious ones</li>
<li>Use the <span><strong><kbd>HTMLEscapeString</kbd> </strong>function from Go's </span><strong><kbd>text/template</kbd> </strong>package to escape special characters in the API parameters, such as <kbd>body</kbd> and <kbd>path </kbd></li>
<li>Use a driver program instead of executing raw SQL queries</li>
<li>Stop relaying database debug messages back to the client</li>
<li>Use security tools such as <kbd>sqlmap</kbd> to find out vulnerabilities</li>
</ul>
<p>With the basics of routing and security covered, in the next section we present an interesting challenge for the reader. It is to create a URL shortening service. We provide all the background details briefly in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reader's challenge – an API for URL shortening</h1>
                </header>
            
            <article>
                
<p>With all the basics you have learned up to now, try to implement a URL shortening service. A URL shortener takes a very long URL and returns a shortened, crisp, and memorable URL back to the user. At first sight, it looks like magic, but it is a simple math trick.</p>
<p>In a single statement, URL shortening services are built upon two things:</p>
<ul>
<li> A string mapping algorithm to map long strings to short strings (Base 62)</li>
<li> A simple web server that redirects a short URL to the original URL</li>
</ul>
<p class="mce-root"/>
<p>There are a few obvious advantages of URL shortening:</p>
<ul>
<li>Users can remember the URL; easy to maintain</li>
<li>Users can use the links where there are restrictions on text length, for example, Twitter</li>
<li>Predictable shortened URL length</li>
</ul>
<p>Take a look at the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d9f22550-1bdc-4284-b716-09cf96dfcc5f.png" style="width:42.42em;height:25.92em;"/></p>
<p>Under the hood, the following things happen in a URL shortening service:</p>
<ol>
<li>Take the original <strong>URL</strong></li>
<li>Apply <strong>BASE62</strong> encoding on it; it generates a <strong>Shortened URL</strong></li>
<li>Store that URL in the database. Map it to the original URL (<kbd>[shortened_url: original_url]</kbd>)</li>
<li>Whenever a request comes to the shortened URL, just do an HTTP redirect to the original URL</li>
</ol>
<p>We will implement a full example in upcoming chapters when we integrate databases to our API server, but before that, though, we should specify the API design documentation.</p>
<p>Take a look at the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 21.6085%"><strong>URL</strong></td>
<td style="width: 12.8876%"><strong>REST Verb</strong></td>
<td style="width: 30.8722%"><strong>Action</strong></td>
<td style="width: 16.6085%"><strong>Success</strong></td>
<td style="width: 16.376%"><strong>Failure</strong></td>
</tr>
<tr>
<td style="width: 21.6085%"><kbd>/api/v1/new</kbd></td>
<td style="width: 12.8876%"><kbd>POST</kbd></td>
<td style="width: 30.8722%"><kbd>Create a shortened URL</kbd></td>
<td style="width: 16.6085%"><kbd>200</kbd></td>
<td style="width: 16.376%"><kbd>500, 404</kbd></td>
</tr>
<tr>
<td style="width: 21.6085%"><kbd>/api/v1/:url</kbd></td>
<td style="width: 12.8876%"><kbd>GET</kbd></td>
<td style="width: 30.8722%"><kbd>Redirect to original URL</kbd></td>
<td style="width: 16.6085%"><kbd>301</kbd></td>
<td style="width: 16.376%"><kbd>404</kbd></td>
</tr>
</tbody>
</table>
<div class="packt_infobox">You can use a dummy JSON file/Go map to store the URL for now instead of a database.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary </h1>
                </header>
            
            <article>
                
<p>In this chapter, we first introduced the HTTP router. We tried to create HTTP routes using Go's <kbd>net/http</kbd> package. Then, we briefly discussed ServeMux with an example. We saw how to add multiple handler functions to multiple routes. Then, we introduced a lightweight router package called <kbd>httprouter</kbd>, which allows developers to create elegant routes, with the option of parsing parameters passed in the URL path.</p>
<p>We can also serve files over the HTTP using <kbd>httprouter</kbd>. We built a small service to get the Go version and file contents (read-only). That example can be extended to fetch any system information or run a system command.</p>
<p>Next, we introduced the popular Go routing library, <kbd>gorilla/mux</kbd>. We discussed how it is different from <kbd>httprouter</kbd> and explored its functionality by implementing two examples. We explained how <kbd>Vars</kbd> can be used to get path parameters and <kbd>r.URL.Query</kbd> to parse query parameters.</p>
<p>As part of securing API routes, we discussed SQL injection and how it can happen in our applications. We have also seen the counter measures. By the end of this chapter, one can define routes and handler functions to accept HTTP API requests.</p>
<p>In the next chapter, we will look at <kbd>Middleware</kbd> functions, which act as tamperers for HTTP requests and responses. That phenomenon helps us to modify the API response on the fly. The next chapter also features <strong>Remote Procedure Call </strong>(<strong>RPC</strong>).</p>
<div class="content-3WfBL_0" style="background-color: #ffffff">
<div class="outputBox-qe9A4_0">
<div class="outputBox-3oESn_0"><span class="outputBox-13Ovx_0"> </span></div>
<div class="outputBox-17RAm_0"/>
</div>
</div>


            </article>

            
        </section>
    </body></html>