- en: Handling Routing for our REST Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss routing for a REST application. To create an
    API, the first step is to define routes. To define routes, we have to figure out
    the available system packages in Go. We'll begin this chapter by exploring the
    basic internal routing mechanism in Go. We then see how to create a custom multiplexer,
    an entity that matches a given URL to a registered pattern. A multiplexer basically
    allows a developer to create a route to listen to client requests and attaches
    handlers that hold the business logic of the application. The `ServeMux` package
    is the basic multiplexer provided by Go. We'll then explore a few other frameworks
    as `ServeMux` capabilities are very limited.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also includes the likes of third-party libraries such as `httprouter`
    and `gorilla/mux`. Then, we'll discuss topics such as SQL injection. The crux
    of this chapter is to teach you how to create elegant HTTP routers in Go using
    `gorilla/mux`. We'll also briefly discuss designing a URL shortening service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Go's  `net/http` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServeMux`—a basic router in Go'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `httprouter`—a lightweight HTTP router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing` gorilla/mux`—a powerful HTTP router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reader''s challenge: an API for URL shortening'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the software that should be pre-installed for running code
    samples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go latest version compiler >= 1.13.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter2](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter2).
    Clone the code and use the code samples in the `chapter2` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Go's net/http package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Accepting HTTP requests is the primary goal of a web server. In Go, there is
    a `system-level` package that helps developers create HTTP servers and clients.
    The name of the package is `net/http`. We can understand the functionality of
    the `net/http` package by creating a small example. The example accepts an incoming
    request and returns the timestamp of the server. Let us see the steps for creating
    such a server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the program file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a file where we can develop a server with a Health Check API that
    returns a date/time string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `net/http` package and create a function handler called `HealthCheck`.
    The `http.HandleFunc` is a method that takes a route and a function handler as
    its arguments. This function handler has to return an `http.ResponseWriter` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a `HealthCheck` function and attaches it to an HTTP
    route. `HandleFunc` is used to attach a route pattern to a handler function. `ListenAndServe` starts
    a new HTTP server. It returns an error if the server launch is unsuccessful. It
    takes `address:port` as the first argument and the second argument is `nil`, which
    says use the default multiplexer. We will see multiplexers in detail in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `log` function to debug potential errors. The `ListenAndServe` function
    returns an error if there is one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start the web server using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the `healthCheck.go` file from a shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, fire up a shell or browser to see the server in action. Here, we use the
    `curl` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Go has a different concept for handling request and response. We used the `io`
    library to write to the response. For web development, we can use a template to
    automatically fill in the details. Go's internal URL handlers use a ServeMuxmultiplexer.
    In the next section, we will discuss more on ServeMux, a built-in URL router in
    Go.
  prefs: []
  type: TYPE_NORMAL
- en: ServeMux – a basic router in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ServeMux is an HTTP request multiplexer. The `HandleFunc` we used in the preceding
    section is actually a method of ServeMux. By using ServeMux, we can handle multiple
    routes. We can also create our own multiplexer. A multiplexer handles the logic
    of separating routes with a function called `ServeHTTP`. So, if we create a Go
    struct with the `ServeHTTP` method, it can do the job as the in-built multiplexer.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a route as a key in a Go dictionary (map) and a multiplexer as its
    value. Go finds the multiplexer from the route and tries to execute the `ServeHTTP`
    function. In the following section, we will see the usage of ServeMux by creating
    an API that generates UUID strings.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a UUID generation API using ServeMux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A UUID is a unique identifier for a resource or a transaction. UUIDs are widely
    used for identifying an HTTP request. Let us develop an API for generating a UUID.
    Please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the program file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Any Go struct with a few dedicated HTTP methods is qualified to be a ServeMux.
    For example, we can create a custom `UUID struct` and implement the **`ServeHTTP`** function
    in order to make it a `ServeMux` object. Following is the implementation for the
    `uuidGenerator.go` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It consists of the `UUID struct` that acts as a `ServeMux` object. We can access
    the URL path in the handler function and use that information to manually route
    the requests to different response generators.
  prefs: []
  type: TYPE_NORMAL
- en: '`giveRandomUUID` is a response generator function that sets a random UUID string
    to response. Go''s `crypto` package has a `Read` function that fills random characters
    into a byte array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add a main function to the module using the `ServeMux` object. We should
    pass our ServeMux to the  `http.ListenAndServe` function to get our content served.
    We are serving our content on port `8000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use UUID as a multiplexer in the `ListenAndServe` function, which starts
    an HTTP server. The server executes the `ServeHTTP` method that is defined preceding
    on the `mux` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command from your shell/Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make a `curl` request like this to make a request to the web server
    that is listening on port `8000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The response that is returned will be a random string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Use *Ctrl* + *C* or *Cmd* + *C* to stop your Go server. If you are running it
    as a background process, use `` sudo kill `sudo lsof -t -i:8000` `` to kill a
    process running on port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have worked with a single handler. Let us see how we can add multiple
    handlers to route to different function handlers using ServeMux.
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple handlers using ServeMux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us say we have an API requirement that generates random numbers of different
    types such as int, float, and so on. The custom **multiplexer** (**mux**) we developed can
    be cumbersome when there are multiple endpoints with different functionalities.
    To add that logic, we need to add multiple `if/else` conditions to manually check
    the URL route. To overcome that complex code structure, we can instantiate a new
    in-built `ServeMux` object and define many handlers. Let''s look at the code with
    `ServeMux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet shows how to create a `ServeMux` and attach multiple handlers
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: '`randomFloat` and `randomInt` are the two routes we create for returning a
    random `float` and random `int`, respectively. Now, we pass that to the `ListenAndServe`
    function. `Int(100)` returns a random integer number from the range 0-100.'
  prefs: []
  type: TYPE_NORMAL
- en: For more details on random functions, visit the Go random package page at: [http://golang.org](http://golang.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see a complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file to hold our program and call it `multipleHandlers.go` in the
    following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now create a main function and add the code for creating the `ServeMux` object
    and function handlers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, run the server with the `http.ListenAndServe` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the program directly using the `run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us fire two `curl` commands and see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The responses will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We saw how we can create a URL router with basic Go constructs. Let us have
    a look at a few popular URL routing frameworks that are widely used by the Go
    community for their API servers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding httprouter – a lightweight HTTP router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`httprouter`**,** as the name suggests, routes the HTTP requests to particular
    handlers. `httprouter` is a well-known package in Go for creating simple routers
    with an elegant API. The developers coming from the Python/Django community are
    very familiar with a full-blown URL dispatcher in the Django framework. `httprouter`
    provides similar features:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows variables in the route paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matches the REST methods (`GET`, `POST`, `PUT`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No compromise of performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to discuss these qualities in more detail in the following section.
    Before that, there are a few noteworthy points that make `httprouter` an even
    better URL router:'
  prefs: []
  type: TYPE_NORMAL
- en: '`httprouter` plays well with the in-built `http.Handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`httprouter` explicitly says that a request can only match to one route or
    no route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router's design encourages building sensible, hierarchical RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build simple and efficient static file servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we see the installation of `httprouter` and its basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: Installing httprouter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`httprouter` is an open source Go package and can be installed using the `go
    get` command. Let us see the installation and basic usage in the steps given as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `httprouter` using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can import the library in our source code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The basic usage of `httprouter` can be understood through an example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us write a REST service in Go that provides two things:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Gets the Go compiler version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gets the content of a given file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to use a system package called `os/exec` to fetch the preceding details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os/exec` package has a `Command` function, using which we can make any
    system call and the function signature is this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The **`exec.Command`** function takes the command and an additional argument''s
    array. Additional arguments are the options or input for the command. It can then
    be executed by calling the `Output` function, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This program uses `httprouter` to create the service. Let us create it at the
    following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The program''s main function creates two routes and two function handlers.
    The responsibilities of function handlers are:'
  prefs: []
  type: TYPE_NORMAL
- en: To get the current Go compiler version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the contents of a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The program is trying to implement a REST service using `httprouter`**.** We
    are defining two routes here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/v1/go-version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/v1/show-file/:name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`:name` is a path parameter. The basic Go router cannot define these special
    parameters. By using `httprouter`, we can match the REST methods. In the main
    block, we are matching `GET` requests to their respective routes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are coming to the implementation of three handler functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`exec.Command` takes the `bash` command and respective options as its arguments
    and returns an object. That object has an `Output` method that returns the output
    result of command execution. We are utilizing this utility `getCommandOutput` 
    function in both `goVersion` and `getFileContent` handlers. We use shell command
    formats such as `go --version` and `cat file_name` in handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: If you observe the code, we used `/usr/local/go/bin/go` as the Go executable
    location because it is the Go compiler location in Mac OS X. While executing `exec.Command`,
    you should give the absolute path of the executable. So, if you are working on
    an Ubuntu machine or Windows, use the path to your installed Go executable. On
    Linux machines, you can easily find that out by using the `$ which go` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create two new files in the same directory. These files will be served
    by our file server program. You can create any custom files in this directory
    for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Latin.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`Greek.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the program with this command. This time, instead of firing a `curl` command,
    let us use the browser as our output for `GET`. Windows users may not have curl
    as the first-hand application. They can use API testing software such as the Postman
    client while developing the REST API. Take a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the first `GET` request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `GET` request requesting `Greek.txt` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will see the file output in Greek:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Never give the user the power to execute system commands over the REST API.
    In the `exec` example, we made handlers use a `getCommandOutput` helper function
    to execute system commands.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint `/api/v1/show-file/` we defined in the `exec` example is not so
    efficient. Using `httprouter`, we can build advanced and performance-optimized
    file servers. In the next section, we'll learn how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple static file server in minutes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, an API can serve files. The other application of `httprouter`, apart
    from routing, is building an efficient file server. It means that we can build
    a content delivery platform of our own. Some clients need static files from the
    server. Traditionally, we use Apache2 or Nginx for that purpose. If one has to
    create something similar purely in Go, they can leverage `httprouter.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us build one. From the Go server, in order to serve the static files, we
    need to route them through a universal route, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The plan is to use `http` package''s `Dir` method to load the filesystem, and
    pass filesystem handler it returns to `httprouter`. We can use the **`ServeFiles` **function
    of the `httprouter` instance to attach a router to the filesystem handler. It
    should serve all the files in the given public directory. Usually, static files
    are kept in the **`/var/public/www` **folderon a Linux machine. Create a folder
    called `static` in your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, copy the `Latin.txt` and `Greek.txt` files,which we created for the previous
    example, to the preceding static directory. After doing that, let us write the
    program for the file server using the following steps. You will be amazed at the
    simplicity of `httprouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a program at the following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the code like the following. You have to add a route that links a static
    file path route to a filesystem handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the server and see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another Terminal and fire this `curl` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the output will be a static file content server from our file server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we discuss about a widely used HTTP router called `gorilla/mux`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing gorilla/mux – a powerful HTTP router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word `Mux` stands for the multiplexer. `gorilla/mux` is a multiplexer designed
    to multiplex HTTP routes (URLs) to different handlers. Handlers are the functions
    that can handle the given requests. `gorilla/mux` is a wonderful package for writing
    beautiful routes for our API servers.
  prefs: []
  type: TYPE_NORMAL
- en: '`gorilla/mux` provides tons of options to control how routing is done to your
    web application. It allows a lot of features, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Path-based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query-based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sub-domain-based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse URL generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which type of routing to use depends on the types of clients requesting the
    server. We first see the installation and then a basic example to understand the `gorilla/mux`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Installing gorilla/mux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to install the mux package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to run this command in the Terminal (Mac OS X and Linux):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get any errors saying `package github.com/gorilla/mux: cannot download,
    $GOPATH not set. For more details see--go help gopath`, set the `$GOPATH` environment
    variable using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed in [Chapter 1](eb93f11e-bb80-40dc-873c-e350560467db.xhtml), *Getting
    Started with REST API Development*, all the packages and programs go into GOPATH.
    It has three folders: `bin`, **`pkg`**, and `src`. Now, add `GOPATH` to the `PATH`
    variable to use the installed bin files as system utilities that have no `./executable`
    style. Refer to the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These settings stay until you turn off your machine. So, to make it a permanent
    change, add the preceding line to your `bash/zsh` profile file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can import `gorilla/mux` in our programs, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to go. Assuming `gorilla/mux` is installed, we can now explore
    its basics.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of gorilla/mux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `gorilla/mux` package primarily helps to create routers, similar to `httprouter`.
    The difference between both is the attachment of a handler function to a given
    URL. If we observe, the `gorilla/mux` way of attaching a handler is similar to
    that of basic ServeMux. Unlike `httprouter`, `gorilla/mux` wraps all the information
    of an HTTP request into a single request object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three important tools provided in the `gorilla/mux` API are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mux.NewRouter` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `*http.Request` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `*http.ResponseWriter` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `NewRouter` method creates a `new router` object. That object basically
    maps a route to a function handler. `gorilla/mux` passes a modified `*http.Request`
    and `*http.ResponseWriter` object to the function handler. These special objects
    have lots of additional information about headers, path parameters, request body,
    and query parameters. Let us explain how to define and use different routers in
    `gorilla/mux` with two common types:'
  prefs: []
  type: TYPE_NORMAL
- en: Path-based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query-based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path-based matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A path parameter in the URL of an HTTP `GET` request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it is passed after the base URL and API endpoint, in this case `https://example.org/articles/`,
    they are called path parameters. In the preceding URL, `books` and `123` are path
    parameters. Let us see an example of how to create routes that can consume data
    supplied as path parameters. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file for our program at the following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is to create a new router, `mux.NewRouter`, and use it as a handler
    with in-built `http.Server`. We can attach URL endpoints to handler functions
    on this router object. The URL endpoints attached can also be regular expressions.
    The simple program to collect path parameters from a client HTTP request and return
    back the same looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the server using the following command in a shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a `curl` request from another shell and we can get the output as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how to match and parse path parameters. There is one more
    popular way to collect variable information from an HTTP request and that is with
    query parameters. In the next section, we see how to create routes that match
    HTTP requests with query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Query-based matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Query parameters are variables that get passed along with the URL in an HTTP
    request. This is what we commonly see in a REST `GET` request. The `gorilla/mux`
    route can match and collect query parameters. See this following URL, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It has `id` and `category` as query parameters. All query parameters begin after
    the `?` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us modify our copy of our previous example into a new one with the name
    `queryParameters/main.go`. Modify the route object to point to a new handler called
    `QueryHandler`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In `QueryHandler`, we can use `request.URL.Query()` to obtain query parameters
    from the HTTP request. `QueryHandler` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This program is similar to the previous example, but processes query parameters
    instead of path parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the new program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Fire a `curl` request in this format in a Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to escape special characters in the shell. If it is in the browser,
    there is no problem of escaping. The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The **`r.URL.Query()` **function returns a map with all the parameter and value
    pairs. They are basically strings and, in order to use them in our program logic,
    we need to convert the number strings to integers. We can use Go's `strconv` package
    to convert a string to an integer, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: We have used `http.StatusOK` to write a successful HTTP response. Similarly,
    use appropriate status codes for different REST operations. For example, 404 – Not
    found, 500 – Server error, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Other notable features of gorilla/mux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen two basic examples. What next? The `gorilla/mux` package provides
    many handy features that makes an API developer's life easy. It gives a lot of
    flexibility while creating routes. In this section, we try to discuss a few important
    features. The first feature of interest is generating a dynamic URL with the **reverse
    mapping** technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'In simple words, reverse mapping a URL is getting the complete API route for
    an API resource. Reverse mapping is quite useful when we share links to our web
    application or API. However, in order to create a URL from data, we should associate
    a `Name` with the `gorilla/mux` route. You can name a multiplexer route, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can get a dynamically generated API route by using the `url` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If a route consists of the additional path parameters defined, we should pass
    that data as arguments to the `URL` method.
  prefs: []
  type: TYPE_NORMAL
- en: The next important feature of a URL router is **path prefix**. A path prefix
    is a wildcard route for matching all possible paths. It matches all the routes
    to the API server, post a root word. The general use case of path prefixes is
    a static file server. Then, when we serve files from a static folder, the API
    paths should match to filesystem paths to successfully return file content.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we define `/static/` as a path prefix, every API route that
    has this root word as a prefix is routed to the handler attached.
  prefs: []
  type: TYPE_NORMAL
- en: 'These paths are matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8000/static/js/jquery.min.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/static/index.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/static/some_file.extension`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using gorilla/mux''s `PathPrefix` and `StripPefix` methods, we can write a
    static file server, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The next important feature is **strict slash**. A strict slash activated on
    a `gorilla/mux` router allows a URL to redirect to the same URL with `/` appended
    at the end and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let us say we have an **`/articles/`** route that is attached
    to an `ArticleHandler` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, strict slash is set to `true`. The router then redirects
    even `/articles` (without '/' at the end) to the `ArticleHandler`. If it is set
    to `false`, the router treats both `/articles/` and `/articles` as different paths.
  prefs: []
  type: TYPE_NORMAL
- en: The next important feature of a URL router is to match encoded path parameters.
    The `gorilla/mux UseEncodedPath` method can be called on a router to match encoded
    path parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'A server can receive encoded paths from a few clients. We can match the encoded
    path parameter, we can even match the encoded URL route and forward it to the
    given handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This can match the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Where `%2F2` stands for `/2` in encoded form.
  prefs: []
  type: TYPE_NORMAL
- en: Its pattern-matching features and simplicity push `gorilla/mux` as a popular
    choice for an HTTP router in projects. Many successful projects worldwide are
    already using mux for their routing needs.
  prefs: []
  type: TYPE_NORMAL
- en: We are free to define routes for our application. Since routes are entry points
    to any API, developers should be careful about how they process the data received
    from a client. Clients can be attackers too, who can inject malicious scripts
    into the path or query parameters. That situation is called a **security vulnerability**.
    APIs are prone to a common application vulnerability called SQL injection. In
    the next section, we introduce it briefly and see possible countermeasure steps.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection in URLs and ways to avoid them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SQL injection** is a process of attacking a database with malicious scripts.
    If one is not careful when defining URL routes, there may be an opportunity for
    SQL injection. These attacks can happen for all kinds of REST operations. For
    example, if we are allowing the client to pass parameters to the server, then
    there is a chance for an attacker to append an ill-formed string to those parameters.
    If we are using those variables/parameters directly into an SQL query executing
    on our database, it could lead to a potential vulnerability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following Go code snippet that inserts `username` and `password`
    details into the database. It collects values from an HTTP `POST` request and
    appends raw values to the SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the snippet, we are executing a database SQL query, but since we are appending
    the values directly, we may include malicious SQL statements such as `--` comments
    and `ORDER BY n` range clauses in the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If the application returns the database response directly to the client, it
    can leak information about the columns the table has. An attacker can change the
    `ORDER BY` to another number and extract sensitive information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see more about this in our upcoming chapters where we build fully-fledged
    REST services with other methods, such as `POST`, `PUT`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how to avoid these injections. There are several precautions:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the user level permissions to various tables in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log the requests and find the suspicious ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the **`HTMLEscapeString` **function from Go's **`text/template` **package
    to escape special characters in the API parameters, such as `body` and `path `
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a driver program instead of executing raw SQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop relaying database debug messages back to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use security tools such as `sqlmap` to find out vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the basics of routing and security covered, in the next section we present
    an interesting challenge for the reader. It is to create a URL shortening service.
    We provide all the background details briefly in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reader's challenge – an API for URL shortening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the basics you have learned up to now, try to implement a URL shortening
    service. A URL shortener takes a very long URL and returns a shortened, crisp,
    and memorable URL back to the user. At first sight, it looks like magic, but it
    is a simple math trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a single statement, URL shortening services are built upon two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A string mapping algorithm to map long strings to short strings (Base 62)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple web server that redirects a short URL to the original URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few obvious advantages of URL shortening:'
  prefs: []
  type: TYPE_NORMAL
- en: Users can remember the URL; easy to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can use the links where there are restrictions on text length, for example,
    Twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predictable shortened URL length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9f22550-1bdc-4284-b716-09cf96dfcc5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the hood, the following things happen in a URL shortening service:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the original **URL**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply **BASE62** encoding on it; it generates a **Shortened URL**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Store that URL in the database. Map it to the original URL (`[shortened_url:
    original_url]`)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever a request comes to the shortened URL, just do an HTTP redirect to the
    original URL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will implement a full example in upcoming chapters when we integrate databases
    to our API server, but before that, though, we should specify the API design documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL** | **REST Verb** | **Action** | **Success** | **Failure** |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/v1/new` | `POST` | `Create a shortened URL` | `200` | `500, 404` |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/v1/:url` | `GET` | `Redirect to original URL` | `301` | `404` |'
  prefs: []
  type: TYPE_TB
- en: You can use a dummy JSON file/Go map to store the URL for now instead of a database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first introduced the HTTP router. We tried to create HTTP
    routes using Go's `net/http` package. Then, we briefly discussed ServeMux with
    an example. We saw how to add multiple handler functions to multiple routes. Then,
    we introduced a lightweight router package called `httprouter`, which allows developers
    to create elegant routes, with the option of parsing parameters passed in the
    URL path.
  prefs: []
  type: TYPE_NORMAL
- en: We can also serve files over the HTTP using `httprouter`. We built a small service
    to get the Go version and file contents (read-only). That example can be extended
    to fetch any system information or run a system command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced the popular Go routing library, `gorilla/mux`. We discussed
    how it is different from `httprouter` and explored its functionality by implementing
    two examples. We explained how `Vars` can be used to get path parameters and `r.URL.Query` to
    parse query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As part of securing API routes, we discussed SQL injection and how it can happen
    in our applications. We have also seen the counter measures. By the end of this
    chapter, one can define routes and handler functions to accept HTTP API requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at `Middleware` functions, which act as tamperers
    for HTTP requests and responses. That phenomenon helps us to modify the API response
    on the fly. The next chapter also features **Remote Procedure Call **(**RPC**).
  prefs: []
  type: TYPE_NORMAL
