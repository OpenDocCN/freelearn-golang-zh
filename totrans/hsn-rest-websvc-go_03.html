<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with Middleware and RPC</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we are going to look at two new concepts. First, we will learn about middleware, and how can we build one from scratch. Then, we will move to a better middleware solution written by the community, called <strong>Gorilla handlers</strong>. We will then see the use cases where middleware is helpful. After that, we will learn about developing <span><strong>Remote Procedure Call </strong></span><span>(<strong>RPC</strong>) </span>services with Go's internal RPC and JSON-RPC. Then, we will move to an advanced RPC framework called Gorilla HTTP RPC.</p>
<p>The topics we cover in this chapter are as follows:</p>
<ul>
<li>What is middleware?</li>
<li>Multiple middleware and chaining </li>
<li>Painless middleware chaining with <kbd>alice</kbd></li>
<li>Using Gorilla handlers middleware for logging</li>
<li>What is RPC?</li>
<li>JSON-RPC using Gorilla RPC</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The following software should be pre-installed for running code samples:</p>
<ul>
<li>OS: Linux (Ubuntu 18.04)/Windows 10/<span>Mac OS X </span>&gt;= 10.13</li>
<li>Software: Docker &gt;= 18 (Docker Desktop for Windows and <span>Mac OS X</span>)</li>
<li>Go latest version compiler &gt;= 1.13.5</li>
</ul>
<p><span>You can download the code for this chapter from </span><a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter3" target="_blank">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter3</a><span>. Clone the code and use the code samples in the </span><kbd>chapter3</kbd><span> directory.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is middleware? </h1>
                </header>
            
            <article>
                
<p><strong>Middleware</strong> is an entity that hooks into a server's request/response life cycle. The middleware can be defined in many components. Each component has a specific function to perform. Whenever we define handlers for URL patterns (as in <a href="72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml" target="_blank">Chapter 2</a>, <em>Handling Routing for our REST Services</em>), a handler executes some business logic for every incoming request. But middleware, as the name specifies, sits between a request and the handler, or between a handler and a response. So, virtually every middleware can perform these functions:</p>
<ul>
<li>Process the request before reaching the handler (function)</li>
<li>Pass the modified request to the handler function (execute some business logic)</li>
<li>Process the response coming from the handler</li>
<li>Pass the modified response to the client</li>
</ul>
<p>We can see the previous points in the form of a visual illustration, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/f03d6714-7a81-4d67-9eee-8d03e3c4fc0c.png" style="width:26.42em;height:48.25em;"/></div>
<p>If we observe the diagram carefully, the journey of a request starts from the client. The request first reaches a middleware called <strong>AUTH MIDDLEWARE</strong> and is then forwarded to a <strong>FUNCTION HANDLER</strong>. Once a response is generated from a handler, it is then forwarded to another middleware called <strong>CUSTOM MIDDLEWARE</strong><span class="packt_screen"> </span>that can modify the response.</p>
<p>In an application with no middleware, a request reaches the API server and gets handled by a function handler directly. The response is immediately sent back from the server, and the client receives it. But in applications with middleware configured to a function handler, it can pass through a set of stages, such as logging, authentication, session validation, and so on, and then proceeds to the business logic. This is to filter the requests from interacting with the business logic. The most common use cases are as follows:</p>
<ul>
<li>Use a logger to log each and every request for a REST API</li>
<li>Validate the session of the user and keep the communication alive</li>
<li>Authenticate the user, if not identified</li>
<li>Attach properties to responses while serving the client</li>
</ul>
<p>With the help of middleware, we can do any housekeeping work, such as authentication, in its proper place. Let's create a basic middleware and tamper an HTTP request in Go.</p>
<p>Middleware functions can be handy when many function handlers have the same business logic to execute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a basic middleware</h1>
                </header>
            
            <article>
                
<p>Building middleware functions is simple and straightforward. Let's build a program based on the knowledge gained from <a href="72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml" target="_blank">Chapter 2</a>, <em>Handling Routing for our REST Services</em>. If you are not familiar with closure functions, a closure function returns another function. This principle helps us write middleware. A middleware should return another function, which can be either a middleware or a function handler. It is similar to JavaScript chain methods, whereby one function returns a new function as a return value. Let's create a closure function in Go, by doing the following:</p>
<ol>
<li>Create a program file, like so:</li>
</ol>
<pre style="padding-left: 30px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/closureExample/main.go</strong></pre>
<p style="padding-left: 60px">We use this file to add our code.</p>
<ol start="2">
<li>A closure function returns another function. Let's create a closure function that generates positive integers, using the following code:</li>
</ol>
<pre style="padding-left: 60px">// This function returns another function<br/>func generator() func() int { // Outer function<br/>   var i = 0<br/>    return func() int { // Inner function<br/>        i++<br/>        return i<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The function is a generator that returns a sequence of integers. <span>A generator pattern generates a new item each time, based on given conditions. The i</span>nner <span>function is returning an anonymous function with no arguments and one return type of integer. The </span><kbd>i</kbd><span> variable that is defined inside the o</span>uter <span>function is available to the anonymous function, making it remember the state between upcoming function calls.</span></p>
<ol start="3">
<li>Now, we can use the previous generator in our <kbd>main</kbd> program, like this:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "fmt"<br/>)<br/><br/>...<br/>func main() {<br/>  numGenerator := generator()<br/>  for i := 0; i &lt; 5; i++ {<br/>    fmt.Print(numGenerator(), "\t")<br/>  }<br/>}</pre>
<ol start="4">
<li>We <span>can run the previous </span>code<span> as a standalone program, as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter3/closureExample/main.go</strong></pre>
<p style="padding-left: 60px">The following numbers will be generated and printed using <em>Tab</em> spaces:</p>
<pre style="padding-left: 60px"><strong>1 2 3 4 5</strong></pre>
<p>In Go, the function signature of the outer function should exactly match the anonymous function's signature. In the previous example, <kbd>func() int</kbd> is the signature for both the outer and inner functions. The only exception is that the outer function can have an interface as a return type, and the inner function can implement that interface. We will see how in the next few lines.</p>
<p>Now, coming to how closures help to build a middleware: any generator function that can return another function that satisfies the <kbd>http.Handler</kbd> interface can be a middleware. Let's validate this statement with an example, as follows:</p>
<ol>
<li>Create a file for our program, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/customMiddleware/main.go</strong></pre>
<ol start="2">
<li>The middleware takes a normal HTTP handler function as its argument and returns another handler function. The function looks like this:</li>
</ol>
<pre style="padding-left: 60px">func middleware(originalHandler http.Handler) http.Handler {<br/>    return http.HandlerFunc(func(w http.ResponseWriter, <br/>    r *http.Request) {<br/>        fmt.Println("Executing middleware before request phase!")<br/>        // Pass control back to the handler<br/>        originalHandler.ServeHTTP(w, r)<br/>        fmt.Println("Executing middleware after response phase!")<br/>    })<br/>}</pre>
<p style="padding-left: 60px">If you notice the preceding middleware function, it is taking <kbd>originalHandler</kbd>, an HTTP handler, as its argument, and is returning another HTTP handler. The inner function is using the original handler to execute the logic. Before and after that handler is where the middleware operates on request and response objects. This makes all the requests coming to the main handler pass through the middleware logic.</p>
<ol start="3">
<li>Now, Let's define the main logic that uses the middleware function we have created, as follows:</li>
</ol>
<pre style="padding-left: 60px">package main<br/>import (<br/>    "fmt"<br/>    "net/http"<br/>)<br/><br/>func handle(w http.ResponseWriter, r *http.Request) {<br/>    // Business logic goes here<br/>    fmt.Println("Executing mainHandler...")<br/>    w.Write([]byte("OK"))<br/>}<br/>func main() {<br/>    // HandlerFunc returns a HTTP Handler<br/>    originalHandler := http.HandlerFunc(handle)<br/>    http.Handle("/", middleware(originalHandler))<br/>    http.ListenAndServe(":8000", nil)<br/>}</pre>
<ol start="4">
<li>Run the code, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter3/customMiddleware/main.go</strong></pre>
<ol start="5">
<li>If you do a <kbd>curl</kbd> request to—or visit— <kbd>http://localhost:8000</kbd> in your browser, the console will receive this message:</li>
</ol>
<pre style="padding-left: 60px"><strong>Executing middleware before request phase!</strong><br/><strong>Executing mainHandler...</strong><br/><strong>Executing middleware after response phase!</strong></pre>
<p><span>This program is denoted by the rectangle block to the right in the preceding diagram, with the label</span> <span class="packt_screen">CUSTOM MIDDLEWARE</span><span>. </span>If you observe the middleware <span>visual illustration</span> provided previously, the request phase direction is to the right, and the response direction is to the left.</p>
<p>Go web frameworks such as Martini and Gin provide middleware by default. We will see more about them in <a href="08db4c3a-536c-4f0c-bedc-fcb802c3306a.xhtml" target="_blank">Chapter 4</a>, <em>Simplifying RESTful Services with Popular Go Frameworks</em>. It is good for a developer to understand the low-level details of middleware.</p>
<p>The following diagram can help you understand how the logic flow happens in the middleware. This diagram explains how a handler is converted into a wrapper handler:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1c61bcf5-1477-48f3-901c-b6e36548941b.png"/></p>
<p>We have seen the creation of a simple middleware, but in a real scenario, multiple middleware are required to log requests, authenticate, and so on. In the next section, we will see how to chain multiple middleware.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple middleware and chaining</h1>
                </header>
            
            <article>
                
<p>In the previous section, we built a single middleware to perform an action before or after a request hits the handler. It is also possible to chain a group of middleware. In order to do that, we should follow the same closure logic as in the preceding section. Let's create a <kbd>cityAPI</kbd> program for saving city details. For simplicity's sake, the API will have one <kbd>POST</kbd> method, and the body will consist of two fields: city name and city area.</p>
<p>Let's us think about a scenario where a client is only allowed to send a JSON <kbd>Content-Type</kbd> request to an API. The main function of the API is to send a response to the client with a UTC timestamp cookie attached to it. We can add that content check in the middleware.</p>
<p>The functions of the two middleware are as follows:</p>
<ul>
<li>In the first middleware, check whether the content type is JSON. If not, don't allow the request to proceed.</li>
<li>In the second middleware, add a timestamp called Server-Time (UTC) to the response cookie.</li>
</ul>
<p>Before adding the middleware, Let's create a <kbd>POST</kbd> API that collects the name and area of a city and returns a message with a status code of <kbd>201</kbd>, to show it has been successfully created. This can be done in the following way:</p>
<ol>
<li>Create a file for our program, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/cityAPI/main.go</strong></pre>
<ol start="2">
<li>Now, write the function that handles the <kbd>POST</kbd> request from the client. It decodes the body and reads the name and area, and fills them into a struct called <kbd>city</kbd>, like this:</li>
</ol>
<pre style="padding-left: 60px">type city struct {<br/>  Name string<br/>  Area uint64<br/>}<br/><br/>func postHandler(w http.ResponseWriter, r *http.Request) {<br/>  if r.Method == "POST" {<br/>    var tempCity city<br/>    decoder := json.NewDecoder(r.Body)<br/>    err := decoder.Decode(&amp;tempCity)<br/>    if err != nil {<br/>      panic(err)<br/>    }<br/>    defer r.Body.Close()<br/>    fmt.Printf("Got %s city with area of %d sq miles!\n",<br/>     tempCity.Name, tempCity.Area)<br/>    w.WriteHeader(http.StatusOK)<br/>    w.Write([]byte("201 - Created"))<br/>  } else {<br/>    w.WriteHeader(http.StatusMethodNotAllowed)<br/>    w.Write([]byte("405 - Method Not Allowed"))<br/>  }<br/>}</pre>
<p style="padding-left: 60px"><kbd>postHandler</kbd> is handling a client request in this snippet. It returns a status code of <kbd>405 - Method Not Allowed</kbd> if a client tries to perform a <kbd>GET</kbd> request. <kbd>json.NewDecoder</kbd> is used to read the body from a request. <kbd>Decode</kbd> maps the body parameters to a struct, of the <kbd>city</kbd>  type.</p>
<ol start="3">
<li>Now comes the main logic, as shown here:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "encoding/json"<br/>  "fmt"<br/>  "net/http"<br/>)<br/><br/>func main() {<br/>  http.HandleFunc("/city", postHandler)<br/>  http.ListenAndServe(":8000", nil)<br/>}</pre>
<ol start="4">
<li>We can start the API server by using the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter3/cityAPI/main.go</strong></pre>
<ol start="5">
<li>Then, fire a couple of <kbd>curl</kbd> requests, like so:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -H "Content-Type: application/json" -X POST http://localhost:8000/city -d '{"name":"New York", "area":304}'</strong><br/><br/><strong>curl -H "Content-Type: application/json" -X POST http://localhost:8000/city -d '{"name":"Boston", "area":89}'</strong></pre>
<ol start="6">
<li>The server logs this output:</li>
</ol>
<pre style="padding-left: 60px"><strong>Got New York city with area of 304 sq miles!</strong><br/><strong>Got Boston city with area of 89 sq miles!</strong></pre>
<p style="padding-left: 60px">The <kbd>curl</kbd> responses are as follows:</p>
<pre style="padding-left: 60px"><strong>201 - Created</strong><br/><strong>201 - Created</strong></pre>
<ol start="7">
<li>Now comes the content checks. In order to chain middleware functions, we have to pass the handler between multiple middleware. Only one handler is involved in the preceding example. But now, for the upcoming task, the idea is to pass the main handler to multiple middleware handlers. We can modify the <kbd>cityAPI</kbd> program to a new file, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/multipleMiddleware/main.go</strong></pre>
<ol start="8">
<li>Let's first create the content-check middleware. Let's call it <kbd>filterContentType</kbd>. This middleware checks the <kbd>MIME</kbd> header from the request and, if it is not JSON, returns a response of status code <kbd>415- Unsupported Media Type</kbd>, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">func filterContentType(handler http.Handler) http.Handler {<br/> return http.HandlerFunc(func(w http.ResponseWriter,<br/>  r *http.Request) {<br/> log.Println("Currently in the check content type middleware")<br/> // Filtering requests by MIME type<br/> if r.Header.Get("Content-type") != "application/json" {<br/> w.WriteHeader(http.StatusUnsupportedMediaType)<br/> w.Write([]byte("415 - Unsupported Media Type. Please send JSON"))<br/> return<br/> }<br/> handler.ServeHTTP(w, r)<br/> })<br/>}</pre>
<ol start="9">
<li>Now, Let's define a second middleware called <kbd>setServerTimeCookie</kbd>. After receiving a proper content type while sending a response back to the client, this middleware adds a cookie called <span><kbd>Server-Time(UTC)</kbd> </span>with the server UTC timestamp as the value, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">func setServerTimeCookie(handler http.Handler) http.Handler {<br/>  return http.HandlerFunc(func(w http.ResponseWriter,<br/>  r *http.Request) {<br/>    handler.ServeHTTP(w, r)<br/>    // Setting cookie to every API response<br/>    cookie := http.Cookie{Name: "Server-Time(UTC)", <br/>     Value: strconv.FormatInt(time.Now().Unix(), 10)}<br/>    http.SetCookie(w, &amp;cookie)<br/>    log.Println("Currently in the set server time middleware")<br/>  })<br/>}</pre>
<ol start="10">
<li>The main function has a slight variation in the mapping of a route to the handler. It uses nested function calls for chaining middleware, as can be seen here:</li>
</ol>
<pre style="padding-left: 60px">func main() {<br/>  originalHandler := http.HandlerFunc(handle)<br/>  http.Handle("/city", <br/>   filterContentType(setServerTimeCookie(originalHandler)))<br/>  http.ListenAndServe(":8000", nil)<br/>}</pre>
<p style="padding-left: 90px">We chain the middleware by using <kbd>filterContentType(setServerTimeCookie(originalHandler))</kbd>. Please carefully observe the order of chaining.</p>
<ol start="11">
<li>Now, run the updated server, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter3/multipleMiddleware/main.go</strong></pre>
<p style="padding-left: 60px">Then, fire a <kbd>curl</kbd> request, like this:</p>
<pre style="padding-left: 60px"><strong>curl -i -H "Content-Type: application/json" -X POST http://localhost:8000/city -d '{"name":"Boston", "area":89}'</strong></pre>
<p style="padding-left: 60px">The response output is the following:</p>
<pre style="padding-left: 60px"><strong>HTTP/1.1 200 OK</strong><br/><strong>Date: Sat, 27 May 2017 14:35:46 GMT</strong><br/><strong>Content-Length: 13</strong><br/><strong>Content-Type: text/plain; charset=utf-8</strong><br/><br/><strong>201 - Created</strong></pre>
<ol start="12">
<li>But if we remove <kbd>Content-Type: application/json</kbd> from the <kbd>curl</kbd> request, the middleware blocks us from executing the main handler, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -i -X POST http://localhost:8000/city -d '{"name":"New York", "area":304}'<br/><br/>Result:</strong><strong><br/></strong><strong>HTTP/1.1 415 Unsupported Media Type</strong><br/><strong>Date: Sat, 27 May 2017 15:36:58 GMT</strong><br/><strong>Content-Length: 46</strong><br/><strong>Content-Type: text/plain; charset=utf-8</strong><br/><br/><strong>415 - Unsupported Media Type. Please send JSON</strong></pre>
<p>This is the simplest way of chaining middleware in Go API servers.</p>
<p>If an API server wishes a request to go through many middleware, then how can we make that chaining simple and readable? There is a very good library called <kbd>alice</kbd> to solve this problem. It allows you to semantically order and attach your middleware to the main handler. We will see it briefly in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Painless middleware chaining with Alice</h1>
                </header>
            
            <article>
                
<p>The <kbd>alice</kbd> library reduces the complexity of chaining the middleware when the list of middleware is big. It provides us with a clean API to pass the handler to the middleware. It is a lightweight solution, unlike other middleware chaining Go packages.</p>
<p>Install <kbd>alice</kbd> via the <kbd>go get</kbd> command, like this:</p>
<pre><strong>go get github.com/justinas/alice</strong></pre>
<p>Now, we can import the <kbd>alice</kbd> package in our program and use it straight away. We can modify the sections of the previous program to bring the same functionality, with improved chaining. Let's call the program directory <kbd><span>multipleMiddlewareWithAlice</span></kbd>, and create a main program in this location:</p>
<pre><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/multipleMiddlewareWithAlice/main.go</strong></pre>
<p>In the <kbd>import</kbd> section, add <kbd>github.com/justinas/alice</kbd>, as shown in the following code snippet:</p>
<div>
<pre>import (<br/>    "encoding/json"<br/>    "github.com/justinas/alice"<br/>    "log"<br/>    "net/http"<br/>    "strconv"<br/>    "time"<br/>)</pre></div>
<p>Now, in the <kbd>main</kbd> function, we can modify the handler part, like this:</p>
<div>
<pre>func main() {<br/>    originalHandler := http.HandlerFunc(handle)<br/>    chain := alice.New(filterContentType,<br/>     setServerTimeCookie).Then(originalHandler)<br/>    http.Handle("/city", chain)<br/>    http.ListenAndServe(":8000", nil)<br/>}</pre></div>
<p>The output of this program is similar to the previous one. With the knowledge of the preceding concepts, Let's build a logging middleware with a library from the Gorilla toolkit called <strong>handlers</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Gorilla handlers middleware for logging </h1>
                </header>
            
            <article>
                
<p>The Gorilla handlers package provides various pre-written middleware for common tasks. The most important ones in the list are:</p>
<ul>
<li><kbd>LoggingHandler</kbd>: For logging in Apache <strong>Common Log Format</strong> (<strong>CLF</strong>)</li>
<li><kbd>CompressionHandler</kbd>: For zipping the responses</li>
<li><kbd>RecoveryHandler</kbd>: For recovering from unexpected panics</li>
</ul>
<p>Here, we use the <kbd>LoggingHandler</kbd> middleware to perform API-wide logging. First, install this library using <kbd>go get</kbd>, like this:</p>
<pre><strong>go get "github.com/gorilla/handlers"</strong></pre>
<p>This logging server enables us to create a server-like a log with time and options. For example, when you see <kbd>apache.log</kbd>, you find the log in a standard format, as shown in the following code block:</p>
<pre><strong>192.168.2.20 - - [28/Jul/2006:10:27:10 -0300] "GET /cgi-bin/try/ HTTP/1.0" 200 3395</strong><br/><strong>127.0.0.1 - - [28/Jul/2006:10:22:04 -0300] "GET / HTTP/1.0" 200 2216</strong></pre>
<p>The format is this: <kbd>IP-Date-Method:Endpoint-ResponseStatus</kbd>. Writing our own middleware that mimics Apache-style logging takes some effort, but Gorilla Handlers already implemented one for us. Let's update the previous program in a few ways by creating a new program, like this:</p>
<pre><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/loggingMiddleware/main.go</strong></pre>
<p>Now, Let's write the program, using the following steps:</p>
<ol>
<li>First, we create a <kbd>Gorilla</kbd> router and attach it to the <kbd>LoggingHandler</kbd>. </li>
<li>The <kbd>LoggingHandler</kbd> registers a standard output (Let's say, in our case, <kbd>os.Stdout</kbd>) and returns a new router. We use that new router to register with the HTTP server, as shown in the following code block:</li>
</ol>
<div>
<pre style="padding-left: 60px">package main<br/>import (<br/>    "github.com/gorilla/handlers"<br/>    "github.com/gorilla/mux"<br/>    "log"<br/>    "os"<br/>    "net/http"<br/>)<br/>func handle(w http.ResponseWriter, r *http.Request) {<br/>    log.Println("Processing request!")<br/>    w.Write([]byte("OK"))<br/>    log.Println("Finished processing request")<br/>}<br/>func main() {<br/>    r := mux.NewRouter()<br/>    r.HandleFunc("/", handle)<br/>    loggedRouter := handlers.LoggingHandler(os.Stdout, r)<br/>    http.ListenAndServe(":8000", loggedRouter)<br/>}</pre></div>
<ol start="3">
<li>Start the server by running the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter3/loggingMiddleware/main.go</strong></pre>
<ol start="4">
<li>Now, open <kbd>http://127.0.0.1:8000</kbd> in the browser, or fire a <kbd>curl</kbd> request, and you will see the following output: </li>
</ol>
<pre style="padding-left: 60px"><strong>2017/05/28 10:51:44 Processing request!</strong><br/><strong>2017/05/28 10:51:44 Finished processing request</strong><br/><strong>127.0.0.1 - - [28/May/2017:10:51:44 +0530] "GET / HTTP/1.1" 200 2</strong><br/><strong>127.0.0.1 - - [28/May/2017:10:51:44 +0530] "GET /favicon.ico HTTP/1.1" 404 19</strong></pre>
<p>If you observe, the last two logs are generated by the middleware. Gorilla <kbd>LoggingMiddleware</kbd> writes them at response time.</p>
<p>In the previous example, we always checked the API on the localhost. In this example, we explicitly specified replacing the localhost with <kbd>127.0.0.1</kbd> because the former will show as an empty IP in the logs.</p>
<p>Coming to the program, we are importing the <kbd>gorilla/mux</kbd> router and <kbd>gorilla/handlers</kbd>. Then, we are attaching a handler called <kbd>handle</kbd> to the router. Next, we are wrapping the router in the <kbd>handlers.LoggingHandler</kbd> middleware. It returns one more handler, which we can pass safely to <kbd>http.ListenAndServe</kbd>.</p>
<p>You can try other middleware from handlers, too. This section's goal is to introduce you to <kbd>gorilla/handlers</kbd>. There are many other external packages available for Go. There is one library worth mentioning for writing middleware directly on <kbd>net/http</kbd>. It is <kbd>Negroni</kbd> (<a href="http://github.com/urfave/negroni" target="_blank">github.com/urfave/negroni</a>). It also provides the functionality of <kbd>alice</kbd>, the Gorilla <kbd>LoggingHandler</kbd>. So, please have a look at it.</p>
<p>We can easily build cookie-based authentication middleware, using a library called <kbd>go.uuid</kbd> (<a href="http://github.com/satori/go.uuid" target="_blank">github.com/satori/go.uuid</a>) and cookies.</p>
<p>Systems talk to each other using web services. A client API can be powered by multiple server instances. RPC is a mechanism to delegate work to a remote server in an understandable fashion. RPC is an important concept in Go because it can play a part in supporting a REST service served to a client. The Gorilla toolkit provides packages to support RPC. We will understand it in detail in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is RPC?</h1>
                </header>
            
            <article>
                
<p>RPC is an inter-process communication that exchanges information between various distributed systems. A computer called Alice can call functions (procedures) in another computer called Bob in protocol format and can get the computed result back. Without implementing the functionality locally, we can request things from a network that lies in another place or geographical region.</p>
<p>The entire process can be broken down into the following steps:</p>
<ol>
<li>Clients prepare function name and arguments to send</li>
<li>Clients send them to an RPC server by dialing the connection</li>
<li>The server receives the function name and arguments</li>
<li>The server executes the remote process</li>
<li>The message will be sent back to the client</li>
<li>The client collects the data from the request and uses it appropriately</li>
</ol>
<p>The server needs to expose its service for the client to connect and request a remote procedure. Take a look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/4b91c8df-db63-4b11-8015-78ecebb0859e.png" style="width:31.42em;height:13.42em;"/></div>
<p>Go provides a library to implement both the <strong>RPC Server</strong> and <strong>RPC Client</strong>. In the preceding diagram, the <strong>RPC Client</strong> dials the connection with details such as the host and port. It sends two things along with the request. One is arguments, and the other is the reply pointer. Since it is a pointer, the server can modify it and send it back. Then, the client can use the data filled into the pointer. Go has two libraries, <kbd>net/rpc</kbd> and <kbd>net/rpc/jsonrpc</kbd>, for working with RPC. Let's write an RPC server that talks to the client and sends the server time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an RPC server</h1>
                </header>
            
            <article>
                
<p>Let's create a simple RPC server that sends the UTC server time back to the RPC client. The RPC server and RPC client should agree upon two things:</p>
<ul>
<li>Arguments passed</li>
<li>Value returned</li>
</ul>
<p>The types of these two parameters should match <span>exactly </span>for both server and client. Let's look at the steps for creating an RPC server, as follows: </p>
<ol>
<li>Let's create an RPC server program, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/rpcServer/main.go</strong></pre>
<ol start="2">
<li>We should create an <kbd>Args struct</kbd> and a reply pointer to hold data for RPC calls.</li>
<li>Then, create a function for a remote client to execute, and name it <kbd>GiveServerTime</kbd>, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">type Args struct{}<br/><br/>type TimeServer int64<br/><br/>func (t *TimeServer) GiveServerTime(args *Args, reply *int64) error {<br/>  // Fill reply pointer to send the data back<br/>  *reply = time.Now().Unix()<br/>  return nil<br/>}</pre>
<ol start="4">
<li>Now, we can activate <kbd>TimeServer</kbd> with a method called <kbd>rpc.Register</kbd>. The main logic looks like this:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "log"<br/>  "net"<br/>  "net/http"<br/>  "net/rpc"<br/>  "time"<br/>)<br/><br/>func main() {<br/>  timeserver := new(TimeServer)<br/>  rpc.Register(timeserver)<br/>  rpc.HandleHTTP()<br/>  // Listen for requests on port 1234<br/>  l, e := net.Listen("tcp", ":1234")<br/>  if e != nil {<br/>    log.Fatal("listen error:", e)<br/>  }<br/>  http.Serve(l, nil)<br/>}</pre>
<p>There are a few points to note from the preceding example:</p>
<ul>
<li><kbd>GiveServerTime</kbd> takes the <kbd>Args</kbd> object as the first argument and a reply pointer object</li>
<li>It sets the reply pointer object but does not return anything except an error</li>
<li>The <kbd>Args</kbd> struct here has no fields because this server is not expecting any arguments from clients</li>
</ul>
<p>Before using this RPC server, Let's write the RPC client, too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an RPC client</h1>
                </header>
            
            <article>
                
<p>A client also uses the same <kbd>net/rpc</kbd> package, but different methods to dial to the server and get the remote function executed. The only way to get data back is to pass the reply pointer object along with the request. Let's look at the steps for creating an RPC client, as follows:</p>
<ol start="1">
<li>Let's define that client program, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/rpcClient/main.go</strong></pre>
<ol start="2">
<li>A client dials to an RPC server, using the <kbd>rpc.DialHTTP</kbd> method. It returns a <kbd>client</kbd> object. Once dial-in is successful, it can then execute a remote function using the <kbd>client.Call</kbd> method, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">package main<br/>import (<br/>    "log"<br/>    "net/rpc"<br/>)<br/>type Args struct {<br/>}<br/>func main() {<br/>    var reply int64<br/>    args := Args{}<br/>    client, err := rpc.DialHTTP("tcp", "localhost"+":1234")<br/>    if err != nil {<br/>        log.Fatal("dialing:", err)<br/>    }<br/>    err = client.Call("TimeServer.GiveServerTime",<br/>     args, &amp;reply)<br/>    if err != nil {<br/>        log.Fatal("arith error:", err)<br/>    }<br/>    log.Printf("%d", reply)}</pre>
<ol start="3">
<li>Now, we can run both the server and client to see them in action. <span>This runs the server, like this</span>:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter3/rpcServer/main.go</strong></pre>
<ol start="4">
<li>Now, open another shell tab and run this, like so:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter3/rpcClient/main.go</strong></pre>
<p style="padding-left: 60px">Now, the server console will output the following Unix time string:</p>
<pre style="padding-left: 60px"><strong>2017/05/28 19:26:31 1495979791</strong></pre>
<p>Did you see the magic? The client is running as an independent program from the server. Here, both the programs can be on different machines, and computing can still be shared. This is the core concept of distributed systems. The tasks are divided and given to various RPC servers. Finally, the client collects the results and uses them to take further decisions.</p>
<div class="packt_infobox">RPC should be secured because it is executing the remote functions. Authorization is a must while collecting requests from the client.</div>
<p><span>Custom RPC code is only useful when the client and server are both written in Go. So, in order to have the RPC server consumed by multiple services, we need to define the JSON-RPC over HTTP. Then, any other programming language can send a JSON string and get JSON as the result back.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON-RPC using Gorilla RPC</h1>
                </header>
            
            <article>
                
<p>We saw that the Gorilla toolkit helps us by providing many useful libraries. It has libraries such as Mux for routing, Handlers for middleware, and now, the <kbd>gorilla/rpc</kbd> library. Using this, we can create RPC servers and clients that talk using JSON instead of a custom reply pointer. Let's convert the preceding example into a much more useful one.</p>
<p>Consider this scenario. We have a JSON file on the server that has details of books (name, ID, author). The client requests book information by making an HTTP request. When the RPC server receives the request, it reads the file from the filesystem and parses it. If the given ID matches any book, then the server sends the information back to the client in JSON format. Let's look at the steps here: </p>
<ol>
<li>We can install Gorilla RPC with the <kbd>go get</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>go get github.com/gorilla/rpc</strong></pre>
<p style="padding-left: 60px">This package derives from the standard <kbd>net/rpc</kbd> package but uses a single HTTP request per call instead of persistent connections. Other differences compared to <kbd>net/rpc</kbd> are explained in the next few lines. Multiple codecs can be registered on the same server. A codec is chosen based on the <kbd>Content-Type</kbd> header from the request. Service methods also receive the <kbd>http.Request</kbd> as a parameter.</p>
<ol start="2">
<li class="mce-root">Now, Let's write an RPC JSON server. Here, we are implementing the JSON 1.0 specification. For 2.0, you should use Gorilla JSON2. Let's define a dummy JSON file that has information on <span>books, like this:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/jsonRPCServer/books.json</strong></pre>
<ol start="3">
<li>Let's us add a few books to the JSON file, like so:</li>
</ol>
<pre style="padding-left: 60px">[<br/>  {<br/>    "id": "1234",<br/>    "name": "In the sunburned country",<br/>    "author": "Bill Bryson"<br/>  },<br/>  {<br/>    "id":"2345",<br/>    "name": "The picture of Dorian Gray",<br/>    "author": "Oscar Wilde"<br/>  }<br/>]</pre>
<ol start="4">
<li>Now, we have a book database file (JSON, in this case). Let's us write the RPC server similar to the previous example, by running the following code:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter3/jsonRPCServer/main.go<br/></strong></pre>
<ol start="5">
<li>The process is to define a struct to hold types for a book. Then, create a <kbd>JSONServer</kbd> struct for registering with the RPC Server. It should have a method as an RPC action. Read the JSON file from the given file using the <kbd>filepath</kbd> built-in utility function. The <kbd>reply</kbd> argument of <kbd>JSONServer</kbd> is filled with the matched book information, as shown in the following code block:</li>
</ol>
<div>
<pre style="padding-left: 60px">// Args holds arguments passed to JSON-RPC service<br/>type Args struct {<br/>  ID string<br/>}<br/><br/>// Book struct holds Book JSON structure<br/>type Book struct {<br/>  ID string `json:"id,omitempty"`<br/>  Name string `json:"name,omitempty"`<br/>  Author string `json:"author,omitempty"`<br/>}<br/><br/>type JSONServer struct{}<br/><br/>// GiveBookDetail is RPC implementation<br/>func (t *JSONServer) GiveBookDetail(r *http.Request, args *Args, reply *Book) error {<br/>  var books []Book<br/>  // Read JSON file and load data<br/>  absPath, _ := filepath.Abs("chapter3/books.json")<br/>  raw, readerr := ioutil.ReadFile(absPath)<br/>  if readerr != nil {<br/>    log.Println("error:", readerr)<br/>    os.Exit(1)<br/>  }<br/>  // Unmarshal JSON raw data into books array<br/>  marshalerr := jsonparse.Unmarshal(raw, &amp;books)<br/>  if marshalerr != nil {<br/>    log.Println("error:", marshalerr)<br/>    os.Exit(1)<br/>  }<br/>  // Iterate over each book to find the given book<br/>  for _, book := range books {<br/>    if book.ID == args.ID {<br/>      // If book found, fill reply with it<br/>      *reply = book<br/>      break<br/>    }<br/>  }<br/>  return nil<br/>}</pre></div>
<p style="padding-left: 60px">It looks similar to the last example, but a clear difference is that the server here expects an ID from the client. That ID is a key to fetch the book from JSON. In <kbd>GiveBookDetail</kbd>, we are using <kbd>ioutil.ReadFile</kbd> to read file content and unmarshal it into the <kbd>books</kbd> struct. We then iterate over a list of books to match the key and fill the <kbd>reply</kbd> pointer with the matched book.</p>
<ol start="6">
<li>Now, Let's us finish the <kbd>main</kbd> block, which registers the <kbd>JSONServer</kbd> defined previously as an RPC service, like this:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  jsonparse "encoding/json"<br/>  "io/ioutil"<br/>  "log"<br/>  "net/http"<br/>  "os"<br/><br/>  "path/filepath"<br/><br/>  "github.com/gorilla/mux"<br/>  "github.com/gorilla/rpc"<br/>  "github.com/gorilla/rpc/json"<br/>)<br/><br/>func main() {<br/>  // Create a new RPC server<br/>  s := rpc.NewServer()<br/>  // Register the type of data requested as JSON<br/>  s.RegisterCodec(json.NewCodec(), "application/json")<br/>  // Register the service by creating a new JSON server<br/>  s.RegisterService(new(JSONServer), "")<br/>  r := mux.NewRouter()<br/>  r.Handle("/rpc", s)<br/>  http.ListenAndServe(":1234", r)<br/><br/>}</pre>
<p style="padding-left: 60px">A slight difference here is we have to register codec type using the <kbd>RegisterCodec</kbd> method. That is JSON codec in this case. Then, we can register the service using the <kbd>RegisterService</kbd> method and start a normal HTTP server. If you have noticed well, we used the alias <kbd>jsonparse</kbd> for the <kbd>encoding/json</kbd> package because it can conflict with another package, <kbd>github.com/gorilla/rpc/json</kbd>. </p>
<ol start="7">
<li>We can start this <kbd>jsonRPCServer</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter3/jsonRPCServer/main.go</strong></pre>
<ol start="8">
<li>Now, do we have to develop a client? Not necessarily, because a client can be a <kbd><span>curl</span></kbd> program since the RPC server is serving requests over HTTP, we need to post JSON with a book ID to get the details. So, fire up another shell and execute this <kbd>curl</kbd> request:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X POST \</strong><br/><strong>   http://localhost:1234/rpc \</strong><br/><strong>   -H 'cache-control: no-cache' \</strong><br/><strong>   -H 'content-type: application/json' \</strong><br/><strong>   -d '{</strong><br/><strong>   "method": "JSONServer.GiveBookDetail",</strong><br/><strong>   "params": [{</strong><br/><strong>   "ID": "1234"</strong><br/><strong>   }],</strong><br/><strong>   "id": "1"</strong><br/><strong>}'</strong></pre>
<ol start="9">
<li>The output will be nice JSON that is served directly from the JSON-RPC server, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>{"result":{"id":"1234","name":"In the sunburned country","author":"Bill Bryson"},"error":null,"id":"1"}</strong></pre>
<div class="packt_tip">Make JSON-RPC your preferred choice when multiple client technologies need to connect to your RPC service.</div>
<p>RPC is a very common way of defining typed services in programming languages. The Gorilla toolkit is a very useful package while working with Go. When a REST JSON API needs to be provided, you can go ahead and use JSON-RPC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we first looked into what middleware is and how middleware processes a request and response. We then explored the middleware code, with a few practical examples. After that, we saw how to chain many middleware, one after the other. A package such as <kbd>alice</kbd> can be used for intuitive chaining. A package from the Gorilla toolkit, <kbd>gorilla/handlers</kbd>, provides various middleware for logging, compression, and <strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>).</p>
<p>Next, we learned what an RPC is, and how an RPC server and client can be built. After that, we explained what a JSON-RPC is, and we saw how to create a JSON-RPC using the Gorilla toolkit. We introduced many third-party packages for middleware and RPC along the way.</p>
<p>In the next chapter, we are going to explore a few famous web frameworks that further simplify REST API creation.</p>
<div class="content-3WfBL_0" style="background-color: #ffffff">
<div class="outputBox-qe9A4_0">
<div class="outputBox-3oESn_0"><span class="outputBox-13Ovx_0"> </span></div>
<div class="outputBox-17RAm_0"/>
</div>
</div>


            </article>

            
        </section>
    </body></html>