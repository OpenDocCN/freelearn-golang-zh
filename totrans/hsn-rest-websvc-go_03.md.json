["```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/closureExample/main.go\n```", "```go\n// This function returns another function\nfunc generator() func() int { // Outer function\n   var i = 0\n    return func() int { // Inner function\n        i++\n        return i\n    }\n}\n```", "```go\npackage main\n\nimport (\n  \"fmt\"\n)\n\n...\nfunc main() {\n  numGenerator := generator()\n  for i := 0; i < 5; i++ {\n    fmt.Print(numGenerator(), \"\\t\")\n  }\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter3/closureExample/main.go\n```", "```go\n1 2 3 4 5\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/customMiddleware/main.go\n```", "```go\nfunc middleware(originalHandler http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, \n    r *http.Request) {\n        fmt.Println(\"Executing middleware before request phase!\")\n        // Pass control back to the handler\n        originalHandler.ServeHTTP(w, r)\n        fmt.Println(\"Executing middleware after response phase!\")\n    })\n}\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handle(w http.ResponseWriter, r *http.Request) {\n    // Business logic goes here\n    fmt.Println(\"Executing mainHandler...\")\n    w.Write([]byte(\"OK\"))\n}\nfunc main() {\n    // HandlerFunc returns a HTTP Handler\n    originalHandler := http.HandlerFunc(handle)\n    http.Handle(\"/\", middleware(originalHandler))\n    http.ListenAndServe(\":8000\", nil)\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter3/customMiddleware/main.go\n```", "```go\nExecuting middleware before request phase!\nExecuting mainHandler...\nExecuting middleware after response phase!\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/cityAPI/main.go\n```", "```go\ntype city struct {\n  Name string\n  Area uint64\n}\n\nfunc postHandler(w http.ResponseWriter, r *http.Request) {\n  if r.Method == \"POST\" {\n    var tempCity city\n    decoder := json.NewDecoder(r.Body)\n    err := decoder.Decode(&tempCity)\n    if err != nil {\n      panic(err)\n    }\n    defer r.Body.Close()\n    fmt.Printf(\"Got %s city with area of %d sq miles!\\n\",\n     tempCity.Name, tempCity.Area)\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(\"201 - Created\"))\n  } else {\n    w.WriteHeader(http.StatusMethodNotAllowed)\n    w.Write([]byte(\"405 - Method Not Allowed\"))\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"encoding/json\"\n  \"fmt\"\n  \"net/http\"\n)\n\nfunc main() {\n  http.HandleFunc(\"/city\", postHandler)\n  http.ListenAndServe(\":8000\", nil)\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter3/cityAPI/main.go\n```", "```go\ncurl -H \"Content-Type: application/json\" -X POST http://localhost:8000/city -d '{\"name\":\"New York\", \"area\":304}'\n\ncurl -H \"Content-Type: application/json\" -X POST http://localhost:8000/city -d '{\"name\":\"Boston\", \"area\":89}'\n```", "```go\nGot New York city with area of 304 sq miles!\nGot Boston city with area of 89 sq miles!\n```", "```go\n201 - Created\n201 - Created\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/multipleMiddleware/main.go\n```", "```go\nfunc filterContentType(handler http.Handler) http.Handler {\n return http.HandlerFunc(func(w http.ResponseWriter,\n  r *http.Request) {\n log.Println(\"Currently in the check content type middleware\")\n // Filtering requests by MIME type\n if r.Header.Get(\"Content-type\") != \"application/json\" {\n w.WriteHeader(http.StatusUnsupportedMediaType)\n w.Write([]byte(\"415 - Unsupported Media Type. Please send JSON\"))\n return\n }\n handler.ServeHTTP(w, r)\n })\n}\n```", "```go\nfunc setServerTimeCookie(handler http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter,\n  r *http.Request) {\n    handler.ServeHTTP(w, r)\n    // Setting cookie to every API response\n    cookie := http.Cookie{Name: \"Server-Time(UTC)\", \n     Value: strconv.FormatInt(time.Now().Unix(), 10)}\n    http.SetCookie(w, &cookie)\n    log.Println(\"Currently in the set server time middleware\")\n  })\n}\n```", "```go\nfunc main() {\n  originalHandler := http.HandlerFunc(handle)\n  http.Handle(\"/city\", \n   filterContentType(setServerTimeCookie(originalHandler)))\n  http.ListenAndServe(\":8000\", nil)\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter3/multipleMiddleware/main.go\n```", "```go\ncurl -i -H \"Content-Type: application/json\" -X POST http://localhost:8000/city -d '{\"name\":\"Boston\", \"area\":89}'\n```", "```go\nHTTP/1.1 200 OK\nDate: Sat, 27 May 2017 14:35:46 GMT\nContent-Length: 13\nContent-Type: text/plain; charset=utf-8\n\n201 - Created\n```", "```go\ncurl -i -X POST http://localhost:8000/city -d '{\"name\":\"New York\", \"area\":304}'\n\nResult:HTTP/1.1 415 Unsupported Media Type\nDate: Sat, 27 May 2017 15:36:58 GMT\nContent-Length: 46\nContent-Type: text/plain; charset=utf-8\n\n415 - Unsupported Media Type. Please send JSON\n```", "```go\ngo get github.com/justinas/alice\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/multipleMiddlewareWithAlice/main.go\n```", "```go\nimport (\n    \"encoding/json\"\n    \"github.com/justinas/alice\"\n    \"log\"\n    \"net/http\"\n    \"strconv\"\n    \"time\"\n)\n```", "```go\nfunc main() {\n    originalHandler := http.HandlerFunc(handle)\n    chain := alice.New(filterContentType,\n     setServerTimeCookie).Then(originalHandler)\n    http.Handle(\"/city\", chain)\n    http.ListenAndServe(\":8000\", nil)\n}\n```", "```go\ngo get \"github.com/gorilla/handlers\"\n```", "```go\n192.168.2.20 - - [28/Jul/2006:10:27:10 -0300] \"GET /cgi-bin/try/ HTTP/1.0\" 200 3395\n127.0.0.1 - - [28/Jul/2006:10:22:04 -0300] \"GET / HTTP/1.0\" 200 2216\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/loggingMiddleware/main.go\n```", "```go\npackage main\nimport (\n    \"github.com/gorilla/handlers\"\n    \"github.com/gorilla/mux\"\n    \"log\"\n    \"os\"\n    \"net/http\"\n)\nfunc handle(w http.ResponseWriter, r *http.Request) {\n    log.Println(\"Processing request!\")\n    w.Write([]byte(\"OK\"))\n    log.Println(\"Finished processing request\")\n}\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/\", handle)\n    loggedRouter := handlers.LoggingHandler(os.Stdout, r)\n    http.ListenAndServe(\":8000\", loggedRouter)\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter3/loggingMiddleware/main.go\n```", "```go\n2017/05/28 10:51:44 Processing request!\n2017/05/28 10:51:44 Finished processing request\n127.0.0.1 - - [28/May/2017:10:51:44 +0530] \"GET / HTTP/1.1\" 200 2\n127.0.0.1 - - [28/May/2017:10:51:44 +0530] \"GET /favicon.ico HTTP/1.1\" 404 19\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/rpcServer/main.go\n```", "```go\ntype Args struct{}\n\ntype TimeServer int64\n\nfunc (t *TimeServer) GiveServerTime(args *Args, reply *int64) error {\n  // Fill reply pointer to send the data back\n  *reply = time.Now().Unix()\n  return nil\n}\n```", "```go\npackage main\n\nimport (\n  \"log\"\n  \"net\"\n  \"net/http\"\n  \"net/rpc\"\n  \"time\"\n)\n\nfunc main() {\n  timeserver := new(TimeServer)\n  rpc.Register(timeserver)\n  rpc.HandleHTTP()\n  // Listen for requests on port 1234\n  l, e := net.Listen(\"tcp\", \":1234\")\n  if e != nil {\n    log.Fatal(\"listen error:\", e)\n  }\n  http.Serve(l, nil)\n}\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/rpcClient/main.go\n```", "```go\npackage main\nimport (\n    \"log\"\n    \"net/rpc\"\n)\ntype Args struct {\n}\nfunc main() {\n    var reply int64\n    args := Args{}\n    client, err := rpc.DialHTTP(\"tcp\", \"localhost\"+\":1234\")\n    if err != nil {\n        log.Fatal(\"dialing:\", err)\n    }\n    err = client.Call(\"TimeServer.GiveServerTime\",\n     args, &reply)\n    if err != nil {\n        log.Fatal(\"arith error:\", err)\n    }\n    log.Printf(\"%d\", reply)}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter3/rpcServer/main.go\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter3/rpcClient/main.go\n```", "```go\n2017/05/28 19:26:31 1495979791\n```", "```go\ngo get github.com/gorilla/rpc\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/jsonRPCServer/books.json\n```", "```go\n[\n  {\n    \"id\": \"1234\",\n    \"name\": \"In the sunburned country\",\n    \"author\": \"Bill Bryson\"\n  },\n  {\n    \"id\":\"2345\",\n    \"name\": \"The picture of Dorian Gray\",\n    \"author\": \"Oscar Wilde\"\n  }\n]\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter3/jsonRPCServer/main.go \n```", "```go\n// Args holds arguments passed to JSON-RPC service\ntype Args struct {\n  ID string\n}\n\n// Book struct holds Book JSON structure\ntype Book struct {\n  ID string `json:\"id,omitempty\"`\n  Name string `json:\"name,omitempty\"`\n  Author string `json:\"author,omitempty\"`\n}\n\ntype JSONServer struct{}\n\n// GiveBookDetail is RPC implementation\nfunc (t *JSONServer) GiveBookDetail(r *http.Request, args *Args, reply *Book) error {\n  var books []Book\n  // Read JSON file and load data\n  absPath, _ := filepath.Abs(\"chapter3/books.json\")\n  raw, readerr := ioutil.ReadFile(absPath)\n  if readerr != nil {\n    log.Println(\"error:\", readerr)\n    os.Exit(1)\n  }\n  // Unmarshal JSON raw data into books array\n  marshalerr := jsonparse.Unmarshal(raw, &books)\n  if marshalerr != nil {\n    log.Println(\"error:\", marshalerr)\n    os.Exit(1)\n  }\n  // Iterate over each book to find the given book\n  for _, book := range books {\n    if book.ID == args.ID {\n      // If book found, fill reply with it\n      *reply = book\n      break\n    }\n  }\n  return nil\n}\n```", "```go\npackage main\n\nimport (\n  jsonparse \"encoding/json\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n  \"os\"\n\n  \"path/filepath\"\n\n  \"github.com/gorilla/mux\"\n  \"github.com/gorilla/rpc\"\n  \"github.com/gorilla/rpc/json\"\n)\n\nfunc main() {\n  // Create a new RPC server\n  s := rpc.NewServer()\n  // Register the type of data requested as JSON\n  s.RegisterCodec(json.NewCodec(), \"application/json\")\n  // Register the service by creating a new JSON server\n  s.RegisterService(new(JSONServer), \"\")\n  r := mux.NewRouter()\n  r.Handle(\"/rpc\", s)\n  http.ListenAndServe(\":1234\", r)\n\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter3/jsonRPCServer/main.go\n```", "```go\ncurl -X POST \\\n http://localhost:1234/rpc \\\n -H 'cache-control: no-cache' \\\n -H 'content-type: application/json' \\\n -d '{\n \"method\": \"JSONServer.GiveBookDetail\",\n \"params\": [{\n \"ID\": \"1234\"\n }],\n \"id\": \"1\"\n}'\n```", "```go\n{\"result\":{\"id\":\"1234\",\"name\":\"In the sunburned country\",\"author\":\"Bill Bryson\"},\"error\":null,\"id\":\"1\"}\n```"]