- en: Working with Middleware and RPC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与中间件和RPC一起工作
- en: In this chapter, we are going to look at two new concepts. First, we will learn
    about middleware, and how can we build one from scratch. Then, we will move to
    a better middleware solution written by the community, called **Gorilla handlers**.
    We will then see the use cases where middleware is helpful. After that, we will
    learn about developing **Remote Procedure Call **(**RPC**) services with Go's
    internal RPC and JSON-RPC. Then, we will move to an advanced RPC framework called
    Gorilla HTTP RPC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两个新的概念。首先，我们将学习中间件，以及如何从头开始构建它。然后，我们将转向社区编写的一个更好的中间件解决方案，称为**Gorilla处理器**。然后，我们将看到中间件有帮助的使用案例。之后，我们将学习使用Go的内部RPC和JSON-RPC开发**远程过程调用（RPC**）服务。然后，我们将转向一个名为Gorilla
    HTTP RPC的高级RPC框架。
- en: 'The topics we cover in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的主题如下：
- en: What is middleware?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是中间件？
- en: Multiple middleware and chaining
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个中间件和链式调用
- en: Painless middleware chaining with `alice`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`alice`轻松实现中间件链式调用
- en: Using Gorilla handlers middleware for logging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gorilla处理器中间件进行日志记录
- en: What is RPC?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPC是什么？
- en: JSON-RPC using Gorilla RPC
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gorilla RPC进行JSON-RPC
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software should be pre-installed for running code samples:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下软件应预先安装以运行代码示例：
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X >= 10.13'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux（Ubuntu 18.04）/Windows 10/Mac OS X >= 10.13
- en: 'Software: Docker >= 18 (Docker Desktop for Windows and Mac OS X)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件：Docker >= 18（适用于Windows和Mac OS X的Docker Desktop）
- en: Go latest version compiler >= 1.13.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go最新版本编译器 >= 1.13.5
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter3](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter3).
    Clone the code and use the code samples in the `chapter3` directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter3](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter3)下载本章的代码。克隆代码并使用`chapter3`目录中的代码示例。
- en: What is middleware?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是中间件？
- en: '**Middleware** is an entity that hooks into a server''s request/response life
    cycle. The middleware can be defined in many components. Each component has a
    specific function to perform. Whenever we define handlers for URL patterns (as
    in [Chapter 2](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml), *Handling Routing
    for our REST Services*), a handler executes some business logic for every incoming
    request. But middleware, as the name specifies, sits between a request and the
    handler, or between a handler and a response. So, virtually every middleware can
    perform these functions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**中间件**是一个实体，它可以钩入服务器的请求/响应生命周期。中间件可以定义在许多组件中。每个组件都有特定的功能来执行。每当我们在URL模式（如[第2章](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml)，*处理我们的REST服务路由*）中定义处理器时，处理器就会为每个传入的请求执行一些业务逻辑。但是，正如其名称所指定的，中间件位于请求和处理器之间，或者位于处理器和响应之间。因此，几乎每个中间件都可以执行以下功能：'
- en: Process the request before reaching the handler (function)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在到达处理器（函数）之前处理请求
- en: Pass the modified request to the handler function (execute some business logic)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将修改后的请求传递给处理器函数（执行一些业务逻辑）
- en: Process the response coming from the handler
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理来自处理器的响应
- en: Pass the modified response to the client
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将修改后的响应传递给客户端
- en: 'We can see the previous points in the form of a visual illustration, as shown
    in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的点以以下图表的形式进行视觉说明：
- en: '![](img/f03d6714-7a81-4d67-9eee-8d03e3c4fc0c.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f03d6714-7a81-4d67-9eee-8d03e3c4fc0c.png)'
- en: If we observe the diagram carefully, the journey of a request starts from the
    client. The request first reaches a middleware called **AUTH MIDDLEWARE** and
    is then forwarded to a **FUNCTION HANDLER**. Once a response is generated from
    a handler, it is then forwarded to another middleware called **CUSTOM MIDDLEWARE** that
    can modify the response.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察图表，请求的旅程是从客户端开始的。请求首先到达一个名为**AUTH MIDDLEWARE**的中间件，然后被转发到**FUNCTION
    HANDLER**。一旦处理器生成响应，它就会被转发到另一个名为**CUSTOM MIDDLEWARE**的中间件，该中间件可以修改响应。
- en: 'In an application with no middleware, a request reaches the API server and
    gets handled by a function handler directly. The response is immediately sent
    back from the server, and the client receives it. But in applications with middleware
    configured to a function handler, it can pass through a set of stages, such as
    logging, authentication, session validation, and so on, and then proceeds to the
    business logic. This is to filter the requests from interacting with the business
    logic. The most common use cases are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有中间件的程序中，请求直接到达API服务器并由函数处理器处理。响应立即从服务器发送，客户端接收它。但在配置了中间件到函数处理器的程序中，它可以通过一系列阶段，如记录、认证、会话验证等，然后继续到业务逻辑。这是为了过滤请求与业务逻辑的交互。最常见的情况如下：
- en: Use a logger to log each and every request for a REST API
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录器记录每个REST API的请求
- en: Validate the session of the user and keep the communication alive
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户的会话并保持通信活跃
- en: Authenticate the user, if not identified
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未识别，则验证用户
- en: Attach properties to responses while serving the client
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务客户端时附加属性到响应
- en: With the help of middleware, we can do any housekeeping work, such as authentication,
    in its proper place. Let's create a basic middleware and tamper an HTTP request
    in Go.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过中间件的帮助，我们可以在适当的位置执行任何家务工作，例如认证。让我们创建一个基本的中间件并在Go中篡改HTTP请求。
- en: Middleware functions can be handy when many function handlers have the same
    business logic to execute.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多函数处理器有相同业务逻辑要执行时，中间件函数很有用。
- en: Creating a basic middleware
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的中间件
- en: 'Building middleware functions is simple and straightforward. Let''s build a
    program based on the knowledge gained from [Chapter 2](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml),
    *Handling Routing for our REST Services*. If you are not familiar with closure
    functions, a closure function returns another function. This principle helps us
    write middleware. A middleware should return another function, which can be either
    a middleware or a function handler. It is similar to JavaScript chain methods,
    whereby one function returns a new function as a return value. Let''s create a
    closure function in Go, by doing the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 构建中间件函数既简单又直接。让我们基于从[第2章](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml)《处理我们的REST服务路由》中获得的知识构建一个程序。如果你不熟悉闭包函数，闭包函数返回另一个函数。这个原则帮助我们编写中间件。一个中间件应该返回另一个函数，这个函数可以是中间件或函数处理器。这类似于JavaScript链式方法，其中一个函数返回一个新的函数作为返回值。让我们在Go中通过以下方式创建一个闭包函数：
- en: 'Create a program file, like so:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个程序文件，如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use this file to add our code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此文件添加我们的代码。
- en: 'A closure function returns another function. Let''s create a closure function
    that generates positive integers, using the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闭包函数返回另一个函数。让我们创建一个闭包函数，该函数使用以下代码生成正整数：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The function is a generator that returns a sequence of integers. A generator
    pattern generates a new item each time, based on given conditions. The inner function
    is returning an anonymous function with no arguments and one return type of integer.
    The `i` variable that is defined inside the outer function is available to the
    anonymous function, making it remember the state between upcoming function calls.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个生成器，它返回一系列整数。生成器模式根据给定的条件每次生成一个新项目。内部函数返回一个无参数的匿名函数，返回类型为整数。在外部函数内部定义的`i`变量对匿名函数可用，使其能够在即将到来的函数调用之间记住状态。
- en: 'Now, we can use the previous generator in our `main` program, like this:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的`main`程序中使用之前的生成器，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can run the previous code as a standalone program, as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将之前的代码作为一个独立的程序运行，如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following numbers will be generated and printed using *Tab* spaces:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数字将使用*制表符*空格生成并打印：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Go, the function signature of the outer function should exactly match the
    anonymous function's signature. In the previous example, `func() int` is the signature
    for both the outer and inner functions. The only exception is that the outer function
    can have an interface as a return type, and the inner function can implement that
    interface. We will see how in the next few lines.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，外部函数的函数签名应该与匿名函数的签名完全匹配。在上一个例子中，`func() int`是外部和内部函数的签名。唯一的例外是外部函数可以有一个接口作为返回类型，而内部函数可以实现该接口。我们将在接下来的几行中看到这一点。
- en: 'Now, coming to how closures help to build a middleware: any generator function
    that can return another function that satisfies the `http.Handler` interface can
    be a middleware. Let''s validate this statement with an example, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看闭包如何帮助构建中间件：任何可以返回满足`http.Handler`接口的另一个函数的生成器函数都可以作为中间件。以下是一个示例，以验证这个陈述：
- en: 'Create a file for our program, like this:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的程序创建一个文件，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The middleware takes a normal HTTP handler function as its argument and returns
    another handler function. The function looks like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件接受一个正常的HTTP处理器函数作为其参数，并返回另一个处理器函数。该函数看起来像这样：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you notice the preceding middleware function, it is taking `originalHandler`,
    an HTTP handler, as its argument, and is returning another HTTP handler. The inner
    function is using the original handler to execute the logic. Before and after
    that handler is where the middleware operates on request and response objects.
    This makes all the requests coming to the main handler pass through the middleware
    logic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意前面的中间件函数，它接受`originalHandler`，一个HTTP处理器，作为其参数，并返回另一个HTTP处理器。内部函数使用原始处理器来执行逻辑。在处理器之前和之后是中间件对请求和响应对象进行操作的地方。这使得所有发送到主处理器的请求都通过中间件逻辑。
- en: 'Now, Let''s define the main logic that uses the middleware function we have
    created, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义使用我们创建的中间件函数的主要逻辑，如下所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the code, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you do a `curl` request to—or visit— `http://localhost:8000` in your browser,
    the console will receive this message:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用`curl`请求或在浏览器中访问`http://localhost:8000`，控制台将收到以下消息：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This program is denoted by the rectangle block to the right in the preceding
    diagram, with the label CUSTOM MIDDLEWARE. If you observe the middleware visual
    illustration provided previously, the request phase direction is to the right,
    and the response direction is to the left.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，该程序由右侧的矩形块表示，标签为CUSTOM MIDDLEWARE。如果你观察之前提供的中间件视觉说明，请求阶段的方向是向右，响应方向是向左。
- en: Go web frameworks such as Martini and Gin provide middleware by default. We
    will see more about them in [Chapter 4](08db4c3a-536c-4f0c-bedc-fcb802c3306a.xhtml),
    *Simplifying RESTful Services with Popular Go Frameworks*. It is good for a developer
    to understand the low-level details of middleware.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Go网络框架，如Martini和Gin，默认提供中间件。我们将在第4章中了解更多关于它们的信息，*使用流行的Go框架简化RESTful服务*。了解中间件的底层细节对开发者来说是有益的。
- en: 'The following diagram can help you understand how the logic flow happens in
    the middleware. This diagram explains how a handler is converted into a wrapper
    handler:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表可以帮助你理解中间件中逻辑流程是如何发生的。此图表解释了处理器是如何转换为包装处理器的：
- en: '![](img/1c61bcf5-1477-48f3-901c-b6e36548941b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c61bcf5-1477-48f3-901c-b6e36548941b.png)'
- en: We have seen the creation of a simple middleware, but in a real scenario, multiple
    middleware are required to log requests, authenticate, and so on. In the next
    section, we will see how to chain multiple middleware.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了简单中间件的创建，但在实际场景中，需要多个中间件来记录请求、进行身份验证等。在下一节中，我们将看到如何链式连接多个中间件。
- en: Multiple middleware and chaining
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个中间件和链式连接
- en: 'In the previous section, we built a single middleware to perform an action
    before or after a request hits the handler. It is also possible to chain a group
    of middleware. In order to do that, we should follow the same closure logic as
    in the preceding section. Let''s create a `cityAPI` program for saving city details.
    For simplicity''s sake, the API will have one `POST` method, and the body will
    consist of two fields: city name and city area.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了一个单个中间件，在请求击中处理器之前或之后执行操作。也可以链式连接一组中间件。为了做到这一点，我们应该遵循上一节中相同的闭包逻辑。让我们创建一个`cityAPI`程序来保存城市详情。为了简单起见，该API将有一个`POST`方法，并且正文将包含两个字段：城市名称和城市面积。
- en: Let's us think about a scenario where a client is only allowed to send a JSON
    `Content-Type` request to an API. The main function of the API is to send a response
    to the client with a UTC timestamp cookie attached to it. We can add that content
    check in the middleware.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，即客户端只能向API发送JSON `Content-Type`请求。API的主要功能是向客户端发送响应，并附加UTC时间戳cookie。我们可以在中间件中添加这个内容检查。
- en: 'The functions of the two middleware are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 两个中间件的功能如下：
- en: In the first middleware, check whether the content type is JSON. If not, don't
    allow the request to proceed.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个中间件中，检查内容类型是否为JSON。如果不是，则不允许请求继续进行。
- en: In the second middleware, add a timestamp called Server-Time (UTC) to the response
    cookie.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个中间件中，将一个名为 Server-Time (UTC) 的时间戳添加到响应cookie中。
- en: 'Before adding the middleware, Let''s create a `POST` API that collects the
    name and area of a city and returns a message with a status code of `201`, to
    show it has been successfully created. This can be done in the following way:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加中间件之前，让我们创建一个`POST` API，该 API 收集城市的名称和区域，并返回状态码为`201`的消息，以表明它已被成功创建。这可以通过以下方式完成：
- en: 'Create a file for our program, like this:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于程序的文件，如下所示：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, write the function that handles the `POST` request from the client. It
    decodes the body and reads the name and area, and fills them into a struct called
    `city`, like this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写处理客户端`POST`请求的函数。它解码请求体并读取名称和区域，并将它们填充到名为`city`的结构体中，如下所示：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`postHandler` is handling a client request in this snippet. It returns a status
    code of `405 - Method Not Allowed` if a client tries to perform a `GET` request. `json.NewDecoder` is
    used to read the body from a request. `Decode` maps the body parameters to a struct,
    of the `city`  type.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`postHandler`在这个片段中处理客户端请求。如果客户端尝试执行`GET`请求，则返回状态码`405 - Method Not Allowed`。`json.NewDecoder`用于从请求中读取请求体。`Decode`将请求体参数映射到`city`类型的结构体。'
- en: 'Now comes the main logic, as shown here:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是主要逻辑，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can start the API server by using the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码启动 API 服务器：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, fire a couple of `curl` requests, like so:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，发送几个`curl`请求，如下所示：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The server logs this output:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器记录了以下输出：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `curl` responses are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`的响应如下：'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now comes the content checks. In order to chain middleware functions, we have
    to pass the handler between multiple middleware. Only one handler is involved
    in the preceding example. But now, for the upcoming task, the idea is to pass
    the main handler to multiple middleware handlers. We can modify the `cityAPI`
    program to a new file, like this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是内容检查环节。为了链式调用中间件函数，我们必须在多个中间件之间传递处理器。在先前的例子中只有一个处理器参与。但现在，对于即将到来的任务，我们的想法是将主处理器传递给多个中间件处理器。我们可以将`cityAPI`程序修改为一个新的文件，如下所示：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s first create the content-check middleware. Let''s call it `filterContentType`.
    This middleware checks the `MIME` header from the request and, if it is not JSON,
    returns a response of status code `415- Unsupported Media Type`, as shown in the
    following code block:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建内容检查中间件。让我们称它为`filterContentType`。此中间件检查请求的`MIME`头，如果它不是 JSON，则返回状态码为`415-
    Unsupported Media Type`的响应，如下面的代码块所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, Let''s define a second middleware called `setServerTimeCookie`. After
    receiving a proper content type while sending a response back to the client, this
    middleware adds a cookie called `Server-Time(UTC)` with the server UTC timestamp
    as the value, as shown in the following code block:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义第二个中间件，称为`setServerTimeCookie`。在向客户端发送响应后收到适当的内容类型，此中间件会添加一个名为`Server-Time(UTC)`的cookie，其值为服务器的
    UTC 时间戳，如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The main function has a slight variation in the mapping of a route to the handler.
    It uses nested function calls for chaining middleware, as can be seen here:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主函数在将路由映射到处理器方面略有变化。它使用嵌套函数调用进行中间件链式调用，如下所示：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We chain the middleware by using `filterContentType(setServerTimeCookie(originalHandler))`.
    Please carefully observe the order of chaining.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`filterContentType(setServerTimeCookie(originalHandler))`来链式调用中间件。请仔细观察链式调用的顺序。
- en: 'Now, run the updated server, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式运行更新后的服务器：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, fire a `curl` request, like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，发送一个`curl`请求，如下所示：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The response output is the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 响应输出如下：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But if we remove `Content-Type: application/json` from the `curl` request,
    the middleware blocks us from executing the main handler, as shown in the following
    code block:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '但如果我们从`curl`请求中移除`Content-Type: application/json`，中间件将阻止我们执行主处理器，如下面的代码块所示：'
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the simplest way of chaining middleware in Go API servers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Go API 服务器中链式调用中间件的最简单方式。
- en: If an API server wishes a request to go through many middleware, then how can
    we make that chaining simple and readable? There is a very good library called
    `alice` to solve this problem. It allows you to semantically order and attach
    your middleware to the main handler. We will see it briefly in the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 API 服务器希望请求通过许多中间件，那么我们如何使链式调用简单且易于阅读？有一个非常好的库叫做`alice`来解决这个问题。它允许你以语义顺序将中间件附加到主处理器。我们将在下一节简要介绍它。
- en: Painless middleware chaining with Alice
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Alice 实现无痛苦的中件间链式调用
- en: The `alice` library reduces the complexity of chaining the middleware when the
    list of middleware is big. It provides us with a clean API to pass the handler
    to the middleware. It is a lightweight solution, unlike other middleware chaining
    Go packages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当中间件列表很长时，`alice` 库简化了中间件链的连接。它为我们提供了一个干净的 API 来将处理器传递给中间件。这是一个轻量级的解决方案，与其他中间件链的
    Go 包不同。
- en: 'Install `alice` via the `go get` command, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装 `alice`：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can import the `alice` package in our program and use it straight away.
    We can modify the sections of the previous program to bring the same functionality,
    with improved chaining. Let''s call the program directory `multipleMiddlewareWithAlice`,
    and create a main program in this location:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的程序中导入 `alice` 包并立即使用它。我们可以修改之前程序的相应部分以实现相同的功能，并改进链式调用。让我们将程序目录命名为
    `multipleMiddlewareWithAlice`，并在该位置创建一个主程序：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `import` section, add `github.com/justinas/alice`, as shown in the following
    code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `import` 部分，添加 `github.com/justinas/alice`，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, in the `main` function, we can modify the handler part, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `main` 函数中，我们可以修改处理器部分，如下所示：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output of this program is similar to the previous one. With the knowledge
    of the preceding concepts, Let's build a logging middleware with a library from
    the Gorilla toolkit called **handlers**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出与上一个程序类似。在了解前面的概念之后，让我们使用 Gorilla 工具包中的 **handlers** 库构建一个日志中间件。
- en: Using Gorilla handlers middleware for logging
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gorilla handlers 中间件进行日志记录
- en: 'The Gorilla handlers package provides various pre-written middleware for common
    tasks. The most important ones in the list are:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla handlers 包提供了各种预先编写的中间件以供常见任务使用。列表中最重要的是：
- en: '`LoggingHandler`: For logging in Apache **Common Log Format** (**CLF**)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoggingHandler`：用于 Apache **通用日志格式**（**CLF**）的日志记录'
- en: '`CompressionHandler`: For zipping the responses'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompressionHandler`：用于压缩响应'
- en: '`RecoveryHandler`: For recovering from unexpected panics'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecoveryHandler`：用于从意外的恐慌中恢复'
- en: 'Here, we use the `LoggingHandler` middleware to perform API-wide logging. First,
    install this library using `go get`, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `LoggingHandler` 中间件执行 API 全局日志记录。首先，使用以下方式使用 `go get` 安装此库：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This logging server enables us to create a server-like a log with time and
    options. For example, when you see `apache.log`, you find the log in a standard
    format, as shown in the following code block:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个日志服务器使我们能够创建一个带有时间和选项的服务器样式的日志。例如，当你看到 `apache.log` 时，你会在标准格式中找到日志，如下面的代码块所示：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The format is this: `IP-Date-Method:Endpoint-ResponseStatus`. Writing our own
    middleware that mimics Apache-style logging takes some effort, but Gorilla Handlers
    already implemented one for us. Let''s update the previous program in a few ways
    by creating a new program, like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 格式如下：`IP-日期-方法:端点-响应状态`。编写模仿 Apache 风格日志的自定义中间件需要一些努力，但 Gorilla Handlers 已经为我们实现了。让我们通过创建一个新的程序来更新之前的程序，如下所示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, Let''s write the program, using the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤编写程序：
- en: First, we create a `Gorilla` router and attach it to the `LoggingHandler`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `Gorilla` 路由器并将其附加到 `LoggingHandler`。
- en: 'The `LoggingHandler` registers a standard output (Let''s say, in our case, `os.Stdout`)
    and returns a new router. We use that new router to register with the HTTP server,
    as shown in the following code block:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoggingHandler` 注册一个标准输出（在我们的例子中，是 `os.Stdout`）并返回一个新的路由器。我们使用这个新的路由器将 HTTP
    服务器注册，如下面的代码块所示：'
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Start the server by running the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下代码启动服务器：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, open `http://127.0.0.1:8000` in the browser, or fire a `curl` request,
    and you will see the following output:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开 `http://127.0.0.1:8000`，或者发送一个 `curl` 请求，你将看到以下输出：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you observe, the last two logs are generated by the middleware. Gorilla `LoggingMiddleware`
    writes them at response time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察，最后两个日志是由中间件生成的。Gorilla `LoggingMiddleware` 在响应时写入它们。
- en: In the previous example, we always checked the API on the localhost. In this
    example, we explicitly specified replacing the localhost with `127.0.0.1` because
    the former will show as an empty IP in the logs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们总是在本地主机上检查 API。在这个例子中，我们明确指定用 `127.0.0.1` 替换本地主机，因为前者在日志中会显示为空 IP。
- en: Coming to the program, we are importing the `gorilla/mux` router and `gorilla/handlers`.
    Then, we are attaching a handler called `handle` to the router. Next, we are wrapping
    the router in the `handlers.LoggingHandler` middleware. It returns one more handler,
    which we can pass safely to `http.ListenAndServe`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序方面，我们正在导入 `gorilla/mux` 路由器和 `gorilla/handlers`。然后，我们将一个名为 `handle` 的处理程序附加到路由器上。接下来，我们将路由器包装在
    `handlers.LoggingHandler` 中间件中。它返回一个额外的处理程序，我们可以安全地将其传递给 `http.ListenAndServe`。
- en: You can try other middleware from handlers, too. This section's goal is to introduce
    you to `gorilla/handlers`. There are many other external packages available for
    Go. There is one library worth mentioning for writing middleware directly on `net/http`. It
    is `Negroni` ([github.com/urfave/negroni](http://github.com/urfave/negroni)).
    It also provides the functionality of `alice`, the Gorilla `LoggingHandler`. So,
    please have a look at it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以尝试 handlers 中的其他中间件。本节的目标是向您介绍 `gorilla/handlers`。Go 有许多其他外部包可用。有一个值得注意的库是直接在
    `net/http` 上编写中间件的库，它是 `Negroni` ([github.com/urfave/negroni](http://github.com/urfave/negroni))。它还提供了
    `alice`，Gorilla `LoggingHandler` 的功能。所以，请查看它。
- en: We can easily build cookie-based authentication middleware, using a library
    called `go.uuid` ([github.com/satori/go.uuid](http://github.com/satori/go.uuid))
    and cookies.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用名为 `go.uuid` 的库（[github.com/satori/go.uuid](http://github.com/satori/go.uuid)）和
    cookies，轻松构建基于 cookie 的身份验证中间件。
- en: Systems talk to each other using web services. A client API can be powered by
    multiple server instances. RPC is a mechanism to delegate work to a remote server
    in an understandable fashion. RPC is an important concept in Go because it can
    play a part in supporting a REST service served to a client. The Gorilla toolkit
    provides packages to support RPC. We will understand it in detail in the next
    section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 系统通过 Web 服务相互交谈。客户端 API 可以由多个服务器实例提供支持。RPC 是一种以可理解的方式将工作委托给远程服务器的机制。RPC 是 Go
    中的一个重要概念，因为它可以在支持客户端的 REST 服务中发挥作用。Gorilla 工具包提供了支持 RPC 的包。我们将在下一节中详细了解它。
- en: What is RPC?
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC 是什么？
- en: RPC is an inter-process communication that exchanges information between various
    distributed systems. A computer called Alice can call functions (procedures) in
    another computer called Bob in protocol format and can get the computed result
    back. Without implementing the functionality locally, we can request things from
    a network that lies in another place or geographical region.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 是一种进程间通信，它在不同分布式系统之间交换信息。一台称为 Alice 的计算机可以在另一台称为 Bob 的计算机上以协议格式调用函数（过程），并获取计算结果。我们可以在不实现本地功能的情况下，从另一个地方或地理区域请求网络上的事物。
- en: 'The entire process can be broken down into the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程可以分解为以下步骤：
- en: Clients prepare function name and arguments to send
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端准备要发送的函数名和参数
- en: Clients send them to an RPC server by dialing the connection
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端通过拨号连接将它们发送到 RPC 服务器
- en: The server receives the function name and arguments
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收函数名和参数
- en: The server executes the remote process
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器执行远程进程
- en: The message will be sent back to the client
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息将被发送回客户端
- en: The client collects the data from the request and uses it appropriately
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端从请求中收集数据并适当使用
- en: 'The server needs to expose its service for the client to connect and request
    a remote procedure. Take a look at the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器需要暴露其服务，以便客户端连接并请求远程过程。请查看以下图表：
- en: '![](img/4b91c8df-db63-4b11-8015-78ecebb0859e.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b91c8df-db63-4b11-8015-78ecebb0859e.png)'
- en: Go provides a library to implement both the **RPC Server** and **RPC Client**.
    In the preceding diagram, the **RPC Client** dials the connection with details
    such as the host and port. It sends two things along with the request. One is
    arguments, and the other is the reply pointer. Since it is a pointer, the server
    can modify it and send it back. Then, the client can use the data filled into
    the pointer. Go has two libraries, `net/rpc` and `net/rpc/jsonrpc`, for working
    with RPC. Let's write an RPC server that talks to the client and sends the server
    time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一个库来实现 **RPC 服务器** 和 **RPC 客户端**。在上面的图表中，**RPC 客户端**使用主机和端口等详细信息拨号连接。它随请求发送两件事。一是参数，二是回复指针。由于它是一个指针，服务器可以修改它并发送回来。然后，客户端可以使用填充到指针中的数据。Go
    有两个库，`net/rpc` 和 `net/rpc/jsonrpc`，用于处理 RPC。让我们编写一个与客户端交谈并发送服务器时间的 RPC 服务器。
- en: Creating an RPC server
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RPC 服务器
- en: 'Let''s create a simple RPC server that sends the UTC server time back to the
    RPC client. The RPC server and RPC client should agree upon two things:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的 RPC 服务器，将 UTC 服务器时间发送回 RPC 客户端。RPC 服务器和 RPC 客户端应该就以下两点达成一致：
- en: Arguments passed
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递的参数
- en: Value returned
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的值
- en: 'The types of these two parameters should match exactly for both server and
    client. Let''s look at the steps for creating an RPC server, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数的类型应该完全匹配服务器和客户端。让我们看看创建 RPC 服务器的步骤，如下所示：
- en: 'Let''s create an RPC server program, like this:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 RPC 服务器程序，如下所示：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We should create an `Args struct` and a reply pointer to hold data for RPC calls.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该创建一个 `Args struct` 和一个回复指针来保存 RPC 调用的数据。
- en: 'Then, create a function for a remote client to execute, and name it `GiveServerTime`,
    as shown in the following code block:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个远程客户端要执行的功能，命名为 `GiveServerTime`，如下面的代码块所示：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can activate `TimeServer` with a method called `rpc.Register`. The
    main logic looks like this:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用名为 `rpc.Register` 的方法激活 `TimeServer`。主逻辑如下：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are a few points to note from the preceding example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们可以注意以下几点：
- en: '`GiveServerTime` takes the `Args` object as the first argument and a reply
    pointer object'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GiveServerTime` 将 `Args` 对象作为第一个参数和一个回复指针对象'
- en: It sets the reply pointer object but does not return anything except an error
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置了回复指针对象，但没有返回任何内容，除了错误信息
- en: The `Args` struct here has no fields because this server is not expecting any
    arguments from clients
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里 `Args` 结构体没有字段，因为这个服务器不期望从客户端接收任何参数
- en: Before using this RPC server, Let's write the RPC client, too.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此 RPC 服务器之前，让我们也编写 RPC 客户端。
- en: Creating an RPC client
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RPC 客户端
- en: 'A client also uses the same `net/rpc` package, but different methods to dial
    to the server and get the remote function executed. The only way to get data back
    is to pass the reply pointer object along with the request. Let''s look at the
    steps for creating an RPC client, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端也使用相同的 `net/rpc` 包，但使用不同的方法拨号到服务器并执行远程函数。获取数据的唯一方法是将回复指针对象与请求一起传递。让我们看看创建
    RPC 客户端的步骤，如下所示：
- en: 'Let''s define that client program, like this:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义这个客户端程序，如下所示：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A client dials to an RPC server, using the `rpc.DialHTTP` method. It returns
    a `client` object. Once dial-in is successful, it can then execute a remote function
    using the `client.Call` method, as shown in the following code block:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端使用 `rpc.DialHTTP` 方法拨号到 RPC 服务器。它返回一个 `client` 对象。一旦拨号成功，就可以使用 `client.Call`
    方法执行远程函数，如下面的代码块所示：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can run both the server and client to see them in action. This runs
    the server, like this:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行服务器和客户端以观察它们的工作情况。这会运行服务器，如下所示：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, open another shell tab and run this, like so:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开另一个 shell 标签并运行此命令，如下所示：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, the server console will output the following Unix time string:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务器控制台将输出以下 Unix 时间字符串：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Did you see the magic? The client is running as an independent program from
    the server. Here, both the programs can be on different machines, and computing
    can still be shared. This is the core concept of distributed systems. The tasks
    are divided and given to various RPC servers. Finally, the client collects the
    results and uses them to take further decisions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了这个魔法吗？客户端作为一个独立的程序在服务器上运行。在这里，这两个程序可以位于不同的机器上，计算仍然可以共享。这是分布式系统的核心概念。任务被分割并分配给各个
    RPC 服务器。最后，客户端收集结果并使用它们做出进一步的决策。
- en: RPC should be secured because it is executing the remote functions. Authorization
    is a must while collecting requests from the client.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 应该被加密，因为它正在执行远程函数。在从客户端收集请求时，授权是必须的。
- en: Custom RPC code is only useful when the client and server are both written in
    Go. So, in order to have the RPC server consumed by multiple services, we need
    to define the JSON-RPC over HTTP. Then, any other programming language can send
    a JSON string and get JSON as the result back.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 RPC 代码仅在客户端和服务器都使用 Go 语言编写时才有用。因此，为了使 RPC 服务器被多个服务消费，我们需要定义通过 HTTP 的 JSON-RPC。然后，任何其他编程语言都可以发送
    JSON 字符串并获取 JSON 作为结果返回。
- en: JSON-RPC using Gorilla RPC
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gorilla RPC 的 JSON-RPC
- en: We saw that the Gorilla toolkit helps us by providing many useful libraries.
    It has libraries such as Mux for routing, Handlers for middleware, and now, the
    `gorilla/rpc` library. Using this, we can create RPC servers and clients that
    talk using JSON instead of a custom reply pointer. Let's convert the preceding
    example into a much more useful one.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 Gorilla 工具包通过提供许多有用的库来帮助我们。它有如 Mux 用于路由、Handlers 用于中间件，现在还有 `gorilla/rpc`
    库。使用这个库，我们可以创建使用 JSON 而不是自定义回复指针进行通信的 RPC 服务器和客户端。让我们将前面的示例转换为更有用的一个。
- en: 'Consider this scenario. We have a JSON file on the server that has details
    of books (name, ID, author). The client requests book information by making an
    HTTP request. When the RPC server receives the request, it reads the file from
    the filesystem and parses it. If the given ID matches any book, then the server
    sends the information back to the client in JSON format. Let''s look at the steps
    here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个场景。我们在服务器上有一个包含书籍详细信息（名称、ID、作者）的 JSON 文件。客户端通过发送 HTTP 请求来请求书籍信息。当 RPC 服务器接收到请求时，它会从文件系统中读取文件并解析它。如果给定的
    ID 与任何书籍匹配，则服务器以 JSON 格式将信息发送回客户端。让我们看看这里的步骤：
- en: 'We can install Gorilla RPC with the `go get` command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `go get` 命令安装 Gorilla RPC：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This package derives from the standard `net/rpc` package but uses a single HTTP
    request per call instead of persistent connections. Other differences compared
    to `net/rpc` are explained in the next few lines. Multiple codecs can be registered
    on the same server. A codec is chosen based on the `Content-Type` header from
    the request. Service methods also receive the `http.Request` as a parameter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包源自标准的 `net/rpc` 包，但在每次调用时使用单个 HTTP 请求而不是持久连接。与其他 `net/rpc` 相比的不同之处将在接下来的几行中解释。可以在同一服务器上注册多个编解码器。编解码器是根据请求的
    `Content-Type` 头部来选择的。服务方法也接收 `http.Request` 作为参数。
- en: 'Now, Let''s write an RPC JSON server. Here, we are implementing the JSON 1.0
    specification. For 2.0, you should use Gorilla JSON2. Let''s define a dummy JSON
    file that has information on books, like this:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个 RPC JSON 服务器。在这里，我们正在实现 JSON 1.0 规范。对于 2.0，你应该使用 Gorilla JSON2。让我们定义一个示例
    JSON 文件，其中包含有关书籍的信息，如下所示：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s us add a few books to the JSON file, like so:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 JSON 文件中添加一些书籍，如下所示：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we have a book database file (JSON, in this case). Let''s us write the
    RPC server similar to the previous example, by running the following code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有一个书籍数据库文件（在这个例子中是 JSON）。让我们编写一个与前面示例类似的 RPC 服务器，通过运行以下代码：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The process is to define a struct to hold types for a book. Then, create a
    `JSONServer` struct for registering with the RPC Server. It should have a method
    as an RPC action. Read the JSON file from the given file using the `filepath`
    built-in utility function. The `reply` argument of `JSONServer` is filled with
    the matched book information, as shown in the following code block:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流程是定义一个结构体来保存书籍的类型。然后，创建一个 `JSONServer` 结构体用于与 RPC 服务器注册。它应该有一个作为 RPC 动作的方法。使用内置的
    `filepath` 实用函数从给定的文件中读取 JSON 文件。`JSONServer` 的 `reply` 参数填充了匹配的书籍信息，如下面的代码块所示：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It looks similar to the last example, but a clear difference is that the server
    here expects an ID from the client. That ID is a key to fetch the book from JSON.
    In `GiveBookDetail`, we are using `ioutil.ReadFile` to read file content and unmarshal
    it into the `books` struct. We then iterate over a list of books to match the
    key and fill the `reply` pointer with the matched book.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与上一个示例相似，但一个明显的区别是，这里的服务器期望从客户端接收一个 ID。这个 ID 是从 JSON 中获取书籍的关键。在 `GiveBookDetail`
    中，我们使用 `ioutil.ReadFile` 读取文件内容并将其反序列化到 `books` 结构体中。然后我们遍历书籍列表以匹配键，并将匹配的书籍填充到
    `reply` 指针中。
- en: 'Now, Let''s us finish the `main` block, which registers the `JSONServer` defined
    previously as an RPC service, like this:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们完成 `main` 块，将之前定义的 `JSONServer` 作为 RPC 服务进行注册，如下所示：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A slight difference here is we have to register codec type using the `RegisterCodec` method.
    That is JSON codec in this case. Then, we can register the service using the `RegisterService` method
    and start a normal HTTP server. If you have noticed well, we used the alias `jsonparse`
    for the `encoding/json` package because it can conflict with another package, `github.com/gorilla/rpc/json`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个细微差别是我们必须使用 `RegisterCodec` 方法注册编解码器类型。在这种情况下是 JSON 编解码器。然后，我们可以使用 `RegisterService`
    方法注册服务并启动一个正常的 HTTP 服务器。如果你注意到了，我们使用了 `jsonparse` 作为 `encoding/json` 包的别名，因为它可能会与另一个包
    `github.com/gorilla/rpc/json` 冲突。
- en: 'We can start this `jsonRPCServer`, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像这样启动这个 `jsonRPCServer`：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, do we have to develop a client? Not necessarily, because a client can
    be a `curl` program since the RPC server is serving requests over HTTP, we need
    to post JSON with a book ID to get the details. So, fire up another shell and
    execute this `curl` request:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们是否必须开发一个客户端？不一定，因为客户端可以是一个 `curl` 程序，因为 RPC 服务器正在通过 HTTP 提供服务，我们需要发送带有书籍
    ID 的 JSON 来获取详细信息。所以，打开另一个 shell 并执行这个 `curl` 请求：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output will be nice JSON that is served directly from the JSON-RPC server,
    like this:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将是一个直接从 JSON-RPC 服务器提供的漂亮的 JSON，如下所示：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Make JSON-RPC your preferred choice when multiple client technologies need to
    connect to your RPC service.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个客户端技术需要连接到您的 RPC 服务时，请将 JSON-RPC 作为首选选择。
- en: RPC is a very common way of defining typed services in programming languages.
    The Gorilla toolkit is a very useful package while working with Go. When a REST
    JSON API needs to be provided, you can go ahead and use JSON-RPC.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 是在编程语言中定义类型化服务的一种非常常见的方式。Gorilla 工具包是在使用 Go 语言时一个非常实用的包。当需要提供 REST JSON
    API 时，你可以继续使用 JSON-RPC。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first looked into what middleware is and how middleware
    processes a request and response. We then explored the middleware code, with a
    few practical examples. After that, we saw how to chain many middleware, one after
    the other. A package such as `alice` can be used for intuitive chaining. A package
    from the Gorilla toolkit, `gorilla/handlers`, provides various middleware for
    logging, compression, and **Cross-Origin Resource Sharing** (**CORS**).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了什么是中间件以及中间件如何处理请求和响应。然后，我们通过一些实际例子探讨了中间件代码。之后，我们看到了如何将多个中间件一个接一个地串联起来。例如，`alice`
    包可以用于直观的链式调用。Gorilla 工具包中的一个包，`gorilla/handlers`，提供了用于日志记录、压缩和**跨源资源共享**（**CORS**）的各种中间件。
- en: Next, we learned what an RPC is, and how an RPC server and client can be built.
    After that, we explained what a JSON-RPC is, and we saw how to create a JSON-RPC
    using the Gorilla toolkit. We introduced many third-party packages for middleware
    and RPC along the way.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了 RPC 是什么，以及如何构建 RPC 服务器和客户端。然后，我们解释了什么是 JSON-RPC，并展示了如何使用 Gorilla 工具包创建
    JSON-RPC。在过程中，我们介绍了许多用于中间件和 RPC 的第三方包。
- en: In the next chapter, we are going to explore a few famous web frameworks that
    further simplify REST API creation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些著名的网络框架，这些框架进一步简化了 REST API 的创建。
