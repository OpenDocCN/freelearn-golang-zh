<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Simplifying RESTful Services with Popular Go Frameworks</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to use different frameworks for simplifying the process of building REST services. First, we will take a quick look at <kbd>go-restful</kbd>, a REST API creation framework, and then move to a framework called Gin. We will build a Metro Rail API in this chapter. The frameworks that we will discuss are fully-fledged web frameworks that can also be used to create REST APIs in a short time. We will also talk a lot about resources and REST verbs in this chapter. We will then try to integrate a small database called SQLite3 with our API. Finally, we explore <kbd>revel.go</kbd> and see how to prototype our REST API with it.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li><kbd>go-restful</kbd> – a framework for REST API creation</li>
<li>SQLite3 basics and CRUD operations</li>
<li>Building a Metro Rail API with <kbd>go-restful</kbd></li>
<li>Building a RESTful API with the Gin framework</li>
<li>Building a RESTful API with <kbd>revel.go</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements </h1>
                </header>
            
            <article>
                
<p>The following are the software that should be pre-installed for running code samples:</p>
<ul>
<li>OS: Linux (Ubuntu 18.04)/Windows 10/<span>Mac OS X </span> &gt;=10.13</li>
<li>Software: Docker &gt;= 18 (Docker Desktop for Windows and <span>Mac OS X</span>)</li>
<li>Go latest version compiler &gt;= 1.13.5</li>
</ul>
<p>You can download the code for this chapter from <a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter4" target="_blank">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter4</a>. Clone the code and use the code samples in the <kbd>chapter4</kbd> directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing go-restful – a REST API framework</h1>
                </header>
            
            <article>
                
<p><kbd>go-restful</kbd> is a package for building REST-style web services in Go. REST, as we discussed in <a href="eb93f11e-bb80-40dc-873c-e350560467db.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started with REST API Development</em>, asks developers to follow a set of design protocols. There we also discussed how the REST verbs are defined and what they do to the resources. </p>
<p>Using <kbd>go-restful</kbd>, we can separate the logic for API handlers and attach REST verbs. The benefit is that it clearly shows what resources are manipulated by looking at the code. Before jumping into an example, we have to install a database called SQLite3 for our REST API with <kbd>go-restful</kbd>. The installation steps are as follows:</p>
<ol>
<li>First, install the dependencies for the <kbd>go-restful</kbd> package. On Ubuntu, run this command:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> apt-get install sqlite3 libsqlite3-dev</strong></pre>
<p style="padding-left: 60px">On <span>Mac OS X</span>, you can use the <kbd>brew</kbd> command to install <kbd>sqlite3</kbd>:</p>
<pre style="padding-left: 60px">&gt;<strong> brew install sqlite3</strong></pre>
<ol start="2">
<li>Now, install the <kbd>go-restful</kbd> package with the following <kbd>get</kbd> command:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> go get github.com/emicklei/go-restful</strong></pre>
<div class="packt_infobox">On Windows OS, you can download the SQLite3 executable from <a href="https://www.sqlite.org" target="_blank">https://www.sqlite.org</a><span>.</span></div>
<p>We are now ready to go. First, let's write a simple program showing what <kbd>go-restful</kbd> can do in a few lines of code. It provides a <kbd>WebService</kbd> using which we can attach a route to a handler. The use case is to create a simple ping server that echoes the server time back to the client. The steps are as follows:</p>
<ol>
<li>Let's create a <kbd>basicExample.go</kbd> program:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter4/basicExample/main.go</strong></pre>
<ol start="2">
<li>Now, create a function that writes  the server time to the response. It takes <kbd>Request</kbd> and <kbd>Response</kbd> objects:</li>
</ol>
<pre style="padding-left: 60px">func pingTime(req *restful.Request, resp *restful.Response) {<br/> // Write to the response<br/> io.WriteString(resp, fmt.Sprintf("%s", time.Now()))<br/>}</pre>
<p style="padding-left: 60px">The <kbd>pingTime</kbd> handler is straightforward and simply writes a server time to the response.</p>
<ol start="3">
<li>We have to create an instance of <kbd>restful.WebService</kbd> to attach a given route to a verb and a handler. See how we can do it in the following <kbd>main</kbd> block:</li>
</ol>
<pre style="padding-left: 90px">package main<br/>import (<br/>    "fmt"<br/>    "github.com/emicklei/go-restful"<br/>    "io"<br/>    "net/http"<br/>    "time"<br/>)<br/>func main() {<br/>    // Create a web service<br/>    webservice := new(restful.WebService)<br/>    // Create a route and attach it to handler in the service<br/>    webservice.Route(webservice.GET("/ping").To(pingTime))<br/>    // Add the service to application<br/>    restful.Add(webservice)<br/>    http.ListenAndServe(":8000", nil)<br/>}</pre>
<ol start="4">
<li>Now, run the program:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter4/basicExample/main.go</strong></pre>
<ol start="5">
<li>The server will be running on port <kbd>8000</kbd> of localhost. So, we can either make a <kbd>curl</kbd> request or use a browser to see the <kbd>GET</kbd> request output:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET "http://localhost:8000/ping"</strong><br/><strong>2020-01-01 07:37:26.238146296 +0530 CET</strong></pre>
<p style="padding-left: 60px">In the preceding program, we imported the <kbd>go-restful</kbd> library and created a new service using an instance of the <kbd>restful.WebService</kbd> struct.</p>
<ol start="6">
<li>Next, we will create a REST verb using the following statement:</li>
</ol>
<pre style="padding-left: 60px"><strong>webservice.GET("/ping")</strong></pre>
<ol start="7">
<li>We then attach a function handler to execute this verb; <kbd>pingTime</kbd> is one such function. These chained functions are passed to a <kbd>Route</kbd> function to create a router. Then comes the following important statement:</li>
</ol>
<pre style="padding-left: 60px"><strong>restful.Add(webservice)</strong></pre>
<p>This registers the newly created <kbd>webservice</kbd> with <kbd>go-restful</kbd>. If you observe, we are not passing any <kbd>ServeMux</kbd> objects to the <kbd>http.ListenServe</kbd> function; <kbd>go-restful</kbd> will take care of it.</p>
<p>The main concept here is to use the resource-based REST API creation in <kbd>go-restful</kbd>. Going from the basic example, let's build something practical.</p>
<p>Take a scenario where your city is getting a new Metro Rail project and you have to develop a REST API for other developers to create apps around it. We will create one such API in this chapter and use various frameworks to show the implementation. Before that, for <strong>Create</strong>, <strong>Read</strong>, <strong>Update</strong>, <strong>Delete</strong> (<strong>CRUD</strong>) operations, we should know how to query or insert data into a database with Go code. We pick the simplest one called SQLite3 and discuss it in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SQLite3 basics and CRUD operations</h1>
                </header>
            
            <article>
                
<p><strong>SQLite3</strong> is a lightweight, file-based SQL database. It is very useful to quickly build persistence for API. It leverages the SQL language and a relational database. In this section, we see how to interact with SQLite3 from Go.</p>
<p>All SQLite3 operations are going to be done using the <kbd>go-sqlite3</kbd> library. We can install that package using the following command:</p>
<pre><strong>go get github.com/mattn/go-sqlite3</strong></pre>
<p>The special thing about this library is that it uses the internal <kbd>sql</kbd> package of Go. We usually import <kbd>database/sql</kbd> and use SQL to execute database queries on the database (here, SQLite3):</p>
<pre><strong>import "database/sql"</strong></pre>
<p>Now, we can use the following steps to create a database driver and then execute the SQL commands on it using the <kbd>Query</kbd> method:</p>
<ol>
<li>Let's create a file in this path:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter4/sqliteExample/main.go</strong></pre>
<ol start="2">
<li>Let's define the main block that creates a table if none exists and calls another function for CRUD operations:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "database/sql"<br/>  "log"<br/><br/>  _ "github.com/mattn/go-sqlite3"<br/>)<br/><br/>// Book is a placeholder for book<br/>type Book struct {<br/>  id int<br/>  name string<br/>  author string<br/>}<br/><br/>func main() {<br/>  db, err := sql.Open("sqlite3", "./books.db")<br/>  if err != nil {<br/>    log.Println(err)<br/>  }<br/>  // Create table<br/>  statement, err := db.Prepare("CREATE TABLE IF NOT EXISTS books<br/>   (id INTEGER PRIMARY KEY, isbn INTEGER, author VARCHAR(64),<br/>    name VARCHAR(64) NULL)")<br/>  if err != nil {<br/>    log.Println("Error in creating table")<br/>  } else {<br/>    log.Println("Successfully created table books!")<br/>  }<br/>  statement.Exec()<br/>  dbOperations(db)<br/>}</pre>
<p style="padding-left: 60px">We are creating a database called <kbd>books.db</kbd> and execute a SQL statement for creating a <kbd>books</kbd> table. We created a SQL statement with the <kbd>db.Prepare</kbd> method. Then we executed it using the statement's <kbd>Exec</kbd> method.</p>
<ol start="3">
<li>If you notice, we called the <kbd>dbOperations</kbd> function for performing CRUD operations. In that function, we create a book, read it, then update, and then delete it. Let's see the implementation:</li>
</ol>
<pre style="padding-left: 60px">func dbOperations(db *sql.DB) {<br/>  // Create<br/>  statement, _ := db.Prepare("INSERT INTO books (name, author,<br/>   isbn) VALUES (?, ?, ?)")<br/>  statement.Exec("A Tale of Two Cities", "Charles Dickens",<br/>   140430547)<br/>  log.Println("Inserted the book into database!")<br/><br/>  // Read<br/>  rows, _ := db.Query("SELECT id, name, author FROM books")<br/>  var tempBook Book<br/>  for rows.Next() {<br/>    rows.Scan(&amp;tempBook.id, &amp;tempBook.name, &amp;tempBook.author)<br/>    log.Printf("ID:%d, Book:%s, Author:%s\n", tempBook.id,<br/>     tempBook.name, tempBook.author)<br/>  }<br/>  // Update<br/>  statement, _ = db.Prepare("update books set name=? where id=?")<br/>  statement.Exec("The Tale of Two Cities", 1)<br/>  log.Println("Successfully updated the book in database!")<br/><br/>  //Delete<br/>  statement, _ = db.Prepare("delete from books where id=?")<br/>  statement.Exec(1)<br/>  log.Println("Successfully deleted the book in database!")<br/>}</pre>
<p style="padding-left: 60px">In addition to the <kbd>Prepare</kbd> function, now we have another <kbd>Query</kbd> method. This is mainly used for reading data from a database. <kbd>Exec</kbd> is a common function for executing a prepared/queried statement on SQLite.</p>
<div class="packt_infobox">A Prepare statement is for performing actions on a database that causes a change in the database, and Query is for read-only.</div>
<ol start="4">
<li>Let's run the <kbd>sqliteFunamentals</kbd> program:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter4/sqliteExample/main.go</strong></pre>
<p style="padding-left: 60px">The output looks like the following, printing all the log statements:</p>
<pre style="padding-left: 60px"><strong>2017/06/10 08:04:31 Successfully created table books!</strong><br/><strong>2017/06/10 08:04:31 Inserted the book into database!</strong><br/><strong>2017/06/10 08:04:31 ID:1, Book:A Tale of Two Cities, Author:Charles Dickens</strong><br/><strong>2017/06/10 08:04:31 Successfully updated the book in database!</strong><br/><strong>2017/06/10 08:04:31 Successfully deleted the book in database!</strong></pre>
<p style="padding-left: 60px">There is an important thing related to security while running queries. Take a statement from the preceding code:</p>
<pre style="padding-left: 60px">statement, _ = db.Prepare("INSERT INTO books (name, author, isbn) VALUES (?, ?, ?)")<br/>statement.Exec("A Tale of Two Cities", "Charles Dickens", 140430547)</pre>
<p>If you pass incorrect values, such as strings that cause SQL injection, the driver rejects the SQL operation instantly. This is to avoid any raw strings being executed by the database engine. It could be dangerous as SQL can do anything, even dropping a database. Always prepare the statement first and then pass the necessary details.</p>
<p>In the next section, we try to build an example API with <kbd>go-restful</kbd> and SQLite3.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a Metro Rail API with go-restful</h1>
                </header>
            
            <article>
                
<p>Let's use the knowledge of <kbd>go-restful</kbd> and SQLite3 we have gained and create an API for the Metro Rail project we talked about in the preceding section. The road map is as follows:</p>
<ol>
<li> Design a REST API document</li>
<li> Create models for a database</li>
<li> Implement the API logic</li>
</ol>
<p>Let's understand each of them in detail. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design specification</h1>
                </header>
            
            <article>
                
<p>Before creating any API, we should know what the specifications of APIs are in the form of a document. We showed an example in <a href="72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml" target="_blank">Chapter 2</a>, <em>Handling Routing for our REST Services</em>, where we showed the URL shortener API design document. Let's try to create one for this Metro Rail project. Take a look at the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 84.2045px"><strong>HTTP verb</strong></td>
<td style="width: 296.932px"><strong>Path</strong></td>
<td style="width: 51.4773px"><strong>Action</strong></td>
<td style="width: 73.2955px">
<p><strong>Resource</strong></p>
</td>
</tr>
<tr>
<td style="width: 84.2045px"><kbd>POST</kbd></td>
<td>
<p><kbd>/v1/train (details as JSON body)</kbd></p>
</td>
<td style="width: 51.4773px">
<p><kbd>Create</kbd></p>
</td>
<td style="width: 73.2955px">
<p><kbd>Train</kbd></p>
</td>
</tr>
<tr>
<td style="width: 84.2045px"><kbd>POST</kbd></td>
<td style="width: 296.932px">
<p><kbd>/v1/station (details as JSON body)</kbd></p>
</td>
<td style="width: 51.4773px">
<p><kbd>Create</kbd></p>
</td>
<td style="width: 73.2955px">
<p><kbd>Station</kbd></p>
</td>
</tr>
<tr>
<td style="width: 84.2045px"><kbd>GET</kbd></td>
<td style="width: 296.932px"><kbd>/v1/train/id </kbd></td>
<td style="width: 51.4773px">
<p><kbd>Read</kbd></p>
</td>
<td style="width: 73.2955px">
<p><kbd>Train</kbd></p>
</td>
</tr>
<tr>
<td style="width: 84.2045px"><kbd>GET</kbd></td>
<td style="width: 296.932px"><kbd>/v1/station/id</kbd></td>
<td style="width: 51.4773px">
<p><kbd>Read</kbd></p>
</td>
<td style="width: 73.2955px">
<p><kbd>Station</kbd></p>
</td>
</tr>
<tr>
<td style="width: 84.2045px"><kbd>POST</kbd></td>
<td style="width: 296.932px">
<p><kbd>/v1/schedule (source and destination)</kbd></p>
</td>
<td style="width: 51.4773px">
<p><kbd>Create</kbd></p>
</td>
<td style="width: 73.2955px">
<p><kbd>Route</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We can also include the <kbd>UPDATE</kbd> and <kbd>DELETE</kbd> methods. By implementing the preceding design, it will be obvious for users to implement them on their own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating database models</h1>
                </header>
            
            <article>
                
<p>Let's write a few SQL strings for creating the tables for the preceding <kbd>train</kbd>, <kbd>station</kbd>, and <kbd>route</kbd> resources. We are going to create a project layout for this API. Create two directories called <kbd>railAPI</kbd> and <kbd>dbutils</kbd> in <kbd>$GOPATH/src/github.com/git-user/chapter4</kbd>.</p>
<p>Here, <kbd>railAPI</kbd> is our project source, and <kbd>dbutils</kbd> is our own package for handling database initialization utility functions. Follow these steps:</p>
<ol>
<li>Let's start with the <kbd>dbutils/models.go</kbd> file. Add three models each for <kbd>train</kbd>, <kbd>station</kbd>, and <kbd>schedule</kbd> in the <kbd>models.go</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">package dbutils<br/><br/>const train = `<br/>      CREATE TABLE IF NOT EXISTS train (<br/>           ID INTEGER PRIMARY KEY AUTOINCREMENT,<br/>           DRIVER_NAME VARCHAR(64) NULL,<br/>           OPERATING_STATUS BOOLEAN<br/>        )<br/>`<br/><br/>const station = `<br/>        CREATE TABLE IF NOT EXISTS station (<br/>          ID INTEGER PRIMARY KEY AUTOINCREMENT,<br/>          NAME VARCHAR(64) NULL,<br/>          OPENING_TIME TIME NULL,<br/>          CLOSING_TIME TIME NULL<br/>        )<br/>`<br/>const schedule = `<br/>        CREATE TABLE IF NOT EXISTS schedule (<br/>          ID INTEGER PRIMARY KEY AUTOINCREMENT,<br/>          TRAIN_ID INT,<br/>          STATION_ID INT,<br/>          ARRIVAL_TIME TIME,<br/>          FOREIGN KEY (TRAIN_ID) REFERENCES train(ID),<br/>          FOREIGN KEY (STATION_ID) REFERENCES station(ID)<br/>        )<br/>`</pre>
<p style="padding-left: 60px">These are plain multi-line strings that are delimited by the back tick <kbd>`</kbd> character. <kbd>schedule</kbd> holds the information of a train arriving at a particular station at a given time. Here, <kbd>train</kbd> and <kbd>station</kbd> are foreign keys to the <kbd>schedule</kbd> table. For <kbd>train</kbd>, the details related to it are columns. The package name is <kbd>dbutils</kbd>. When we use the package names, all the Go programs in that package can share variables and functions without an explicit import.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>Now, let's add code to initialize the (create tables) database in the <kbd>init-tables.go</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">package dbutils<br/>import "log"<br/>import "database/sql"<br/><br/>func Initialize(dbDriver *sql.DB) {<br/>    statement, driverError := dbDriver.Prepare(train)<br/>    if driverError != nil {<br/>        log.Println(driverError)<br/>    }<br/>    // Create train table<br/>    _, statementError := statement.Exec()<br/>    if statementError != nil {<br/>        log.Println("Table already exists!")<br/>    }<br/>    statement, _ = dbDriver.Prepare(station)<br/>    statement.Exec()<br/>    statement, _ = dbDriver.Prepare(schedule)<br/>    statement.Exec()<br/>    log.Println("All tables created/initialized successfully!")<br/>}</pre>
<p style="padding-left: 60px">We are importing <kbd>database/sql</kbd> to pass the type of argument in the function. All other statements in the function are similar to the SQLite3 example we gave in the preceding section. It is creating three tables in the SQLite3 database. Our main program should pass the database driver to this function. If you observe here, we are not importing <kbd>train</kbd>, <kbd>station</kbd>, and <kbd>schedule</kbd>. However, since this file is in the <kbd>dbutils</kbd> package, variables in <kbd>models.go</kbd> are accessible here.</p>
<ol start="3">
<li>Now, our initial package is finished. Build the object code for this package using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>go build $GOPATH/src/github.com/git-user/chapter4/dbutils</strong></pre>
<ol start="4">
<li>It is not useful until we create and run our main program. So, let's write a simple main program that imports the <kbd>Initialize</kbd> function from the <kbd>dbutils</kbd> package. Let's call the <kbd>main.go</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter4/railAPI/main.go</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li>Now, in the main function, let's import the <kbd>dbutils</kbd> package and initialize the tables:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>    "database/sql"<br/>    "log"<br/><br/>    _ "github.com/mattn/go-sqlite3"<br/>    "github.com/git-user/chapter4/dbutils"<br/>)<br/><br/>func main() {<br/>    // Connect to Database<br/>    db, err := sql.Open("sqlite3", "./railapi.db")<br/>    if err != nil {<br/>        log.Println("Driver creation failed!")<br/>    }<br/>    // Create tables<br/>    dbutils.Initialize(db)<br/>}</pre>
<ol start="6">
<li>Run the program from the <kbd>railAPI</kbd> directory using the following command:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter4/railAPI/main.go</strong></pre>
<ol start="7">
<li>The output should be something like the following:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>2020/01/10 14:05:36 All tables created/initialized successfully!</strong></pre>
<p>In the previous <kbd>railAPI</kbd> example, we delegated the table creation task to the <kbd>Initialize</kbd> function in the <kbd>dbutils</kbd> package. We can do that straight away in our main program, but it is good practice to decompose the logic into multiple packages.</p>
<div class="packt_infobox">The <kbd>railapi.db</kbd> file from the preceding directory tree screenshot gets created once we run our main program. SQLite3 will take care of creating the database file if it doesn't exist. SQLite3 databases are simple files. You can enter into the SQLite shell using the <kbd>$ sqlite3 file_name</kbd> command.</div>
<p>Let's extend the main program from <kbd>railAPI</kbd>. Our goal is to create an API that was mentioned in the <em>Design specification</em> section. We will go step by step and understand how to build REST services using <kbd>go-restful</kbd> and SQLite3 in this example:</p>
<ol>
<li>First, add the necessary imports to the program:</li>
</ol>
<div>
<pre style="padding-left: 60px">package main<br/>import (<br/>    "database/sql"<br/>    "encoding/json"<br/>    "log"<br/>    "net/http"<br/>    "time"<br/>    "github.com/emicklei/go-restful"<br/>    _ "github.com/mattn/go-sqlite3"<br/>    "github.com/git-user/chapter4/dbutils"<br/>)</pre></div>
<p style="padding-left: 60px">We need two external packages, <kbd>go-restful</kbd> and <kbd>go-sqlite3</kbd>, for building the API logic. The first one is for handlers and the second package is for adding storage. <kbd>dbutils</kbd> stays as it is from the <kbd>railAPI</kbd> example. The <kbd>time</kbd> and <kbd>net/http</kbd> packages are for general purpose tasks.</p>
<ol start="2">
<li>Even though concrete names are given to the columns in the SQLite database's tables, in Go programming, we need a few struct types to handle data going in and out of the database. Take a look at the following code snippet that defines necessary structs to hold data:</li>
</ol>
<div>
<pre style="padding-left: 60px">// DB Driver visible to whole program<br/>var DB *sql.DB<br/><br/>// TrainResource is the model for holding rail information<br/>type TrainResource struct {<br/>    ID int<br/>    DriverName string<br/>    OperatingStatus bool<br/>}<br/>// StationResource holds information about locations<br/>type StationResource struct {<br/>    ID int<br/>    Name string<br/>    OpeningTime time.Time<br/>    ClosingTime time.Time<br/>}<br/>// ScheduleResource links both trains and stations<br/>type ScheduleResource struct {<br/>    ID int<br/>    TrainID int<br/>    StationID int<br/>    ArrivalTime time.Time<br/>}</pre></div>
<p style="padding-left: 60px">The <kbd>DB</kbd> variable is allocated to hold the global database driver. All the preceding structs are exact representations of the database models in SQL. Go's <kbd>time.Time</kbd> struct type can actually hold the <kbd>Time</kbd> field from the database.</p>
<ol start="3">
<li>Now comes the actual <kbd>go-restful</kbd> implementation. We need to create a container for our API in <kbd>go-restful</kbd>. Then, we should register the web services to that container. What we have to do now is pick a resource and define a <kbd>Register</kbd> method on it. In our case, say <kbd>TrainResource</kbd> struct is a resource. The method argument will be a <kbd>go-restful</kbd> container where we can attach a service to a namespace, as shown in the following code snippet:</li>
</ol>
<div>
<pre style="padding-left: 60px">// Register adds paths and routes to a new service instance<br/>func (t *TrainResource) Register(container *restful.Container) {<br/>    ws := new(restful.WebService)<br/>    ws.Path("/v1/trains").Consumes(restful.MIME_JSON).Produces<br/>    (restful.MIME_JSON)<br/>    ws.Route(ws.GET("/{train-id}").To(t.getTrain))<br/>    ws.Route(ws.POST("").To(t.createTrain))<br/>    ws.Route(ws.DELETE("/{train-id}").To(t.removeTrain))<br/>    container.Add(ws)<br/>}</pre></div>
<p style="padding-left: 60px">We first created a service, then added path and routes to the resource. Finally, we attached the service to the container. A path is the URL endpoint, and routes are the path parameters or query parameters attached to the function handlers. </p>
<p style="padding-left: 60px">We attached three REST methods, namely <kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd> to three function handlers, <kbd>getTrain</kbd>, <kbd>createTrain</kbd>, and <kbd>removeTrain</kbd>, respectively. We haven't implemented those handlers yet, but we will soon.</p>
<p style="padding-left: 60px">If you look at this special statement:</p>
<div>
<pre style="padding-left: 60px">ws.Path("/v1/trains").Consumes(restful.MIME_JSON).Produces(restful.MIME_JSON)</pre></div>
<p style="padding-left: 60px">It tells us that our API will only entertain Content-Type as application/JSON in the request. For all other types, it automatically returns a <kbd>415--Media Not Supported</kbd> error.</p>
<p style="padding-left: 60px">The returned response is automatically converted to a pretty JSON. We can also have a list of formats such as XML, JSON, and so on. <kbd>go-restful</kbd> provides this feature out of the box.</p>
<ol start="4">
<li>Now, let's define the function handlers. The <kbd>getTrain</kbd><span> handler takes an HTT</span><span>P request and accesses the <kbd>path</kbd> parameter, then creates a <kbd>DB</kbd> query statement to fetch the row from the database.</span> <kbd>WriteEntity</kbd> <span>is used to write a struct as JSON to a response:</span></li>
</ol>
<pre style="padding-left: 60px">// GET http://localhost:8000/v1/trains/1<br/>func (t TrainResource) getTrain(request *restful.Request,<br/> response *restful.Response) {<br/>    id := request.PathParameter("train-id")<br/>    err := DB.QueryRow("select ID, DRIVER_NAME, OPERATING_STATUS<br/>     FROM train where id=?", id).Scan(&amp;t.ID, &amp;t.DriverName,<br/>     &amp;t.OperatingStatus)<br/>    if err != nil {<br/>        log.Println(err)<br/>        response.AddHeader("Content-Type", "text/plain")<br/>        response.WriteErrorString(http.StatusNotFound, "Train could<br/>         not be found.")<br/>    } else {<br/>        response.WriteEntity(t)<br/>    }<br/>}</pre>
<ol start="5">
<li>Now comes the <kbd>POST</kbd> handler, <kbd>createTrain</kbd>. It is similar to <kbd>GET</kbd>, but instead of fetching information from path parameters, it decodes the body of the incoming request. Then it prepares a database query statement to insert body data. It returns the <kbd>ID</kbd> of the inserted record in response with the <kbd>201-created</kbd> status:</li>
</ol>
<div>
<pre style="padding-left: 60px"><br/>// POST http://localhost:8000/v1/trains<br/>func (t TrainResource) createTrain(request *restful.Request, response *restful.Response) {<br/>    log.Println(request.Request.Body)<br/>    decoder := json.NewDecoder(request.Request.Body)<br/>    var b TrainResource<br/>    err := decoder.Decode(&amp;b)<br/>    log.Println(b.DriverName, b.OperatingStatus)<br/>    // Error handling is obvious here. So omitting...<br/>    statement, _ := DB.Prepare("insert into train (DRIVER_NAME,<br/>     OPERATING_STATUS) values (?, ?)")<br/>    result, err := statement.Exec(b.DriverName, b.OperatingStatus)<br/>    if err == nil {<br/>        newID, _ := result.LastInsertId()<br/>        b.ID = int(newID)<br/>        response.WriteHeaderAndEntity(http.StatusCreated, b)<br/>    } else {<br/>        response.AddHeader("Content-Type", "text/plain")<br/>        response.WriteErrorString(http.StatusInternalServerError,<br/>        err.Error())<br/>    }<br/>}</pre></div>
<ol start="6">
<li>The <kbd>DELETE</kbd> function is quite obvious if you understand the previous two handlers. We are making a <kbd>DELETE</kbd> SQL command using <kbd>DB.Prepare</kbd> and returning a <kbd>201</kbd> Status created back, telling us the delete operation was successful. Otherwise, we are sending back the actual error as a server error:</li>
</ol>
<pre style="padding-left: 60px">// DELETE http://localhost:8000/v1/trains/1<br/>func (t TrainResource) removeTrain(request *restful.Request, response *restful.Response) {<br/>    id := request.PathParameter("train-id")<br/>    statement, _ := DB.Prepare("delete from train where id=?")<br/>    _, err := statement.Exec(id)<br/>    if err == nil {<br/>        response.WriteHeader(http.StatusOK)<br/>    } else {<br/>        response.AddHeader("Content-Type", "text/plain")<br/>        response.WriteErrorString(http.StatusInternalServerError,<br/>        err.Error())<br/>    }<br/>}</pre>
<ol start="7">
<li>Now, let's write the main function handler, which is an entry point for our program. It creates a <kbd>go-restful</kbd> container and registers <kbd>TrainResource</kbd>:</li>
</ol>
<div>
<pre style="padding-left: 60px">func main() {<br/>    var err error<br/>    DB, err = sql.Open("sqlite3", "./railapi.db")<br/>    if err != nil {<br/>        log.Println("Driver creation failed!")<br/>    }<br/>    dbutils.Initialize(DB)<br/>    wsContainer := restful.NewContainer()<br/>    wsContainer.Router(restful.CurlyRouter{})<br/>    t := TrainResource{}<br/>    t.Register(wsContainer)<br/>    log.Printf("start listening on localhost:8000")<br/>    server := &amp;http.Server{Addr: ":8000", Handler: wsContainer}<br/>    log.Fatal(server.ListenAndServe())<br/>}</pre></div>
<p style="padding-left: 60px">The first few lines are performing the database-related housekeeping. Then, we are creating a new container using <kbd>restful.NewContainer</kbd>. The <kbd>go-restful</kbd> package provides a router called <kbd>CurlyRouter</kbd> (which allows us to use {train_id} syntax in paths while setting routes) for our container, and there are other types too. We have chosen that router for incoming HTTP requests. Then, we created an instance of the <kbd>TrainResource</kbd> struct and passed this container to the <kbd>Register</kbd> method. That container can act as a wrapped HTTP handler, so we can directly pass it to <kbd>http.Server</kbd> easily.</p>
<ol start="8">
<li>Use <kbd>request.QueryParameter</kbd> to fetch the query parameters from an HTTP request in the <kbd>go-restful</kbd> handler.</li>
<li>Let's run the program:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter4/railAPI/main.go</strong></pre>
<ol start="10">
<li>Now, make a <kbd>curl</kbd> <kbd>POST</kbd> request to create a train:</li>
</ol>
<pre style="padding-left: 60px"><strong> curl -X POST \</strong><br/><strong>      http://localhost:8000/v1/trains \</strong><br/><strong>     -H 'cache-control: no-cache' \</strong><br/><strong>     -H 'content-type: application/json' \</strong><br/><strong>     -d '{"driverName": "Veronica", "operatingStatus": true}'</strong></pre>
<p style="padding-left: 60px">This creates a new train with the driver and operation status details. The response is the newly created resource with the train <kbd>ID</kbd> allocated:</p>
<pre style="padding-left: 60px">{<br/> "ID": 1,<br/> "DriverName": "Veronica",<br/> "OperatingStatus": true<br/> }</pre>
<ol start="11">
<li>Now, let's make a <kbd>curl</kbd> request to check <kbd>GET</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET "http://localhost:8000/v1/trains/1"</strong></pre>
<p style="padding-left: 60px">You will see the JSON output, as follows:</p>
<pre style="padding-left: 60px"><strong>{</strong><br/><strong> "ID": 1,</strong><br/><strong> "DriverName": "Veronica",</strong><br/><strong> "OperatingStatus": true</strong><br/><strong> }</strong></pre>
<p style="padding-left: 60px">We can use the same names for both posting data and JSON returned, but in order to show the difference between two operations, different variable names are used.</p>
<ol start="12">
<li>Now, delete the resource we created in the preceding code snippet with the <kbd>DELETE</kbd> API call:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X DELETE "http://localhost:8000/v1/trains/1"</strong></pre>
<p style="padding-left: 60px">It won't return any response body; it returns Status <kbd>200 OK</kbd> if the operation was successful.</p>
<ol start="13">
<li>Now, if we try to do <kbd>GET</kbd> on the <kbd>ID 1</kbd> train, then it returns us this response:</li>
</ol>
<pre style="padding-left: 60px"><strong>Train could not be found.</strong></pre>
<p>To support more API operations such as <kbd>PUT</kbd> and <kbd>PATCH</kbd>, we need to add two more routes to the web service in the <kbd>Register</kbd> method and define respective handlers. Here, we created a web service for <kbd>TrainResource</kbd>. In a similar way, web services can be created for doing CRUD operations on the <kbd>Station</kbd> and <kbd>Schedule</kbd> tables. That task is left as an exercise for the readers.</p>
<p><kbd>go-restful</kbd> is a lightweight library that is powerful in creating RESTful services in an elegant way. The main theme is to convert resources (models) into consumable APIs. Using other heavy frameworks may speed up the development, but the API can end up slower because of the wrapping of code. <kbd>go-restful</kbd> is a lean and low-level package for API creation.</p>
<p><kbd>go-restful</kbd> also provides built-in support for documenting the REST API with swagger. It is a tool that runs and generates templates for documenting the REST API we build. By integrating it with our <kbd>go-restful</kbd>-based web services, we can generate documentation on the fly. For more information, visit <a href="https://github.com/emicklei/go-restful-swagger12" target="_blank">https://github.com/emicklei/go-restful-swagger12</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building RESTful API with the Gin framework</h1>
                </header>
            
            <article>
                
<p>Gin-Gonic is a framework based on <kbd>httprouter</kbd>. We learned about <kbd>httprouter</kbd> in <a href="72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml" target="_blank">Chapter 2</a>, <em>Handling Routing for our REST Services</em>. It is an HTTP multiplexer like <kbd>gorilla/mux</kbd>, but it is faster. Gin allows a high-level API to create REST services in a clean way.</p>
<p>Gin can be compared to another web framework in Go called Martini. All web frameworks allow us to do a lot more things such as templates and web server design, in addition to service creation.</p>
<p>One can install the Gin package using the following command:</p>
<pre><strong>go get gopkg.in/gin-gonic/gin.v1</strong></pre>
<p>Let's write a simple hello world program in Gin to get familiarized with the Gin constructs:</p>
<ol>
<li class="mce-root"><span>First, create a file that holds our program:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter4/ginExample/main.go</strong></pre>
<ol start="2">
<li>Gin provides a <kbd>Default</kbd> method to create HTTP route/verb/handler combinations. It also provides a context object inside the handler function to easily operate on HTTP request and response. See an API created with Gin to request <kbd>serverT<span>ime </span>UTC</kbd> here:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>    "time"<br/>    "github.com/gin-gonic/gin"<br/>)<br/>func main() {<br/>    r := gin.Default()<br/>    r.GET("/pingTime", func(c *gin.Context) {<br/>        // JSON serializer is available on gin context<br/>        c.JSON(200, gin.H{<br/>            "serverTime": time.Now().UTC(),<br/>        })<br/>    })<br/>    r.Run(":8000") // Listen and serve on 0.0.0.0:8080<br/>}</pre>
<p style="padding-left: 60px">This simple server tries to implement a service that serves UTC server time to the clients. If you look carefully, Gin allows you to do a lot of stuff with just a few lines of code; all the boilerplate details such as route are taken away.</p>
<p style="padding-left: 60px">Coming to the program, we are creating a router with the <kbd>gin.Default</kbd> function. Then, we are attaching routes with REST verbs as we did in <kbd>go-restful</kbd>; a route to the function handler. Then, we are calling the <kbd>Run</kbd> function by passing the port to run. The default port will be <kbd>8080</kbd>.</p>
<p style="padding-left: 60px"><kbd>c</kbd> is a context variable that holds the information about the individual request. We can serialize data into JSON before sending it back to the client using the <kbd>context.JSON</kbd> function.</p>
<ol start="3">
<li>Now, if we run the <kbd>ginBasic</kbd> program:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter4/ginExample/main.go<br/></strong></pre>
<ol start="4">
<li>Make a <kbd><span>curl</span></kbd> request to see the response:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET "http://localhost:8000/pingTime"</strong><br/><br/>{"serverTime":"2020-02-27T19:08:05.470955Z"}</pre>
<p>At the same time, the Gin server console captures beautiful logs about HTTP requests to the server:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d90432a3-1fea-4d86-849e-0f5ad50b9d0d.png" style="width:42.92em;height:11.58em;"/></div>
<p>It is an Apache-style log showing <kbd>&lt;the endpoint, the latency of the request, and the REST method&gt;</kbd>.</p>
<p>In order to run Gin in production mode, set the <kbd>GIN_MODE=release</kbd> environment variable. Then the console output will be muted and log files can be used for monitoring the logs.</p>
<p>Now, let's write our Metro Rail API in Gin to show how to implement exactly the same API, but with a different framework. We use the same project layout, name the new project <kbd>railAPIGin</kbd>, and use the <kbd>dbutils</kbd> as it is. Let's look at the steps:</p>
<ol>
<li>First, let's prepare the imports for our program:</li>
</ol>
<div>
<pre style="padding-left: 60px">package main<br/>import (<br/>    "database/sql"<br/>    "log"<br/>    "net/http"<br/>    "github.com/gin-gonic/gin"<br/>    _ "github.com/mattn/go-sqlite3"<br/>    "github.com/git-user/chapter4/dbutils"<br/>)</pre></div>
<p style="padding-left: 60px">We imported <kbd>sqlite3</kbd> and <kbd>dbutils</kbd> for database-related actions. We imported <kbd>gin</kbd> for creating our API server. <kbd>net/http</kbd> is useful in providing the intuitive status codes to be sent along with the response.</p>
<ol start="2">
<li>let's define a struct to represent a station in program memory and a database driver:</li>
</ol>
<div>
<pre style="padding-left: 60px">// DB Driver visible to whole program<br/>var DB *sql.DB<br/>// StationResource holds information about locations<br/>type StationResource struct {<br/>    ID int `json:"id"`<br/>    Name string `json:"name"`<br/>    OpeningTime string `json:"opening_time"`<br/>    ClosingTime string `json:"closing_time"`<br/>}</pre></div>
<p><kbd>StationResource</kbd> is the placeholder for two kinds of data. First, for the POST body coming from an HTTP request, and second for data queried from the database. This is why it is slightly modified from the <kbd>railAPI</kbd> example of <kbd>go-restful</kbd>.</p>
<p>Now, let's write the handlers implementing the <kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd> methods for the station resource. We define CRUD handlers similar to the previous Metro Rail API <kbd>go-restful</kbd> example.</p>
<ol>
<li>The first handler is a <kbd>GET</kbd> handler. In <kbd>GetStation</kbd>, we use <kbd>c.Param</kbd> to strip the <kbd>station_id</kbd> path parameter. We use that value as an ID while querying a database record from the SQLite3 station table:</li>
</ol>
<pre style="padding-left: 60px">// GetStation returns the station detail<br/>func GetStation(c *gin.Context) {<br/>    var station StationResource<br/>    id := c.Param("station_id")<br/>    err := DB.QueryRow("select ID, NAME, CAST(OPENING_TIME as<br/>     CHAR), CAST(CLOSING_TIME as CHAR) from station where id=?",<br/>     id).Scan(&amp;station.ID, &amp;station.Name, &amp;station.OpeningTime,<br/>     &amp;station.ClosingTime)<br/>    if err != nil {<br/>        log.Println(err)<br/>        c.JSON(500, gin.H{<br/>            "error": err.Error(),<br/>        })<br/>    } else {<br/>        c.JSON(200, gin.H{<br/>            "result": station,<br/>        })<br/>    }<br/>}</pre>
<p style="padding-left: 60px">If you observe carefully, the SQL query is a bit different. We are using the <kbd>CAST</kbd> method to retrieve the <kbd>SQL TIME</kbd> field as a string for Go to consume properly. If you remove the casting, a panic error will be raised because we are trying to load a <kbd>TIME</kbd> field into the Go string at run time. To give you an idea, the TIME field looks like <kbd>8:00:00</kbd>, <kbd>17:31:12</kbd>, and so on. We are returning back the result using the <kbd>gin.H</kbd> method if there is no error.</p>
<ol start="2">
<li>In the <kbd>POST</kbd> handler, <kbd>CreateStation</kbd>, we perform a database insertion. We need to use the <kbd>c.BindJSON</kbd> function in Gin to extract data from the request body. This function loads the data into the struct that is passed as the argument. The idea is to load the station struct with body details. That is why <kbd>StationResource</kbd> has the JSON inference strings to tell what key values are expected. See the function body:</li>
</ol>
<pre style="padding-left: 60px">// CreateStation handles the POST<br/>func CreateStation(c *gin.Context) {<br/>    var station StationResource<br/>    // Parse the body into our resource<br/>    if err := c.BindJSON(&amp;station); err == nil {<br/>        // Format Time to Go time format<br/>        statement, _ := DB.Prepare("insert into station (NAME,<br/>         OPENING_TIME, CLOSING_TIME) values (?, ?, ?)")<br/>        result, _ := statement.Exec(station.Name,<br/>         station.OpeningTime, station.ClosingTime)<br/>        if err == nil {<br/>            newID, _ := result.LastInsertId()<br/>            station.ID = int(newID)<br/>            c.JSON(http.StatusOK, gin.H{<br/>                "result": station,<br/>            })<br/>        } else {<br/>            c.String(http.StatusInternalServerError, err.Error())<br/>        }<br/>    } else {<br/>        c.String(http.StatusInternalServerError, err.Error())<br/>    }<br/>}</pre>
<p style="padding-left: 60px">After collecting the data from a <kbd>POST</kbd> request body, we are preparing a database insert statement and executing it. The result is the ID of the inserted record. We are using that ID to send station details back to the client.</p>
<ol start="3">
<li>In the HTTP <kbd>DELETE</kbd> function handler <kbd>RemoveStation</kbd>, we should use a <kbd>DELETE</kbd> SQL query. If the operation is successful, we return a <kbd>200 OK</kbd> status back. Otherwise, we send the appropriate response back with a <kbd>500-Internal Server Error</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// RemoveStation handles the removing of resource<br/>func RemoveStation(c *gin.Context) {<br/>    id := c.Param("station-id")<br/>    statement, _ := DB.Prepare("delete from station where id=?")<br/>    _, err := statement.Exec(id)<br/>    if err != nil {<br/>        log.Println(err)<br/>        c.JSON(500, gin.H{<br/>            "error": err.Error(),<br/>        })<br/>    } else {<br/>        c.String(http.StatusOK, "")<br/>    }<br/>}</pre>
<p>Now comes the main program, which runs the database logic first to make sure tables are created. Then, it tries to create a Gin router and adds routes to it:</p>
<div>
<pre>func main() {<br/>    var err error<br/>    DB, err = sql.Open("sqlite3", "./railapi.db")<br/>    if err != nil {<br/>        log.Println("Driver creation failed!")<br/>    }<br/>    dbutils.Initialize(DB)<br/>    r := gin.Default()<br/>    // Add routes to REST verbs<br/>    r.GET("/v1/stations/:station_id", GetStation)<br/>    r.POST("/v1/stations", CreateStation)<br/>    r.DELETE("/v1/stations/:station_id", RemoveStation)<br/>    r.Run(":8000") // Default listen and serve on 0.0.0.0:8080<br/>}</pre></div>
<p>We are registering the <kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd> routes with the Gin router. Then, we are passing routes and handlers to them. Finally, we are starting the server using the <kbd>Run</kbd> function of Gin with <kbd>8000</kbd> as the port. Run the preceding program, as follows:</p>
<pre><strong>go run $GOPATH/src/github.com/git-user/chapter4/railAPIGin/main.go</strong> </pre>
<p class="mce-root"/>
<p>Now, we can create a new station by performing a <kbd>POST</kbd> request:</p>
<pre><strong>curl -X POST \</strong><br/><strong>  http://localhost:8000/v1/stations \</strong><br/><strong> -H 'cache-control: no-cache' \</strong><br/><strong> -H 'content-type: application/json' \</strong><br/><strong> -d '{"name":"Brooklyn", "opening_time":"8:12:00", "closing_time":"18:23:00"}'</strong></pre>
<p>It returns:</p>
<pre><strong>{"result":{"id":1,"name":"Brooklyn","opening_time":"8:12:00","closing_time":"18:23:00"}}</strong></pre>
<p>Now try to fetch the station details using <kbd>GET</kbd>:</p>
<pre><strong>CURL -X GET "http://localhost:8000/v1/stations/1"</strong><br/><br/><strong>Output</strong><br/><strong>======</strong><br/><strong>{"result":{"id":1,"name":"Brooklyn","opening_time":"8:12:00","closing_time":"18:23:00"}}</strong></pre>
<p>We can also delete the station record using the following command:</p>
<pre><strong>curl -X DELETE "http://localhost:8000/v1/stations/1"</strong></pre>
<p>It returns a <kbd>200 OK</kbd> status, confirming the resource was successfully deleted. As we already discussed, Gin provides intuitive debugging on the console, showing the attached handler, and highlighting the latency and REST verbs with colors:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8f0de0ec-2bdf-4e27-a642-3ee9e097d129.png" style="width:45.00em;height:16.83em;"/></div>
<p>For example, a <span class="packt_screen">200</span> is green, a <span class="packt_screen">404</span> is yellow, <span class="packt_screen">DELETE</span> is red, and so on. Gin provides many other features such as the categorization of routes, redirects, and middleware functions. </p>
<p>Use the Gin framework if you are quickly prototyping a REST web service. You can also use it for many other things such as static file serving, and so on. Remember that it is a fully-fledged web framework. For fetching the query parameters in Gin, use the following method on the Gin context object: <kbd>c.Query</kbd> (parameter).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a RESTful API with revel.go</h1>
                </header>
            
            <article>
                
<p><kbd>revel.go</kbd> is also a fully-fledged web framework like Python's Django. It is older than Gin and is termed as a highly productive web framework. It is an asynchronous, modular, and stateless framework. Unlike the <kbd>go-restful</kbd> and Gin frameworks where we created the project ourselves, Revel generates a scaffold for working directly:</p>
<ol>
<li>Install <kbd>revel.go</kbd> using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>go get github.com/revel/revel </strong><span> </span></pre>
<ol start="2">
<li>In order to run the scaffold tool, we should install one more supplementary package:</li>
</ol>
<pre style="padding-left: 60px"><strong>go get github.com/revel/cmd/revel</strong></pre>
<p style="padding-left: 60px">Make sure that <kbd>$GOPATH/bin</kbd> is in your PATH variable. Some external packages install the binary in the <kbd>$GOPATH/bin</kbd> directory. If it is in the path, we can access the executables system wide. Here, Revel installs a binary called <kbd>revel</kbd>.</p>
<ol start="3">
<li>On Ubuntu or <span>Mac OS X</span>, you can make sure to point Go binaries to the system path using this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>export PATH=$PATH:$GOPATH/bin</strong></pre>
<p style="padding-left: 60px">Add this export statement to <kbd>~/.bashrc</kbd> to save the setting permanently. On Windows, you have to directly call the executable by its location. Now we are ready to go with Revel.</p>
<ol start="4">
<li>Let's create a new project called <kbd>railAPIRevel</kbd> in <kbd>github.com/git-user/chapter4</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>revel new railAPIRevel</strong></pre>
<ol start="5">
<li>This creates a project scaffold without writing a single line of code. This is how web frameworks abstract things for quick prototyping. A Revel project layout tree looks like this:</li>
</ol>
<pre style="padding-left: 30px"><strong>    conf/             Configuration directory</strong><br/><strong>        app.conf      Main app configuration file</strong><br/><strong>        routes        Routes definition file</strong><br/><br/><strong>    app/              App sources</strong><br/><strong>        init.go       Interceptor registration</strong><br/><strong>        controllers/  App controllers go here</strong><br/><strong>        views/        Templates directory</strong><br/><br/><strong>    messages/         Message files</strong><br/><br/><strong>    public/           Public static assets</strong><br/><strong>        css/          CSS files</strong><br/><strong>        js/           Javascript files</strong><br/><strong>        images/       Image files</strong><br/><br/><strong>    tests/            Test suites</strong></pre>
<p>Out of all those boilerplate directories, three things are important for creating an API. Those are:</p>
<ul>
<li><kbd>app/controllers</kbd></li>
<li><kbd>conf/app.conf</kbd></li>
<li><kbd>conf/routes</kbd></li>
</ul>
<p>Controllers are the logic containers that execute the API logic. The <kbd>app.conf</kbd> file allows us to set the host, port, dev mode/production mode, and so on. <kbd>routes</kbd> defines the triple of the endpoint, REST verb, and function handler (here, controller's function). This is required for combining routes, verbs, and function handlers.</p>
<p>Let's use the same Rail API example we developed with <kbd>go-restful</kbd> and Gin. However, here, due to the redundancy, we drop the database logic. We will see shortly how to build <kbd>GET</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd> actions for the API using Revel:</p>
<ol>
<li>Now, modify the routes file to this:</li>
</ol>
<pre style="padding-left: 60px"><strong># Routes Config</strong><br/> <strong>#</strong><br/> <strong># This file defines all application routes (Higher priority routes<br/>   first)</strong><br/> <strong>#</strong><br/> <br/> <strong>module:testrunner</strong><br/> <strong># module:jobs</strong><br/> <br/> <br/> <strong>GET /v1/trains/:train-id                                                                                                App.GetTrain</strong><br/> <strong>POST /v1/trains                                                                                                        App.CreateTrain</strong><br/> <strong>DELETE /v1/trains/:train-id                                                                                            App.RemoveTrain</strong></pre>
<p style="padding-left: 60px">The syntax may look a bit new. It is a configuration file where we simply define a route in this format:</p>
<pre style="padding-left: 90px">VERB       END_POINT         HANDLER</pre>
<p style="padding-left: 60px"><kbd>VERB</kbd> is a REST verb, <kbd>END_POINT</kbd> is the API endpoint, and <kbd>HANDLER</kbd> is the name of the function that processes requests.</p>
<p style="padding-left: 60px">We haven't defined handlers yet. In the endpoint, the path parameters are accessed using the :param notation. This means for a <kbd>GET</kbd> request to the server, <kbd>train-id</kbd> will be passed as the path parameter.</p>
<ol start="2">
<li>Now, navigate to the <kbd>controllers</kbd> folder and modify the existing controller in the <kbd>app.go</kbd> file.</li>
<li>We first create a <kbd>struct</kbd> that represents our application context. let's name it <kbd>App</kbd>. We should also define another struct for <kbd>TrainResource</kbd> <span>that holds rail information:</span></li>
</ol>
<pre style="padding-left: 60px">type App struct {<br/>    *revel.Controller<br/>}<br/>// TrainResource is the model for holding rail information<br/>type TrainResource struct {<br/>    ID int `json:"id"`<br/>    DriverName string `json:"driver_name"`<br/>    OperatingStatus bool `json:"operating_status"`<br/>}</pre>
<ol start="4">
<li>Now let's define CRUD handlers in Revel. First is <kbd>GetTrain</kbd>. Why a capital lettered name for a controller? Because Revel expects controllers to be exported out of the package. Go packages only export names starting with capital letters. The controller accesses the path parameter to get a train ID and uses it to query the database. Here we are mocking the database result for brevity:</li>
</ol>
<div>
<pre style="padding-left: 60px">// GetTrain handles GET on train resource<br/>func (c App) GetTrain() revel.Result {<br/>    var train TrainResource<br/>    // Getting the values from path parameters.<br/>    id := c.Params.Route.Get("train-id")<br/>    // use this ID to query from database and fill train table....<br/>    train.ID, _ = strconv.Atoi(id)<br/>    train.DriverName = "Logan" // Comes from DB<br/>    train.OperatingStatus = true // Comes from DB<br/>    c.Response.Status = http.StatusOK<br/>    return c.RenderJSON(train)<br/>}</pre></div>
<ol start="5">
<li>In <kbd>CreateTrain</kbd>, we add the <kbd>POST</kbd> request logic. We should create an object of <kbd>TrainResource</kbd> struct and pass it to a function called <kbd>c.Params.BindJSON</kbd>. JSON tags(<kbd>'json:"id"`</kbd>) gives us the flexibility of defining output fields. This is a good practice in Go while working with JSON. Then, we return an HTTP response with <kbd>201 created</kbd> status. We can use the <kbd>RenderJSON</kbd> method on context to marshal a struct to JSON on the fly:</li>
</ol>
<pre style="padding-left: 60px">// CreateTrain handles POST on train resource<br/>func (c App) CreateTrain() revel.Result {<br/>    var train TrainResource<br/>    c.Params.BindJSON(&amp;train)<br/>    // Use train.DriverName and train.OperatingStatus<br/>    // to insert into train table....<br/>    train.ID = 2<br/>    c.Response.Status = http.StatusCreated<br/>    return c.RenderJSON(train)<br/>}</pre>
<p class="mce-root"/>
<ol start="6">
<li>The <kbd>RemoveTrain</kbd> handler logic is similar to that of <kbd>GET</kbd>. A subtle difference is that nothing is sent in the body. As we previously mentioned, database CRUD logic is omitted from the preceding example. It is an exercise for readers to try adding SQLite3 logic by observing what we have done in the <kbd>go-restful</kbd> and Gin sections:</li>
</ol>
<pre style="padding-left: 60px">// RemoveTrain implements DELETE on train resource<br/>func (c App) RemoveTrain() revel.Result {<br/>    id := c.Params.Route.Get("train-id")<br/>    // Use ID to delete record from train table....<br/>    log.Println("Successfully deleted the resource:", id)<br/>    c.Response.Status = http.StatusOK<br/>    return c.RenderText("")<br/>}</pre>
<ol start="7">
<li>Finally, the default port on which the Revel server runs is <kbd>9000</kbd>. The configuration to change the port number is in the <kbd>conf/app.conf</kbd> file. Let's follow the tradition of running our app on <kbd>8000</kbd>. So, modify the HTTP port section of <kbd>app.conf</kbd> to the following. This tells the Revel server to run on a different port:</li>
</ol>
<pre style="padding-left: 60px"><strong>......</strong><br/><strong># The IP address on which to listen.</strong><br/><strong>http.addr =</strong><br/><br/><strong># The port on which to listen.</strong><br/><strong>http.port = 8000 # Change from 9000 to 8000 or any port</strong><br/><br/><strong># Whether to use SSL or not.</strong><br/><strong>http.ssl = false</strong><br/><strong>......</strong></pre>
<ol start="8">
<li>Now, we can run our Revel API server using this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>revel run github.com/git-user/chapter4/railAPIRevel</strong></pre>
<ol start="9">
<li>Our app server starts at <kbd>http://localhost:8000</kbd>. Now, let's make a few API requests:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET "http://localhost:8000/v1/trains/1"</strong><br/><br/><strong>Output</strong><br/><strong>=======</strong><br/><strong>{</strong><br/><strong> "id": 1,</strong><br/><strong> "driver_name": "Logan",</strong><br/><strong> "operating_status": true</strong><br/><strong>}</strong></pre>
<p style="padding-left: 60px"><kbd>POST</kbd> request:</p>
<pre style="padding-left: 60px"><strong>curl -X POST \</strong><br/><strong>   http://localhost:8000/v1/trains \</strong><br/><strong>   -H 'cache-control: no-cache' \</strong><br/><strong>   -H 'content-type: application/json' \</strong><br/><strong>   -d '{"driver_name":"Magneto", "operating_status": true}'</strong><br/><br/><strong>Output</strong><br/><strong>======</strong><br/><strong>{</strong><br/><strong> "id": 2,</strong><br/><strong> "driver_name": "Magneto",</strong><br/><strong> "operating_status": true</strong><br/><strong>}</strong></pre>
<p><kbd>DELETE</kbd> is the same as <kbd>GET</kbd>, but no body is returned. Here, the code is illustrated to show how to handle the request and response. Remember, Revel is more than a simple API framework. It is a fully-fledged web framework similar to Django (Python) or Ruby on Rails. We have got templates, tests, and many more bundled in <kbd>revel.go</kbd>. It is mainly used for web development, but one can also use it to quickly develop a REST API.</p>
<p>Make sure that you create a new Revel project for <kbd>GOPATH/user</kbd>, otherwise, your Revel command-line tool may not find the project while running the project.</p>
<p>There is middleware support in all the web frameworks we saw in this chapter. <kbd>go-restful</kbd> names its middleware Filters, whereas Gin names them Custom Middleware, and Revel calls its middleware, Interceptors. A middleware reads or writes the request and response before and after a function handler, respectively.</p>
<p>In <a href="ab89bca5-b60d-4681-bc36-23ee51a56cc6.xhtml" target="_blank">Chapter 3</a>, <em>Working with Middleware and RPC</em>, we have already briefly <span>discussed </span>middleware.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary </h1>
                </header>
            
            <article>
                
<p>In this chapter, we built a Metro Rail API with the help of a few web frameworks available in Go. The most popular ones are <kbd>go-restful</kbd>, Gin Gonic, and <kbd>revel.go</kbd>. We have introduced a database layer in this chapter. We chose SQLite3 and tried to write a sample application using the <kbd>go-sqlite3</kbd> library.</p>
<p>We then explored <kbd>go-restful</kbd> and looked in detail at how to create routes and handlers. <kbd>go-restful</kbd> has the concept of building APIs on top of resources. We explained why <kbd>go-restful</kbd> is lightweight and can be used to create low-latency APIs.</p>
<p>Next, we introduced the Gin framework and tried to re-implement the <kbd>railAPI</kbd>. Finally, we tried to create another API on the train resource, but this time with the <kbd>revel.go</kbd> web framework. Revel is a framework that is similar to Django and Ruby on Rails. It provides scaffolding for most of the server needs such as routing, handlers, and middleware.</p>
<p>The main theme of this chapter is to suggest you use available frameworks for REST API development. Use <kbd>revel.go</kbd> when you have an end-to-end web application (templates and UI) in addition to the REST API, use Gin to quickly create REST services, and use <kbd>go-restful</kbd> when the performance of the API is critical. </p>
<p>We also worked with a relational database in the form of SQLite3. In the next chapter, we introduce a popular non-relational database called MongoDB for building an API.</p>


            </article>

            
        </section>
    </body></html>