["```go\n> apt-get install sqlite3 libsqlite3-dev\n```", "```go\n> brew install sqlite3\n```", "```go\n> go get github.com/emicklei/go-restful\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter4/basicExample/main.go\n```", "```go\nfunc pingTime(req *restful.Request, resp *restful.Response) {\n // Write to the response\n io.WriteString(resp, fmt.Sprintf(\"%s\", time.Now()))\n}\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"github.com/emicklei/go-restful\"\n    \"io\"\n    \"net/http\"\n    \"time\"\n)\nfunc main() {\n    // Create a web service\n    webservice := new(restful.WebService)\n    // Create a route and attach it to handler in the service\n    webservice.Route(webservice.GET(\"/ping\").To(pingTime))\n    // Add the service to application\n    restful.Add(webservice)\n    http.ListenAndServe(\":8000\", nil)\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter4/basicExample/main.go\n```", "```go\ncurl -X GET \"http://localhost:8000/ping\"\n2020-01-01 07:37:26.238146296 +0530 CET\n```", "```go\nwebservice.GET(\"/ping\")\n```", "```go\nrestful.Add(webservice)\n```", "```go\ngo get github.com/mattn/go-sqlite3\n```", "```go\nimport \"database/sql\"\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter4/sqliteExample/main.go\n```", "```go\npackage main\n\nimport (\n  \"database/sql\"\n  \"log\"\n\n  _ \"github.com/mattn/go-sqlite3\"\n)\n\n// Book is a placeholder for book\ntype Book struct {\n  id int\n  name string\n  author string\n}\n\nfunc main() {\n  db, err := sql.Open(\"sqlite3\", \"./books.db\")\n  if err != nil {\n    log.Println(err)\n  }\n  // Create table\n  statement, err := db.Prepare(\"CREATE TABLE IF NOT EXISTS books\n   (id INTEGER PRIMARY KEY, isbn INTEGER, author VARCHAR(64),\n    name VARCHAR(64) NULL)\")\n  if err != nil {\n    log.Println(\"Error in creating table\")\n  } else {\n    log.Println(\"Successfully created table books!\")\n  }\n  statement.Exec()\n  dbOperations(db)\n}\n```", "```go\nfunc dbOperations(db *sql.DB) {\n  // Create\n  statement, _ := db.Prepare(\"INSERT INTO books (name, author,\n   isbn) VALUES (?, ?, ?)\")\n  statement.Exec(\"A Tale of Two Cities\", \"Charles Dickens\",\n   140430547)\n  log.Println(\"Inserted the book into database!\")\n\n  // Read\n  rows, _ := db.Query(\"SELECT id, name, author FROM books\")\n  var tempBook Book\n  for rows.Next() {\n    rows.Scan(&tempBook.id, &tempBook.name, &tempBook.author)\n    log.Printf(\"ID:%d, Book:%s, Author:%s\\n\", tempBook.id,\n     tempBook.name, tempBook.author)\n  }\n  // Update\n  statement, _ = db.Prepare(\"update books set name=? where id=?\")\n  statement.Exec(\"The Tale of Two Cities\", 1)\n  log.Println(\"Successfully updated the book in database!\")\n\n  //Delete\n  statement, _ = db.Prepare(\"delete from books where id=?\")\n  statement.Exec(1)\n  log.Println(\"Successfully deleted the book in database!\")\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter4/sqliteExample/main.go\n```", "```go\n2017/06/10 08:04:31 Successfully created table books!\n2017/06/10 08:04:31 Inserted the book into database!\n2017/06/10 08:04:31 ID:1, Book:A Tale of Two Cities, Author:Charles Dickens\n2017/06/10 08:04:31 Successfully updated the book in database!\n2017/06/10 08:04:31 Successfully deleted the book in database!\n```", "```go\nstatement, _ = db.Prepare(\"INSERT INTO books (name, author, isbn) VALUES (?, ?, ?)\")\nstatement.Exec(\"A Tale of Two Cities\", \"Charles Dickens\", 140430547)\n```", "```go\npackage dbutils\n\nconst train = `\n      CREATE TABLE IF NOT EXISTS train (\n           ID INTEGER PRIMARY KEY AUTOINCREMENT,\n           DRIVER_NAME VARCHAR(64) NULL,\n           OPERATING_STATUS BOOLEAN\n        )\n`\n\nconst station = `\n        CREATE TABLE IF NOT EXISTS station (\n          ID INTEGER PRIMARY KEY AUTOINCREMENT,\n          NAME VARCHAR(64) NULL,\n          OPENING_TIME TIME NULL,\n          CLOSING_TIME TIME NULL\n        )\n`\nconst schedule = `\n        CREATE TABLE IF NOT EXISTS schedule (\n          ID INTEGER PRIMARY KEY AUTOINCREMENT,\n          TRAIN_ID INT,\n          STATION_ID INT,\n          ARRIVAL_TIME TIME,\n          FOREIGN KEY (TRAIN_ID) REFERENCES train(ID),\n          FOREIGN KEY (STATION_ID) REFERENCES station(ID)\n        )\n`\n```", "```go\npackage dbutils\nimport \"log\"\nimport \"database/sql\"\n\nfunc Initialize(dbDriver *sql.DB) {\n    statement, driverError := dbDriver.Prepare(train)\n    if driverError != nil {\n        log.Println(driverError)\n    }\n    // Create train table\n    _, statementError := statement.Exec()\n    if statementError != nil {\n        log.Println(\"Table already exists!\")\n    }\n    statement, _ = dbDriver.Prepare(station)\n    statement.Exec()\n    statement, _ = dbDriver.Prepare(schedule)\n    statement.Exec()\n    log.Println(\"All tables created/initialized successfully!\")\n}\n```", "```go\ngo build $GOPATH/src/github.com/git-user/chapter4/dbutils\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter4/railAPI/main.go\n```", "```go\npackage main\n\nimport (\n    \"database/sql\"\n    \"log\"\n\n    _ \"github.com/mattn/go-sqlite3\"\n    \"github.com/git-user/chapter4/dbutils\"\n)\n\nfunc main() {\n    // Connect to Database\n    db, err := sql.Open(\"sqlite3\", \"./railapi.db\")\n    if err != nil {\n        log.Println(\"Driver creation failed!\")\n    }\n    // Create tables\n    dbutils.Initialize(db)\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter4/railAPI/main.go\n```", "```go\n2020/01/10 14:05:36 All tables created/initialized successfully!\n```", "```go\npackage main\nimport (\n    \"database/sql\"\n    \"encoding/json\"\n    \"log\"\n    \"net/http\"\n    \"time\"\n    \"github.com/emicklei/go-restful\"\n    _ \"github.com/mattn/go-sqlite3\"\n    \"github.com/git-user/chapter4/dbutils\"\n)\n```", "```go\n// DB Driver visible to whole program\nvar DB *sql.DB\n\n// TrainResource is the model for holding rail information\ntype TrainResource struct {\n    ID int\n    DriverName string\n    OperatingStatus bool\n}\n// StationResource holds information about locations\ntype StationResource struct {\n    ID int\n    Name string\n    OpeningTime time.Time\n    ClosingTime time.Time\n}\n// ScheduleResource links both trains and stations\ntype ScheduleResource struct {\n    ID int\n    TrainID int\n    StationID int\n    ArrivalTime time.Time\n}\n```", "```go\n// Register adds paths and routes to a new service instance\nfunc (t *TrainResource) Register(container *restful.Container) {\n    ws := new(restful.WebService)\n    ws.Path(\"/v1/trains\").Consumes(restful.MIME_JSON).Produces\n    (restful.MIME_JSON)\n    ws.Route(ws.GET(\"/{train-id}\").To(t.getTrain))\n    ws.Route(ws.POST(\"\").To(t.createTrain))\n    ws.Route(ws.DELETE(\"/{train-id}\").To(t.removeTrain))\n    container.Add(ws)\n}\n```", "```go\nws.Path(\"/v1/trains\").Consumes(restful.MIME_JSON).Produces(restful.MIME_JSON)\n```", "```go\n// GET http://localhost:8000/v1/trains/1\nfunc (t TrainResource) getTrain(request *restful.Request,\n response *restful.Response) {\n    id := request.PathParameter(\"train-id\")\n    err := DB.QueryRow(\"select ID, DRIVER_NAME, OPERATING_STATUS\n     FROM train where id=?\", id).Scan(&t.ID, &t.DriverName,\n     &t.OperatingStatus)\n    if err != nil {\n        log.Println(err)\n        response.AddHeader(\"Content-Type\", \"text/plain\")\n        response.WriteErrorString(http.StatusNotFound, \"Train could\n         not be found.\")\n    } else {\n        response.WriteEntity(t)\n    }\n}\n```", "```go\n\n// POST http://localhost:8000/v1/trains\nfunc (t TrainResource) createTrain(request *restful.Request, response *restful.Response) {\n    log.Println(request.Request.Body)\n    decoder := json.NewDecoder(request.Request.Body)\n    var b TrainResource\n    err := decoder.Decode(&b)\n    log.Println(b.DriverName, b.OperatingStatus)\n    // Error handling is obvious here. So omitting...\n    statement, _ := DB.Prepare(\"insert into train (DRIVER_NAME,\n     OPERATING_STATUS) values (?, ?)\")\n    result, err := statement.Exec(b.DriverName, b.OperatingStatus)\n    if err == nil {\n        newID, _ := result.LastInsertId()\n        b.ID = int(newID)\n        response.WriteHeaderAndEntity(http.StatusCreated, b)\n    } else {\n        response.AddHeader(\"Content-Type\", \"text/plain\")\n        response.WriteErrorString(http.StatusInternalServerError,\n        err.Error())\n    }\n}\n```", "```go\n// DELETE http://localhost:8000/v1/trains/1\nfunc (t TrainResource) removeTrain(request *restful.Request, response *restful.Response) {\n    id := request.PathParameter(\"train-id\")\n    statement, _ := DB.Prepare(\"delete from train where id=?\")\n    _, err := statement.Exec(id)\n    if err == nil {\n        response.WriteHeader(http.StatusOK)\n    } else {\n        response.AddHeader(\"Content-Type\", \"text/plain\")\n        response.WriteErrorString(http.StatusInternalServerError,\n        err.Error())\n    }\n}\n```", "```go\nfunc main() {\n    var err error\n    DB, err = sql.Open(\"sqlite3\", \"./railapi.db\")\n    if err != nil {\n        log.Println(\"Driver creation failed!\")\n    }\n    dbutils.Initialize(DB)\n    wsContainer := restful.NewContainer()\n    wsContainer.Router(restful.CurlyRouter{})\n    t := TrainResource{}\n    t.Register(wsContainer)\n    log.Printf(\"start listening on localhost:8000\")\n    server := &http.Server{Addr: \":8000\", Handler: wsContainer}\n    log.Fatal(server.ListenAndServe())\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter4/railAPI/main.go\n```", "```go\n curl -X POST \\\n http://localhost:8000/v1/trains \\\n -H 'cache-control: no-cache' \\\n -H 'content-type: application/json' \\\n -d '{\"driverName\": \"Veronica\", \"operatingStatus\": true}'\n```", "```go\n{\n \"ID\": 1,\n \"DriverName\": \"Veronica\",\n \"OperatingStatus\": true\n }\n```", "```go\ncurl -X GET \"http://localhost:8000/v1/trains/1\"\n```", "```go\n{\n \"ID\": 1,\n \"DriverName\": \"Veronica\",\n \"OperatingStatus\": true\n }\n```", "```go\ncurl -X DELETE \"http://localhost:8000/v1/trains/1\"\n```", "```go\nTrain could not be found.\n```", "```go\ngo get gopkg.in/gin-gonic/gin.v1\n```", "```go\ntouch -p $GOPATH/src/github.com/git-user/chapter4/ginExample/main.go\n```", "```go\npackage main\n\nimport (\n    \"time\"\n    \"github.com/gin-gonic/gin\"\n)\nfunc main() {\n    r := gin.Default()\n    r.GET(\"/pingTime\", func(c *gin.Context) {\n        // JSON serializer is available on gin context\n        c.JSON(200, gin.H{\n            \"serverTime\": time.Now().UTC(),\n        })\n    })\n    r.Run(\":8000\") // Listen and serve on 0.0.0.0:8080\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter4/ginExample/main.go \n```", "```go\ncurl -X GET \"http://localhost:8000/pingTime\"\n\n{\"serverTime\":\"2020-02-27T19:08:05.470955Z\"}\n```", "```go\npackage main\nimport (\n    \"database/sql\"\n    \"log\"\n    \"net/http\"\n    \"github.com/gin-gonic/gin\"\n    _ \"github.com/mattn/go-sqlite3\"\n    \"github.com/git-user/chapter4/dbutils\"\n)\n```", "```go\n// DB Driver visible to whole program\nvar DB *sql.DB\n// StationResource holds information about locations\ntype StationResource struct {\n    ID int `json:\"id\"`\n    Name string `json:\"name\"`\n    OpeningTime string `json:\"opening_time\"`\n    ClosingTime string `json:\"closing_time\"`\n}\n```", "```go\n// GetStation returns the station detail\nfunc GetStation(c *gin.Context) {\n    var station StationResource\n    id := c.Param(\"station_id\")\n    err := DB.QueryRow(\"select ID, NAME, CAST(OPENING_TIME as\n     CHAR), CAST(CLOSING_TIME as CHAR) from station where id=?\",\n     id).Scan(&station.ID, &station.Name, &station.OpeningTime,\n     &station.ClosingTime)\n    if err != nil {\n        log.Println(err)\n        c.JSON(500, gin.H{\n            \"error\": err.Error(),\n        })\n    } else {\n        c.JSON(200, gin.H{\n            \"result\": station,\n        })\n    }\n}\n```", "```go\n// CreateStation handles the POST\nfunc CreateStation(c *gin.Context) {\n    var station StationResource\n    // Parse the body into our resource\n    if err := c.BindJSON(&station); err == nil {\n        // Format Time to Go time format\n        statement, _ := DB.Prepare(\"insert into station (NAME,\n         OPENING_TIME, CLOSING_TIME) values (?, ?, ?)\")\n        result, _ := statement.Exec(station.Name,\n         station.OpeningTime, station.ClosingTime)\n        if err == nil {\n            newID, _ := result.LastInsertId()\n            station.ID = int(newID)\n            c.JSON(http.StatusOK, gin.H{\n                \"result\": station,\n            })\n        } else {\n            c.String(http.StatusInternalServerError, err.Error())\n        }\n    } else {\n        c.String(http.StatusInternalServerError, err.Error())\n    }\n}\n```", "```go\n// RemoveStation handles the removing of resource\nfunc RemoveStation(c *gin.Context) {\n    id := c.Param(\"station-id\")\n    statement, _ := DB.Prepare(\"delete from station where id=?\")\n    _, err := statement.Exec(id)\n    if err != nil {\n        log.Println(err)\n        c.JSON(500, gin.H{\n            \"error\": err.Error(),\n        })\n    } else {\n        c.String(http.StatusOK, \"\")\n    }\n}\n```", "```go\nfunc main() {\n    var err error\n    DB, err = sql.Open(\"sqlite3\", \"./railapi.db\")\n    if err != nil {\n        log.Println(\"Driver creation failed!\")\n    }\n    dbutils.Initialize(DB)\n    r := gin.Default()\n    // Add routes to REST verbs\n    r.GET(\"/v1/stations/:station_id\", GetStation)\n    r.POST(\"/v1/stations\", CreateStation)\n    r.DELETE(\"/v1/stations/:station_id\", RemoveStation)\n    r.Run(\":8000\") // Default listen and serve on 0.0.0.0:8080\n}\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter4/railAPIGin/main.go \n```", "```go\ncurl -X POST \\\n http://localhost:8000/v1/stations \\\n -H 'cache-control: no-cache' \\\n -H 'content-type: application/json' \\\n -d '{\"name\":\"Brooklyn\", \"opening_time\":\"8:12:00\", \"closing_time\":\"18:23:00\"}'\n```", "```go\n{\"result\":{\"id\":1,\"name\":\"Brooklyn\",\"opening_time\":\"8:12:00\",\"closing_time\":\"18:23:00\"}}\n```", "```go\nCURL -X GET \"http://localhost:8000/v1/stations/1\"\n\nOutput\n======\n{\"result\":{\"id\":1,\"name\":\"Brooklyn\",\"opening_time\":\"8:12:00\",\"closing_time\":\"18:23:00\"}}\n```", "```go\ncurl -X DELETE \"http://localhost:8000/v1/stations/1\"\n```", "```go\ngo get github.com/revel/revel  \n```", "```go\ngo get github.com/revel/cmd/revel\n```", "```go\nexport PATH=$PATH:$GOPATH/bin\n```", "```go\nrevel new railAPIRevel\n```", "```go\n conf/             Configuration directory\n app.conf      Main app configuration file\n routes        Routes definition file\n\n app/              App sources\n init.go       Interceptor registration\n controllers/  App controllers go here\n views/        Templates directory\n\n messages/         Message files\n\n public/           Public static assets\n css/          CSS files\n js/           Javascript files\n images/       Image files\n\n tests/            Test suites\n```", "```go\n# Routes Config\n #\n # This file defines all application routes (Higher priority routes\n   first)\n #\n\n module:testrunner\n # module:jobs\n\n GET /v1/trains/:train-id                                                                                                App.GetTrain\n POST /v1/trains                                                                                                        App.CreateTrain\n DELETE /v1/trains/:train-id                                                                                            App.RemoveTrain\n```", "```go\nVERB       END_POINT         HANDLER\n```", "```go\ntype App struct {\n    *revel.Controller\n}\n// TrainResource is the model for holding rail information\ntype TrainResource struct {\n    ID int `json:\"id\"`\n    DriverName string `json:\"driver_name\"`\n    OperatingStatus bool `json:\"operating_status\"`\n}\n```", "```go\n// GetTrain handles GET on train resource\nfunc (c App) GetTrain() revel.Result {\n    var train TrainResource\n    // Getting the values from path parameters.\n    id := c.Params.Route.Get(\"train-id\")\n    // use this ID to query from database and fill train table....\n    train.ID, _ = strconv.Atoi(id)\n    train.DriverName = \"Logan\" // Comes from DB\n    train.OperatingStatus = true // Comes from DB\n    c.Response.Status = http.StatusOK\n    return c.RenderJSON(train)\n}\n```", "```go\n// CreateTrain handles POST on train resource\nfunc (c App) CreateTrain() revel.Result {\n    var train TrainResource\n    c.Params.BindJSON(&train)\n    // Use train.DriverName and train.OperatingStatus\n    // to insert into train table....\n    train.ID = 2\n    c.Response.Status = http.StatusCreated\n    return c.RenderJSON(train)\n}\n```", "```go\n// RemoveTrain implements DELETE on train resource\nfunc (c App) RemoveTrain() revel.Result {\n    id := c.Params.Route.Get(\"train-id\")\n    // Use ID to delete record from train table....\n    log.Println(\"Successfully deleted the resource:\", id)\n    c.Response.Status = http.StatusOK\n    return c.RenderText(\"\")\n}\n```", "```go\n......\n# The IP address on which to listen.\nhttp.addr =\n\n# The port on which to listen.\nhttp.port = 8000 # Change from 9000 to 8000 or any port\n\n# Whether to use SSL or not.\nhttp.ssl = false\n......\n```", "```go\nrevel run github.com/git-user/chapter4/railAPIRevel\n```", "```go\ncurl -X GET \"http://localhost:8000/v1/trains/1\"\n\nOutput\n=======\n{\n \"id\": 1,\n \"driver_name\": \"Logan\",\n \"operating_status\": true\n}\n```", "```go\ncurl -X POST \\\n http://localhost:8000/v1/trains \\\n -H 'cache-control: no-cache' \\\n -H 'content-type: application/json' \\\n -d '{\"driver_name\":\"Magneto\", \"operating_status\": true}'\n\nOutput\n======\n{\n \"id\": 2,\n \"driver_name\": \"Magneto\",\n \"operating_status\": true\n}\n```"]