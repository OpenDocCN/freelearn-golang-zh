- en: Simplifying RESTful Services with Popular Go Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to use different frameworks for simplifying the
    process of building REST services. First, we will take a quick look at `go-restful`,
    a REST API creation framework, and then move to a framework called Gin. We will
    build a Metro Rail API in this chapter. The frameworks that we will discuss are
    fully-fledged web frameworks that can also be used to create REST APIs in a short
    time. We will also talk a lot about resources and REST verbs in this chapter.
    We will then try to integrate a small database called SQLite3 with our API. Finally,
    we explore `revel.go` and see how to prototype our REST API with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go-restful` – a framework for REST API creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite3 basics and CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Metro Rail API with `go-restful`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a RESTful API with the Gin framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a RESTful API with `revel.go`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the software that should be pre-installed for running code
    samples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X  >=10.13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Software: Docker >= 18 (Docker Desktop for Windows and Mac OS X)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go latest version compiler >= 1.13.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter4](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter4).
    Clone the code and use the code samples in the `chapter4` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing go-restful – a REST API framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`go-restful` is a package for building REST-style web services in Go. REST,
    as we discussed in [Chapter 1](eb93f11e-bb80-40dc-873c-e350560467db.xhtml), *Getting
    Started with REST API Development*, asks developers to follow a set of design
    protocols. There we also discussed how the REST verbs are defined and what they
    do to the resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `go-restful`, we can separate the logic for API handlers and attach REST
    verbs. The benefit is that it clearly shows what resources are manipulated by
    looking at the code. Before jumping into an example, we have to install a database
    called SQLite3 for our REST API with `go-restful`. The installation steps are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the dependencies for the `go-restful` package. On Ubuntu, run
    this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On Mac OS X, you can use the `brew` command to install `sqlite3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, install the `go-restful` package with the following `get` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On Windows OS, you can download the SQLite3 executable from [https://www.sqlite.org](https://www.sqlite.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to go. First, let''s write a simple program showing what `go-restful`
    can do in a few lines of code. It provides a `WebService` using which we can attach
    a route to a handler. The use case is to create a simple ping server that echoes
    the server time back to the client. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `basicExample.go` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a function that writes  the server time to the response. It takes
    `Request` and `Response` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `pingTime` handler is straightforward and simply writes a server time to
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to create an instance of `restful.WebService` to attach a given route
    to a verb and a handler. See how we can do it in the following `main` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will be running on port `8000` of localhost. So, we can either make
    a `curl` request or use a browser to see the `GET` request output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we imported the `go-restful` library and created a
    new service using an instance of the `restful.WebService` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a REST verb using the following statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then attach a function handler to execute this verb; `pingTime` is one such
    function. These chained functions are passed to a `Route` function to create a
    router. Then comes the following important statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This registers the newly created `webservice` with `go-restful`. If you observe,
    we are not passing any `ServeMux` objects to the `http.ListenServe` function;
    `go-restful` will take care of it.
  prefs: []
  type: TYPE_NORMAL
- en: The main concept here is to use the resource-based REST API creation in `go-restful`.
    Going from the basic example, let's build something practical.
  prefs: []
  type: TYPE_NORMAL
- en: Take a scenario where your city is getting a new Metro Rail project and you
    have to develop a REST API for other developers to create apps around it. We will
    create one such API in this chapter and use various frameworks to show the implementation.
    Before that, for **Create**, **Read**, **Update**, **Delete** (**CRUD**) operations,
    we should know how to query or insert data into a database with Go code. We pick
    the simplest one called SQLite3 and discuss it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite3 basics and CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SQLite3** is a lightweight, file-based SQL database. It is very useful to
    quickly build persistence for API. It leverages the SQL language and a relational
    database. In this section, we see how to interact with SQLite3 from Go.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All SQLite3 operations are going to be done using the `go-sqlite3` library.
    We can install that package using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The special thing about this library is that it uses the internal `sql` package
    of Go. We usually import `database/sql` and use SQL to execute database queries
    on the database (here, SQLite3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the following steps to create a database driver and then execute
    the SQL commands on it using the `Query` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file in this path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the main block that creates a table if none exists and calls
    another function for CRUD operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a database called `books.db` and execute a SQL statement for
    creating a `books` table. We created a SQL statement with the `db.Prepare` method.
    Then we executed it using the statement's `Exec` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you notice, we called the `dbOperations` function for performing CRUD operations.
    In that function, we create a book, read it, then update, and then delete it.
    Let''s see the implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `Prepare` function, now we have another `Query` method. This
    is mainly used for reading data from a database. `Exec` is a common function for
    executing a prepared/queried statement on SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: A Prepare statement is for performing actions on a database that causes a change
    in the database, and Query is for read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the `sqliteFunamentals` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like the following, printing all the log statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an important thing related to security while running queries. Take
    a statement from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you pass incorrect values, such as strings that cause SQL injection, the
    driver rejects the SQL operation instantly. This is to avoid any raw strings being
    executed by the database engine. It could be dangerous as SQL can do anything,
    even dropping a database. Always prepare the statement first and then pass the
    necessary details.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we try to build an example API with `go-restful` and SQLite3.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Metro Rail API with go-restful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the knowledge of `go-restful` and SQLite3 we have gained and create
    an API for the Metro Rail project we talked about in the preceding section. The
    road map is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Design a REST API document
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create models for a database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the API logic
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's understand each of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Design specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before creating any API, we should know what the specifications of APIs are
    in the form of a document. We showed an example in [Chapter 2](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml),
    *Handling Routing for our REST Services*, where we showed the URL shortener API
    design document. Let''s try to create one for this Metro Rail project. Take a
    look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Path** | **Action** | **Resource** |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/v1/train (details as JSON body)` | `Create` | `Train` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/v1/station (details as JSON body)` | `Create` | `Station` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/v1/train/id ` | `Read` | `Train` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/v1/station/id` | `Read` | `Station` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/v1/schedule (source and destination)` | `Create` | `Route` |'
  prefs: []
  type: TYPE_TB
- en: We can also include the `UPDATE` and `DELETE` methods. By implementing the preceding
    design, it will be obvious for users to implement them on their own.
  prefs: []
  type: TYPE_NORMAL
- en: Creating database models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write a few SQL strings for creating the tables for the preceding `train`,
    `station`, and `route` resources. We are going to create a project layout for
    this API. Create two directories called `railAPI` and `dbutils` in `$GOPATH/src/github.com/git-user/chapter4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `railAPI` is our project source, and `dbutils` is our own package for
    handling database initialization utility functions. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `dbutils/models.go` file. Add three models each for `train`,
    `station`, and `schedule` in the `models.go` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These are plain multi-line strings that are delimited by the back tick `` `
    `` character. `schedule` holds the information of a train arriving at a particular
    station at a given time. Here, `train` and `station` are foreign keys to the `schedule`
    table. For `train`, the details related to it are columns. The package name is
    `dbutils`. When we use the package names, all the Go programs in that package
    can share variables and functions without an explicit import.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add code to initialize the (create tables) database in the `init-tables.go`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We are importing `database/sql` to pass the type of argument in the function.
    All other statements in the function are similar to the SQLite3 example we gave
    in the preceding section. It is creating three tables in the SQLite3 database.
    Our main program should pass the database driver to this function. If you observe
    here, we are not importing `train`, `station`, and `schedule`. However, since
    this file is in the `dbutils` package, variables in `models.go` are accessible
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our initial package is finished. Build the object code for this package
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not useful until we create and run our main program. So, let''s write
    a simple main program that imports the `Initialize` function from the `dbutils`
    package. Let''s call the `main.go` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the main function, let''s import the `dbutils` package and initialize
    the tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program from the `railAPI` directory using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the previous `railAPI` example, we delegated the table creation task to the `Initialize`
    function in the `dbutils` package. We can do that straight away in our main program,
    but it is good practice to decompose the logic into multiple packages.
  prefs: []
  type: TYPE_NORMAL
- en: The `railapi.db` file from the preceding directory tree screenshot gets created
    once we run our main program. SQLite3 will take care of creating the database
    file if it doesn't exist. SQLite3 databases are simple files. You can enter into
    the SQLite shell using the `$ sqlite3 file_name` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the main program from `railAPI`. Our goal is to create an API
    that was mentioned in the *Design specification* section. We will go step by step
    and understand how to build REST services using `go-restful` and SQLite3 in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the necessary imports to the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We need two external packages, `go-restful` and `go-sqlite3`, for building the
    API logic. The first one is for handlers and the second package is for adding
    storage. `dbutils` stays as it is from the `railAPI` example. The `time` and `net/http`
    packages are for general purpose tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though concrete names are given to the columns in the SQLite database''s
    tables, in Go programming, we need a few struct types to handle data going in
    and out of the database. Take a look at the following code snippet that defines
    necessary structs to hold data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `DB` variable is allocated to hold the global database driver. All the preceding
    structs are exact representations of the database models in SQL. Go's `time.Time`
    struct type can actually hold the `Time` field from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the actual `go-restful` implementation. We need to create a container
    for our API in `go-restful`. Then, we should register the web services to that
    container. What we have to do now is pick a resource and define a `Register` method
    on it. In our case, say `TrainResource` struct is a resource. The method argument
    will be a `go-restful` container where we can attach a service to a namespace,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We first created a service, then added path and routes to the resource. Finally,
    we attached the service to the container. A path is the URL endpoint, and routes
    are the path parameters or query parameters attached to the function handlers.
  prefs: []
  type: TYPE_NORMAL
- en: We attached three REST methods, namely `GET`, `POST`, and `DELETE` to three
    function handlers, `getTrain`, `createTrain`, and `removeTrain`, respectively.
    We haven't implemented those handlers yet, but we will soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at this special statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It tells us that our API will only entertain Content-Type as application/JSON
    in the request. For all other types, it automatically returns a `415--Media Not
    Supported` error.
  prefs: []
  type: TYPE_NORMAL
- en: The returned response is automatically converted to a pretty JSON. We can also
    have a list of formats such as XML, JSON, and so on. `go-restful` provides this
    feature out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the function handlers. The `getTrain` handler takes an HTTP
    request and accesses the `path` parameter, then creates a `DB` query statement
    to fetch the row from the database. `WriteEntity` is used to write a struct as
    JSON to a response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the `POST` handler, `createTrain`. It is similar to `GET`, but instead
    of fetching information from path parameters, it decodes the body of the incoming
    request. Then it prepares a database query statement to insert body data. It returns
    the `ID` of the inserted record in response with the `201-created` status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DELETE` function is quite obvious if you understand the previous two handlers.
    We are making a `DELETE` SQL command using `DB.Prepare` and returning a `201`
    Status created back, telling us the delete operation was successful. Otherwise,
    we are sending back the actual error as a server error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write the main function handler, which is an entry point for our
    program. It creates a `go-restful` container and registers `TrainResource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first few lines are performing the database-related housekeeping. Then,
    we are creating a new container using `restful.NewContainer`. The `go-restful`
    package provides a router called `CurlyRouter` (which allows us to use {train_id}
    syntax in paths while setting routes) for our container, and there are other types
    too. We have chosen that router for incoming HTTP requests. Then, we created an
    instance of the `TrainResource` struct and passed this container to the `Register`
    method. That container can act as a wrapped HTTP handler, so we can directly pass
    it to `http.Server` easily.
  prefs: []
  type: TYPE_NORMAL
- en: Use `request.QueryParameter` to fetch the query parameters from an HTTP request
    in the `go-restful` handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make a `curl` `POST` request to create a train:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new train with the driver and operation status details. The
    response is the newly created resource with the train `ID` allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s make a `curl` request to check `GET`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the JSON output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can use the same names for both posting data and JSON returned, but in order
    to show the difference between two operations, different variable names are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, delete the resource we created in the preceding code snippet with the `DELETE`
    API call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It won't return any response body; it returns Status `200 OK` if the operation
    was successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to do `GET` on the `ID 1` train, then it returns us this response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To support more API operations such as `PUT` and `PATCH`, we need to add two
    more routes to the web service in the `Register` method and define respective
    handlers. Here, we created a web service for `TrainResource`. In a similar way,
    web services can be created for doing CRUD operations on the `Station` and `Schedule`
    tables. That task is left as an exercise for the readers.
  prefs: []
  type: TYPE_NORMAL
- en: '`go-restful` is a lightweight library that is powerful in creating RESTful
    services in an elegant way. The main theme is to convert resources (models) into
    consumable APIs. Using other heavy frameworks may speed up the development, but
    the API can end up slower because of the wrapping of code. `go-restful` is a lean
    and low-level package for API creation.'
  prefs: []
  type: TYPE_NORMAL
- en: '`go-restful` also provides built-in support for documenting the REST API with
    swagger. It is a tool that runs and generates templates for documenting the REST
    API we build. By integrating it with our `go-restful`-based web services, we can
    generate documentation on the fly. For more information, visit [https://github.com/emicklei/go-restful-swagger12](https://github.com/emicklei/go-restful-swagger12).'
  prefs: []
  type: TYPE_NORMAL
- en: Building RESTful API with the Gin framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gin-Gonic is a framework based on `httprouter`. We learned about `httprouter`
    in [Chapter 2](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml), *Handling Routing
    for our REST Services*. It is an HTTP multiplexer like `gorilla/mux`, but it is
    faster. Gin allows a high-level API to create REST services in a clean way.
  prefs: []
  type: TYPE_NORMAL
- en: Gin can be compared to another web framework in Go called Martini. All web frameworks
    allow us to do a lot more things such as templates and web server design, in addition
    to service creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can install the Gin package using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a simple hello world program in Gin to get familiarized with the Gin
    constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a file that holds our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Gin provides a `Default` method to create HTTP route/verb/handler combinations.
    It also provides a context object inside the handler function to easily operate
    on HTTP request and response. See an API created with Gin to request `serverTime UTC`
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This simple server tries to implement a service that serves UTC server time
    to the clients. If you look carefully, Gin allows you to do a lot of stuff with
    just a few lines of code; all the boilerplate details such as route are taken
    away.
  prefs: []
  type: TYPE_NORMAL
- en: Coming to the program, we are creating a router with the `gin.Default` function.
    Then, we are attaching routes with REST verbs as we did in `go-restful`; a route
    to the function handler. Then, we are calling the `Run` function by passing the
    port to run. The default port will be `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: '`c` is a context variable that holds the information about the individual request.
    We can serialize data into JSON before sending it back to the client using the `context.JSON`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run the `ginBasic` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a `curl` request to see the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, the Gin server console captures beautiful logs about HTTP
    requests to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d90432a3-1fea-4d86-849e-0f5ad50b9d0d.png)'
  prefs: []
  type: TYPE_IMG
- en: It is an Apache-style log showing `<the endpoint, the latency of the request,
    and the REST method>`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to run Gin in production mode, set the `GIN_MODE=release` environment
    variable. Then the console output will be muted and log files can be used for
    monitoring the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write our Metro Rail API in Gin to show how to implement exactly
    the same API, but with a different framework. We use the same project layout,
    name the new project `railAPIGin`, and use the `dbutils` as it is. Let''s look
    at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s prepare the imports for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We imported `sqlite3` and `dbutils` for database-related actions. We imported
    `gin` for creating our API server. `net/http` is useful in providing the intuitive
    status codes to be sent along with the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'let''s define a struct to represent a station in program memory and a database
    driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`StationResource` is the placeholder for two kinds of data. First, for the POST
    body coming from an HTTP request, and second for data queried from the database.
    This is why it is slightly modified from the `railAPI` example of `go-restful`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's write the handlers implementing the `GET`, `POST`, and `DELETE` methods
    for the station resource. We define CRUD handlers similar to the previous Metro
    Rail API `go-restful` example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first handler is a `GET` handler. In `GetStation`, we use `c.Param` to
    strip the `station_id` path parameter. We use that value as an ID while querying
    a database record from the SQLite3 station table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If you observe carefully, the SQL query is a bit different. We are using the `CAST` method
    to retrieve the `SQL TIME` field as a string for Go to consume properly. If you
    remove the casting, a panic error will be raised because we are trying to load
    a `TIME` field into the Go string at run time. To give you an idea, the TIME field
    looks like `8:00:00`, `17:31:12`, and so on. We are returning back the result
    using the `gin.H` method if there is no error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `POST` handler, `CreateStation`, we perform a database insertion. We
    need to use the `c.BindJSON` function in Gin to extract data from the request
    body. This function loads the data into the struct that is passed as the argument.
    The idea is to load the station struct with body details. That is why `StationResource`
    has the JSON inference strings to tell what key values are expected. See the function
    body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After collecting the data from a `POST` request body, we are preparing a database
    insert statement and executing it. The result is the ID of the inserted record.
    We are using that ID to send station details back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the HTTP `DELETE` function handler `RemoveStation`, we should use a `DELETE`
    SQL query. If the operation is successful, we return a `200 OK` status back. Otherwise,
    we send the appropriate response back with a `500-Internal Server Error`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the main program, which runs the database logic first to make sure
    tables are created. Then, it tries to create a Gin router and adds routes to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We are registering the `GET`, `POST`, and `DELETE` routes with the Gin router.
    Then, we are passing routes and handlers to them. Finally, we are starting the
    server using the `Run` function of Gin with `8000` as the port. Run the preceding
    program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a new station by performing a `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try to fetch the station details using `GET`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also delete the station record using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns a `200 OK` status, confirming the resource was successfully deleted.
    As we already discussed, Gin provides intuitive debugging on the console, showing
    the attached handler, and highlighting the latency and REST verbs with colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f0de0ec-2bdf-4e27-a642-3ee9e097d129.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, a 200 is green, a 404 is yellow, DELETE is red, and so on. Gin
    provides many other features such as the categorization of routes, redirects,
    and middleware functions.
  prefs: []
  type: TYPE_NORMAL
- en: Use the Gin framework if you are quickly prototyping a REST web service. You
    can also use it for many other things such as static file serving, and so on.
    Remember that it is a fully-fledged web framework. For fetching the query parameters
    in Gin, use the following method on the Gin context object: `c.Query` (parameter).
  prefs: []
  type: TYPE_NORMAL
- en: Building a RESTful API with revel.go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`revel.go` is also a fully-fledged web framework like Python''s Django. It
    is older than Gin and is termed as a highly productive web framework. It is an
    asynchronous, modular, and stateless framework. Unlike the `go-restful` and Gin
    frameworks where we created the project ourselves, Revel generates a scaffold
    for working directly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `revel.go` using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run the scaffold tool, we should install one more supplementary
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that `$GOPATH/bin` is in your PATH variable. Some external packages
    install the binary in the `$GOPATH/bin` directory. If it is in the path, we can
    access the executables system wide. Here, Revel installs a binary called `revel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu or Mac OS X, you can make sure to point Go binaries to the system
    path using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Add this export statement to `~/.bashrc` to save the setting permanently. On
    Windows, you have to directly call the executable by its location. Now we are
    ready to go with Revel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new project called `railAPIRevel` in `github.com/git-user/chapter4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a project scaffold without writing a single line of code. This
    is how web frameworks abstract things for quick prototyping. A Revel project layout
    tree looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Out of all those boilerplate directories, three things are important for creating
    an API. Those are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app/controllers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf/app.conf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf/routes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controllers are the logic containers that execute the API logic. The `app.conf`
    file allows us to set the host, port, dev mode/production mode, and so on. `routes`
    defines the triple of the endpoint, REST verb, and function handler (here, controller's
    function). This is required for combining routes, verbs, and function handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same Rail API example we developed with `go-restful` and Gin.
    However, here, due to the redundancy, we drop the database logic. We will see
    shortly how to build `GET`, `POST`, and `DELETE` actions for the API using Revel:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, modify the routes file to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax may look a bit new. It is a configuration file where we simply define
    a route in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`VERB` is a REST verb, `END_POINT` is the API endpoint, and `HANDLER` is the
    name of the function that processes requests.'
  prefs: []
  type: TYPE_NORMAL
- en: We haven't defined handlers yet. In the endpoint, the path parameters are accessed
    using the :param notation. This means for a `GET` request to the server, `train-id`
    will be passed as the path parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, navigate to the `controllers` folder and modify the existing controller
    in the `app.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We first create a `struct` that represents our application context. let''s
    name it `App`. We should also define another struct for `TrainResource` that holds
    rail information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define CRUD handlers in Revel. First is `GetTrain`. Why a capital
    lettered name for a controller? Because Revel expects controllers to be exported
    out of the package. Go packages only export names starting with capital letters.
    The controller accesses the path parameter to get a train ID and uses it to query
    the database. Here we are mocking the database result for brevity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In `CreateTrain`, we add the `POST` request logic. We should create an object
    of `TrainResource` struct and pass it to a function called `c.Params.BindJSON`.
    JSON tags(`` ''json:"id"` ``) gives us the flexibility of defining output fields.
    This is a good practice in Go while working with JSON. Then, we return an HTTP
    response with `201 created` status. We can use the `RenderJSON` method on context
    to marshal a struct to JSON on the fly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RemoveTrain` handler logic is similar to that of `GET`. A subtle difference
    is that nothing is sent in the body. As we previously mentioned, database CRUD
    logic is omitted from the preceding example. It is an exercise for readers to
    try adding SQLite3 logic by observing what we have done in the `go-restful` and
    Gin sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the default port on which the Revel server runs is `9000`. The configuration
    to change the port number is in the `conf/app.conf` file. Let''s follow the tradition
    of running our app on `8000`. So, modify the HTTP port section of `app.conf` to
    the following. This tells the Revel server to run on a different port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run our Revel API server using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app server starts at `http://localhost:8000`. Now, let''s make a few API
    requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`DELETE` is the same as `GET`, but no body is returned. Here, the code is illustrated
    to show how to handle the request and response. Remember, Revel is more than a
    simple API framework. It is a fully-fledged web framework similar to Django (Python)
    or Ruby on Rails. We have got templates, tests, and many more bundled in `revel.go`.
    It is mainly used for web development, but one can also use it to quickly develop
    a REST API.'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you create a new Revel project for `GOPATH/user`, otherwise,
    your Revel command-line tool may not find the project while running the project.
  prefs: []
  type: TYPE_NORMAL
- en: There is middleware support in all the web frameworks we saw in this chapter.
    `go-restful` names its middleware Filters, whereas Gin names them Custom Middleware,
    and Revel calls its middleware, Interceptors. A middleware reads or writes the
    request and response before and after a function handler, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ab89bca5-b60d-4681-bc36-23ee51a56cc6.xhtml), *Working with Middleware
    and RPC*, we have already briefly discussed middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a Metro Rail API with the help of a few web frameworks
    available in Go. The most popular ones are `go-restful`, Gin Gonic, and `revel.go`.
    We have introduced a database layer in this chapter. We chose SQLite3 and tried
    to write a sample application using the `go-sqlite3` library.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored `go-restful` and looked in detail at how to create routes and
    handlers. `go-restful` has the concept of building APIs on top of resources. We
    explained why `go-restful` is lightweight and can be used to create low-latency
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced the Gin framework and tried to re-implement the `railAPI`.
    Finally, we tried to create another API on the train resource, but this time with
    the `revel.go` web framework. Revel is a framework that is similar to Django and
    Ruby on Rails. It provides scaffolding for most of the server needs such as routing,
    handlers, and middleware.
  prefs: []
  type: TYPE_NORMAL
- en: The main theme of this chapter is to suggest you use available frameworks for
    REST API development. Use `revel.go` when you have an end-to-end web application
    (templates and UI) in addition to the REST API, use Gin to quickly create REST
    services, and use `go-restful` when the performance of the API is critical.
  prefs: []
  type: TYPE_NORMAL
- en: We also worked with a relational database in the form of SQLite3\. In the next
    chapter, we introduce a popular non-relational database called MongoDB for building
    an API.
  prefs: []
  type: TYPE_NORMAL
