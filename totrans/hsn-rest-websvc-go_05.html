<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with MongoDB and Go to Create a REST API</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to introduce a popular NoSQL database called MongoDB. We will learn how well MongoDB suits modern web services by storing documents instead of relations. We'll begin by learning about MongoDB collections and documents and create an example API with MongoDB as the database. While doing so, we'll use a driver package called <kbd>mongo-driver</kbd>. Then, we'll try to design a document model schema for a delivery logistics problem. <strong><br/></strong></p>
<p>In this chapter, we are going to discuss the following topics:</p>
<ul>
<li><span>Introduction to MongoDB</span></li>
<li><span>Installing MongoDB and using the shell</span></li>
<li><span>Introducing <kbd>mongo-driver</kbd>, an official MongoDB driver for Go</span></li>
<li><span>RESTful API with <kbd>gorilla/mux</kbd> and MongoDB</span></li>
<li><span>Boosting querying performance with indexing</span></li>
<li><span>Designing MongoDB documents for delivery logistics<br/></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements </h1>
                </header>
            
            <article>
                
<p>The following software needs to be pre-installed if you wish to run the code examples in this book:</p>
<ul>
<li>OS: Linux(Ubuntu 18.04)/Windows 10/Mac OS X &gt;=10.13</li>
<li>Dep: A dependency management tool for Go &gt;= 0.5.3</li>
<li>Go compiler &gt;= 1.13.5</li>
<li>MongoDB &gt;= 4.2.3</li>
</ul>
<p>You can download the code for this chapter from <a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter5" target="_blank">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter5</a>. Clone the code and use the code samples in the<span> </span><kbd>chapter5</kbd><span> </span>directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to MongoDB</h1>
                </header>
            
            <article>
                
<p><strong>MongoDB</strong> is a popular NoSQL database that is attracting a lot of developers worldwide. It is different from traditional relational databases such as MySQL, PostgreSQL, and SQLite3. The main big difference with MongoDB compared to other databases is it is schemaless and stores collections and documents. Think of MongoDB collections as tables, and documents as rows in SQL databases. However, in MongoDB, there is no relationship between collections. This schemaless design allows MongoDB to scale horizontally using a mechanism called <strong>Sharding</strong>. MongoDB stores data as BSON files on disk. BSON is an efficient binary format for operation and data transfer. Almost all MongoDB clients convert JSON into BSON and vice versa while inserting or retrieving documents.</p>
<p>Many big companies such as Expedia, Comcast, and MetLife built their applications on MongoDB. It has been proven as a vital element in modern internet businesses. MongoDB stores data in a document; think of this as a row in SQL databases. All MongoDB documents are stored in a collection, and this collection is similar to a table (in terms of SQL). Let's look at an example. A sample document for an IMDb movie has a few keys, such as name, year, and directors. The values for these keys can be a number, boolean, string, list, or a map. This would look something similar to the following:</p>
<pre>{<br/>  _id: 5,<br/>  name: 'Star Trek',<br/>  year: 2009,<br/>  directors: ['J.J. Abrams'],<br/>  writers: ['Roberto Orci', 'Alex Kurtzman'],<br/>  boxOffice: {<br/>     budget:<span>150000000,<br/></span>     gross:<span>257704099</span><br/>  }<br/>}</pre>
<p>The main advantages of MongoDB over relational databases are as follows:</p>
<ul>
<li>Easy to model (schema-free)</li>
<li>Can leverage querying power</li>
<li>Document structure suits modern-day web applications (<strong>JSON</strong>)</li>
<li>More scalable than relational databases (via <strong>Sharding</strong>)</li>
</ul>
<p>Now that we know what MongoDB is, let's look at it in more detail. In the next section, we will learn how to install MongoDB and try to access it from the MongoDB shell.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing MongoDB and using the shell</h1>
                </header>
            
            <article>
                
<p>MongoDB can be easily installed on any platform. On Ubuntu 18.04, we need to perform some steps before running the <kbd>apt-get</kbd> command:</p>
<pre><strong>sudo apt-get update<br/>sudo apt-get install -y mongodb</strong></pre>
<p>Once you've installed it, check whether the <kbd>mongo</kbd> process is running. If not, you can start the MongoDB daemon using the following command:</p>
<pre><strong>systemctl start mongod</strong></pre>
<p>If the user is root, you can drop the <kbd>sudo</kbd> keyword before each command.</p>
<div class="packt_infobox">We can also download MongoDB manually from the website and copy it to <kbd>/usr/local/bin</kbd>. To do this, we have to create an init script for the server since the server stops when the system is shut down. We can use the <kbd>nohup</kbd> tool to run the server in the background. Usually, it is better to install it using <kbd>apt-get</kbd>.</div>
<p>To install MongoDB on Mac OS X, you'll need to use the Homebrew software. Follow these steps to do so:</p>
<ol>
<li>We can easily install it using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>brew tap mongodb/brew<br/>brew install mongodb-community<br/></strong></pre>
<ol start="2">
<li>After that, we need to create the <kbd>db</kbd> directory where MongoDB stores its database: </li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir -p /data/db</strong></pre>
<ol start="3">
<li>Then, change the permissions of that file using <kbd>chown</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>chown -R `id -un` /data/db</strong></pre>
<ol start="4">
<li>Now, MongoDB is ready. To see its logs interactively, we need to stop MongoDB as a process and run it in a shell. To stop the service, use the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>systemctl stop mongod</strong></pre>
<ol start="5">
<li>Now, in a Terminal window, run the following command, <span>which starts MongoDB interactively (not in the background):</span></li>
</ol>
<pre style="padding-left: 60px"><strong>mongod</strong></pre>
<p style="padding-left: 60px">The preceding command results in the following output:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/453088c4-7456-4317-ba8f-0ed64145380f.png"/></div>
<p>The preceding command shows the status of the database in a few columns. From these <kbd>logs</kbd>, we can figure out that the server started on port <kbd>27017</kbd>. It displays the build environment, the storage engine that was used, and so on.</p>
<p>On Windows, we can manually download the installer binary and launch it by adding the installation <kbd>bin</kbd> directory to the <kbd>PATH</kbd> variable. Then, we can run it using the <kbd>mongod</kbd><strong> </strong>command. Alongside the MongoDB installation comes a client shell called Mongo. We will look at it in brief in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with the MongoDB shell</h1>
                </header>
            
            <article>
                
<p>Whenever we start using MongoDB, the first thing we need to explore is the available commands that we can use in order to interact with it. Looking up the available databases, collections, documents, and so on can be done with a simple client tool called <strong>MongoDB shell</strong>. It is similar to the MySQL client. This shell program is included in the standard MongoDB server installation. We can launch it using the following command:</p>
<pre><strong>mongo</strong></pre>
<p>Refer to the following screenshot: </p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/761f8225-770c-4e69-8bc4-5a3b943c0134.png"/></div>
<p>If you see that a <kbd>session</kbd> ID has been created, as shown in the preceding screenshot, everything worked fine. If you get an error, the server is probably not running as expected. To troubleshoot, have a look at the MongoDB troubleshooting guide at <a href="https://docs.mongodb.com/manual/faq/diagnostics/" target="_blank">https://docs.mongodb.com/manual/faq/diagnostics</a>. The client provides information about MongoDB versions and other warnings. To see all the available shell commands, use the <kbd>help</kbd> command.</p>
<p>Let's create a new collection called <kbd>movies</kbd> and insert the preceding example document into it. Follow these steps:</p>
<ol>
<li>By default, the database will be a test database:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; show databases<br/><br/>admin   0.000GB<br/>config  0.000GB<br/>local   0.000GB<br/>test    0.000GB</strong></pre>
<p style="padding-left: 60px">The preceding <kbd>show</kbd> command lists all available databases. <kbd>admin</kbd>, <kbd>config</kbd>, <kbd>test</kbd>, and <kbd>local</kbd> are the four databases available by default.</p>
<ol start="2">
<li>To create a new database or switch to an existing database, just type <kbd>use db_name</kbd>. In our case, let's name our database <kbd>appDB</kbd>. Type the following into a MongoDB shell:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; use appDB</strong></pre>
<p style="padding-left: 60px">This switches the current database to the <kbd>appDB</kbd><span> </span>database.<strong> </strong>If you try to list the available databases, <kbd>appDB</kbd> won't show up because MongoDB only creates a physical database when some data is inserted into it (first collection or document).</p>
<ol start="3">
<li>Now, we can create a new collection by inserting the first document. We can insert the sample document for IMDb movies into a collection called <kbd>movies</kbd><strong> </strong>using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.insertOne({ _id: 5, name: 'Star Trek', year: 2009, directors: ['J.J. Abrams'], writers: ['Roberto Orci', 'Alex Kurtzman'], boxOffice: { budget:150000000, gross:257704099 } } )</strong><br/><strong>{ </strong><br/><strong>      "acknowledged" : true,</strong><br/><strong>      "insertedId" : 5 </strong><br/><strong>}</strong></pre>
<p style="padding-left: 60px">The JSON you inserted has an ID called <kbd>_id</kbd>. We can provide it while inserting a document, or MongoDB itself can generate one for you.</p>
<ol start="4">
<li>In SQL databases, we use <em>auto-increment</em> along with an <kbd>ID</kbd> schema to<strong> </strong>increment the <kbd>ID</kbd> field. Here, MongoDB generates a unique hash <kbd>ID</kbd> rather than a sequence. Let's insert one more document about <kbd>The Dark Knight</kbd>, but this time, we won't pass the <kbd>_id</kbd> field:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.insertOne({ name: 'The Dark Knight ', year: 2008, directors: ['Christopher Nolan'], writers: ['Jonathan Nolan', 'Christopher Nolan'], boxOffice: { budget:185000000, gross:533316061 } } )</strong><br/><strong>{ </strong><br/><strong>     "acknowledged" : true,</strong><br/><strong>     "insertedId" : ObjectId("59574125bf7a73d140d5ba4a")</strong><br/><strong>}</strong></pre>
<p style="padding-left: 60px">As shown by the acknowledgement JSON response, <kbd>insertedId</kbd> has<strong> </strong>changed to a very lengthy <kbd>59574125bf7a73d140d5ba4a</kbd>.<strong> </strong>This is the unique hash that's generated by MongoDB.</p>
<p class="mce-root"/>
<div class="packt_infobox">We can also insert a batch of documents at a given time using the <kbd>insertMany</kbd> function.</div>
<ol start="5">
<li>Using the <kbd>find</kbd> function without arguments on the movies collection returns all the matched documents, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.find()</strong><br/><br/><strong>{ "_id" : 5, "name" : "Star Trek", "year" : 2009, "directors" : [ "J.J. Abrams" ], "writers" : [ "Roberto Orci", "Alex Kurtzman" ], "boxOffice" : { "budget" : 150000000, "gross" : 257704099 } }</strong><br/><strong>{ "_id" : ObjectId("59574125bf7a73d140d5ba4a"), "name" : "The Dark Knight ", "year" : 2008, "directors" : [ "Christopher Nolan" ], "writers" : [ "Jonathan Nolan", "Christopher Nolan" ], "boxOffice" : { "budget" : 185000000, "gross" : 533316061 } }</strong></pre>
<ol start="6">
<li>In order to return a single document, use the <kbd>findOne</kbd> function. This returns the oldest document from multiple results:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.findOne()</strong><br/><br/><strong>{ "_id" : 5, "name" : "Star Trek", "year" : 2009, "directors" : [ "J.J. Abrams" ], "writers" : [ "Roberto Orci", "Alex Kurtzman" ], "boxOffice" : { "budget" : 150000000, "gross" : 257704099 }}</strong></pre>
<ol start="7">
<li>How do we query documents? Querying in MongoDB is known as filtering data and returning a result. If we need to filter for movies that were released in <kbd>2008</kbd>, then we can do this:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.find({year: {$eq: 2008}})</strong><br/><br/><strong>{ "_id" : ObjectId("59574125bf7a73d140d5ba4a"), "name" : "The Dark Knight ", "year" : 2008, "directors" : [ "Christopher Nolan" ], "writers" : [ "Jonathan Nolan", "Christopher Nolan" ], "boxOffice" : { "budget" : 185000000, "gross" : 533316061 } }</strong></pre>
<p style="padding-left: 60px">   The filter query from the preceding MongoDB shell statement is as follows:</p>
<pre style="padding-left: 60px"><strong>{year: {$eq: 2008}}</strong></pre>
<p style="padding-left: 60px">This states that the searching criterion is the <kbd>year</kbd> and that the value should be <kbd>2008</kbd>. <kbd>$eq</kbd> is called a <strong>filtering operator</strong>, which helps to relate the condition between the field and data. It is equivalent to the <kbd>=</kbd> operator in SQL. In SQL, the equivalent query can be written as follows:</p>
<pre style="padding-left: 60px"><strong>SELECT * FROM movies WHERE year=2008;</strong></pre>
<ol start="8">
<li>We can simplify the previously written MongoDB shell statement to the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.find({year: 2008})</strong></pre>
<p style="padding-left: 60px">This filter query and the previous filter query are the same since they return the same set of documents. The former syntax is using <kbd>$eq</kbd>, which is a query operator. From now on, we'll call a <em>query operator</em> simply an <em>operator</em>.</p>
<p style="padding-left: 60px">The other main operators are as follows:</p>
<table border="1" style="border-collapse: collapse;width: 651px;height: 204px">
<tbody>
<tr>
<td style="width: 306.774px">
<p class="CDPAlignLeft CDPAlign"><strong>Operator</strong></p>
</td>
<td style="width: 337.226px">
<p class="CDPAlignLeft CDPAlign"><strong> Function</strong></p>
</td>
</tr>
<tr>
<td style="width: 306.774px"><kbd>$lt</kbd></td>
<td style="width: 337.226px"><kbd>Less than</kbd></td>
</tr>
<tr>
<td style="width: 306.774px"><kbd>$gt</kbd></td>
<td style="width: 337.226px"><kbd>Greater than</kbd></td>
</tr>
<tr>
<td style="width: 306.774px"><kbd>$in</kbd></td>
<td style="width: 337.226px"><kbd>In the</kbd></td>
</tr>
<tr>
<td style="width: 306.774px"><kbd>$lte</kbd></td>
<td style="width: 337.226px"><kbd>Less than or equal to</kbd></td>
</tr>
<tr>
<td style="width: 306.774px"><kbd>$ne</kbd></td>
<td style="width: 337.226px"><kbd>Not equal to</kbd></td>
</tr>
</tbody>
</table>
<div class="packt_infobox"><br/>
You can find all the available operators here: <a href="https://docs.mongodb.com/manual/reference/operator/" target="_blank">https://docs.mongodb.com/manual/reference/operator/</a>.</div>
<ol start="9">
<li>Now, let's pose a question to ourselves. We have a requirement to fetch all the documents whose budget is more than $150,000,000<span>. How can we filter this with the query knowledge we gained previously? Take a look at the following code snippet:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.find({'boxOffice.budget': {$gt: 150000000}})</strong><br/><br/><strong>{ "_id" : ObjectId("59574125bf7a73d140d5ba4a"), "name" : "The Dark Knight ", "year" : 2008, "directors" : [ "Christopher Nolan" ], "writers" : [ "Jonathan Nolan", "Christopher Nolan" ], "boxOffice" : { "budget" : 185000000, "gross" : 533316061 } }</strong></pre>
<p style="padding-left: 60px">As you can see, we accessed the <kbd>budget</kbd> key within the JSON using <kbd>boxOffice.budget</kbd>.<strong> </strong>The beauty of MongoDB is that it allows us to query the JSON with a lot of freedom.</p>
<ol start="10">
<li>Can't we add two or more operators to the criteria while fetching documents? Yes, we can! Let's find all the movies in the database that were released in <kbd>2009</kbd> with a budget of more than $150,000,000:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.find({'boxOffice.budget': {$gt: 150000000}, year: 2009})</strong></pre>
<p style="padding-left: 60px">This returns nothing because we don't have any documents that match the given criteria. By default, comma-separated query fields, such as <kbd>'boxOffice.budget': {$gt: 150000000}, year: 2009 </kbd>, are combined with the <kbd>AND</kbd><strong> </strong>operation.</p>
<ol start="11">
<li>Now, let's relax our condition and find any movies that were either released in <kbd>2009</kbd> or had a budget of more than $150,000,000: </li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.find({$or: [{'boxOffice.budget': {$gt: 150000000}}, {year: 2009}]})</strong><br/><br/><strong>{ "_id" : 5, "name" : "Star Trek", "year" : 2009, "directors" : [ "J.J. Abrams" ], "writers" : [ "Roberto Orci", "Alex Kurtzman" ], "boxOffice" : { "budget" : 150000000, "gross" : 257704099 } }</strong><br/><strong>{ "_id" : ObjectId("59574125bf7a73d140d5ba4a"), "name" : "The Dark Knight ", "year" : 2008, "directors" : [ "Christopher Nolan" ], "writers" : [ "Jonathan Nolan", "Christopher Nolan" ], "boxOffice" : { "budget" : 185000000, "gross" : 533316061 } }</strong></pre>
<p style="padding-left: 60px">Here, the query is a bit different. We used an operator called <kbd>$or</kbd><strong> </strong>to find the predicate of the two conditions. The result will be the criteria for fetching the documents. <kbd>$or</kbd><strong> </strong>needs to be assigned to a list (see the preceding query) of JSON condition objects. Since JSON can be nested, conditions can also be nested. This style of querying might look new to people coming from a SQL background. The MongoDB team designed it to intuitively filter data. We can also write advanced queries such as inner joins, outer joins, nested queries, and so on easily in MongoDB with the clever use of operators.</p>
<ol start="12">
<li>So far, we have explored two <span><strong>Create</strong>, <strong>Read</strong>, <strong>Update</strong>, and <strong>Delete</strong> (</span><strong>CRUD</strong>) operations in order to create and read on MongoDB documents. Now, we'll look at the update and delete operations. To update a document, use the <kbd>db.collection.update</kbd> method. The syntax consists of the criteria and a set operation:</li>
</ol>
<pre style="padding-left: 60px"><strong>db.movies.update(CRITERIA, SET)</strong></pre>
<ol start="13">
<li>Let's update Star Trek (ID: 5)'s box office budget. Our goal is to change <kbd>150000000</kbd> to <kbd>200000000</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>db.movies.update({"_id": 5}, {$set: {"boxOffice.budget": 200000000}})</strong></pre>
<p style="padding-left: 60px">The first argument for the <kbd>update</kbd> method is the filter criteria. The second argument is a <kbd>$set</kbd> operator that changes the fields/sections in the document.</p>
<ol start="14">
<li>Now, let's take a look at the delete operation. We can delete a document from a given collection using the <kbd>deleteOne</kbd> and <kbd>deleteMany</kbd> functions:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; db.movies.deleteOne({"_id": ObjectId("59574125bf7a73d140d5ba4a")})</strong><br/><strong>{ "acknowledged" : true, "deletedCount" : 1 }</strong></pre>
<p>The argument that's passed to the <strong><kbd>deleteOne</kbd> </strong>function is a filter criterion, which is similar to the read and update operations. All the documents that match the given criteria will be removed from the collection. The response contains a nice acknowledgment message with a count of documents that were deleted.</p>
<p>This and the preceding sections discussed the basics of MongoDB with the MongoDB shell. However, how we can do the same thing from a Go program? We need to use a driver package. In the next section, we'll explore the official MongoDB driver package for Go, called <kbd>mongo-driver</kbd>. MongoDB supports official drivers for major languages such as Python, Java, Ruby, and Go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing mongo-driver, an official MongoDB driver for Go</h1>
                </header>
            
            <article>
                
<p><kbd>mongo-driver</kbd> is a rich MongoDB driver that allows developers to write applications that use MongoDB as the database. The Go application can talk easily with MongoDB for all its CRUD operations using the <kbd>mongo</kbd> driver. It is an open source implementation maintained by MongoDB and can be used and modified freely. We can think of it as a wrapper around the MongoDB API. Installing the package is similar to other <kbd>go get</kbd> commands. However, in this chapter, we'll introduce a new Go package tool called <kbd>dep</kbd>.</p>
<p><kbd>dep</kbd> is a Go package installer tool similar to Python's <kbd>pip</kbd> or JavaScript's <kbd>npm</kbd>. Follow this web page to install the dep tool on various platforms: <a href="https://golang.github.io/dep/docs/installation.html" target="_blank">https://golang.github.io/dep/docs/installation.html</a>.</p>
<p>Let's write a Go program that inserts <kbd>The Dark Knight</kbd> movie document into MongoDB. Follow these steps:</p>
<ol start="1">
<li>Create a directory for our project:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir $GOPATH/src/github.com/git-user/chapter5/intro</strong></pre>
<ol start="2">
<li>Now, traverse to the <kbd>intro</kbd> directory and initialize the <kbd>dep</kbd> tool. It creates a few files so that we can track package dependencies:</li>
</ol>
<pre style="padding-left: 60px"><strong>dep init</strong></pre>
<ol start="3">
<li>Add the <kbd>mongo-driver</kbd> dependency to <kbd>dep</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>dep ensure -add <span class="pl-s"><span class="pl-pds">"</span>go.mongodb.org/mongo-driver/mongo@~1.0.0<span class="pl-pds">"</span></span></strong></pre>
<ol start="4">
<li>Create a <kbd>main</kbd> file, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch $GOPATH/src/github.com/git-user/chapter5/intro/main.go</strong></pre>
<ol start="5">
<li>This is all we need to do to set up all the files and dependencies. To represent the movie and box office, we have to create structs that imitate the BSON data. These structs look like this:</li>
</ol>
<pre style="padding-left: 60px">// Movie holds a movie data<br/>type Movie struct {<br/>  Name string `bson:"name"`<br/>  Year string `bson:"year"`<br/>  Directors []string `bson:"directors"`<br/>  Writers []string `bson:"writers"`<br/>  BoxOffice `bson:"boxOffice"`<br/>}<br/><br/>// BoxOffice is nested in Movie<br/>type BoxOffice struct {<br/>  Budget uint64 `bson:"budget"`<br/>  Gross uint64 `bson:"gross"`<br/>}</pre>
<p style="padding-left: 60px">We used <kbd>bson</kbd> tags for the struct fields. The reason we did this is that the <kbd>mongo-driver</kbd> package uses another package called <kbd>bson</kbd> to serialize Go structs into BSON format. This <kbd>bson</kbd> package needs some meta information in the form of tags to process fields. Hence, we attach a few <kbd>helper</kbd> tags. The preceding structs represent the BSON documents in memory.</p>
<ol start="6">
<li>Now, w<span>e have to import two packages called </span><kbd>mongo</kbd><span> and </span><kbd>options</kbd><span> from <kbd>mongo-driver</kbd>. The </span><kbd>bson</kbd><span> package is required if we wish to perform queries on MongoDB collections. The import section of the program looks like this:</span></li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "context"<br/>  "fmt"<br/>  "log"<br/><br/>  "go.mongodb.org/mongo-driver/mongo"<br/>  "go.mongodb.org/mongo-driver/mongo/options"<br/>  "gopkg.in/mgo.v2/bson"<br/>)</pre>
<ol start="7">
<li>Now, in the <kbd>main</kbd> function, we have to create a database client and connect to it. This should happen in the main block of the program. As per the <kbd>mongo-driver</kbd> API, we create an instance of <kbd>ClientOptions</kbd>. The <kbd>ClientOptions</kbd> object holds details such as the database server's information (host and port) and so on. Then, we create a client using a context and the <kbd>ClientOptions</kbd> object. The context is used as a request timeout. With the help of the client, we can ping the database using the <kbd>Ping</kbd> method. If the database ping is successful, we can fetch the reference for a collection. The logic for creating a client and pinging the server looks like this:</li>
</ol>
<pre style="padding-left: 60px">clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")<br/>client, err := mongo.Connect(context.TODO(), clientOptions)<br/><br/>if err != nil {<br/>  panic(err)<br/>}<br/><br/>err = client.Ping(context.TODO(), nil)<br/><br/>if err != nil {<br/>  log.Fatal(err)<br/>}<br/><br/>fmt.Println("Connected to MongoDB successfully")<br/>collection := client.Database("appDB").Collection("movies")</pre>
<ol start="8">
<li>Now that the collection is ready, we can insert a movie record into the database. <kbd>mongo-driver</kbd> provides a method called <kbd>InsertOne</kbd> for a collection. We can insert a struct into the database collection as follows:</li>
</ol>
<pre style="padding-left: 60px">  // Create a movie<br/>  darkNight := Movie{<br/>    Name: "The Dark Knight",<br/>    Year: "2008",<br/>    Directors: []string{"Christopher Nolan"},<br/>    Writers: []string{"Jonathan Nolan", "Christopher Nolan"},<br/>    BoxOffice: BoxOffice{<br/>      Budget: 185000000,<br/>      Gross: 533316061,<br/>    },<br/>  }<br/><br/>  // Insert a document into MongoDB<br/>  _, err := collection.InsertOne(context.TODO(), darkNight)<br/><br/>  if err != nil {<br/>    log.Fatal(err)<br/>  }</pre>
<ol start="9">
<li>By doing this, a record has been inserted into the database. Let's retrieve it using a query with a filter, that is, a movie with a box office budget greater than <span>$150 million. </span>We should create an empty movie struct to hold the result. A filter query can be constructed using the <kbd>bson.M</kbd> <span>struct. It is a generic map that holds</span> <kbd>KEY:VALUE</kbd> <span>pairs and is convenient for creating BSON queries. The</span> <kbd>collection.FindOne</kbd> <span>method takes a filter query and returns a</span> <kbd>SingleResult</kbd> <span>object. We can decode that object into the empty movie struct like so:</span></li>
</ol>
<pre style="padding-left: 60px">  queryResult := &amp;Movie{}<br/>  // bson.M is used for building map for filter query<br/>  filter := bson.M{"boxOffice.budget": bson.M{"$gt": 150000000}}<br/>  result = collection.FindOne(context.TODO(), filter)<br/>  err = result.Decode(queryResult)<br/><br/>  if err != nil {<br/>    log.Fatal(err)<br/>  }<br/><br/>  fmt.Println("Movie:", queryResult)</pre>
<ol start="10">
<li>Finally, we disconnect from the database once our operations have been completed:</li>
</ol>
<pre style="padding-left: 60px">  err = client.Disconnect(context.TODO())<br/>  if err != nil {<br/>    panic(err)<br/>  }<br/>  fmt.Println("Disconnected from MongoDB")</pre>
<ol start="11">
<li>We can run the entire program using the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter5/intro/main.go</strong></pre>
<p style="padding-left: 60px">The output looks as follows:</p>
<pre style="padding-left: 60px">Connected to MongoDB successfully<br/>Movie: &amp;{ObjectID("5cfd106733090c1e34713c43")}<br/>Disconnected from MongoDB</pre>
<p>The result from a query can be stored in a new struct and can be serialized into JSON so that the clients can use it too. For that, you should add JSON meta tags to the struct, along with BSON tags.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RESTful API with gorilla/mux and MongoDB</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we explored all the possible ways of building a RESTful API. We used basic HTTP routers, as well as many other web frameworks. However, to keep it simple, we can use <kbd>gorilla/mux</kbd> with <kbd>mongo-driver</kbd> for the MongoDB driver. In this section, we will build an end-to-end movie API while integrating the database and HTTP router. In the previous section, we learned how to create a new MongoDB document and retrieve it using <kbd>mongo-driver</kbd>. By consolidating our knowledge of HTTP routers and databases, we can create a movie API.</p>
<p>Let's create the plan so that we can create the API:</p>
<ol>
<li>Prepare structs to hold movie information and the database connection.</li>
<li>Create a server for hosting the API.</li>
<li>Prepare the routes for the API endpoints.</li>
<li>Implement handlers for the routes.</li>
</ol>
<p><span>We have to follow these steps to achieve our goal:</span></p>
<ol>
<li>Create a directory to hold our project:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir $GOPATH/src/github.com/git-user/chapter5/movieAPI</strong></pre>
<ol start="2">
<li>Add a <kbd>main.go</kbd> file in the project:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch $GOPATH/src/github.com/git-user/chapter5/movieAPI/main.go</strong></pre>
<div class="packt_infobox">Please install the <kbd>mongo-driver</kbd> package using the <kbd>dep</kbd> tool, just like we did in the previous section.</div>
<ol start="3">
<li>Let's take a look at the structs we need to create; that is, <kbd>DB</kbd>, <kbd>Movie</kbd>, and <kbd>BoxOffice</kbd>. <kbd>Movie</kbd> and <kbd>BoxOffice</kbd> hold the movie information. The <kbd>DB</kbd> struct holds a collection in a MongoDB database that can be passed across multiple functions. The code for this is as follows:</li>
</ol>
<pre style="padding-left: 60px">type DB struct {<br/>  collection *mongo.Collection<br/>}<br/><br/>type Movie struct {<br/>  ID interface{} `json:"id" bson:"_id,omitempty"`<br/>  Name string `json:"name" bson:"name"`<br/>  Year string `json:"year" bson:"year"`<br/>  Directors []string `json:"directors" bson:"directors"`<br/>  Writers []string `json:"writers" bson:"writers"`<br/>  BoxOffice BoxOffice `json:"boxOffice" bson:"boxOffice"`<br/>}<br/><br/>type BoxOffice struct {<br/>  Budget uint64 `json:"budget" bson:"budget"`<br/>  Gross uint64 `json:"gross" bson:"gross"`<br/>}</pre>
<ol start="4">
<li>We need a few important packages in order to implement our API. These are <kbd>gorilla/mux</kbd>, <kbd>mongo-driver</kbd>, and a few other <kbd>helper</kbd> packages. Let's look at how to import these packages:</li>
</ol>
<pre style="padding-left: 60px">  ...<br/>  "go.mongodb.org/mongo-driver/bson/primitive"<br/><br/>  "go.mongodb.org/mongo-driver/bson"<br/><br/>  "github.com/gorilla/mux"<br/>  "go.mongodb.org/mongo-driver/mongo"<br/>  "go.mongodb.org/mongo-driver/mongo/options"</pre>
<p style="padding-left: 60px">We need the <kbd>primitive</kbd> package to generate an <kbd>ObjectID</kbd> from a string, the <kbd>bson</kbd> package to create query filters, and the <kbd>mongo/options</kbd> package to create a MongoDB client.</p>
<ol start="5">
<li>Let's create the <kbd>main</kbd> function, which is where we create a MongoDB client. <span>The client is created by passing options to the </span><kbd>Connect</kbd><span> method. Once we are connected to MongoDB, which is running locally on port <kbd>27017</kbd>, we can access the collection using the </span><kbd>Database.Collection</kbd> <span>method. We can delay cleaning up the connection using the <kbd>defer</kbd> </span> keyword:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px">func main() {<br/>  clientOptions := <br/>    options.Client().ApplyURI("mongodb://localhost:27017")<br/>  client, err := mongo.Connect(context.TODO(), clientOptions)<br/>  if err != nil {<br/>    panic(err)<br/>  }<br/>  defer client.Disconnect(context.TODO())<br/><br/>  collection := client.Database("appDB").Collection("movies")<br/>  db := &amp;DB{collection: collection}<br/>  ...<br/>}</pre>
<div class="packt_infobox">The <kbd>defer</kbd> keyword is special in a Go program. It defers a function call so that it's executed right before the enclosing outer function returns. It is commonly used for I/O connection cleanup.<br/>
<br/>
In our case, the enclosing function is the <kbd>main</kbd>, and the deferred function is <kbd>client.Disconnect</kbd>. So, when <kbd>main</kbd> returns/terminates, the defer statement closes the MongoDB connection properly.</div>
<ol start="6">
<li>Next<span>, we create a few HTTP routes for the <kbd>GET</kbd> and <kbd>POST</kbd> operations on a movie. Let's call them </span><kbd>GetMovie</kbd><span> and </span><kbd>PostMovie</kbd>, <span>respectively. The code looks like this:<br/></span></li>
</ol>
<pre style="padding-left: 60px">  r := mux.NewRouter()<br/>  r.HandleFunc("/v1/movies/{id:[a-zA-Z0-9]*}",<br/>   db.GetMovie).Methods("GET")<br/>  r.HandleFunc("/v1/movies", db.PostMovie).Methods("POST")</pre>
<ol start="7">
<li><span>Now, we can start a server using the <kbd>http.Server</kbd> method, as shown in the following code:</span></li>
</ol>
<pre style="padding-left: 60px">  srv := &amp;http.Server{<br/>    Handler: r,<br/>    Addr: "127.0.0.1:8000",<br/>    WriteTimeout: 15 * time.Second,<br/>    ReadTimeout: 15 * time.Second,<br/>  }<br/>  log.Fatal(srv.ListenAndServe())<br/>}</pre>
<ol start="8">
<li>Now comes the actual implementation of the handlers. <kbd>GetMovie</kbd>, like any other mux handler, takes response and request objects. It receives an <kbd>ObjectId</kbd> (hex string) of the movie from the path parameters and queries a matching document from the database. We can use the <kbd>mux.Vars</kbd> map to collect path parameters.</li>
</ol>
<p style="padding-left: 60px">We can't simply form a filter query using the raw ID. We have to convert the hex string that was passed into the <kbd>ObjectID</kbd> using the <kbd>primitive.ObjectIDFromHex</kbd> method from the <kbd>mongo-driver/bson/primitive</kbd> package. We should use this <kbd>ObjectID</kbd> in a <kbd>filter</kbd> query.</p>
<p style="padding-left: 60px">Then, we run a query using the <kbd>collection.FindOne</kbd> method. The result can then be decoded into a <kbd>Movie</kbd> struct literal and returned as a JSON <kbd>response</kbd>. Take a look at the following code for the <kbd>GetMovie</kbd> function handler:</p>
<pre style="padding-left: 60px">// GetMovie fetches a movie with a given ID<br/>func (db *DB) GetMovie(w http.ResponseWriter, r *http.Request) {<br/>  vars := mux.Vars(r)<br/>  var movie Movie<br/>  objectID, _ := primitive.ObjectIDFromHex(vars["id"])<br/>  filter := bson.M{"_id": objectID}<br/>  err := db.collection.FindOne(context.TODO(),<br/>   filter).Decode(&amp;movie)<br/><br/>  if err != nil {<br/>    w.WriteHeader(http.StatusInternalServerError)<br/>    w.Write([]byte(err.Error()))<br/>  } else {<br/>    w.Header().Set("Content-Type", "application/json")<br/>    response, _ := json.Marshal(movie)<br/>    w.WriteHeader(http.StatusOK)<br/>    w.Write(response)<br/>  }<br/>}</pre>
<ol start="9">
<li><kbd>PostMovie</kbd> <span>has the exact same function signature as the <kbd>GET</kbd> handler function. Instead of reading from the path parameters, it reads information from the request body in JSON and un-marshalls it into</span> the <kbd>Movie</kbd> <span>struct. Then, we use</span> the <kbd>collection.InsertOne</kbd> <span>method and perform a database insert operation. The result of the JSON is sent back as an HTTP response. The code for the</span> <kbd>PostMovie</kbd> <span>handler function looks like this:</span></li>
</ol>
<pre style="padding-left: 60px">// PostMovie adds a new movie to our MongoDB collection<br/>func (db *DB) PostMovie(w http.ResponseWriter, r *http.Request) {<br/>  var movie Movie<br/>  postBody, _ := ioutil.ReadAll(r.Body)<br/>  json.Unmarshal(postBody, &amp;movie)<br/>  <br/>  result, err := db.collection.InsertOne(context.TODO(), movie)<br/>  if err != nil {<br/>    w.WriteHeader(http.StatusInternalServerError)<br/>    w.Write([]byte(err.Error()))<br/>  } else {<br/>    w.Header().Set("Content-Type", "application/json")<br/>    response, _ := json.Marshal(result)<br/>    w.WriteHeader(http.StatusOK)<br/>    w.Write(response)<br/>  }<br/>}</pre>
<ol start="10">
<li>Now, let's run the program:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter5/movieAPI/main.go</strong></pre>
<ol start="11">
<li>Next, we open a Terminal and make a <kbd>POST</kbd> API request using <kbd>curl</kbd> or <kbd>Postman</kbd> to create a new movie:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X POST \</strong><br/><strong> http://localhost:8000/v1/movies \</strong><br/><strong> -H 'cache-control: no-cache' \</strong><br/><strong> -H 'content-type: application/json' \</strong><br/><strong> -d '{ "name" : "The Dark Knight", "year" : "2008", "directors" : [ "Christopher Nolan" ], "writers" : [ "Jonathan Nolan", "Christopher Nolan" ], "boxOffice" : { "budget" : 185000000, "gross" : 533316061 }</strong><br/><strong>}'</strong></pre>
<p style="padding-left: 60px">This returns the following response:</p>
<pre style="padding-left: 60px"><strong>{"InsertedID":"5cfd6cf0c281945c6cfefaab"}</strong></pre>
<ol start="12">
<li>Our movie has been created successfully. Next, let's retrieve it. Make a <kbd>GET</kbd> API request using <kbd>curl</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET </strong><strong>http://localhost:8000/v1/movies/5cfd6cf0c281945c6cfefaab</strong></pre>
<p style="padding-left: 60px">It returns the same data that we got while creating the resource:</p>
<pre style="padding-left: 60px"><strong>{"id":"5cfd6cf0c281945c6cfefaab","name":"The Dark Knight","year":"2008","directors":["Christopher Nolan"],"writers":["Jonathan Nolan","Christopher Nolan"],"boxOffice":{"budget":185000000,"gross":533316061}}</strong></pre>
<ol start="13">
<li>We can easily add <kbd>PUT</kbd> (update) and <kbd>DELETE</kbd> methods to/from the preceding code. We just need to define two more handlers. First, look at the <kbd>UpdateMovie</kbd> handler. It gets the <kbd>ObjectID</kbd> as a path parameter in order to update a document in MongoDB, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px">// UpdateMovie modifies the data of given resource<br/>func (db *DB) UpdateMovie(w http.ResponseWriter, r *http.Request) {<br/>  vars := mux.Vars(r)<br/>  var movie Movie<br/>  putBody, _ := ioutil.ReadAll(r.Body)<br/>  json.Unmarshal(putBody, &amp;movie)<br/><br/>  objectID, _ := primitive.ObjectIDFromHex(vars["id"])<br/>  filter := bson.M{"_id": objectID}<br/>  update := bson.M{"$set": &amp;movie}<br/>  _, err := db.collection.UpdateOne(context.TODO(), filter, update)<br/>  ...<br/>}</pre>
<p class="mce-root"/>
<ol start="14">
<li>Next, the handler function is <kbd>DeleteMovie</kbd>. It gets the object ID from the path parameters and tries to delete a document with the same ID in the database using the <kbd>DeleteOne</kbd> method, like this:</li>
</ol>
<pre style="padding-left: 60px">// DeleteMovie removes the data from the db<br/>func (db *DB) DeleteMovie(w http.ResponseWriter, r *http.Request) {<br/>  vars := mux.Vars(r)<br/>  objectID, _ := primitive.ObjectIDFromHex(vars["id"])<br/>  filter := bson.M{"_id": objectID}<br/><br/>  _, err := db.collection.DeleteOne(context.TODO(), filter)<br/>  ...<br/>}</pre>
<p style="padding-left: 60px">In these API operations, we can also simply send the status back to the client with no HTTP body.</p>
<p style="padding-left: 60px">For these handlers to be activated by <kbd>gorilla/mux</kbd>, we have to register two new HTTP endpoints to the router, like this:</p>
<pre style="padding-left: 60px">r.HandleFunc("/v1/movies/{id:[a-zA-Z0-9]*}", db.UpdateMovie).Methods("PUT")
r.HandleFunc("/v1/movies/{id:[a-zA-Z0-9]*}", db.DeleteMovie).Methods("DELETE")</pre>
<p>The complete code for these additions is available in the <kbd>chapter5/movieAPI_updated/main.go</kbd> file. If you run the updated program, you will have a full CRUD-based API with MongoDB as a backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Boosting the querying performance with indexing</h1>
                </header>
            
            <article>
                
<p>We all know that, while reading a book, indexes are very important. When we try to search for a topic in the book, we scroll through the index page. If the topic is found in the index, then we go to the specific page number for that topic. But there is a drawback here. We are using additional pages for the sake of this indexing. Similarly, MongoDB needs to go through all the documents whenever we query for something. If the document stores indexes for important fields, it can give us data quickly. At the same time, we should remember that extra space is required for storing indexes.</p>
<p>In computing, a B-tree is an important data structure for implementing indexing because it can categorize nodes. By traversing that tree, we can find the data we need in fewer steps. We can create an index using the <kbd>createIndex</kbd> function provided by MongoDB. Take an example of students and their scores in an examination. <kbd>GET</kbd> operations are more frequent with sorting scores. The indexing for this scenario can be visualized as follows:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/8ce4cfed-ef8a-48f0-8eb3-2f0d08e0f617.png" style="width:35.67em;height:16.75em;"/></div>
<p>This is the official example given by the MongoDB website. The <strong>score</strong> is the field to be indexed because of frequent use. Once it's been indexed, the database stores the address for each document in a binary tree. Whenever someone queries this field, it checks for the range operator (in this case, it's <kbd>$lt</kbd>), traverses the binary tree, and gets the addresses of the documents in fewer steps. Since the score<strong> </strong>is indexed, the sort operations are less costly. So, the time that it takes for the database to return the sorted (ascending or descending) result is shorter.</p>
<p>Coming to our previous examples of the movies API, we can create indexes for data. By default, all the <kbd>_id</kbd><strong> </strong>fields are indexed, so we are using MongoDB shell to show that. Previously, we treated the <kbd>year</kbd> field as a string. Let's modify that so that it's an integer and index it. Launch the MongoDB shell using the <kbd>mongo</kbd> command. Connect to a new database; for example, <kbd>test</kbd>, from a MongoDB shell and insert a document into it:</p>
<pre><strong>&gt; db.movies.insertOne({ name: 'Star Trek',   year: 2009,   directors: ['J.J. Abrams'],   writers: ['Roberto Orci', 'Alex Kurtzman'],   boxOffice: {      budget:150000000,      gross:257704099   } } )</strong><br/><strong>{ </strong><br/><strong>   "acknowledged" : true,</strong><br/><strong>   "insertedId" : ObjectId("595a6cc01226e5fdf52026a1")</strong><br/><strong>}</strong></pre>
<p>Insert one more similar document containing different data:</p>
<pre><strong>&gt; db.movies.insertOne({ name: 'The Dark Knight ', year: 2008, directors: ['Christopher Nolan'], writers: ['Jonathan Nolan', 'Christopher Nolan'], boxOffice: { budget:185000000, gross:533316061 } } )</strong><br/><strong>{ </strong><br/><strong>    "acknowledged" : true,</strong><br/><strong>    "insertedId" : ObjectId("59603d3b0f41ead96110cf4f")</strong><br/><strong>}</strong></pre>
<p>Now, let's add indexing to the year with the <kbd>createIndex</kbd> function:</p>
<pre><strong>db.movies.createIndex({year: 1})</strong></pre>
<p>This single line adds the magic for retrieving the database records faster. Now, all the queries related to <kbd>year</kbd> leverage the indexing:</p>
<pre><strong>&gt; db.movies.find({year: {$lt: 2010}})</strong><br/><strong>{ "_id" : ObjectId("5957397f4e5c31eb7a9ed48f"), "name" : "Star Trek", "year" : 2009, "directors" : [ "J.J. Abrams" ], "writers" : [ "Roberto Orci", "Alex Kurtzman" ], "boxOffice" : { "budget" : 150000000, "gross" : 257704099 } }</strong><br/><strong>{ "_id" : ObjectId("59603d3b0f41ead96110cf4f"), "name" : "The Dark Knight ", "year" : 2008, "directors" : [ "Christopher Nolan" ], "writers" : [ "Jonathan Nolan", "Christopher Nolan" ], "boxOffice" : { "budget" : 185000000, "gross" : 533316061 } }</strong></pre>
<p>There is no difference in the query result. However, the lookup mechanism for documents by <kbd>MongoDB</kbd> has changed due to indexing. For a larger number of documents, this could reduce the lookup time drastically.</p>
<p>Indexing comes with a cost. Some queries run very slow on different fields if indexing is not done properly. We can also have compound indexes in MongoDB that can index multiple fields.</p>
<div class="packt_tip">MongoDB comes with a tool called <kbd>query planner</kbd>. To see the time of execution of a query, use the <kbd>explain</kbd> function after a <kbd>query</kbd> function, for example, <kbd>db.movies.find({year: {$lt: 2010}}).explain("executionStats")</kbd>. This explains the winning plan for a query, the time that it took in milliseconds, indexes used, and so on. </div>
<p>You can view the performance of indexed and non-indexed data using the <kbd>explain</kbd> function. Take a look at the MongoDB website to understand more about indexes: <a href="https://docs.mongodb.com/manual/indexes/" target="_blank">https://docs.mongodb.com/manual/indexes/</a>.</p>
<p>With all the knowledge of MongoDB and the <kbd>driver</kbd> API you have under your belt, you can start developing a REST API that uses NoSQL as a backend. In the next section, we'll present a schema for delivery logistics and get you to develop a sample API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing MongoDB documents for a delivery logistics API</h1>
                </header>
            
            <article>
                
<p>There are many cases for which a REST API can be developed. One such case is delivery logistics. In the logistics world, many entities play an important role. To know what to implement, you need to know the terminology that's used for logistics. Here, we are going to model a few JSON documents that can be implemented for MongoDB.  After going through this section, try to use this schema information as a guide to building a Logistics REST API.</p>
<p>The following six minimal components are essential in any delivery logistics design:</p>
<ul>
<li>Sender</li>
<li>Receiver</li>
<li>Package</li>
<li>Payment</li>
<li>Carrier</li>
<li>Shipment</li>
</ul>
<p>Let's look at a schema for each and every component:</p>
<ol>
<li>A sender is a person sending the package:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  _id: ObjectId("5cfe142a7ba402aacb71f710"),<br/>  first_name: "Philip",<br/>  last_name: "Zorn",<br/>  address: {<br/>    type: "work"<br/>    street: "241 Indian Spring St",<br/>    city: "Pittsburg",<br/>    state: "California",<br/>    pincode: 94565,<br/>    country: "USA"<br/>  },<br/>  "phone": "(xxx) yyy-zzzz"<br/>}</pre>
<p class="mce-root"/>
<ol start="2">
<li>A receiver receives the package from a sender:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  _id: ObjectId("5cfe142a7ba402aacb71f706"),<br/>  first_name: "Max",<br/>  last_name: "Charles",<br/>  address: {<br/>    type: "home"<br/>    street: "Ludwig Str. 5",<br/>    city: "Ansbach",<br/>    state: "Bayern",<br/>    pincode: 91522,<br/>    country: "Deutschland"<br/>  },<br/>  "phone": "xx-yyyyyy-zzzzz"<br/>}<br/><br/></pre>
<ol start="3">
<li>A sender sends a package to a receiver. So, we have to model a package document that holds package information such as dimensions in centimeters and weight in grams:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  _id: ObjectId("5cfe15607ba402aacb71f711"),<br/>  dimensions: {<br/>    width: 21,<br/>    height: 12<br/>  },<br/>  weight: 10,<br/>  is_damaged: false,<br/>  status: "In transit"<br/>}</pre>
<ol start="4">
<li>A payment transaction should be recorded when the sender buys the delivery service. It should have payment transaction details for further reference:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  _id: ObjectId("5cfe162a7ba402aacb71f713"),<br/>  initiated_on: ISODate("2019-06-10T08:38:30.894Z"),<br/>  successful_on: ISODate("2019-06-10T08:39:06.894Z").<br/>  merchant_id: 112543,<br/>  mode_of_payment: "paypal",<br/>  payment_details: {<br/>    transaction_token: "dfghjvbsclka76asdadn89"<br/>  }<br/>}</pre>
<ol start="5">
<li>Now comes the Carrier. We have a third-party international vendor to a partner that will ship the package on our behalf:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  _id: ObjectId("5cfe1a4e7ba402aacb71f714"),<br/>  name: "PHL International",<br/>  carrier_code: 988,<br/>  is_partner: true<br/>}</pre>
<ol start="6">
<li>Finally, with all those details, we have a shipment document that holds information about all the other stakeholders:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  _id: ObjectId("5cfe162a7ba402aacb71f712"),<br/>  sender: ObjectId("5cfe142a7ba402aacb71f710"),<br/>  receiver: ObjectId("5cfe142a7ba402aacb71f706"),<br/>  package: ObjectId("5cfe15607ba402aacb71f711"),<br/>  payment: ObjectId("5cfe162a7ba402aacb71f713"),<br/>  carrier: ObjectId("5cfe1a4e7ba402aacb71f714"),<br/>  promised_on: ISODate("2019-07-15T08:54:11.694Z")<br/>}</pre>
<p>A shipment contains <kbd>sender</kbd>, <kbd>receiver</kbd>, <kbd>payment</kbd>, <kbd>carrier</kbd>, and <kbd>package</kbd> details. This is a minimal document design for delivery logistics.</p>
<p>You can find all the previous MongoDB Shell schemas in this project's repository, that is, <kbd><span>chapter5/delivery_logistics</span></kbd><span>.</span></p>
<p>All the preceding schemas have been implemented to give you an idea of how a REST service can be designed for MongoDB as a storage system.</p>
<div class="packt_infobox">Note that the preceding format is for MongoDB shell. Please be aware of this difference while creating the service.</div>
<p>Here's a coding exercise for you: <em>Can you create a REST service for logistics by leveraging the knowledge we gained from the initial sections of this chapter?</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We started this chapter with an introduction to MongoDB and how it solves the problems of the modern web. MongoDB is a NoSQL database that is different from traditional relational databases. Then, we learned how to install MongoDB on all platforms, how to start the MongoDB server, and we explored the features of the MongoDB shell. The MongoDB shell is a tool that can be used to quickly check or perform CRUD operations, as well as many other operations in MongoDB. We looked at operator symbols for querying. Then, we introduced Go's MongoDB driver called <kbd>mongo-driver</kbd><strong> </strong>and learned how it's used. We created a persistent movies API with the help of <kbd>mongo-driver</kbd> and Go. Finally, we learned how to map a Go struct to a JSON document.</p>
<p>Not every query is efficient in MongoDB. So, for boosting query performance, we introduced the indexing mechanism, which reduces the document fetching time by arranging the documents in the order of a B-tree. We learned how to measure the execution time of a query using the <kbd>explain</kbd> command. Finally, we laid out a logistics document design by providing BSON (<em>MongoDB shell syntax</em>).</p>
<p>Sometimes, your REST API has to be supported with additional background services and transports. One such service is the <strong>Remote Procedure Call</strong> (<strong>RPC</strong>). When a distributed system powers a REST API, there could be thousands of RPC calls behind the scene. Those RPC calls can call different endpoints, use different data formats and transports, and so on. It is crucial to learn them if you wish to develop APIs in distributed systems. In the next chapter, we will learn how to work <span>with an RPC method called <strong>gRPC</strong> and a data format called <strong>Protocol Buffers</strong>.</span><span><br/></span></p>


            </article>

            
        </section>
    </body></html>