- en: Working with MongoDB and Go to Create a REST API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 和 Go 创建 REST API
- en: In this chapter, we are going to introduce a popular NoSQL database called MongoDB.
    We will learn how well MongoDB suits modern web services by storing documents
    instead of relations. We'll begin by learning about MongoDB collections and documents
    and create an example API with MongoDB as the database. While doing so, we'll
    use a driver package called `mongo-driver`. Then, we'll try to design a document
    model schema for a delivery logistics problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一个流行的 NoSQL 数据库 MongoDB。我们将通过存储文档而不是关系来了解 MongoDB 如何适合现代网络服务。我们将从学习
    MongoDB 集合和文档开始，并使用 MongoDB 作为数据库创建一个示例 API。在这个过程中，我们将使用一个名为 `mongo-driver` 的驱动程序包。然后，我们将尝试为配送物流问题设计一个文档模型架构。
- en: 'In this chapter, we are going to discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Introduction to MongoDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 简介
- en: Installing MongoDB and using the shell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 MongoDB 并使用 shell
- en: Introducing `mongo-driver`, an official MongoDB driver for Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 `mongo-driver`，它是 Go 的官方 MongoDB 驱动程序
- en: RESTful API with `gorilla/mux` and MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 `gorilla/mux` 和 MongoDB 的 RESTful API
- en: Boosting querying performance with indexing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过索引提高查询性能
- en: Designing MongoDB documents for delivery logistics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为配送物流设计 MongoDB 文档
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software needs to be pre-installed if you wish to run the code
    examples in this book:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望运行本书中的代码示例，以下软件需要预先安装：
- en: 'OS: Linux(Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux(Ubuntu 18.04)/Windows 10/Mac OS X >=10.13
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dep：Go 的依赖管理工具 >= 0.5.3
- en: Go compiler >= 1.13.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 编译器 >= 1.13.5
- en: MongoDB >= 4.2.3
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB >= 4.2.3
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter5](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter5).
    Clone the code and use the code samples in the `chapter5` directory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter5](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter5)
    下载本章的代码。克隆代码并使用 `chapter5` 目录中的代码示例。
- en: Introduction to MongoDB
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB 简介
- en: '**MongoDB** is a popular NoSQL database that is attracting a lot of developers
    worldwide. It is different from traditional relational databases such as MySQL,
    PostgreSQL, and SQLite3\. The main big difference with MongoDB compared to other
    databases is it is schemaless and stores collections and documents. Think of MongoDB
    collections as tables, and documents as rows in SQL databases. However, in MongoDB,
    there is no relationship between collections. This schemaless design allows MongoDB
    to scale horizontally using a mechanism called **Sharding**. MongoDB stores data
    as BSON files on disk. BSON is an efficient binary format for operation and data
    transfer. Almost all MongoDB clients convert JSON into BSON and vice versa while
    inserting or retrieving documents.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**MongoDB** 是一个流行的 NoSQL 数据库，吸引了全球许多开发者的关注。它与传统的如 MySQL、PostgreSQL 和 SQLite3
    的关系数据库不同。与其它数据库相比，MongoDB 的主要区别在于它是无模式的，并存储集合和文档。将 MongoDB 集合视为表，将文档视为 SQL 数据库中的行。然而，在
    MongoDB 中，集合之间没有关系。这种无模式的设计允许 MongoDB 通过称为 **Sharding** 的机制进行水平扩展。MongoDB 将数据存储在磁盘上的
    BSON 文件中。BSON 是一种高效的操作和数据传输的二进制格式。几乎所有的 MongoDB 客户端在插入或检索文档时都将 JSON 转换为 BSON，反之亦然。'
- en: 'Many big companies such as Expedia, Comcast, and MetLife built their applications
    on MongoDB. It has been proven as a vital element in modern internet businesses.
    MongoDB stores data in a document; think of this as a row in SQL databases. All
    MongoDB documents are stored in a collection, and this collection is similar to
    a table (in terms of SQL). Let''s look at an example. A sample document for an
    IMDb movie has a few keys, such as name, year, and directors. The values for these
    keys can be a number, boolean, string, list, or a map. This would look something
    similar to the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型公司，如 Expedia、Comcast 和 MetLife，都基于 MongoDB 构建了他们的应用程序。它已被证明是现代互联网业务中的一个关键元素。MongoDB
    以文档的形式存储数据；将其视为 SQL 数据库中的一行。所有 MongoDB 文档都存储在集合中，这个集合类似于表（在 SQL 的意义上）。让我们看看一个例子。一个
    IMDb 电影的示例文档有几个键，如名称、年份和导演。这些键的值可以是数字、布尔值、字符串、列表或映射。这看起来可能类似于以下内容：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The main advantages of MongoDB over relational databases are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 相对于关系数据库的主要优势如下：
- en: Easy to model (schema-free)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于建模（无模式）
- en: Can leverage querying power
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以利用查询能力
- en: Document structure suits modern-day web applications (**JSON**)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档结构适合现代网络应用程序（**JSON**）
- en: More scalable than relational databases (via **Sharding**)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比关系型数据库更可扩展（通过 **分片**）
- en: Now that we know what MongoDB is, let's look at it in more detail. In the next
    section, we will learn how to install MongoDB and try to access it from the MongoDB
    shell.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 MongoDB 是什么，让我们更详细地看看它。在下一节中，我们将学习如何安装 MongoDB 并尝试从 MongoDB 壳中访问它。
- en: Installing MongoDB and using the shell
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 MongoDB 和使用壳
- en: 'MongoDB can be easily installed on any platform. On Ubuntu 18.04, we need to
    perform some steps before running the `apt-get` command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 可以轻松地安装在任何平台上。在 Ubuntu 18.04 上，在运行 `apt-get` 命令之前，我们需要执行一些步骤：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you''ve installed it, check whether the `mongo` process is running. If
    not, you can start the MongoDB daemon using the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，检查 `mongo` 进程是否正在运行。如果没有，可以使用以下命令启动 MongoDB 守护进程：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the user is root, you can drop the `sudo` keyword before each command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户是 root，可以在每个命令之前删除 `sudo` 关键字。
- en: We can also download MongoDB manually from the website and copy it to `/usr/local/bin`.
    To do this, we have to create an init script for the server since the server stops
    when the system is shut down. We can use the `nohup` tool to run the server in
    the background. Usually, it is better to install it using `apt-get`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从网站上手动下载 MongoDB 并将其复制到 `/usr/local/bin`。为此，我们必须为服务器创建一个初始化脚本，因为当系统关闭时，服务器会停止。我们可以使用
    `nohup` 工具在后台运行服务器。通常，使用 `apt-get` 安装它更好。
- en: 'To install MongoDB on Mac OS X, you''ll need to use the Homebrew software.
    Follow these steps to do so:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Mac OS X 上安装 MongoDB，您需要使用 Homebrew 软件。按照以下步骤进行操作：
- en: 'We can easily install it using the following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令轻松安装它：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, we need to create the `db` directory where MongoDB stores its database:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要创建 MongoDB 存储数据库的 `db` 目录：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, change the permissions of that file using `chown`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `chown` 修改该文件的权限：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, MongoDB is ready. To see its logs interactively, we need to stop MongoDB
    as a process and run it in a shell. To stop the service, use the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，MongoDB 已经准备好了。为了交互式地查看其日志，我们需要停止 MongoDB 作为进程并在壳中运行它。要停止服务，请使用以下命令：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, in a Terminal window, run the following command, which starts MongoDB
    interactively (not in the background):'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端窗口中，运行以下命令，这将交互式地启动 MongoDB（不在后台）：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding command results in the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会产生以下输出：
- en: '![](img/453088c4-7456-4317-ba8f-0ed64145380f.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/453088c4-7456-4317-ba8f-0ed64145380f.png)'
- en: The preceding command shows the status of the database in a few columns. From
    these `logs`, we can figure out that the server started on port `27017`. It displays
    the build environment, the storage engine that was used, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令显示了数据库状态的一些列。从这些 `日志` 中，我们可以推断出服务器在端口 `27017` 上启动。它显示了构建环境、使用的存储引擎等等。
- en: On Windows, we can manually download the installer binary and launch it by adding
    the installation `bin` directory to the `PATH` variable. Then, we can run it using
    the `mongod`command. Alongside the MongoDB installation comes a client shell called
    Mongo. We will look at it in brief in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们可以手动下载安装程序二进制文件，通过将安装 `bin` 目录添加到 `PATH` 变量中来启动它。然后，我们可以使用 `mongod`
    命令运行它。与 MongoDB 安装一起来的还有一个名为 Mongo 的客户端壳。我们将在下一节简要介绍它。
- en: Working with the MongoDB shell
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 壳工作
- en: 'Whenever we start using MongoDB, the first thing we need to explore is the
    available commands that we can use in order to interact with it. Looking up the
    available databases, collections, documents, and so on can be done with a simple
    client tool called **MongoDB shell**. It is similar to the MySQL client. This
    shell program is included in the standard MongoDB server installation. We can
    launch it using the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们开始使用 MongoDB 时，我们首先需要探索的是我们可以用来与之交互的可用命令。通过一个简单的客户端工具查找可用的数据库、集合、文档等，称为
    **MongoDB 壳**。它与 MySQL 客户端类似。这个壳程序包含在标准的 MongoDB 服务器安装中。我们可以使用以下命令启动它：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Refer to the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图：
- en: '![](img/761f8225-770c-4e69-8bc4-5a3b943c0134.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/761f8225-770c-4e69-8bc4-5a3b943c0134.png)'
- en: If you see that a `session` ID has been created, as shown in the preceding screenshot,
    everything worked fine. If you get an error, the server is probably not running
    as expected. To troubleshoot, have a look at the MongoDB troubleshooting guide
    at [https://docs.mongodb.com/manual/faq/diagnostics](https://docs.mongodb.com/manual/faq/diagnostics/).
    The client provides information about MongoDB versions and other warnings. To
    see all the available shell commands, use the `help` command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到已经创建了一个 `session` ID，如前面的截图所示，那么一切正常。如果您收到错误，服务器可能没有按预期运行。为了排除故障，请查看 MongoDB
    故障排除指南[https://docs.mongodb.com/manual/faq/diagnostics](https://docs.mongodb.com/manual/faq/diagnostics/)。客户端提供有关
    MongoDB 版本和其他警告的信息。要查看所有可用的 shell 命令，请使用 `help` 命令。
- en: 'Let''s create a new collection called `movies` and insert the preceding example
    document into it. Follow these steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `movies` 的新集合，并将前面的示例文档插入其中。按照以下步骤操作：
- en: 'By default, the database will be a test database:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，数据库将是一个测试数据库：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding `show` command lists all available databases. `admin`, `config`,
    `test`, and `local` are the four databases available by default.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `show` 命令列出了所有可用的数据库。`admin`、`config`、`test` 和 `local` 是默认可用的四个数据库。
- en: 'To create a new database or switch to an existing database, just type `use
    db_name`. In our case, let''s name our database `appDB`. Type the following into
    a MongoDB shell:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建新数据库或切换到现有数据库，只需键入 `use db_name`。在我们的例子中，让我们将我们的数据库命名为 `appDB`。在 MongoDB
    shell 中键入以下内容：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This switches the current database to the `appDB` database.If you try to list
    the available databases, `appDB` won't show up because MongoDB only creates a
    physical database when some data is inserted into it (first collection or document).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将当前数据库切换到 `appDB` 数据库。如果您尝试列出可用的数据库，`appDB` 不会显示，因为 MongoDB 只有在向其中插入一些数据时（第一个集合或文档）才会创建物理数据库。
- en: 'Now, we can create a new collection by inserting the first document. We can
    insert the sample document for IMDb movies into a collection called `movies`using
    the following command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过插入第一个文档来创建一个新的集合。我们可以使用以下命令将 IMDb 电影的示例文档插入到名为 `movies` 的集合中：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The JSON you inserted has an ID called `_id`. We can provide it while inserting
    a document, or MongoDB itself can generate one for you.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您插入的 JSON 中有一个名为 `_id` 的 ID。我们可以在插入文档时提供它，或者 MongoDB 本身可以为您生成一个。
- en: 'In SQL databases, we use *auto-increment* along with an `ID` schema toincrement
    the `ID` field. Here, MongoDB generates a unique hash `ID` rather than a sequence.
    Let''s insert one more document about `The Dark Knight`, but this time, we won''t
    pass the `_id` field:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SQL 数据库中，我们使用 *auto-increment* 与 `ID` 架构一起增加 `ID` 字段。在这里，MongoDB 生成一个唯一的哈希
    `ID` 而不是序列。让我们插入一个关于《黑暗骑士》的更多文档，但这次我们不会传递 `_id` 字段：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown by the acknowledgement JSON response, `insertedId` haschanged to a
    very lengthy `59574125bf7a73d140d5ba4a`.This is the unique hash that's generated
    by MongoDB.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如确认 JSON 响应所示，`insertedId` 已更改为一个非常长的 `59574125bf7a73d140d5ba4a`。这是由 MongoDB
    生成的唯一哈希。
- en: We can also insert a batch of documents at a given time using the `insertMany`
    function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `insertMany` 函数在给定时间内插入一批文档。
- en: 'Using the `find` function without arguments on the movies collection returns
    all the matched documents, like this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在电影集合上使用不带参数的 `find` 函数将返回所有匹配的文档，如下所示：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order to return a single document, use the `findOne` function. This returns
    the oldest document from multiple results:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了返回单个文档，请使用 `findOne` 函数。这返回多个结果中最旧的文档：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'How do we query documents? Querying in MongoDB is known as filtering data and
    returning a result. If we need to filter for movies that were released in `2008`,
    then we can do this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何查询文档？在 MongoDB 中，查询被称为过滤数据并返回结果。如果我们需要过滤 2008 年发布的电影，我们可以这样做：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The filter query from the preceding MongoDB shell statement is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 MongoDB shell 语句中的过滤查询如下：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This states that the searching criterion is the `year` and that the value should
    be `2008`. `$eq` is called a **filtering operator**, which helps to relate the
    condition between the field and data. It is equivalent to the `=` operator in
    SQL. In SQL, the equivalent query can be written as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示搜索标准是 `year`，并且值应该是 `2008`。`$eq` 被称为 **过滤运算符**，它有助于在字段和数据之间建立条件关系。它在 SQL
    中相当于 `=` 运算符。在 SQL 中，等效的查询可以写成以下内容：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can simplify the previously written MongoDB shell statement to the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将之前编写的 MongoDB shell 语句简化为以下内容：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This filter query and the previous filter query are the same since they return
    the same set of documents. The former syntax is using `$eq`, which is a query
    operator. From now on, we'll call a *query operator* simply an *operator*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤查询和之前的过滤查询是相同的，因为它们返回相同的文档集。前者的语法是使用`$eq`，这是一个查询操作符。从现在起，我们将一个*查询操作符*简单地称为*操作符*。
- en: 'The other main operators are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其他主要操作符如下：
- en: '| **Operator** | ** Function** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **函数** |'
- en: '| `$lt` | `Less than` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `$lt` | `小于` |'
- en: '| `$gt` | `Greater than` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `$gt` | `大于` |'
- en: '| `$in` | `In the` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `$in` | `在...之中` |'
- en: '| `$lte` | `Less than or equal to` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `$lte` | `小于或等于` |'
- en: '| `$ne` | `Not equal to` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `$ne` | `不等于` |'
- en: 'You can find all the available operators here: [https://docs.mongodb.com/manual/reference/operator/](https://docs.mongodb.com/manual/reference/operator/).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到所有可用的操作符：[https://docs.mongodb.com/manual/reference/operator/](https://docs.mongodb.com/manual/reference/operator/).
- en: 'Now, let''s pose a question to ourselves. We have a requirement to fetch all
    the documents whose budget is more than $150,000,000\. How can we filter this
    with the query knowledge we gained previously? Take a look at the following code
    snippet:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们给自己提出一个问题。我们有一个需求，需要获取所有预算超过$150,000,000的文档。如何使用我们之前学到的查询知识来过滤这些文档？看看下面的代码片段：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we accessed the `budget` key within the JSON using `boxOffice.budget`.The
    beauty of MongoDB is that it allows us to query the JSON with a lot of freedom.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用`boxOffice.budget`在JSON中访问了`budget`键。MongoDB的美丽之处在于它允许我们以很大的自由度查询JSON。
- en: 'Can''t we add two or more operators to the criteria while fetching documents?
    Yes, we can! Let''s find all the movies in the database that were released in
    `2009` with a budget of more than $150,000,000:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在获取文档时不能添加两个或更多操作符到标准吗？是的，我们可以！让我们找到数据库中所有在`2009`年上映且预算超过$150,000,000的电影：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This returns nothing because we don''t have any documents that match the given
    criteria. By default, comma-separated query fields, such as `''boxOffice.budget'':
    {$gt: 150000000}, year: 2009 `, are combined with the `AND`operation.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '这没有返回任何内容，因为我们没有符合给定标准的任何文档。默认情况下，以逗号分隔的查询字段，如`''boxOffice.budget'': {$gt:
    150000000}, year: 2009`，会与`AND`操作结合。'
- en: 'Now, let''s relax our condition and find any movies that were either released
    in `2009` or had a budget of more than $150,000,000:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们放宽条件，找到任何在`2009`年上映或预算超过$150,000,000的电影：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the query is a bit different. We used an operator called `$or`to find
    the predicate of the two conditions. The result will be the criteria for fetching
    the documents. `$or`needs to be assigned to a list (see the preceding query) of
    JSON condition objects. Since JSON can be nested, conditions can also be nested.
    This style of querying might look new to people coming from a SQL background.
    The MongoDB team designed it to intuitively filter data. We can also write advanced
    queries such as inner joins, outer joins, nested queries, and so on easily in
    MongoDB with the clever use of operators.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，查询略有不同。我们使用了一个名为`$or`的操作符来找到两个条件的谓词。结果将是获取文档的标准。`$or`需要分配给一个JSON条件对象的列表（见前面的查询）。由于JSON可以嵌套，条件也可以嵌套。这种查询风格可能对来自SQL背景的人来说是新的。MongoDB团队设计它以直观地过滤数据。我们也可以通过巧妙地使用操作符，在MongoDB中轻松编写如内连接、外连接、嵌套查询等高级查询。
- en: 'So far, we have explored two **Create**, **Read**, **Update**, and **Delete**
    (**CRUD**) operations in order to create and read on MongoDB documents. Now, we''ll
    look at the update and delete operations. To update a document, use the `db.collection.update`
    method. The syntax consists of the criteria and a set operation:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了两个**创建**、**读取**、**更新**和**删除**（**CRUD**）操作，以便在MongoDB文档上创建和读取。现在，我们将查看更新和删除操作。要更新一个文档，使用`db.collection.update`方法。语法包括标准和设置操作：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s update Star Trek (ID: 5)''s box office budget. Our goal is to change
    `150000000` to `200000000`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新《星际迷航》（ID：5）的票房预算。我们的目标是把`150000000`改为`200000000`：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first argument for the `update` method is the filter criteria. The second
    argument is a `$set` operator that changes the fields/sections in the document.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法的第一个参数是过滤标准。第二个参数是一个`$set`操作符，它更改文档中的字段/部分。'
- en: 'Now, let''s take a look at the delete operation. We can delete a document from
    a given collection using the `deleteOne` and `deleteMany` functions:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看删除操作。我们可以使用`deleteOne`和`deleteMany`函数从给定的集合中删除一个文档：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The argument that's passed to the **`deleteOne` **function is a filter criterion,
    which is similar to the read and update operations. All the documents that match
    the given criteria will be removed from the collection. The response contains
    a nice acknowledgment message with a count of documents that were deleted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 **`deleteOne`** 函数的参数是一个过滤条件，这与读取和更新操作类似。所有符合给定条件的文档都将从集合中删除。响应包含一个友好的确认消息，其中包含已删除文档的数量。
- en: This and the preceding sections discussed the basics of MongoDB with the MongoDB
    shell. However, how we can do the same thing from a Go program? We need to use
    a driver package. In the next section, we'll explore the official MongoDB driver
    package for Go, called `mongo-driver`. MongoDB supports official drivers for major
    languages such as Python, Java, Ruby, and Go.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分和前面的章节讨论了使用 MongoDB shell 的 MongoDB 基础知识。然而，我们如何从一个 Go 程序中完成相同的事情？我们需要使用一个驱动程序包。在下一节中，我们将探索官方的
    MongoDB Go 驱动程序包，称为 `mongo-driver`。MongoDB 支持包括 Python、Java、Ruby 和 Go 在内的主要语言的官方驱动程序。
- en: Introducing mongo-driver, an official MongoDB driver for Go
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 mongo-driver，Go 的官方 MongoDB 驱动程序
- en: '`mongo-driver` is a rich MongoDB driver that allows developers to write applications
    that use MongoDB as the database. The Go application can talk easily with MongoDB
    for all its CRUD operations using the `mongo` driver. It is an open source implementation
    maintained by MongoDB and can be used and modified freely. We can think of it
    as a wrapper around the MongoDB API. Installing the package is similar to other
    `go get` commands. However, in this chapter, we''ll introduce a new Go package
    tool called `dep`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongo-driver` 是一个功能丰富的 MongoDB 驱动程序，允许开发者编写使用 MongoDB 作为数据库的应用程序。Go 应用程序可以使用
    `mongo` 驱动程序轻松地与 MongoDB 进行所有 CRUD 操作。这是一个由 MongoDB 维护的开源实现，可以自由使用和修改。我们可以将其视为
    MongoDB API 的包装器。安装此包的命令与其他 `go get` 命令类似。然而，在本章中，我们将介绍一个新的 Go 包工具，称为 `dep`。'
- en: '`dep` is a Go package installer tool similar to Python''s `pip` or JavaScript''s
    `npm`. Follow this web page to install the dep tool on various platforms: [https://golang.github.io/dep/docs/installation.html](https://golang.github.io/dep/docs/installation.html).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`dep` 是一个类似于 Python 的 `pip` 或 JavaScript 的 `npm` 的 Go 包安装工具。按照以下网页安装 dep 工具到各种平台：[https://golang.github.io/dep/docs/installation.html](https://golang.github.io/dep/docs/installation.html)。'
- en: 'Let''s write a Go program that inserts `The Dark Knight` movie document into
    MongoDB. Follow these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个 Go 程序，将 `The Dark Knight` 电影文档插入到 MongoDB 中。按照以下步骤操作：
- en: 'Create a directory for our project:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的项目创建一个目录：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, traverse to the `intro` directory and initialize the `dep` tool. It creates
    a few files so that we can track package dependencies:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到 `intro` 目录并初始化 `dep` 工具。它创建了一些文件，以便我们可以跟踪包依赖项：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the `mongo-driver` dependency to `dep`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `mongo-driver` 依赖项添加到 `dep` 中：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a `main` file, like this:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main` 文件，如下所示：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is all we need to do to set up all the files and dependencies. To represent
    the movie and box office, we have to create structs that imitate the BSON data.
    These structs look like this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们设置所有文件和依赖项所需做的全部工作。为了表示电影和票房，我们必须创建模仿 BSON 数据的结构体。这些结构体看起来像这样：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We used `bson` tags for the struct fields. The reason we did this is that the `mongo-driver`
    package uses another package called `bson` to serialize Go structs into BSON format.
    This `bson` package needs some meta information in the form of tags to process
    fields. Hence, we attach a few `helper` tags. The preceding structs represent
    the BSON documents in memory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为结构体字段使用了 `bson` 标签。我们这样做的原因是 `mongo-driver` 包使用另一个名为 `bson` 的包将 Go 结构体序列化为
    BSON 格式。这个 `bson` 包需要一些以标签形式存在的元信息来处理字段。因此，我们附加了一些 `helper` 标签。前面的结构体代表了内存中的 BSON
    文档。
- en: 'Now, we have to import two packages called `mongo` and `options` from `mongo-driver`.
    The `bson` package is required if we wish to perform queries on MongoDB collections.
    The import section of the program looks like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须从 `mongo-driver` 中导入两个名为 `mongo` 和 `options` 的包。如果我们希望对 MongoDB 集合执行查询，则需要
    `bson` 包。程序中的导入部分看起来像这样：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, in the `main` function, we have to create a database client and connect
    to it. This should happen in the main block of the program. As per the `mongo-driver`
    API, we create an instance of `ClientOptions`. The `ClientOptions` object holds
    details such as the database server''s information (host and port) and so on.
    Then, we create a client using a context and the `ClientOptions` object. The context
    is used as a request timeout. With the help of the client, we can ping the database
    using the `Ping` method. If the database ping is successful, we can fetch the
    reference for a collection. The logic for creating a client and pinging the server
    looks like this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `main` 函数中，我们必须创建一个数据库客户端并连接到它。这应该在程序的 main 块中完成。根据 `mongo-driver` API，我们创建一个
    `ClientOptions` 实例。`ClientOptions` 对象包含数据库服务器信息（主机和端口）等细节。然后，我们使用上下文和 `ClientOptions`
    对象创建一个客户端。上下文用作请求超时。借助客户端，我们可以使用 `Ping` 方法ping数据库。如果数据库ping成功，我们可以获取集合的引用。创建客户端和ping服务器的逻辑如下：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that the collection is ready, we can insert a movie record into the database. `mongo-driver`
    provides a method called `InsertOne` for a collection. We can insert a struct
    into the database collection as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在集合已准备就绪，我们可以将电影记录插入到数据库中。`mongo-driver` 为集合提供了一个名为 `InsertOne` 的方法。我们可以将结构体插入到数据库集合中，如下所示：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By doing this, a record has been inserted into the database. Let''s retrieve
    it using a query with a filter, that is, a movie with a box office budget greater
    than $150 million. We should create an empty movie struct to hold the result.
    A filter query can be constructed using the `bson.M` struct. It is a generic map
    that holds `KEY:VALUE` pairs and is convenient for creating BSON queries. The
    `collection.FindOne` method takes a filter query and returns a `SingleResult`
    object. We can decode that object into the empty movie struct like so:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这样做，一条记录已被插入到数据库中。让我们使用带有过滤器的查询检索它，即票房预算超过 150 亿美元的电影。我们应该创建一个空的电影结构体来存储结果。可以使用
    `bson.M` 结构体构建一个过滤器查询。它是一个通用的映射，包含 `KEY:VALUE` 对，便于创建 BSON 查询。`collection.FindOne`
    方法接受一个过滤器查询并返回一个 `SingleResult` 对象。我们可以将此对象解码到空的电影结构体中，如下所示：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we disconnect from the database once our operations have been completed:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的操作完成后，从数据库断开连接：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can run the entire program using the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码运行整个程序：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output looks as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The result from a query can be stored in a new struct and can be serialized
    into JSON so that the clients can use it too. For that, you should add JSON meta
    tags to the struct, along with BSON tags.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的结果可以存储在一个新的结构体中，并可以序列化为 JSON，以便客户端也能使用它。为此，你应该在结构体中添加 JSON 元标签，以及 BSON 标签。
- en: RESTful API with gorilla/mux and MongoDB
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 gorilla/mux 和 MongoDB 的 RESTful API
- en: In the previous chapters, we explored all the possible ways of building a RESTful
    API. We used basic HTTP routers, as well as many other web frameworks. However,
    to keep it simple, we can use `gorilla/mux` with `mongo-driver` for the MongoDB
    driver. In this section, we will build an end-to-end movie API while integrating
    the database and HTTP router. In the previous section, we learned how to create
    a new MongoDB document and retrieve it using `mongo-driver`. By consolidating
    our knowledge of HTTP routers and databases, we can create a movie API.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了构建 RESTful API 的所有可能方式。我们使用了基本的 HTTP 路由器，以及许多其他网络框架。然而，为了保持简单，我们可以使用
    `gorilla/mux` 与 `mongo-driver` 作为 MongoDB 驱动器。在本节中，我们将构建一个端到端的电影 API，同时集成数据库和
    HTTP 路由器。在前一节中，我们学习了如何使用 `mongo-driver` 创建新的 MongoDB 文档并检索它。通过整合我们对 HTTP 路由器和数据库的知识，我们可以创建一个电影
    API。
- en: 'Let''s create the plan so that we can create the API:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制定计划，以便我们可以创建 API：
- en: Prepare structs to hold movie information and the database connection.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备结构体来存储电影信息和数据库连接。
- en: Create a server for hosting the API.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于托管 API 的服务器。
- en: Prepare the routes for the API endpoints.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备 API 端点的路由。
- en: Implement handlers for the routes.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现路由的处理程序。
- en: 'We have to follow these steps to achieve our goal:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须遵循以下步骤才能实现我们的目标：
- en: 'Create a directory to hold our project:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录来存放我们的项目：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add a `main.go` file in the project:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个 `main.go` 文件：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Please install the `mongo-driver` package using the `dep` tool, just like we
    did in the previous section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用 `dep` 工具安装 `mongo-driver` 包，就像我们在前一节中所做的那样。
- en: 'Let''s take a look at the structs we need to create; that is, `DB`, `Movie`,
    and `BoxOffice`. `Movie` and `BoxOffice` hold the movie information. The `DB`
    struct holds a collection in a MongoDB database that can be passed across multiple
    functions. The code for this is as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们需要创建的结构体；即，`DB`、`Movie` 和 `BoxOffice`。`Movie` 和 `BoxOffice` 存储电影信息。`DB`
    结构体在 MongoDB 数据库中存储一个集合，该集合可以在多个函数之间传递。相应的代码如下：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We need a few important packages in order to implement our API. These are `gorilla/mux`,
    `mongo-driver`, and a few other `helper` packages. Let''s look at how to import
    these packages:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现我们的 API，我们需要几个重要的包。这些是 `gorilla/mux`、`mongo-driver` 和几个其他的 `helper` 包。让我们看看如何导入这些包：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We need the `primitive` package to generate an `ObjectID` from a string, the `bson`
    package to create query filters, and the `mongo/options` package to create a MongoDB
    client.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `primitive` 包从字符串生成 `ObjectID`，`bson` 包用于创建查询过滤器，以及 `mongo/options` 包用于创建
    MongoDB 客户端。
- en: 'Let''s create the `main` function, which is where we create a MongoDB client. The
    client is created by passing options to the `Connect` method. Once we are connected
    to MongoDB, which is running locally on port `27017`, we can access the collection
    using the `Database.Collection` method. We can delay cleaning up the connection
    using the `defer`  keyword:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建 `main` 函数，这是创建 MongoDB 客户端的地方。客户端是通过传递选项给 `Connect` 方法创建的。一旦我们连接到本地运行的
    MongoDB（端口 `27017`），我们就可以使用 `Database.Collection` 方法访问集合。我们可以使用 `defer` 关键字延迟清理连接：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `defer` keyword is special in a Go program. It defers a function call so
    that it's executed right before the enclosing outer function returns. It is commonly
    used for I/O connection cleanup.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 关键字在 Go 程序中是特殊的。它延迟一个函数调用，以便它在包含的外部函数返回之前执行。它通常用于 I/O 连接清理。'
- en: In our case, the enclosing function is the `main`, and the deferred function
    is `client.Disconnect`. So, when `main` returns/terminates, the defer statement
    closes the MongoDB connection properly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，包含的函数是 `main`，延迟的函数是 `client.Disconnect`。所以，当 `main` 返回/终止时，defer 语句会正确地关闭
    MongoDB 连接。
- en: 'Next, we create a few HTTP routes for the `GET` and `POST` operations on a
    movie. Let''s call them `GetMovie` and `PostMovie`, respectively. The code looks
    like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为电影上的 `GET` 和 `POST` 操作创建一些 HTTP 路由。让我们分别称它们为 `GetMovie` 和 `PostMovie`。代码如下：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we can start a server using the `http.Server` method, as shown in the
    following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `http.Server` 方法启动服务器，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now comes the actual implementation of the handlers. `GetMovie`, like any other
    mux handler, takes response and request objects. It receives an `ObjectId` (hex
    string) of the movie from the path parameters and queries a matching document
    from the database. We can use the `mux.Vars` map to collect path parameters.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是处理器的实际实现。`GetMovie`，像任何其他的 mux 处理器一样，接收响应和请求对象。它从路径参数中接收电影的 `ObjectId`（十六进制字符串）并从数据库中查询匹配的文档。我们可以使用
    `mux.Vars` 映射来收集路径参数。
- en: We can't simply form a filter query using the raw ID. We have to convert the
    hex string that was passed into the `ObjectID` using the `primitive.ObjectIDFromHex`
    method from the `mongo-driver/bson/primitive` package. We should use this `ObjectID` in
    a `filter` query.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地使用原始 ID 形成过滤查询。我们必须使用来自 `mongo-driver/bson/primitive` 包的 `primitive.ObjectIDFromHex`
    方法将传递的十六进制字符串转换为 `ObjectID`。我们应该在 `filter` 查询中使用这个 `ObjectID`。
- en: 'Then, we run a query using the `collection.FindOne` method. The result can
    then be decoded into a `Movie` struct literal and returned as a JSON `response`.
    Take a look at the following code for the `GetMovie` function handler:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `collection.FindOne` 方法运行查询。结果可以解码为 `Movie` 结构体字面量并作为 JSON `response`
    返回。请看以下 `GetMovie` 函数处理器的代码：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`PostMovie` has the exact same function signature as the `GET` handler function.
    Instead of reading from the path parameters, it reads information from the request
    body in JSON and un-marshalls it into the `Movie` struct. Then, we use the `collection.InsertOne`
    method and perform a database insert operation. The result of the JSON is sent
    back as an HTTP response. The code for the `PostMovie` handler function looks
    like this:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PostMovie` 与 `GET` 处理器函数具有完全相同的函数签名。它不是从路径参数中读取信息，而是从请求体中读取 JSON 信息并将其反序列化为
    `Movie` 结构体。然后，我们使用 `collection.InsertOne` 方法执行数据库插入操作。JSON 的结果作为 HTTP 响应发送回。`PostMovie`
    处理器函数的代码如下：'
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s run the program:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行程序：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we open a Terminal and make a `POST` API request using `curl` or `Postman`
    to create a new movie:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们打开终端，使用 `curl` 或 `Postman` 发送 `POST` API 请求以创建一个新的电影：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This returns the following response:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回以下响应：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Our movie has been created successfully. Next, let''s retrieve it. Make a `GET`
    API request using `curl`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的电影已成功创建。接下来，让我们检索它。使用 `curl` 发送 `GET` API 请求：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It returns the same data that we got while creating the resource:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回我们在创建资源时得到的数据：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can easily add `PUT` (update) and `DELETE` methods to/from the preceding
    code. We just need to define two more handlers. First, look at the `UpdateMovie`
    handler. It gets the `ObjectID` as a path parameter in order to update a document
    in MongoDB, as shown in the following code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加 `PUT`（更新）和 `DELETE` 方法到/从前面的代码中。我们只需要定义两个额外的处理器。首先，看看 `UpdateMovie`
    处理器。它通过路径参数获取 `ObjectID` 以更新 MongoDB 中的文档，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, the handler function is `DeleteMovie`. It gets the object ID from the
    path parameters and tries to delete a document with the same ID in the database
    using the `DeleteOne` method, like this:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，处理器函数是 `DeleteMovie`。它从路径参数中获取对象 ID，并尝试使用 `DeleteOne` 方法在数据库中删除具有相同 ID 的文档，如下所示：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In these API operations, we can also simply send the status back to the client
    with no HTTP body.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些 API 操作中，我们也可以简单地向客户端发送状态，而不需要 HTTP 主体。
- en: 'For these handlers to be activated by `gorilla/mux`, we have to register two
    new HTTP endpoints to the router, like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这些处理器由 `gorilla/mux` 激活，我们必须将两个新的 HTTP 端点注册到路由器中，如下所示：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The complete code for these additions is available in the `chapter5/movieAPI_updated/main.go`
    file. If you run the updated program, you will have a full CRUD-based API with
    MongoDB as a backend.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些添加的完整代码可在 `chapter5/movieAPI_updated/main.go` 文件中找到。如果您运行更新后的程序，您将拥有一个基于 MongoDB
    后端的完整 CRUD API。
- en: Boosting the querying performance with indexing
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过索引提高查询性能
- en: We all know that, while reading a book, indexes are very important. When we
    try to search for a topic in the book, we scroll through the index page. If the
    topic is found in the index, then we go to the specific page number for that topic.
    But there is a drawback here. We are using additional pages for the sake of this
    indexing. Similarly, MongoDB needs to go through all the documents whenever we
    query for something. If the document stores indexes for important fields, it can
    give us data quickly. At the same time, we should remember that extra space is
    required for storing indexes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，在阅读书籍时，索引非常重要。当我们试图在书中搜索一个主题时，我们会滚动索引页面。如果主题在索引中找到，我们就去该主题的具体页码。但这里有一个缺点。我们为了这个索引使用了额外的页面。同样，MongoDB
    需要每次查询时都遍历所有文档。如果文档存储了重要字段的索引，它可以快速提供数据。同时，我们应该记住，存储索引需要额外的空间。
- en: 'In computing, a B-tree is an important data structure for implementing indexing
    because it can categorize nodes. By traversing that tree, we can find the data
    we need in fewer steps. We can create an index using the `createIndex` function
    provided by MongoDB. Take an example of students and their scores in an examination. `GET` operations
    are more frequent with sorting scores. The indexing for this scenario can be visualized
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，B-tree 是实现索引的重要数据结构，因为它可以分类节点。通过遍历该树，我们可以以更少的步骤找到所需的数据。我们可以使用 MongoDB
    提供的 `createIndex` 函数创建索引。以学生及其考试成绩为例。`GET` 操作在排序成绩时更为频繁。这种场景的索引可以可视化如下：
- en: '![](img/8ce4cfed-ef8a-48f0-8eb3-2f0d08e0f617.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ce4cfed-ef8a-48f0-8eb3-2f0d08e0f617.png)'
- en: This is the official example given by the MongoDB website. The **score** is
    the field to be indexed because of frequent use. Once it's been indexed, the database
    stores the address for each document in a binary tree. Whenever someone queries
    this field, it checks for the range operator (in this case, it's `$lt`), traverses
    the binary tree, and gets the addresses of the documents in fewer steps. Since
    the scoreis indexed, the sort operations are less costly. So, the time that it
    takes for the database to return the sorted (ascending or descending) result is
    shorter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由 MongoDB 网站提供的官方示例。**score** 是因为频繁使用而被索引的字段。一旦它被索引，数据库就会将每个文档的地址存储在一个二叉树中。每当有人查询这个字段时，它会检查范围运算符（在这种情况下，它是
    `$lt`），遍历二叉树，并在更少的步骤中获取文档的地址。由于 score 已被索引，排序操作的成本较低。因此，数据库返回排序（升序或降序）结果所需的时间更短。
- en: 'Coming to our previous examples of the movies API, we can create indexes for
    data. By default, all the `_id`fields are indexed, so we are using MongoDB shell
    to show that. Previously, we treated the `year` field as a string. Let''s modify
    that so that it''s an integer and index it. Launch the MongoDB shell using the `mongo`
    command. Connect to a new database; for example, `test`, from a MongoDB shell
    and insert a document into it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前提到的电影API的示例，我们可以为数据创建索引。默认情况下，所有`_id`字段都是索引的，所以我们使用MongoDB shell来显示这一点。之前，我们将`year`字段视为字符串。让我们将其修改为整数并对其进行索引。使用`mongo`命令启动MongoDB
    shell。从一个MongoDB shell连接到一个新数据库；例如，`test`，并向其中插入一个文档：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Insert one more similar document containing different data:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 插入一个包含不同数据的类似文档：
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let''s add indexing to the year with the `createIndex` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`createIndex`函数为年份添加索引：
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This single line adds the magic for retrieving the database records faster.
    Now, all the queries related to `year` leverage the indexing:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行添加了检索数据库记录更快的方法。现在，所有与`year`相关的查询都利用了索引：
- en: '[PRE57]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There is no difference in the query result. However, the lookup mechanism for
    documents by `MongoDB` has changed due to indexing. For a larger number of documents,
    this could reduce the lookup time drastically.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果没有差异。然而，由于索引，通过`MongoDB`查找文档的机制已经改变。对于大量文档，这可能会大大减少查找时间。
- en: Indexing comes with a cost. Some queries run very slow on different fields if
    indexing is not done properly. We can also have compound indexes in MongoDB that
    can index multiple fields.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是有成本的。如果索引没有正确设置，一些查询在不同字段上运行会非常慢。MongoDB中还可以有复合索引，可以索引多个字段。
- en: 'MongoDB comes with a tool called `query planner`. To see the time of execution
    of a query, use the `explain` function after a `query` function, for example,
    `db.movies.find({year: {$lt: 2010}}).explain("executionStats")`. This explains
    the winning plan for a query, the time that it took in milliseconds, indexes used,
    and so on.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'MongoDB附带一个名为`query planner`的工具。要查看查询的执行时间，请在`query`函数之后使用`explain`函数，例如，`db.movies.find({year:
    {$lt: 2010}}).explain("executionStats")`。这解释了查询的获胜计划、所需时间（以毫秒为单位）、使用的索引等。'
- en: You can view the performance of indexed and non-indexed data using the `explain` function.
    Take a look at the MongoDB website to understand more about indexes: [https://docs.mongodb.com/manual/indexes/](https://docs.mongodb.com/manual/indexes/).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`explain`函数查看索引和非索引数据的性能。请访问MongoDB网站了解有关索引的更多信息：[https://docs.mongodb.com/manual/indexes/](https://docs.mongodb.com/manual/indexes/).
- en: With all the knowledge of MongoDB and the `driver` API you have under your belt,
    you can start developing a REST API that uses NoSQL as a backend. In the next
    section, we'll present a schema for delivery logistics and get you to develop
    a sample API.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的口袋里拥有MongoDB和`driver` API的所有知识后，您可以从开发使用NoSQL作为后端的REST API开始。在下一节中，我们将展示配送物流的架构，并指导您开发一个示例API。
- en: Designing MongoDB documents for a delivery logistics API
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为配送物流API设计MongoDB文档
- en: There are many cases for which a REST API can be developed. One such case is
    delivery logistics. In the logistics world, many entities play an important role.
    To know what to implement, you need to know the terminology that's used for logistics.
    Here, we are going to model a few JSON documents that can be implemented for MongoDB. 
    After going through this section, try to use this schema information as a guide
    to building a Logistics REST API.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多情况，可以开发REST API。其中一种情况是配送物流。在物流世界中，许多实体都扮演着重要的角色。为了知道要实现什么，你需要了解物流中使用的术语。在这里，我们将模拟一些可以用于MongoDB的JSON文档。在本节学习完毕后，请尝试使用此架构信息作为构建物流REST
    API的指南。
- en: 'The following six minimal components are essential in any delivery logistics
    design:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何配送物流设计中，以下六个最小组件是必不可少的：
- en: Sender
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发件人
- en: Receiver
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收件人
- en: Package
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包裹
- en: Payment
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 付款
- en: Carrier
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承运人
- en: Shipment
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装运
- en: 'Let''s look at a schema for each and every component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个组件的架构：
- en: 'A sender is a person sending the package:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发件人是发送包裹的人：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A receiver receives the package from a sender:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收件人从发件人那里接收包裹：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A sender sends a package to a receiver. So, we have to model a package document
    that holds package information such as dimensions in centimeters and weight in
    grams:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发件人向收件人发送包裹。因此，我们必须创建一个包含包裹信息的文档，例如厘米和克的尺寸和重量：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A payment transaction should be recorded when the sender buys the delivery
    service. It should have payment transaction details for further reference:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发送者购买配送服务时，应记录支付交易。它应包含支付交易详情以供进一步参考：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now comes the Carrier. We have a third-party international vendor to a partner
    that will ship the package on our behalf:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是承运商。我们有一个第三方国际供应商，将代表我们发送包裹：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, with all those details, we have a shipment document that holds information
    about all the other stakeholders:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，有了所有这些细节，我们有一个包含关于所有其他利益相关者信息的运输文档：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: A shipment contains `sender`, `receiver`, `payment`, `carrier`, and `package`
    details. This is a minimal document design for delivery logistics.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个运输包含 `sender`（发送者）、`receiver`（接收者）、`payment`（支付）、`carrier`（承运商）和 `package`（包裹）详情。这是交付物流的最小文档设计。
- en: You can find all the previous MongoDB Shell schemas in this project's repository,
    that is, `chapter5/delivery_logistics`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本项目的仓库中找到所有之前的 MongoDB Shell 架构，即 `chapter5/delivery_logistics`。
- en: All the preceding schemas have been implemented to give you an idea of how a
    REST service can be designed for MongoDB as a storage system.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个架构都已实现，以便你了解如何为 MongoDB 作为存储系统设计 REST 服务。
- en: Note that the preceding format is for MongoDB shell. Please be aware of this
    difference while creating the service.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的格式是针对 MongoDB shell 的。在创建服务时，请注意这个差异。
- en: Here's a coding exercise for you: *Can you create a REST service for logistics
    by leveraging the knowledge we gained from the initial sections of this chapter?*
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个编码练习给你：*你能利用本章前几节学到的知识创建一个物流 REST 服务吗？*
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter with an introduction to MongoDB and how it solves the
    problems of the modern web. MongoDB is a NoSQL database that is different from
    traditional relational databases. Then, we learned how to install MongoDB on all
    platforms, how to start the MongoDB server, and we explored the features of the
    MongoDB shell. The MongoDB shell is a tool that can be used to quickly check or
    perform CRUD operations, as well as many other operations in MongoDB. We looked
    at operator symbols for querying. Then, we introduced Go's MongoDB driver called
    `mongo-driver`and learned how it's used. We created a persistent movies API with
    the help of `mongo-driver` and Go. Finally, we learned how to map a Go struct
    to a JSON document.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章开始时介绍了 MongoDB 以及它是如何解决现代网络问题的。MongoDB 是一种不同于传统关系型数据库的 NoSQL 数据库。然后，我们学习了如何在所有平台上安装
    MongoDB，如何启动 MongoDB 服务器，以及我们探讨了 MongoDB shell 的功能。MongoDB shell 是一个工具，可以用来快速检查或执行
    CRUD 操作，以及在 MongoDB 中执行许多其他操作。我们查看查询的运算符符号。然后，我们介绍了 Go 的 MongoDB 驱动程序 `mongo-driver`
    并学习了它的用法。我们借助 `mongo-driver` 和 Go 创建了一个持久电影 API。最后，我们学习了如何将 Go 结构体映射到 JSON 文档。
- en: Not every query is efficient in MongoDB. So, for boosting query performance,
    we introduced the indexing mechanism, which reduces the document fetching time
    by arranging the documents in the order of a B-tree. We learned how to measure
    the execution time of a query using the `explain` command. Finally, we laid out
    a logistics document design by providing BSON (*MongoDB shell syntax*).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个查询在 MongoDB 中都高效。因此，为了提高查询性能，我们引入了索引机制，通过按 B 树的顺序排列文档来减少文档检索时间。我们学习了如何使用
    `explain` 命令来衡量查询的执行时间。最后，我们通过提供 BSON（*MongoDB shell 语法*）来制定物流文档设计。
- en: Sometimes, your REST API has to be supported with additional background services
    and transports. One such service is the **Remote Procedure Call** (**RPC**). When
    a distributed system powers a REST API, there could be thousands of RPC calls
    behind the scene. Those RPC calls can call different endpoints, use different
    data formats and transports, and so on. It is crucial to learn them if you wish
    to develop APIs in distributed systems. In the next chapter, we will learn how
    to work with an RPC method called **gRPC** and a data format called **Protocol
    Buffers**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的 REST API 需要支持额外的后台服务和传输。其中一种服务是 **远程过程调用**（**RPC**）。当分布式系统支持 REST API
    时，后台可能会有成千上万的 RPC 调用。这些 RPC 调用可以调用不同的端点，使用不同的数据格式和传输方式等。如果你想在分布式系统中开发 API，了解这些至关重要。在下一章中，我们将学习如何使用名为
    **gRPC** 的 RPC 方法和一个名为 **Protocol Buffers** 的数据格式。
