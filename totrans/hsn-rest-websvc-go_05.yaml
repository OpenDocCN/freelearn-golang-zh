- en: Working with MongoDB and Go to Create a REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to introduce a popular NoSQL database called MongoDB.
    We will learn how well MongoDB suits modern web services by storing documents
    instead of relations. We'll begin by learning about MongoDB collections and documents
    and create an example API with MongoDB as the database. While doing so, we'll
    use a driver package called `mongo-driver`. Then, we'll try to design a document
    model schema for a delivery logistics problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MongoDB and using the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing `mongo-driver`, an official MongoDB driver for Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful API with `gorilla/mux` and MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boosting querying performance with indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing MongoDB documents for delivery logistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software needs to be pre-installed if you wish to run the code
    examples in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OS: Linux(Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go compiler >= 1.13.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB >= 4.2.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter5](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter5).
    Clone the code and use the code samples in the `chapter5` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MongoDB** is a popular NoSQL database that is attracting a lot of developers
    worldwide. It is different from traditional relational databases such as MySQL,
    PostgreSQL, and SQLite3\. The main big difference with MongoDB compared to other
    databases is it is schemaless and stores collections and documents. Think of MongoDB
    collections as tables, and documents as rows in SQL databases. However, in MongoDB,
    there is no relationship between collections. This schemaless design allows MongoDB
    to scale horizontally using a mechanism called **Sharding**. MongoDB stores data
    as BSON files on disk. BSON is an efficient binary format for operation and data
    transfer. Almost all MongoDB clients convert JSON into BSON and vice versa while
    inserting or retrieving documents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many big companies such as Expedia, Comcast, and MetLife built their applications
    on MongoDB. It has been proven as a vital element in modern internet businesses.
    MongoDB stores data in a document; think of this as a row in SQL databases. All
    MongoDB documents are stored in a collection, and this collection is similar to
    a table (in terms of SQL). Let''s look at an example. A sample document for an
    IMDb movie has a few keys, such as name, year, and directors. The values for these
    keys can be a number, boolean, string, list, or a map. This would look something
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The main advantages of MongoDB over relational databases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to model (schema-free)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can leverage querying power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document structure suits modern-day web applications (**JSON**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More scalable than relational databases (via **Sharding**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know what MongoDB is, let's look at it in more detail. In the next
    section, we will learn how to install MongoDB and try to access it from the MongoDB
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MongoDB and using the shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB can be easily installed on any platform. On Ubuntu 18.04, we need to
    perform some steps before running the `apt-get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve installed it, check whether the `mongo` process is running. If
    not, you can start the MongoDB daemon using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the user is root, you can drop the `sudo` keyword before each command.
  prefs: []
  type: TYPE_NORMAL
- en: We can also download MongoDB manually from the website and copy it to `/usr/local/bin`.
    To do this, we have to create an init script for the server since the server stops
    when the system is shut down. We can use the `nohup` tool to run the server in
    the background. Usually, it is better to install it using `apt-get`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install MongoDB on Mac OS X, you''ll need to use the Homebrew software.
    Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily install it using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to create the `db` directory where MongoDB stores its database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the permissions of that file using `chown`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, MongoDB is ready. To see its logs interactively, we need to stop MongoDB
    as a process and run it in a shell. To stop the service, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in a Terminal window, run the following command, which starts MongoDB
    interactively (not in the background):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/453088c4-7456-4317-ba8f-0ed64145380f.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding command shows the status of the database in a few columns. From
    these `logs`, we can figure out that the server started on port `27017`. It displays
    the build environment, the storage engine that was used, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, we can manually download the installer binary and launch it by adding
    the installation `bin` directory to the `PATH` variable. Then, we can run it using
    the `mongod`command. Alongside the MongoDB installation comes a client shell called
    Mongo. We will look at it in brief in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the MongoDB shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we start using MongoDB, the first thing we need to explore is the
    available commands that we can use in order to interact with it. Looking up the
    available databases, collections, documents, and so on can be done with a simple
    client tool called **MongoDB shell**. It is similar to the MySQL client. This
    shell program is included in the standard MongoDB server installation. We can
    launch it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/761f8225-770c-4e69-8bc4-5a3b943c0134.png)'
  prefs: []
  type: TYPE_IMG
- en: If you see that a `session` ID has been created, as shown in the preceding screenshot,
    everything worked fine. If you get an error, the server is probably not running
    as expected. To troubleshoot, have a look at the MongoDB troubleshooting guide
    at [https://docs.mongodb.com/manual/faq/diagnostics](https://docs.mongodb.com/manual/faq/diagnostics/).
    The client provides information about MongoDB versions and other warnings. To
    see all the available shell commands, use the `help` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new collection called `movies` and insert the preceding example
    document into it. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the database will be a test database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `show` command lists all available databases. `admin`, `config`,
    `test`, and `local` are the four databases available by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new database or switch to an existing database, just type `use
    db_name`. In our case, let''s name our database `appDB`. Type the following into
    a MongoDB shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This switches the current database to the `appDB` database.If you try to list
    the available databases, `appDB` won't show up because MongoDB only creates a
    physical database when some data is inserted into it (first collection or document).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a new collection by inserting the first document. We can
    insert the sample document for IMDb movies into a collection called `movies`using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The JSON you inserted has an ID called `_id`. We can provide it while inserting
    a document, or MongoDB itself can generate one for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL databases, we use *auto-increment* along with an `ID` schema toincrement
    the `ID` field. Here, MongoDB generates a unique hash `ID` rather than a sequence.
    Let''s insert one more document about `The Dark Knight`, but this time, we won''t
    pass the `_id` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As shown by the acknowledgement JSON response, `insertedId` haschanged to a
    very lengthy `59574125bf7a73d140d5ba4a`.This is the unique hash that's generated
    by MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: We can also insert a batch of documents at a given time using the `insertMany`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `find` function without arguments on the movies collection returns
    all the matched documents, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to return a single document, use the `findOne` function. This returns
    the oldest document from multiple results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we query documents? Querying in MongoDB is known as filtering data and
    returning a result. If we need to filter for movies that were released in `2008`,
    then we can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The filter query from the preceding MongoDB shell statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This states that the searching criterion is the `year` and that the value should
    be `2008`. `$eq` is called a **filtering operator**, which helps to relate the
    condition between the field and data. It is equivalent to the `=` operator in
    SQL. In SQL, the equivalent query can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify the previously written MongoDB shell statement to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This filter query and the previous filter query are the same since they return
    the same set of documents. The former syntax is using `$eq`, which is a query
    operator. From now on, we'll call a *query operator* simply an *operator*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other main operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | ** Function** |'
  prefs: []
  type: TYPE_TB
- en: '| `$lt` | `Less than` |'
  prefs: []
  type: TYPE_TB
- en: '| `$gt` | `Greater than` |'
  prefs: []
  type: TYPE_TB
- en: '| `$in` | `In the` |'
  prefs: []
  type: TYPE_TB
- en: '| `$lte` | `Less than or equal to` |'
  prefs: []
  type: TYPE_TB
- en: '| `$ne` | `Not equal to` |'
  prefs: []
  type: TYPE_TB
- en: 'You can find all the available operators here: [https://docs.mongodb.com/manual/reference/operator/](https://docs.mongodb.com/manual/reference/operator/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s pose a question to ourselves. We have a requirement to fetch all
    the documents whose budget is more than $150,000,000\. How can we filter this
    with the query knowledge we gained previously? Take a look at the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we accessed the `budget` key within the JSON using `boxOffice.budget`.The
    beauty of MongoDB is that it allows us to query the JSON with a lot of freedom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can''t we add two or more operators to the criteria while fetching documents?
    Yes, we can! Let''s find all the movies in the database that were released in
    `2009` with a budget of more than $150,000,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns nothing because we don''t have any documents that match the given
    criteria. By default, comma-separated query fields, such as `''boxOffice.budget'':
    {$gt: 150000000}, year: 2009 `, are combined with the `AND`operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s relax our condition and find any movies that were either released
    in `2009` or had a budget of more than $150,000,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, the query is a bit different. We used an operator called `$or`to find
    the predicate of the two conditions. The result will be the criteria for fetching
    the documents. `$or`needs to be assigned to a list (see the preceding query) of
    JSON condition objects. Since JSON can be nested, conditions can also be nested.
    This style of querying might look new to people coming from a SQL background.
    The MongoDB team designed it to intuitively filter data. We can also write advanced
    queries such as inner joins, outer joins, nested queries, and so on easily in
    MongoDB with the clever use of operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have explored two **Create**, **Read**, **Update**, and **Delete**
    (**CRUD**) operations in order to create and read on MongoDB documents. Now, we''ll
    look at the update and delete operations. To update a document, use the `db.collection.update`
    method. The syntax consists of the criteria and a set operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update Star Trek (ID: 5)''s box office budget. Our goal is to change
    `150000000` to `200000000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first argument for the `update` method is the filter criteria. The second
    argument is a `$set` operator that changes the fields/sections in the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the delete operation. We can delete a document from
    a given collection using the `deleteOne` and `deleteMany` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The argument that's passed to the **`deleteOne` **function is a filter criterion,
    which is similar to the read and update operations. All the documents that match
    the given criteria will be removed from the collection. The response contains
    a nice acknowledgment message with a count of documents that were deleted.
  prefs: []
  type: TYPE_NORMAL
- en: This and the preceding sections discussed the basics of MongoDB with the MongoDB
    shell. However, how we can do the same thing from a Go program? We need to use
    a driver package. In the next section, we'll explore the official MongoDB driver
    package for Go, called `mongo-driver`. MongoDB supports official drivers for major
    languages such as Python, Java, Ruby, and Go.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing mongo-driver, an official MongoDB driver for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`mongo-driver` is a rich MongoDB driver that allows developers to write applications
    that use MongoDB as the database. The Go application can talk easily with MongoDB
    for all its CRUD operations using the `mongo` driver. It is an open source implementation
    maintained by MongoDB and can be used and modified freely. We can think of it
    as a wrapper around the MongoDB API. Installing the package is similar to other
    `go get` commands. However, in this chapter, we''ll introduce a new Go package
    tool called `dep`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`dep` is a Go package installer tool similar to Python''s `pip` or JavaScript''s
    `npm`. Follow this web page to install the dep tool on various platforms: [https://golang.github.io/dep/docs/installation.html](https://golang.github.io/dep/docs/installation.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a Go program that inserts `The Dark Knight` movie document into
    MongoDB. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory for our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, traverse to the `intro` directory and initialize the `dep` tool. It creates
    a few files so that we can track package dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `mongo-driver` dependency to `dep`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `main` file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all we need to do to set up all the files and dependencies. To represent
    the movie and box office, we have to create structs that imitate the BSON data.
    These structs look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We used `bson` tags for the struct fields. The reason we did this is that the `mongo-driver`
    package uses another package called `bson` to serialize Go structs into BSON format.
    This `bson` package needs some meta information in the form of tags to process
    fields. Hence, we attach a few `helper` tags. The preceding structs represent
    the BSON documents in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to import two packages called `mongo` and `options` from `mongo-driver`.
    The `bson` package is required if we wish to perform queries on MongoDB collections.
    The import section of the program looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `main` function, we have to create a database client and connect
    to it. This should happen in the main block of the program. As per the `mongo-driver`
    API, we create an instance of `ClientOptions`. The `ClientOptions` object holds
    details such as the database server''s information (host and port) and so on.
    Then, we create a client using a context and the `ClientOptions` object. The context
    is used as a request timeout. With the help of the client, we can ping the database
    using the `Ping` method. If the database ping is successful, we can fetch the
    reference for a collection. The logic for creating a client and pinging the server
    looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the collection is ready, we can insert a movie record into the database. `mongo-driver`
    provides a method called `InsertOne` for a collection. We can insert a struct
    into the database collection as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, a record has been inserted into the database. Let''s retrieve
    it using a query with a filter, that is, a movie with a box office budget greater
    than $150 million. We should create an empty movie struct to hold the result.
    A filter query can be constructed using the `bson.M` struct. It is a generic map
    that holds `KEY:VALUE` pairs and is convenient for creating BSON queries. The
    `collection.FindOne` method takes a filter query and returns a `SingleResult`
    object. We can decode that object into the empty movie struct like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we disconnect from the database once our operations have been completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the entire program using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The result from a query can be stored in a new struct and can be serialized
    into JSON so that the clients can use it too. For that, you should add JSON meta
    tags to the struct, along with BSON tags.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful API with gorilla/mux and MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we explored all the possible ways of building a RESTful
    API. We used basic HTTP routers, as well as many other web frameworks. However,
    to keep it simple, we can use `gorilla/mux` with `mongo-driver` for the MongoDB
    driver. In this section, we will build an end-to-end movie API while integrating
    the database and HTTP router. In the previous section, we learned how to create
    a new MongoDB document and retrieve it using `mongo-driver`. By consolidating
    our knowledge of HTTP routers and databases, we can create a movie API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the plan so that we can create the API:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare structs to hold movie information and the database connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a server for hosting the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the routes for the API endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement handlers for the routes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have to follow these steps to achieve our goal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory to hold our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `main.go` file in the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Please install the `mongo-driver` package using the `dep` tool, just like we
    did in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the structs we need to create; that is, `DB`, `Movie`,
    and `BoxOffice`. `Movie` and `BoxOffice` hold the movie information. The `DB`
    struct holds a collection in a MongoDB database that can be passed across multiple
    functions. The code for this is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a few important packages in order to implement our API. These are `gorilla/mux`,
    `mongo-driver`, and a few other `helper` packages. Let''s look at how to import
    these packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We need the `primitive` package to generate an `ObjectID` from a string, the `bson`
    package to create query filters, and the `mongo/options` package to create a MongoDB
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `main` function, which is where we create a MongoDB client. The
    client is created by passing options to the `Connect` method. Once we are connected
    to MongoDB, which is running locally on port `27017`, we can access the collection
    using the `Database.Collection` method. We can delay cleaning up the connection
    using the `defer`  keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `defer` keyword is special in a Go program. It defers a function call so
    that it's executed right before the enclosing outer function returns. It is commonly
    used for I/O connection cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the enclosing function is the `main`, and the deferred function
    is `client.Disconnect`. So, when `main` returns/terminates, the defer statement
    closes the MongoDB connection properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a few HTTP routes for the `GET` and `POST` operations on a
    movie. Let''s call them `GetMovie` and `PostMovie`, respectively. The code looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start a server using the `http.Server` method, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now comes the actual implementation of the handlers. `GetMovie`, like any other
    mux handler, takes response and request objects. It receives an `ObjectId` (hex
    string) of the movie from the path parameters and queries a matching document
    from the database. We can use the `mux.Vars` map to collect path parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can't simply form a filter query using the raw ID. We have to convert the
    hex string that was passed into the `ObjectID` using the `primitive.ObjectIDFromHex`
    method from the `mongo-driver/bson/primitive` package. We should use this `ObjectID` in
    a `filter` query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we run a query using the `collection.FindOne` method. The result can
    then be decoded into a `Movie` struct literal and returned as a JSON `response`.
    Take a look at the following code for the `GetMovie` function handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`PostMovie` has the exact same function signature as the `GET` handler function.
    Instead of reading from the path parameters, it reads information from the request
    body in JSON and un-marshalls it into the `Movie` struct. Then, we use the `collection.InsertOne`
    method and perform a database insert operation. The result of the JSON is sent
    back as an HTTP response. The code for the `PostMovie` handler function looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we open a Terminal and make a `POST` API request using `curl` or `Postman`
    to create a new movie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Our movie has been created successfully. Next, let''s retrieve it. Make a `GET`
    API request using `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the same data that we got while creating the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily add `PUT` (update) and `DELETE` methods to/from the preceding
    code. We just need to define two more handlers. First, look at the `UpdateMovie`
    handler. It gets the `ObjectID` as a path parameter in order to update a document
    in MongoDB, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the handler function is `DeleteMovie`. It gets the object ID from the
    path parameters and tries to delete a document with the same ID in the database
    using the `DeleteOne` method, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In these API operations, we can also simply send the status back to the client
    with no HTTP body.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these handlers to be activated by `gorilla/mux`, we have to register two
    new HTTP endpoints to the router, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for these additions is available in the `chapter5/movieAPI_updated/main.go`
    file. If you run the updated program, you will have a full CRUD-based API with
    MongoDB as a backend.
  prefs: []
  type: TYPE_NORMAL
- en: Boosting the querying performance with indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know that, while reading a book, indexes are very important. When we
    try to search for a topic in the book, we scroll through the index page. If the
    topic is found in the index, then we go to the specific page number for that topic.
    But there is a drawback here. We are using additional pages for the sake of this
    indexing. Similarly, MongoDB needs to go through all the documents whenever we
    query for something. If the document stores indexes for important fields, it can
    give us data quickly. At the same time, we should remember that extra space is
    required for storing indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In computing, a B-tree is an important data structure for implementing indexing
    because it can categorize nodes. By traversing that tree, we can find the data
    we need in fewer steps. We can create an index using the `createIndex` function
    provided by MongoDB. Take an example of students and their scores in an examination. `GET` operations
    are more frequent with sorting scores. The indexing for this scenario can be visualized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ce4cfed-ef8a-48f0-8eb3-2f0d08e0f617.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the official example given by the MongoDB website. The **score** is
    the field to be indexed because of frequent use. Once it's been indexed, the database
    stores the address for each document in a binary tree. Whenever someone queries
    this field, it checks for the range operator (in this case, it's `$lt`), traverses
    the binary tree, and gets the addresses of the documents in fewer steps. Since
    the scoreis indexed, the sort operations are less costly. So, the time that it
    takes for the database to return the sorted (ascending or descending) result is
    shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming to our previous examples of the movies API, we can create indexes for
    data. By default, all the `_id`fields are indexed, so we are using MongoDB shell
    to show that. Previously, we treated the `year` field as a string. Let''s modify
    that so that it''s an integer and index it. Launch the MongoDB shell using the `mongo`
    command. Connect to a new database; for example, `test`, from a MongoDB shell
    and insert a document into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert one more similar document containing different data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add indexing to the year with the `createIndex` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This single line adds the magic for retrieving the database records faster.
    Now, all the queries related to `year` leverage the indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There is no difference in the query result. However, the lookup mechanism for
    documents by `MongoDB` has changed due to indexing. For a larger number of documents,
    this could reduce the lookup time drastically.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing comes with a cost. Some queries run very slow on different fields if
    indexing is not done properly. We can also have compound indexes in MongoDB that
    can index multiple fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB comes with a tool called `query planner`. To see the time of execution
    of a query, use the `explain` function after a `query` function, for example,
    `db.movies.find({year: {$lt: 2010}}).explain("executionStats")`. This explains
    the winning plan for a query, the time that it took in milliseconds, indexes used,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: You can view the performance of indexed and non-indexed data using the `explain` function.
    Take a look at the MongoDB website to understand more about indexes: [https://docs.mongodb.com/manual/indexes/](https://docs.mongodb.com/manual/indexes/).
  prefs: []
  type: TYPE_NORMAL
- en: With all the knowledge of MongoDB and the `driver` API you have under your belt,
    you can start developing a REST API that uses NoSQL as a backend. In the next
    section, we'll present a schema for delivery logistics and get you to develop
    a sample API.
  prefs: []
  type: TYPE_NORMAL
- en: Designing MongoDB documents for a delivery logistics API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many cases for which a REST API can be developed. One such case is
    delivery logistics. In the logistics world, many entities play an important role.
    To know what to implement, you need to know the terminology that's used for logistics.
    Here, we are going to model a few JSON documents that can be implemented for MongoDB. 
    After going through this section, try to use this schema information as a guide
    to building a Logistics REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following six minimal components are essential in any delivery logistics
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: Sender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carrier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shipment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at a schema for each and every component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A sender is a person sending the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'A receiver receives the package from a sender:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'A sender sends a package to a receiver. So, we have to model a package document
    that holds package information such as dimensions in centimeters and weight in
    grams:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'A payment transaction should be recorded when the sender buys the delivery
    service. It should have payment transaction details for further reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the Carrier. We have a third-party international vendor to a partner
    that will ship the package on our behalf:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, with all those details, we have a shipment document that holds information
    about all the other stakeholders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: A shipment contains `sender`, `receiver`, `payment`, `carrier`, and `package`
    details. This is a minimal document design for delivery logistics.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the previous MongoDB Shell schemas in this project's repository,
    that is, `chapter5/delivery_logistics`.
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding schemas have been implemented to give you an idea of how a
    REST service can be designed for MongoDB as a storage system.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding format is for MongoDB shell. Please be aware of this
    difference while creating the service.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a coding exercise for you: *Can you create a REST service for logistics
    by leveraging the knowledge we gained from the initial sections of this chapter?*
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with an introduction to MongoDB and how it solves the
    problems of the modern web. MongoDB is a NoSQL database that is different from
    traditional relational databases. Then, we learned how to install MongoDB on all
    platforms, how to start the MongoDB server, and we explored the features of the
    MongoDB shell. The MongoDB shell is a tool that can be used to quickly check or
    perform CRUD operations, as well as many other operations in MongoDB. We looked
    at operator symbols for querying. Then, we introduced Go's MongoDB driver called
    `mongo-driver`and learned how it's used. We created a persistent movies API with
    the help of `mongo-driver` and Go. Finally, we learned how to map a Go struct
    to a JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: Not every query is efficient in MongoDB. So, for boosting query performance,
    we introduced the indexing mechanism, which reduces the document fetching time
    by arranging the documents in the order of a B-tree. We learned how to measure
    the execution time of a query using the `explain` command. Finally, we laid out
    a logistics document design by providing BSON (*MongoDB shell syntax*).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, your REST API has to be supported with additional background services
    and transports. One such service is the **Remote Procedure Call** (**RPC**). When
    a distributed system powers a REST API, there could be thousands of RPC calls
    behind the scene. Those RPC calls can call different endpoints, use different
    data formats and transports, and so on. It is crucial to learn them if you wish
    to develop APIs in distributed systems. In the next chapter, we will learn how
    to work with an RPC method called **gRPC** and a data format called **Protocol
    Buffers**.
  prefs: []
  type: TYPE_NORMAL
