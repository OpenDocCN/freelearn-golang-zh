<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with Protocol Buffers and gRPC</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we are going to enter the world of protocol buffers. The REST API needs support from other internal services. Those internal services can implement a <strong>Remote Procedure Call</strong> (<strong>RPC</strong>) and use a protocol buffer as a data exchange format. First, we will discover the benefits of using protocol buffers instead of JSON for services, and where to use both. We will use Google's <kbd>proto</kbd> library to compile protocol buffers. We will also try to write a few web services with protocol buffers that can talk to either Go, or other applications such as Python and Node.js. Then, we'll explain gRPC, an advanced simplified form of RPC. We will learn how gRPC and protocol buffers can help us build low-bandwidth services that can be consumed by different clients. Finally, we will discuss HTTP/2 and its benefits over plain HTTP/1.1-based services.</p>
<p><span>In short, we will cover the following topics</span>:</p>
<ul>
<li>Introduction to protocol buffers</li>
<li>Protocol buffer language</li>
<li>Compiling a protocol buffer with protoc</li>
<li>Introduction to gRPC</li>
<li>Bidirectional streaming with gRPC</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements </h1>
                </header>
            
            <article>
                
<p>You'll need to preinstall the following software in order to run the code examples in this chapter:</p>
<ul>
<li>OS: Linux (Ubuntu 18.04)/Windows 10/<span>Mac OS X </span>&gt;=10.13</li>
<li>Go's latest version compiler &gt;= 1.13.5</li>
</ul>
<p>You can download the code for this chapter from <a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter6" target="_blank">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter6</a>. Clone the code and use the code samples in the<span> </span><kbd>chapter6</kbd><span> </span>directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to protocol buffers</h1>
                </header>
            
            <article>
                
<p>HTTP/1.1 is the standard that is adopted by the web community. In recent times, HTTP/2 is becoming more popular because of its advantages. Some of the benefits of using HTTP/2 are as follows:</p>
<ul>
<li>Flow control between sender and receiver</li>
<li>Better compression of HTTP headers</li>
<li>Single TCP connection for bidirectional streaming</li>
<li>Server push support for sending files on one TCP connection</li>
<li>Support from all major browsers</li>
</ul>
<p><span>The technical definition from Google about protocol buffers is as follows:</span></p>
<div class="packt_quote"><span>Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data—think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use the specially generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. You can even update your data structure without breaking deployed programs that are compiled against the "old" format.</span></div>
<p>Let's look at this in detail. A protocol buffer is a <span>strongly typed specification language. A tight data interface is essential for designing microservices. Protocol buffers allow us to define the data contract between multiple systems. Once a protocol buffer file has been defined, we can compile it to a target programming language. The output of this compilation will be classes and functions in the target programming language. The sender serializes data into a binary format that is transferred over the network. The receiver deserializes the data and consumes it. Basically, protocol buffers are similar to data formats such as JSON and XML, but the latter formats are text-based while protocol buffers are binary.</span></p>
<p>In Go, protocol buffers can be transported over different transports, such as HTTP/2 and <strong>Advanced Message Queuing Protocol </strong>(<strong>AMQP</strong>). They are a transport format similar to JSON but strictly typed, and can only be understood between the client and the server. First, we will understand why <span><strong>protocol buffers</strong></span> (<strong><span>protobufs</span></strong>) exist and how to use them.</p>
<p>Protocol buffers have many advantages over JSON/XML for serializing structured data, such as the following:</p>
<ul>
<li>They have a strong interface</li>
<li>They are a lot smaller than text-based data formats</li>
<li>They are usually faster than JSON/XML when it comes to serialization/deserialization</li>
<li>They are less ambiguous because of type and order</li>
<li>They generate data access classes that are easier to use programmatically</li>
</ul>
<p>We will prove these points while discussing a few examples later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Protocol buffer language</h1>
                </header>
            
            <article>
                
<p>A protocol buffer is a file with minimalist language syntax. We compile a protocol buffer, and a new file is generated for a target programming language. For example, in Go, the compiled file will be a <kbd>.go</kbd> file with structs mapping the <kbd>protobuf</kbd> file. In Java, a <kbd>class</kbd> file will be created. Think of a protocol buffer as a data structure with types. The protocol buffer language provides various types that we can use to create interfaces. First, we'll discuss all the types with equivalent JSON snippets. After that, we'll implement a full example of a protocol buffer. From here on, we'll use the terms <kbd>protobuf/s</kbd> and protocol buffers interchangeably.</p>
<div class="packt_infobox">Here, we are going to use <kbd>proto3</kbd> as our protobuf version. There are slight variations in versions, so please note the differences when you are using older versions.</div>
<p>First, let's learn how to model messages in a protobuf. A message is a resource that is transmitted to the receiver. Here, we're trying to define a simple network interface message:</p>
<pre>syntax 'proto3';<br/><br/>message NetworkInterface {<br/>  int index = 1;<br/>  int mtu = 2;<br/>  string name = 3;<br/>  string hardwareaddr = 4;<br/>}</pre>
<p>This syntax may look new to you. In the preceding code, we were defining a message type called <kbd>NetworkInterface</kbd>.<strong> </strong>It has four fields: <kbd>index</kbd>, <strong>maximum transmission</strong> <strong>unit</strong> (<strong>MTU</strong>), <kbd>name</kbd>, and hardware address <em>(</em>MAC). If we wish to write the same in JSON, it would look like this:</p>
<pre>{<br/>   "networkInterface": {<br/>       "index" : 0,<br/>       "mtu" : 68,<br/>       "name": "eth0",<br/>       "hardwareAddr": "<span>00:A0:C9:14:C8:29</span>"<br/>   }<br/>}</pre>
<p>The field names are changed to comply with the JSON style guide, but the essence and structure are the same. But what are the sequential numbers (1,2,3,4) that are given to the fields in the preceding protobuf file? They are the ordering tags that are given to serialize and deserialize protocol buffer data between two systems. It's like hinting at the protocol buffer encoding/decoding systems to write/read the data in that particular order, respectively. When the preceding protobuf file is compiled in Go as a target, the protocol buffer message will be converted into a Go struct and the fields will be filled with empty default values.</p>
<p>In the protobuf language, there are many basic types. Some of the important ones are as follows:</p>
<ul>
<li>Scalar values</li>
<li>Enumerations and repeated fields</li>
<li>Nested fields</li>
</ul>
<p>We'll discuss each of them briefly in the upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scalar values</h1>
                </header>
            
            <article>
                
<p>The types we assigned to the fields in the <kbd>networkInterface</kbd> message are scalar types. These types are similar to Go types and match with them. For other programming languages, they will be converted into their respective types. Protobufs support many diverse types, such as <kbd>int</kbd>, <kbd>int32</kbd>, <kbd>int64</kbd>, <kbd>string</kbd>, and <kbd>bool</kbd>, which resemble Go types, but with a few variations.</p>
<p>They are as follows:</p>
<div class="CDPAlignCenter CDPAlign">
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Go type</strong></td>
<td><strong>Protobuf type</strong></td>
</tr>
<tr>
<td><kbd>float32</kbd></td>
<td><kbd>float</kbd></td>
</tr>
<tr>
<td><kbd>float64</kbd></td>
<td><kbd>double</kbd></td>
</tr>
<tr>
<td><kbd>uint32</kbd></td>
<td><kbd>fixed32</kbd></td>
</tr>
<tr>
<td><kbd>uint64</kbd></td>
<td><kbd>fixed64</kbd></td>
</tr>
<tr>
<td><kbd>[]byte</kbd></td>
<td><kbd>bytes</kbd></td>
</tr>
</tbody>
</table>
</div>
<p>These types can be used while defining fields in a <kbd>protobuf</kbd> file. These fields and types in protobuf are converted into their respective Go variables and types upon being compiled. Go fills an unassigned variable with its empty value. Let's look at a few default empty values in Go for the protobuf message type:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 49.5754%"><strong>Protobuf type</strong></td>
<td style="width: 49.7463%"><strong>Default value</strong></td>
</tr>
<tr>
<td style="width: 49.5754%"><kbd>string</kbd></td>
<td style="width: 49.7463%"><kbd>""</kbd></td>
</tr>
<tr>
<td style="width: 49.5754%"><kbd>bytes</kbd></td>
<td style="width: 49.7463%"><kbd>empty bytes[]</kbd></td>
</tr>
<tr>
<td style="width: 49.5754%"><kbd>bool</kbd></td>
<td style="width: 49.7463%"><kbd>false</kbd></td>
</tr>
<tr>
<td style="width: 49.5754%"><kbd>int</kbd>, <kbd>int32</kbd>, <kbd>int64</kbd>, <kbd>float</kbd>, <kbd>double</kbd></td>
<td style="width: 49.7463%"><kbd>0</kbd></td>
</tr>
<tr>
<td style="width: 49.5754%"><kbd>enum</kbd></td>
<td style="width: 49.7463%"><kbd>0</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">Since protobufs make an agreement beforehand about messages and fields between end systems using a data structure, they don't take up additional space for keys like they do in JSON. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enumerations and repeated fields</h1>
                </header>
            
            <article>
                
<p><strong>Enumerations </strong>(<strong>enum</strong>) provide the ordering of numbers for a given set of elements. The default order of values is from <em>0 </em>to <em>n</em>. So, in a protocol buffer message, we can have an enumeration type. Let's look at an example of the <kbd>enum</kbd>:</p>
<pre>syntax 'proto3';<br/> <br/>message Schedule{<br/>  enum Days{<br/>     SUNDAY = 0;<br/>     MONDAY = 1;<br/>     TUESDAY = 2;<br/>     WEDNESDAY = 3;<br/>     THURSDAY = 4;<br/>     FRIDAY = 5;<br/>     SATURDAY = 6;<br/>  }<br/>}</pre>
<p>What if we have to assign the same values for the multiple enumeration members?</p>
<p>Protobuf3 has an option called <strong><kbd>allow_alias</kbd> </strong>that we can use to assign two different members the same value, like so:</p>
<pre>enum EnumAllowingAlias {
  option allow_alias = true;
  UNKNOWN = 0;
  STARTED = 1;
  RUNNING = 1;
}</pre>
<p>Here, <kbd>STARTED</kbd> and <kbd>RUNNING</kbd> both have a <kbd>1</kbd> tag. This means that both can have the same value in the data. If we try to remove duplicated values, we should also remove the <kbd>allow_alias</kbd><strong> </strong>option. Otherwise, the proto compiler will throw an error (we will see what a proto compiler is shortly).</p>
<p><kbd>repeated</kbd> fields are the fields in the message of a protocol buffer that represent a list of items. In JSON, we have a list of elements for a given key. Similarly, repeated fields allow us to define an array/list of elements of a particular type:</p>
<pre>message Site{<br/>   string url = 1;<br/>   int latency = 2;<br/>   repeated string proxies = 3;<br/>}</pre>
<p>In the preceding code, the third field is a repeated field, which means it is an array/list of proxies. The value could be something like <kbd>["100.104.112.10", "100.104.112.12"]</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nested fields</h1>
                </header>
            
            <article>
                
<p>We can also use a message as a type of another message. It is similar to a map data structure. It is analogous to nested JSON.</p>
<p>For example, take a look at the following JSON code:</p>
<pre>{<br/>  "site": {<br/>      "url": "https://example.org",<br/>      "latency": "5ms",<br/>      "proxies": [<br/>        {"url": "https://example-proxy-1.org", "latency": "6ms"},<br/>        {"url": "https://example-proxy-2.org", "latency": "4ms"}<br/>      ]<br/>  }<br/>}</pre>
<p>The preceding JSON contains information about a site that has a list of proxies. Each proxy is a map itself and contains details such as <kbd>url</kbd> and <kbd>latency</kbd>.</p>
<p>How can we model the same thing in protobufs? We can do this using the nested messages, as shown in the following code:</p>
<pre>message Site {<br/> string url = 1;<br/> int latency = 2;<br/> repeated Proxy proxies = 3;<br/>}<br/><br/>message Proxy {<br/> string url = 1;<br/> int latency = 2;<br/>}</pre>
<p>Here, we are nesting the <kbd>Proxy</kbd> type into <kbd>Site</kbd>. We will look at all of these field types soon. You can find more details about types here: <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank">https://developers.google.com/protocol-buffers/docs/proto</a>.</p>
<p>In the next section, we'll learn about a protobuf compiler and how to use it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling a protocol buffer with protoc</h1>
                </header>
            
            <article>
                
<p>So far, we have discussed how to write a protocol buffer file by defining messages and their field types. But how do we actually integrate one into our Go programs? Remember that protobufs are a format of communication between various systems, similar to JSON. But the actual data that is transferred is binary. The protoc compiler automatically generates Go structs from <kbd>.proto</kbd> files. Later, those structs can be imported to create binary data.</p>
<p>The following are the practical steps we follow when using protobufs in our Go programs:</p>
<ol>
<li>Install the <kbd>protoc</kbd> command-line tool and the <kbd>proto</kbd> library.</li>
<li>Write a protobuf file with the <kbd>.proto</kbd> extension.</li>
<li>Compile the file so that it targets a programming language (in our case, it is Go).</li>
</ol>
<ol start="4">
<li>Import structs from the generated target file and add the necessary data.</li>
<li>Serialize the data into binary format and send it to the receiver.</li>
<li>On a remote machine, the receiver deserializes the data and decodes data.</li>
</ol>
<p>These steps can be seen in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a5e4950f-1e7d-4899-996e-b95bff240ee2.jpg" style="width:32.67em;height:25.58em;"/></p>
<p>The first step is to install the <kbd>protobuf</kbd> compiler on our machine. For this, download the <kbd>protobuf</kbd> package from <a href="https://github.com/google/protobuf/releases" target="_blank">https://github.com/google/protobuf/releases</a>. On <span>Mac OS X</span>, we can install <kbd>protobuf</kbd> using this command:</p>
<pre><strong>brew install protobuf</strong></pre>
<p>On Ubuntu or Linux, we can copy <kbd>protoc</kbd> to the <kbd>/usr/bin</kbd> folder:</p>
<pre class="mce-root"><strong># Make sure you grab the latest version</strong><br/><strong>curl -OL https://github.com/protocolbuffers/protobuf/releases/download/<br/>v3.11.3/protoc-3.11.3-linux-x86_64.zip</strong><br/><strong># Unzip</strong><br/><strong>unzip protoc-3.11.3-linux-x86_64.zip -d protoc3</strong><br/><strong># Move only protoc* to /usr/bin/</strong><br/><strong>sudo mv protoc3/bin/protoc /usr/bin/protoc</strong></pre>
<p class="mce-root"/>
<p class="mce-root">On Windows, we can just copy the executable (<kbd>.exe</kbd>) from <a href="https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-win64.zip" target="_blank">https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-win64.zip</a> to the <kbd>PATH</kbd> environment variable. Let's write a simple protocol buffer to illustrate how to compile and use structs from the target file. Create a folder called <kbd>protobufs</kbd> in your <kbd>GOPATH</kbd>:</p>
<pre><strong>mkdir -r $GOPATH/src/github.com/git-user/chapter6/protobufs</strong></pre>
<p>Inside protobufs, create a new directory called <kbd>protofiles</kbd>. This directory holds the compiled files from protocol buffers.</p>
<p>In the <kbd>protofiles</kbd> directory, create a file called <kbd>person.proto</kbd>, which models a person's information. It defines name, ID, email, and phone number. Add a few messages to it, as shown in the following code snippet:</p>
<pre>syntax = "proto3";<br/>package protofiles;<br/><br/>message Person {<br/>  string name = 1;<br/>  int32 id = 2; // Unique ID number for this person.<br/>  string email = 3;<br/><br/>  enum PhoneType {<br/>    MOBILE = 0;<br/>    HOME = 1;<br/>    WORK = 2;<br/>  }<br/><br/>  message PhoneNumber {<br/>    string number = 1;<br/>    PhoneType type = 2;<br/>  }<br/><br/>  repeated PhoneNumber phones = 4;<br/>}<br/><br/>// Our address book file is just one of these.<br/>message AddressBook {<br/>  repeated Person people = 1;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, we created two main messages called <kbd>AddressBook</kbd> and <kbd>Person</kbd>.<strong> </strong>The<strong> </strong><kbd>AddressBook</kbd> message contains a list of persons. A <kbd>Person</kbd> has a <kbd>name</kbd>, <kbd>id</kbd>, <kbd>email</kbd>, and <kbd>PhoneNumber</kbd>. In the second line, we declared the package as <kbd>protofiles</kbd>, like this:</p>
<pre>package protofiles;</pre>
<p class="mce-root"/>
<p>This tells the compiler to add the generating file in relation to the given package name. Go cannot consume this <kbd>.proto</kbd> file directly. We need to compile it to a valid Go file. When compiled, the <kbd>protofiles</kbd> package will be used to create a Go package. To compile our <kbd>person.proto</kbd> protocol buffer file, traverse to the <kbd>protofiles</kbd> directory and run the following command:</p>
<pre><strong>protoc --go_out=. *.proto</strong></pre>
<p>This command converts the given protocol buffer file(s) into the Go file(s) with the same name. After running this command, you'll see that a new file has been created in the same directory:</p>
<pre><strong>[16:20:27] git-user:protofiles git:(master*) $ ls -l</strong><br/><strong>total 24</strong><br/><strong>-rw-r--r-- 1 naren staff 5657 Jul 15 16:20 person.pb.go</strong><br/><strong>-rw-r--r--@ 1 naren staff 433 Jul 15 15:58 person.proto</strong></pre>
<p>The new file's name is <kbd>person.pb.go</kbd>.<strong> </strong>If we open and inspect this file, we'll see that it contains automatically generated code blocks:</p>
<pre>....<br/>type Person_PhoneType int32<br/><br/>const (<br/>  Person_MOBILE Person_PhoneType = 0<br/>  Person_HOME Person_PhoneType = 1<br/>  Person_WORK Person_PhoneType = 2<br/>)<br/><br/>var Person_PhoneType_name = map[int32]string{<br/>  0: "MOBILE",<br/>  1: "HOME",<br/>  2: "WORK",<br/>}<br/>var Person_PhoneType_value = map[string]int32{<br/>  "MOBILE": 0,<br/>  "HOME": 1,<br/>  "WORK": 2,<br/>}<br/>.....</pre>
<p>This is just one part of that file. Many getter and setter methods will be created for the given structs, such as <kbd>Person</kbd> and <kbd>AddressBook</kbd>, in the output file.</p>
<p>The preceding <kbd>person.pb.go</kbd> package is automatically generated boilerplate by the <kbd>proto</kbd> compiler. We need to consume that package in the main program to create protocol buffer strings. Now, we should create the <kbd>main.go</kbd> file, which uses the <kbd>Person</kbd> struct from the <kbd>person.pb.go</kbd> file like this:</p>
<pre><strong>touch -p $GOPATH/src/github.com/git-user/chapter6/protobufs/basicExample/main.go</strong></pre>
<p>Now, for Go to serialize a struct into binary format, we need to install the Go <kbd>proto</kbd> driver. Install it using the <kbd>go get</kbd> command:</p>
<pre><strong>go get github.com/golang/protobuf/proto</strong></pre>
<p>The goal of the program we are going to create is to read the <kbd>Person</kbd> struct from the auto-generated package and serialize it into a buffer string using the <kbd>proto.Marshal</kbd> method. The fill the <kbd>main.go</kbd> like this:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/><br/>  "github.com/golang/protobuf/proto"<br/>  pb "github.com/git-user/chapter6/protobufs/protofiles"<br/>)<br/><br/>func main() {<br/>  p := &amp;pb.Person{<br/>    Id: 1234,<br/>    Name: "Roger F",<br/>    Email: "rf@example.com",<br/>    Phones: []*pb.Person_PhoneNumber{<br/>      {Number: "555-4321", Type: pb.Person_HOME},<br/>    },<br/>  }<br/><br/>  p1 := &amp;pb.Person{}<br/>  body, _ := proto.Marshal(p)<br/>  _ = proto.Unmarshal(body, p1)<br/>  fmt.Println("Original struct loaded from proto file:", p, "\n")<br/>  fmt.Println("Marshalled proto data: ", body, "\n")<br/>  fmt.Println("Unmarshalled struct: ", p1)<br/>}</pre>
<p>Here, we are importing the <strong>protocol buffer</strong> (<kbd>pb</kbd>) from the <kbd>protofiles</kbd> package. We initialized the <kbd>Person</kbd> struct with details. Then, we serialized the struct using the <kbd>proto.Marshal</kbd><strong> </strong>function. If we run this program, the output looks like this:</p>
<pre><strong>go run $GOPATH/src/github.com/git-user/chapter6/</strong><strong>protobufs/basicExample/main.go</strong><br/><strong><br/>Original struct loaded from proto file: name:"Roger F" id:1234 email:"rf@example.com" phones:&lt;number:"555-4321" type:HOME &gt;</strong><br/><br/><strong>Marshaled proto data: [10 7 82 111 103 101 114 32 70 16 210 9 26 14 114 102 64 101 120 97 109 112 108 101 46 99 111 109 34 12 10 8 53 53 53 45 52 51 50 49 16 1]</strong><br/><br/><strong>Unmarshaled struct: name:"Roger F" id:1234 email:"rf@example.com" phones:&lt;number:"555-4321" type:HOME &gt;</strong></pre>
<p>The second output of the marshaled data is not obvious because the <kbd>proto</kbd> library serializes data into binary bytes. Another good thing about protocol buffers in Go is that the structs that are generated by compiling the proto files can be used to generate JSON on the fly. Let's modify the preceding example into a new program. Call it <kbd>jsonExample</kbd>:</p>
<pre><strong>touch -p $GOPATH/src/github.com/narenaryan/chapter6/protobufs/jsonExample/main.go</strong></pre>
<p>In this program, we'll use JSON's marshaler instead of protobuf's marshaler. The beauty of the Go interfaces is that it allows the protocol buffer struct to be an input for different types of marshalers. The following is the modified code for converting the <kbd>Person</kbd> struct into JSON:</p>
<pre>package main<br/><br/>import (<br/>  "fmt"<br/><br/>  "encoding/json"<br/>  pb "github.com/git-user/chapter6/protobufs/protofiles"<br/>)<br/><br/>func main() {<br/>  p := &amp;pb.Person{<br/>    Id: 1234,<br/>    Name: "Roger F",<br/>    Email: "rf@example.com",<br/>    Phones: []*pb.Person_PhoneNumber{<br/>      {Number: "555-4321", Type: pb.Person_HOME},<br/>    },<br/>  }<br/>  body, _ := json.Marshal(p)<br/>  fmt.Println(string(body))<br/>}</pre>
<p>If we run this, it prints a JSON string that can be sent to any client that can understand JSON:</p>
<pre><strong>go run $GOPATH/src/github.com/git-user/chapter6/protobufs</strong><strong>/jsonExample/main.go</strong><br/><br/>{"name":"Roger F","id":1234,"email":"rf@example.com","phones":[{"number":"555-4321","type":1}]}</pre>
<p>Any other web service/receiver can easily consume this JSON string instantly. So, what is the benefit of using protocol buffers instead of JSON? First of all, protocol buffers are intended for two backend systems to communicate with each other with a strong interface and smaller payload size. Since the size of the binary is less than the text, the protocol marshaled data is always significantly smaller than the JSON text.</p>
<div class="packt_tip">The output that's generated by a <kbd>protobuf</kbd> compiler is nothing but a plain Go struct. This allows you to convert from and protobuf into JSON easily.</div>
<p>Protocol buffers are just a data format. They need a mode of transport to move between systems. We saw how RPC works and also created an RPC client and server in <a href="ab89bca5-b60d-4681-bc36-23ee51a56cc6.xhtml">Chapter 3</a>, <em>Working with Middleware and RPC</em>. Now, we are going to extend that knowledge to use a <strong>Google Remote Procedure Call</strong> (<strong>gRPC</strong>) with protocol buffers to efficiently transfer data. A server and a client, in this case, can talk with each other in the protocol buffer format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to gRPC</h1>
                </header>
            
            <article>
                
<p><strong>gRPC</strong> is a transport mechanism that sends and receives messages between two systems. Traditionally, these systems are a server and a client. As we described in the previous chapters, RPC can be implemented in Go for transferring JSON. We called it a <strong>JSON RPC</strong> service. Similarly, gRPC is specially designed to transfer data in the form of protocol buffers.</p>
<p>gRPC makes service creation easy and elegant. It provides a nice set of APIs that we can use to define services and start running them. In this section, we will focus on how to create a gRPC service and how to use it. The main advantage of gRPC is that it can be understood by multiple programming languages. Protocol buffers provide a common data structure. So, this combination enables seamless communication between various tech stacks and systems. This is the integral concept of distributed computing.</p>
<p>Square, Netflix, and many other giants leverage this gRPC to scale their huge traffic-prone services. Google uses gRPC heavily for their web services. We can leverage it to get better throughput between two internal services.</p>
<p>We need to install the <kbd>grpc</kbd> Go library and a <kbd>protoc-gen</kbd> plugin before writing the services. Install them using the following commands:</p>
<pre><strong>go get google.golang.org/grpc</strong><br/><strong>go get -u github.com/golang/protobuf/protoc-gen-go</strong></pre>
<p>gRPC has the following benefits over a traditional HTTP/REST/JSON architecture:</p>
<ul>
<li>gRPC uses HTTP/2, which is a binary protocol.</li>
<li>Header compression is possible in HTTP/2, which means less overhead.</li>
<li>We can multiplex many requests on one connection.</li>
<li>We can use protobufs for strict typing of data.</li>
<li>Streaming requests or responses, instead of using a request/response transaction, is possible.</li>
</ul>
<p>Take a look at the following diagram:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"> <img src="assets/c7bb83e9-7c49-40d3-871c-c97d984c538b.jpg" style="width:21.67em;height:18.75em;"/>              </div>
<p>The preceding diagram clearly shows that any back-end system or mobile app can directly communicate to a gRPC server using a protocol buffer. Let's write a money transaction service in Go using gRPC and protocol buffers. A service in gRPC is an RPC contract. It takes a message and returns another message.</p>
<p>The steps for implementing the money transaction service are as follows:</p>
<ol>
<li>Create the protocol buffer with the definitions of service and messages.</li>
<li>Compile the protocol buffer file.</li>
<li>Use the generated Go package to create a gRPC server.</li>
<li>Create a gRPC client that talks to the server.</li>
</ol>
<p>To understand these steps, let's create the project directories for our upcoming example, like so:</p>
<pre><strong>mkdir -r $GOPATH/src/github.com/git-user/chapter6/grpcExample<br/>mkdir -r $GOPATH/src/github.com/git-user/chapter6/grpcExample/protofiles</strong></pre>
<p>Create a file called <kbd>transaction.proto</kbd> for defining gRPC services:</p>
<pre><strong>touch -p $GOPATH/src/github.com/git-user/chapter6/grpcExample/protofiles/transaction.proto</strong></pre>
<p>Now, in the <kbd>transaction.proto</kbd> file, define the service and transaction messages, like this:</p>
<pre>syntax = "proto3";<br/>package protofiles;<br/><br/>message TransactionRequest {<br/>   string from = 1;<br/>   string to = 2;<br/>   float amount = 3;<br/>}<br/><br/>message TransactionResponse {<br/>  bool confirmation = 1;<br/>}<br/><br/>service MoneyTransaction {<br/>    rpc MakeTransaction(TransactionRequest) returns (TransactionResponse) {}<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This is a simple protocol buffer for a money transaction on the server. We introduced the <kbd>message</kbd> keyword when we discussed protocol buffers. The new keyword, <kbd>service</kbd>, defines a gRPC service. This new keyword is solely related to gRPC, and the <kbd>protoc-gen-go</kbd> helper plugin translates it into an understandable format via the <kbd>protoc</kbd> compiler. Now, let's compile this file using <kbd>protoc</kbd> from the <kbd>grpcExample</kbd> directory:</p>
<pre><strong>protoc -I protofiles/ protofiles/transaction.proto --go_out=plugins=grpc:protofiles</strong></pre>
<p>This command is slightly bigger than the compile command we used previously. This is because we are using the <kbd>protoc-gen-go</kbd> plugin. This command simply says to use data files as the input directory for proto files and use the same directory for outputting the target Go files. Now, if we list the <kbd>protofiles</kbd> directory, we'll see an autogenerated file called <kbd>transaction.pb.go</kbd>:</p>
<pre><strong>ls protofiles<br/>-rw-r--r-- 1 git-user staff 6215 Jan 16 17:28 transaction.pb.go</strong><br/><strong>-rw-r--r-- 1 git-user staff 294 Jan 16 17:28 transaction.proto</strong></pre>
<p>Now, we have to build a server and client that consumes previously built protobufs. Create two more directories for the server and client logic in <kbd>grpcExample</kbd>, like this:</p>
<pre><strong>mkdir grpcServer grpcClient</strong></pre>
<p>Let's create a <kbd>grPC</kbd> server first. Add a file called <kbd>server.go</kbd> to the <kbd>grpcServer</kbd> directory, which implements the transaction service. Our goal is to create a server that collects a transaction request from the client and returns the confirmation.</p>
<p>We need the help of more packages here, that is,<span> </span><kbd>context</kbd><span> </span>and<span> </span><kbd>reflection</kbd>.<strong> </strong><kbd>context</kbd> is used to create a<span> </span><kbd>context</kbd><span> </span>variable, which lives throughout an RPC request's lifetime. Both of these libraries are used by gRPC for its internal functions:</p>
<pre>import (<br/>   ...<br/>   pb "github.com/git-user/chapter6/grpcExample/protofiles"<br/>  "golang.org/x/net/context"<br/>  "google.golang.org/grpc"<br/>  "google.golang.org/grpc/reflection"<br/>)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If we open the autogenerated <kbd>transaction.pb.go</kbd> package in <kbd>protofiles</kbd>, we can clearly see that there are two important things:</p>
<ul>
<li>The<span> </span><kbd>MakeTransaction</kbd><span> </span>function, as part of the <kbd>MoneyTransactionServer</kbd><span> </span>interface</li>
<li>The<span> </span><kbd>RegisterMoneyTransactionServer</kbd> function</li>
</ul>
<p><kbd>MakeTransaction</kbd> is used for implementing the service. Let's take a look at the implementation. It defines a struct and a method. This method performs the money transaction using the data that's supplied via the <kbd>*pb.TransactionRequest</kbd> argument:</p>
<pre>// server is used to create MoneyTransactionServer.<br/>type server struct{}<br/><br/>// MakeTransaction implements MoneyTransactionServer.MakeTransaction<br/>func (s *server) MakeTransaction(ctx context.Context, in *pb.TransactionRequest) (*pb.TransactionResponse, error) {<br/>  // Use in.Amount, in.From, in.To and perform transaction logic<br/>  return &amp;pb.TransactionResponse{Confirmation: true}, nil<br/>}</pre>
<p><kbd>MakeTransaction</kbd> contains the RPC request details. It is basically a struct that maps to the <kbd>TransactionRequest</kbd> message we defined in the protocol buffer file. What's returned from <kbd>MakeTransaction</kbd> is <kbd>TransactionResponse</kbd>.<strong> </strong>This function signature matches with the one we defined in the protocol buffer file initially:</p>
<pre>rpc MakeTransaction(TransactionRequest) returns (TransactionResponse) {}</pre>
<p>Now comes the main block. Here, we have to create an instance of the gRPC server and register the server struct with it. We run this gRPC server on port <kbd>50051</kbd>:</p>
<pre>const (<br/>    port = ":50051"<br/>)<br/><br/>func main() {<br/>  lis, err := net.Listen("tcp", port)<br/>  ...<br/>  s := grpc.NewServer()<br/>  pb.RegisterMoneyTransactionServer(s, &amp;server{})<br/>  reflection.Register(s)<br/>  if err := s.Serve(lis); err != nil {<br/>    log.Fatalf("Failed to serve: %v", err)<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now, we need to write a client. Add a file called <kbd>client.go</kbd> in the <kbd>grpcClient</kbd> directory. The client should dial the server and acquire a connection. Using that connection, we can call remote functions and get the results. A gRPC client also uses the same protobuf boilerplate classes so that it's in sync with the server. The following is the code for the client:</p>
<pre>package main<br/><br/>import (<br/>  "log"<br/><br/>  pb "github.com/git-user/chapter6/grpcExample/protofiles"<br/>  "golang.org/x/net/context"<br/>  "google.golang.org/grpc"<br/>)<br/><br/>const (<br/>  address = "localhost:50051"<br/>)<br/><br/>func main() {<br/>  // Set up a connection to the server.<br/>  conn, err := grpc.Dial(address, grpc.WithInsecure())<br/>  ...<br/>  // Create a client<br/>  c := pb.NewMoneyTransactionClient(conn)<br/>  <br/>  from := "1234"<br/>  to := "5678"<br/>  amount := float32(1250.75)<br/><br/>  // Make a server request.<br/>  r, err := c.MakeTransaction(context.Background(),<br/>  &amp;pb.TransactionRequest{From: from,<br/>    To: to, Amount: amount})<br/>  ...<br/>}</pre>
<p>This client is also using the <kbd>grpc</kbd><strong> </strong>package. It uses an empty context called <kbd>context.Background()</kbd><strong> </strong>to pass to the <kbd>MakeTransaction</kbd><strong> </strong>function. The second argument of the function is the <kbd>TransactionRequest</kbd> struct:</p>
<pre>&amp;pb.TransactionRequest{From: from, To: to, Amount: amount}</pre>
<p class="mceNonEditable"/>
<p>Now, let's run both the server and the client and view the output. Open a new console and run the gRPC server by using the following command:</p>
<pre><strong>go run $GOPATH/src/github.com/git-user/chapter6/grpcExample/grpcServer/<br/>server.go</strong></pre>
<p>The TCP server starts listening on port <kbd>50051</kbd>. Now, open one more Terminal/shell and start the client program that talks to this server:</p>
<pre><strong>go run $GOPATH/src/github.com/git-user/chapter6/grpcExample/grpcClient/<br/>client.go</strong></pre>
<p>It prints the output of the successful transaction:</p>
<pre><strong>2020/01/10 19:13:16 Transaction confirmed: true</strong></pre>
<p>At the same time, the server logs this message to the console:</p>
<pre><strong>2020/01/10 19:13:16 Amount: 1250.750000, From A/c:1234, To A/c:5678</strong></pre>
<p>Here, the client made a single request to the gRPC server and passed details of the <kbd>From A/c</kbd> number, the <kbd>To A/c</kbd> number, and <kbd>Amount</kbd>. The server picks those details, processes them, and sends a response saying everything is fine.</p>
<div class="packt_tip">A gRPC client can request a gRPC server to perform a computation-heavy/secure operation. The client can be a mobile device too.</div>
<p>The full programs can be found in this chapter's project repository. In the next section, we'll look at bidirectional streaming in gRPC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bidirectional streaming with gRPC</h1>
                </header>
            
            <article>
                
<p>The main advantage of gRPC over traditional HTTP/1.1 is that it can use a single TCP connection for sending and receiving multiple messages between the server and the client. We saw the example of a money transaction previously. Another real-world use case is a GPS installed in a taxi. Here, the taxi is the client that sends its geographical points to the server along its route. Finally, the server can calculate the total fare amount depending on the time spent between points and the total distance. </p>
<p>Another use case is a server pushing data to a client. This is called a server push model, where a server can send a stream of results back to the client. This is different from polling, where the client creates a new request/response cycle each and every time. The server push can be very handy for building real-time applications. Let's implement an example to illustrate this:</p>
<ol>
<li>Create a project called <kbd>serverPush</kbd>, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir -r $GOPATH/src/github.com/git-user/chapter6/serverPush</strong><br/><strong>mkdir -r $GOPATH/src/github.com/git-user/chapter6/serverPush/<br/>protofiles</strong></pre>
<ol start="2">
<li>Now, add the transactions to <kbd>protofiles</kbd>, a protocol buffer that is similar to the one that we used in the previous gRPC money transaction example, except the return type of <kbd>MakeTransaction</kbd> is a stream:</li>
</ol>
<pre style="padding-left: 60px">syntax = "proto3";<br/>package protofiles;<br/><br/>message TransactionRequest {<br/>   string from = 1;<br/>   string to = 2;<br/>   float amount = 3;<br/>}<br/><br/>message TransactionResponse {<br/>  string status = 1;<br/>  int32 step = 2;<br/>  string description = 3;<br/>}<br/><br/>service MoneyTransaction {<br/>    rpc MakeTransaction(TransactionRequest) returns (stream<br/>     TransactionResponse) {}<br/>}</pre>
<p style="padding-left: 60px">We have two messages and one service defined in the protocol buffer file. The exciting part is in the service; we are returning a stream instead of a plain response:</p>
<pre style="padding-left: 60px">rpc MakeTransaction(TransactionRequest) returns (stream TransactionResponse) {}</pre>
<p style="padding-left: 60px">The use case of this project is that <em>the client sends a money transfer request to the server, the server does a few tasks, and then sends those step details as a stream of responses back to the server</em>.</p>
<ol start="3">
<li>Now, let's compile the <kbd>.proto</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><strong>protoc -I protofiles/ protofiles/transaction.proto <br/> --go_out=plugins=grpc:protofiles</strong></pre>
<p style="padding-left: 60px">This creates a new file called <kbd>transaction.pb.go</kbd> in the <kbd>protofiles</kbd> directory. We use the definitions in this file in our server and client programs, which we will create shortly.</p>
<ol start="4">
<li>Now, let's write the gRPC server code. This code is a bit different compared to the previous example because of the introduction of streams:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir $GOPATH/src/github.com/git-user/chapter6/serverPush/<br/>grpcServer</strong><br/><strong>touch $GOPATH/src/github.com/git-user/chapter6/serverPush/<br/>grpcServer/server.go</strong></pre>
<p style="padding-left: 60px">We skip th<span>e imports and look at the main logic of the program. The main function is similar to the previous gRPC example, but the most interesting th</span><span>ing is the handler. Let's say the handler takes the request from the client and performs three steps. At the end of each step, the server sends a notification to the client. It is a long-living connection, unlike the one-time RPC call we saw earlier. The following is the code for streaming</span> <kbd>MakeTransaction</kbd><span>:</span></p>
<pre style="padding-left: 60px">const (<br/>  port = ":50051"<br/>  noOfSteps = 3<br/>)<br/><br/>// MakeTransaction implements MoneyTransactionServer.MakeTransaction<br/>func (s *server) MakeTransaction(in *pb.TransactionRequest, stream pb.MoneyTransaction_MakeTransactionServer) error {<br/>  log.Printf("Got request for money transfer....")<br/>  log.Printf("Amount: $%f, From A/c:%s, To A/c:%s", in.Amount,<br/>   in.From, in.To)<br/>  // Send streams here<br/>  for i := 0; i &lt; noOfSteps; i++ {<br/>    time.Sleep(time.Second * 2)<br/>    // Once task is done, send the successful message<br/>    // back to the client<br/>    if err := stream.Send(&amp;pb.TransactionResponse{Status: "good",<br/>      Step: int32(i),<br/>      Description: fmt.Sprintf("Performing step %d",<br/>       int32(i))}); err != nil {<br/>      log.Fatalf("%v.Send(%v) = %v", stream, "status", err)<br/>    }<br/>  }<br/>  log.Printf("Successfully transferred amount $%v from %v to %v",<br/>   in.Amount, in.From, in.To)<br/>  return nil<br/>}</pre>
<p style="padding-left: 60px"><kbd>MakeTransaction</kbd><strong> </strong>takes a request and a stream as its arguments. In the function, we are looping through the number of steps (here, there are three) and performing the computation. The server is simulating the mock I/O or computation using the <kbd>time.Sleep</kbd><strong> </strong>function. The crucial server method for sending a message is <kbd>Send</kbd><span>:</span></p>
<pre style="padding-left: 90px">stream.Send()</pre>
<p style="padding-left: 60px">This function sends a stream response from the server to the client.</p>
<ol start="5">
<li>Now, let's compose the client program. This is also a bit different from the basic gRPC client that we saw in the money transaction example's client code. Create a new directory for the client program:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir $GOPATH/src/github.com/git-user/chapter6/serverPush/<br/>grpcClient</strong><br/><strong>touch $GOPATH/src/github.com/git-user/chapter6/serverPush/<br/>grpcClient/cilent.go</strong></pre>
<ol start="6">
<li>Now, the client should listen indefinitely for the stream of messages. For that, we used a <kbd>for loop</kbd> and <kbd>break</kbd>. Let's modify our previous client handler into a new one called <kbd>ReceiveStream</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// ReceiveStream listens to the stream contents and use them<br/>func ReceiveStream(client pb.MoneyTransactionClient,<br/> request *pb.TransactionRequest) {<br/>  log.Println("Started listening to the server stream!")<br/>  stream, err := client.MakeTransaction(context.Background(),<br/>   request)<br/>  if err != nil {<br/>    log.Fatalf("%v.MakeTransaction(_) = _, %v", client, err)<br/>  }<br/>  // Listen to the stream of messages<br/>  for {<br/>    response, err := stream.Recv()<br/>    if err == io.EOF {<br/>      // If there are no more messages, get out of loop<br/>      break<br/>    }<br/>    if err != nil {<br/>      log.Fatalf("%v.MakeTransaction(_) = _, %v", client, err)<br/>    }<br/>    log.Printf("Status: %v, Operation: %v", response.Status,<br/>     response.Description)<br/>  }<br/>}</pre>
<p style="padding-left: 60px">Here, <kbd>ReceiveStream</kbd><strong> </strong>is the custom function we wrote for the sake of sending a request and receiving a stream of messages. It takes two arguments: <kbd>MoneyTransactionClient</kbd><strong> </strong>and <kbd>TransactionRequest</kbd>.<strong> </strong>It uses the first argument to create a stream and starts listening to it. Whenever the server exhausts all the messages, the client will stop listening and terminate. Then, an <kbd>io.EOF</kbd> error will be returned if the client tries to receive messages. We are logging the responses that we collected from the gRPC server. The second argument, <kbd>TransactionRequest</kbd>,<strong> </strong>is used to send the request to the server for the first time. Running this will make this process clearer to us.</p>
<div class="packt_infobox">The imports and main logic for the server and client are dropped for brevity. Please refer to this project's repository for the complete programs: <kbd>chapter6/serverPush</kbd>.</div>
<ol start="7">
<li>On the first Terminal, run the gRPC server:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter6/serverPush/<br/>grpcServer/server.go</strong></pre>
<p style="padding-left: 60px">It will keep on listening for incoming requests.</p>
<ol start="8">
<li>Now, run the client on the second Terminal to see it in action:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run $GOPATH/src/github.com/git-user/chapter6/serverPush/<br/>grpcClient/client.go</strong></pre>
<p style="padding-left: 60px">This outputs the following to the console:</p>
<pre style="padding-left: 60px"><strong>2019/06/10 20:43:53 Started listening to the server stream!</strong><br/><strong>2019/06/10 20:43:55 Status: good, Operation: Performing step 0</strong><br/><strong>2019/06/10 20:43:57 Status: good, Operation: Performing step 1</strong><br/><strong>2019/06/10 20:43:59 Status: good, Operation: Performing step 2</strong></pre>
<p style="padding-left: 60px">At the same time, the server also logs its own messages on the first Terminal:</p>
<pre style="padding-left: 60px"><strong>2017/07/16 15:08:15 Got request for money Transfer....</strong><br/><strong>2017/07/16 15:08:15 Amount: $1250.750000, From A/c:1234, To A/c:5678</strong><br/><strong>2017/07/16 15:08:21 Successfully transferred amount $1250.75 from 1234 to 5678</strong></pre>
<p>This process happens in sync with the server. The client stays alive until the last streaming message is sent back. The server can handle any number of clients at a given time. Every client request is considered an individual entity. This is an example of the server sending a stream of responses. There are other use cases that can also be implemented with protocol buffers and gRPC:</p>
<ul>
<li>The client sends streamed requests to get one final response from the server</li>
<li>The client and server can both send streamed requests and responses at the same time</li>
</ul>
<div class="packt_tip">The official gRPC team has provided a nice example of routing a taxi on GitHub. You can take a look at it to learn more about the functionality of bidirectional streams at <a href="https://github.com/grpc/grpc-go/tree/master/examples/route_guide" target="_blank">https://github.com/grpc/grpc-go/tree/master/examples/route_guide</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started our journey by understanding the basics of protocol buffers. Then, we came across the protocol buffers language, which has many types, such as scalar, enumeration, and repeated types. We look at a few analogies between JSON and protocol buffers. We learned that protocol buffers are more memory-efficient than the plain JSON data format as the former are binary-based.</p>
<p>Next, we installed the <kbd>protoc</kbd> compiler to compile our files written in the protocol buffer language. Then, we learned how to compile a <kbd>.proto</kbd> file to generate a <kbd>.go</kbd> file with boilerplate code. This Go file contains all the structs and interfaces for the main program to consume. Next, we wrote a protocol buffer for an address book and person.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Then, we moved on to gRPC, an RPC technology from Google that uses protocol buffers. We saw the benefits of HTTP/2 and gRPC. Then, we defined a gRPC service and some data in the form of protocol buffers. Next, we implemented a gRPC server and gRPC with respect to the file we generated from <kbd>.proto</kbd>. </p>
<p>gRPC technology provides a bidirectional and full-duplex transport mechanism for stream data. This means that it can use a single TCP connection for all its message transmissions. We implemented one such scenario where the client sends a message to a server and the server replies with a stream of messages.</p>
<p>In the next chapter, we will learn about <span>using PostgreSQL as backend storage for an API. There, we'll learn how to work with a relational database and Go. We'll also learn how to run a database in the form of a Docker container.<br/></span></p>


            </article>

            
        </section>
    </body></html>