- en: Working with Protocol Buffers and gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to enter the world of protocol buffers. The REST
    API needs support from other internal services. Those internal services can implement
    a **Remote Procedure Call** (**RPC**) and use a protocol buffer as a data exchange
    format. First, we will discover the benefits of using protocol buffers instead
    of JSON for services, and where to use both. We will use Google's `proto` library
    to compile protocol buffers. We will also try to write a few web services with
    protocol buffers that can talk to either Go, or other applications such as Python
    and Node.js. Then, we'll explain gRPC, an advanced simplified form of RPC. We
    will learn how gRPC and protocol buffers can help us build low-bandwidth services
    that can be consumed by different clients. Finally, we will discuss HTTP/2 and
    its benefits over plain HTTP/1.1-based services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to protocol buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol buffer language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling a protocol buffer with protoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to gRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bidirectional streaming with gRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll need to preinstall the following software in order to run the code
    examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go's latest version compiler >= 1.13.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter6](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter6).
    Clone the code and use the code samples in the `chapter6` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to protocol buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP/1.1 is the standard that is adopted by the web community. In recent times,
    HTTP/2 is becoming more popular because of its advantages. Some of the benefits
    of using HTTP/2 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Flow control between sender and receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better compression of HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single TCP connection for bidirectional streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server push support for sending files on one TCP connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support from all major browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The technical definition from Google about protocol buffers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffers are a flexible, efficient, automated mechanism for serializing
    structured data—think XML, but smaller, faster, and simpler. You define how you
    want your data to be structured once, then you can use the specially generated
    source code to easily write and read your structured data to and from a variety
    of data streams and using a variety of languages. You can even update your data
    structure without breaking deployed programs that are compiled against the "old"
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at this in detail. A protocol buffer is a strongly typed specification
    language. A tight data interface is essential for designing microservices. Protocol
    buffers allow us to define the data contract between multiple systems. Once a
    protocol buffer file has been defined, we can compile it to a target programming
    language. The output of this compilation will be classes and functions in the
    target programming language. The sender serializes data into a binary format that
    is transferred over the network. The receiver deserializes the data and consumes
    it. Basically, protocol buffers are similar to data formats such as JSON and XML,
    but the latter formats are text-based while protocol buffers are binary.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, protocol buffers can be transported over different transports, such as
    HTTP/2 and **Advanced Message Queuing Protocol **(**AMQP**). They are a transport
    format similar to JSON but strictly typed, and can only be understood between
    the client and the server. First, we will understand why **protocol buffers** (**protobufs**)
    exist and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocol buffers have many advantages over JSON/XML for serializing structured
    data, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: They have a strong interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are a lot smaller than text-based data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are usually faster than JSON/XML when it comes to serialization/deserialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are less ambiguous because of type and order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They generate data access classes that are easier to use programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will prove these points while discussing a few examples later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffer language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A protocol buffer is a file with minimalist language syntax. We compile a protocol
    buffer, and a new file is generated for a target programming language. For example,
    in Go, the compiled file will be a `.go` file with structs mapping the `protobuf`
    file. In Java, a `class` file will be created. Think of a protocol buffer as a
    data structure with types. The protocol buffer language provides various types
    that we can use to create interfaces. First, we'll discuss all the types with
    equivalent JSON snippets. After that, we'll implement a full example of a protocol
    buffer. From here on, we'll use the terms `protobuf/s` and protocol buffers interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to use `proto3` as our protobuf version. There are slight
    variations in versions, so please note the differences when you are using older
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s learn how to model messages in a protobuf. A message is a resource
    that is transmitted to the receiver. Here, we''re trying to define a simple network
    interface message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax may look new to you. In the preceding code, we were defining a
    message type called `NetworkInterface`.It has four fields: `index`, **maximum
    transmission** **unit** (**MTU**), `name`, and hardware address *(*MAC). If we
    wish to write the same in JSON, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The field names are changed to comply with the JSON style guide, but the essence
    and structure are the same. But what are the sequential numbers (1,2,3,4) that
    are given to the fields in the preceding protobuf file? They are the ordering
    tags that are given to serialize and deserialize protocol buffer data between
    two systems. It's like hinting at the protocol buffer encoding/decoding systems
    to write/read the data in that particular order, respectively. When the preceding
    protobuf file is compiled in Go as a target, the protocol buffer message will
    be converted into a Go struct and the fields will be filled with empty default
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the protobuf language, there are many basic types. Some of the important
    ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations and repeated fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll discuss each of them briefly in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The types we assigned to the fields in the `networkInterface` message are scalar
    types. These types are similar to Go types and match with them. For other programming
    languages, they will be converted into their respective types. Protobufs support
    many diverse types, such as `int`, `int32`, `int64`, `string`, and `bool`, which
    resemble Go types, but with a few variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Go type** | **Protobuf type** |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` | `double` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | `fixed32` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | `fixed64` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]byte` | `bytes` |'
  prefs: []
  type: TYPE_TB
- en: 'These types can be used while defining fields in a `protobuf` file. These fields
    and types in protobuf are converted into their respective Go variables and types
    upon being compiled. Go fills an unassigned variable with its empty value. Let''s
    look at a few default empty values in Go for the protobuf message type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protobuf type** | **Default value** |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `""` |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | `empty bytes[]` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `int`, `int32`, `int64`, `float`, `double` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `enum` | `0` |'
  prefs: []
  type: TYPE_TB
- en: Since protobufs make an agreement beforehand about messages and fields between
    end systems using a data structure, they don't take up additional space for keys
    like they do in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations and repeated fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Enumerations **(**enum**) provide the ordering of numbers for a given set
    of elements. The default order of values is from *0 *to *n*. So, in a protocol
    buffer message, we can have an enumeration type. Let''s look at an example of
    the `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What if we have to assign the same values for the multiple enumeration members?
  prefs: []
  type: TYPE_NORMAL
- en: 'Protobuf3 has an option called **`allow_alias` **that we can use to assign
    two different members the same value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `STARTED` and `RUNNING` both have a `1` tag. This means that both can
    have the same value in the data. If we try to remove duplicated values, we should
    also remove the `allow_alias`option. Otherwise, the proto compiler will throw
    an error (we will see what a proto compiler is shortly).
  prefs: []
  type: TYPE_NORMAL
- en: '`repeated` fields are the fields in the message of a protocol buffer that represent
    a list of items. In JSON, we have a list of elements for a given key. Similarly,
    repeated fields allow us to define an array/list of elements of a particular type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the third field is a repeated field, which means it is
    an array/list of proxies. The value could be something like `["100.104.112.10",
    "100.104.112.12"]`.
  prefs: []
  type: TYPE_NORMAL
- en: Nested fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also use a message as a type of another message. It is similar to a map
    data structure. It is analogous to nested JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the following JSON code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding JSON contains information about a site that has a list of proxies.
    Each proxy is a map itself and contains details such as `url` and `latency`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we model the same thing in protobufs? We can do this using the nested
    messages, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are nesting the `Proxy` type into `Site`. We will look at all of these
    field types soon. You can find more details about types here: [https://developers.google.com/protocol-buffers/docs/proto](https://developers.google.com/protocol-buffers/docs/proto).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn about a protobuf compiler and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a protocol buffer with protoc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed how to write a protocol buffer file by defining messages
    and their field types. But how do we actually integrate one into our Go programs?
    Remember that protobufs are a format of communication between various systems,
    similar to JSON. But the actual data that is transferred is binary. The protoc
    compiler automatically generates Go structs from `.proto` files. Later, those
    structs can be imported to create binary data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the practical steps we follow when using protobufs in our
    Go programs:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `protoc` command-line tool and the `proto` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a protobuf file with the `.proto` extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the file so that it targets a programming language (in our case, it
    is Go).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import structs from the generated target file and add the necessary data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serialize the data into binary format and send it to the receiver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a remote machine, the receiver deserializes the data and decodes data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5e4950f-1e7d-4899-996e-b95bff240ee2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step is to install the `protobuf` compiler on our machine. For this,
    download the `protobuf` package from [https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases).
    On Mac OS X, we can install `protobuf` using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu or Linux, we can copy `protoc` to the `/usr/bin` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, we can just copy the executable (`.exe`) from [https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-win64.zip](https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-win64.zip)
    to the `PATH` environment variable. Let''s write a simple protocol buffer to illustrate
    how to compile and use structs from the target file. Create a folder called `protobufs`
    in your `GOPATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inside protobufs, create a new directory called `protofiles`. This directory
    holds the compiled files from protocol buffers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `protofiles` directory, create a file called `person.proto`, which models
    a person''s information. It defines name, ID, email, and phone number. Add a few
    messages to it, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created two main messages called `AddressBook` and `Person`.The`AddressBook`
    message contains a list of persons. A `Person` has a `name`, `id`, `email`, and
    `PhoneNumber`. In the second line, we declared the package as `protofiles`, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the compiler to add the generating file in relation to the given
    package name. Go cannot consume this `.proto` file directly. We need to compile
    it to a valid Go file. When compiled, the `protofiles` package will be used to
    create a Go package. To compile our `person.proto` protocol buffer file, traverse
    to the `protofiles` directory and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command converts the given protocol buffer file(s) into the Go file(s)
    with the same name. After running this command, you''ll see that a new file has
    been created in the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The new file''s name is `person.pb.go`.If we open and inspect this file, we''ll
    see that it contains automatically generated code blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is just one part of that file. Many getter and setter methods will be created
    for the given structs, such as `Person` and `AddressBook`, in the output file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding `person.pb.go` package is automatically generated boilerplate
    by the `proto` compiler. We need to consume that package in the main program to
    create protocol buffer strings. Now, we should create the `main.go` file, which
    uses the `Person` struct from the `person.pb.go` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for Go to serialize a struct into binary format, we need to install the
    Go `proto` driver. Install it using the `go get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The goal of the program we are going to create is to read the `Person` struct
    from the auto-generated package and serialize it into a buffer string using the `proto.Marshal`
    method. The fill the `main.go` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are importing the **protocol buffer** (`pb`) from the `protofiles`
    package. We initialized the `Person` struct with details. Then, we serialized
    the struct using the `proto.Marshal`function. If we run this program, the output
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The second output of the marshaled data is not obvious because the `proto`
    library serializes data into binary bytes. Another good thing about protocol buffers
    in Go is that the structs that are generated by compiling the proto files can
    be used to generate JSON on the fly. Let''s modify the preceding example into
    a new program. Call it `jsonExample`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, we''ll use JSON''s marshaler instead of protobuf''s marshaler.
    The beauty of the Go interfaces is that it allows the protocol buffer struct to
    be an input for different types of marshalers. The following is the modified code
    for converting the `Person` struct into JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this, it prints a JSON string that can be sent to any client that
    can understand JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Any other web service/receiver can easily consume this JSON string instantly.
    So, what is the benefit of using protocol buffers instead of JSON? First of all,
    protocol buffers are intended for two backend systems to communicate with each
    other with a strong interface and smaller payload size. Since the size of the
    binary is less than the text, the protocol marshaled data is always significantly
    smaller than the JSON text.
  prefs: []
  type: TYPE_NORMAL
- en: The output that's generated by a `protobuf` compiler is nothing but a plain
    Go struct. This allows you to convert from and protobuf into JSON easily.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffers are just a data format. They need a mode of transport to move
    between systems. We saw how RPC works and also created an RPC client and server
    in [Chapter 3](ab89bca5-b60d-4681-bc36-23ee51a56cc6.xhtml), *Working with Middleware
    and RPC*. Now, we are going to extend that knowledge to use a **Google Remote
    Procedure Call** (**gRPC**) with protocol buffers to efficiently transfer data.
    A server and a client, in this case, can talk with each other in the protocol
    buffer format.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**gRPC** is a transport mechanism that sends and receives messages between
    two systems. Traditionally, these systems are a server and a client. As we described
    in the previous chapters, RPC can be implemented in Go for transferring JSON.
    We called it a **JSON RPC** service. Similarly, gRPC is specially designed to
    transfer data in the form of protocol buffers.'
  prefs: []
  type: TYPE_NORMAL
- en: gRPC makes service creation easy and elegant. It provides a nice set of APIs
    that we can use to define services and start running them. In this section, we
    will focus on how to create a gRPC service and how to use it. The main advantage
    of gRPC is that it can be understood by multiple programming languages. Protocol
    buffers provide a common data structure. So, this combination enables seamless
    communication between various tech stacks and systems. This is the integral concept
    of distributed computing.
  prefs: []
  type: TYPE_NORMAL
- en: Square, Netflix, and many other giants leverage this gRPC to scale their huge
    traffic-prone services. Google uses gRPC heavily for their web services. We can
    leverage it to get better throughput between two internal services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to install the `grpc` Go library and a `protoc-gen` plugin before writing
    the services. Install them using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'gRPC has the following benefits over a traditional HTTP/REST/JSON architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: gRPC uses HTTP/2, which is a binary protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header compression is possible in HTTP/2, which means less overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can multiplex many requests on one connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use protobufs for strict typing of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming requests or responses, instead of using a request/response transaction,
    is possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7bb83e9-7c49-40d3-871c-c97d984c538b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram clearly shows that any back-end system or mobile app can
    directly communicate to a gRPC server using a protocol buffer. Let's write a money
    transaction service in Go using gRPC and protocol buffers. A service in gRPC is
    an RPC contract. It takes a message and returns another message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for implementing the money transaction service are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the protocol buffer with the definitions of service and messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the protocol buffer file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the generated Go package to create a gRPC server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a gRPC client that talks to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To understand these steps, let''s create the project directories for our upcoming
    example, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `transaction.proto` for defining gRPC services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `transaction.proto` file, define the service and transaction messages,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple protocol buffer for a money transaction on the server. We
    introduced the `message` keyword when we discussed protocol buffers. The new keyword, `service`,
    defines a gRPC service. This new keyword is solely related to gRPC, and the `protoc-gen-go` helper
    plugin translates it into an understandable format via the `protoc` compiler.
    Now, let''s compile this file using `protoc` from the `grpcExample` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is slightly bigger than the compile command we used previously.
    This is because we are using the `protoc-gen-go` plugin. This command simply says
    to use data files as the input directory for proto files and use the same directory
    for outputting the target Go files. Now, if we list the `protofiles` directory,
    we''ll see an autogenerated file called `transaction.pb.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to build a server and client that consumes previously built protobufs.
    Create two more directories for the server and client logic in `grpcExample`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a `grPC` server first. Add a file called `server.go` to the `grpcServer`
    directory, which implements the transaction service. Our goal is to create a server
    that collects a transaction request from the client and returns the confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the help of more packages here, that is, `context` and `reflection`.`context`
    is used to create a `context` variable, which lives throughout an RPC request''s
    lifetime. Both of these libraries are used by gRPC for its internal functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open the autogenerated `transaction.pb.go` package in `protofiles`, we
    can clearly see that there are two important things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `MakeTransaction` function, as part of the `MoneyTransactionServer` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RegisterMoneyTransactionServer` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeTransaction` is used for implementing the service. Let''s take a look
    at the implementation. It defines a struct and a method. This method performs
    the money transaction using the data that''s supplied via the `*pb.TransactionRequest`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`MakeTransaction` contains the RPC request details. It is basically a struct
    that maps to the `TransactionRequest` message we defined in the protocol buffer
    file. What''s returned from `MakeTransaction` is `TransactionResponse`.This function
    signature matches with the one we defined in the protocol buffer file initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the main block. Here, we have to create an instance of the gRPC server
    and register the server struct with it. We run this gRPC server on port `50051`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to write a client. Add a file called `client.go` in the `grpcClient`
    directory. The client should dial the server and acquire a connection. Using that
    connection, we can call remote functions and get the results. A gRPC client also
    uses the same protobuf boilerplate classes so that it''s in sync with the server.
    The following is the code for the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This client is also using the `grpc`package. It uses an empty context called
    `context.Background()`to pass to the `MakeTransaction`function. The second argument
    of the function is the `TransactionRequest` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run both the server and the client and view the output. Open a
    new console and run the gRPC server by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The TCP server starts listening on port `50051`. Now, open one more Terminal/shell
    and start the client program that talks to this server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the output of the successful transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, the server logs this message to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, the client made a single request to the gRPC server and passed details
    of the `From A/c` number, the `To A/c` number, and `Amount`. The server picks
    those details, processes them, and sends a response saying everything is fine.
  prefs: []
  type: TYPE_NORMAL
- en: A gRPC client can request a gRPC server to perform a computation-heavy/secure
    operation. The client can be a mobile device too.
  prefs: []
  type: TYPE_NORMAL
- en: The full programs can be found in this chapter's project repository. In the
    next section, we'll look at bidirectional streaming in gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional streaming with gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main advantage of gRPC over traditional HTTP/1.1 is that it can use a single
    TCP connection for sending and receiving multiple messages between the server
    and the client. We saw the example of a money transaction previously. Another
    real-world use case is a GPS installed in a taxi. Here, the taxi is the client
    that sends its geographical points to the server along its route. Finally, the
    server can calculate the total fare amount depending on the time spent between
    points and the total distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case is a server pushing data to a client. This is called a server
    push model, where a server can send a stream of results back to the client. This
    is different from polling, where the client creates a new request/response cycle
    each and every time. The server push can be very handy for building real-time
    applications. Let''s implement an example to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project called `serverPush`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the transactions to `protofiles`, a protocol buffer that is similar
    to the one that we used in the previous gRPC money transaction example, except
    the return type of `MakeTransaction` is a stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two messages and one service defined in the protocol buffer file. The
    exciting part is in the service; we are returning a stream instead of a plain
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The use case of this project is that *the client sends a money transfer request
    to the server, the server does a few tasks, and then sends those step details
    as a stream of responses back to the server*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compile the `.proto` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new file called `transaction.pb.go` in the `protofiles` directory.
    We use the definitions in this file in our server and client programs, which we
    will create shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the gRPC server code. This code is a bit different compared
    to the previous example because of the introduction of streams:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We skip the imports and look at the main logic of the program. The main function
    is similar to the previous gRPC example, but the most interesting thing is the
    handler. Let''s say the handler takes the request from the client and performs
    three steps. At the end of each step, the server sends a notification to the client.
    It is a long-living connection, unlike the one-time RPC call we saw earlier. The
    following is the code for streaming `MakeTransaction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`MakeTransaction`takes a request and a stream as its arguments. In the function,
    we are looping through the number of steps (here, there are three) and performing
    the computation. The server is simulating the mock I/O or computation using the `time.Sleep`function.
    The crucial server method for sending a message is `Send`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This function sends a stream response from the server to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compose the client program. This is also a bit different from the
    basic gRPC client that we saw in the money transaction example''s client code.
    Create a new directory for the client program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the client should listen indefinitely for the stream of messages. For
    that, we used a `for loop` and `break`. Let''s modify our previous client handler
    into a new one called `ReceiveStream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ReceiveStream`is the custom function we wrote for the sake of sending
    a request and receiving a stream of messages. It takes two arguments: `MoneyTransactionClient`and
    `TransactionRequest`.It uses the first argument to create a stream and starts
    listening to it. Whenever the server exhausts all the messages, the client will
    stop listening and terminate. Then, an `io.EOF` error will be returned if the
    client tries to receive messages. We are logging the responses that we collected
    from the gRPC server. The second argument, `TransactionRequest`,is used to send
    the request to the server for the first time. Running this will make this process
    clearer to us.
  prefs: []
  type: TYPE_NORMAL
- en: The imports and main logic for the server and client are dropped for brevity.
    Please refer to this project's repository for the complete programs: `chapter6/serverPush`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first Terminal, run the gRPC server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It will keep on listening for incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the client on the second Terminal to see it in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, the server also logs its own messages on the first Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This process happens in sync with the server. The client stays alive until
    the last streaming message is sent back. The server can handle any number of clients
    at a given time. Every client request is considered an individual entity. This
    is an example of the server sending a stream of responses. There are other use
    cases that can also be implemented with protocol buffers and gRPC:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends streamed requests to get one final response from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client and server can both send streamed requests and responses at the same
    time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official gRPC team has provided a nice example of routing a taxi on GitHub.
    You can take a look at it to learn more about the functionality of bidirectional
    streams at [https://github.com/grpc/grpc-go/tree/master/examples/route_guide](https://github.com/grpc/grpc-go/tree/master/examples/route_guide).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our journey by understanding the basics of protocol
    buffers. Then, we came across the protocol buffers language, which has many types,
    such as scalar, enumeration, and repeated types. We look at a few analogies between
    JSON and protocol buffers. We learned that protocol buffers are more memory-efficient
    than the plain JSON data format as the former are binary-based.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we installed the `protoc` compiler to compile our files written in the
    protocol buffer language. Then, we learned how to compile a `.proto` file to generate
    a `.go` file with boilerplate code. This Go file contains all the structs and
    interfaces for the main program to consume. Next, we wrote a protocol buffer for
    an address book and person.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we moved on to gRPC, an RPC technology from Google that uses protocol
    buffers. We saw the benefits of HTTP/2 and gRPC. Then, we defined a gRPC service
    and some data in the form of protocol buffers. Next, we implemented a gRPC server
    and gRPC with respect to the file we generated from `.proto`.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC technology provides a bidirectional and full-duplex transport mechanism
    for stream data. This means that it can use a single TCP connection for all its
    message transmissions. We implemented one such scenario where the client sends
    a message to a server and the server replies with a stream of messages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about using PostgreSQL as backend storage
    for an API. There, we'll learn how to work with a relational database and Go.
    We'll also learn how to run a database in the form of a Docker container.
  prefs: []
  type: TYPE_NORMAL
