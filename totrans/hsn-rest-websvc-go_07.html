<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with PostgreSQL, JSON, and Go</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we are going to take a bird's-eye view of SQL. In the previous chapters, we discussed SQLite3, which is a lightweight database for quick prototyping. But when it comes to developing an enterprise-grade application, MySQL or PostgreSQL is the preferred choice. Both are well-proven, heavy-duty databases that are open source. In this chapter, we'll pick PostgreSQL as our main subject.</p>
<p class="mce-root">First, we'll discuss the internals of PostgreSQL, and then move on to use the database with Go. The goal of this chapter is to make the reader comfortable working with PostgreSQL and Go. We'll also build a URL-shortening service that requires a database layer.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Discussing PostgreSQL installation options</li>
<li>Introducing <kbd><span>pq</span></kbd>, a pure PostgreSQL database driver for Go</li>
<li>Implementing a URL-shortening service using PostgreSQL and <kbd>pq</kbd></li>
<li>Exploring the JSONStore feature in PostgreSQL</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements </h1>
                </header>
            
            <article>
                
<p>The following software should be pre-installed in order to run the code samples:</p>
<ul>
<li>Operating system: Linux (Ubuntu 18.04)/Windows 10/MacOS X &gt;= 10.13</li>
<li>Software: Docker &gt;= 18 (Docker Desktop for Windows and MacOS X)</li>
<li>Go compiler: stable version &gt;= 1.13.5</li>
<li>PostgreSQL: stable version &gt;= 10.8</li>
</ul>
<p class="mce-root"/>
<p><span>You can download the code for this chapter from </span><a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter7" target="_blank">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter7</a><span>. Clone the code, and use the code samples in the</span><span> </span><kbd>chapter7</kbd><span> </span><span>directory.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discussing PostgreSQL installation options</h1>
                </header>
            
            <article>
                
<p>PostgreSQL is an open source database that can be installed on multiple platforms. There are two standard options to install PostgreSQL:</p>
<ul>
<li>Manual server installation on a machine</li>
<li>Installation in a Docker container</li>
</ul>
<p> Manual installation on an operating system can be a universal installation. You can find instructions for installation at this official PostgreSQL link: <a href="https://www.postgresql.org/download/" target="_blank">https://www.postgresql.org/download/</a>.</p>
<p>For <span>MacOS X</span> and Windows, you get straightforward installers. For the varieties of Linux, the PostgreSQL website has nice documentation with detailed instructions. The only drawback with universal installation is you are bound to install/uninstall the PostgreSQL database whenever you change the version. In container-based systems, the execution environment is isolated from the host system. Docker is one such popular container system. In the upcoming subsection, we'll look at the installation of PostgreSQL inside a Docker container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing via Docker</h1>
                </header>
            
            <article>
                
<p>We can also install PostgreSQL via Docker. This is the most common approach these days because of reduced complexity and an easy installation process. Assuming Docker is set up on your machine, proceed as follows:</p>
<ol>
<li>The latest stable version is <kbd>10.8</kbd>. Pull a Docker image with the version as a tag, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker pull postgres:10.8</strong></pre>
<ol start="2">
<li>See a list of all the images available with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker images</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>Start a PostgreSQL server on port <kbd>5432</kbd> inside a container by mapping the database file to a local file, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker run --name postgres-local -p 5432:5432 -v ~/.postgres-data:/var/lib/postgresql/data  -e POSTGRES_PASSWORD=YOUR_PASSWORD -d postgres:10.8</strong></pre>
<p>This starts the PostgreSQL server on <kbd>localhost:5432</kbd>. It also mounts the PostgreSQL database's data directory to a local directory named <kbd>postgres-data</kbd>. </p>
<p>Replace <kbd>YOUR_PASSWORD</kbd> with an actual password while running the preceding command. The <kbd>-d</kbd> option is used in the command to run the container as a daemon process. Now, the PostgreSQL server is running on our machine. It uses the <kbd>postgres:10.8</kbd> Docker image we pulled previously.</p>
<div class="packt_infobox">We can also use the <kbd>docker run</kbd> command without pulling the image. The <kbd>docker pull</kbd> command is to explicitly show that we are using the <kbd>postgres</kbd> image.</div>
<p>Once we have installed PostgreSQL, we have to create default users to access the database. We'll look at this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding users and databases in PostgreSQL</h1>
                </header>
            
            <article>
                
<p>Now, we can create a new user and database. For this, we are going to use Ubuntu/<span>MacOS X</span> as a general example. We do this in a shell called the <kbd>psql</kbd> shell. We can see all available commands in <kbd>psql</kbd> using the <kbd>\?</kbd> command. In order to enter the <kbd>psql</kbd> shell, first, change to the <kbd>postgres</kbd> user. On Ubuntu, for universal installation, you can enter the <kbd>psql</kbd> shell using the following command:</p>
<pre><strong>sudo su postgres</strong></pre>
<p>Now, it turns us into a user called <kbd>postgres</kbd>. Then, launch the <kbd>psql</kbd> shell using the following command:</p>
<pre>psql</pre>
<p>In the case of PostgreSQL running in a Docker container, use this command to launch the <kbd>psql</kbd> shell directly:</p>
<pre><strong>docker exec -i -t postgres-local-1 psql -U postgres</strong></pre>
<p>Once you are in the <kbd>psql</kbd> shell, type the <kbd><span>\?</span></kbd> help command in there, and you will see the output of all available commands, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/f2f8467d-50d8-4b0d-94a8-fa961bdefab4.png" style="width:31.17em;height:14.92em;"/> </div>
<p>To list all available users and their privileges, you will find the following command in the <kbd>Informational</kbd> section of the help shell: </p>
<pre><strong>\du - List roles</strong></pre>
<p>A role is the access permission given to a user. With the <kbd>\du</kbd> command, you can see that the default user is <kbd>postgres</kbd>, with the following roles attached:</p>
<pre><strong>postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS</strong></pre>
<p>We need a new user to work with PostgreSQL. To add a new user, just type this <kbd>SQL</kbd> command in the <kbd>psql</kbd> shell:</p>
<pre><strong>CREATE ROLE git-user with LOGIN PASSWORD 'YOUR_PASSWORD'; # Caution: Choose strong password here<br/></strong></pre>
<p>This creates a new user with the name <kbd><span><span>gituser</span></span></kbd> and the password <kbd>YOUR_PASSWORD</kbd>. Now, give permission to the user to create databases and further roles, using the following command:</p>
<pre><strong>ALTER USER gituser CREATEDB, CREATEROLE;</strong></pre>
<p>In order to delete a user, use the <kbd>DROP</kbd> command in the same context, like this:</p>
<pre><strong>DROP ROLE git-user;</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<div class="packt_infobox">Don't try to change the password for the default <kbd>postgres</kbd> user.<strong> </strong>It is intended to be a superuser account, and should not be kept as a normal user. Instead, create a new role and give the required permissions for it. Use strong passwords.</div>
<p>If you don't use a <strong>command-line interface</strong> (<strong>CLI</strong>), you can install a <strong>graphical user interface</strong> (<strong>GUI</strong>) client such as <strong>pgAdmin 4</strong> for accessing the database.</p>
<div class="packt_infobox">You can find more details about installing <strong>pgAdmin 4</strong> as a Docker application here: <a href="https://hub.docker.com/r/dpage/pgadmin4/" target="_blank">https://hub.docker.com/r/dpage/pgadmin4/</a>.</div>
<p>Now we know how to create a role, let's see a few more <strong>create</strong>, <strong>read</strong>, <strong>update</strong>, and <strong>delete</strong> (<strong>CRUD</strong>) SQL commands that are common in most relational databases. Take a look at the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Action</strong></td>
<td><strong>SQL command</strong></td>
</tr>
<tr>
<td>Create a database</td>
<td>
<pre class="PROGRAMLISTING"><strong>CREATE DATABASE mydb;</strong></pre></td>
</tr>
<tr>
<td>Create a table</td>
<td>
<pre class="PROGRAMLISTING"><strong>CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);</strong></pre></td>
</tr>
<tr>
<td>Insert into table</td>
<td>
<pre class="PROGRAMLISTING"><strong>INSERT INTO products VALUES (1, 'Rice', 5.99);</strong></pre></td>
</tr>
<tr>
<td>Update table</td>
<td>
<pre class="PROGRAMLISTING"><strong>UPDATE products SET price = 10 WHERE price = 5.99;</strong></pre></td>
</tr>
<tr>
<td>Delete from table</td>
<td>
<pre class="PROGRAMLISTING"><strong>DELETE FROM products WHERE price = 5.99;</strong></pre></td>
</tr>
</tbody>
</table>
<p> </p>
<p>These basic commands can be supported by many advanced SQL operators, such as <kbd>LIMIT</kbd>, <kbd>ORDER BY</kbd>, and <kbd>GROUP BY</kbd>. SQL has many other concepts, such as joining relations over tables.</p>
<div class="packt_infobox">You can find more details about SQL queries that are supported by PostgreSQL here: <a href="https://www.postgresql.org/docs/10/sql.html" target="_blank">https://www.postgresql.org/docs/10/sql.html</a>.</div>
<p>In the next section, we'll see how Go programs communicate with the PostgreSQL server. We'll try to leverage a database driver called <kbd>pq</kbd>. Using that driver package, we'll see an example of how to insert a web URL into PostgreSQL.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing pq, a pure PostgreSQL database driver for Go</h1>
                </header>
            
            <article>
                
<p>In <a href="08db4c3a-536c-4f0c-bedc-fcb802c3306a.xhtml">Chapter 4</a>, <em>Simplifying RESTful Services with Popular Go Frameworks</em>, we used a driver package called <kbd>go-sqlite3</kbd> to work with SQLite3. In the same way, <kbd>pq</kbd> is a database driver package available for Go.<strong> </strong>We can install that library system-wide by using the <kbd>go get</kbd> command, as follows:</p>
<pre><strong>go get github.com/lib/pq</strong></pre>
<p>We can also use the <kbd>dep</kbd> tool to install this package. We'll use it in this example. Let's look at the steps for installation here:</p>
<ol>
<li>Create a new project directory called <kbd>basicExample</kbd> in <kbd>GOPATH</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>touch -p $GOPATH/src/github.com/git-user/chapter7/basicExample</strong></pre>
<ol start="2">
<li>Now, traverse to the <kbd>basicExample</kbd> directory and use <kbd>dep</kbd> to install the <kbd>pq</kbd> package in the directory, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>dep init<br/>dep ensure --add github.com/lib/pq</strong></pre>
<p style="padding-left: 60px">This creates a few configuration files and adds a package to the vendor in the same directory. Now, we can create our program and use that <kbd>pq</kbd> package.</p>
<ol start="3">
<li>In order to create a new table, we should create a new database in the PostgreSQL server. To create a new database, enter the <kbd>psql</kbd> shell or use <strong>pgAdmin 4</strong>, as shown in the following command (you only have to do this once):</li>
</ol>
<pre style="padding-left: 60px"><strong>CREATE DATABASE mydb;</strong></pre>
<p>Let's look at  a short example that explains the usage of the <kbd>pq</kbd> driver. In the later sections, we<span>'ll</span> implement a URL-shortening service. This a pre-step for that service. We'll create a table called <kbd>web_url</kbd> for our purpose by following these steps: </p>
<ol>
<li>Create a directory called <kbd>helper</kbd> in the project, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir $GOPATH/src/github.com/git-user/chapter7/basicExample/helper</strong></pre>
<p style="padding-left: 60px"><span>This helps in initiating database operations such as creating a table.</span></p>
<p class="mce-root"/>
<ol start="2">
<li>Now, add a file called <kbd>models.go</kbd>.<strong> </strong>This file is going to have the table creation logic. We use <kbd>sql.Open</kbd> to make a connection to PostgreSQL. That function takes a database type and a database string as arguments. We can prepare a SQL statement using the <kbd>db.Prepare</kbd> command.</li>
<li>Import the necessary packages in the program, like this:</li>
</ol>
<pre style="padding-left: 60px">package helper<br/><br/>import (<br/>  "database/sql"<br/>  "fmt"<br/>  "log"<br/><br/>  _ "github.com/lib/pq" // sql behavior modified<br/>)</pre>
<ol start="4">
<li>Now, create a few constants that hold database-connection information. A database connection needs a hostname, a port, a username, a password, and a database name, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px">const (<br/>  host = "127.0.0.1"<br/>  port = 5432<br/>  user = "git-user"<br/>  password = "YOUR_PASSWORD"<br/>  dbname = "mydb"<br/>)</pre>
<p style="padding-left: 60px"><span>The password should be the one you passed when creating the user.</span></p>
<ol start="5">
<li>Next, create a function called <kbd>InitDB</kbd>. It uses a connection string to open a new database connection to PostgreSQL. After a successful connection, it should prepare a SQL statement to create a table called <kbd>web_url</kbd>. The code for the function looks like this:</li>
</ol>
<pre style="padding-left: 60px">func InitDB() (*sql.DB, error) {<br/>    var connectionString = fmt.Sprintf("host=%s port=%d user=%s "+<br/>        "password=%s dbname=%s sslmode=disable",<br/>        host, port, user, password, dbname)<br/><br/>    var err error<br/>    db, err := sql.Open("postgres", connectionString)<br/><br/>    if err != nil {<br/>        return nil, err<br/>    }<br/><br/>    stmt, err := db.Prepare("CREATE TABLE IF NOT EXISTS web_url(ID SERIAL PRIMARY KEY, URL TEXT NOT NULL);")<br/><br/>    if err != nil {<br/>        return nil, err<br/>    }<br/><br/>    _, err = stmt.Exec()<br/><br/>    if err != nil {<br/>        return nil, err<br/>    }<br/><br/>    return db, nil<br/>}</pre>
<p style="padding-left: 60px">The <kbd>sql.Open</kbd> method opens the connection string. It then prepares and executes a <kbd>CREATE TABLE</kbd> query to create a <kbd>web_url</kbd> table if this does not already exist. <kbd>InitDB</kbd> returns an error if any operation fails on the database.</p>
<ol start="6">
<li>Let's create a <kbd>main.go</kbd> program to use the <kbd>helper</kbd> package, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir $GOPATH/src/github.com/git-user/chapter7/basicExample/main.go</strong></pre>
<ol start="7">
<li>In the <kbd>main</kbd> block, we can import an <kbd><span>InitDB</span></kbd> helper function and use it like this:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>    "log"<br/><br/>    "github.com/git-user/chapter7/basicExample/helper"<br/>)<br/><br/>func main() {<br/>    _, err := helper.InitDB()<br/>    if err != nil {<br/>        log.Println(err)<br/>    }<br/><br/>    log.Println("Database tables are successfully initialized.")<br/>}</pre>
<p style="padding-left: 60px">This program imports the <kbd>helper</kbd> package and uses the <kbd>InitDB</kbd><strong> </strong>function from it. We log a successful initialization message if the table was successfully created; otherwise, we log an error.</p>
<ol start="8">
<li>If you run the program, you will see this message printed:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run main.go<br/><br/>2020/02/13 22:15:34 Database tables are successfully initialized.</strong></pre>
<p style="padding-left: 60px"> This creates a <kbd>web_url</kbd> table<strong> </strong>in the <kbd>mydb</kbd> database.<strong> </strong></p>
<ol start="9">
<li>We can cross-check that by entering into the <kbd>psql</kbd> shell and typing the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>\c mydb \dt</strong></pre>
<p style="padding-left: 60px">This connects the user to the <kbd>mydb</kbd> database and lists all available tables, as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><strong>You are now connected to database "mydb" as user "postgres".</strong><br/><strong> List of relations</strong><br/><strong> Schema | Name | Type | Owner</strong><br/><strong>--------+---------+-------+-------</strong><br/><strong> public | web_url | table | user</strong><br/><strong>(1 row)</strong></pre>
<div class="packt_tip">In PostgreSQL, the <kbd>AUTO_INCREMENT</kbd> type needs to be replaced by <kbd>SERIAL</kbd> while providing a schema for table creation.</div>
<p>As we promised earlier, in the next section, we will try to implement a URL-shortening service. We'll initially lay out the basics required for building such a service. Then, we'll move  on to the implementation. The URL-shortening service will give you a clear understanding of how PostgreSQL can be used to solve problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a URL-shortening service using PostgreSQL and pq</h1>
                </header>
            
            <article>
                
<p>Let's code the URL-shortening service to explain all the concepts we discussed in the preceding section. We need a few basics before writing an API for our service. First, we need to design a package that implements the <kbd>Base62</kbd> algorithm with encoding/decoding functions. The URL-shortening technique needs the <kbd>Base62</kbd> algorithm to convert a long URL to a short one, and vice versa. After designing the package, we'll write an example to show how this encoding works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the Base62 algorithm</h1>
                </header>
            
            <article>
                
<p>The <kbd>Base62</kbd> algorithm is a number encoder that converts a given number to a string. How does it do that? The input number is mapped from 62 characters. The beauty of this algorithm is that it creates unique, shorter strings for every given number. It can generate memorable short strings, even when the inputs are big. We use this technique to pass a database ID into the <kbd>ToBase62</kbd> function—which we are going to create shortly—and get a short string out. Let's write an example for implementing the <kbd>Base62</kbd> algorithm. The logic is purely mathematical and can be implemented in different ways. Proceed as follows:</p>
<ol>
<li class="mce-root"><span>Create a project called</span> <kbd>base62Example</kbd>, like this:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>mkdir $GOPATH/src/github.com/git-user/chapter7/base62Example</strong></pre>
<ol start="2">
<li class="mce-root"><span>C</span>reate a packag<span>e called</span> <kbd>base62</kbd> <span>and add a file called</span> <kbd>encodeutils.go</kbd>, like this:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>mkdir $GOPATH/src/github.com/git-user/chapter7/base62Example/base62<br/></strong><strong>touch $GOPATH/src/github.com/git-user/chapter7/base62Example/base62<br/>/encodeutils.go</strong></pre>
<ol start="3">
<li>Define two function<span>s called </span><kbd>ToBase62</kbd><span> and </span><kbd>ToBase10</kbd><span>.</span><strong> </strong><span>The first one takes an integer and generates a </span><kbd>base62</kbd><span> string, and the latter one reverses the effect, which means it takes a </span><kbd>base62</kbd><span> string and returns the original number. The program for encoding/decoding is as follows:</span></li>
</ol>
<pre style="padding-left: 60px">package base62<br/><br/>import (<br/>     "math"<br/>     "strings"<br/>)<br/><br/>const base = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"<br/>const b = 62<br/><br/>// Function encodes the given database ID to a base62 string<br/>func ToBase62(num int) string{<br/>    r := num % b<br/>    res := string(base[r])<br/>    div := num / b<br/>    q := int(math.Floor(float64(div)))<br/><br/>    for q != 0 {<br/>        r = q % b<br/>        temp := q / b<br/>        q = int(math.Floor(float64(temp)))<br/>        res = string(base[int(r)]) + res<br/>    }<br/><br/>    return string(res)<br/>}<br/><br/>// Function decodes a given base62 string to database ID<br/>func ToBase10(str string) int{<br/>    res := 0<br/>    for _, r := range str {<br/>        res = (b * res) + strings.Index(base, string(r))<br/>    }<br/>    return res<br/>}</pre>
<ol start="4">
<li class="mce-root"><span>C</span>reate another p<span>rogram that uses these utility functions, as follows:</span></li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>vi $GOPATH/src/github.com/git-user/chapter7/base62Example/base62/usebase62.go</strong></pre>
<p style="padding-left: 60px">This program uses the imported functions from <kbd>encodeutils.go</kbd> and calculates an encoded string. Then, it decodes back again to the original number and prints both the number and the string, as follows:</p>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>  "log"<br/><br/>  "github.com/git-user/chapter7/base62Example/base62"<br/>)<br/><br/>func main() {<br/>  x := 100<br/>  base62String := base62.ToBase62(x)<br/>  log.Println(base62String)<br/>  normalNumber := base62.ToBase10(base62String)<br/>  log.Println(normalNumber)<br/>}</pre>
<p style="padding-left: 60px">Here, we are using the <kbd>encode/decode</kbd> functions from the <kbd>base62</kbd> package<strong> </strong>and trying to print the conversion.</p>
<ol start="5">
<li>We can run the program using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>go run usebase62.go</strong></pre>
<p style="padding-left: 90px">It prints the following:</p>
<pre style="padding-left: 60px"><strong>2020/02/14 21:24:43 1C<br/>2020/02/14 21:24:43 100</strong></pre>
<p class="mce-root" style="padding-left: 60px">The <kbd>Base62</kbd> encoding of <kbd>100</kbd> is <kbd>1C</kbd>. This is because the number <kbd>100</kbd> shrunk to <kbd>1C</kbd> in our <kbd>base62</kbd> logic.</p>
<p>After learning the basics of <kbd>Base62</kbd> encoding, let's implement a URL-shortening service, whereby we'll leverage a <kbd>Base62</kbd> algorithm to generate a short URL. The implementation strategy looks like this:</p>
<ol>
<li>Design an API route to collect a long URL from the client.</li>
<li>Insert that long URL in the database and get the ID of that record.</li>
<li>Use that ID to generate a <kbd>Base62</kbd> string and pass it along with the API server hostname as a shortened URL in the response.</li>
<li>Whenever a client uses that shortened URL, it hits our API server.</li>
<li>The API server then decodes the <kbd>Base62</kbd> string back to the database ID and fetches the original URL.</li>
<li>Finally, the client can use this URL to redirect to the original site.</li>
</ol>
<p>Remember that we are building a service to support URL shorteners. These leverage our API to <kbd>encode/decode</kbd> logic to ask for a shortened URL.</p>
<p>We are going to write a Go API service that implements the preceding strategy. We will reuse the following files:</p>
<ul>
<li><kbd>encodeutils.go</kbd> from the <kbd>base62Example</kbd> project for encoding/decoding</li>
<li><kbd>base62</kbd> and <kbd>models.go</kbd> from the <kbd>basicExample</kbd> project for database logic</li>
</ul>
<p>We will use the <kbd>gorilla/mux</kbd> package for multiplexing the URL and <kbd>pq</kbd> for storing and retrieving results in the PostgreSQL database. Let's create the project structure, as follows:</p>
<ol>
<li>The directory structure looks like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>urlshortener</strong><br/><strong>├── main.go</strong><br/><strong>├── helper</strong><br/><strong>│   └── models.go</strong><br/><strong>└── utils</strong><br/><strong>    └── encodeutils.go</strong><br/><br/><strong>2 directories, 3 files</strong></pre>
<ol start="2">
<li>Copy <kbd>encodeutils.go</kbd><strong> </strong>and <kbd>models.go</kbd><strong> </strong>from the preceding examples to the directories shown in the preceding code block.</li>
<li>We need two data structures in the main program: one to hold the database connection and the other one for the URL-shortener service response. Let's call the response as a <kbd>Record</kbd> <span>type. Create two structs, like this:</span></li>
</ol>
<pre style="padding-left: 60px">type DBClient struct {<br/>  db *sql.DB<br/>}<br/><br/>type Record struct {<br/>  ID int `json:"id"`<br/>  URL string `json:"url"`<br/>}</pre>
<ol start="4">
<li>Now, create the <kbd>main</kbd> function, where we define two URLs to handler functions. These application routes are required to shorten the URL and retrieve the original URL respectively. The main block should create a new database connection and two <kbd>mux</kbd> routes. We attach <kbd>GenerateShortURL</kbd> and <kbd>GetOriginalURL</kbd> function handlers to those two mux routes.</li>
<li>Finally, we run the HTTP server, serving the API. See the following code for the <kbd>main</kbd> block:</li>
</ol>
<pre style="padding-left: 60px">func main() {<br/>  db, err := models.InitDB()<br/>  if err != nil {<br/>    panic(err)<br/>  }<br/>  dbclient := &amp;DBClient{db: db}<br/>  if err != nil {<br/>    panic(err)<br/>  }<br/>  defer db.Close()<br/>  // Create a new router<br/>  r := mux.NewRouter()<br/>  // Attach an elegant path with handler<br/>  r.HandleFunc("/v1/short/{encoded_string:[a-zA-Z0-9]*}",<br/>   dbclient.GetOriginalURL).Methods("GET")<br/>  r.HandleFunc("/v1/short",<br/>   dbclient.GenerateShortURL).Methods("POST")<br/>  srv := &amp;http.Server{<br/>    Handler: r,<br/>    Addr: "127.0.0.1:8000",<br/>    // Good practice: enforce timeouts for servers you create!<br/>    WriteTimeout: 15 * time.Second,<br/>    ReadTimeout: 15 * time.Second,<br/>  }<br/>  log.Fatal(srv.ListenAndServe())<br/>}</pre>
<p>See the <kbd>POST</kbd> operation. The <kbd>GenerateShortURL</kbd> function handler takes an HTTP request and performs the following actions:</p>
<ol>
<li>Inserts the URL coming from the HTTP request body into the database and fetches the ID of a new record.</li>
<li>Uses <kbd>base62</kbd> to convert the ID to a string and send it back in the HTTP response, as follows:</li>
</ol>
<pre style="padding-left: 60px">// GenerateShortURL adds URL to DB and gives back shortened string<br/>func (driver *DBClient) GenerateShortURL(w http.ResponseWriter,<br/>r *http.Request) {<br/>    var id int<br/>    var record Record<br/>    postBody, _ := ioutil.ReadAll(r.Body)<br/>    err := json.Unmarshal(postBody, &amp;record)<br/>    err = driver.db.QueryRow("INSERT INTO web_url(url)<br/>     VALUES($1) RETURNING id", record.URL).Scan(&amp;id)<br/>    responseMap := map[string]string{"encoded_string":<br/>     base62.ToBase62(id)}<br/><br/>    if err != nil {<br/>        w.WriteHeader(http.StatusInternalServerError)<br/>        w.Write([]byte(err.Error()))<br/>    } else {<br/>        w.WriteHeader(http.StatusOK)<br/>        w.Header().Set("Content-Type", "application/json")<br/>        response, _ := json.Marshal(responseMap)<br/>        w.Write(response)<br/>    }<br/>}</pre>
<p>The client thinks the original URL is shortened, but in reality, the ID is mapped to a shorter string using the <kbd>base62</kbd> algorithm.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now comes the <kbd>GET</kbd> operation. The <kbd>GetOriginalURL</kbd> function handler takes the shortened URL and converts it back to the original one. The logic is to convert a <kbd>base62</kbd> string (a shortened string) to a number and use that number to fetch records from the PostgreSQL database. We parse the input request and collect the <kbd>encoded_string</kbd> parameter. We use that to retrieve the original URL from the database. See the following code for the <kbd>GetOriginalURL</kbd> function handler:</p>
<pre>// GetOriginalURL fetches the original URL for the given encoded(short) string<br/>func (driver *DBClient) GetOriginalURL(w http.ResponseWriter,<br/>r *http.Request) {<br/>    var url string<br/>    vars := mux.Vars(r)<br/>    // Get ID from base62 string<br/>    id := base62.ToBase10(vars["encoded_string"])<br/>    err := driver.db.QueryRow("SELECT url FROM web_url<br/>     WHERE id = $1", id).Scan(&amp;url)<br/>    // Handle response details<br/>    if err != nil {<br/>        w.WriteHeader(http.StatusInternalServerError)<br/>        w.Write([]byte(err.Error()))<br/>    } else {<br/>        w.WriteHeader(http.StatusOK)<br/>        w.Header().Set("Content-Type", "application/json")<br/>        responseMap := map[string]interface{}{"url": url}<br/>        response, _ := json.Marshal(responseMap)<br/>        w.Write(response)<br/>    }<br/>}</pre>
<p>The <kbd>DBClient</kbd> struct is needed in order to pass the database driver between various functions. Run the program, like this:</p>
<pre><strong>go run $GOPATH/src/github.com/git-user/chapter7/urlshortener/main.go</strong></pre>
<p>Another option is to install a binary. If your <kbd>$GOPATH/bin</kbd> is already in the system <kbd>PATH</kbd> variable, we can first install the binary and run it like this:</p>
<pre><strong>go install $GOPATH/src/github.com/git-user/chapter7/urlshortener/main.go</strong></pre>
<p>Use the binary name, as follows:</p>
<pre><strong>./urlshortener</strong></pre>
<div class="packt_tip"><span>It is a best practice to install the binary because it is available system-wide. But for smaller programs, we can run <kbd>main.go</kbd> from the directory of the program.</span></div>
<p>Now, it runs the HTTP server on port <kbd>8000</kbd> and starts collecting requests for the URL-shortening service. Open the console and type these <kbd>curl</kbd> commands:</p>
<pre><strong>curl -X POST \</strong><br/><strong>  http://localhost:8000/v1/short \</strong><br/><strong>  -H 'cache-control: no-cache' \</strong><br/><strong>  -H 'content-type: application/json' \</strong><br/><strong>  -d '{</strong><br/><strong>  "url": "https://www.packtpub.com/eu/game-development/unreal-engine-4-shaders-and-effects-cookbook"</strong><br/><strong>}'</strong></pre>
<p>It returns the shortened string, as follows:</p>
<pre>{<br/>  "encoded_string": "1"<br/>}</pre>
<p>The encoded string is just <kbd>"1"</kbd>. The <kbd>Base62</kbd> algorithm starts allocating shorter strings, starting from <kbd>"1"</kbd> up to a combination of alphanumeric letters. Now, if we need to retrieve the original URL, we can perform a <kbd>GET</kbd> request, like this:</p>
<pre><strong>curl -X GET http://localhost:8000/v1/short/1</strong><strong><br/></strong></pre>
<p>It returns the following JSON code:</p>
<pre>{<br/>"url":"https://www.packtpub.com/eu/game-development/unreal-engine-4-shaders-and-effects-cookbook"<br/>}</pre>
<p>So, the service can use this result to redirect the user to the original URL (site). Here, the generated string doesn't depend on the length of the URL because  the database ID is the only criterion for encoding.</p>
<p><span>The package</span> <span>imports in </span><kbd>urlshortener</kbd><span> are left out, for brevity. Please refer to the project code from the <kbd>chapter7</kbd> GitHub repository.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_infobox">The <kbd>RETURNING</kbd> keyword needs to be added to the <kbd>INSERT</kbd> SQL command in PostgreSQL to fetch the last inserted database ID. This is not the case with the MySQL or SQLite3 <kbd>INSERT INTO web_url( ) VALUES($1) RETURNING id, record.URL</kbd> query. This database query returns the last inserted record's ID. If we drop that <kbd>RETURNING</kbd> keyword, the query returns nothing.</div>
<p>In the next section, we'll look at an important feature of PostgreSQL called JSONStore. PostgreSQL, unlike other relational databases, can allow JSON to be stored in the form of fields. It also provides a query language for JSON.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the JSONStore feature in PostgreSQL</h1>
                </header>
            
            <article>
                
<p><strong>PostgreSQL &gt;9.2</strong> has a prominent feature called JSONStore. PostgreSQL introduced two new data types for 9.2"&gt;storing JSON data. PostgreSQL allows users to insert JSON data as a <kbd>json</kbd> field or a <kbd>jsonb</kbd> field. It is quite useful for modeling real-world data that has to be more flexible in its structure. PostgreSQL draws on the best of both worlds by allowing us to store JSON strings as well as relational types.</p>
<p>The main difference between <kbd>json</kbd> and <kbd>jsonb</kbd> is that the <kbd>json</kbd> field stores data as plaintext whereas <kbd>jsonb</kbd> stores that same data as a binary field. Each has its own benefits. For example, the <kbd>json</kbd> field commonly takes up less space than <kbd>jsonb</kbd> because it is a straightforward insert, but the <kbd>jsonb</kbd> field indexes JSON for better querying. You should choose the right field depending on whether the JSON document is fetched as a whole or queried on internal keys.</p>
<p>In this section, we will try to understand a few of the JSON models that we defined for the logistics use case in the previous chapter, but here, we'll use the <kbd>jsonb</kbd> field to store and retrieve items in PostgreSQL. For accessing PostgreSQL's JSONStore, the normal <kbd>pq</kbd> library is very tedious. So, in order to handle that better, we can use an <strong>Object Relational Mapper</strong> (<strong>ORM</strong>) called <strong>Grails Object Relational Mapping</strong> (<strong>GORM</strong>). In the next section, we will discuss this briefly.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing GORM, a powerful ORM for Go</h1>
                </header>
            
            <article>
                
<p><strong>GORM</strong> provides methods for all operations that can be done in the <kbd>database/sql</kbd> package. We can install GORM using the <kbd>dep</kbd> tool. In this section, we will look at with examples of how to insert, retrieve, and query PostgreSQL <kbd>JSON</kbd> using the <kbd>GORM</kbd> package.</p>
<p>For the full documentation about this ORM, visit <a href="http://jinzhu.me/gorm/" target="_blank">http://jinzhu.me/gorm/</a>. Let's write a program that implements the <kbd>Shipment</kbd> and <kbd>Package</kbd> types as JSON models. We'll use the same models that we defined in the previous chapter for logistics. Let's look at the steps:</p>
<ol>
<li>Create a new directory called <kbd>jsonstore</kbd> in <kbd>$GOPATH/src/github.com/git-user/chapter7</kbd> and create the files, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>mkdir jsonstore</strong><br/><strong>mkdir jsonstore/helper</strong><br/><strong>touch jsonstore/helper/models.go</strong></pre>
<ol start="2">
<li>Install all dependencies via <kbd>dep</kbd> in the <kbd>jsonstore</kbd> directory, like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>dep init</strong><br/><strong>dep ensure --add "github.com/gorilla/mux" "github.com/jinzhu/gorm" "github.com/lib/pq"</strong></pre>
<ol start="3">
<li>Now, edit the <kbd>helper.go</kbd> file to add <kbd>Shipment</kbd> and <kbd>Package</kbd> models. <span>Every model (table) we create should be represented as a struct in <kbd>gorm</kbd>. That is the reason we created two structs: </span><kbd>Package</kbd> <span>and </span><kbd>Shipment</kbd><span>. The first line should be </span><kbd>gorm.Model</kbd><span>.</span> <span>The other fields are the fields of the table. By default, an auto-increment ID will be created in the documents inserted into the database. See the following code:</span></li>
</ol>
<pre style="padding-left: 90px">package helper<br/><br/>import (<br/>  "github.com/jinzhu/gorm"<br/>  _ "github.com/lib/pq"<br/>)<br/><br/>type Shipment struct {<br/>  gorm.Model<br/>  Packages []Package<br/>  Data string `sql:"type:JSONB NOT NULL DEFAULT '{}'::JSONB" json:"-"`<br/>}<br/><br/>type Package struct {<br/>  gorm.Model<br/>  Data string `sql:"type:JSONB NOT NULL DEFAULT '{}'::JSONB"`<br/>}<br/><br/>// GORM creates tables with plural names.<br/>// Use this to suppress it<br/>func (Shipment) TableName() string {<br/>  return "Shipment"<br/>}<br/><br/>func (Package) TableName() string {<br/>  return "Package"<br/>}<br/><br/></pre>
<p style="padding-left: 90px">If you notice, in the preceding code block, <kbd>Data</kbd> is the <kbd>jsonb</kbd> field created for the <kbd>Shipment</kbd> and <kbd>Package</kbd> tables.</p>
<ol start="4">
<li>After finishing the definitions of structs, we can write a table initialization logic that migrates these structs into tables in the PostgreSQL database. In order to do that, utilize the <kbd>Open</kbd> method from the GORM package to get the database connection. We can then run the <kbd>AutoMigrate</kbd> method with the structs we created previously, to save them to the database. See the following code for migration:</li>
</ol>
<pre style="padding-left: 60px">func InitDB() (*gorm.DB, error) {<br/>  var err error<br/>  db, err := gorm.Open("postgres",<br/>   "postgres://git-user:YOUR_PASSWORD@<br/>   localhost/mydb?sslmode=disable")<br/>  if err != nil {<br/>    return nil, err<br/>  }<br/>  db.AutoMigrate(&amp;Shipment{}, &amp;Package{})<br/>  return db, nil<br/>}</pre>
<p>This <kbd>InitDB</kbd> logic looks similar to the logic we defined using the <kbd>pq</kbd> library. This helper file migrates the tables and returns the database connection back to whoever calls the <kbd>InitDB</kbd> function. In the next section, we'll leverage this connection to interact with the <kbd>Shipment</kbd> and <kbd>Package</kbd> tables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the logistics REST API</h1>
                </header>
            
            <article>
                
<p>Before jumping in, let's design the API specification table that shows the REST API signatures for various URL endpoints. Refer to the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 33%"><strong>Endpoint</strong></td>
<td style="width: 23.3103%"><strong>Method</strong></td>
<td style="width: 40.6897%"><strong>Description</strong></td>
</tr>
<tr>
<td style="width: 33%"><kbd><span>/v1/shipment/id</span></kbd></td>
<td style="width: 23.3103%"><kbd>GET</kbd></td>
<td style="width: 40.6897%">Get a shipment from ID</td>
</tr>
<tr>
<td style="width: 33%"><kbd>/v1/package/id</kbd></td>
<td style="width: 23.3103%"><kbd>GET</kbd></td>
<td style="width: 40.6897%">Get a package from ID</td>
</tr>
<tr>
<td style="width: 33%"><kbd><span>/v1/package?weight=n</span></kbd></td>
<td style="width: 23.3103%"><kbd>GET</kbd></td>
<td style="width: 40.6897%">Get a package with a given weight in grams</td>
</tr>
<tr>
<td style="width: 33%"><kbd>/v1/shipment</kbd></td>
<td style="width: 23.3103%"><kbd>POST</kbd></td>
<td style="width: 40.6897%">Create a new shipment</td>
</tr>
<tr>
<td style="width: 33%"><kbd>/v1/package</kbd></td>
<td style="width: 23.3103%"><kbd>POST</kbd></td>
<td style="width: 40.6897%">Create a new package</td>
</tr>
</tbody>
</table>
<p> </p>
<p>To implement the preceding API, we need a main program that registers API routes to handler functions. Add one more file to our <kbd>jsonstore</kbd><strong> </strong>project, like this:</p>
<pre><strong>touch jsonstore/main.go</strong></pre>
<p>In this program, we will try to implement the <kbd>POST</kbd> and <kbd>GET</kbd> endpoints for <kbd>Package</kbd>. We suggest implementing the remaining two endpoints of <kbd>Shipment</kbd> as an assignment for the reader. Follow these steps:</p>
<ol>
<li>The program structure follows the same style as all the programs we have seen until now. We collect the database connection from the helper package and use it to create <kbd>DBClient</kbd>. We use <kbd>gorilla/mux</kbd> as our HTTP router and the <kbd>gorm</kbd> package for database operations. We should have these routes and handlers in our program, as follows:</li>
</ol>
<pre style="padding-left: 60px">type DBClient struct {<br/>    db *gorm.DB<br/>}<br/><br/>func main(){<br/>  ...<br/>  db, err := models.InitDB()<br/>  dbclient := &amp;DBClient{db: db}<br/><br/>  r.HandleFunc("/v1/package/{id:[a-zA-Z0-9]*}",<br/>   dbclient.GetPackage).Methods("GET")<br/>  r.HandleFunc("/v1/package",<br/>   dbclient.PostPackage).Methods("POST")<br/>  r.HandleFunc("/v1/package",<br/>   dbclient.GetPackagesbyWeight).Methods("GET")<br/>  ...<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>The <kbd>POST</kbd> handler function saves a package object into the database. It returns an ID of the inserted record. The code for the <kbd>PostPackage</kbd> handler looks like this:</li>
</ol>
<pre style="padding-left: 60px">// PostPackage saves the package information<br/>func (driver *DBClient) PostPackage(w http.ResponseWriter,<br/> r *http.Request) {<br/>  var Package = models.Package{}<br/>  postBody, _ := ioutil.ReadAll(r.Body)<br/>  Package.Data = string(postBody)<br/>  driver.db.Save(&amp;Package)<br/>  responseMap := map[string]interface{}{"id": Package.ID}<br/>  w.Header().Set("Content-Type", "application/json")<br/>  response, _ := json.Marshal(responseMap)<br/>  w.Write(response)<br/>}</pre>
<p class="CDPAlignLeft CDPAlign" style="padding-left: 60px">This function is reading the <kbd>POST</kbd> body from the response and making an ORM function call to save the package data, like this:</p>
<pre style="padding-left: 60px">driver.db.Save(&amp;Package)</pre>
<p style="padding-left: 60px">After saving the package successfully to the database, the preceding function is returning the ID as part of the response.</p>
<ol start="3">
<li>Now, let's write the code for the <kbd>GetPackage</kbd> handler function. It is similar to the preceding handler except that it uses a different database function. In this code, instead of reading the request body, we have to read the <kbd>PATH</kbd> variable and use that for querying data. See the following code:</li>
</ol>
<pre style="padding-left: 60px">type PackageResponse struct {<br/>    Package helper.Package `json:"Package"`<br/>}<br/><br/>// GetPackage fetches the original URL for the given<br/>// encoded(short) string<br/>func (driver *DBClient) GetPackage(w http.ResponseWriter,<br/>r *http.Request) {<br/>  var Package = models.Package{}<br/>  vars := mux.Vars(r)<br/> <br/>  driver.db.First(&amp;Package, vars["id"])<br/>  var PackageData interface{}<br/> <br/>  json.Unmarshal([]byte(Package.Data), &amp;PackageData)<br/>  var response = PackageResponse{Package: Package}<br/>  w.WriteHeader(http.StatusOK)<br/>  w.Header().Set("Content-Type", "application/json")<br/>  respJSON, _ := json.Marshal(response)<br/>  w.Write(respJSON)<br/>}</pre>
<p style="padding-left: 60px">In this case, the query is as follows:</p>
<pre style="padding-left: 60px">driver.db.First(&amp;Package, vars["id"])</pre>
<ol start="4">
<li>Now comes another <kbd>GET</kbd> operation. The <kbd>GetPackagebyWeight</kbd> handler function queries the database for a package with a given weight. Here, we use a JSON query on the <kbd>data</kbd> field. We use a special syntax of <kbd>column -&gt;&gt; field</kbd>, as shown in the following handler code:</li>
</ol>
<pre style="padding-left: 60px">// GetPackagesbyWeight fetches all packages with given weight<br/>func (driver *DBClient) GetPackagesbyWeight(w http.ResponseWriter, r *http.Request) {<br/>  var packages []models.Package<br/>  weight := r.FormValue("weight")<br/>  // Handle response details<br/>  var query = "select * from \"Package\" where data-&gt;&gt;'weight'=?"<br/>  driver.db.Raw(query, weight).Scan(&amp;packages)<br/>  w.WriteHeader(http.StatusOK)<br/>  w.Header().Set("Content-Type", "application/json")<br/>  respJSON, _ := json.Marshal(packages)<br/>  w.Write(respJSON)<br/>}</pre>
<div class="packt_infobox">There are many other variations for querying JSON in PostgreSQL. You can find them here: <a href="https://www.postgresql.org/docs/10/functions-json.html">https://www.postgresql.org/docs/10/functions-json.html</a>.</div>
<p>In the <kbd>GetPackagesbyWeight</kbd> handler function, we are making a raw query to the database by using the <kbd>db.Raw</kbd> method. It returns all packages <span>as a list of those matching the weight criteria</span> . For this <kbd>GET</kbd> API, the weight criteria list is being sent by the client as a query parameter.</p>
<p>There are four important aspects in this JSONStore example, as follows:</p>
<ul>
<li>We replaced the traditional driver, <kbd>pq</kbd>, with the <kbd>GORM</kbd> driver.</li>
<li>We used GORM functions for CRUD operations.</li>
<li>We inserted JSON into PostgreSQL and retrieved results.</li>
<li>We executed raw SQL and filtered fields on JSON.</li>
</ul>
<p class="mce-root"/>
<p>This completes the important logic for our program. Please refer to the <kbd>chapter7</kbd> repository for the complete code.</p>
<p>Now, run the program using the following command:</p>
<pre><strong>go run jsonstore/main.go</strong></pre>
<p>It runs a Go server. Make a few <kbd>curl</kbd> commands to see the API response, as follows:</p>
<ol>
<li>Create the package (<kbd>POST</kbd>), as follows:</li>
</ol>
<pre style="padding-left: 60px">curl -X POST \<br/>  http://localhost:8000/v1/package \<br/>  -H 'cache-control: no-cache' \<br/>  -H 'content-type: application/json' \<br/>  -d '{<br/>      "dimensions": {<br/>       "width": 21,<br/>        "height": 12<br/>      },<br/>      "weight": 10,<br/>      "is_damaged": false,<br/>      "status": "In transit"<br/>     }'</pre>
<p style="padding-left: 60px">It returns the inserted record in the database, as follows:</p>
<pre style="padding-left: 60px">{<br/>  "id": 1<br/>}</pre>
<ol start="2">
<li>Now, we need to <kbd>GET</kbd> the details of the inserted package, as follows: </li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET http://localhost:8000/v1/package/1</strong> </pre>
<p style="padding-left: 60px">It returns all the details about a package with <kbd>ID:1</kbd>, as follows:</p>
<pre style="padding-left: 60px">{"Package":{"ID":1,"CreatedAt":"2020-02-15T11:14:52.859073Z","UpdatedAt":"2020-02-15T11:14:52.859073Z","DeletedAt":null,"Data":"{\"status\": \"In transit\", \"weight\": 10, \"dimensions\": {\"width\": 21, \"height\": 12}, \"is_damaged\": false}"}}</pre>
<ol start="3">
<li>Let's test our second <kbd>GET</kbd> API, as follows:<strong> </strong></li>
</ol>
<pre style="padding-left: 60px"><strong>curl -X GET 'http://localhost:8000/v1/package?weight=10'</strong></pre>
<p style="padding-left: 60px">This returns all the packages with a weight of <kbd>10</kbd> gms, as follows:</p>
<pre style="padding-left: 60px">[{"ID":1,"CreatedAt":"2020-02-15T11:14:52.859073Z","UpdatedAt":"2020-02-15T11:14:52.859073Z","DeletedAt":null,"Data":"{\"status\": \"In transit\", \"weight\": 10, \"dimensions\": {\"width\": 21, \"height\": 12}, \"is_damaged\": false}"}]</pre>
<p>The goal of this project is to show how JSON can be stored in and retrieved from PostgreSQL. This concludes our journey through PostgreSQL. There is a lot more to explore in PostgreSQL, but it is out of the scope of this book. PostgreSQL brings together the best of both worlds by allowing us to store relational as well as JSON data in the same table. It also allows us to query JSON data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started our journey by introducing PostgreSQL. We saw how to run PostgreSQL in Docker, and then listed out a few basic SQL queries for CRUD operations. We learned how to add new users and roles in PostgreSQL. We then discussed <kbd>pq</kbd>, a PostgreSQL driver package for Go, with an example.</p>
<p>We designed a URL-shortening service using the Base62 algorithm. We leveraged <kbd>pq</kbd> and <kbd>gorilla/mux</kbd> for implementing that service.</p>
<p>PostgreSQL also allows <strong>JSON storage</strong> (<strong>JSONStore</strong>) from version 9.2 onward. It allows developers to insert and retrieve JSON documents in a database. It combines the power of both relational and non-relational databases with JSONStore.</p>
<p>We also introduced GORM, a well-known ORM for Go. Using an ORM, database operations can be easily managed. GORM provides a few useful functions—such as <kbd>AutoMigrate</kbd> (creating a table if one doesn't exist)—for writing intuitive Go code over the traditional <kbd>database/sql</kbd> driver.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, we implemented a REST API for logistics <span>using GORM</span>. PostgreSQL is a well-established, open source relational database that can be a good storage backend for Go. With <kbd>pq</kbd> and <kbd>GORM</kbd>, driver support for Go is exceptional. The primary goal of this chapter was to make you feel comfortable working with PostgreSQL and Go for REST API development.</p>
<p>So far, we have looked at about building servers that provide REST APIs. Sometimes, developers need client-side tools to consume a REST API. It is also useful to understand how clients can consume a REST API to create a better API. In the next chapter, we will learn generally about <span>how client software is built in Go. There, we also develop API clients for a GitHub REST API.</span></p>


            </article>

            
        </section>
    </body></html>