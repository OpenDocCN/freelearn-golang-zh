- en: Working with PostgreSQL, JSON, and Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与PostgreSQL、JSON和Go一起工作
- en: In this chapter, we are going to take a bird's-eye view of SQL. In the previous
    chapters, we discussed SQLite3, which is a lightweight database for quick prototyping.
    But when it comes to developing an enterprise-grade application, MySQL or PostgreSQL
    is the preferred choice. Both are well-proven, heavy-duty databases that are open
    source. In this chapter, we'll pick PostgreSQL as our main subject.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从宏观的角度审视SQL。在前面的章节中，我们讨论了SQLite3，它是一个用于快速原型设计的轻量级数据库。但是，当涉及到开发企业级应用程序时，MySQL或PostgreSQL是首选的选择。两者都是经过充分验证的、功能强大的开源数据库。在本章中，我们将选择PostgreSQL作为我们的主要主题。
- en: First, we'll discuss the internals of PostgreSQL, and then move on to use the
    database with Go. The goal of this chapter is to make the reader comfortable working
    with PostgreSQL and Go. We'll also build a URL-shortening service that requires
    a database layer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论PostgreSQL的内部结构，然后转向使用Go数据库。本章的目标是让读者能够舒适地使用PostgreSQL和Go。我们还将构建一个需要数据库层的URL缩短服务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Discussing PostgreSQL installation options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论PostgreSQL的安装选项
- en: Introducing `pq`, a pure PostgreSQL database driver for Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`pq`，一个纯PostgreSQL数据库驱动程序，用于Go
- en: Implementing a URL-shortening service using PostgreSQL and `pq`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PostgreSQL和`pq`实现URL缩短服务
- en: Exploring the JSONStore feature in PostgreSQL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索PostgreSQL中的JSONStore功能
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software should be pre-installed in order to run the code samples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行代码示例，以下软件应预先安装：
- en: 'Operating system: Linux (Ubuntu 18.04)/Windows 10/MacOS X >= 10.13'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux（Ubuntu 18.04）/Windows 10/MacOS X >= 10.13
- en: 'Software: Docker >= 18 (Docker Desktop for Windows and MacOS X)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件：Docker >= 18（Windows和MacOS X的Docker Desktop）
- en: 'Go compiler: stable version >= 1.13.5'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go编译器：稳定版本 >= 1.13.5
- en: 'PostgreSQL: stable version >= 10.8'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL：稳定版本 >= 10.8
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter7](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter7).
    Clone the code, and use the code samples in the `chapter7` directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter7](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter7)下载本章的代码。克隆代码，并使用`chapter7`目录中的代码示例。
- en: Discussing PostgreSQL installation options
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论PostgreSQL的安装选项
- en: 'PostgreSQL is an open source database that can be installed on multiple platforms.
    There are two standard options to install PostgreSQL:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL是一个开源数据库，可以在多个平台上安装。安装PostgreSQL有两种标准选项：
- en: Manual server installation on a machine
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器上手动安装服务器
- en: Installation in a Docker container
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker容器中安装
- en: Manual installation on an operating system can be a universal installation.
    You can find instructions for installation at this official PostgreSQL link: [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统上手动安装可以是通用安装。您可以在以下官方PostgreSQL链接中找到安装说明：[https://www.postgresql.org/download/](https://www.postgresql.org/download/)。
- en: For MacOS X and Windows, you get straightforward installers. For the varieties
    of Linux, the PostgreSQL website has nice documentation with detailed instructions.
    The only drawback with universal installation is you are bound to install/uninstall
    the PostgreSQL database whenever you change the version. In container-based systems,
    the execution environment is isolated from the host system. Docker is one such
    popular container system. In the upcoming subsection, we'll look at the installation
    of PostgreSQL inside a Docker container.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MacOS X和Windows，您将获得直接的安装程序。对于各种Linux版本，PostgreSQL网站有很好的文档，提供了详细的说明。使用通用安装的唯一缺点是，每当您更改版本时，您都必须安装/卸载PostgreSQL数据库。在基于容器的系统中，执行环境与主机系统隔离。Docker就是这样一种流行的容器系统。在接下来的小节中，我们将探讨如何在Docker容器中安装PostgreSQL。
- en: Installing via Docker
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Docker安装
- en: 'We can also install PostgreSQL via Docker. This is the most common approach
    these days because of reduced complexity and an easy installation process. Assuming
    Docker is set up on your machine, proceed as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过Docker安装PostgreSQL。由于简化了复杂性和易于安装的过程，这种方法现在是最常见的。假设Docker已在您的机器上设置，请按照以下步骤操作：
- en: 'The latest stable version is `10.8`. Pull a Docker image with the version as
    a tag, like this:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最新稳定版本是`10.8`。拉取带有版本作为标签的Docker镜像，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'See a list of all the images available with the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令查看所有可用镜像的列表：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Start a PostgreSQL server on port `5432` inside a container by mapping the
    database file to a local file, like this:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将数据库文件映射到本地文件，在容器内以端口`5432`启动PostgreSQL服务器，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This starts the PostgreSQL server on `localhost:5432`. It also mounts the PostgreSQL
    database's data directory to a local directory named `postgres-data`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`localhost:5432`上启动PostgreSQL服务器。它还将PostgreSQL数据库的数据目录挂载到名为`postgres-data`的本地目录。
- en: Replace `YOUR_PASSWORD` with an actual password while running the preceding
    command. The `-d` option is used in the command to run the container as a daemon
    process. Now, the PostgreSQL server is running on our machine. It uses the `postgres:10.8` Docker
    image we pulled previously.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令时，将`YOUR_PASSWORD`替换为实际密码。`-d`选项用于在命令中运行容器作为守护进程。现在，PostgreSQL服务器正在我们的机器上运行。它使用我们之前拉取的`postgres:10.8`
    Docker镜像。
- en: We can also use the `docker run` command without pulling the image. The `docker
    pull` command is to explicitly show that we are using the `postgres` image.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`docker run`命令而不拉取镜像。`docker pull`命令是明确显示我们正在使用`postgres`镜像。
- en: Once we have installed PostgreSQL, we have to create default users to access
    the database. We'll look at this in the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了PostgreSQL，我们必须创建默认用户以访问数据库。我们将在下一节中探讨这个问题。
- en: Adding users and databases in PostgreSQL
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PostgreSQL中添加用户和数据库
- en: 'Now, we can create a new user and database. For this, we are going to use Ubuntu/MacOS
    X as a general example. We do this in a shell called the `psql` shell. We can
    see all available commands in `psql` using the `\?` command. In order to enter
    the `psql` shell, first, change to the `postgres` user. On Ubuntu, for universal
    installation, you can enter the `psql` shell using the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个新的用户和数据库。为此，我们将使用Ubuntu/MacOS X作为一个通用示例。我们在名为`psql`的shell中这样做。我们可以使用`\?`命令在`psql`中查看所有可用的命令。为了进入`psql`
    shell，首先，切换到`postgres`用户。在Ubuntu上，对于通用安装，你可以使用以下命令进入`psql` shell：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, it turns us into a user called `postgres`. Then, launch the `psql` shell
    using the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它使我们成为名为`postgres`的用户。然后，使用以下命令启动`psql` shell：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the case of PostgreSQL running in a Docker container, use this command to
    launch the `psql` shell directly:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL在Docker容器中运行的情况下，使用以下命令直接启动`psql` shell：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you are in the `psql` shell, type the `\?` help command in there, and
    you will see the output of all available commands, as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入`psql` shell，在shell中输入`\?`帮助命令，你将看到所有可用的命令输出，如下面的截图所示：
- en: '![](img/f2f8467d-50d8-4b0d-94a8-fa961bdefab4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2f8467d-50d8-4b0d-94a8-fa961bdefab4.png)'
- en: 'To list all available users and their privileges, you will find the following
    command in the `Informational` section of the help shell:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有可用的用户及其权限，你将在帮助shell的`信息`部分找到以下命令：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A role is the access permission given to a user. With the `\du` command, you
    can see that the default user is `postgres`, with the following roles attached:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是授予用户的访问权限。使用`\du`命令，你可以看到默认用户是`postgres`，附有以下角色：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need a new user to work with PostgreSQL. To add a new user, just type this
    `SQL` command in the `psql` shell:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个新用户来与PostgreSQL一起工作。要添加新用户，只需在`psql` shell中输入此`SQL`命令：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This creates a new user with the name `gituser` and the password `YOUR_PASSWORD`.
    Now, give permission to the user to create databases and further roles, using
    the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为`gituser`的新用户和密码`YOUR_PASSWORD`。现在，使用以下命令给用户权限以创建数据库和进一步的角色：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to delete a user, use the `DROP` command in the same context, like
    this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除用户，使用相同上下文中的`DROP`命令，如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Don't try to change the password for the default `postgres` user.It is intended
    to be a superuser account, and should not be kept as a normal user. Instead, create
    a new role and give the required permissions for it. Use strong passwords.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试更改默认`postgres`用户的密码。它被设计为一个超级用户账户，不应作为普通用户保留。相反，创建一个新的角色并为其分配所需的权限。使用强密码。
- en: If you don't use a **command-line interface** (**CLI**), you can install a **graphical
    user interface** (**GUI**) client such as **pgAdmin 4** for accessing the database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用**命令行界面**（**CLI**），你可以安装**图形用户界面**（**GUI**）客户端，如**pgAdmin 4**，以访问数据库。
- en: You can find more details about installing **pgAdmin 4** as a Docker application
    here: [https://hub.docker.com/r/dpage/pgadmin4/](https://hub.docker.com/r/dpage/pgadmin4/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到更多关于如何将**pgAdmin 4**作为Docker应用程序安装的详细信息：[https://hub.docker.com/r/dpage/pgadmin4/](https://hub.docker.com/r/dpage/pgadmin4/)。
- en: 'Now we know how to create a role, let''s see a few more **create**, **read**,
    **update**, and **delete** (**CRUD**) SQL commands that are common in most relational
    databases. Take a look at the following table:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建一个角色，让我们看看一些更常见的**创建**、**读取**、**更新**和**删除**（**CRUD**）SQL命令，这些命令在大多数关系型数据库中都很常见。看看下面的表格：
- en: '| **Action** | **SQL command** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **SQL命令** |'
- en: '| Create a database |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 创建数据库 |'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Create a table |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 创建表 |'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Insert into table |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 向表中插入 |'
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Update table |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 更新表 |'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Delete from table |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 从表中删除 |'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: These basic commands can be supported by many advanced SQL operators, such as
    `LIMIT`, `ORDER BY`, and `GROUP BY`. SQL has many other concepts, such as joining
    relations over tables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本命令可以由许多高级SQL运算符支持，例如`LIMIT`、`ORDER BY`和`GROUP BY`。SQL还有许多其他概念，例如在表之间连接关系。
- en: You can find more details about SQL queries that are supported by PostgreSQL
    here: [https://www.postgresql.org/docs/10/sql.html](https://www.postgresql.org/docs/10/sql.html).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到更多关于PostgreSQL支持的SQL查询的详细信息：[https://www.postgresql.org/docs/10/sql.html](https://www.postgresql.org/docs/10/sql.html)。
- en: In the next section, we'll see how Go programs communicate with the PostgreSQL
    server. We'll try to leverage a database driver called `pq`. Using that driver
    package, we'll see an example of how to insert a web URL into PostgreSQL.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到Go程序如何与PostgreSQL服务器通信。我们将尝试利用一个名为`pq`的数据库驱动程序。使用该驱动程序包，我们将看到一个将Web
    URL插入PostgreSQL的例子。
- en: Introducing pq, a pure PostgreSQL database driver for Go
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍pq，一个纯PostgreSQL数据库驱动程序，适用于Go
- en: 'In [Chapter 4](08db4c3a-536c-4f0c-bedc-fcb802c3306a.xhtml), *Simplifying RESTful
    Services with Popular Go Frameworks*, we used a driver package called `go-sqlite3` to
    work with SQLite3\. In the same way, `pq` is a database driver package available
    for Go.We can install that library system-wide by using the `go get` command,
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](08db4c3a-536c-4f0c-bedc-fcb802c3306a.xhtml)，《使用流行的Go框架简化RESTful服务》，我们使用了一个名为`go-sqlite3`的驱动包来与SQLite3交互。同样地，`pq`是一个适用于Go的数据库驱动包。我们可以通过使用`go
    get`命令在系统范围内安装该库，如下所示：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also use the `dep` tool to install this package. We''ll use it in this
    example. Let''s look at the steps for installation here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`dep`工具安装此包。我们将在本例中使用它。让我们看看安装步骤：
- en: 'Create a new project directory called `basicExample` in `GOPATH`, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GOPATH`中创建一个名为`basicExample`的新项目目录，如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, traverse to the `basicExample` directory and use `dep` to install the `pq`
    package in the directory, like this:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到`basicExample`目录，并使用`dep`安装该目录中的`pq`包，如下所示：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This creates a few configuration files and adds a package to the vendor in the
    same directory. Now, we can create our program and use that `pq` package.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一些配置文件，并在同一目录下添加一个包到供应商中。现在，我们可以创建我们的程序并使用那个`pq`包。
- en: 'In order to create a new table, we should create a new database in the PostgreSQL
    server. To create a new database, enter the `psql` shell or use **pgAdmin 4**,
    as shown in the following command (you only have to do this once):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个新的表，我们应该在PostgreSQL服务器中创建一个新的数据库。要创建一个新的数据库，请进入`psql`外壳或使用**pgAdmin 4**，如下所示（你只需这样做一次）：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s look at  a short example that explains the usage of the `pq` driver.
    In the later sections, we''ll implement a URL-shortening service. This a pre-step
    for that service. We''ll create a table called `web_url` for our purpose by following
    these steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简短的例子，解释了`pq`驱动程序的使用。在后面的章节中，我们将实现一个URL缩短服务。这是该服务的预步骤。我们将按照以下步骤创建一个名为`web_url`的表：
- en: 'Create a directory called `helper` in the project, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中创建一个名为`helper`的目录，如下所示：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This helps in initiating database operations such as creating a table.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于启动数据库操作，如创建表。
- en: Now, add a file called `models.go`.This file is going to have the table creation
    logic. We use `sql.Open` to make a connection to PostgreSQL. That function takes
    a database type and a database string as arguments. We can prepare a SQL statement
    using the `db.Prepare` command.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为`models.go`的文件。这个文件将包含表创建逻辑。我们使用`sql.Open`来连接到PostgreSQL。该函数接受数据库类型和数据库字符串作为参数。我们可以使用`db.Prepare`命令准备一个SQL语句。
- en: 'Import the necessary packages in the program, like this:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序中导入必要的包，如下所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, create a few constants that hold database-connection information. A database
    connection needs a hostname, a port, a username, a password, and a database name,
    as shown in the following code block:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一些常量来保存数据库连接信息。数据库连接需要一个主机名、端口号、用户名、密码和数据库名，如下面的代码块所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The password should be the one you passed when creating the user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 密码应该是你在创建用户时提供的密码。
- en: 'Next, create a function called `InitDB`. It uses a connection string to open
    a new database connection to PostgreSQL. After a successful connection, it should
    prepare a SQL statement to create a table called `web_url`. The code for the function
    looks like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `InitDB` 的函数。它使用连接字符串来打开一个新的数据库连接到 PostgreSQL。在成功连接后，它应该准备一个 SQL
    语句来创建一个名为 `web_url` 的表。该函数的代码如下：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `sql.Open` method opens the connection string. It then prepares and executes
    a `CREATE TABLE` query to create a `web_url` table if this does not already exist. `InitDB`
    returns an error if any operation fails on the database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`sql.Open` 方法打开连接字符串。然后准备并执行一个 `CREATE TABLE` 查询来创建一个 `web_url` 表（如果该表尚不存在）。如果数据库上的任何操作失败，`InitDB`
    将返回一个错误。'
- en: 'Let''s create a `main.go` program to use the `helper` package, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `main.go` 程序来使用 `helper` 包，如下所示：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `main` block, we can import an `InitDB` helper function and use it like
    this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 块中，我们可以导入一个 `InitDB` 辅助函数并像这样使用它：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This program imports the `helper` package and uses the `InitDB`function from
    it. We log a successful initialization message if the table was successfully created;
    otherwise, we log an error.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序导入了 `helper` 包并使用其中的 `InitDB` 函数。如果表成功创建，我们将记录一个成功的初始化消息；否则，我们将记录一个错误。
- en: 'If you run the program, you will see this message printed:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行程序，你将看到以下信息被打印出来：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This creates a `web_url` tablein the `mydb` database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `mydb` 数据库中创建了一个 `web_url` 表。
- en: 'We can cross-check that by entering into the `psql` shell and typing the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过进入 `psql` 壳并输入以下内容来交叉检查：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This connects the user to the `mydb` database and lists all available tables,
    as shown in the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用户连接到 `mydb` 数据库并列出所有可用的表，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In PostgreSQL, the `AUTO_INCREMENT` type needs to be replaced by `SERIAL` while
    providing a schema for table creation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中，创建表时需要将 `AUTO_INCREMENT` 类型替换为 `SERIAL`。
- en: As we promised earlier, in the next section, we will try to implement a URL-shortening
    service. We'll initially lay out the basics required for building such a service.
    Then, we'll move  on to the implementation. The URL-shortening service will give
    you a clear understanding of how PostgreSQL can be used to solve problems.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前承诺的，在下一节中，我们将尝试实现一个 URL 缩短服务。我们首先将概述构建此类服务所需的基本知识。然后，我们将继续进行实现。URL 缩短服务将帮助你清楚地了解
    PostgreSQL 如何用于解决问题。
- en: Implementing a URL-shortening service using PostgreSQL and pq
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL 和 pq 实现URL缩短服务
- en: Let's code the URL-shortening service to explain all the concepts we discussed
    in the preceding section. We need a few basics before writing an API for our service.
    First, we need to design a package that implements the `Base62` algorithm with
    encoding/decoding functions. The URL-shortening technique needs the `Base62` algorithm
    to convert a long URL to a short one, and vice versa. After designing the package,
    we'll write an example to show how this encoding works.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写 URL 缩短服务的代码来解释前面章节中讨论的所有概念。在编写我们服务的 API 之前，我们需要一些基础知识。首先，我们需要设计一个实现 `Base62`
    算法并带有编码/解码函数的包。URL 缩短技术需要 `Base62` 算法将长 URL 转换为短 URL，反之亦然。设计完包后，我们将编写一个示例来展示这种编码是如何工作的。
- en: Defining the Base62 algorithm
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 Base62 算法
- en: 'The `Base62` algorithm is a number encoder that converts a given number to
    a string. How does it do that? The input number is mapped from 62 characters.
    The beauty of this algorithm is that it creates unique, shorter strings for every
    given number. It can generate memorable short strings, even when the inputs are
    big. We use this technique to pass a database ID into the `ToBase62` function—which
    we are going to create shortly—and get a short string out. Let''s write an example
    for implementing the `Base62` algorithm. The logic is purely mathematical and
    can be implemented in different ways. Proceed as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Base62` 算法是一个数字编码器，它将给定的数字转换为字符串。它是如何做到这一点的？输入数字是从 62 个字符映射过来的。这个算法的美丽之处在于它为每个给定的数字创建唯一的、较短的字符串。即使输入很大，它也可以生成易于记忆的短字符串。我们使用这种技术将数据库
    ID 传递到我们将要创建的 `ToBase62` 函数中，并得到一个短字符串。让我们编写一个实现 `Base62` 算法的示例。逻辑完全是数学性的，可以以不同的方式实现。按照以下步骤进行：'
- en: 'Create a project called `base62Example`, like this:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `base62Example` 的项目，如下所示：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a package called `base62` and add a file called `encodeutils.go`, like
    this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `base62` 的包并添加一个名为 `encodeutils.go` 的文件，如下所示：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define two functions called `ToBase62` and `ToBase10`.The first one takes an
    integer and generates a `base62` string, and the latter one reverses the effect,
    which means it takes a `base62` string and returns the original number. The program
    for encoding/decoding is as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个函数，分别命名为 `ToBase62` 和 `ToBase10`。第一个函数接收一个整数并生成一个 `base62` 字符串，而第二个函数则相反，它接收一个
    `base62` 字符串并返回原始数字。编码/解码的程序如下：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create another program that uses these utility functions, as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个程序，使用这些实用函数，如下所示：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This program uses the imported functions from `encodeutils.go` and calculates
    an encoded string. Then, it decodes back again to the original number and prints
    both the number and the string, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序使用从 `encodeutils.go` 导入的函数并计算一个编码字符串。然后，它将其解码回原始数字并打印出数字和字符串，如下所示：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we are using the `encode/decode` functions from the `base62` packageand
    trying to print the conversion.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `base62` 包中的 `encode/decode` 函数并尝试打印转换。
- en: 'We can run the program using the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行程序：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It prints the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印以下内容：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Base62` encoding of `100` is `1C`. This is because the number `100` shrunk
    to `1C` in our `base62` logic.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 `100` 的 `Base62` 编码是 `1C`。这是因为数字 `100` 在我们的 `base62` 逻辑中缩小为 `1C`。
- en: 'After learning the basics of `Base62` encoding, let''s implement a URL-shortening
    service, whereby we''ll leverage a `Base62` algorithm to generate a short URL.
    The implementation strategy looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 `Base62` 编码的基础知识之后，让我们实现一个 URL 缩短服务，我们将利用 `Base62` 算法生成一个短 URL。实现策略如下所示：
- en: Design an API route to collect a long URL from the client.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计一个 API 路由以从客户端收集一个长 URL。
- en: Insert that long URL in the database and get the ID of that record.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该长 URL 插入数据库并获取该记录的 ID。
- en: Use that ID to generate a `Base62` string and pass it along with the API server
    hostname as a shortened URL in the response.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该 ID 生成一个 `Base62` 字符串，并将其与 API 服务器主机名一起作为响应中的缩短 URL 传递。
- en: Whenever a client uses that shortened URL, it hits our API server.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端使用该缩短 URL 时，它会击中我们的 API 服务器。
- en: The API server then decodes the `Base62` string back to the database ID and
    fetches the original URL.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 服务器然后将 `Base62` 字符串解码回数据库 ID 并获取原始 URL。
- en: Finally, the client can use this URL to redirect to the original site.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，客户端可以使用此 URL 跳转到原始网站。
- en: Remember that we are building a service to support URL shorteners. These leverage
    our API to `encode/decode` logic to ask for a shortened URL.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们正在构建一个支持 URL 缩短的服务。这些服务利用我们的 API 来 `encode/decode` 逻辑请求缩短 URL。
- en: 'We are going to write a Go API service that implements the preceding strategy.
    We will reuse the following files:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个 Go API 服务，实现上述策略。我们将重用以下文件：
- en: '`encodeutils.go` from the `base62Example` project for encoding/decoding'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `base62Example` 项目中获取 `encodeutils.go` 以进行编码/解码
- en: '`base62` and `models.go` from the `basicExample` project for database logic'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `basicExample` 项目中获取 `base62` 和 `models.go` 以支持数据库逻辑
- en: 'We will use the `gorilla/mux` package for multiplexing the URL and `pq` for
    storing and retrieving results in the PostgreSQL database. Let''s create the project
    structure, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `gorilla/mux` 包进行 URL 多路复用，并使用 `pq` 在 PostgreSQL 数据库中存储和检索结果。让我们创建项目结构，如下所示：
- en: 'The directory structure looks like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目录结构如下所示：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Copy `encodeutils.go`and `models.go`from the preceding examples to the directories
    shown in the preceding code block.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`encodeutils.go`和`models.go`从前面的示例复制到前面代码块中显示的目录。
- en: 'We need two data structures in the main program: one to hold the database connection
    and the other one for the URL-shortener service response. Let''s call the response
    as a `Record` type. Create two structs, like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主程序中，我们需要两个数据结构：一个用于存储数据库连接，另一个用于存储URL缩短服务响应。让我们将响应称为`Record`类型。创建两个结构体，如下所示：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, create the `main` function, where we define two URLs to handler functions.
    These application routes are required to shorten the URL and retrieve the original
    URL respectively. The main block should create a new database connection and two
    `mux` routes. We attach `GenerateShortURL` and `GetOriginalURL` function handlers
    to those two mux routes.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`main`函数，其中我们定义两个URL处理函数。这些应用程序路由需要缩短URL和检索原始URL。主块应该创建一个新的数据库连接和两个`mux`路由。我们将`GenerateShortURL`和`GetOriginalURL`函数处理程序附加到这两个mux路由。
- en: 'Finally, we run the HTTP server, serving the API. See the following code for
    the `main` block:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行HTTP服务器，提供API服务。以下代码是`main`块：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'See the `POST` operation. The `GenerateShortURL` function handler takes an
    HTTP request and performs the following actions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`POST`操作。`GenerateShortURL`函数处理程序接收一个HTTP请求并执行以下操作：
- en: Inserts the URL coming from the HTTP request body into the database and fetches
    the ID of a new record.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将来自HTTP请求体的URL插入数据库并检索新记录的ID。
- en: 'Uses `base62` to convert the ID to a string and send it back in the HTTP response,
    as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`base62`将ID转换为字符串，并在HTTP响应中发送，如下所示：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The client thinks the original URL is shortened, but in reality, the ID is mapped
    to a shorter string using the `base62` algorithm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端认为原始URL已被缩短，但实际上，ID是通过`base62`算法映射到一个更短的字符串。
- en: 'Now comes the `GET` operation. The `GetOriginalURL` function handler takes
    the shortened URL and converts it back to the original one. The logic is to convert
    a `base62` string (a shortened string) to a number and use that number to fetch
    records from the PostgreSQL database. We parse the input request and collect the
    `encoded_string` parameter. We use that to retrieve the original URL from the
    database. See the following code for the `GetOriginalURL` function handler:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`GET`操作。`GetOriginalURL`函数处理程序接收缩短的URL并将其转换回原始URL。逻辑是将`base62`字符串（缩短的字符串）转换为数字，并使用该数字从PostgreSQL数据库中检索记录。我们解析输入请求并收集`encoded_string`参数。我们使用它从数据库中检索原始URL。以下代码是`GetOriginalURL`函数处理程序：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `DBClient` struct is needed in order to pass the database driver between
    various functions. Run the program, like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBClient`结构体是必需的，以便在各个函数之间传递数据库驱动程序。运行程序，如下所示：'
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Another option is to install a binary. If your `$GOPATH/bin` is already in
    the system `PATH` variable, we can first install the binary and run it like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是安装一个二进制文件。如果你的`$GOPATH/bin`已经包含在系统`PATH`变量中，我们可以首先安装二进制文件并像这样运行它：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the binary name, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制文件名，如下所示：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It is a best practice to install the binary because it is available system-wide.
    But for smaller programs, we can run `main.go` from the directory of the program.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安装二进制文件是一个最佳实践，因为它在系统范围内可用。但对于较小的程序，我们可以从程序的目录中运行`main.go`。
- en: 'Now, it runs the HTTP server on port `8000` and starts collecting requests
    for the URL-shortening service. Open the console and type these `curl` commands:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它将在端口`8000`上运行HTTP服务器并开始收集URL缩短服务的请求。打开控制台并输入以下`curl`命令：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It returns the shortened string, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回缩短的字符串，如下所示：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The encoded string is just `"1"`. The `Base62` algorithm starts allocating
    shorter strings, starting from `"1"` up to a combination of alphanumeric letters.
    Now, if we need to retrieve the original URL, we can perform a `GET` request,
    like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的字符串只是`"1"`。`Base62`算法从`"1"`开始分配更短的字符串，直到一个由字母数字字符组合。现在，如果我们需要检索原始URL，我们可以执行一个`GET`请求，如下所示：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It returns the following JSON code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回以下JSON代码：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: So, the service can use this result to redirect the user to the original URL
    (site). Here, the generated string doesn't depend on the length of the URL because 
    the database ID is the only criterion for encoding.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该服务可以使用此结果将用户重定向到原始URL（网站）。在这里，生成的字符串不依赖于URL的长度，因为数据库ID是编码的唯一标准。
- en: The package imports in `urlshortener` are left out, for brevity. Please refer
    to the project code from the `chapter7` GitHub repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，省略了`urlshortener`包的导入。请参考`chapter7` GitHub仓库中的项目代码。
- en: The `RETURNING` keyword needs to be added to the `INSERT` SQL command in PostgreSQL
    to fetch the last inserted database ID. This is not the case with the MySQL or
    SQLite3 `INSERT INTO web_url( ) VALUES($1) RETURNING id, record.URL` query. This
    database query returns the last inserted record's ID. If we drop that `RETURNING` keyword,
    the query returns nothing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL中，需要在`INSERT` SQL命令中添加`RETURNING`关键字来获取最后插入的数据库ID。MySQL或SQLite3的`INSERT
    INTO web_url( ) VALUES($1) RETURNING id, record.URL`查询并非如此。此数据库查询返回最后插入记录的ID。如果我们删除那个`RETURNING`关键字，查询将返回空值。
- en: In the next section, we'll look at an important feature of PostgreSQL called
    JSONStore. PostgreSQL, unlike other relational databases, can allow JSON to be
    stored in the form of fields. It also provides a query language for JSON.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨PostgreSQL的一个重要特性，称为JSONStore。与其它关系型数据库不同，PostgreSQL允许以字段形式存储JSON。它还提供了一种用于JSON的查询语言。
- en: Exploring the JSONStore feature in PostgreSQL
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索PostgreSQL中的JSONStore特性
- en: '**PostgreSQL >9.2** has a prominent feature called JSONStore. PostgreSQL introduced
    two new data types for 9.2">storing JSON data. PostgreSQL allows users to insert
    JSON data as a `json` field or a `jsonb` field. It is quite useful for modeling
    real-world data that has to be more flexible in its structure. PostgreSQL draws
    on the best of both worlds by allowing us to store JSON strings as well as relational
    types.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**PostgreSQL >9.2**有一个名为JSONStore的显著特性。PostgreSQL为9.2版本引入了两种新的数据类型用于存储JSON数据。PostgreSQL允许用户将JSON数据作为`json`字段或`jsonb`字段插入。这对于需要更灵活结构的现实世界数据建模非常有用。PostgreSQL通过允许我们存储JSON字符串以及关系型数据类型，结合了两者的优点。'
- en: The main difference between `json` and `jsonb` is that the `json` field stores
    data as plaintext whereas `jsonb` stores that same data as a binary field. Each
    has its own benefits. For example, the `json` field commonly takes up less space
    than `jsonb` because it is a straightforward insert, but the `jsonb` field indexes
    JSON for better querying. You should choose the right field depending on whether
    the JSON document is fetched as a whole or queried on internal keys.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`和`jsonb`之间的主要区别在于，`json`字段以纯文本形式存储数据，而`jsonb`字段以二进制字段形式存储相同的数据。每个都有其自身的优点。例如，`json`字段通常比`jsonb`字段占用更少的空间，因为它是一个简单的插入操作，但`jsonb`字段对JSON进行了索引，以便更好地查询。您应根据JSON文档是整体获取还是基于内部键查询来选择合适的字段。'
- en: In this section, we will try to understand a few of the JSON models that we
    defined for the logistics use case in the previous chapter, but here, we'll use
    the `jsonb` field to store and retrieve items in PostgreSQL. For accessing PostgreSQL's
    JSONStore, the normal `pq` library is very tedious. So, in order to handle that
    better, we can use an **Object Relational Mapper** (**ORM**) called **Grails Object
    Relational Mapping** (**GORM**). In the next section, we will discuss this briefly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试理解之前章节中为物流用例定义的一些JSON模型，但在这里，我们将使用`jsonb`字段在PostgreSQL中存储和检索项目。为了更好地处理PostgreSQL的JSONStore，普通的`pq`库非常繁琐。因此，为了更好地处理，我们可以使用一个名为**Grails
    Object Relational Mapping**（GORM）的对象关系映射器（ORM）。在下一节中，我们将简要讨论这一点。
- en: Introducing GORM, a powerful ORM for Go
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍GORM，一个强大的Go语言ORM
- en: '**GORM** provides methods for all operations that can be done in the `database/sql` package.
    We can install GORM using the `dep` tool. In this section, we will look at with
    examples of how to insert, retrieve, and query PostgreSQL `JSON` using the `GORM`
    package.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**GORM**提供了在`database/sql`包中可以执行的所有操作的函数。我们可以使用`dep`工具安装GORM。在本节中，我们将通过示例展示如何使用`GORM`包插入、检索和查询PostgreSQL的`JSON`。'
- en: 'For the full documentation about this ORM, visit [http://jinzhu.me/gorm/](http://jinzhu.me/gorm/).
    Let''s write a program that implements the `Shipment` and `Package` types as JSON
    models. We''ll use the same models that we defined in the previous chapter for
    logistics. Let''s look at the steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 欲获取此ORM的完整文档，请访问[http://jinzhu.me/gorm/](http://jinzhu.me/gorm/)。让我们编写一个程序来实现`Shipment`和`Package`类型作为JSON模型。我们将使用之前章节中定义的相同模型进行物流。让我们看看步骤：
- en: 'Create a new directory called `jsonstore` in `$GOPATH/src/github.com/git-user/chapter7` and
    create the files, like this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`$GOPATH/src/github.com/git-user/chapter7`中创建一个名为`jsonstore`的新目录，并创建文件，如下所示：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Install all dependencies via `dep` in the `jsonstore` directory, like this:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`dep`在`jsonstore`目录下安装所有依赖，如下所示：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, edit the `helper.go` file to add `Shipment` and `Package` models. Every
    model (table) we create should be represented as a struct in `gorm`. That is the
    reason we created two structs: `Package` and `Shipment`. The first line should
    be `gorm.Model`. The other fields are the fields of the table. By default, an
    auto-increment ID will be created in the documents inserted into the database.
    See the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`helper.go`文件以添加`Shipment`和`Package`模型。我们创建的每个模型（表）都应该在`gorm`中以结构体的形式表示。这就是我们创建两个结构体的原因：`Package`和`Shipment`。第一行应该是`gorm.Model`。其他字段是表中的字段。默认情况下，将在数据库中插入的文档中创建一个自增ID。请参见以下代码：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you notice, in the preceding code block, `Data` is the `jsonb` field created
    for the `Shipment` and `Package` tables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，在前面的代码块中，`Data`是为`Shipment`和`Package`表创建的`jsonb`字段。
- en: 'After finishing the definitions of structs, we can write a table initialization
    logic that migrates these structs into tables in the PostgreSQL database. In order
    to do that, utilize the `Open` method from the GORM package to get the database
    connection. We can then run the `AutoMigrate` method with the structs we created
    previously, to save them to the database. See the following code for migration:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成结构体的定义后，我们可以编写一个表初始化逻辑，将这些结构体迁移到PostgreSQL数据库中的表。为了做到这一点，利用GORM包中的`Open`方法获取数据库连接。然后，我们可以使用之前创建的结构体运行`AutoMigrate`方法，将它们保存到数据库中。请参见以下迁移代码：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This `InitDB` logic looks similar to the logic we defined using the `pq` library.
    This helper file migrates the tables and returns the database connection back
    to whoever calls the `InitDB` function. In the next section, we'll leverage this
    connection to interact with the `Shipment` and `Package` tables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`InitDB`逻辑与使用`pq`库定义的逻辑相似。这个辅助文件迁移表并将数据库连接返回给调用`InitDB`函数的人。在下一节中，我们将利用这个连接与`Shipment`和`Package`表交互。
- en: Implementing the logistics REST API
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现物流REST API
- en: 'Before jumping in, let''s design the API specification table that shows the
    REST API signatures for various URL endpoints. Refer to the following table:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们设计一个API规范表，该表显示了各种URL端点的REST API签名。请参考以下表格：
- en: '| **Endpoint** | **Method** | **Description** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **端点** | **方法** | **描述** |'
- en: '| `/v1/shipment/id` | `GET` | Get a shipment from ID |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/shipment/id` | `GET` | 根据ID获取一个运输 |'
- en: '| `/v1/package/id` | `GET` | Get a package from ID |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/package/id` | `GET` | 根据ID获取一个包装 |'
- en: '| `/v1/package?weight=n` | `GET` | Get a package with a given weight in grams
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/package?weight=n` | `GET` | 获取给定重量的包装（以克为单位） |'
- en: '| `/v1/shipment` | `POST` | Create a new shipment |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/shipment` | `POST` | 创建一个新的运输 |'
- en: '| `/v1/package` | `POST` | Create a new package |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/package` | `POST` | 创建一个新的包装 |'
- en: 'To implement the preceding API, we need a main program that registers API routes
    to handler functions. Add one more file to our `jsonstore`project, like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现前面的API，我们需要一个主程序，该程序将API路由注册到处理函数。向我们的`jsonstore`项目添加一个额外的文件，如下所示：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this program, we will try to implement the `POST` and `GET` endpoints for
    `Package`. We suggest implementing the remaining two endpoints of `Shipment` as
    an assignment for the reader. Follow these steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将尝试实现`Package`的`POST`和`GET`端点。我们建议将`Shipment`的剩余两个端点作为读者的作业来实现。按照以下步骤操作：
- en: 'The program structure follows the same style as all the programs we have seen
    until now. We collect the database connection from the helper package and use
    it to create `DBClient`. We use `gorilla/mux` as our HTTP router and the `gorm`
    package for database operations. We should have these routes and handlers in our
    program, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序结构遵循我们迄今为止看到的程序相同的风格。我们从辅助包中收集数据库连接并使用它来创建`DBClient`。我们使用`gorilla/mux`作为我们的HTTP路由器，并使用`gorm`包进行数据库操作。我们应该在我们的程序中有以下路由和处理函数：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `POST` handler function saves a package object into the database. It returns
    an ID of the inserted record. The code for the `PostPackage` handler looks like
    this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST`处理函数将一个包装对象保存到数据库中。它返回插入记录的ID。`PostPackage`处理函数的代码如下：'
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This function is reading the `POST` body from the response and making an ORM
    function call to save the package data, like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数正在从响应中读取`POST`正文，并调用ORM函数来保存包装数据，如下所示：
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After saving the package successfully to the database, the preceding function
    is returning the ID as part of the response.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功将包装保存到数据库后，前面的函数将ID作为响应的一部分返回。
- en: 'Now, let''s write the code for the `GetPackage` handler function. It is similar
    to the preceding handler except that it uses a different database function. In
    this code, instead of reading the request body, we have to read the `PATH` variable
    and use that for querying data. See the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写 `GetPackage` 处理函数的代码。它与前面的处理函数类似，只是它使用了一个不同的数据库函数。在这段代码中，我们不是读取请求体，而是必须读取
    `PATH` 变量并使用它来查询数据。请参阅以下代码：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In this case, the query is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，查询如下所示：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now comes another `GET` operation. The `GetPackagebyWeight` handler function
    queries the database for a package with a given weight. Here, we use a JSON query
    on the `data` field. We use a special syntax of `column ->> field`, as shown in
    the following handler code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来进行另一个 `GET` 操作。`GetPackagebyWeight` 处理函数查询数据库以获取给定重量的包。在这里，我们对 `data` 字段使用
    JSON 查询。我们使用特殊的 `column ->> field` 语法，如下所示的处理代码：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are many other variations for querying JSON in PostgreSQL. You can find
    them here: [https://www.postgresql.org/docs/10/functions-json.html](https://www.postgresql.org/docs/10/functions-json.html).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中查询 JSON 的其他变体有很多。您可以在以下链接中找到它们：[https://www.postgresql.org/docs/10/functions-json.html](https://www.postgresql.org/docs/10/functions-json.html)。
- en: In the `GetPackagesbyWeight` handler function, we are making a raw query to
    the database by using the `db.Raw` method. It returns all packages as a list of
    those matching the weight criteria . For this `GET` API, the weight criteria list
    is being sent by the client as a query parameter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GetPackagesbyWeight` 处理函数中，我们通过使用 `db.Raw` 方法对数据库进行原始查询。它返回所有符合重量标准的包列表。对于这个
    `GET` API，重量标准列表是由客户端作为查询参数发送的。
- en: 'There are four important aspects in this JSONStore example, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 JSONStore 示例中，有四个重要的方面，如下所示：
- en: We replaced the traditional driver, `pq`, with the `GORM` driver.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将传统的驱动程序 `pq` 替换为了 `GORM` 驱动程序。
- en: We used GORM functions for CRUD operations.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了 GORM 函数进行 CRUD 操作。
- en: We inserted JSON into PostgreSQL and retrieved results.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 JSON 插入 PostgreSQL 并检索结果。
- en: We executed raw SQL and filtered fields on JSON.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们执行了原始 SQL 并对 JSON 字段进行了过滤。
- en: This completes the important logic for our program. Please refer to the `chapter7`
    repository for the complete code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们程序的重要逻辑。请参考 `chapter7` 仓库以获取完整的代码。
- en: 'Now, run the program using the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令运行程序：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It runs a Go server. Make a few `curl` commands to see the API response, as
    follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行一个 Go 服务器。执行几个 `curl` 命令以查看 API 响应，如下所示：
- en: 'Create the package (`POST`), as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包（`POST`），如下所示：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It returns the inserted record in the database, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回数据库中插入的记录，如下所示：
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we need to `GET` the details of the inserted package, as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要 `GET` 插入包的详细信息，如下所示：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It returns all the details about a package with `ID:1`, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回了 `ID:1` 的包的所有详细信息，如下所示：
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s test our second `GET` API, as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试我们的第二个 `GET` API，如下所示：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This returns all the packages with a weight of `10` gms, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了所有重量为 `10` 克的包，如下所示：
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The goal of this project is to show how JSON can be stored in and retrieved
    from PostgreSQL. This concludes our journey through PostgreSQL. There is a lot
    more to explore in PostgreSQL, but it is out of the scope of this book. PostgreSQL
    brings together the best of both worlds by allowing us to store relational as
    well as JSON data in the same table. It also allows us to query JSON data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的目标是展示如何将 JSON 存储在 PostgreSQL 中并从中检索。这标志着我们通过 PostgreSQL 的旅程结束。在 PostgreSQL
    中还有更多东西可以探索，但这超出了本书的范围。PostgreSQL 通过允许我们在同一张表中存储关系型数据以及 JSON 数据，将两者的优点结合在一起。它还允许我们查询
    JSON 数据。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started our journey by introducing PostgreSQL. We saw how
    to run PostgreSQL in Docker, and then listed out a few basic SQL queries for CRUD
    operations. We learned how to add new users and roles in PostgreSQL. We then discussed `pq`,
    a PostgreSQL driver package for Go, with an example.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过介绍 PostgreSQL 开始了我们的旅程。我们看到了如何在 Docker 中运行 PostgreSQL，并列出了一些基本的 SQL
    查询以进行 CRUD 操作。我们学习了如何在 PostgreSQL 中添加新用户和角色。然后，我们讨论了 `pq`，这是 Go 的 PostgreSQL 驱动程序包的一个示例。
- en: We designed a URL-shortening service using the Base62 algorithm. We leveraged
    `pq` and `gorilla/mux` for implementing that service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Base62 算法设计了一个 URL 缩短服务。我们利用 `pq` 和 `gorilla/mux` 来实现该服务。
- en: PostgreSQL also allows **JSON storage** (**JSONStore**) from version 9.2 onward.
    It allows developers to insert and retrieve JSON documents in a database. It combines
    the power of both relational and non-relational databases with JSONStore.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本9.2开始，PostgreSQL也允许**JSON存储**（**JSONStore**）。它允许开发者在数据库中插入和检索JSON文档。它结合了关系型和非关系型数据库的JSONStore功能。
- en: We also introduced GORM, a well-known ORM for Go. Using an ORM, database operations
    can be easily managed. GORM provides a few useful functions—such as `AutoMigrate` (creating
    a table if one doesn't exist)—for writing intuitive Go code over the traditional
    `database/sql` driver.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了GORM，这是Go中一个知名的ORM。使用ORM，可以轻松管理数据库操作。GORM提供了一些有用的函数——例如`AutoMigrate`（如果不存在则创建表）——以便在传统的`database/sql`驱动程序上编写直观的Go代码。
- en: Finally, we implemented a REST API for logistics using GORM. PostgreSQL is a
    well-established, open source relational database that can be a good storage backend
    for Go. With `pq` and `GORM`, driver support for Go is exceptional. The primary
    goal of this chapter was to make you feel comfortable working with PostgreSQL
    and Go for REST API development.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用GORM实现了物流的REST API。PostgreSQL是一个成熟的、开源的关系型数据库，可以成为Go的良好存储后端。本章的主要目标是让您在PostgreSQL和Go进行REST
    API开发时感到舒适。
- en: So far, we have looked at about building servers that provide REST APIs. Sometimes,
    developers need client-side tools to consume a REST API. It is also useful to
    understand how clients can consume a REST API to create a better API. In the next
    chapter, we will learn generally about how client software is built in Go. There,
    we also develop API clients for a GitHub REST API.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了构建提供REST API的服务器。有时，开发者需要客户端工具来消费REST API。了解客户端如何消费REST API以创建更好的API也是很有用的。在下一章中，我们将大致了解如何在Go中构建客户端软件。在那里，我们也为GitHub
    REST API开发了API客户端。
