- en: Building a REST API Client in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to discuss how Go client applications work in
    depth. We will explore `grequests`, a Python requests-style library that allows
    us to make API calls from the Go code. Then, we'll write some client software
    that uses the GitHub API. While doing that, we'll try to learn about two Go libraries
    called `cli` and `cobra`. After learning about the fundamentals of those packages,
    we'll write an API testing tool for the command line. Then, we'll introduce Redis,
    an in-memory database that we can use to cache the API responses to back up the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Plan for building a REST API client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics for writing a command-line tool in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grequests` – a REST API package for Go'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting comfortable with the GitHub REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cobra, an advanced CLI library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CLI tool as an API client for the GitHub REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Redis to cache the API data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software needs to be pre-installed so that you can run the code
    samples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OS: Linux(Ubuntu 18.04)/ Windows 10/Mac OS X >=10.13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go stable version compiler >= 1.13.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter8](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter8).
    Clone the code and use the code samples in the `chapter8` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Plan for building a REST API client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've mainly focused on writing server-side REST APIs. Basically, these
    are server programs. In a few cases, such as gRPC, we need a client. A client
    program takes input from the user and executes some logic. For developing a Go
    client, we should know about the `flag` library in Go. Before that, we should
    be aware of how to make requests for an API from a Go program. In the previous
    chapters, we used different clients such as cURL, Browser, Postman, and so on.
    But how can we turn a Go program into a client?
  prefs: []
  type: TYPE_NORMAL
- en: Command-line tools are equally important as web user interfaces to perform system
    tasks. In **business-to-business** (**B2B**) companies, the software is packaged
    as a single binary instead of having multiple different packages. As a Go developer,
    you should know how to achieve the goal of writing apps for the command line.
    Then, that knowledge can be invested in creating REST API-related web clients
    easily and elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore the basics of how we can write **command-line interface **(**CLI**)
    tools in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Basics for writing a command-line tool in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides a built-in library called `flag` for writing CLI tools. It refers
    to the command-line flags. Since it is already packed with the Go distribution,
    there is no need to install anything externally. The `flag` package has multiple
    functions, such as `Int` and `String`, to handle the respective type input that's
    supplied as a command-line flag. Let's suppose that we collect a name from the
    user and print it back to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can use the `flag.String` method, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a short program to illustrate the `flag` API in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `flagExample.go` in the `GOPATH`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `flag` package''s `String` method to receive a string from
    the command line as an option, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we are creating a flag called `name`. It is a string pointer.
    `flag.String` takes three arguments. The first argument is the name of the option.
    The second and third method arguments are the default values of that flag and
    the help text, respectively. We have asked the program to parse all the flag pointers
    in the main block.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the program, it maps the values supplied from the command-line options
    to the respective variables. To access the value of a flag in code, we use `*`,
    which is a pointer value reference; for example `*name` in the preceding code
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and then run the program using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This creates a binary in the `basic` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run it like a normal executable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, we didn't pass the `name` argument to the command.
    However, we did assign the default value to that argument. Go's flag takes the
    default value and proceeds further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to see what options are available and to find out about them,
    we need to ask for help, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is the reason why we passed the help text as the third argument for the
    flag command.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, `.exe` will be generated when we build a `.go` file. After that,
    from the command line, we can run the program by calling the program name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try to pass the `name` option with a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Both styles work fine and the output prints the supplied value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish to pass multiple options, modify the preceding program in the `basic`
    directory to add age, and call it `flagExampleMultipleParam.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes two options, with the addition of a different type. If we build
    and run this, we''ll see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using pointers, we can bind a variable to the parsed output. This
    binding is done through the `init()` function, which runs in a Go program, irrespective
    of whether the main function exists or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the value will be directly stored in the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Completely rewriting the preceding program to create a new one using the `init()`
    function can be seen in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`basic/initFlag.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output is exactly the same as it was for the preceding program. Here, instead
    of using pointers, we are able to load data directly into our variables.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, execution starts from the main program. However, a Go program can have
    any number of `init` functions. If a package has an `init` function in it, that
    will be executed before the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: This `flag` library is very basic to work with. However, in order to write advanced
    client applications, we need to take the help of a CLI package. In the next section,
    we'll explore a package called `cli` that will do just this.
  prefs: []
  type: TYPE_NORMAL
- en: CLI – a package for building beautiful clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cli` package is the next step for a Go developer after working with the
    `flag` package. It provides an intuitive API for creating command-line applications
    with ease. It allows a Go program to collect arguments and flags. It's quite handy
    for designing complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a directory for our example programs. For our basic CLI example,
    create the following directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the package, we use the `dep` tool. Initialize the tool first and
    then add the `cli` package as the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can write a program that does exactly the same job as the preceding
    flag example. Create a file called `example1/main.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cli` package provides three major elements:'
  prefs: []
  type: TYPE_NORMAL
- en: App
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apps** are used for defining namespaces in applications. A **flag** is an
    actual container that stores options passed. **Action** is a function that executes
    on collected options. Let''s look at the following example code for further insight.
    Here, we''re trying to use the `cli` API to create App, Flags, and Action. We
    have to import the package into our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is lengthier than the one we saw previously, but it is more expressive.
    Here, we created a new app using the `cli.NewApp` function. This creates a new
    struct. We need to attach parameters to this struct, specifically the `Flags`
    struct and the `Action` function. The `Flags` struct is a list that defines all
    possible flags for this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of `Flag` from GoDoc ([https://godoc.org/github.com/urfave/cli#Flag](https://godoc.org/github.com/urfave/cli#Flag))
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The inbuilt structs, such as `StringFlag` and `IntFlag`, implement this `Flag`
    interface. The `Name`, `Value`, and `Usage` fields are straightforward. They are
    similar to the ones we used in the `flag` package. The `Action` function takes
    the `cli.Context` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The context object holds any information regarding flags and command-line arguments.
    The `c.String`, `c.Int`, and other functions are used to look up the flag variables.
    For example, in the preceding program, `c.String("name")` fetches a flag variable
    whose name is `name`. This program runs the same as the previous flag example.
    You can build and run the program like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That's it regarding the basic usage of the `cli` package. This package also
    provides advanced combinations of flags and arguments. We'll look at this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting command-line arguments in the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In bash terminology, there is a difference between command-line arguments and
    flags. The following diagram clearly specifies the distinction between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df0a34bf-d4fc-4c65-a291-af487838555c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose that we have a command-line app called `storeMarks` for saving the
    marks of a student. It has a flag (called `save`) to specify whether details should
    be persisted or not. The arguments that are given are the name and actual marks
    of the student. We already saw how to collect the flag values in the program.
    In this section, we will learn how to collect program arguments in an expressive
    way. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For collecting arguments, we use the `c.Args` function, where `c` is the `cli`
    context of the `Action` function. Add a new directory called `example2` for our
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, create a program file called `example2/main.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the app in the main block `cli.NewApp` creates a new application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the flags on the `app.cli.Flag` takes a few predefined flags,
    such as integer flag or string flag. Here, we need a string flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to define actions on the app. Actions are the control structures
    that define the dynamics of logic upon given flags. These options are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--save=no`, which skips saving arguments to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--save=yes` (or) no flag, which saves arguments to the database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding statements will go into the main function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to run the app using `app.Run` to make the tool run and collect arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`c.Args` stores all the arguments supplied with the command. Since we know
    the order of the arguments, we deduced that the first argument is the name, and
    the remaining values are the marks. We are checking a flag called `save` to save
    those details in a database or not (we don''t have database logic here, for simplicity).
    `app.Version` sets the version of the tool. Everything else remains the same as
    the previous `cli` introductory example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s build the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from the `example2` directory, run the built tool by passing the flag
    and its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t give a flag, the default is `save=no`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, everything looks good. But how can we make the command-line tool display
    help text when a user needs it? The `cli` library creates a nice help section
    for the given app. If you type in any of these commands, some help text will be
    auto-generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./storeMarks -h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./storeMarks -help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./storeMarks --help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./storeMarks help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A nice help section appears, like the one shown in the following code, which
    shows version details and available flags (global options), commands, and arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `cli` package simplifies client application development. It is much faster
    and intuitive than the internal `flag` package.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line tools are binaries that are generated after building the program.
    They need to be run with the options. It is like any system program and not related
    to the Go compiler anymore. Make sure you build them for the target architecture
    where you want to run them.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `flag` package or `cli` to build a REST API client. However,
    for advanced applications, we might need a robust library with rich features.
    In the next section, we'll explore such a library called `cobra`, which is used
    to create command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: Cobra, an advanced CLI library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like `cli`, `cobra` is a package for writing client binaries but takes a different
    approach. In cobra, we have to create separate commands and use them in our main
    app. We can install `cobra` using dep. Let''s create our cobra project repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's create another directory called `cmd` in the project for defining
    commands. In cobra apps, there will be a root command. This can have multiple
    subcommands. We can implement the same example we used for the flag package. Input
    the name and age from the command line using cobra.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a root command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a command with "details" as a command. It has few properties,
    such as `Use`, `Short`, `Long`, `Args` and, `Run`. See the following table to
    find their exact meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `Use` | Name of the command |'
  prefs: []
  type: TYPE_TB
- en: '| `Short` | Short description |'
  prefs: []
  type: TYPE_TB
- en: '| `Long` | Long description |'
  prefs: []
  type: TYPE_TB
- en: '| `Args` | Number of arguments expected |'
  prefs: []
  type: TYPE_TB
- en: '| `Run` | Process inputs after collection |'
  prefs: []
  type: TYPE_TB
- en: 'In the `Run` command, we are expecting two arguments: `name` and `age`. However,
    in order to collect them, we have to define them. Where can we define them? Cobra
    asks the developer to define them in a special function called `Execute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use the previously defined root command to attach the flags. `PersistentFlags`
    has various types that can be used to collect flags. Now, create the main program
    and import this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in this file, you can import the command and call the `Execute` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. We have a client application that can be used to collect the name
    and age of the student. When we build this, it generates a binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run that binary as a client tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints a log to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass flags in a different order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can also create many subcommands on top of this command and do a lot more.
    This is just a basic example. We will look at an advanced example in the next
    section, where you will implement the same with cobra.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we'll discuss creating REST clients in Go. Before that,
    you should know how to make HTTP requests from a Go program. Although this is
    possible with Go's built-in `net/http` package, we need a more intuitive package.
    In the next section, we'll look at `grequests`, a similar package to Python's
    `Requests` for making HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: grequests a REST API package for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developers who worked on Python know about the `Requests` library. It is
    a clean, short library that is not included in the standard library of Python.
  prefs: []
  type: TYPE_NORMAL
- en: The Go `grequests` package is inspired by `Requests`. It provides a simple set
    of functions, using which we can make API requests such as `GET`, `POST`, `PUT`,
    and `DELETE` from our Go code. Using `grequests` allows us to encapsulate the
    in-built HTTP request and response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the project directory and install `grequests` using the `dep` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the `grequests` package for Go, run the following `dep` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a basic program illustrating the use of the `grequests` library
    to make a `GET` request to a REST API. It uses the `Get` method from the `grequests`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grequests` package contains methods for performing all REST actions. The
    preceding program uses the `Get` function from the package. It takes two function
    arguments. The first one is the URL of the API, while the second one is the request
    parameters object. Since we are not passing any request parameters, the second
    argument is `nil` here. `resp` is returned from the request, and it has a function
    called `String()` that returns the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the JSON response that''s returned by `httpbin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we understood how to use `grequests`. However, to leverage its power,
    we should be aware of its API (functions).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at the `grequests` library in more detail. We'll
    learn how request parameters and response properties are configured.
  prefs: []
  type: TYPE_NORMAL
- en: API overview of grequests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important thing to explore in `grequests` is not the HTTP functions,
    but the `RequestOptions` struct. It is a very big struct that holds various kinds
    of information regarding the type of API method being used. If the REST method
    is `GET`, `RequestOptions` holds the `Params` property. If the method is a `POST`,
    the struct will have a `Data` property. Whenever we make a request to a URL endpoint,
    we get a response back. Let''s look at the structure of the response. From the
    official documentation, the response looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `Ok` property of the response holds information about whether a request
    was successful or not. If something went wrong, an error will be found in the
    `Error` property. `RawResponse` is the Go HTTP response that will be used by other
    functions of the `grequests` response. `StatusCode` and `Header` store the status
    codes of the response and header details, respectively. There are a few functions
    in `Response` that are useful
  prefs: []
  type: TYPE_NORMAL
- en: '`Response.JSON()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Response.XML()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Response.String()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Response.Bytes()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data from the response can be filled into a generic map by the preceding
    functions. Let''s take a look at an example, that is `requestExample/jsonRequest.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declared an interface to hold the JSON values. Then, we populated `returnData`
    (empty interface) using the `resp.JSON` function. This program prints the map
    instead of plain JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out about all the available options by looking at the project
    documentation: [https://godoc.org/github.com/levigross/grequests](https://godoc.org/github.com/levigross/grequests).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll understand how GitHub API version 3 works and use
    our knowledge of command-line arguments to develop a client that fetches useful
    information from the GitHub API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting comfortable with the GitHub REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub provides a well-written, easy to consume REST API. It opens up the data
    about users, repositories, repository statistics, and so on to the clients through
    well-formed API. The current stable version is v3\. The API documentation can
    be found at [https://developer.github.com/v3/](https://developer.github.com/v3/).
    The root endpoint of the API is `https://api.github.com`.
  prefs: []
  type: TYPE_NORMAL
- en: All GitHub API routes will be appended to this root endpoint. Let's learn how
    to make a few queries and get data. For an unauthenticated client, the rate limit
    is 60/hour, whereas, for clients who are passing `client_id` (we can get it from
    their GitHub account console), it is 5,000/hour.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a GitHub account (if not, it is highly recommended that you create
    one), you can find the access tokens in the Your Profile | Personal Access Tokens
    section or by visiting [https://github.com/settings/tokens](https://github.com/settings/tokens).
    Create a new access token using the Generate new token button. You'll be asked
    for various permissions for different resources. Tick the `repo` and `gist` options.
    A new personal token string will be generated for you. Save it somewhere safe
    and private. The token that was generated can now be used to access the GitHub
    API (for a longer rate limit).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to export that access token as an environment variable, **`GITHUB_TOKEN`**.
    You can set it using the `export` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`YOUR_GITHUB_ACCESS_TOKEN` is what was generated and saved from the GitHub
    account. You can also add the preceding export command to your **`~/.bashrc`**
    file to make it persistent from the next shell launch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a program for fetching all the repositories of a user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory and program, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We should use this logic to make a `GET` request from a Go program. This program
    fetches repository information from the GitHub API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a struct that will hold the repository''s information. Let''s call it
    `Repo`. We will also define an environment variable that will fetch `GITHUB_TOKEN`.
    Now, we can create request options from that token. For GitHub to authenticate
    the origin of the `GET` request, we should pass an argument called `Auth` to the
    `RequestOptions` struct. This can be seen in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define a function handler that takes a URL as input and returns the GitHub
    API `Response`. It makes a simple GET request to the given URL location. We use
    the `grequests` package to make API calls to GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define the main block, which passes a GitHub link to the preceding function
    and stores the response in the `Repo` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`Response` consists of multiple repositories, so we have to load the response
    JSON into an array of `Repo`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding program, you will receive the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program illustrates how we can query the GitHub API and load that
    data into our custom struct called `Repo`. The JSON that's returned contains many
    fields, but for simplicity's sake, we are just picking a few important fields.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've seen how to make HTTP requests to the GitHub API. In the next
    section, we'll create a client that makes HTTP requests to the GitHub API based
    on user commands.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CLI tool as an API client for the GitHub REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After looking at this example, we''ll be able to easily access the GitHub API
    from our Go client. We can combine both of the techniques we''ve learned about
    in this chapter to come up with a command-line tool that consumes the GitHub API.
    Let''s create a new command-line application that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides options to get repository details by username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploads a file to GitHub gist (text snippets) with a given description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticates using a personal access token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use the `cli` package and `grequests` to build this tool. You can re-implement
    the same example in cobra too.
  prefs: []
  type: TYPE_NORMAL
- en: Gist are snippets provided by GitHub that store text content. For more details,
    visit [https://gist.github.com](https://gist.github.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory called `gitTool` in this chapter''s directory and add the
    `main` file to it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s define the main block with a few `cli` commands so that we can
    input commands for repository details and gist upload actions. Here, we''re using
    `app` from the `cli` package and creating `Commands`. We''re defining two commands
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `getStats` and `createGist` are the functions that are used
    for actual API calls. We''ll define these next, but, before we do, we should prepare
    a few data structures that hold information about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file to upload as a gist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gist on GitHub (list of files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we need to create three structs that hold the preceding information, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a request option that builds a header and uses GitHub tokens from
    environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to write the `getStats` and `createGist` functions. Let''s
    code `getStats` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This function makes a `GET` request and returns the response object. The code
    is simple and is a generic GET request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at `createGist`. Here, we have to do more. A gist contains
    multiple files. Due to this, we need to do the following in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of files from command-line arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the file content and store it in a map of files with the filename as the
    key and content as the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert this map into JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a `POST` request to the Gist API with the preceding JSON as the body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have to make a `POST` request to the Gist API. The `createGist` function
    takes a URL string and other arguments. The function should return the response
    of the `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using `grequests.Post` to pass files to GitHub''s Gist API. It returns
    `Status: 201 Created` on successful creation with gist details in the response
    body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build the command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a binary in the same directory. If we type in `./gitTool -h`,
    it shows us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look at the help commands, you''ll see two commands, `fetch`
    and `create`. The `fetch` command fetches the repositories of a given user, while
    the `create` command creates a `gist` with the supplied files. Let''s create two
    sample files in the same directory of the program to test the `create` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tool with the first command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns all the repositories that belong to the great Linus Torvalds.
    The log message prints the struct that was filled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check the second command. This creates the `gist` with the given
    description and a set of files as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns JSON details about the created gist. It is a very lengthy JSON,
    so the output has been skipped here. Now, if you open your [gist.github.com](https://gist.github.com/)
    account, you will see the created `gist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba9cac57-bc13-4037-b122-ed603ce99890.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Remember, the GitHub `gists` API expects JSON data as a body in the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: For any Go program to read and comprehend quickly, follow the `main` function
    and then step into the other functions. By doing this, we can read the code from
    the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, build a command-line tool for the preceding requirements in
    `cobra`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis to cache the API data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Redis** is an in-memory database that can store key/value pairs. It best
    suits the use case of storing heavy read-intensive data. For example, news agencies
    such as the BBC and The Guardian show the latest news articles on their dashboard.
    Their traffic is high and, if documents are to be fetched from the database, they
    have to maintain a huge cluster of databases at all times.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the given set of news articles does not change (for hours), an agency
    can maintain a cache of articles. When the first customer visits the page, a copy
    is pulled from the DB, placed in the Redis cache, and then sent to the browser.
    Then, for another customer, the news agency server reads content from Redis instead
    of hitting the DB. Since Redis runs in the primary memory, latency is minimal.
    As a result, the customer sees faster page loads. The benchmarks on the web can
    tell us more about how efficiently a site can optimize its contents.
  prefs: []
  type: TYPE_NORMAL
- en: What if data is no longer relevant in Redis? (For example, the agency updated
    its top stories.) Redis provides a way to expire the `keys:values` stored in it.
    We can run a scheduler that updates Redis whenever the expiration time has passed.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can cache the third-party API responses for the given request
    (`GET`). We need to do this because third-party systems such as GitHub have a
    rate limit (telling us to be conservative). For a given `GET URL`, we can store
    the `URL` as a key and the `Response` as a value. Whenever the same request is
    given within the next time (before key expiration), just pull the response out
    of Redis instead of hitting the GitHub servers.
  prefs: []
  type: TYPE_NORMAL
- en: This method is applicable to our REST API, too. The most frequent and unchanged
    REST API responses can be cached in order to reduce the load on the primary database.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a wonderful library available for Go that can talk to Redis. It can
    be found at [https://github.com/go-redis/redis](https://github.com/go-redis/redis).
    It is a well-known library that many developers recommend. The following diagram
    illustrates this concept very well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fd94758-390c-4550-a156-ec17f046aa32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One caveat here is the expiration of the API. A real-time API should not be
    cached because of its dynamic nature. Caching brings performance optimization
    to our plate, as well as a few headaches regarding data syncing.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful while caching. Always implement a robust cache-busting method. There
    are many better practices available globally. Please go through them to get an
    understanding of the various architectures.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss Redis in more detail in the next chapter, where we'll discuss
    strategies that can be used to develop asynchronous APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We started this chapter with understanding client software: how a software
    client works and how we can create a few. We saw the basics of writing a command-line
    application. `cli` is a third-party package that allows us to create beautiful
    command-line applications. After installing it, we learned how to collect command-line
    arguments through the tool. We also explored commands and flags in our CLI application.
    Next, we looked into `grequest``s`, a package similar to Python requests that''s
    used to make API requests from Go code. We learned how to make `GET`, `POST`,
    and other requests from the client programs. We looked at a fresh package called
    `cobra` for creating commands/sub-commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we explored the GitHub API and how to fetch details about repositories.
    With the knowledge of both concepts, we developed a client that lists the repositories
    for a given user and also creates a `gist` (a set of text snippets on GitHub).
    Finally, we introduced the Redis architecture and how caching can help us handle
    the rate-limited API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss strategies for building asynchronous APIs
    with the help of queuing and caching.
  prefs: []
  type: TYPE_NORMAL
