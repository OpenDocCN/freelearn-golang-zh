["```go\ndocker run --hostname rabbitmq-host --name rabbitmq-server -p 5672:5672 -p 15672:15672 rabbitmq:3\n```", "```go\n Starting broker...\n2019-08-10 08:19:20.371 [info] <0.223.0>\n node           : rabbit@rabbitmq-host\n home dir       : /var/lib/rabbitmq\n config file(s) : /etc/rabbitmq/rabbitmq.conf\n cookie hash    : tUgaG2zTrSrf/yZv3KRV5Q==\n log(s)         : <stdout>\n database dir   : /var/lib/rabbitmq/mnesia/rabbit@rabbitmq-host\n\n....\n2019-08-10 08:19:20.873 [info] <0.497.0> started TCP listener on [::]:5672\n```", "```go\nmkdir -p $GOPATH/src/github.com/git-user/chapter9/basicSender\n```", "```go\ndep ensure --add \"github.com/streadway/amqp\"\n```", "```go\npackage main\n\nimport (\n    \"log\"\n\n    \"github.com/streadway/amqp\"\n)\n```", "```go\nfunc handleError(err error, msg string) {\n    if err != nil {\n        log.Fatalf(\"%s: %s\", msg, err)\n    }\n}\n```", "```go\nfunc main() {\n    conn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n    handleError(err, \"Dialing failed to RabbitMQ broker\")\n    defer conn.Close()\n\n    channel, err := conn.Channel()\n    handleError(err, \"Fetching channel failed\")\n    defer channel.Close()\n}\n```", "```go\namqp://guest:guest@localhost:5672/\n```", "```go\ntestQueue, err := channel.QueueDeclare(\n    \"test\", // Name of the queue\n    false,  // Message is persisted or not\n    false,  // Delete message when unused\n    false,  // Exclusive\n    false,  // No Waiting time\n    nil,    // Extra args\n)\n\nhandleError(err, \"Queue creation failed\")\n```", "```go\nserverTime := time.Now()\nmessage := amqp.Publishing{\n    ContentType: \"text/plain\",\n    Body:        []byte(serverTime.String()),\n}\n```", "```go\nerr = channel.Publish(\n    \"\",             // exchange\n    testQueue.Name, // routing key(Queue)\n    false,          // mandatory\n    false,          // immediate\n    message,\n)\n\nhandleError(err, \"Failed to publish a message\")\nlog.Println(\"Successfully published a message to the queue\")\n```", "```go\nmkdir -p $GOPATH/src/github.com/git-user/chapter9/basicReceiver touch $GOPATH/src/github.com/git-user/chapter9/basicReceiver/\nmain.go\n```", "```go\npackage main\n\nimport (\n    \"log\"\n\n    \"github.com/streadway/amqp\"\n)\n\nfunc handleError(err error, msg string) {\n    if err != nil {\n        log.Fatalf(\"%s: %s\", msg, err)\n    }\n}\n\nfunc main() {\n    conn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n    handleError(err, \"Dialing failed to RabbitMQ broker\")\n    defer conn.Close()\n\n    channel, err := conn.Channel()\n    handleError(err, \"Fetching channel failed\")\n    defer channel.Close()\n\n    testQueue, err := channel.QueueDeclare(\n        \"test\", // Name of the queue\n        false,  // Message is persisted or not\n        false,  // Delete message when unused\n        false,  // Exclusive\n        false,  // No Waiting time\n        nil,    // Extra args\n    )\n\n    handleError(err, \"Queue creation failed\")\n\n}\n```", "```go\nmessages, err := channel.Consume(\n    testQueue.Name, // queue\n    \"\",             // consumer\n    true,           // auto-acknowledge\n    false,          // exclusive\n    false,          // no-local\n    false,          // no-wait\n    nil,            // args\n)\n\nhandleError(err, \"Failed to register a consumer\")\n```", "```go\ngo func() {\n    for message := range messages {\n        log.Printf(\"Received a message from the queue: %s\",\n         message.Body)\n    }\n}()\n```", "```go\nlog.Println(\"Worker has started\")\nwait := make(chan bool)\n<-wait\n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter9/basicReceiver/\nmain.go\n2019/08/10 16:02:29 Worker has started \n```", "```go\ngo run $GOPATH/src/github.com/git-user/chapter9/basicSender/\nmain.go\n2019/08/10 16:03:15 Successfully published a message to the queue \n```", "```go\n2019/08/10 16:03:15 Received a message from the queue: 2019-08-10 16:03:15.367476 +0200 CEST m=+0.014980319\n```", "```go\nmkdir -p $GOPATH/src/github.com/git-user/chapter9/longRunningTaskV1\n```", "```go\nmkdir -p $GOPATH/src/github.com/git-user/chapter9/longRunningTaskV1\n/models touch $GOPATH/src/github.com/git-user/chapter9/longRunningTaskV1\n/models/job.go \n```", "```go\npackage models\n\nimport (\n    \"time\"\n\n    \"github.com/google/uuid\"\n)\n\n// Job represents UUID of a Job\ntype Job struct {\n    ID      uuid.UUID   `json:\"uuid\"`\n    Type      string      `json:\"type\"`\n    ExtraData interface{} `json:\"extra_data\"`\n}\n\n// Worker-A data\ntype Log struct {\n    ClientTime time.Time `json:\"client_time\"`\n}\n\n// CallBack data\ntype CallBack struct {\n    CallBackURL string `json:\"callback_url\"`\n}\n\n// Mail data\ntype Mail struct {\n    EmailAddress string `json:\"email_address\"`\n}\n```", "```go\n    ExtraData interface{} `json:\"extra_data\"`\n```", "```go\ntouch $GOPATH/src/github.com/git-user/chapter9/longRunningTaskV1\n/main.go\n```", "```go\nconst queueName string = \"jobQueue\"\nconst hostString string = \"127.0.0.1:8000\"\n\nfunc handleError(err error, msg string) {\n    if err != nil {\n        log.Fatalf(\"%s: %s\", msg, err)\n    }\n}\n```", "```go\ntouch $GOPATH/src/github.com/git-user/chapter9/longRunningTaskV1\n/worker.go\n```", "```go\ntype Workers struct {\n    conn *amqp.Connection\n}\n```", "```go\nfunc (w *Workers) run() {\n    log.Printf(\"Workers are booted up and running\")\n    channel, err := w.conn.Channel()\n    handleError(err, \"Fetching channel failed\")\n    defer channel.Close()\n\n    jobQueue, err := channel.QueueDeclare(\n        queueName, // Name of the queue\n        false,     // Message is persisted or not\n        false,     // Delete message when unused\n        false,     // Exclusive\n        false,     // No Waiting time\n        nil,       // Extra args\n    )\n    handleError(err, \"Job queue fetch failed\")\n\n    messages, err := channel.Consume(\n        jobQueue.Name, // queue\n        \"\",            // consumer\n        true,          // auto-acknowledge\n        false,         // exclusive\n        false,         // no-local\n        false,         // no-wait\n        nil,           // args\n    )\n    go func() {\n        for message := range messages {\n\n            job := models.Job{}\n            err = json.Unmarshal(message.Body, &job)\n\n            log.Printf(\"Workers received a message from the queue:\n             %s\", job)\n            handleError(err, \"Unable to load queue message\")\n\n            switch job.Type {\n            case \"A\":\n                w.dbWork(job)\n            case \"B\":\n                w.callbackWork(job)\n            case \"C\":\n                w.emailWork(job)\n            }\n        }\n    }()\n    defer w.conn.Close()\n    wait := make(chan bool)\n    <-wait // Run long-running worker\n}\n```", "```go\n\nfunc (w *Workers) dbWork(job models.Job) {\n    result := job.ExtraData.(map[string]interface{})\n    log.Printf(\"Worker %s: extracting data..., JOB: %s\",\n     job.Type, result)\n    time.Sleep(2 * time.Second)\n    log.Printf(\"Worker %s: saving data to database...,\n     JOB: %s\", job.Type, job.ID)\n}\n\nfunc (w *Workers) callbackWork(job models.Job) {\n    log.Printf(\"Worker %s: performing some long running process...,\n     JOB: %s\", job.Type, job.ID)\n    time.Sleep(10 * time.Second)\n    log.Printf(\"Worker %s: posting the data back to the given\n     callback..., JOB: %s\", job.Type, job.ID)\n}\n\nfunc (w *Workers) emailWork(job models.Job) {\n    log.Printf(\"Worker %s: sending the email..., JOB: %s\",\n     job.Type, job.ID)\n    time.Sleep(2 * time.Second)\n    log.Printf(\"Worker %s: sent the email successfully,\n     JOB: %s\", job.Type, job.ID)\n}\n```", "```go\ntouch $GOPATH/src/github.com/git-user/chapter9/longRunningTaskV1\n/handlers.go\n```", "```go\n// JobServer holds handler functions\ntype JobServer struct {\n    Queue   amqp.Queue\n    Channel *amqp.Channel\n    Conn    *amqp.Connection\n}\n```", "```go\nfunc (s *JobServer) publish(jsonBody []byte) error {\n    message := amqp.Publishing{\n        ContentType: \"application/json\",\n        Body:        jsonBody,\n    }\n    err := s.Channel.Publish(\n        \"\",        // exchange\n        queueName, // routing key(Queue)\n        false,     // mandatory\n        false,     // immediate\n        message,\n    )\n\n    handleError(err, \"Error while generating JobID\")\n    return err\n}\n```", "```go\nfunc (s *JobServer) asyncDBHandler(w http.ResponseWriter,\nr *http.Request) {\n    jobID, err := uuid.NewRandom()\n    queryParams := r.URL.Query()\n    // Ex: client_time: 1569174071\n    unixTime, err := strconv.ParseInt(queryParams.Get(\"client_time\"),\n     10, 64)\n    clientTime := time.Unix(unixTime, 0)\n    handleError(err, \"Error while converting client time\")\n\n    jsonBody, err := json.Marshal(models.Job{ID: jobID,\n        Type:      \"A\",\n        ExtraData: models.Log{ClientTime: clientTime},\n    })\n    handleError(err, \"JSON body creation failed\")\n\n    if s.publish(jsonBody) == nil {\n        w.WriteHeader(http.StatusOK)\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.Write(jsonBody)\n    } else {\n        w.WriteHeader(http.StatusInternalServerError)\n    }\n}\n```", "```go\n    jsonBody, err := json.Marshal(models.Job{ID: jobID,\n        Type:      \"B\",\n        ExtraData: \"\", // Can be custom data, Ex: {\"client_time\":\n                       // \"2020-01-22T20:38:15+02:00\"}\n })\n```", "```go\n    jsonBody, err := json.Marshal(models.Job{ID: jobID,\n        Type:      \"C\",\n        ExtraData: \"\", // Can be custom data, Ex: {\"email_address\":\n                       // \"packt@example.org\"}\n })\n```", "```go\nfunc getServer(name string) JobServer {\n    /*\n        Creates a server object and initiates\n        the Channel and Queue details to publish messages\n    */\n    conn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n    handleError(err, \"Dialing failed to RabbitMQ broker\")\n\n    channel, err := conn.Channel()\n    handleError(err, \"Fetching channel failed\")\n\n    jobQueue, err := channel.QueueDeclare(\n        name,  // Name of the queue\n        false, // Message is persisted or not\n        false, // Delete message when unused\n        false, // Exclusive\n        false, // No Waiting time\n        nil,   // Extra args\n    )\n    handleError(err, \"Job queue creation failed\")\n    return JobServer{Conn: conn, Channel: channel, Queue: jobQueue}\n}\n```", "```go\nfunc main() {\n    jobServer := getServer(queueName)\n\n    // Rest of the code goes here....\n}\n```", "```go\n// Start Workers\ngo func(conn *amqp.Connection) {\n    workerProcess := Workers{\n        conn: jobServer.Conn,\n    }\n    workerProcess.run()\n}(jobServer.Conn)\n```", "```go\nrouter := mux.NewRouter()\n// Attach handlers\nrouter.HandleFunc(\"/job/database\", jobServer.asyncDBHandler)\nrouter.HandleFunc(\"/job/mail\", jobServer.asyncMailHandler)\nrouter.HandleFunc(\"/job/callback\", jobServer.asyncCallbackHandler)\n\nhttpServer := &http.Server{\n    Handler:      router,\n    Addr:         hostString,\n    WriteTimeout: 15 * time.Second,\n    ReadTimeout:  15 * time.Second,\n}\n\n// Run HTTP server\nlog.Fatal(httpServer.ListenAndServe())\n```", "```go\n// Cleanup resources\ndefer jobServer.Channel.Close()\ndefer jobServer.Conn.Close()\n```", "```go\ngo build .\n```", "```go\n./longRunningTaskV1\n2019/09/22 20:36:06 Workers are booted up and running\n```", "```go\n> curl -X GET http://localhost:8000/job/database\\?client_time\\=1569177495\n{\"uuid\":\"9dfbc374-a046-4b29-b6f8-5414a277aaa2\",\"type\":\"A\",\"extra_data\":{\"client_time\":\"2019-09-22T20:38:15+02:00\"}}\n\n> curl -X GET http://localhost:8000/job/callback\n{\"uuid\":\"ac297c92-74ec-4fcb-b3e6-6dfb96eb45e0\",\"type\":\"B\",\"extra_data\":\"\"}\n\n> curl -X GET http://localhost:8000/job/mail\n{\"uuid\":\"4ed59a6f-24d8-4179-8432-fe4adcdd4f51\",\"type\":\"C\",\"extra_data\":\"\"}\n```", "```go\n2019/09/22 20:39:56 Workers received a message from the queue: {9dfbc374-a046-4b29-b6f8-5414a277aaa2 A map[client_time:2019-09-22T20:38:15+02:00]}\n2019/09/22 20:39:56 Worker A: extracting data..., JOB: map[client_time:2019-09-22T20:38:15+02:00]\n2019/09/22 20:39:58 Worker A: saving data to database..., JOB: 9dfbc374-a046-4b29-b6f8-5414a277aaa2\n2019/09/22 20:40:29 Workers received a message from the queue: {ac297c92-74ec-4fcb-b3e6-6dfb96eb45e0 B }\n2019/09/22 20:40:29 Worker B: performing some long running process..., JOB: ac297c92-74ec-4fcb-b3e6-6dfb96eb45e0\n2019/09/22 20:40:39 Worker B: posting the data back to the given callback..., JOB: ac297c92-74ec-4fcb-b3e6-6dfb96eb45e0\n2019/09/22 20:40:39 Workers received a message from the queue: {4ed59a6f-24d8-4179-8432-fe4adcdd4f51 C }\n2019/09/22 20:40:39 Worker C: sending the email..., JOB: 4ed59a6f-24d8-4179-8432-fe4adcdd4f51\n2019/09/22 20:40:41 Worker C: sent the email successfully, JOB: 4ed59a6f-24d8-4179-8432-fe4adcdd4f51\n```", "```go\n{ '4ed59a6f-24d8-4179-8432-fe4adcdd4f51': 'In Progress'\n```", "```go\n> docker run --name some-redis -p 6379:6379 -d redis\n```", "```go\n> docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                             NAMES\n2f0b2b457ed7        redis               \"docker-entrypoint.s…\"   8 minutes ago       Up 8 minutes        0.0.0.0:6379->6379/tcp                                                            some-redis\nc3b2a0a0295d        rabbitmq:3          \"docker-entrypoint.s…\"   6 weeks ago         Up 11 hours         4369/tcp, 0.0.0.0:5672->5672/tcp, 5671/tcp, 25672/tcp, 0.0.0.0:15672->15672/tcp   rabbitmq-server\n```", "```go\n> docker exec -i -t some-redis redis-cli\n127.0.0.1:6379>\n```", "```go\n 127.0.0.1:6379> KEYS *\n```", "```go\n127.0.0.1:6379> SET topic async\nOK\n```", "```go\nmkdir -p $GOPATH/src/github.com/git-user/chapter9/redisIntro\n```", "```go\ndep init\ndep ensure --add \"github.com/go-redis/redis\"\n```", "```go\ntouch $GOPATH/src/github.com/git-user/chapter9/redisIntro/main.go\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/go-redis/redis\"\n)\n\nfunc main() {\n    client := redis.NewClient(&redis.Options{\n        Addr:     \"localhost:6379\",\n        Password: \"\", // no password set\n        DB:       0,  // use default DB\n    })\n\n    pong, _ := client.Ping().Result() // Ignoring error\n    fmt.Println(pong)\n}\n```", "```go\n> go run $GOPATH/src/github.com/git-user/chapter9/redisIntro/\nmain.go\nPONG\n```", "```go\ndep ensure\n```", "```go\ndep ensure --add github.com/go-redis/redis\n```", "```go\nvi $GOPATH/src/github.com/git-user/chapter9/longRunningTaskV2\n/handlers.go\n```", "```go\nimport (\n    ...\n    \"github.com/go-redis/redis\"\n)\n\n// JobServer holds handler functions\ntype JobServer struct {\n    Queue       amqp.Queue\n    Channel     *amqp.Channel\n    Conn        *amqp.Connection\n    redisClient *redis.Client\n}\n```", "```go\n...\nfunc (s *JobServer) statusHandler(w http.ResponseWriter,\nr *http.Request) {\n    queryParams := r.URL.Query()\n    // fetch UUID from query\n    uuid := queryParams.Get(\"uuid\")\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    jobStatus := s.redisClient.Get(uuid)\n    status := map[string]string{\"uuid\": uuid, \"status\":\n     jobStatus.Val()}\n    response, err := json.Marshal(status)\n    handleError(err, \"Cannot create response for client\")\n    w.Write(response)\n}\n```", "```go\n\nimport (\n    ...\n    \"github.com/go-redis/redis\" // Add redis import\n)\n\nfunc main() {\n    jobServer := getServer(queueName)\n\n    // Create a client and attach to job server\n    jobServer.redisClient = redis.NewClient(&redis.Options{\n        Addr:     \"localhost:6379\",\n        Password: \"\", // no password set\n        DB:       0,  // use default DB\n    })\n\n    ...\n    router := mux.NewRouter()\n    // Attach handlers\n    router.HandleFunc(\"/job/database\", jobServer.asyncDBHandler)\n    router.HandleFunc(\"/job/mail\", jobServer.asyncMailHandler)\n    router.HandleFunc(\"/job/callback\",\n     jobServer.asyncCallbackHandler)\n\n    // Add a new route here\n    router.HandleFunc(\"/job/status\", jobServer.statusHandler)\n}\n```", "```go\nvi $GOPATH/src/github.com/git-user/chapter9/longRunningTaskV2\n/worker.go\n```", "```go\nimport (\n    ...\n    \"github.com/go-redis/redis\"\n}\n```", "```go\n// Workers do the job. It holds connections\n\ntype Workers struct {\n    conn        *amqp.Connection\n    redisClient *redis.Client\n}\n```", "```go\nfunc (w *Workers) run() {\n    ...\n    // Create a new connection\n    w.redisClient = redis.NewClient(&redis.Options{\n        Addr:     \"localhost:6379\",\n        Password: \"\", // no password set\n        DB:       0,  // use default DB\n    })\n    ...\n}\n```", "```go\n...\nfunc (w *Workers) dbWork(job models.Job) {\n    result := job.ExtraData.(map[string]interface{})\n    w.redisClient.Set(job.ID.String(), \"STARTED\", 0)\n    log.Printf(\"Worker %s: extracting data..., JOB: %s\",\n     job.Type, result)\n    w.redisClient.Set(job.ID.String(), \"IN PROGRESS\", 0)\n    time.Sleep(2 * time.Second)\n    log.Printf(\"Worker %s: saving data to database..., JOB: %s\",\n     job.Type, job.ID)\n    w.redisClient.Set(job.ID.String(), \"DONE\", 0)\n}\n...\n```", "```go\ngo build .\n\n./longRunningTaskV2\n```", "```go\ncurl -X GET http://localhost:8000/job/database\\?client_time\\=1569177495\n```", "```go\n{\"uuid\":\"07050695-ce75-4ae8-99d3-2ab068cafe9d\",\"type\":\"A\",\"extra_data\":{\"client_time\":\"2019-09-23T00:08:15+05:30\"}}\n```", "```go\ncurl -X GET http://localhost:8000/job/status\\?uuid\\=07050695-ce75-4ae8-99d3-2ab068cafe9d\n```", "```go\n{\"uuid\":\"07050695-ce75-4ae8-99d3-2ab068cafe9d\",\"status\":\"DONE\"}\n```"]