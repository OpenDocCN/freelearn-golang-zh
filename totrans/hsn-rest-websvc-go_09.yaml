- en: Asynchronous API Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步API设计
- en: In this chapter, we are going to discuss how to design an asynchronous API for
    clients. We will look into strategies such as queuing tasks and publish/subscribe
    paradigms. A synchronous request waits on the server to compute the result. On
    the other hand, an **asynchronous **(**async**) request receives a response immediately
    with the information about the eventual result. The real world is composed of
    many synchronous and asynchronous events.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何为客户设计异步API。我们将探讨如队列任务和发布/订阅模式等策略。同步请求会在服务器上等待直到返回结果。另一方面，异步（**asynchronous**）请求会立即收到一个包含最终结果信息的响应。现实世界由许多同步和异步事件组成。
- en: Asynchronous events are very popular in browsers. An async API mimics the same
    behavior as an event loop in modern browsers. In this chapter, we'll look at the
    difference between the request types. We'll also write a few clients in Go that
    can consume an asynchronous API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异步事件在浏览器中非常流行。异步API模仿了现代浏览器中事件循环的行为。在本章中，我们将查看请求类型之间的差异。我们还将用Go编写一些客户端，以消费异步API。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding sync/async API requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解同步/异步API请求
- en: Fan-in/fan-out of services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的扇入/扇出
- en: Delaying API jobs with queuing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列延迟API作业
- en: Long-running task design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长运行任务设计
- en: Caching strategies for APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的缓存策略
- en: Event-driven API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动API
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need to install the following software to run the code samples in
    this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装以下软件来运行本章的代码示例：
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13
- en: Go stable version compiler >= 1.13.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go稳定版本编译器 >= 1.13.5
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dep: Go >= 0.5.3的依赖管理工具'
- en: Docker version >= 18.09.2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker版本 >= 18.09.2
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter9](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter9).
    Clone the code and use the code samples in the `chapter9` directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter9](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter9)下载本章的代码。克隆代码并使用`chapter9`目录中的代码示例。
- en: Understanding sync/async API requests
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解同步/异步API请求
- en: 'A synchronous request is an HTTP request that blocks the server until the response
    is returned. The majority of the services on the web run in this fashion. Nowadays,
    with the advent of distributed systems and loose coupling, API requests can also
    be asynchronous. In other words, an asynchronous request returns with information
    that can be used to fetch the information of a process. These asynchronous requests
    on a server are closely related to how concurrently the server can execute a job
    for multiple clients. Let''s look at what a synchronous request looks like:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同步请求是一个会阻塞服务器直到返回响应的HTTP请求。大多数网络服务都是以这种方式运行的。如今，随着分布式系统和松耦合的出现，API请求也可以是异步的。换句话说，异步请求返回的信息可以用来获取进程的信息。这些服务器上的异步请求与服务器如何并发地为多个客户端执行作业密切相关。让我们看看同步请求的样子：
- en: '![](img/6ed7e24a-abe2-45fb-b25c-a4716b31faaf.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ed7e24a-abe2-45fb-b25c-a4716b31faaf.png)'
- en: In this type of request, the web server performs all the actions and returns
    an **Immediate Response** to the **Web client**/**Mobile client**. The drawback
    of this approach is that if the server takes too much time to render the result,
    the client is blocked on the server's action.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类请求中，Web服务器执行所有操作并返回一个**即时响应**给**Web客户端**/**移动客户端**。这种方法的缺点是，如果服务器渲染结果花费太多时间，客户端会被阻塞在服务器的操作上。
- en: 'An asynchronous request instantly returns a response but not with the result.
    It issues a ticket for finding the status of the requested operation. A client
    can use that ticket (a different response) to check the status and the final result
    of the operation:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 异步请求会立即返回一个响应，但不包含结果。它为查找请求操作的状态发出一个票据。客户端可以使用该票据（不同的响应）来检查操作的状态和最终结果：
- en: '![](img/841cf354-4327-437d-987d-36d99bca8471.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/841cf354-4327-437d-987d-36d99bca8471.png)'
- en: As shown in the preceding diagram, the client is sending a request to the server
    and the server returns a response to the client. This response is not something
    the client can consume instantly. Long-running tasks/jobs can be made asynchronous
    by the server. The client can then use the received response to find out the status
    of the job. Once the job is done, either the server can notify the client or the
    client can poll the result by looking at the status. So far, we have only built
    a synchronous API. This chapter will discuss its implementation in detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，客户端正在向服务器发送请求，服务器向客户端返回响应。这个响应不是客户端可以立即消费的东西。长时间运行的任务/作业可以通过服务器异步执行。然后，客户端可以使用收到的响应来了解作业的状态。一旦作业完成，服务器可以通知客户端，或者客户端可以通过查看状态来轮询结果。到目前为止，我们只构建了一个同步API。本章将详细讨论其实现。
- en: In the next section, we'll discuss how APIs can diverge into multiple or submerge
    into a single call. These techniques are called fan-out and fan-in, respectively.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论API如何分化成多个或合并成一个调用。这些技术分别称为输出和输入。
- en: Fan-in/fan-out of services
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务输入/输出
- en: Let's take a real-world example of an e-commerce website integrating itself
    with a third-party payment gateway. Here, the website uses an API from the payment
    gateway to pop up the payment screen and enters security credentials. At the same
    time, the website may call another API called analytics to record the attempt
    of payment. This process of forking a single request into multiple is called **fan-out**.
    In the real world, there can be many fan-out services involved in a single client
    request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个电子商务网站与第三方支付网关集成的真实世界例子为例。在这里，网站使用支付网关的API弹出支付界面并输入安全凭证。同时，网站可能调用另一个名为分析（analytics）的API来记录支付尝试。将单个请求分解成多个请求的过程称为**输出**。在现实世界中，单个客户端请求可能涉及许多输出服务。
- en: 'Another example is **MapReduce**. Map is a fan-in operation, while Reduce is
    a fan-out operation. A server can fan out a piece of information to the next set
    of services (API) and ignore the result or can wait until all the responses from
    those servers are returned. As shown in the following diagram, an incoming request
    is being multiplexed by the server into two outgoing requests:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是**MapReduce**。Map是一个输入操作，而Reduce是一个输出操作。服务器可以将一条信息扇出到下一组服务（API），并忽略结果，或者等待从那些服务器返回的所有响应。如图所示，服务器正在将一个进入的请求多路复用到两个出去的请求：
- en: '![](img/cb751d20-f1e0-4b5e-8c27-a02390d0d5bc.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb751d20-f1e0-4b5e-8c27-a02390d0d5bc.png)'
- en: This process is a simple fan-out.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的输出过程。
- en: '**Fan-in** is an operation where two or more incoming requests converge into
    a single request. This scenario is how an API aggregates results from multiple
    backend services and returns the result on the fly to a client. For example, think
    about a hotel price aggregator or flight ticket aggregator that fetches requested
    information about multiple hotels or flights from various data providers and displays
    them. The following diagram shows how a fan-in operation combines multiple requests
    and prepares a final response that''s consumed by a client:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**是一种操作，其中两个或多个进入的请求汇聚成一个单一请求。这种场景是API如何从多个后端服务聚合结果，并即时返回给客户端。例如，考虑一个酒店价格聚合器或航班票务聚合器，它从各种数据提供商获取关于多个酒店或航班的请求信息，并将它们显示出来。以下图显示了输入操作如何结合多个请求，并准备一个最终响应，该响应被客户端消费：'
- en: '![](img/8b9179a1-4dc9-4c6a-9213-33a5deb5649e.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b9179a1-4dc9-4c6a-9213-33a5deb5649e.png)'
- en: The client can also be a server that serves further clients. As shown in the
    preceding diagram, the left-side hand server is collecting the responses from
    **Hotel A**, **Hotel B**, and **Airline Provider A** and preparing another response
    for a different client. Therefore, fan-in and fan-out operations are not always
    completely independent of each other. Mostly, it will be a hybrid scenario where
    both fan-in and fan-out operations fit with each other.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端也可以是一个服务器，它为其他客户端提供服务。如图所示，左侧的手动服务器正在收集来自**酒店A**、**酒店B**和**航空公司A**的响应，并为不同的客户端准备另一个响应。因此，输入和输出操作并不总是完全独立的。大多数情况下，它将是一个混合场景，其中输入和输出操作相互匹配。
- en: Please remember that the fan-out operation to the next set of servers can be
    asynchronous too. This may not be true with fan-in requests. A fan-in operation
    is sometimes called an API call.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对下一组服务器的输出操作也可以是异步的。对于输入请求可能不成立。输入操作有时被称为API调用。
- en: In this section, we've seen how fan-in and fan-out work. To use these techniques,
    we need to know how to implement an asynchronous service (API). In the next section,
    we'll try to implement such a service using a mechanism called job queuing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了扇入和扇出的工作方式。要使用这些技术，我们需要了解如何实现异步服务（API）。在下一节中，我们将尝试使用称为作业排队的机制来实现此类服务。
- en: Delaying API jobs with queuing
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用排队延迟 API 作业
- en: In synchronous APIs, the blocking code plays a crucial role in preparing the
    response that is sent to the client. However, in the asynchronous design, non-blocking
    is key. A queue and workers can be helpful in achieving non-blocking code. A server
    can have multiple workers running in parallel who can exhaust the contents of
    a queue and work on them. Whenever a client requests an operation through an asynchronous
    API, the server can put that request in a job queue, and all the workers can pick
    up a task whenever their turn comes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步 API 中，阻塞代码在准备发送给客户端的响应中起着至关重要的作用。然而，在异步设计中，非阻塞是关键。队列和工作者可以帮助实现非阻塞代码。服务器可以并行运行多个工作者，他们可以耗尽队列的内容并对其进行处理。每当客户端通过异步
    API 请求操作时，服务器可以将该请求放入作业队列，所有工作者都可以在他们轮到时选择任务。
- en: This approach can offload an API server and focus on its business logic instead
    of getting blocked on parallel/independent tasks such as sending emails, contacting
    third-party services, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以将 API 服务器卸载，并专注于其业务逻辑，而不是在并行/独立任务（如发送电子邮件、联系第三方服务等）上阻塞。
- en: 'A few use cases of queuing are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 排队的一些用例如下：
- en: Compress images and email the final result
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩图像并通过电子邮件发送最终结果
- en: Automatic back pressuring (limiting the load on the server to predictable amounts)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动背压（将服务器负载限制在可预测的量）
- en: To explain this concept in detail, let's formulate an example and try to implement
    it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细解释这个概念，让我们制定一个示例并尝试实现它。
- en: 'Let''s develop an asynchronous API server that can perform two different kinds
    of jobs:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个可以执行两种不同类型作业的异步 API 服务器：
- en: Logging given information to the database
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将给定信息记录到数据库
- en: Sending an email
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: The condition is that it should not block other operations. The API should return
    a Job ID ticket to the client who can use that information to fetch the running
    information of the job.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 条件是它不应该阻塞其他操作。API 应该返回一个 Job ID 票据给客户端，客户端可以使用该信息来获取作业的运行信息。
- en: Before jumping into the implementation, we should know about a few basics of
    enabling queuing to our service. We can implement queue/worker from scratch, but
    there are many good open source queuing systems such as RabbitMQ or ZeroMQ to
    choose from.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实施之前，我们应该了解一些启用排队到我们服务的基本知识。我们可以从头开始实现队列/工作者，但有许多优秀的开源排队系统可供选择，例如 RabbitMQ
    或 ZeroMQ。
- en: We, as part of implementing the preceding problem, will use RabbitMQ due to
    its popularity and the maturity of Go bindings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实施上述问题的一部分，我们将使用 RabbitMQ，因为它很受欢迎，Go 绑定也很成熟。
- en: RabbitMQ, a powerful message queue
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大的消息队列 RabbitMQ
- en: 'RabbitMQ implements a messaging protocol called **Advanced Message Queueing
    Protocol** (**AMQP**). It uses it to support worker queues. It also supports many
    other data exchange patterns, such as the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 实现了一种名为 **高级消息队列协议** （**AMQP**）的消息协议。它使用它来支持工作者队列。它还支持许多其他数据交换模式，例如以下内容：
- en: Publish/Subscribe
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布/订阅
- en: Topic/Subscription
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题/订阅
- en: Routing messages
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由消息
- en: '**Remote Procedure Call** (**RPC**)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程过程调用** （**RPC**）'
- en: 'In this section, we''ll focus on the messaging functionality of RabbitMQ. We
    can install RabbitMQ on our system using Docker, like so:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注 RabbitMQ 的消息功能。我们可以使用 Docker 在我们的系统上安装 RabbitMQ，如下所示：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It starts the RabbitMQ broker with the given hostname, `rabbitmq-host`, and
    container name, `rabbitmq-server`. We use `rabbitmq:3` as the base image for our
    server. Docker pulls the image from the Docker hub and creates a container. You
    will see an output similar to this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用给定的主机名 `rabbitmq-host` 和容器名 `rabbitmq-server` 启动 RabbitMQ 代理。我们使用 `rabbitmq:3`
    作为我们服务的基础镜像。Docker 从 Docker Hub 拉取镜像并创建一个容器。您将看到类似以下内容的输出：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: RabbitMQ uses default port `5672` for its operations. You can change this using
    the initial settings for the Docker command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 使用默认端口 `5672` 进行操作。您可以使用 Docker 命令的初始设置来更改此端口。
- en: 'The preceding RabbitMQ broker runs in the foreground. However, in production,
    you have to run it in the background. This means you need to pass the `-d` flag
    to the Docker command to run it in the background, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的RabbitMQ代理在前台运行。然而，在生产中，您必须将其在后台运行。这意味着您需要将`-d`标志传递给Docker命令以在后台运行，如下所示：
- en: '`docker run -d --hostname rabbitmq-host --name rabbitmq-server -p 5672:5672
    -p 15672:15672 rabbitmq:3`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run -d --hostname rabbitmq-host --name rabbitmq-server -p 5672:5672
    -p 15672:15672 rabbitmq:3`'
- en: By default, if we don't pass user credentials while launching the container
    (`docker run ...`), a default `<guest:guest>` user's credentials are created for
    the broker. You can reset them at any time or pass them while launching a container.
    You can find out more at [https://hub.docker.com/_/rabbitmq](https://hub.docker.com/_/rabbitmq).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果我们启动容器时（`docker run ...`）不传递用户凭证，将为代理创建一个默认的`<guest:guest>`用户的凭证。您可以在任何时候重置它们或在启动容器时传递它们。您可以在[https://hub.docker.com/_/rabbitmq](https://hub.docker.com/_/rabbitmq)了解更多信息。
- en: Communicating with RabbitMQ in Go
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go与RabbitMQ通信
- en: Now, we have a message broker (RabbitMQ). Before building an asynchronous API,
    we should learn how a Go program can talk to the message broker and send/receive
    the messages. While doing so, we'll create clients for production and consumption.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个消息代理（RabbitMQ）。在构建异步API之前，我们应该了解Go程序如何与消息代理通信并发送/接收消息。在这个过程中，我们将创建用于生产和消费的客户端。
- en: First, we have to create a `connection` to dial to the broker. If the connection
    is successful, a `Channel` needs to be created out of the connection. It has the
    API for performing operations on the message broker. Then, we can define a queue
    that messages are sent to. Finally, we publish a message to the queue.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个`connection`以连接到代理。如果连接成功，需要从连接中创建一个`Channel`。它具有在消息代理上执行操作的API。然后，我们可以定义一个消息发送到的队列。最后，我们向队列发布一条消息。
- en: We use an open source Go package called `amqp` for working with RabbitMQ.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`amqp`的开源Go包来与RabbitMQ一起工作。
- en: 'Let''s create our first program of this chapter:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建本章的第一个程序：
- en: 'Create a directory like this for a message sender:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为消息发送者创建一个如下所示的目录：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Install the `amqp` package using the `dep` tool:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dep`工具安装`amqp`包：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This creates the `Gopkg.toml` and `Gopkg.lock` files in the directory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在目录中创建`Gopkg.toml`和`Gopkg.lock`文件。
- en: 'Now, we are ready to go. We''re going to look at an example that creates a
    queue in RabbitMQ and sends a message to it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备就绪。我们将查看一个示例，该示例在RabbitMQ中创建一个队列并向其发送消息：
- en: 'First, let''s import the necessary packages/libraries inside `main.go`. These
    are `log` and `amqp`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在`main.go`内部导入必要的包/库。这些是`log`和`amqp`：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we need a handler to handle errors that will be generated from every step.
    Go''s error handling can be messy, which hampers readability. To have a clean
    code structure, we need to handle errors in one single place:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个处理程序来处理每一步将生成的错误。Go的错误处理可能很混乱，这会妨碍可读性。为了有一个干净的代码结构，我们需要在单个位置处理错误：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function takes an error and a message and logs the information to `STDOUT`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接收一个错误和一个消息，并将信息记录到`STDOUT`。
- en: 'Now, let''s write the logic for sending and receiving messages. In the program''s
    main block, create a connection and channel. Then, dial to RabbitMQ using a connection
    string that contains user credentials. Once the connection is successful, obtain
    the `Channel` object to push messages. The code looks like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写发送和接收消息的逻辑。在程序的主块中，创建一个连接和通道。然后，使用包含用户凭证的连接字符串连接到RabbitMQ。一旦连接成功，获取`Channel`对象以推送消息。代码如下所示：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the connection string:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是连接字符串：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is formed with the details of `protocol ://user:password@host:port`, where
    `host`, `port`, `user`, and `password` are the credentials of the RabbitMQ server.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它由`protocol ://user:password@host:port`的详细信息组成，其中`host`、`port`、`user`和`password`是RabbitMQ服务器的凭证。
- en: You should never use the default credentials for RabbitMQ in production. Please
    set strong passwords for all your sensitive information, including – RabbitMQ.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你绝不应该使用RabbitMQ的默认凭证。请为所有敏感信息设置强密码，包括 – RabbitMQ。
- en: 'Declare a queue called `test` for publishing the messages:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`test`的队列以发布消息：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we have a queue. Let''s prepare an `amqp` message (RabbitMQ message) to
    push it into the queue. Let''s say the message body is a log of server time:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有一个队列。让我们准备一个`amqp`消息（RabbitMQ消息）以将其推入队列。假设消息体是服务器时间的日志：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Publish the preceding message to the predefined queue, that is `testQueue`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的消息发布到预定义的队列，即`testQueue`：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Publish` method publishes a given message into a RabbitMQ queue.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publish`方法将给定消息发布到RabbitMQ队列。'
- en: We've finished creating a sender. Now, if we run this program, it pushes a message
    instantly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了发送器的创建。现在，如果我们运行这个程序，它会立即推送一个消息。
- en: 'Now, let''s write a receiver (worker) to consume those messages:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个接收器（工作程序）来消费这些消息：
- en: 'The logic is to define a `Consumer` and receive the messages. The code for
    the worker is mostly the same as it was previously:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑是定义一个`Consumer`并接收消息。工作程序的代码基本上与之前相同：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Dial to RabbitMQ using the connection string, fetch the `Channel`, and create
    a representation for `testQueue`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用连接字符串连接到RabbitMQ，获取`Channel`，并为`testQueue`创建一个表示：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need to add some extra functionality to consume. Just after `handleError`
    in the main section, we need to define which queue to consume and its properties:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加一些额外的功能来消费。在主部分的`handleError`之后，我们需要定义要消费的队列及其属性：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`messages` is a consumable that can be read for messages that are pushed into
    `testQueue`. Let''s see how we can read it:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`messages`是一个可消费的，可以读取推送到`testQueue`的消息。让我们看看我们如何读取它：'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This runs a go-routine that spawns a function that runs an infinite loop to
    collect messages and process them. A go-routine is a lightweight thread that's
    managed by Go's runtime engine. We can spawn a go-routine from a function. Here,
    we are simply logging the message to `STDOUT` in our go-routine. If we don't block
    the main program, the whole process ends, quickly killing the go-routine.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这运行了一个goroutine，它启动了一个函数，该函数运行一个无限循环以收集消息并处理它们。goroutine是由Go的运行时引擎管理的轻量级线程。我们可以从一个函数中启动goroutine。在这里，我们只是在我们的goroutine中将消息记录到`STDOUT`。如果我们不阻塞主程序，整个过程将结束，快速杀死goroutine。
- en: 'Let''s create a channel and read from it to block the main program:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个通道并从中读取以阻塞主程序：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this way, we have a worker.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有一个工作程序。
- en: 'Let''s run both programs to see how they work. First, run the worker. It creates
    a Queue called "text" if it doesn''t exist. Then, run the sender to send a message
    to the queue on a Terminal:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行这两个程序来看看它们是如何工作的。首先，运行工作程序。如果不存在，它会创建一个名为"text"的队列。然后，在终端上运行发送程序以向队列发送消息：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In another window of the Terminal (shell), run the sender program, which pushes
    a server time log into the queue:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口（shell）中运行发送程序，将服务器时间日志推送到队列：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you check the first Terminal, you''ll see the following message:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你检查第一个终端，你会看到以下消息：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This means the worker is successfully able to retrieve the messages from the
    queue. This functionality can be leveraged by API servers to put long-running
    jobs into message queues and let dedicated workers handle them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着工作程序能够成功从队列中检索消息。这个功能可以被API服务器利用，将长运行作业放入消息队列，并让专门的工人处理它们。
- en: After grasping the basics of queuing and how it can help us build asynchronous
    APIs, we should implement a real-world problem. In the next section, we'll define
    the problem statement and try to design a long-running task that performs various
    functions at the same time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握队列的基础知识和它如何帮助我们构建异步API之后，我们应该实现一个现实世界的问题。在下一节中，我们将定义问题陈述并尝试设计一个同时执行各种功能的长运行任务。
- en: Long-running task design
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长运行任务设计
- en: 'So far, we''ve learned about the basics of queuing and how to delay jobs. Now,
    we''re going to design a solution to a problem regarding asynchronous APIs. The
    problem is that we want to build a system that can handle requests for the following
    scenarios:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了队列的基础知识以及如何延迟作业。现在，我们将设计一个解决方案来解决有关异步API的问题。问题是，我们想要构建一个可以处理以下场景请求的系统：
- en: The server should save information to the database as one operation.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器应该将信息作为一个操作保存到数据库中。
- en: It should send an email to the given email address.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该发送电子邮件到指定的电子邮件地址。
- en: It should perform a long-running job and POST the result to a callback. This
    is known as a web-hook.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该执行一个长运行的任务并将结果POST到一个回调。这被称为web钩子。
- en: 'Let''s say these three operations are asynchronous and long-running. We need
    a mechanism to facilitate a long-running process that has the following characteristics:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这三个操作是异步和长运行的。我们需要一个机制来促进具有以下特征的长运行过程：
- en: The client can fire an API and receive a job ID back.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以触发一个API并返回一个作业ID。
- en: The job is pushed onto a queue with the respective message format.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业以相应的消息格式推送到队列中。
- en: A worker picks the job and starts performing it.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作者选择工作并开始执行。
- en: Finally, the worker saves the result on various endpoints and sends the status
    to the database.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，工作者将结果保存在各种端点上，并将状态发送到数据库。
- en: 'The following diagram shows the preceding requirements in detail:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图详细显示了前面的要求：
- en: '![](img/32f92cad-16d3-40c7-bb77-9dacb758c13f.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32f92cad-16d3-40c7-bb77-9dacb758c13f.png)'
- en: 'The preceding diagram shows a few engaging entities:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了几个引人入胜的实体：
- en: '**API server**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API服务器**'
- en: '****Database server****'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****数据库服务器****'
- en: '**Queue**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**'
- en: '**Workers**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作者**'
- en: '**API Server** is accepting asynchronous requests from the client and pushing
    those jobs into a message queue. Then, the workers are picking those jobs and
    performing some action on them.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**API服务器**正在接受来自客户端的异步请求，并将这些工作推送到消息队列。然后，工作者选择这些工作并对它们执行一些操作。'
- en: '**Worker A** saves the information from the message into a database. **Worker
    B** picks a job. After working on the message, it posts some information to a
    callback that was received as part of a request. **Worker C**''s job is to send
    an email.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作者A** 将消息中的信息保存到数据库中。**工作者B** 选择一个工作。在处理消息后，它将一些信息发布到作为请求一部分接收的回调。**工作者C**
    的任务是发送电子邮件。'
- en: For the sake of simplicity, we'll mock the end actions (DB insert, Email sending,
    and Callback). We're doing this in order to focus on the asynchronous API design
    over concrete actions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将模拟最终操作（数据库插入、发送电子邮件和回调）。我们这样做是为了专注于异步API设计而不是具体操作。
- en: To design this flow, we need to reuse the same message and make it fit all use
    cases. JSON is a better format for storing information about a job.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计这个流程，我们需要重用相同的消息并使其适合所有用例。JSON是存储关于作业信息的更好格式。
- en: 'We need to create some structs that hold information about the jobs, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一些结构来保存关于工作的信息，如下所示：
- en: '**Job**: Global storage for a job'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**：作业的全局存储'
- en: '**Log**: Information dedicated to Job A'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：专门针对作业A的信息'
- en: '**CallBack**: Information dedicated to Job B'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调**：专门针对作业B的信息'
- en: '**Mail**: Information dedicated to Job C'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邮件**：专门针对作业C的信息'
- en: A, B, and C are the worker types mentioned in the previous diagram.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: A、B和C是前面图中提到的工作者类型。
- en: 'Now, let''s define our project. Creating a project directory and developing
    each piece shown in the preceding architecture is part of this process:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的项目。创建项目目录并开发前面架构中显示的每个部分是这个过程的一部分：
- en: 'Create the project:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We're naming it `V1` (`Version 1`) because it is our first attempt to achieve
    asynchronicity. We'll add more features with more versions in the upcoming sections.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其命名为 `V1`（版本1），因为我们第一次尝试实现异步性。在接下来的章节中，我们将添加更多功能，并推出更多版本。
- en: 'We need to store our structs in the `models` directory. Create a package called
    `models` and add a new file to store the preceding structs:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将我们的结构存储在 `models` 目录中。创建一个名为 `models` 的包，并添加一个新文件来存储前面的结构：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the fields, we have `UUID` to track the job, `type` to distinguish between
    jobs, and extra data that is specific to respective jobs. We use Google''s `UUID`
    package to generate a `UUID` string and set a Job ID. `type` could be "A", "B",
    or "C".`Log` is used for time-related operations, so it needs a time field. `callback`
    needs a callback URL to post data. `mail` needs an email address to send a message
    to. The struct file contains the following constructs:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于字段，我们有 `UUID` 来跟踪工作，`type` 来区分工作，以及针对各自工作的特定额外数据。我们使用Google的 `UUID` 包生成 `UUID`
    字符串并设置作业ID。`type` 可以是 "A"，"B" 或 "C"。`Log` 用于与时间相关的操作，因此需要一个时间字段。`callback` 需要一个回调URL来发布数据。`mail`
    需要一个电子邮件地址来发送消息。结构文件包含以下结构：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The important field from the preceding file is `ExtraData`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '之前文件中的重要字段是 `ExtraData`:'
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We define it as an interface and make it a placeholder for Log, Callback, and
    Mail. We instantiate the respective structs when we publish the message.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其定义为接口，并使其成为Log、Callback和Mail的占位符。当我们发布消息时，我们实例化相应的结构。
- en: 'In the main program, we have to define a few helper functions and constants.
    We add these to our project''s main file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主程序中，我们必须定义一些辅助函数和常量。我们将这些添加到项目的主文件中：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define the queue name, the address that the HTTP server runs on, and an error
    handler that handles any errors:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义队列名称、HTTP服务器运行的地址以及处理任何错误的错误处理器：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is done to avoid duplicate code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了避免重复代码。
- en: 'We have to bake a few more components in our project:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在我们的项目中再烘焙几个组件：
- en: An HTTP server
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HTTP服务器
- en: Workers
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作者
- en: URL handlers
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL处理器
- en: A `Handler` takes an incoming request and tries to create an instant Job ID.
    Once it successfully places the job in the queue, it returns the Job ID to the
    caller. Now, the workers who are already started and listening to the job queue
    pick those tasks and execute them concurrently.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler`接收一个传入的请求并尝试创建一个即时作业ID。一旦它成功将作业放入队列，它就会将作业ID返回给调用者。现在，已经启动并监听作业队列的工作者将选择这些任务并发地执行它们。'
- en: 'Create a file for the worker:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为工作者创建一个文件：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Workers` is a `struct` that holds a connection to the message queue. Using
    that connection, all the workers read from the queue:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Workers`是一个`struct`，它包含对消息队列的连接。使用该连接，所有工作者从队列中读取：'
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At some point, we need to start the workers. To do this, we need to define a
    run method that initiates/boots workers. The worker should listen to the message
    queue for messages and consume them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们需要启动工作者。为此，我们需要定义一个运行方法来启动/引导工作者。工作者应该监听消息队列中的消息并消费它们。
- en: 'Once there is an incoming message, check the type of work and delegate it to
    the respective functions, that is,`dbWork`, `callbackWork`, and `emailWork`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦有传入的消息，检查工作类型并将其委派给相应的函数，即`dbWork`、`callbackWork`和`emailWork`：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At the end of the function, we closed the channel and blocked the worker since
    go-routines are running in the background.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数结束时，我们关闭了通道并阻塞了工作者，因为goroutines在后台运行。
- en: 'Now, we can mock the actual work of the workers with delays for three functions: `dbWork`,
    `callbackWork`, and `emailWork`. We use delays to simulate the background work
    and log messages accordingly. We will define those functions on the `workers`
    struct so that the functions are tightly attached:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过为三个函数`dbWork`、`callbackWork`和`emailWork`添加延迟来模拟实际工作者的工作。我们使用延迟来模拟后台工作并相应地记录消息。我们将在`workers`结构体上定义这些函数，以便函数紧密关联：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These workers work independent of the main program. They listen to the message
    queue and process incoming messages according to their type. By doing this, we
    have defined the endpoints/workers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工作者独立于主程序工作。它们监听消息队列并按照其类型处理传入的消息。通过这种方式，我们定义了端点/工作者。
- en: 'Now, it''s time to define a few endpoints for our HTTP server that accept the
    API requests and publish messages to the queue. These will go into a new file
    called `handlers.go`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候为我们的HTTP服务器定义一些端点了，这些端点接受API请求并将消息发布到队列。这些将放入一个名为`handlers.go`的新文件中：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our handlers also need access to the message queue''s connection, which is
    a channel where we can publish messages. Due to this, it is better to have a struct
    for the server and define the handlers as methods. Let''s call it `JobStruct`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的管理员也需要访问消息队列的连接，这是一个我们可以发布消息的通道。因此，最好为服务器定义一个结构体，并将处理程序定义为方法。让我们称它为`JobStruct`：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We should attach a method called `publish` to the preceding struct. All the
    handlers can use this method to publish a JSON body to the message queue. It is
    similar to the logic we explored when we introduced the RabbitMQ channel:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在前面定义的结构体上附加一个名为`publish`的方法。所有处理程序都可以使用此方法将JSON体发布到消息队列。这与我们在介绍RabbitMQ通道时探索的逻辑类似：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s define three handlers that will work on three types of jobs, as
    follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义三个处理程序，它们将处理三种类型的工作，如下所示：
- en: The first handler creates a job for work type A– saving client time to the database.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个处理程序为工作类型A创建一个任务——将客户端时间保存到数据库中。
- en: The second handler creates a job for work type B– a callback to the URL after
    some time.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个处理程序为工作类型B创建一个任务——在一段时间后回调URL。
- en: The third handler creates a job for work type C– sending an email.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个处理程序为工作类型C创建一个任务——发送电子邮件。
- en: 'For the first handler, we take a query parameter called `client_time` from
    an HTTP request and use it to save in the DB. We use `json` and `strconv` to make
    required data conversions. Once we have the necessary information for the worker,
    we can compose the JSON and publish it to the queue:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个处理程序，我们从HTTP请求中获取一个名为`client_time`的查询参数，并将其用于在数据库中保存。我们使用`json`和`strconv`进行所需的数据转换。一旦我们有了工作者所需的所有信息，我们就可以组合JSON并将其发布到队列中：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, this function handler composes a message that is required for
    the worker that processes `"A"`(database job). Extra information is passed inside
    the `ExtraData` field. As we mentioned previously, the interface can fit any kind
    of new struct in it. So, at runtime, we set what could fit into `ExtraData`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此函数处理程序为处理`"A"`（数据库作业）的工作者组合了所需的消息。额外的信息在`ExtraData`字段中传递。正如我们之前提到的，接口可以适应任何新的结构体。因此，在运行时，我们在`ExtraData`中设置可以放入的内容。
- en: The other two handlers look exactly the same, except for the composition of
    `jsonBody`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个处理程序看起来完全一样，只是`jsonBody`的组成不同。
- en: 'The JSON message for handler 2 is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序2的JSON消息如下：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The JSON message for handler 3 is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序3的JSON消息如下：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next is the main program. We have to glue workers, handlers, and structs using
    our main logic. Previously, we added the constants, but now we have to extend
    this to bring the workers and API to life.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是主程序。我们必须使用我们的主逻辑将工人、处理程序和结构体粘合在一起。之前，我们添加了常量，但现在我们必须扩展这一点，以使工人和API活跃起来。
- en: 'Finally, we should glue everything we have built so far together. Follow these
    steps to do so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该将迄今为止构建的每一部分都粘合在一起。按照以下步骤操作：
- en: 'We need a function that returns a `JobServer` object. Let''s add that function,
    called `getServer`, to the `main.go` file. The job server holds a connection and
    a queue. The code looks like this:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个返回`JobServer`对象的函数。让我们将这个名为`getServer`的函数添加到`main.go`文件中。作业服务器持有连接和队列。代码如下：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using this server, we can link URL endpoints to handler functions. These functions
    use the instantiated connection properties of RabbitMQ/Message Queue.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个服务器，我们可以将URL端点链接到处理程序函数。这些函数使用RabbitMQ/消息队列的实例化连接属性。
- en: 'Now, get a `JobServer` by calling the preceding function with `queueName`,
    which we defined as a constant:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过调用前面的函数并传入`queueName`（我们将其定义为常量）来获取`JobServer`：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we should start the workers. If we start them normally, they''ll block
    the main execution thread. Therefore, we have to make them goroutines:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该启动工人。如果我们正常启动他们，他们将阻塞主执行线程。因此，我们必须将它们变成goroutines：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To take client requests and make our application possible, we have to attach
    handlers to the URL. The Gorilla Mux router can be used for this. We discussed
    it extensively in [Chapter 2](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml),[ ](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml)*Handling
    Routing for our REST Services*. We''ll reuse the same pattern we used there to
    attach the routes to the handlers:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了接收客户端请求并使我们的应用程序成为可能，我们必须将处理程序附加到URL。可以使用Gorilla Mux路由器来完成此操作。我们在[第2章](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml)中详细讨论了它，[处理我们的REST服务的路由](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml)。我们将重用那里使用的相同模式将路由附加到处理程序：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This starts an HTTP server and routes requests to the URL we defined previously.
    As you may have noticed, we are using a job server's handlers as endpoints.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个HTTP服务器并将请求路由到我们之前定义的URL。正如你可能已经注意到的，我们正在使用作业服务器的处理程序作为端点。
- en: 'Last but not least, we should safely close the connection and channel:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们应该安全地关闭连接和通道：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This completes our example. Let''s build the Go project from the project root
    (`longRunningTask`) and see the output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的示例。让我们从项目根目录（`longRunningTask`）构建Go项目并查看输出：
- en: Make sure your RabbitMQ server isn't down. Our job server uses RabbitMQ as a
    message queue.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的RabbitMQ服务器没有关闭。我们的作业服务器使用RabbitMQ作为消息队列。
- en: 'Run the `go build` command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go build`命令：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This generates an executable with the same name as the project, that is, `longRunningTaskV1`.
    We can start our HTTP server like so:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将生成一个与项目同名的可执行文件，即`longRunningTaskV1`。我们可以这样启动我们的HTTP服务器：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The server is now running on port `8000`. Make a few `curl` `GET` requests
    to the server:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器现在正在端口`8000`上运行。向服务器发送几个`curl` `GET`请求：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Instead of blocking the requests, the server returns quickly with a Job ID
    for the tasks. Let''s take a look at the server logs:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器不会阻塞请求，而是快速返回任务的工作ID。让我们看看服务器日志：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There is a two second delay in sending the mail, but the client is not blocked
    on that decision. This is how an asynchronous API works by design.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 发送邮件有2秒的延迟，但客户端不会在该决策上阻塞。这就是异步API按设计工作的方式。
- en: Always prepare a design upfront for an asynchronous API. Since there is no silver
    bullet for a given problem, you have to explore various architectures, such as
    message queues.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计异步API之前，总是要提前准备一个设计。由于对于给定的问题没有银弹，你必须探索各种架构，例如消息队列。
- en: Okay, but how can a client retrieve the status of a job, whether it is started,
    in progress, or done? To enable that feature, we have to store the state of a
    job somewhere. This can be a database or a temporary cache. Modern applications
    make a lot of read operations by polling the API for the job status. Redis is
    a good caching solution for these kinds of problems. We can extend this example
    with Redis to solve `find the status of a job ID`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但客户端如何检索作业的状态，无论是已启动、进行中还是已完成？为了启用这个功能，我们必须将作业的状态存储在某个地方。这可以是一个数据库或临时缓存。现代应用程序通过轮询API来获取作业状态，进行大量的读取操作。Redis是这类问题的良好缓存解决方案。我们可以通过Redis扩展这个示例来解决`查找作业ID的状态`的问题。
- en: In the next section, we'll introduce Redis, which includes installing Redis
    and linking it to a Go program. After that, we'll construct an extended version
    of a long-running task with a job status.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍Redis，包括安装Redis并将其链接到Go程序。之后，我们将构建一个具有作业状态的长时间运行任务的扩展版本。
- en: Caching strategies for APIs
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API的缓存策略
- en: Redis is a wonderful open source solution for caching high-read configuration/information.
    It is a key/value pair store and has faster reads thanks to its in-memory storage.
    An example of a key/value pair store is a media website where a few articles are
    set fixed on their home page for a few hours.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个优秀的开源缓存解决方案，用于缓存高读取配置/信息。它是一个键/值对存储，由于其内存存储，读取速度更快。一个键/值对存储的例子是一个媒体网站，其中一些文章会在主页上固定显示几个小时。
- en: Instead of letting every reader hit their database to fetch a record, a media
    house can use Redis to store article content. That is one of many applications
    of Redis.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让每个读者都去数据库中检索记录，媒体机构可以使用Redis来存储文章内容。这是Redis的许多应用之一。
- en: 'Job status is temporary information that becomes irrelevant once the job is
    finished and status is logged to log storage. Due to this, Redis is the best choice
    for implementing job status caching. We plan to do the following things:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作业状态是临时信息，一旦作业完成并将状态记录到日志存储中，就变得无关紧要。因此，Redis是实现作业状态缓存的最好选择。我们计划做以下事情：
- en: Write a job status
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入作业状态
- en: Read a job status
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取作业状态
- en: 'Both actions are performed by our job server but at different times. The status
    can be in three forms:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作都是由我们的作业服务器执行的，但时间不同。状态可以有以下三种形式：
- en: Started
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已启动
- en: In Progress
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行中
- en: Done
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成
- en: 'Redis provides a rich collection of data structures to hold information temporarily.
    Out of them, we use a simple `Key:String` for our job status. Job ID can be a
    key and status is its value. In simple notation, it looks like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Redis提供了一组丰富的数据结构来临时存储信息。其中，我们使用简单的`Key:String`来存储作业状态。作业ID可以是键，状态是其值。用简单的符号表示，它看起来像这样：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can easily run a Redis instance with Docker. Just run a Redis container
    and expose port `6379`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地使用Docker运行Redis实例。只需运行一个Redis容器并公开端口`6379`：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding command runs a Redis server on localhost on port `6379`. The
    process will be run as a daemon with the `-d` option. To check which container
    is for Redis, you can simply run the following Docker command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在本地主机的`6379`端口上运行Redis服务器。进程将以守护进程的方式运行，带有`-d`选项。要检查哪个容器是Redis的，你可以简单地运行以下Docker命令：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`redis-cli` is a tool that can be used to quickly inspect the Redis server.
    You don''t have to install it separately. Your Redis Docker instance already has
    it built in. You just have to execute a command against the Redis container, like
    this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis-cli`是一个可以用来快速检查Redis服务器的工具。你不需要单独安装它。你的Redis Docker实例已经内置了它。你只需要对Redis容器执行一个命令，就像这样：'
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can get all the available keys stored in Redis with the following command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令获取Redis中存储的所有可用键：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can also set a key to a value with an expiration date in the CLI, like
    this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在CLI中设置一个带有过期日期的键值，就像这样：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding command sets a key called `topic` to `async`. The server returns
    `OK` for a successful insert. The CLI is easy to use, but in most cases, you can
    also access Redis from applications. In the next section, we'll learn how to do
    this from Go programs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将一个名为`topic`的键设置为`async`。服务器在成功插入后会返回`OK`。CLI易于使用，但在大多数情况下，你也可以从应用程序中访问Redis。在下一节中，我们将学习如何从Go程序中这样做。
- en: go-redis, a Go client for communicating with Redis
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: go-redis，用于与Redis通信的Go客户端
- en: 'There is a widely used type-safe Go client that''s used to talk to Redis servers
    called `go-redis`. We can use it to connect to a Redis server by creating a client
    similar to RabbitMQ. Let''s look at the steps for doing this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个广泛使用的类型安全的Go客户端，用于与Redis服务器通信，称为`go-redis`。我们可以通过创建一个类似于RabbitMQ的客户端来连接到Redis服务器。让我们看看执行此操作的步骤：
- en: 'First, we need to create a simple project called `redisIntro` for illustrating
    its basic usage:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个名为`redisIntro`的简单项目，以展示其基本用法：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Initialize the necessary dependencies and install the `go-redis` package using
    the `dep` tool from your project''s root:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dep`工具从项目的根目录初始化必要的依赖项并安装`go-redis`包：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, create a small client that calls the default `PING` command and gets `PONG`
    back:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个小的客户端，调用默认的`PING`命令并返回`PONG`：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A client can be created using the `redis.NewClient` method from the `go-redis`
    package:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`go-redis`包中的`redis.NewClient`方法创建一个客户端：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The Redis client can perform commands on the server. One such command is `PING`.
    A `SET` or `GET` command works the same way. Now, let''s run the program:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redis客户端可以在服务器上执行命令。其中一个命令是`PING`。`SET`或`GET`命令的工作方式相同。现在，让我们运行程序：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This prints out the `PONG` message, which is a response that's given by the
    Redis server. With this, we can confirm that our program is successfully connected
    to the server and that the queries are working fine.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出`PONG`消息，这是Redis服务器给出的响应。有了这个，我们可以确认我们的程序已经成功连接到服务器，并且查询工作正常。
- en: Job status cache with Redis
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis进行作业状态缓存
- en: 'Now that we''ve introduced Redis and the Redis client for Go, let''s quickly
    add the feature of job status to our previously designed asynchronous API. We
    need to make the following changes to that project:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Redis和Go的Redis客户端，让我们快速添加作业状态功能到我们之前设计的异步API中。我们需要对那个项目进行以下更改：
- en: Add a new route to collect the job ID from a client
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的路由以从客户端收集作业ID
- en: Add a new handler to fetch the job status from Redis
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的处理程序以从Redis获取作业状态
- en: Whenever someone adds a new job, we need to write status to Redis in every stage
    of the job life cycle
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当有人添加一个新的作业时，我们需要在作业生命周期的每个阶段将状态写入Redis
- en: We'll create a new project for this feature. It has a similar structure to `longRunningTaskV1`,
    which we created previously. The code and files are the same. You can clone the
    project and rename it `longRunningTaskV2`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的项目来实现这个功能。它的结构与我们之前创建的`longRunningTaskV1`类似。代码和文件都是相同的。你可以克隆该项目并将其重命名为`longRunningTaskV2`。
- en: 'Let''s take a look at the implementation, which includes dependency installs
    and modifications we have to make to the previous project. We won''t go through
    the complete code, to avoid any redundancy:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现，包括依赖项安装和我们必须对先前项目进行的修改。我们不会展示完整的代码，以避免任何冗余：
- en: 'To make sure you have all the necessary dependencies, run the `dep` command:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保你有所有必要的依赖项，运行`dep`命令：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the Redis package to the cache in order to store/retrieve the status of
    a job:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Redis包添加到缓存中，以便存储/检索作业的状态：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The first change is to add a route to access the job status. The status could
    be any one of these three:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改是添加一个路由以访问作业状态。状态可以是以下三者之一：
- en: '`STARTED`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTED`'
- en: '`IN PROGRESS`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IN PROGRESS`'
- en: '`DONE`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DONE`'
- en: 'Let''s add one more property to the `JobServer` struct, called `redisClient`.
    This stores the client connection to the Redis container, which is already up
    and running:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向`JobServer`结构体添加一个名为`redisClient`的新属性。它存储到已启动并运行的Redis容器的客户端连接：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add the Redis package and modify its struct:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Redis包并修改其结构：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, add a handler function that accepts a `UUID` as a parameter and constructs
    a response by fetching the job status from Redis:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个处理函数，该函数接受一个`UUID`作为参数，并通过从Redis获取作业状态来构造响应：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This handler uses the Redis client `Get` function to fetch the value of a key
    from the Redis server. After this happens, the HTTP JSON response is sent back
    to the client.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序使用Redis客户端的`Get`函数从Redis服务器获取键的值。在此之后，将HTTP JSON响应发送回客户端。
- en: 'Now, change the `main.go` file and add a new route:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更改`main.go`文件并添加一个新的路由：
- en: '[PRE60]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This imports the Redis package and creates a new Redis client. It also adds
    a new route for collecting UUID job strings from clients. The new route is `"job/status"`, and
    we attach the newly created handler, `statusHandler`, to it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这导入了Redis包并创建了一个新的Redis客户端。它还添加了一个新的路由来收集客户端的UUID作业字符串。新的路由是`"job/status"`，我们将新创建的处理程序`statusHandler`附加到它。
- en: 'We can make an API call to get the status of a job, but the pending functionality
    is to write a job status in Redis whenever a new job is executed. For that, we
    have to modify our workers a bit. The file we''ll be modifying is as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过API调用获取工作的状态，但待办功能是在每次执行新工作项时在Redis中写入工作状态。为此，我们必须稍微修改我们的工作函数。我们将修改的文件如下：
- en: '[PRE61]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we should change the worker struct so that it holds one more Redis connection
    so that it can write the statuses of jobs in the cache. Our plan is to store the
    job ID as a key and the status as a value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该修改工作结构体，使其保持一个额外的Redis连接，以便可以在缓存中写入工作的状态。我们的计划是将工作ID作为键，将状态作为值。
- en: 'Add the Redis package to import `NewClient`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Redis包添加到导入`NewClient`：
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Modify the `Worker` struct to add `redisClient`. This will hold a new connection
    to the Redis server:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Worker`结构体以添加`redisClient`。这将保持对Redis服务器的新连接：
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the `run` function, create a concrete connection to the Redis client:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`run`函数中，创建一个具体的Redis客户端连接：
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Modify the worker functions to add the status messages. For example, let''s
    look at `dbWork`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改工作函数以添加状态消息。例如，让我们看看`dbWork`：
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We are writing messages into a Redis key with the message as a value. The same
    key is overwritten when the process shifts to the next phase. This is achieved
    by calling the Redis `redisClient.Set()`. function.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将消息写入Redis键，其中消息作为值。当过程转移到下一阶段时，相同的键被覆盖。这是通过调用Redis的`redisClient.Set()`函数实现的。
- en: If you're wondering why the third argument is provided, it's because it's the
    expiration time of a key on the Redis server. We can also set a key that lives
    only for some time. For now, we want to persist our keys, so the expiration is
    set to `zero`, which means no expiration in Redis.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么提供了第三个参数，那是因为它是Redis服务器上键的过期时间。我们也可以设置一个只存在一段时间的关键。现在，我们希望持久化我们的键，所以过期设置为`zero`，这意味着在Redis中没有过期。
- en: We can apply the same process for the other two worker functions, that is, `callbackWork`
    and `emailWork`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相同的过程应用于其他两个工作函数，即`callbackWork`和`emailWork`。
- en: 'Now, it''s time to test our new feature:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候测试我们的新特性了：
- en: 'Build the `longRunningTaskV2` project and call a job using curl. Now, find
    the status of that job using the new endpoint that we added:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`longRunningTaskV2`项目并使用curl调用一个工作项。现在，使用我们添加的新端点找到该工作的状态：
- en: '[PRE66]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a new job, like this:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的工作项，如下所示：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This returns the following JSON, which contains job details:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将返回以下JSON，其中包含工作详情：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we can find the status of a job with `uuid`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`uuid`找到工作的状态：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This returns the following status:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将返回以下状态：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This message varies according to when the client calls the API. But it is a
    transparent way to give the status of asynchronous jobs to clients.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息根据客户端何时调用API而变化。但它是一种向客户端透明地提供异步工作状态的方法。
- en: There is one more category of API that realizes asynchronous behavior. That
    is known as the event-driven API. Servers and clients can listen to broadcasted
    events rather than explicitly requesting them. This approach is different from
    traditional asynchronous implementations. We'll take a look at this in the next
    section.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种API类别实现了异步行为。这被称为事件驱动API。服务器和客户端可以监听广播的事件，而不是明确请求它们。这种方法与传统异步实现不同。我们将在下一节中查看这一点。
- en: Event-driven API
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动API
- en: The strategies we've explained so far are instances of the request/response
    protocol where the client makes an API call to execute a job. There are many other
    architectures like this, such as the event-driven API, where a system generates
    a series of events that other systems can listen to and receive updates from.
    For a client to receive events, they should be subscribed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前解释的策略是请求/响应协议的实例，其中客户端通过API调用执行工作。还有许多其他类似架构，例如事件驱动API，其中系统生成一系列事件，其他系统可以监听并从中接收更新。为了客户端接收事件，他们应该订阅。
- en: This is similar to callbacks in some languages, such as JavaScript, where an
    event loop runs continuously and collects events. This type of approach is good
    for non-blocking clients and servers.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这与某些语言中的回调类似，例如JavaScript，其中事件循环持续运行并收集事件。这种方法适用于非阻塞客户端和服务器。
- en: 'A trivial example includes a client registering an HTTP endpoint with an API.
    The server can trigger the API as an event whenever some useful information is
    available. A few practical examples are as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子包括客户端将HTTP端点注册到API。每当有有用的信息可用时，服务器可以触发API作为事件。以下是一些实际例子：
- en: A weather station sending a series of events to subscribed clients (for example,
    mobiles)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个向订阅客户端（例如，手机）发送一系列事件的气象站
- en: Amazon's **Simple Notification Service **(**SNS**) publishing a message to an
    endpoint
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊的**简单通知服务（SNS**）向端点发布消息
- en: A slack webhook that is registered to an API to get events; for example, a code
    pipeline failing
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个注册到API的Slack webhook以获取事件；例如，代码管道失败
- en: 'A few protocols that implement the event-driven architecture are as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 实现事件驱动架构的一些协议如下：
- en: Publish/Subscribe
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布/订阅
- en: WebSocket communication
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket通信
- en: Webhooks/ REST hooks
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webhooks/ REST hooks
- en: Server push (SSE)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器推送（SSE）
- en: These protocols are used in different places according to the use case at hand.
    We'll discuss Publish/Subscribe briefly in [Chapter 11](b5dafb13-8906-4c1a-b780-7f0356f95d61.xhtml),
    *Scaling our REST API Using Microservices*. There, we'll learn how to build an
    event-driven system, consume events from another party, and more.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 根据实际用例，这些协议被用于不同的地方。我们将在第11章[使用微服务扩展我们的REST API](b5dafb13-8906-4c1a-b780-7f0356f95d61.xhtml)中简要讨论发布/订阅。在那里，我们将学习如何构建事件驱动系统，从另一方消费事件，以及更多。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the asynchronous API. First, we explained the
    key difference between a synchronous API and an asynchronous API. Then, we learned
    how multiple API requests lead to the fan-in or fan-out of services.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了异步API。首先，我们解释了同步API和异步API之间的关键区别。然后，我们学习了多个API请求如何导致服务的扇入或扇出。
- en: After that, we introduced a queuing system called RabbitMQ. A queue can hold
    jobs and allows servers to work on them. We learned how to create a queue and
    write a job into it. We also created a few RabbitMQ clients that can pick jobs
    from the queue and process them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们介绍了一个名为RabbitMQ的队列系统。队列可以保存作业并允许服务器处理它们。我们学习了如何创建队列并将作业写入其中。我们还创建了一些可以从队列中提取作业并处理它们的RabbitMQ客户端。
- en: 'We also designed a long-running task with multiple workers and a queue. The
    workers always listen to the queue and accept jobs. We defined three kinds of
    workers: DB, Email, and Callback.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设计了一个具有多个工作者和队列的长运行任务。工作者始终监听队列并接受工作。我们定义了三种类型的工作者：数据库（DB）、电子邮件（Email）和回调（Callback）。
- en: Redis is an in-memory database that stores key/value pairs. We can use it as
    a cache to store the status of jobs. We extended our long-running task to add
    status information by storing job statuses in Redis.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个存储键/值对的内存数据库。我们可以将其用作缓存来存储作业状态。我们扩展了我们的长运行任务，通过在Redis中存储作业状态来添加状态信息。
- en: Finally, we introduced the event-driven API and learned that, using Publish/Subscribe
    and WebSockets, we can set up event-driven data exchange between clients and servers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了事件驱动API，并了解到，使用发布/订阅和WebSocket，我们可以在客户端和服务器之间设置事件驱动的数据交换。
- en: In the next chapter, we will take a look at the basics of GraphQL, as well as
    examples of writing a GraphQL client and a server in Go.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨GraphQL的基础知识，以及如何在Go中编写GraphQL客户端和服务器示例。
