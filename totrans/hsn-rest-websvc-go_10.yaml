- en: GraphQL and Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll introduce a new query language called GraphQL. The traditional
    API definitions have failed to address the under-fetching and over-fetching APIs.
    An under-fetching API is an API that provides a minimum set of details for a given
    request. The drawback of this is that a developer should always create a new API
    or update the existing one. To overcome this, they can provide extra data that
    the clients can ignore safely. This causes another side effect; that is, it increases
    the payload size of the response. This situation is known as **over-fetching**.
    An over-fetching API provides unnecessary or unwanted data for clients. The response
    size is crucial when there are limitations regarding network bandwidth when designing
    APIs for clients.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is a query language that solves this problem. In this chapter, we'll
    learn how a client can efficiently query data from an API using GraphQL. As with
    every framework, GraphQL also has a few limitations, but its positives outweigh
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is GraphQL?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over-fetching and under-fetching problems in the REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating GraphQL clients in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating GraphQL servers in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software needs to be pre-installed in order to run the code samples
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go stable version compiler >= 1.13.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker version >= 18.09.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter10](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter10).
    Clone the code and use the code samples in the `chapter10` directory.
  prefs: []
  type: TYPE_NORMAL
- en: What is GraphQL?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GraphQL** is a query language that provides a set of rules. Using those rules
    and constructs, we can design an API that is efficient. According to the official
    documentation, the definition of GraphQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"GraphQL provides a complete and understandable description of the data in
    your API, gives clients the power to ask for exactly what they need and nothing
    more, makes it easier to evolve APIs over time, and enables powerful developer
    tools."'
  prefs: []
  type: TYPE_NORMAL
- en: '[-https://graphql.org/](https://graphql.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL provides a few features out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: Schema (a type system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versionless API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schema to Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GraphQL schema is a syntax for defining the boundaries of an API. The boundaries
    contain information about what server resources are exposed via the API. Since
    it allows an on-the-fly update of the schema without failing all the clients,
    it helps us create a versionless API. GraphQL provides client and server libraries
    for handling the resources defined in a schema.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is a language, not a runtime. So, someone has to translate a GraphQL
    schema to the code that a programming language can understand. A few GraphQL client
    and server libraries can do some automatic code generation from the schema definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding its functionality, let's look at the differences between a traditional
    API and a GraphQL-powered API.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in e-commerce, a cart page or a wish list page fetches almost the
    same resources (most of the fields), such as product link, image, and cost. A
    few things do vary, however. For example, the cart page needs a shipping address
    but the wish list doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API''s flow looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf6b7946-c329-402d-92d9-fb3675fa5cc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say that the responses for the preceding requests appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cart page (web):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Wish list (mobile):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The API developer usually defines two endpoints, one for the cart and another
    for the wish list. If the content of both the responses contains almost the same
    data, they can merge them into one for maintainability. There could be a problem
    with over-fetching for one of the API calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL gives the clients exactly what they need. The data that is passed over
    the wire is always as per the client''s request. The following diagram shows this
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c437ad9-633f-49cd-8573-0d5520c5feff.png)'
  prefs: []
  type: TYPE_IMG
- en: The same API endpoint can be used for multiple clients that are accepting the
    same resources but not the difference in data fields. That is the beauty of GraphQL.
    We will look at more practical examples in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll show you a solid example of how over-fetching and
    under-fetching can occur in an API.
  prefs: []
  type: TYPE_NORMAL
- en: Over-fetching and under-fetching problems in the REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Over-fetching** happens by an API when a server sends data that is not required
    by the client. The API is defined in advance and a client only needs to follow
    the API documentation. The drawback of this is that bandwidth is wasted. Let''s
    take a look at an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You are trying to make use of a GitHub user''s REST API to create a user tile
    display. The main intention here is to look at their followers, their public gist, their
    starred repositories, and the company name. However, when you make an API call
    to the GitHub API ([https://developer.github.com/v3/users/#get-a-single-user](https://developer.github.com/v3/users/#get-a-single-user))
    with the user `octocat`, it returns a JSON that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a big JSON file with spaces and newlines when you only need the aforementioned
    data fields. So, out of 37 fields, we are only going to consume four fields and
    ignore the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring isn't a problem, but all the data traveled over the network to reach
    the client. This is an unwanted waste of bandwidth. This is called **over-fetching**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Under-fetching** is where a response that''s sent by an API server is not
    sufficient for making decisions for a client. That leads to the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: A client has to make subsequent API calls to different endpoints to procure
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client has to compute manually on top of procured data and then merge it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a very inefficient approach as clients have very few resources compared
    to servers. For example, if a mobile device has to compute costly operations because
    of under-fetching, the API has to change its strategy to provide sufficient data.
    That can lead to over-fetching. Finding the right balance is always tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the previous example of fetching user information from the GitHub
    API. To get the starred repositories, we have to call `User` and then use the `starred_url`
    API endpoint to make a further query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a classical under-fetching problem that limited the GitHub API until
    version 3 (V3). They mitigated this problem by introducing GraphQL API V4 ([https://developer.github.com/v4](https://developer.github.com/v4)).
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL solves this problem by taking a whole new approach. It thinks about
    each entity as a resource and tries to build an API around it. This gives GraphQL
    the flexibility to compose data on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the basics of GraphQL, such as syntax and
    definitions. This includes types, queries, and functions for manipulating data.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A GraphQL schema is composed of many building blocks. These building blocks
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these blocks are essential for building a functional GraphQL API. We can
    divide all of these components into two main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Schemas and types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries and mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many features in each category, but we will only discuss the most
    important ones that can help you understand GraphQL. Let's take an example of
    fetching a user record from an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: All the snippets we show from here on are present in the intro directory
    of [Chapter10](f3dd906b-0446-4b33-a47a-cd2493804fb2.xhtml), *GraphQL and Go*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical GraphQL schema looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a GraphQL schema with three types: one special type called `Query`
    and two other custom types called `Person`  and `Address`.'
  prefs: []
  type: TYPE_NORMAL
- en: This schema is the specification of the API. It defines what types of resources
    are available for querying. It also defines one special type called `Query`, which
    is used by clients to query for data. In the preceding GraphQL schema, only a `user`
    of the  `Person` type can be queried.
  prefs: []
  type: TYPE_NORMAL
- en: 'A client query to the `/api/users` endpoint looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The server then sends sufficient information for the previously requested fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the client doesn''t need the `address` field and only needs the `name` field,
    it can only request the `name` to the same endpoint, that is, `/api/users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The server''s response may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This response has only retained the `name` field and omitted the `address` field.
    This can save a lot of bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: The shape of the GraphQL response directly matches the query, so clients can
    predict what they get back.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about types and queries in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Types and queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraphQL has a type system that a server should know about in order to prepare
    the schema. There are four types of high-level:'
  prefs: []
  type: TYPE_NORMAL
- en: Object level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-nullable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each type in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Object-level types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object-level types are used to define object-level constructs such as queries
    and resources. They are useful for defining what resources and queries are allowed
    on an API. The following is what we saw in the previous example, where we defined
    a query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These are special types and should not be confused with types in a programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Field-level types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, field-level types are defined on a resource/query field.
    They are similar to the types in a programming language. It tells us what data
    type is going to be returned from the API. It can be further divided into two
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar types (String, Int, Float, Boolean, ID)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom types (Address)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous example, the `Person` object-level type has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Go struct for the `Person` resource looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `name` field has a type called `String`, while the `address` field has a
    type called `[Address]`, which is a list of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Non-nullable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a special type that uses normal field types with special syntax and
    makes fields mandatory. When a type has a field with a non-nullable type, it should
    return non-empty data to the client. The type is defined with ! (*exclamatory*)
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the `Person` type, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we make the `name` field a non-nullable, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that if the client requests some data, the response must return
    a non-empty value for the `name` field. It cannot be null. We can also have a
    non-nullable list, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax can return zero or more elements of the `Address` type
    in the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need at least one address to be returned, then we can apply the non-nullable
    rule to list elements too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding rule creates an address field with a list of the `Address` type.
    That list should return at least one address to the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll introduce another important type called `Enumeration`.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Enumerations** (**Enums**) are special types that give flexibility in defining
    a range of scalar types. They can be helpful for passing a range of information
    to the client. It brings the following benefits to an API:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows an API to validate the field with a set of types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without throwing out the type system, it communicates that the accessible field
    value will be in a finite set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this GraphQL schema, we have a query type defined with `vehicle` as a field.
    `Vehicle` is an `Enum`. The vehicle has `Car` and `Bus` as its members. This means
    the query to this schema can expect either a `Car` or a `Bus`. This gives us flexibility
    over the predefined type systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the basics for defining a schema and what types
    we can define. In the next section, we'll learn how to write advanced queries
    from the client while fetching data.
  prefs: []
  type: TYPE_NORMAL
- en: Queries and mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen how the client GraphQL query works. It describes the fields
    regarding the data that should be supplied. But what if we need data about certain
    criteria? Can we query with some values? Yes! GraphQL is built on querying and
    it provides a variety of options we can use while querying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the initial example we showcased, that is, a user''s API
    with `name` and `address`. The client query looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query fetches all the users from the GraphQL server. We can also
    query a record by using the name. The query syntax uses curved brackets and parenthesis
    (:) on a field. Let''s retrieve users whose name is `"alice"`. The preceding client
    query should be modified using parenthesis, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This query only fetches a record/records whose name is `"alice"`. This construct
    is similar to a function call in programming languages. `name: "alice"` is called
    an `argument` for the query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL client can query using query arguments. The values for arguments
    can be scalar values, custom types, or even enumerations. We can also query on
    multiple levels. For example, let''s search for a user with `name "alice"` that
    comes from `city: "Munich"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Querying on multiple levels avoids the concept of multiple API endpoint fetches.
    The same API endpoint can flexibly change the data that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Mutations and inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A REST API has methods such as `GET`, `POST`, `PUT`, and `DELETE`. The method
    itself describes the operation of the API call. Does GraphQL have something similar?
    Yes – mutations. A **mutation** is a GraphQL client query that updates the state
    of a resource on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of a counter API. A counter API allows clients to increment
    and return the counter value. In REST, this is a `POST` method call. In GraphQL,
    we have to define mutations in the client query to create-then-fetch results from
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say the GraphQL schema looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The client query can fetch the count value for an `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This query fetches the counter value for `id:"250"`. It returns the following
    JSON if the count is `1` in the server (storage):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But how can this API be transformed into a create-then-fetch API? This can be
    done using GraphQL mutations and inputs.
  prefs: []
  type: TYPE_NORMAL
- en: A special type called `input` defines a query argument type on the GraphQL server.
    So far, we've only seen scalar types as arguments. We can also create custom types
    and pass them into a client query. Input is used as an argument of a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for `input` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining `input`, we can define a mutation that updates the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This mutation defines a query function that inputs `CounterInput` and updates
    its `value`. Let''s update our schema so that it includes these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a client should call a query in order to update a new value for `id: "250"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This client query updates a counter (`id: "250"`) value with `2` and returns
    the updated record''s ID and value. This is how GraphQL performs a create-then-fetch
    operation.'
  prefs: []
  type: TYPE_NORMAL
- en: A GraphQL query is equivalent to REST's `GET`.
  prefs: []
  type: TYPE_NORMAL
- en: A GraphQL mutation is equivalent to REST's `PUT`, `POST`, and `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge you've gained regarding types, schemas, queries, and mutations
    should be enough for you to understand how GraphQL functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll create a client query in Go and access GitHub's GraphQL
    API. This will confirm the theoretical knowledge we have gained so far.
  prefs: []
  type: TYPE_NORMAL
- en: Creating GraphQL clients in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the Go program is a client for the GraphQL server, the client should understand
    how to compose GraphQL queries correctly and send them to the server. Go cannot
    do that natively, but it can with the help of an external package called `machinebox/graphql`.
    This is a lightweight client that allows developers to send queries and mutations
    to servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install the package using the `dep` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a tool for fetching data from GitHub''s GraphQL API. For that,
    create a project directory called `graphqlClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The goal here is to fetch the details of all the available licenses for GitHub
    projects. GitHub provides an API to fetch all available licenses, but let's say
    we are only interested in the `Apache2.0` license. So, we proceed with the GitHub
    GraphQL API to fetch the license resource. To make API calls to GitHub, you should
    add a bearer token in the headers, along with the request.
  prefs: []
  type: TYPE_NORMAL
- en: We worked with the GitHub API in [Chapter 8](ceb99616-b12b-4ec0-9bd4-aedc74933273.xhtml), *Building
    a REST API Client in Go*, to create a CLI client. There, we used a `GITHUB_TOKEN`,
    which acts as a personal access token or bearer token for API requests. An access
    token is a string that's passed to authenticate a user. We assume that you have
    the access token at hand ([Chapter 8](ceb99616-b12b-4ec0-9bd4-aedc74933273.xhtml),
    *Building a REST API Client in Go*, to find out how and where to get it).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the necessary packages. We need the `graphql` package and some
    other standard packages such as `os` to read the access token and `log` to print
    the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We imported the `graphql` package as it is. If it is not available, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for the GitHub license looks like this (from the documentation:
    [https://developer.github.com/v4/object/license/](https://developer.github.com/v4/object/license/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many fields in the schema, but let''s assume we are only interested
    in name and description. So, create a struct in our main program that holds this
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `graphql` package provides a function called `NewClient` for creating a
    GraphQL client. It takes a GraphQL server endpoint as the only argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the client has been declared, we can create a new GraphQL client request
    using the `graphql.NewRequest` function. It takes a client query string as the
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have both the client and request objects, we can make queries. However, the
    GitHub API is secured and needs an access token for authorization. For that, we
    should add a header called `Authorization` with the `''bearer''` token. The header
    can be calculated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We should concatenate the GitHub access token with the `''bearer ''` string
    (*note the space after "r"*) to form a bearer token. We should pass the whole
    string as a header to the GitHub GraphQL server. The code for this looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are reading a personal access token from the environment variable
    and putting it into the `Authorization` header. After this, we should create a
    context and actually fire the request to the server using the `client.Run` function.
    To do this, we can declare an instance of the `Response` struct and pass it to
    the `Run` function. When the query is successful, the JSON response is loaded
    into the struct instance so that we can access the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, `respData` is the result struct that holds the response from the GraphQL
    server. Once we receive the response, we can log the description of the `Apache2.0`
    license to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the program and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the license description to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is how a Go client can interact with a GraphQL server. Client queries can
    be changed but the procedure always remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to implement a server that is similar
    to the GitHub GraphQL server that is powering API V4\. We'll take a simple example
    of a multiplayer game and try to define a schema API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating GraphQL servers in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve seen how to create a REST API. But how can we create a GraphQL
    API in Go or any other programming language? We can''t do this directly. We need
    the help of a few packages to build GraphQL servers that can handle requests from
    clients. Clients can be web-based or mobile. We need two vital things to build
    a GraphQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: Schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolvers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Schema is what we discussed in the early stage of this chapter. Resolvers,
    on the other hand, are solid entities that generate HTTP responses. The Schema
    only validates and routes the request to the corresponding resources; revolvers
    do the actual logic of computing the result, a database query, or any other backend
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll create a simple server that responds to queries for
    player data in a multiplayer game. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say the schema looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say the server should return this information. Let''s start implementing
    the service. We are going to mock data into our multiplayer game API. The same
    data can be queried from the database or can be fetched from a file. First, install
    the necessary packages. We need two packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`graphql-go`: For creating the schema and adding resolvers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql-go-handler`: For running a server that can route requests to resolvers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create the project repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can install both packages using the `dep` tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write our `main.go` file. It should contain all the necessary imports.
    The main imports are from the packages we installed along with `net/http`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define our dummy data, which we serve through resolvers. Define
    a struct that returns the response for the preceding client query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The previously defined constructs are a simple Go struct and a list. We'll use
    this information later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, define a player object using the `graphql.NewObject` function. This takes
    a `graphql.ObjectConfig` instance that defines the fields and their types for
    the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `graphql` package provides scalar types and composite types such as lists.
    The following is the definition of the player object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: These object fields will be mapped to the struct `Player` fields we defined
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes our main function. Here, we have to define three things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Root query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schema Config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A root query defines the root object while querying. A schema defines the structure
    of the GraphQL response. A new schema can be created from the schema config. Our
    main function does all these things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create a `fields` section and attach it to the root query. These fields
    have a `resolver` that gets called whenever a client makes a query. Let''s say
    we return all the players when someone queries the root object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a schema. But in order to serve it via HTTP, we should pass this
    schema to the `graphql-go` package''s `handler.New` function. We can also create
    an interactive GraphQL browser called `GraphiQL`. Let''s see how to do this in
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`handler.New` takes a schema as well as the option to prettify the GraphQL
    response. The GraphiQL option is used to enable the documentation and the interactive
    browser editor for the exposed API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the program, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This starts a GraphQL server on `localhost:8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a browser and visit `http://localhost:8000`. You should see the interactive
    GraphQL editor. Now, paste the following client query into the left-hand pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see the response that''s served by our GraphQL server in the right-hand
    pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The response contains mock data, but this data should be dynamically generated
    in a real-world API. For more details about creating advanced queries and mutations
    within the server, refer to the `graphql-go` documentation ([https://github.com/graphql-go/graphql](https://github.com/graphql-go/graphql)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use [GraphiQL](https://github.com/graphql/graphiql) (an interactive
    GraphQL editor) as an API documentation service for your GraphQL schema. It is
    similar to the Swagger API specification. See the GitHub interactive API editor
    for inspiration: [https://developer.github.com/v4/explorer/](https://developer.github.com/v4/explorer/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the semantics of APIs. An API can over-fetch
    or under-fetch results for clients. This can cause additional noise in the data.
    Bandwidth wastage can be a big issue too. To overcome this problem, GraphQL offers
    a flexible approach for requesting data from APIs. This allows developers to write
    pragmatic APIs that do exactly what is requested by the client.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we explored GraphQL in depth by understanding queries, mutations, schema,
    and types. We introduced many examples and saw what a GraphQL server response
    looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implemented a Go client for the Github API using a package called
    `machinebox/graphql`. After that, we created a server that responds to a client
    query.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss scaling APIs using microservices.
  prefs: []
  type: TYPE_NORMAL
