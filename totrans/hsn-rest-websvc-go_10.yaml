- en: GraphQL and Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL 和 Go
- en: In this chapter, we'll introduce a new query language called GraphQL. The traditional
    API definitions have failed to address the under-fetching and over-fetching APIs.
    An under-fetching API is an API that provides a minimum set of details for a given
    request. The drawback of this is that a developer should always create a new API
    or update the existing one. To overcome this, they can provide extra data that
    the clients can ignore safely. This causes another side effect; that is, it increases
    the payload size of the response. This situation is known as **over-fetching**.
    An over-fetching API provides unnecessary or unwanted data for clients. The response
    size is crucial when there are limitations regarding network bandwidth when designing
    APIs for clients.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一种名为 GraphQL 的新查询语言。传统的 API 定义未能解决欠取和过取 API 的问题。欠取 API 是指为特定请求提供最小细节集的
    API。其缺点是开发者必须始终创建新的 API 或更新现有的 API。为了克服这一点，他们可以提供客户端可以安全忽略的额外数据。这导致另一个副作用；那就是它增加了响应的有效负载大小。这种情况被称为**过取**。过取
    API 为客户端提供不必要的或不受欢迎的数据。当设计针对客户端的 API 时，如果网络带宽有限制，响应大小至关重要。
- en: GraphQL is a query language that solves this problem. In this chapter, we'll
    learn how a client can efficiently query data from an API using GraphQL. As with
    every framework, GraphQL also has a few limitations, but its positives outweigh
    them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是一种解决这个问题的查询语言。在本章中，我们将学习客户端如何使用 GraphQL 高效地从 API 中查询数据。与每个框架一样，GraphQL
    也有一些限制，但它的优点超过了这些限制。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is GraphQL?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 GraphQL？
- en: Over-fetching and under-fetching problems in the REST API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API 中的过取和欠取问题
- en: GraphQL basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 基础
- en: Creating GraphQL clients in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中创建 GraphQL 客户端
- en: Creating GraphQL servers in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中创建 GraphQL 服务器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software needs to be pre-installed in order to run the code samples
    in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章中的代码示例，以下软件需要预先安装：
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13
- en: Go stable version compiler >= 1.13.5
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 稳定版本编译器 >= 1.13.5
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dep: Go >= 0.5.3 的依赖管理工具'
- en: Docker version >= 18.09.2
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 版本 >= 18.09.2
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter10](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter10).
    Clone the code and use the code samples in the `chapter10` directory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter10](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter10)下载本章的代码。克隆代码并使用`chapter10`目录中的代码示例。
- en: What is GraphQL?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 GraphQL？
- en: '**GraphQL** is a query language that provides a set of rules. Using those rules
    and constructs, we can design an API that is efficient. According to the official
    documentation, the definition of GraphQL is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphQL** 是一种提供一组规则的查询语言。使用这些规则和结构，我们可以设计一个高效的 API。根据官方文档，GraphQL 的定义如下：'
- en: '"GraphQL provides a complete and understandable description of the data in
    your API, gives clients the power to ask for exactly what they need and nothing
    more, makes it easier to evolve APIs over time, and enables powerful developer
    tools."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '"GraphQL 提供了 API 中数据的完整和可理解的描述，赋予客户端请求所需数据的权力，而不需要更多，这使得 API 随时间演变更加容易，并使强大的开发者工具成为可能。"'
- en: '[-https://graphql.org/](https://graphql.org/)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[-https://graphql.org/](https://graphql.org/)'
- en: 'GraphQL provides a few features out of the box:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 提供了一些开箱即用的功能：
- en: Schema (a type system)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式（一种类型系统）
- en: Versionless API
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无版本 API
- en: Schema to Code
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模式到代码
- en: A GraphQL schema is a syntax for defining the boundaries of an API. The boundaries
    contain information about what server resources are exposed via the API. Since
    it allows an on-the-fly update of the schema without failing all the clients,
    it helps us create a versionless API. GraphQL provides client and server libraries
    for handling the resources defined in a schema.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 模式是定义 API 边界的语法。边界包含有关通过 API 暴露的服务器资源的信息。由于它允许在客户端失败之前动态更新模式，因此它帮助我们创建无版本
    API。GraphQL 为处理模式中定义的资源提供了客户端和服务器库。
- en: GraphQL is a language, not a runtime. So, someone has to translate a GraphQL
    schema to the code that a programming language can understand. A few GraphQL client
    and server libraries can do some automatic code generation from the schema definitions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是一种语言，而不是运行时。因此，有人必须将GraphQL模式翻译成编程语言可以理解的代码。一些GraphQL客户端和服务器库可以从模式定义中自动生成一些代码。
- en: Regarding its functionality, let's look at the differences between a traditional
    API and a GraphQL-powered API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于其功能，让我们看看传统API和GraphQL API之间的区别。
- en: For example, in e-commerce, a cart page or a wish list page fetches almost the
    same resources (most of the fields), such as product link, image, and cost. A
    few things do vary, however. For example, the cart page needs a shipping address
    but the wish list doesn't.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在电子商务中，购物车页面或愿望清单页面几乎获取相同的资源（大多数字段），如产品链接、图片和成本。然而，有一些事情是不同的。例如，购物车页面需要一个送货地址，而愿望清单则不需要。
- en: 'The API''s flow looks like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: API的流程如下：
- en: '![](img/cf6b7946-c329-402d-92d9-fb3675fa5cc3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf6b7946-c329-402d-92d9-fb3675fa5cc3.png)'
- en: 'Let''s say that the responses for the preceding requests appear as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面请求的响应如下所示：
- en: 'Cart page (web):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车页面（网页）：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Wish list (mobile):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 愿望清单（移动端）：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The API developer usually defines two endpoints, one for the cart and another
    for the wish list. If the content of both the responses contains almost the same
    data, they can merge them into one for maintainability. There could be a problem
    with over-fetching for one of the API calls.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: API开发者通常定义两个端点，一个用于购物车，另一个用于愿望清单。如果两个响应的内容几乎包含相同的数据，它们可以合并为一个以提高可维护性。对于API调用中的一个，可能会出现过度获取的问题。
- en: 'GraphQL gives the clients exactly what they need. The data that is passed over
    the wire is always as per the client''s request. The following diagram shows this
    in more detail:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL提供给客户端他们确切需要的东西。通过网络传输的数据始终符合客户端的请求。以下图表更详细地展示了这一点：
- en: '![](img/0c437ad9-633f-49cd-8573-0d5520c5feff.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c437ad9-633f-49cd-8573-0d5520c5feff.png)'
- en: The same API endpoint can be used for multiple clients that are accepting the
    same resources but not the difference in data fields. That is the beauty of GraphQL.
    We will look at more practical examples in the upcoming sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个API端点可以用于多个客户端，这些客户端接受相同的资源，但数据字段没有差异。这正是GraphQL的美丽之处。我们将在接下来的章节中查看更多实际示例。
- en: In the next section, we'll show you a solid example of how over-fetching and
    under-fetching can occur in an API.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向您展示一个如何在一个API中发生过度获取和不足获取的稳固示例。
- en: Over-fetching and under-fetching problems in the REST API
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API中的过度获取和不足获取问题
- en: '**Over-fetching** happens by an API when a server sends data that is not required
    by the client. The API is defined in advance and a client only needs to follow
    the API documentation. The drawback of this is that bandwidth is wasted. Let''s
    take a look at an example.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**过度获取**发生在API上，当服务器发送客户端不需要的数据时。API是预先定义的，客户端只需要遵循API文档。这种做法的缺点是带宽被浪费。让我们看看一个例子。'
- en: 'You are trying to make use of a GitHub user''s REST API to create a user tile
    display. The main intention here is to look at their followers, their public gist, their
    starred repositories, and the company name. However, when you make an API call
    to the GitHub API ([https://developer.github.com/v3/users/#get-a-single-user](https://developer.github.com/v3/users/#get-a-single-user))
    with the user `octocat`, it returns a JSON that looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你试图使用GitHub用户的REST API来创建用户头像显示。这里的主要目的是查看他们的关注者、他们的公开代码片段、他们标记的仓库和公司名称。然而，当你使用用户`octocat`调用GitHub
    API ([https://developer.github.com/v3/users/#get-a-single-user](https://developer.github.com/v3/users/#get-a-single-user))时，它返回了一个看起来像这样的JSON：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a big JSON file with spaces and newlines when you only need the aforementioned
    data fields. So, out of 37 fields, we are only going to consume four fields and
    ignore the rest.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大JSON文件，其中包含空格和换行符，而你只需要上述数据字段。因此，在37个字段中，我们只将消费四个字段，忽略其余的。
- en: Ignoring isn't a problem, but all the data traveled over the network to reach
    the client. This is an unwanted waste of bandwidth. This is called **over-fetching**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略并不是问题，但所有数据都通过网络传输到客户端。这是带宽的不必要浪费。这被称为**过度获取**。
- en: '**Under-fetching** is where a response that''s sent by an API server is not
    sufficient for making decisions for a client. That leads to the following conditions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**不足获取**是指API服务器发送的响应不足以让客户端做出决策。这导致以下条件：'
- en: A client has to make subsequent API calls to different endpoints to procure
    data.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须对不同的端点进行后续的API调用以获取数据。
- en: A client has to compute manually on top of procured data and then merge it.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须手动在获取的数据上计算，然后合并它们。
- en: This is a very inefficient approach as clients have very few resources compared
    to servers. For example, if a mobile device has to compute costly operations because
    of under-fetching, the API has to change its strategy to provide sufficient data.
    That can lead to over-fetching. Finding the right balance is always tricky.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常低效的方法，因为与服务器相比，客户端的资源非常有限。例如，如果移动设备因为数据获取不足而必须执行昂贵的操作，API必须改变其策略以提供足够的数据。这可能导致数据获取过多。找到正确的平衡总是很棘手。
- en: 'Let''s take the previous example of fetching user information from the GitHub
    API. To get the starred repositories, we have to call `User` and then use the `starred_url`
    API endpoint to make a further query:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前面从GitHub API获取用户信息的例子为例。要获取星标仓库，我们必须调用`User`，然后使用`starred_url` API端点进行进一步查询：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a classical under-fetching problem that limited the GitHub API until
    version 3 (V3). They mitigated this problem by introducing GraphQL API V4 ([https://developer.github.com/v4](https://developer.github.com/v4)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的欠获取问题，限制了GitHub API直到版本3（V3）。他们通过引入GraphQL API V4（[https://developer.github.com/v4](https://developer.github.com/v4)）来解决这个问题。
- en: GraphQL solves this problem by taking a whole new approach. It thinks about
    each entity as a resource and tries to build an API around it. This gives GraphQL
    the flexibility to compose data on the fly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL通过采取全新的方法来解决此问题。它将每个实体视为一个资源，并试图围绕它构建一个API。这使GraphQL能够动态组合数据。
- en: In the next section, we will look at the basics of GraphQL, such as syntax and
    definitions. This includes types, queries, and functions for manipulating data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨GraphQL的基础知识，如语法和定义。这包括类型、查询和用于操作数据的功能。
- en: GraphQL basics
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL基础知识
- en: 'A GraphQL schema is composed of many building blocks. These building blocks
    are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL模式由许多构建块组成。这些构建块如下：
- en: Types
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Queries
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询
- en: Functions
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Aliases
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名
- en: Variables
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Mutations
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更
- en: 'All these blocks are essential for building a functional GraphQL API. We can
    divide all of these components into two main categories:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些块对于构建一个功能性的GraphQL API都是必不可少的。我们可以将这些组件分为两大类：
- en: Schemas and types
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和类型
- en: Queries and mutations
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询和变更
- en: There are many features in each category, but we will only discuss the most
    important ones that can help you understand GraphQL. Let's take an example of
    fetching a user record from an API.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别中都有许多功能，但我们只会讨论那些可以帮助你理解GraphQL的最重要功能。让我们以从API获取用户记录为例。
- en: 'Note: All the snippets we show from here on are present in the intro directory
    of [Chapter10](f3dd906b-0446-4b33-a47a-cd2493804fb2.xhtml), *GraphQL and Go*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：从现在起，我们展示的所有代码片段都位于[第10章](f3dd906b-0446-4b33-a47a-cd2493804fb2.xhtml)“GraphQL和Go”的intro目录中。
- en: 'A typical GraphQL schema looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的GraphQL模式看起来像这样：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a GraphQL schema with three types: one special type called `Query`
    and two other custom types called `Person`  and `Address`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含三种类型的GraphQL模式：一个称为`Query`的特殊类型和两个其他自定义类型`Person`和`Address`。
- en: This schema is the specification of the API. It defines what types of resources
    are available for querying. It also defines one special type called `Query`, which
    is used by clients to query for data. In the preceding GraphQL schema, only a `user`
    of the  `Person` type can be queried.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式是API的规范。它定义了可用于查询的资源类型。它还定义了一个特殊类型，称为`Query`，客户端使用它来查询数据。在先前的GraphQL模式中，只能查询`Person`类型的`user`。
- en: 'A client query to the `/api/users` endpoint looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端对`/api/users`端点的查询看起来是这样的：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The server then sends sufficient information for the previously requested fields:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器随后发送足够的信息以供之前请求的字段使用：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the client doesn''t need the `address` field and only needs the `name` field,
    it can only request the `name` to the same endpoint, that is, `/api/users`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端不需要`address`字段而只需要`name`字段，它只能向同一端点请求`name`，即`/api/users`：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The server''s response may be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的响应可能如下所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This response has only retained the `name` field and omitted the `address` field.
    This can save a lot of bandwidth.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应只保留了`name`字段并省略了`address`字段。这可以节省大量的带宽。
- en: The shape of the GraphQL response directly matches the query, so clients can
    predict what they get back.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL响应的形状直接匹配查询，因此客户端可以预测他们能得到什么。
- en: We will learn about types and queries in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中学习类型和查询。
- en: Types and queries
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型与查询
- en: 'GraphQL has a type system that a server should know about in order to prepare
    the schema. There are four types of high-level:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL有一个类型系统，服务器应该了解以便准备模式。有四种高级类型：
- en: Object level
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象级别
- en: Field level
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段级别
- en: Non-nullable
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非空
- en: Enumeration
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Let's look at each type in detail.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每种类型。
- en: Object-level types
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象级别类型
- en: 'Object-level types are used to define object-level constructs such as queries
    and resources. They are useful for defining what resources and queries are allowed
    on an API. The following is what we saw in the previous example, where we defined
    a query:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对象级别类型用于定义对象级别结构，如查询和资源。它们对于定义API上允许的资源和方法非常有用。以下是我们前面例子中看到的内容，其中我们定义了一个查询：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These are special types and should not be confused with types in a programming
    language.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是特殊类型，不应与编程语言中的类型混淆。
- en: Field-level types
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段级别类型
- en: 'As the name suggests, field-level types are defined on a resource/query field.
    They are similar to the types in a programming language. It tells us what data
    type is going to be returned from the API. It can be further divided into two
    types:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，字段级别类型是在资源/查询字段上定义的。它们与编程语言中的类型相似。它告诉我们API将返回什么数据类型。它可以进一步分为两种类型：
- en: Scalar types (String, Int, Float, Boolean, ID)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量类型（String，Int，Float，Boolean，ID）
- en: Custom types (Address)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义类型（地址）
- en: 'In the previous example, the `Person` object-level type has the following fields:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Person` 对象级别类型有以下字段：
- en: '`name`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`'
- en: '`address`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`'
- en: 'The Go struct for the `Person` resource looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`资源的Go结构体看起来像这样：'
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `name` field has a type called `String`, while the `address` field has a
    type called `[Address]`, which is a list of addresses.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`字段有一个名为`String`的类型，而`address`字段有一个名为`[Address]`的类型，它是一组地址。'
- en: Non-nullable types
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非空类型
- en: This is a special type that uses normal field types with special syntax and
    makes fields mandatory. When a type has a field with a non-nullable type, it should
    return non-empty data to the client. The type is defined with ! (*exclamatory*)
    at the end.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊类型，它使用特殊语法的普通字段类型并使字段成为强制性的。当一个类型具有非空类型字段时，它应向客户端返回非空数据。类型以结尾的!（感叹号）定义。
- en: 'Take the `Person` type, for example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以`Person`类型为例：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we make the `name` field a non-nullable, it will look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`name`字段设置为非空，它将看起来像这样：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This means that if the client requests some data, the response must return
    a non-empty value for the `name` field. It cannot be null. We can also have a
    non-nullable list, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果客户端请求某些数据，则响应必须为`name`字段返回一个非空值。它不能为空。我们还可以有一个非空列表，如下所示：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding syntax can return zero or more elements of the `Address` type
    in the response.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法可以在响应中返回零个或多个`Address`类型的元素。
- en: 'If we need at least one address to be returned, then we can apply the non-nullable
    rule to list elements too:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要返回至少一个地址，则可以将非空规则应用于列表元素：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding rule creates an address field with a list of the `Address` type.
    That list should return at least one address to the clients.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述规则创建了一个包含`Address`类型列表的地址字段。该列表应至少返回一个地址给客户端。
- en: Next, we'll introduce another important type called `Enumeration`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍另一个重要的类型，称为`枚举`。
- en: Enumerations
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: '**Enumerations** (**Enums**) are special types that give flexibility in defining
    a range of scalar types. They can be helpful for passing a range of information
    to the client. It brings the following benefits to an API:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举**（**Enums**）是特殊类型，在定义一系列标量类型时提供了灵活性。它们对于向客户端传递一系列信息非常有用。它给API带来了以下好处：'
- en: It allows an API to validate the field with a set of types.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许API使用一组类型验证字段。
- en: Without throwing out the type system, it communicates that the accessible field
    value will be in a finite set.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不放弃类型系统的情况下，它表明可访问的字段值将位于一个有限集合中。
- en: 'Let''s take a look at an example schema:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例模式：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this GraphQL schema, we have a query type defined with `vehicle` as a field.
    `Vehicle` is an `Enum`. The vehicle has `Car` and `Bus` as its members. This means
    the query to this schema can expect either a `Car` or a `Bus`. This gives us flexibility
    over the predefined type systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个GraphQL模式中，我们定义了一个以`vehicle`为字段的查询类型。`Vehicle`是一个枚举。车辆有`Car`和`Bus`作为其成员。这意味着对这个模式的查询可以期望得到一个`Car`或`Bus`。这给了我们比预定义类型系统更多的灵活性。
- en: In this section, we covered the basics for defining a schema and what types
    we can define. In the next section, we'll learn how to write advanced queries
    from the client while fetching data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们介绍了定义模式的基础以及我们可以定义的类型。在下一节中，我们将学习如何在客户端编写高级查询以获取数据。 '
- en: Queries and mutations
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询和突变
- en: So far, we've seen how the client GraphQL query works. It describes the fields
    regarding the data that should be supplied. But what if we need data about certain
    criteria? Can we query with some values? Yes! GraphQL is built on querying and
    it provides a variety of options we can use while querying.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了客户端 GraphQL 查询的工作方式。它描述了应该提供的数据相关的字段。但如果我们需要关于某些标准的数据呢？我们可以用一些值进行查询吗？是的！GraphQL
    是基于查询构建的，它提供了我们在查询时可以使用的各种选项。
- en: 'Let''s go back to the initial example we showcased, that is, a user''s API
    with `name` and `address`. The client query looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们最初展示的初始示例，即具有 `name` 和 `address` 的用户 API。客户端查询如下所示：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding query fetches all the users from the GraphQL server. We can also
    query a record by using the name. The query syntax uses curved brackets and parenthesis
    (:) on a field. Let''s retrieve users whose name is `"alice"`. The preceding client
    query should be modified using parenthesis, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询从 GraphQL 服务器获取所有用户。我们也可以通过名称查询一条记录。查询语法在字段上使用括号和冒号（:）。让我们检索名为 `"alice"`
    的用户。前面的客户端查询应该使用括号进行修改，如下所示：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This query only fetches a record/records whose name is `"alice"`. This construct
    is similar to a function call in programming languages. `name: "alice"` is called
    an `argument` for the query.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '此查询仅获取名为 `"alice"` 的记录/记录。这种结构类似于编程语言中的函数调用。`name: "alice"` 被称为查询的 `参数`。'
- en: 'The GraphQL client can query using query arguments. The values for arguments
    can be scalar values, custom types, or even enumerations. We can also query on
    multiple levels. For example, let''s search for a user with `name "alice"` that
    comes from `city: "Munich"`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'GraphQL 客户端可以使用查询参数进行查询。参数的值可以是标量值、自定义类型，甚至是枚举。我们也可以在多个级别上进行查询。例如，让我们搜索一个名为
    `name "alice"` 且来自 `city: "Munich"` 的用户：'
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Querying on multiple levels avoids the concept of multiple API endpoint fetches.
    The same API endpoint can flexibly change the data that is returned.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个级别上进行查询避免了多个 API 端点获取的概念。相同的 API 端点可以灵活地更改返回的数据。
- en: Mutations and inputs
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突变和输入
- en: A REST API has methods such as `GET`, `POST`, `PUT`, and `DELETE`. The method
    itself describes the operation of the API call. Does GraphQL have something similar?
    Yes – mutations. A **mutation** is a GraphQL client query that updates the state
    of a resource on the server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 有 `GET`、`POST`、`PUT` 和 `DELETE` 等方法。方法本身描述了 API 调用的操作。GraphQL 有类似的东西吗？是的——突变。**突变**
    是一个更新服务器上资源状态的 GraphQL 客户端查询。
- en: Let's look at an example of a counter API. A counter API allows clients to increment
    and return the counter value. In REST, this is a `POST` method call. In GraphQL,
    we have to define mutations in the client query to create-then-fetch results from
    the server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个计数器 API 的示例。计数器 API 允许客户端增加并返回计数器的值。在 REST 中，这是一个 `POST` 方法调用。在 GraphQL
    中，我们必须在客户端查询中定义突变来从服务器创建并获取结果。
- en: 'Say the GraphQL schema looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 GraphQL 模式如下所示：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The client query can fetch the count value for an `id`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端查询可以获取 `id` 的计数值：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This query fetches the counter value for `id:"250"`. It returns the following
    JSON if the count is `1` in the server (storage):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询获取 `id:"250"` 的计数器值。如果服务器（存储）中的计数为 `1`，则返回以下 JSON：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But how can this API be transformed into a create-then-fetch API? This can be
    done using GraphQL mutations and inputs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何将此 API 转换为创建后获取的 API？这可以通过使用 GraphQL 突变和输入来完成。
- en: A special type called `input` defines a query argument type on the GraphQL server.
    So far, we've only seen scalar types as arguments. We can also create custom types
    and pass them into a client query. Input is used as an argument of a mutation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `input` 的特殊类型在 GraphQL 服务器上定义了一个查询参数类型。到目前为止，我们只看到了标量类型作为参数。我们也可以创建自定义类型并将它们传递到客户端查询中。输入用作突变的参数。
- en: 'The syntax for `input` looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`input` 的语法如下所示：'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After defining `input`, we can define a mutation that updates the state:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `input` 后，我们可以定义一个更新状态的突变：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This mutation defines a query function that inputs `CounterInput` and updates
    its `value`. Let''s update our schema so that it includes these changes:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此突变定义了一个输入 `CounterInput` 的查询函数并更新其 `value`。让我们更新我们的模式，使其包括这些更改：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, a client should call a query in order to update a new value for `id: "250"`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，客户端应该调用一个查询来更新`id: "250"`的新值：'
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This client query updates a counter (`id: "250"`) value with `2` and returns
    the updated record''s ID and value. This is how GraphQL performs a create-then-fetch
    operation.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '这个客户端查询将计数器（`id: "250"`）的值更新为`2`，并返回更新记录的ID和值。这就是GraphQL如何执行创建然后获取操作。'
- en: A GraphQL query is equivalent to REST's `GET`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL查询等同于REST的`GET`。
- en: A GraphQL mutation is equivalent to REST's `PUT`, `POST`, and `DELETE`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL突变等同于REST的`PUT`、`POST`和`DELETE`。
- en: The knowledge you've gained regarding types, schemas, queries, and mutations
    should be enough for you to understand how GraphQL functions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你关于类型、模式、查询和突变的了解应该足够你理解GraphQL是如何工作的。
- en: In the next section, we'll create a client query in Go and access GitHub's GraphQL
    API. This will confirm the theoretical knowledge we have gained so far.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个Go客户端查询并访问GitHub的GraphQL API。这将证实我们迄今为止所获得的理论知识。
- en: Creating GraphQL clients in Go
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中创建GraphQL客户端
- en: When the Go program is a client for the GraphQL server, the client should understand
    how to compose GraphQL queries correctly and send them to the server. Go cannot
    do that natively, but it can with the help of an external package called `machinebox/graphql`.
    This is a lightweight client that allows developers to send queries and mutations
    to servers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当Go程序是GraphQL服务器的客户端时，客户端应该了解如何正确地组合GraphQL查询并将它们发送到服务器。Go本身不能这样做，但可以通过一个名为`machinebox/graphql`的外部包来实现。这是一个轻量级的客户端，允许开发者向服务器发送查询和突变。
- en: 'We can install the package using the `dep` tool:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`dep`工具来安装包：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s write a tool for fetching data from GitHub''s GraphQL API. For that,
    create a project directory called `graphqlClient`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个从GitHub的GraphQL API获取数据的工具。为此，创建一个名为`graphqlClient`的项目目录：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The goal here is to fetch the details of all the available licenses for GitHub
    projects. GitHub provides an API to fetch all available licenses, but let's say
    we are only interested in the `Apache2.0` license. So, we proceed with the GitHub
    GraphQL API to fetch the license resource. To make API calls to GitHub, you should
    add a bearer token in the headers, along with the request.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是获取GitHub项目中所有可用许可证的详细信息。GitHub提供了一个API来获取所有可用的许可证，但让我们假设我们只对`Apache2.0`许可证感兴趣。因此，我们使用GitHub
    GraphQL API来获取许可证资源。为了向GitHub进行API调用，你应该在头部添加一个bearer令牌，以及请求。
- en: We worked with the GitHub API in [Chapter 8](ceb99616-b12b-4ec0-9bd4-aedc74933273.xhtml), *Building
    a REST API Client in Go*, to create a CLI client. There, we used a `GITHUB_TOKEN`,
    which acts as a personal access token or bearer token for API requests. An access
    token is a string that's passed to authenticate a user. We assume that you have
    the access token at hand ([Chapter 8](ceb99616-b12b-4ec0-9bd4-aedc74933273.xhtml),
    *Building a REST API Client in Go*, to find out how and where to get it).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](ceb99616-b12b-4ec0-9bd4-aedc74933273.xhtml)，*在Go中构建REST API客户端*中与GitHub
    API一起工作，以创建一个CLI客户端。在那里，我们使用了`GITHUB_TOKEN`，它作为API请求的个人访问令牌或bearer令牌。访问令牌是一个字符串，用于验证用户。我们假设你手头有访问令牌（[第8章](ceb99616-b12b-4ec0-9bd4-aedc74933273.xhtml)，*在Go中构建REST
    API客户端*，以了解如何以及在哪里获取它）。
- en: 'First, import the necessary packages. We need the `graphql` package and some
    other standard packages such as `os` to read the access token and `log` to print
    the response:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入必要的包。我们需要`graphql`包和一些其他标准包，例如`os`来读取访问令牌和`log`来打印响应：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We imported the `graphql` package as it is. If it is not available, run the
    following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像这样导入了`graphql`包。如果它不可用，请运行以下命令：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The response for the GitHub license looks like this (from the documentation:
    [https://developer.github.com/v4/object/license/](https://developer.github.com/v4/object/license/)):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub许可证的响应如下（来自文档：[https://developer.github.com/v4/object/license/](https://developer.github.com/v4/object/license/)):'
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are many fields in the schema, but let''s assume we are only interested
    in name and description. So, create a struct in our main program that holds this
    data structure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 模式中有很多字段，但让我们假设我们只对名称和描述感兴趣。因此，在我们的主程序中创建一个结构体来保存这个数据结构：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `graphql` package provides a function called `NewClient` for creating a
    GraphQL client. It takes a GraphQL server endpoint as the only argument.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`graphql`包提供了一个名为`NewClient`的函数来创建GraphQL客户端。它只接受一个GraphQL服务器端点作为参数。'
- en: 'Once the client has been declared, we can create a new GraphQL client request
    using the `graphql.NewRequest` function. It takes a client query string as the
    argument:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了客户端，我们就可以使用 `graphql.NewRequest` 函数创建一个新的 GraphQL 客户端请求。它接受一个客户端查询字符串作为参数：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once we have both the client and request objects, we can make queries. However, the
    GitHub API is secured and needs an access token for authorization. For that, we
    should add a header called `Authorization` with the `''bearer''` token. The header
    can be calculated like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了客户端和请求对象，我们就可以进行查询。然而，GitHub API 是受保护的，需要访问令牌进行授权。为此，我们应该添加一个名为 `Authorization`
    的头信息，并包含 `'bearer'` 令牌。头信息可以计算如下：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We should concatenate the GitHub access token with the `''bearer ''` string
    (*note the space after "r"*) to form a bearer token. We should pass the whole
    string as a header to the GitHub GraphQL server. The code for this looks like
    this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将 GitHub 访问令牌与 `'bearer '` 字符串连接（注意 "r" 后面的空格），以形成一个 bearer 令牌。我们应该将整个字符串作为头信息传递给
    GitHub GraphQL 服务器。相应的代码如下：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we are reading a personal access token from the environment variable
    and putting it into the `Authorization` header. After this, we should create a
    context and actually fire the request to the server using the `client.Run` function.
    To do this, we can declare an instance of the `Response` struct and pass it to
    the `Run` function. When the query is successful, the JSON response is loaded
    into the struct instance so that we can access the result:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从环境变量中读取一个个人访问令牌，并将其放入 `Authorization` 头信息中。之后，我们应该创建一个上下文，并使用 `client.Run`
    函数向服务器发送请求。为此，我们可以声明一个 `Response` 结构体实例，并将其传递给 `Run` 函数。当查询成功时，JSON 响应被加载到结构体实例中，这样我们就可以访问结果：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `respData` is the result struct that holds the response from the GraphQL
    server. Once we receive the response, we can log the description of the `Apache2.0`
    license to the console.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`respData` 是一个结果结构体，它包含了从 GraphQL 服务器返回的响应。一旦我们收到响应，我们就可以将 `Apache2.0` 许可证的描述记录到控制台。
- en: 'Let''s run the program and see the output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行程序并查看输出：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This prints the license description to the console:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将许可证描述打印到控制台：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is how a Go client can interact with a GraphQL server. Client queries can
    be changed but the procedure always remains the same.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Go 客户端如何与 GraphQL 服务器交互。客户端查询可以更改，但程序始终相同。
- en: In the next section, we will learn how to implement a server that is similar
    to the GitHub GraphQL server that is powering API V4\. We'll take a simple example
    of a multiplayer game and try to define a schema API.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何实现一个类似于推动 API V4 的 GitHub GraphQL 服务器的服务器。我们将以一个简单的多人游戏为例，并尝试定义一个模式
    API。
- en: Creating GraphQL servers in Go
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中创建 GraphQL 服务器
- en: 'So far, we''ve seen how to create a REST API. But how can we create a GraphQL
    API in Go or any other programming language? We can''t do this directly. We need
    the help of a few packages to build GraphQL servers that can handle requests from
    clients. Clients can be web-based or mobile. We need two vital things to build
    a GraphQL server:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何创建 REST API。但在 Go 或其他编程语言中，我们如何创建 GraphQL API 呢？我们不能直接这样做。我们需要一些包的帮助来构建可以处理客户端请求的
    GraphQL 服务器。客户端可以是基于 Web 或移动的。构建 GraphQL 服务器需要两个关键要素：
- en: Schema
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式
- en: Resolvers
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器
- en: The Schema is what we discussed in the early stage of this chapter. Resolvers,
    on the other hand, are solid entities that generate HTTP responses. The Schema
    only validates and routes the request to the corresponding resources; revolvers
    do the actual logic of computing the result, a database query, or any other backend
    operation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是我们在本章早期阶段讨论的内容。另一方面，解析器是生成 HTTP 响应的实体。模式仅验证并路由请求到相应的资源；解析器执行实际的逻辑计算结果，如数据库查询或任何其他后端操作。
- en: 'In this section, we''ll create a simple server that responds to queries for
    player data in a multiplayer game. Let''s get started:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个简单的服务器，该服务器响应多人游戏中玩家数据的查询。让我们开始吧：
- en: 'Let''s say the schema looks like this:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设模式如下：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s say the server should return this information. Let''s start implementing
    the service. We are going to mock data into our multiplayer game API. The same
    data can be queried from the database or can be fetched from a file. First, install
    the necessary packages. We need two packages:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设服务器应该返回这些信息。让我们开始实现这个服务。我们将模拟数据到我们的多人游戏 API 中。相同的数据可以从数据库中查询，或者从文件中获取。首先，安装必要的包。我们需要两个包：
- en: '`graphql-go`: For creating the schema and adding resolvers'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql-go`：用于创建模式和添加解析器'
- en: '`graphql-go-handler`: For running a server that can route requests to resolvers'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql-go-handler`：用于运行可以将请求路由到解析器的服务器'
- en: 'Let''s create the project repository:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建项目仓库：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can install both packages using the `dep` tool:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `dep` 工具安装这两个包：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s write our `main.go` file. It should contain all the necessary imports.
    The main imports are from the packages we installed along with `net/http`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写我们的 `main.go` 文件。它应该包含所有必要的导入。主要导入来自我们安装的包以及 `net/http`：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s define our dummy data, which we serve through resolvers. Define
    a struct that returns the response for the preceding client query:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的模拟数据，我们将通过解析器提供这些数据。定义一个结构体，它返回先前客户端查询的响应：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The previously defined constructs are a simple Go struct and a list. We'll use
    this information later.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的结构是一个简单的 Go 结构体和一个列表。我们稍后会使用这些信息。
- en: Now, define a player object using the `graphql.NewObject` function. This takes
    a `graphql.ObjectConfig` instance that defines the fields and their types for
    the object.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `graphql.NewObject` 函数定义一个玩家对象。这需要一个 `graphql.ObjectConfig` 实例，它定义了对象的字段及其类型。
- en: 'The `graphql` package provides scalar types and composite types such as lists.
    The following is the definition of the player object:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`graphql` 包提供了标量类型和复合类型，如列表。以下是对玩家对象的定义：'
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These object fields will be mapped to the struct `Player` fields we defined
    previously.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象字段将被映射到我们之前定义的 `Player` 结构体字段。
- en: 'Next comes our main function. Here, we have to define three things:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的主函数。在这里，我们必须定义三件事：
- en: Root query
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根查询
- en: Schema Config
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式配置
- en: Schema
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式
- en: A root query defines the root object while querying. A schema defines the structure
    of the GraphQL response. A new schema can be created from the schema config. Our
    main function does all these things.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 根查询定义了查询时的根对象。一个模式定义了 GraphQL 响应的结构。可以从模式配置创建一个新的模式。我们的主函数做了所有这些事情。
- en: 'Then, we create a `fields` section and attach it to the root query. These fields
    have a `resolver` that gets called whenever a client makes a query. Let''s say
    we return all the players when someone queries the root object:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `fields` 部分，并将其附加到根查询。这些字段有一个 `resolver`，当客户端进行查询时会被调用。比如说，当有人查询根对象时，我们返回所有玩家：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we have a schema. But in order to serve it via HTTP, we should pass this
    schema to the `graphql-go` package''s `handler.New` function. We can also create
    an interactive GraphQL browser called `GraphiQL`. Let''s see how to do this in
    code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有一个模式。但是，为了通过 HTTP 提供它，我们应该将此模式传递给 `graphql-go` 包的 `handler.New` 函数。我们还可以创建一个名为
    `GraphiQL` 的交互式 GraphQL 浏览器。让我们看看如何在代码中实现这一点：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`handler.New` takes a schema as well as the option to prettify the GraphQL
    response. The GraphiQL option is used to enable the documentation and the interactive
    browser editor for the exposed API.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler.New` 接受一个模式以及用于美化 GraphQL 响应的选项。GraphiQL 选项用于启用暴露的 API 的文档和交互式浏览器编辑器。'
- en: 'Now, run the program, like this:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行程序，如下所示：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This starts a GraphQL server on `localhost:8000`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `localhost:8000` 上启动一个 GraphQL 服务器。
- en: 'Open a browser and visit `http://localhost:8000`. You should see the interactive
    GraphQL editor. Now, paste the following client query into the left-hand pane:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并访问 `http://localhost:8000`。你应该能看到交互式的 GraphQL 编辑器。现在，将以下客户端查询粘贴到左侧面板：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You''ll see the response that''s served by our GraphQL server in the right-hand
    pane:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在右侧面板看到我们的 GraphQL 服务器提供的响应：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The response contains mock data, but this data should be dynamically generated
    in a real-world API. For more details about creating advanced queries and mutations
    within the server, refer to the `graphql-go` documentation ([https://github.com/graphql-go/graphql](https://github.com/graphql-go/graphql)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含模拟数据，但在现实世界的 API 中，这些数据应该是动态生成的。有关在服务器内创建高级查询和变异的更多详细信息，请参阅 `graphql-go`
    文档 ([https://github.com/graphql-go/graphql](https://github.com/graphql-go/graphql))。
- en: 'You can use [GraphiQL](https://github.com/graphql/graphiql) (an interactive
    GraphQL editor) as an API documentation service for your GraphQL schema. It is
    similar to the Swagger API specification. See the GitHub interactive API editor
    for inspiration: [https://developer.github.com/v4/explorer/](https://developer.github.com/v4/explorer/).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 [GraphiQL](https://github.com/graphql/graphiql)（一个交互式的 GraphQL 编辑器）作为你的
    GraphQL 模式的 API 文档服务。它与 Swagger API 规范类似。查看 GitHub 交互式 API 编辑器以获取灵感：[https://developer.github.com/v4/explorer/](https://developer.github.com/v4/explorer/)。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood the semantics of APIs. An API can over-fetch
    or under-fetch results for clients. This can cause additional noise in the data.
    Bandwidth wastage can be a big issue too. To overcome this problem, GraphQL offers
    a flexible approach for requesting data from APIs. This allows developers to write
    pragmatic APIs that do exactly what is requested by the client.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了API的语义。API可能会对客户端过度或不足地检索结果，这可能导致数据中产生额外的噪声。带宽浪费也可能成为一个大问题。为了克服这个问题，GraphQL提供了一种灵活的方法来从API请求数据。这允许开发者编写实用的API，这些API正好满足客户端的需求。
- en: Then, we explored GraphQL in depth by understanding queries, mutations, schema,
    and types. We introduced many examples and saw what a GraphQL server response
    looks like.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过理解查询、变更、模式和类型来深入探讨了GraphQL。我们介绍了许多示例，并看到了GraphQL服务器响应的样子。
- en: Finally, we implemented a Go client for the Github API using a package called
    `machinebox/graphql`. After that, we created a server that responds to a client
    query.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用名为`machinebox/graphql`的包为GitHub API实现了一个Go客户端。之后，我们创建了一个响应客户端查询的服务器。
- en: In the next chapter, we will discuss scaling APIs using microservices.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用微服务来扩展API。
