<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Scaling our REST API Using Microservices</h1>
                </header>
            
            <article>
                
<p class="mce-root">Building a REST API is easy in terms of the concept. But scaling it to accept huge traffic is a challenge. Till now, we've looked into the details of creating REST API structures and sample REST APIs. In this chapter, we are going to explore Go Micro, a wonderful, idiomatic Go package for building microservices.</p>
<p class="mce-root">This is the age of microservices, where huge applications are commonly broken down into loosely coupled components. The microservice architecture allows companies to quickly iterate in parallel. We will start by defining the term <em>microservices</em>, and then move on to Go Micro by creating <strong>Remote Procedure Call</strong> (<strong>RPC</strong>)-/REST-style microservices.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What are microservices?</li>
<li>Monoliths versus microservices</li>
<li>Introducing Go Micro, a package for building microservices</li>
<li>Adding logging to the microservices</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The following software should be pre-installed for running code samples:</p>
<ul>
<li>OS: Linux (Ubuntu 18.04)/Windows 10/<span>Mac OS X </span> &gt;= 10.13</li>
<li>Go stable version compiler &gt;= 1.13.5</li>
<li>Dep: A dependency management tool for Go &gt;= 0.5.3</li>
<li>Docker version &gt;= 18.09.2</li>
</ul>
<p><span>You can download the code for this chapter from <a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter11" target="_blank">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter11</a></span><span>. Clone the code, and use the code samples in the</span> <kbd>chapter11</kbd> <span>directory.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are microservices?</h1>
                </header>
            
            <article>
                
<p>What are microservices? This is the question the enterprise world is asking the computing world. The sustainability of a product depends on how easily modifiable it is. Huge products should retire at some point in time if they cannot be maintained properly. The microservice architecture replaces the traditional monolith with granular services that talk to each other in some kind of agreement.</p>
<p>Microservices bring the following benefits to the table:</p>
<ul>
<li>Small teams can iterate in parallel by working on a small set of features.</li>
<li>Adaptability is easy for new developers.</li>
<li>They allow <strong>Continuous Integration</strong> (<strong>CI</strong>) and <strong>Continuous</strong> <strong>Delivery</strong> (<strong>CD</strong>) for individual components of a system.</li>
<li>They offer easily replaceable software with a loosely coupled architecture.</li>
<li>The architecture is not coupled to a specific technology</li>
</ul>
<p>In a monolithic application (<em>traditional application</em>), a single application serves the incoming requests by sharing the computing power. It is good because we have everything in one place, and it is easily manageable. But there are few problems with monoliths, such as the following:</p>
<ul>
<li>A tightly coupled architecture.</li>
<li>A single point of failure.</li>
<li>The velocity of adding new features and components.</li>
<li>The fragmentation of work is limited to teams.</li>
<li><strong>Continuous</strong><span> </span><strong>Delivery</strong><span> (</span><strong>CD</strong><span>)</span> is tough because an entire application needs to be redeployed for a small change.</li>
</ul>
<p>In a monolithic application, the entire software is treated as a single entity. If the database fails, the app fails. If a bug in the code crashes the software application, the entire connectivity with clients goes down. This requirement paved the way for microservices.</p>
<p>Let's take a scenario. A company run by Bob uses the traditional monolith model, where developers work around the clock to add new features. At the time of a software release, people need to test the code overall for every small component. The project moves from development to testing, when all changes are done.</p>
<p>Another company on the next street, run by Alice, uses a microservices architecture. The software developers in Alice's company work on individual services, who in turn test their individual components. The developers talk with each other's REST/RPC API to add new features. They can easily shift their stack from one technology to another, as compared to Bob's team.</p>
<p>This example shows that Alice's company is highly flexible than Bob's.</p>
<p>Orchestration and service discovery are very important aspects to consider when talking about microservices. A tool such as Kubernetes can be used to orchestrate the Docker containers. Generally, it is a good practice to have a Docker container per microservice.</p>
<p><strong>Service discovery</strong> is the automatic detection of the <span>IP address of a microservice instance on the fly</span>. This removes the potential threat of hardcoding the IP addresses, which can cause a lack of connectivity between services. In the next section, we'll use a diagram to understand what is the crucial difference between a monolith and microservice.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monoliths versus microservices</h1>
                </header>
            
            <article>
                
<p>It is a common practice to begin a software application as a monolith, and then break it down into microservices in the long run. This actually helps to focus on the application delivery, instead of blindly following the microservice pattern. Once the product is stabilized, then developers should find a way to break down product features. Take a look at the following diagram for the difference between a monolith and microservices:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/0228d9b8-e898-42e0-8aa2-dd5cb9175ea5.png"/></div>
<p>This diagram depicts the structure of monolithic and microservices architectures. A monolith has everything wrapped in a single system. It is called a <strong>tightly coupled</strong> architecture. In contrast, microservices are individual entities that are easy to replace and modifiable. Each microservice can talk to one another through various transport mechanisms, such as HTTP, REST, or RPC. The data format exchanged between services could be either JSON or Protocol buffers. Microservices can also handle various request entry points, such as <strong>UI</strong> and <strong>API clients</strong>.</p>
<p>Microservices can be implemented in any technology (Java, Go, Python, and so on), and can be replaced with any technology because of their loosely coupled nature.</p>
<p>In the next section, we explore how to create microservices in Go using a lightweight framework called Go Micro. There, we see how to develop mini services that can talk to each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Go Micro, a package for building microservices</h1>
                </header>
            
            <article>
                
<p>Netflix's Eureka and Spring Boot from the Java community are famous for building microservices. The Go Micro package provides the same set of features. It is a toolkit for building microservices in Go. It is lightweight, which means start small and go big.</p>
<p>It has a Go style of adding services, which makes developers feel good. In the upcoming sections, we will see how to create a microservice with the steps defined by Go Micro. Go Micro provides requirements to implement RPC and <strong>event-driven architectures</strong> (<strong>EDAs</strong>). It also has a pluggable interface where we can plug any external functionality.</p>
<p>The main features supported by Go Micro are as follows:</p>
<ul>
<li>Request/response</li>
<li>Service discovery</li>
<li>Load balancing</li>
<li>Message encoding</li>
<li>Async messaging</li>
<li>Pluggable interfaces</li>
</ul>
<p><strong>Request/response</strong> is a plain HTTP/RPC call. <strong>Service discovery</strong> is useful for finding microservice instances at runtime. <strong>Load balancing</strong> is for routing requests to multiple same-type applications. <strong>Message encoding</strong> is essential for services to understand each other. <strong>Async messaging</strong> involves the generation and consumption of events. Go Micro's <strong>pluggable interfaces</strong> provide functionality such as codecs for translation, and brokers for storage systems.</p>
<p>Install Go Micro using the <kbd>dep</kbd> tool in any project in this way:</p>
<pre class="mce-root">&gt;<strong> dep init<br/></strong>&gt;<strong> dep ensure -add  "github.com/micro/go-micro"</strong></pre>
<p>In the next section, we lay down the plan for our first microservice. We see how to encrypt and decrypt messages in Go. We will then build an encrypting/decrypting service using Go Micro.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding encryption</h1>
                </header>
            
            <article>
                
<p>We all know about the encryption of messages. <strong>Encryption</strong> is a process that uses a base message and a key to produce an encoded message through a mathematical algorithm that can only be decoded using the original key. That message can be passed over the wire. The recipient decrypts the message with a key and gets back the original message. We are going to create a microservice that provides both encryption and decryption.</p>
<p>See the plan for the development of our first microservice:</p>
<ol>
<li>Develop utility functions for encryption/decryption.</li>
<li>Then, integrate it with Go Micro to produce a service.</li>
</ol>
<p>Go comes with packages for encrypting m<span>essages. We need to import encrypting algorithms from those packages and use them. For that, we create a</span><span> </span>project <span>that uses the</span> <strong>Advanced Encryption Standard</strong> <span>(</span><strong>AES</strong><span>), as in the following steps:</span></p>
<ol>
<li>Create a directory called <kbd>encryptString</kbd> in your <kbd>GOPATH/src/github.com</kbd> directory, as follows:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> mkdir -p $GOPATH/src/github.com/git-user/chapter11/encryptString<br/></strong><strong>cd </strong><strong>$GOPATH/src/github.com/git-user/chapter11/encryptString</strong></pre>
<ol start="2">
<li>Then, add one more file in the new directory, called <kbd>utils</kbd>. Add <kbd>main.go</kbd> in the project directory and <kbd>utils.go</kbd> in the new <kbd>utils</kbd> directory. The directory structure looks like this:</li>
</ol>
<pre style="padding-left: 60px">└── encryptString<br/>    ├── main.go<br/>    └── utils<br/>        └── utils.go</pre>
<ol start="3">
<li>Now, let's add the logic of encryption in our <kbd>utils.go</kbd> file. We create two functions, one for encryption and another for the decryption of a message. First, import the necessary packages, <kbd>crypto</kbd> and <kbd>encoding</kbd>, as shown in the following code block:</li>
</ol>
<div>
<pre style="padding-left: 60px">package utils<br/>import (<br/>    "crypto/aes"<br/>    "crypto/cipher"<br/>    "encoding/base64"<br/>)</pre></div>
<ol start="4">
<li>The AES algorithm takes an initialization vector. The vector is an arbitrary byte array that can be used along with a secret key for data encryption. Define it like this:</li>
</ol>
<div>
<pre style="padding-left: 60px">/* Initialization vector for the AES algorithm<br/>More details visit this link https://en.wikipedia.org/wiki/Advanced_Encryption_Standard */<br/>var initVector = []byte{35, 46, 57, 24, 85, 35, 24, 74, 87, 35, 88, 98, 66, 32, 14, 05}</pre></div>
<p style="padding-left: 60px">The values in the vector can also be generated randomly. Here, we use a predefined vector.</p>
<ol start="5">
<li>Now, let's implement the logic for encryption. It declares a new cipher using the <kbd>aes.NewCipher</kbd> and <kbd>aes.NewCFBEncryptor</kbd> functions. Then, we execute a function called <kbd>XORKeyStream</kbd> on the cipher to get the encrypted string. <span>Then, we need to do a <kbd>base64</kbd> encoding to generate the protected string, like so:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">// EncryptString encrypts the string with given key<br/>func EncryptString(key, text string) string {<br/>    block, err := aes.NewCipher([]byte(key))<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    plaintext := []byte(text)<br/>    cfb := cipher.NewCFBEncrypter(block, initVector)<br/>    ciphertext := make([]byte, len(plaintext))<br/>    cfb.XORKeyStream(ciphertext, plaintext)<br/>    return base64.StdEncoding.EncodeToString(ciphertext)<br/>}</pre></div>
<ol start="6">
<li>Next, <span>in the same way, let's define a <kbd>DecryptString</kbd> function that takes a key and <kbd>ciphertext</kbd> and generates an original message. In the <kbd>DecryptString</kbd> function, first, decode the <kbd>base64</kbd> encoded text and create a cipher block with the key. Pass this cipher block with the initialization vector to <kbd>NewCFBEncrypter</kbd>.</span></li>
<li>Then, use <kbd>XORKeyStream</kbd> <span>to load content from <kbd>ciphertext</kbd> to <kbd>plaintext</kbd>. Basically, it is a process of swapping the encrypted and decrypted messages in</span> <kbd>XORKeyStream</kbd><span>. The code looks like this:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">// DecryptString decrypts the encrypted string to original<br/>func DecryptString(key, text string) string {<br/>    block, err := aes.NewCipher([]byte(key))<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    ciphertext, _ := base64.StdEncoding.DecodeString(text)<br/>    cfb := cipher.NewCFBEncrypter(block, initVector)<br/>    plaintext := make([]byte, len(ciphertext))<br/>    cfb.XORKeyStream(plaintext, ciphertext)<br/>    return string(plaintext)<br/>}</pre></div>
<p style="padding-left: 60px">This completes the definition of utility files for encryption and decryption.</p>
<ol start="8">
<li>Now, let's edit the <kbd>main.go</kbd> file to leverage the preceding <kbd>utils</kbd> package and its functions. The <kbd>main</kbd> function should encrypt a message using the <kbd>EncryptString</kbd> function, and then decrypt a message using the <kbd>DecryptString</kbd> function, like this:</li>
</ol>
<div>
<pre style="padding-left: 60px">package main<br/>import (<br/>    "log"<br/>    "github.com/git-user/chapter11/encryptString/utils"<br/>)<br/>// AES keys should be of length 16, 24, 32<br/>func main() {<br/>    key := "111023043350789514532147"<br/>    message := "I am A Message"<br/>    log.Println("Original message: ", message)<br/>    encryptedString := utils.EncryptString(key, message)<br/>    log.Println("Encrypted message: ", encryptedString)<br/>    decryptedString := utils.DecryptString(key, encryptedString)<br/>    log.Println("Decrypted message: ", decryptedString)<br/>}</pre></div>
<p style="padding-left: 60px"><span>The original message should not change.</span></p>
<ol start="9">
<li>Here, we are importing the <kbd>encrypting/decrypting</kbd> functions from the <kbd>utils</kbd> package and using them to show an example. If we run this program, we see the following output:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> go run main.go</strong><br/><br/><strong>Original message: I am A Message</strong><br/><strong>Encrypted message: 8/+JCfTb+ibIjzQtmCo=</strong><br/><strong>Decrypted message: I am A Message</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This program illustrates how we can use the AES algorithm to encrypt a message and get it back using the same secret key. This algorithm is also called the <strong>Rijndael</strong> <span>(pronounced as <em>rain-dahl</em>)</span> algorithm.</p>
<p>In the next section, we use this encryption knowledge to create a microservice using Go Micro.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a microservice with Go Micro</h1>
                </header>
            
            <article>
                
<p>We will use Go Micro and our encryption logic in <kbd>utils</kbd> to write a microservice. A Go microservice should be built in a step-wise manner. To create a service, we need to design a few entities upfront. They are as follows:</p>
<ul>
<li>A protocol buffer file for defining RPC methods of service</li>
<li>A handler file that has an actual implementation of methods</li>
<li>A server that exposes RPC methods</li>
<li>A client that can make RPC requests and get results</li>
</ul>
<p>We need two system level-tools called <kbd>protoc</kbd> and <kbd>protoc-gen-micro</kbd> for compiling protocol buffers to Go packages. Let's see the steps for creating an encryption microservice, as follows:</p>
<ol>
<li>Let's install those compilers using the <kbd>go get</kbd> command, as follows:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> go get -u github.com/golang/protobuf/protoc-gen-go</strong><br/>&gt;<strong> go get github.com/micro/protoc-gen-micro</strong></pre>
<ol start="2">
<li>Let's create our project directories, like this:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> mkdir -p $GOPATH/src/github.com/git-user/chapter11/encryptService<br/></strong><strong>mkdir $GOPATH/src/github.com/git-user/chapter11/encryptService/<br/>proto</strong></pre>
<ol start="3">
<li>Now, define an <kbd>encryption.proto</kbd> protocol buffer file in the <kbd>proto</kbd> directory, like this:</li>
</ol>
<pre style="padding-left: 60px">syntax = "proto3";<br/><br/>service Encrypter {<br/>  rpc Encrypt(Request) returns (Response) {}<br/>  rpc Decrypt(Request) returns (Response) {}<br/>}<br/><br/>message Request {<br/>    string message = 1;<br/>    string key = 2;<br/>}<br/><br/>message Response {<br/>    string result = 2;<br/>}</pre>
<p style="padding-left: 60px">It should have a service called <kbd>Encrypter</kbd> and two messages called <kbd>Request</kbd> and <kbd>Response</kbd>. These two messages are for requesting encryption and decryption.</p>
<p style="padding-left: 60px">The syntax of the preceding file is <kbd>"proto3"</kbd>. The <kbd>Request</kbd> message has two fields, called <kbd>message</kbd> and <kbd>key</kbd> respectively. The client uses these field to send a <kbd>plaintext</kbd>/<kbd>ciphertext</kbd> message.</p>
<p style="padding-left: 60px">The <kbd>Response</kbd> message has a field called <kbd>result</kbd>. It is the result of the encryption/decryption process. The <kbd>Encrypter</kbd> service has two RPC methods called <kbd>Encrypt</kbd> and <kbd>Decrypt</kbd>. Both take a <kbd>Request</kbd> and return a <kbd>Response</kbd>.</p>
<ol start="4">
<li>Now, we can generate the Go files by compiling a <kbd>.proto</kbd> file, like this:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> protoc -I=. --micro_out=. --go_out=. proto/encryption.proto</strong></pre>
<p style="padding-left: 60px">This is the breakdown of the command:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Option</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td><kbd>-I</kbd></td>
<td>The input of project root</td>
</tr>
<tr>
<td><kbd>--go_out</kbd></td>
<td>The output of the Go file that has autogenerated methods</td>
</tr>
<tr>
<td><kbd>--micro_out</kbd></td>
<td>Similar to <kbd>--go_out</kbd>, but generates an extra file with Go micro methods</td>
</tr>
<tr>
<td><kbd>proto/encryption.proto</kbd></td>
<td>Path to the protocol buffer file to be compiled</td>
</tr>
</tbody>
</table>
<p> </p>
<p style="padding-left: 60px">It generates two new files in the project's <kbd>proto</kbd> directory. Their names are as follows:</p>
<ul>
<li style="padding-left: 60px"><kbd>encryption.pb.go</kbd></li>
<li style="padding-left: 60px"><kbd>encryption.pb.micro.go</kbd></li>
</ul>
<p style="padding-left: 60px"><span>These code-generated files should not be modified by hand.</span></p>
<ol start="5">
<li>Let's copy the <kbd>utils.go</kbd> file we have defined in the <kbd>encryptString</kbd> example. It can be reused as it is, except for a small change in the package name, as shown here:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> cp $GOPATH/src/github.com/git-user/chapter11/encryptString/utils/<br/>utils.go </strong><strong>$GOPATH/src/github.com/git-user/chapter11/encryptService/</strong></pre>
<ol start="6">
<li>After the copy, change the package name in the file from <kbd>utils</kbd> to <kbd>main</kbd> (because now, this file is in the new project's root), as follows:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>    "crypto/aes"<br/>    "crypto/cipher"<br/>    "encoding/base64"<br/>)<br/>...</pre>
<p style="padding-left: 60px">With this, we have the <kbd>EncryptString</kbd> and <kbd>DecryptString</kbd> functions available throughout the Go project.</p>
<ol start="7">
<li>Now, add one more file called <kbd>handlers.go</kbd>, where we define the business logic for our service. It exports an <kbd>Encrypter</kbd> struct and a few methods that handle RPC requests. The code for this is shown here:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> touch $GOPATH/src/github.com/git-user/chapter11/encryptService/<br/>handlers.go</strong></pre>
<p class="mce-root"/>
<ol start="8">
<li>The <kbd><span>Encrypter</span></kbd> struct should have two methods, <kbd>Encrypt</kbd> and <kbd>Decrypt</kbd>. Each method takes a context object, an RPC request object, and an RPC response object. The job each method does is to call the respective utility function and set the response object with a result, like so:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>    "context"<br/><br/>    proto "github.com/git-user/chapter11/encryptService/proto"<br/>)<br/><br/>// Encrypter holds the information about methods<br/>type Encrypter struct{}<br/><br/>// Encrypt converts a message into cipher and returns response<br/>func (g *Encrypter) Encrypt(ctx context.Context,<br/> req *proto.Request, rsp *proto.Response) error {<br/>    rsp.Result = EncryptString(req.Key, req.Message)<br/>    return nil<br/>}<br/><br/>// Decrypt converts a cipher into message and returns response<br/>func (g *Encrypter) Decrypt(ctx context.Context,<br/> req *proto.Request, rsp *proto.Response) error {<br/>    rsp.Result = DecryptString(req.Key, req.Message)<br/>    return nil<br/>}</pre>
<ol start="9">
<li>The <kbd>Encrypt</kbd> and <kbd>Decrypt</kbd> methods are mapped to these RPC methods in the protocol buffer file, like so:</li>
</ol>
<pre style="padding-left: 60px">  rpc Encrypt(Request) returns (Response) {}<br/>  rpc Decrypt(Request) returns (Response) {}</pre>
<ol start="10">
<li>Now, we have to plug these handlers into our <kbd>main</kbd> program, like so:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> touch $GOPATH/src/github.com/git-user/chapter11/encryptService/<br/>main.go</strong></pre>
<ol start="11">
<li>The <kbd>main</kbd> program imports the <kbd>proto</kbd> and <kbd>go-micro</kbd> packages and tries to create a new microservice instance. Then, it registers the service to the <kbd>Encrypter</kbd> handler we exported from the <kbd>handlers.go</kbd> file. Finally, it runs the service. All this is illustrated in the following block of code:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>    fmt "fmt"<br/><br/>    proto "github.com/git-user/chapter11/encryptService/proto"<br/>    micro "github.com/micro/go-micro"<br/>)<br/><br/>func main() {<br/>    // Create a new service. Optionally include some options here.<br/>    service := micro.NewService(<br/>        micro.Name("encrypter"),<br/>    )<br/><br/>    // Init will parse the command line flags.<br/>    service.Init()<br/><br/>    // Register handler<br/>    proto.RegisterEncrypterHandler(service.Server(),<br/>     new(Encrypter))<br/><br/>    // Run the server<br/>    if err := service.Run(); err != nil {<br/>        fmt.Println(err)<br/>    }<br/>}</pre>
<p class="mce-root" style="padding-left: 60px">In the preceding program, <kbd>micro.NewService</kbd> is being used to create a new microservice. It returns a <kbd>service</kbd> object. We can also collect command-line arguments by running <kbd>service.Init()</kbd>. In our example, we are not passing any. We can register the service to the handler by using the <kbd>RegisterEncrypterHandler</kbd> method. This method is dynamically generated by the protocol buffer compiler. Finally, <kbd>service.Run</kbd> starts the server. Let's run the service.</p>
<ol start="12">
<li>Try to build the project from the project root directory, <kbd>encryptService</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> go build &amp;&amp; ./encryptService</strong><br/><br/>2019/12/22 16:16:18 log.go:18: Transport [http] Listening on [::]:58043<br/>2019/12/22 16:16:18 log.go:18: Broker [http] Connected to [::]:58044<br/>2019/12/22 16:16:18 log.go:18: Registry [mdns] Registering node: encrypter-4d68d94a-727d-445b-80a3-24a1db3639dd</pre>
<p>As you see from the server output, Go Micro starts the microservice with a transport and a message broker. Now, clients can make requests to these ports. The service is not so useful unless there is a client to consume the API. So, in the next section, we'll try to build a Go Micro client and see how to connect to the preceding server.</p>
<div class="packt_tip">If you want to run the program without building it, you have to include all the packages that are imported in the <kbd>main</kbd> file.<br/>
<br/>
For example, <kbd>go run main.go handlers.go utils.go</kbd> is equivalent to <kbd>go build &amp;&amp; ./encryptService</kbd>.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building an RPC client with Go Micro</h1>
                </header>
            
            <article>
                
<p>In <a href="613be150-a44b-4840-8fe5-9b41f53f3244.xhtml" target="_blank">Chapter 6</a>, <em>Working with Protocol Buffers and gRPC</em>, where we discussed protocol buffers, we mentioned that a server and client should agree on the same protocol buffer. In the same way, Go Micro expects the service and client to use the same <kbd>.proto</kbd> file—in our case, <kbd>encryption.proto</kbd>. A client can be another service that is requesting some information.</p>
<p>We can build clients using Go Micro. It includes all the necessary constructs to connect and make RPC calls to a microservice. Our plan is to create a client and ask the service to encrypt and decrypt messages. Those requests will be RPC calls. Let's see the steps for creating and using a Go Micro client, as follows:</p>
<ol>
<li>Create a new project for the client, like this:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> mkdir -p $GOPATH/src/github.com/git-user/chapter11/encryptClient/<br/></strong>&gt;<strong> mkdir</strong><strong> $GOPATH/src/github.com/git-user/chapter11/encryptClient/<br/>proto</strong></pre>
<ol start="2">
<li>Now, add an <kbd>encryption.proto</kbd> file in the <kbd>proto</kbd> directory, which looks exactly similar to that of the <kbd>service</kbd>, like this:</li>
</ol>
<pre style="padding-left: 60px">syntax = "proto3";<br/><br/>service Encrypter {<br/>  rpc Encrypt(Request) returns (Response) {}<br/>  rpc Decrypt(Request) returns (Response) {}<br/>}<br/><br/>message Request {<br/>  string message = 1;<br/>  string key = 2;<br/>}<br/><br/>message Response {<br/>    string result = 2;<br/>}</pre>
<ol start="3">
<li>If observed carefully, the service name, messages, and their definitions are matching with that of the <kbd>service</kbd>. Now, compile the protocol buffer from the <kbd>encryptClient</kbd> <span>project root, as follows:</span></li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> protoc -I=. --micro_out=. --go_out=. proto/encryption.proto</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>After this, the client generates two files in the <kbd>proto</kbd> directory. Those should not be modified. Now, we are ready with our setup. Add a <kbd>main.go</kbd> file for making RPC calls to the service, as follows:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> touch $GOPATH/src/github.com/git-user/chapter11/encryptClient/<br/>main.go</strong></pre>
<ol start="5">
<li>The <kbd>main</kbd> program imports the <kbd>proto</kbd> and <kbd>go-micro</kbd> packages where we compiled protocol buffers, like so:</li>
</ol>
<pre style="padding-left: 60px">package main<br/><br/>import (<br/>    "context"<br/>    "fmt"<br/><br/>    proto "github.com/git-user/chapter11/encryptClient/proto"<br/>    micro "github.com/micro/go-micro"<br/>)</pre>
<ol start="6">
<li>A client should also be created with a function called <kbd>micro.NewService</kbd>, like this:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px">func main() {<br/>    // Create a new service<br/>    service := micro.NewService(micro.Name("encrypter.client"))<br/>    // Initialise the client and parse command line flags<br/>    service.Init()<br/><br/>    // Create new encrypter service instance<br/>    encrypter := proto.NewEncrypterService("encrypter",<br/>     service.Client())<br/>    ...<br/>}</pre>
<p style="padding-left: 60px"><span>It can be initialized to collect environment variables. The key difference between a client and</span> a service <span>is</span> that for the client, we <span>create an instance of <kbd>service</kbd> using the</span> <span><kbd>proto.NewEncrypterService</kbd> function. We use that instance to make API calls. Remember that the function is auto-generated by the <kbd>protoc</kbd> command.</span></p>
<ol start="7">
<li>The <kbd>encrypter</kbd> is the service instance in the code. Next, we can make RPC calls by calling RPC methods directly on the service instance. Let's pass a text called <kbd>"I am a Message"</kbd> with the key <kbd>"<span>111023043350789514532147</span>"</kbd> to encrypt the method, like this:</li>
</ol>
<pre style="padding-left: 30px">    // Call the encrypter<br/>    rsp, err := encrypter.Encrypt(context.TODO(), &amp;proto.Request{<br/>        Message: "I am a Message",<br/>        Key:     "111023043350789514532147",<br/>    })<br/><br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }<br/><br/>    // Print response<br/>    fmt.Println(rsp.Result)</pre>
<p style="padding-left: 60px">The function, as specified in the protocol buffer, returns a response that has a <kbd>Result</kbd> field. <span>We are printing that value to the console.</span></p>
<ol start="8">
<li>Next, let's pass this result back as a cipher for the <kbd>Decrypt</kbd> function. It should return the original message back. We use the same key as we did for encryption, like this:</li>
</ol>
<pre style="padding-left: 30px">    // Call the decrypter<br/>    rsp, err = encrypter.Decrypt(context.TODO(), &amp;proto.Request{<br/>        Message: rsp.Result,<br/>        Key:     "111023043350789514532147",<br/>    })<br/><br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }<br/>    <br/>    // Print response<br/>    fmt.Println(rsp.Result)</pre>
<ol start="9">
<li>These two blocks go into the <kbd>main</kbd> function. Once we are done adding them, let's build and run the client, as follows:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> go build &amp;&amp; ./encryptClient</strong><br/><br/>8/+JCfT7+ibIjzQtmCo=<br/>I am a Message</pre>
<p>We passed the plaintext and key, and the original message is returned back as the final result. It confirms that the <kbd>encrypt</kbd> and <kbd>decrypt</kbd> RPC calls are working properly. The benefit of Go Micro is, with a few lines of code, we can create microservices and clients.</p>
<p>In the next section, we see how Go Micro supports EDAs where services and clients can communicate via events.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building event-driven microservices</h1>
                </header>
            
            <article>
                
<p>In <a href="4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml" target="_blank">Chapter 9</a>, <em>Asynchronous API Design</em>, we learned about asynchronous programming. An asynchronous API can be achieved by events. The service and client can talk to each other using events. They don't have to wait until one party finishes their job.</p>
<p>An event generator is an entity that generates events. An event consumer consumes the events from other parties. <span>Publish/Subscribe</span> is an architectural pattern that is possible with events. Go Micro supports Publish/Subscribe by using a message broker interface.</p>
<p>See the following diagram to understand the event flow:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/096710a3-5922-4935-ada7-c79fe1162c6d.png"/></p>
<p><span>A Go Micro client can</span> <span><strong>Subscribe</strong> to a topic. A Go microservice can</span> <strong>Publish</strong> <span>messages into that <strong>Topic</strong></span><span>. Events flow from right to left in this case.</span></p>
<p>It comes with an inbuilt HTTP message broker and can be easily replaced with widely used message brokers such as RabbitMQ or Kafka. In our discussion, we stick to the default HTTP broker.</p>
<p>We will illustrate Publish/Subscribe with an example. Let's say a microservice should push weather alerts every 5 seconds. Instead of the client calling the service API, the service can publish those changes to a topic where a client can subscribe. The client consumes those alerts and does the processing.</p>
<p class="mce-root"/>
<div class="packt_infobox">In all the projects we are working on, we should install Go Micro using the <kbd>dep</kbd> tool and running the following code:<br/>
<br/>
<kbd>&gt; dep init</kbd><br/>
<kbd>&gt; dep ensure -add "github.com/micro/go-micro"</kbd></div>
<p>We are going to create an <kbd>asyncServer</kbd> and an <kbd>asyncClient</kbd>. The <kbd>asyncServer</kbd> generates weather events, and the client consumes them. Let's look at the steps for this example here:</p>
<ol>
<li>Create a project directory, like this:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> mkdir -p $GOPATH/src/github.com/git-user/chapter11/asyncService<br/></strong>&gt;<strong> mkdir $GOPATH/src/github.com/git-user/chapter11/asyncServer/proto<br/><br/></strong>&gt;<strong> mkdir -p $GOPATH/src/github.com/git-user/chapter11/asyncClient<br/></strong>&gt;<strong> mkdir $GOPATH/src/github.com/git-user/chapter11/asyncClient/proto</strong></pre>
<ol start="2">
<li>Create a <kbd>weather.proto</kbd> file in the <kbd>proto</kbd> directory of both <kbd>asyncService</kbd> and <kbd>asyncClient</kbd>. It holds a structure and RPC methods for communication. <span>This file defines an <kbd>Event</kbd> that is a weather alert, and the code can be seen as follows:</span></li>
</ol>
<pre style="padding-left: 60px">syntax = "proto3";<br/><br/>// Example message<br/>message Event {<br/>    // city name<br/>    string city = 1;<br/>    // unix timestamp<br/>    int64 timestamp = 2;<br/>    // temperaure in Celsius<br/>    int64 temperature = 3;<br/>}</pre>
<p style="padding-left: 60px">It has three fields, as follows:</p>
<ul>
<li style="padding-left: 60px"><kbd>city name</kbd></li>
<li style="padding-left: 60px"><kbd>unix timestamp</kbd></li>
<li style="padding-left: 60px"><kbd>temperature in Celsius</kbd></li>
</ul>
<p style="padding-left: 60px">A service should publish this event to a topic called <kbd>alerts</kbd>.</p>
<ol start="3">
<li>Now, compile the <kbd>.proto</kbd> file in both the service and client, and get auto-generated Go files, as follows:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> protoc -I=. --micro_out=. --go_out=. proto/weather.proto</strong></pre>
<div class="packt_infobox">For brevity, we are skipping the imports in this example, so please access the chapter repo for the complete code.</div>
<ol start="4">
<li>Coming to the service, the <kbd>main.go</kbd> file should declare a microservice and a publisher. A publisher is created by the <kbd>micro.NewPublisher</kbd> method. It takes the topic name <kbd>alerts</kbd> and a <kbd>service.Client()</kbd> as its arguments, as follows:</li>
</ol>
<pre style="padding-left: 60px">func main() {<br/>    // Create a new service. Optionally include some options here.<br/>    service := micro.NewService(<br/>        micro.Name("weather"),<br/>    )<br/>    p := micro.NewPublisher("alerts", service.Client())<br/>    ...<br/>}</pre>
<ol start="5">
<li>Next, we create a dummy ticker that publishes a weather alert every <kbd>15</kbd> seconds. We achieve that by using the <kbd>time.Tick</kbd> built-in Go method. We spawn a <kbd>go-routine</kbd> that loops forever, listens to a tick, and publishes an event into the topic using the <kbd>publisher.Publish</kbd> method. The <kbd>Publish</kbd> method takes a context object and an event with data as arguments, as can be seen in the following code block:</li>
</ol>
<pre style="padding-left: 30px">    go func() {<br/>        for now := range time.Tick(15 * time.Second) {<br/>            log.Println("Publishing weather alert to Topic: alerts")<br/>            p.Publish(context.TODO(), &amp;proto.Event{<br/>                City:        "Munich",<br/>                Timestamp:   now.UTC().Unix(),<br/>                Temperature: 2,<br/>            })<br/>        }<br/>    }()</pre>
<ol start="6">
<li>After this, finally, we have to run the service by calling the <kbd>service.Run</kbd> method, like this:</li>
</ol>
<pre style="padding-left: 30px">    // Run the server<br/>    if err := service.Run(); err != nil {<br/>        log.Println(err)<br/>    }</pre>
<ol start="7">
<li>Both <kbd>service</kbd> and <kbd>go-routine</kbd> run in parallel. When you run this service, you see this output:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> go build &amp;&amp; ./asyncService</strong><br/><br/>2019/12/22 21:31:03 log.go:18: Transport [http] Listening on [::]:60243<br/>2019/12/22 21:31:03 log.go:18: Broker [http] Connected to [::]:60244<br/>2019/12/22 21:31:03 log.go:18: Registry [mdns] Registering node: weather-83982bda-5e9e-445b-9ce2-5439d1560d1f<br/>2019-12-22 21:31:18.379616 I | Publishing event to Topic: alerts<br/>2019-12-22 21:31:33.376924 I | Publishing event to Topic: alerts</pre>
<ol start="8">
<li>Now, the service is pushing events, but there is no client to consume them. Let's update the <kbd>main.go</kbd> file <kbd>asyncClient</kbd> with consuming logic. In the client, we should declare a handler function to process the event. The handler is executed whenever there is an incoming event. It prints out the event in our case, as can be seen here:</li>
</ol>
<pre style="padding-left: 60px">// ProcessEvent processes a weather alert<br/>func ProcessEvent(ctx context.Context, event *proto.Event) error {<br/>    log.Println("Got alert:", event)<br/>    return nil<br/>}</pre>
<ol start="9">
<li>After defining the handler function to process events, we can attach the client with the topic. The <kbd>micro.RegisterSubscriber</kbd> function attaches a <kbd>ProcessEvent</kbd> handler function to the <kbd>alerts</kbd> topic, like this:</li>
</ol>
<pre style="padding-left: 60px">func main() {<br/>    // Create a new service<br/>    service := micro.NewService(micro.Name("weather_client"))<br/>    // Initialise the client and parse command line flags<br/>    service.Init()<br/>    micro.RegisterSubscriber("alerts", service.Server(),<br/>     ProcessEvent)<br/><br/>    if err := service.Run(); err != nil {<br/>        log.Fatal(err)<br/>    }<br/>}</pre>
<ol start="10">
<li>If we run this program, it consumes the alerts published by the service we defined previously, as follows:</li>
</ol>
<pre style="padding-left: 60px">&gt;<strong> go build &amp;&amp; ./asyncClient</strong><br/><br/>2019/12/22 21:48:07 log.go:18: Transport [http] Listening on [::]:60445<br/>2019/12/22 21:48:07 log.go:18: Broker [http] Connected to [::]:60446<br/>2019/12/22 21:48:07 log.go:18: Registry [mdns] Registering node: weather_client-73496273-31ca-4bed-84dc-60df07a1570d<br/>2019/12/22 21:48:07 log.go:18: Subscribing weather_client-73496273-31ca-4bed-84dc-60df07a1570d to topic: alerts<br/>2019-12-22 21:48:18.436189 I | Got event: city:"Munich" timestamp:1577047698 temperature:2 <br/>2019-12-22 21:48:33.431529 I | Got event: city:"Munich" timestamp:1577047713 temperature:2 </pre>
<p>This is how asynchronous behavior is achieved in microservices. The border between clients and services can blur, as anyone can publish or subscribe. In a distributed system, services are clients to other services. So, Go Micro provides a lightweight and flexible approach to creating microservices.</p>
<p>In the next section, we will discuss the logging and instrumentation of microservices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding logging to microservices</h1>
                </header>
            
            <article>
                
<p>Logging is a crucial aspect of microservices. We can write middleware to capture all requests and responses going into and out of a service. Even for a client, we can capture logs while making RPC calls to a service.</p>
<p>Go Micro is a lean framework and doesn't enforce logging by default. We can easily wrap a service handler with our own custom logger. For example, in the <kbd>encryptService</kbd> example, we have a file called <kbd>handlers.go</kbd>.</p>
<p>In order to activate logging for each request in a custom format, we have to define a wrapper, and then link it to the service. As an example, if we have to log every incoming encryption request, follow these steps:</p>
<ol>
<li>Create a new <kbd>wrapper</kbd> function. It takes <kbd>Context</kbd>, <kbd>Request</kbd>, and <kbd>Response</kbd> as arguments. Here, we just print the time of the request arrival, like this:</li>
</ol>
<pre style="padding-left: 60px">func logWrapper(fn server.HandlerFunc) server.HandlerFunc {<br/> return func(ctx context.Context, req *proto.Request,<br/>  rsp *proto.Response) error {<br/> fmt.Printf("encryption request at time: %v", time.Now())<br/> return fn(ctx, req, rsp)<br/> }<br/>}</pre>
<ol start="2">
<li class="mce-root">In <span><kbd>service</kbd>, we can attach the wrapper, like this:</span></li>
</ol>
<pre class="mce-root" style="padding-left: 60px">service := micro.NewService(<br/>micro.Name("encrypter"),<br/>// wrap the client<br/>micro.WrapClient(logWrap),<br/>)</pre>
<p style="padding-left: 60px">Now, the service logs every request in the format defined in the wrapper function, like so:</p>
<pre style="padding-left: 60px">encryption request at time: 2019/12/22 23:07:3</pre>
<div class="packt_infobox">For more information about logging, see the documentation at <a href="https://micro.mu/docs/go-micro.html#wrappers" target="_blank">https://micro.mu/docs/go-micro.html#wrappers</a>.<a href="https://micro.mu/docs/go-micro.html#wrappers"/></div>
<p>The instrumentation of services is out of the scope of this book, but there is an open standard called <strong>OpenTracing</strong> (<a href="https://opentracing.io/" target="_blank">https://opentracing.io/</a>). It defines a standard for how to metricize API endpoints, number of requests, and so on. Please feel free to explore it.</p>
<div class="packt_tip">The APIs we created in this chapter are RPC-based. To convert them to REST, you just have to use a plugin called <strong>Micro Web</strong>. For more information, see this link for easy conversion to REST (<a href="https://micro.mu/docs/go-web.html" target="_blank">https://micro.mu/docs/go-web.html</a>).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we started with the definition of microservices. The main difference between a monolithic application and a microservice is the way a tightly coupled architecture is broken into a loosely coupled architecture.</p>
<p class="mce-root">Microservices talk to each other using either REST-based JSON or RPC-based protocol buffers. Using microservices, we can break business logic into multiple chunks. Each service does one job pretty well. Go has a lightweight framework called <strong>Go Micro</strong>. Using it, we can create services and clients.</p>
<p><span>We</span> first created an encryption service using <kbd>Micro go</kbd>. We then developed a client for consuming the service. Go Micro also allows asynchronous programming by providing a Publish/Subscribe pattern. Any client/service can subscribe or push events to a topic. It uses an HTTP broker by default but can be easily configured to RabbitMQ or Kafka. Go Micro also provides features such as service discovery, and various transport mechanisms such as protocol buffers, JSON, and so on. Small organizations can start with a monolith, but in bigger organizations with huge teams, microservices are better suited.</p>
<p>In the next chapter, we are going to see how to deploy our Go services using nginx. A service needs to be deployed for it to be exposed to the outside world. We also use <kbd>docker-compose</kbd> and containers for a clean deployment.</p>


            </article>

            
        </section>
    </body></html>