["```go\n> dep init > dep ensure -add  \"github.com/micro/go-micro\"\n```", "```go\n> mkdir -p $GOPATH/src/github.com/git-user/chapter11/encryptString cd $GOPATH/src/github.com/git-user/chapter11/encryptString\n```", "```go\n└── encryptString\n    ├── main.go\n    └── utils\n        └── utils.go\n```", "```go\npackage utils\nimport (\n    \"crypto/aes\"\n    \"crypto/cipher\"\n    \"encoding/base64\"\n)\n```", "```go\n/* Initialization vector for the AES algorithm\nMore details visit this link https://en.wikipedia.org/wiki/Advanced_Encryption_Standard */\nvar initVector = []byte{35, 46, 57, 24, 85, 35, 24, 74, 87, 35, 88, 98, 66, 32, 14, 05}\n```", "```go\n// EncryptString encrypts the string with given key\nfunc EncryptString(key, text string) string {\n    block, err := aes.NewCipher([]byte(key))\n    if err != nil {\n        panic(err)\n    }\n    plaintext := []byte(text)\n    cfb := cipher.NewCFBEncrypter(block, initVector)\n    ciphertext := make([]byte, len(plaintext))\n    cfb.XORKeyStream(ciphertext, plaintext)\n    return base64.StdEncoding.EncodeToString(ciphertext)\n}\n```", "```go\n// DecryptString decrypts the encrypted string to original\nfunc DecryptString(key, text string) string {\n    block, err := aes.NewCipher([]byte(key))\n    if err != nil {\n        panic(err)\n    }\n    ciphertext, _ := base64.StdEncoding.DecodeString(text)\n    cfb := cipher.NewCFBEncrypter(block, initVector)\n    plaintext := make([]byte, len(ciphertext))\n    cfb.XORKeyStream(plaintext, ciphertext)\n    return string(plaintext)\n}\n```", "```go\npackage main\nimport (\n    \"log\"\n    \"github.com/git-user/chapter11/encryptString/utils\"\n)\n// AES keys should be of length 16, 24, 32\nfunc main() {\n    key := \"111023043350789514532147\"\n    message := \"I am A Message\"\n    log.Println(\"Original message: \", message)\n    encryptedString := utils.EncryptString(key, message)\n    log.Println(\"Encrypted message: \", encryptedString)\n    decryptedString := utils.DecryptString(key, encryptedString)\n    log.Println(\"Decrypted message: \", decryptedString)\n}\n```", "```go\n> go run main.go\n\nOriginal message: I am A Message\nEncrypted message: 8/+JCfTb+ibIjzQtmCo=\nDecrypted message: I am A Message\n```", "```go\n> go get -u github.com/golang/protobuf/protoc-gen-go\n> go get github.com/micro/protoc-gen-micro\n```", "```go\n> mkdir -p $GOPATH/src/github.com/git-user/chapter11/encryptService mkdir $GOPATH/src/github.com/git-user/chapter11/encryptService/\nproto\n```", "```go\nsyntax = \"proto3\";\n\nservice Encrypter {\n  rpc Encrypt(Request) returns (Response) {}\n  rpc Decrypt(Request) returns (Response) {}\n}\n\nmessage Request {\n    string message = 1;\n    string key = 2;\n}\n\nmessage Response {\n    string result = 2;\n}\n```", "```go\n> protoc -I=. --micro_out=. --go_out=. proto/encryption.proto\n```", "```go\n> cp $GOPATH/src/github.com/git-user/chapter11/encryptString/utils/\nutils.go $GOPATH/src/github.com/git-user/chapter11/encryptService/\n```", "```go\npackage main\n\nimport (\n    \"crypto/aes\"\n    \"crypto/cipher\"\n    \"encoding/base64\"\n)\n...\n```", "```go\n> touch $GOPATH/src/github.com/git-user/chapter11/encryptService/\nhandlers.go\n```", "```go\npackage main\n\nimport (\n    \"context\"\n\n    proto \"github.com/git-user/chapter11/encryptService/proto\"\n)\n\n// Encrypter holds the information about methods\ntype Encrypter struct{}\n\n// Encrypt converts a message into cipher and returns response\nfunc (g *Encrypter) Encrypt(ctx context.Context,\n req *proto.Request, rsp *proto.Response) error {\n    rsp.Result = EncryptString(req.Key, req.Message)\n    return nil\n}\n\n// Decrypt converts a cipher into message and returns response\nfunc (g *Encrypter) Decrypt(ctx context.Context,\n req *proto.Request, rsp *proto.Response) error {\n    rsp.Result = DecryptString(req.Key, req.Message)\n    return nil\n}\n```", "```go\n  rpc Encrypt(Request) returns (Response) {}\n  rpc Decrypt(Request) returns (Response) {}\n```", "```go\n> touch $GOPATH/src/github.com/git-user/chapter11/encryptService/\nmain.go\n```", "```go\npackage main\n\nimport (\n    fmt \"fmt\"\n\n    proto \"github.com/git-user/chapter11/encryptService/proto\"\n    micro \"github.com/micro/go-micro\"\n)\n\nfunc main() {\n    // Create a new service. Optionally include some options here.\n    service := micro.NewService(\n        micro.Name(\"encrypter\"),\n    )\n\n    // Init will parse the command line flags.\n    service.Init()\n\n    // Register handler\n    proto.RegisterEncrypterHandler(service.Server(),\n     new(Encrypter))\n\n    // Run the server\n    if err := service.Run(); err != nil {\n        fmt.Println(err)\n    }\n}\n```", "```go\n> go build && ./encryptService\n\n2019/12/22 16:16:18 log.go:18: Transport [http] Listening on [::]:58043\n2019/12/22 16:16:18 log.go:18: Broker [http] Connected to [::]:58044\n2019/12/22 16:16:18 log.go:18: Registry [mdns] Registering node: encrypter-4d68d94a-727d-445b-80a3-24a1db3639dd\n```", "```go\n> mkdir -p $GOPATH/src/github.com/git-user/chapter11/encryptClient/ > mkdir $GOPATH/src/github.com/git-user/chapter11/encryptClient/\nproto\n```", "```go\nsyntax = \"proto3\";\n\nservice Encrypter {\n  rpc Encrypt(Request) returns (Response) {}\n  rpc Decrypt(Request) returns (Response) {}\n}\n\nmessage Request {\n  string message = 1;\n  string key = 2;\n}\n\nmessage Response {\n    string result = 2;\n}\n```", "```go\n> protoc -I=. --micro_out=. --go_out=. proto/encryption.proto\n```", "```go\n> touch $GOPATH/src/github.com/git-user/chapter11/encryptClient/\nmain.go\n```", "```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    proto \"github.com/git-user/chapter11/encryptClient/proto\"\n    micro \"github.com/micro/go-micro\"\n)\n```", "```go\nfunc main() {\n    // Create a new service\n    service := micro.NewService(micro.Name(\"encrypter.client\"))\n    // Initialise the client and parse command line flags\n    service.Init()\n\n    // Create new encrypter service instance\n    encrypter := proto.NewEncrypterService(\"encrypter\",\n     service.Client())\n    ...\n}\n```", "```go\n    // Call the encrypter\n    rsp, err := encrypter.Encrypt(context.TODO(), &proto.Request{\n        Message: \"I am a Message\",\n        Key:     \"111023043350789514532147\",\n    })\n\n    if err != nil {\n        fmt.Println(err)\n    }\n\n    // Print response\n    fmt.Println(rsp.Result)\n```", "```go\n    // Call the decrypter\n    rsp, err = encrypter.Decrypt(context.TODO(), &proto.Request{\n        Message: rsp.Result,\n        Key:     \"111023043350789514532147\",\n    })\n\n    if err != nil {\n        fmt.Println(err)\n    }\n\n    // Print response\n    fmt.Println(rsp.Result)\n```", "```go\n> go build && ./encryptClient\n\n8/+JCfT7+ibIjzQtmCo=\nI am a Message\n```", "```go\n> mkdir -p $GOPATH/src/github.com/git-user/chapter11/asyncService > mkdir $GOPATH/src/github.com/git-user/chapter11/asyncServer/proto > mkdir -p $GOPATH/src/github.com/git-user/chapter11/asyncClient > mkdir $GOPATH/src/github.com/git-user/chapter11/asyncClient/proto\n```", "```go\nsyntax = \"proto3\";\n\n// Example message\nmessage Event {\n    // city name\n    string city = 1;\n    // unix timestamp\n    int64 timestamp = 2;\n    // temperaure in Celsius\n    int64 temperature = 3;\n}\n```", "```go\n> protoc -I=. --micro_out=. --go_out=. proto/weather.proto\n```", "```go\nfunc main() {\n    // Create a new service. Optionally include some options here.\n    service := micro.NewService(\n        micro.Name(\"weather\"),\n    )\n    p := micro.NewPublisher(\"alerts\", service.Client())\n    ...\n}\n```", "```go\n    go func() {\n        for now := range time.Tick(15 * time.Second) {\n            log.Println(\"Publishing weather alert to Topic: alerts\")\n            p.Publish(context.TODO(), &proto.Event{\n                City:        \"Munich\",\n                Timestamp:   now.UTC().Unix(),\n                Temperature: 2,\n            })\n        }\n    }()\n```", "```go\n    // Run the server\n    if err := service.Run(); err != nil {\n        log.Println(err)\n    }\n```", "```go\n> go build && ./asyncService\n\n2019/12/22 21:31:03 log.go:18: Transport [http] Listening on [::]:60243\n2019/12/22 21:31:03 log.go:18: Broker [http] Connected to [::]:60244\n2019/12/22 21:31:03 log.go:18: Registry [mdns] Registering node: weather-83982bda-5e9e-445b-9ce2-5439d1560d1f\n2019-12-22 21:31:18.379616 I | Publishing event to Topic: alerts\n2019-12-22 21:31:33.376924 I | Publishing event to Topic: alerts\n```", "```go\n// ProcessEvent processes a weather alert\nfunc ProcessEvent(ctx context.Context, event *proto.Event) error {\n    log.Println(\"Got alert:\", event)\n    return nil\n}\n```", "```go\nfunc main() {\n    // Create a new service\n    service := micro.NewService(micro.Name(\"weather_client\"))\n    // Initialise the client and parse command line flags\n    service.Init()\n    micro.RegisterSubscriber(\"alerts\", service.Server(),\n     ProcessEvent)\n\n    if err := service.Run(); err != nil {\n        log.Fatal(err)\n    }\n}\n```", "```go\n> go build && ./asyncClient\n\n2019/12/22 21:48:07 log.go:18: Transport [http] Listening on [::]:60445\n2019/12/22 21:48:07 log.go:18: Broker [http] Connected to [::]:60446\n2019/12/22 21:48:07 log.go:18: Registry [mdns] Registering node: weather_client-73496273-31ca-4bed-84dc-60df07a1570d\n2019/12/22 21:48:07 log.go:18: Subscribing weather_client-73496273-31ca-4bed-84dc-60df07a1570d to topic: alerts\n2019-12-22 21:48:18.436189 I | Got event: city:\"Munich\" timestamp:1577047698 temperature:2 \n2019-12-22 21:48:33.431529 I | Got event: city:\"Munich\" timestamp:1577047713 temperature:2 \n```", "```go\nfunc logWrapper(fn server.HandlerFunc) server.HandlerFunc {\n return func(ctx context.Context, req *proto.Request,\n  rsp *proto.Response) error {\n fmt.Printf(\"encryption request at time: %v\", time.Now())\n return fn(ctx, req, rsp)\n }\n}\n```", "```go\nservice := micro.NewService(\nmicro.Name(\"encrypter\"),\n// wrap the client\nmicro.WrapClient(logWrap),\n)\n```", "```go\nencryption request at time: 2019/12/22 23:07:3\n```"]