- en: Scaling our REST API Using Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a REST API is easy in terms of the concept. But scaling it to accept
    huge traffic is a challenge. Till now, we've looked into the details of creating
    REST API structures and sample REST APIs. In this chapter, we are going to explore
    Go Micro, a wonderful, idiomatic Go package for building microservices.
  prefs: []
  type: TYPE_NORMAL
- en: This is the age of microservices, where huge applications are commonly broken
    down into loosely coupled components. The microservice architecture allows companies
    to quickly iterate in parallel. We will start by defining the term *microservices*,
    and then move on to Go Micro by creating **Remote Procedure Call** (**RPC**)-/REST-style
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoliths versus microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Go Micro, a package for building microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding logging to the microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software should be pre-installed for running code samples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X  >= 10.13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go stable version compiler >= 1.13.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker version >= 18.09.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter11](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter11).
    Clone the code, and use the code samples in the `chapter11` directory.
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are microservices? This is the question the enterprise world is asking
    the computing world. The sustainability of a product depends on how easily modifiable
    it is. Huge products should retire at some point in time if they cannot be maintained
    properly. The microservice architecture replaces the traditional monolith with
    granular services that talk to each other in some kind of agreement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices bring the following benefits to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: Small teams can iterate in parallel by working on a small set of features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adaptability is easy for new developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They allow **Continuous Integration** (**CI**) and **Continuous** **Delivery**
    (**CD**) for individual components of a system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They offer easily replaceable software with a loosely coupled architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture is not coupled to a specific technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a monolithic application (*traditional application*), a single application
    serves the incoming requests by sharing the computing power. It is good because
    we have everything in one place, and it is easily manageable. But there are few
    problems with monoliths, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A tightly coupled architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single point of failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The velocity of adding new features and components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fragmentation of work is limited to teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous** **Delivery** (**CD**) is tough because an entire application
    needs to be redeployed for a small change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a monolithic application, the entire software is treated as a single entity.
    If the database fails, the app fails. If a bug in the code crashes the software
    application, the entire connectivity with clients goes down. This requirement
    paved the way for microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a scenario. A company run by Bob uses the traditional monolith model,
    where developers work around the clock to add new features. At the time of a software
    release, people need to test the code overall for every small component. The project
    moves from development to testing, when all changes are done.
  prefs: []
  type: TYPE_NORMAL
- en: Another company on the next street, run by Alice, uses a microservices architecture.
    The software developers in Alice's company work on individual services, who in
    turn test their individual components. The developers talk with each other's REST/RPC
    API to add new features. They can easily shift their stack from one technology
    to another, as compared to Bob's team.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows that Alice's company is highly flexible than Bob's.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration and service discovery are very important aspects to consider when
    talking about microservices. A tool such as Kubernetes can be used to orchestrate
    the Docker containers. Generally, it is a good practice to have a Docker container
    per microservice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Service discovery** is the automatic detection of the IP address of a microservice
    instance on the fly. This removes the potential threat of hardcoding the IP addresses,
    which can cause a lack of connectivity between services. In the next section,
    we''ll use a diagram to understand what is the crucial difference between a monolith
    and microservice.'
  prefs: []
  type: TYPE_NORMAL
- en: Monoliths versus microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a common practice to begin a software application as a monolith, and
    then break it down into microservices in the long run. This actually helps to
    focus on the application delivery, instead of blindly following the microservice
    pattern. Once the product is stabilized, then developers should find a way to
    break down product features. Take a look at the following diagram for the difference
    between a monolith and microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0228d9b8-e898-42e0-8aa2-dd5cb9175ea5.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram depicts the structure of monolithic and microservices architectures.
    A monolith has everything wrapped in a single system. It is called a **tightly
    coupled** architecture. In contrast, microservices are individual entities that
    are easy to replace and modifiable. Each microservice can talk to one another
    through various transport mechanisms, such as HTTP, REST, or RPC. The data format
    exchanged between services could be either JSON or Protocol buffers. Microservices
    can also handle various request entry points, such as **UI** and **API clients**.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can be implemented in any technology (Java, Go, Python, and so
    on), and can be replaced with any technology because of their loosely coupled
    nature.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we explore how to create microservices in Go using a lightweight
    framework called Go Micro. There, we see how to develop mini services that can
    talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Go Micro, a package for building microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netflix's Eureka and Spring Boot from the Java community are famous for building
    microservices. The Go Micro package provides the same set of features. It is a
    toolkit for building microservices in Go. It is lightweight, which means start
    small and go big.
  prefs: []
  type: TYPE_NORMAL
- en: It has a Go style of adding services, which makes developers feel good. In the
    upcoming sections, we will see how to create a microservice with the steps defined
    by Go Micro. Go Micro provides requirements to implement RPC and **event-driven
    architectures** (**EDAs**). It also has a pluggable interface where we can plug
    any external functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features supported by Go Micro are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Request/response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pluggable interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request/response** is a plain HTTP/RPC call. **Service discovery** is useful
    for finding microservice instances at runtime. **Load balancing** is for routing
    requests to multiple same-type applications. **Message encoding** is essential
    for services to understand each other. **Async messaging** involves the generation
    and consumption of events. Go Micro''s **pluggable interfaces** provide functionality
    such as codecs for translation, and brokers for storage systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Go Micro using the `dep` tool in any project in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we lay down the plan for our first microservice. We see
    how to encrypt and decrypt messages in Go. We will then build an encrypting/decrypting
    service using Go Micro.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know about the encryption of messages. **Encryption** is a process that
    uses a base message and a key to produce an encoded message through a mathematical
    algorithm that can only be decoded using the original key. That message can be
    passed over the wire. The recipient decrypts the message with a key and gets back
    the original message. We are going to create a microservice that provides both
    encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the plan for the development of our first microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop utility functions for encryption/decryption.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, integrate it with Go Micro to produce a service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go comes with packages for encrypting messages. We need to import encrypting
    algorithms from those packages and use them. For that, we create a project that
    uses the **Advanced Encryption Standard** (**AES**), as in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory called `encryptString` in your `GOPATH/src/github.com` directory,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add one more file in the new directory, called `utils`. Add `main.go`
    in the project directory and `utils.go` in the new `utils` directory. The directory
    structure looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the logic of encryption in our `utils.go` file. We create two
    functions, one for encryption and another for the decryption of a message. First,
    import the necessary packages, `crypto` and `encoding`, as shown in the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The AES algorithm takes an initialization vector. The vector is an arbitrary
    byte array that can be used along with a secret key for data encryption. Define
    it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The values in the vector can also be generated randomly. Here, we use a predefined
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the logic for encryption. It declares a new cipher using
    the `aes.NewCipher` and `aes.NewCFBEncryptor` functions. Then, we execute a function
    called `XORKeyStream` on the cipher to get the encrypted string. Then, we need
    to do a `base64` encoding to generate the protected string, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, in the same way, let's define a `DecryptString` function that takes a
    key and `ciphertext` and generates an original message. In the `DecryptString`
    function, first, decode the `base64` encoded text and create a cipher block with
    the key. Pass this cipher block with the initialization vector to `NewCFBEncrypter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, use `XORKeyStream` to load content from `ciphertext` to `plaintext`.
    Basically, it is a process of swapping the encrypted and decrypted messages in
    `XORKeyStream`. The code looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This completes the definition of utility files for encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s edit the `main.go` file to leverage the preceding `utils` package
    and its functions. The `main` function should encrypt a message using the `EncryptString`
    function, and then decrypt a message using the `DecryptString` function, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The original message should not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are importing the `encrypting/decrypting` functions from the `utils`
    package and using them to show an example. If we run this program, we see the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This program illustrates how we can use the AES algorithm to encrypt a message
    and get it back using the same secret key. This algorithm is also called the **Rijndael**
    (pronounced as *rain-dahl*) algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we use this encryption knowledge to create a microservice
    using Go Micro.
  prefs: []
  type: TYPE_NORMAL
- en: Building a microservice with Go Micro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Go Micro and our encryption logic in `utils` to write a microservice.
    A Go microservice should be built in a step-wise manner. To create a service,
    we need to design a few entities upfront. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A protocol buffer file for defining RPC methods of service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A handler file that has an actual implementation of methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server that exposes RPC methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client that can make RPC requests and get results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need two system level-tools called `protoc` and `protoc-gen-micro` for compiling
    protocol buffers to Go packages. Let''s see the steps for creating an encryption
    microservice, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install those compilers using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create our project directories, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define an `encryption.proto` protocol buffer file in the `proto` directory,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It should have a service called `Encrypter` and two messages called `Request`
    and `Response`. These two messages are for requesting encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the preceding file is `"proto3"`. The `Request` message has two
    fields, called `message` and `key` respectively. The client uses these field to
    send a `plaintext`/`ciphertext` message.
  prefs: []
  type: TYPE_NORMAL
- en: The `Response` message has a field called `result`. It is the result of the
    encryption/decryption process. The `Encrypter` service has two RPC methods called
    `Encrypt` and `Decrypt`. Both take a `Request` and return a `Response`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can generate the Go files by compiling a `.proto` file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the breakdown of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `-I` | The input of project root |'
  prefs: []
  type: TYPE_TB
- en: '| `--go_out` | The output of the Go file that has autogenerated methods |'
  prefs: []
  type: TYPE_TB
- en: '| `--micro_out` | Similar to `--go_out`, but generates an extra file with Go
    micro methods |'
  prefs: []
  type: TYPE_TB
- en: '| `proto/encryption.proto` | Path to the protocol buffer file to be compiled
    |'
  prefs: []
  type: TYPE_TB
- en: 'It generates two new files in the project''s `proto` directory. Their names
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`encryption.pb.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encryption.pb.micro.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These code-generated files should not be modified by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s copy the `utils.go` file we have defined in the `encryptString` example.
    It can be reused as it is, except for a small change in the package name, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the copy, change the package name in the file from `utils` to `main`
    (because now, this file is in the new project''s root), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have the `EncryptString` and `DecryptString` functions available
    throughout the Go project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add one more file called `handlers.go`, where we define the business logic
    for our service. It exports an `Encrypter` struct and a few methods that handle
    RPC requests. The code for this is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Encrypter` struct should have two methods, `Encrypt` and `Decrypt`. Each
    method takes a context object, an RPC request object, and an RPC response object.
    The job each method does is to call the respective utility function and set the
    response object with a result, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Encrypt` and `Decrypt` methods are mapped to these RPC methods in the
    protocol buffer file, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to plug these handlers into our `main` program, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` program imports the `proto` and `go-micro` packages and tries to
    create a new microservice instance. Then, it registers the service to the `Encrypter`
    handler we exported from the `handlers.go` file. Finally, it runs the service.
    All this is illustrated in the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, `micro.NewService` is being used to create a new microservice.
    It returns a `service` object. We can also collect command-line arguments by running
    `service.Init()`. In our example, we are not passing any. We can register the
    service to the handler by using the `RegisterEncrypterHandler` method. This method
    is dynamically generated by the protocol buffer compiler. Finally, `service.Run`
    starts the server. Let's run the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to build the project from the project root directory, `encryptService`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you see from the server output, Go Micro starts the microservice with a transport
    and a message broker. Now, clients can make requests to these ports. The service
    is not so useful unless there is a client to consume the API. So, in the next
    section, we'll try to build a Go Micro client and see how to connect to the preceding
    server.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to run the program without building it, you have to include all
    the packages that are imported in the `main` file.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `go run main.go handlers.go utils.go` is equivalent to `go build
    && ./encryptService`.
  prefs: []
  type: TYPE_NORMAL
- en: Building an RPC client with Go Micro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](613be150-a44b-4840-8fe5-9b41f53f3244.xhtml), *Working with Protocol
    Buffers and gRPC*, where we discussed protocol buffers, we mentioned that a server
    and client should agree on the same protocol buffer. In the same way, Go Micro
    expects the service and client to use the same `.proto` file—in our case, `encryption.proto`.
    A client can be another service that is requesting some information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build clients using Go Micro. It includes all the necessary constructs
    to connect and make RPC calls to a microservice. Our plan is to create a client
    and ask the service to encrypt and decrypt messages. Those requests will be RPC
    calls. Let''s see the steps for creating and using a Go Micro client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project for the client, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add an `encryption.proto` file in the `proto` directory, which looks exactly
    similar to that of the `service`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If observed carefully, the service name, messages, and their definitions are
    matching with that of the `service`. Now, compile the protocol buffer from the
    `encryptClient` project root, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, the client generates two files in the `proto` directory. Those
    should not be modified. Now, we are ready with our setup. Add a `main.go` file
    for making RPC calls to the service, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` program imports the `proto` and `go-micro` packages where we compiled
    protocol buffers, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A client should also be created with a function called `micro.NewService`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It can be initialized to collect environment variables. The key difference between
    a client and a service is that for the client, we create an instance of `service`
    using the `proto.NewEncrypterService` function. We use that instance to make API
    calls. Remember that the function is auto-generated by the `protoc` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `encrypter` is the service instance in the code. Next, we can make RPC
    calls by calling RPC methods directly on the service instance. Let''s pass a text
    called `"I am a Message"` with the key `"111023043350789514532147"` to encrypt
    the method, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The function, as specified in the protocol buffer, returns a response that has
    a `Result` field. We are printing that value to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s pass this result back as a cipher for the `Decrypt` function.
    It should return the original message back. We use the same key as we did for
    encryption, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These two blocks go into the `main` function. Once we are done adding them,
    let''s build and run the client, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We passed the plaintext and key, and the original message is returned back as
    the final result. It confirms that the `encrypt` and `decrypt` RPC calls are working
    properly. The benefit of Go Micro is, with a few lines of code, we can create
    microservices and clients.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we see how Go Micro supports EDAs where services and clients
    can communicate via events.
  prefs: []
  type: TYPE_NORMAL
- en: Building event-driven microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 9](4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml), *Asynchronous API
    Design*, we learned about asynchronous programming. An asynchronous API can be
    achieved by events. The service and client can talk to each other using events.
    They don't have to wait until one party finishes their job.
  prefs: []
  type: TYPE_NORMAL
- en: An event generator is an entity that generates events. An event consumer consumes
    the events from other parties. Publish/Subscribe is an architectural pattern that
    is possible with events. Go Micro supports Publish/Subscribe by using a message
    broker interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following diagram to understand the event flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/096710a3-5922-4935-ada7-c79fe1162c6d.png)'
  prefs: []
  type: TYPE_IMG
- en: A Go Micro client can **Subscribe** to a topic. A Go microservice can **Publish**
    messages into that **Topic**. Events flow from right to left in this case.
  prefs: []
  type: TYPE_NORMAL
- en: It comes with an inbuilt HTTP message broker and can be easily replaced with
    widely used message brokers such as RabbitMQ or Kafka. In our discussion, we stick
    to the default HTTP broker.
  prefs: []
  type: TYPE_NORMAL
- en: We will illustrate Publish/Subscribe with an example. Let's say a microservice
    should push weather alerts every 5 seconds. Instead of the client calling the
    service API, the service can publish those changes to a topic where a client can
    subscribe. The client consumes those alerts and does the processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all the projects we are working on, we should install Go Micro using the
    `dep` tool and running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`> dep init`'
  prefs: []
  type: TYPE_NORMAL
- en: '`> dep ensure -add "github.com/micro/go-micro"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create an `asyncServer` and an `asyncClient`. The `asyncServer`
    generates weather events, and the client consumes them. Let''s look at the steps
    for this example here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project directory, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `weather.proto` file in the `proto` directory of both `asyncService`
    and `asyncClient`. It holds a structure and RPC methods for communication. This
    file defines an `Event` that is a weather alert, and the code can be seen as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It has three fields, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`city name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix timestamp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`temperature in Celsius`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service should publish this event to a topic called `alerts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, compile the `.proto` file in both the service and client, and get auto-generated
    Go files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, we are skipping the imports in this example, so please access the
    chapter repo for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming to the service, the `main.go` file should declare a microservice and
    a publisher. A publisher is created by the `micro.NewPublisher` method. It takes
    the topic name `alerts` and a `service.Client()` as its arguments, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a dummy ticker that publishes a weather alert every `15` seconds.
    We achieve that by using the `time.Tick` built-in Go method. We spawn a `go-routine`
    that loops forever, listens to a tick, and publishes an event into the topic using
    the `publisher.Publish` method. The `Publish` method takes a context object and
    an event with data as arguments, as can be seen in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, finally, we have to run the service by calling the `service.Run`
    method, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `service` and `go-routine` run in parallel. When you run this service,
    you see this output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the service is pushing events, but there is no client to consume them.
    Let''s update the `main.go` file `asyncClient` with consuming logic. In the client,
    we should declare a handler function to process the event. The handler is executed
    whenever there is an incoming event. It prints out the event in our case, as can
    be seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the handler function to process events, we can attach the client
    with the topic. The `micro.RegisterSubscriber` function attaches a `ProcessEvent`
    handler function to the `alerts` topic, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program, it consumes the alerts published by the service we
    defined previously, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is how asynchronous behavior is achieved in microservices. The border between
    clients and services can blur, as anyone can publish or subscribe. In a distributed
    system, services are clients to other services. So, Go Micro provides a lightweight
    and flexible approach to creating microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss the logging and instrumentation of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Adding logging to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is a crucial aspect of microservices. We can write middleware to capture
    all requests and responses going into and out of a service. Even for a client,
    we can capture logs while making RPC calls to a service.
  prefs: []
  type: TYPE_NORMAL
- en: Go Micro is a lean framework and doesn't enforce logging by default. We can
    easily wrap a service handler with our own custom logger. For example, in the
    `encryptService` example, we have a file called `handlers.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to activate logging for each request in a custom format, we have to
    define a wrapper, and then link it to the service. As an example, if we have to
    log every incoming encryption request, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `wrapper` function. It takes `Context`, `Request`, and `Response`
    as arguments. Here, we just print the time of the request arrival, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In `service`, we can attach the wrapper, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the service logs every request in the format defined in the wrapper function,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For more information about logging, see the documentation at [https://micro.mu/docs/go-micro.html#wrappers](https://micro.mu/docs/go-micro.html#wrappers).
  prefs: []
  type: TYPE_NORMAL
- en: The instrumentation of services is out of the scope of this book, but there
    is an open standard called **OpenTracing** ([https://opentracing.io/](https://opentracing.io/)).
    It defines a standard for how to metricize API endpoints, number of requests,
    and so on. Please feel free to explore it.
  prefs: []
  type: TYPE_NORMAL
- en: The APIs we created in this chapter are RPC-based. To convert them to REST,
    you just have to use a plugin called **Micro Web**. For more information, see
    this link for easy conversion to REST ([https://micro.mu/docs/go-web.html](https://micro.mu/docs/go-web.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with the definition of microservices. The main difference
    between a monolithic application and a microservice is the way a tightly coupled
    architecture is broken into a loosely coupled architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices talk to each other using either REST-based JSON or RPC-based protocol
    buffers. Using microservices, we can break business logic into multiple chunks.
    Each service does one job pretty well. Go has a lightweight framework called **Go
    Micro**. Using it, we can create services and clients.
  prefs: []
  type: TYPE_NORMAL
- en: We first created an encryption service using `Micro go`. We then developed a
    client for consuming the service. Go Micro also allows asynchronous programming
    by providing a Publish/Subscribe pattern. Any client/service can subscribe or
    push events to a topic. It uses an HTTP broker by default but can be easily configured
    to RabbitMQ or Kafka. Go Micro also provides features such as service discovery,
    and various transport mechanisms such as protocol buffers, JSON, and so on. Small
    organizations can start with a monolith, but in bigger organizations with huge
    teams, microservices are better suited.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to see how to deploy our Go services using
    nginx. A service needs to be deployed for it to be exposed to the outside world.
    We also use `docker-compose` and containers for a clean deployment.
  prefs: []
  type: TYPE_NORMAL
