- en: Deploying REST Services on Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After preparing a deployable ecosystem, we have to host that ecosystem on a
    cloud provider to make **application programming interface** (**API**) endpoints
    visible to the public internet. We need to leverage cloud services such as **Amazon
    Web Services** (**AWS**) **Elastic Compute Cloud** (**EC2**) to deploy web services.
  prefs: []
  type: TYPE_NORMAL
- en: The journey doesn't end right after deployment. We have to track our API usage
    and performance for a better understanding of the clients. Who are the clients
    that are connecting to an API? How frequent are their requests? How many failed
    authorizations and so on are important factors for fine-tuning an API? For better
    security, an API server should not be directly exposed to the public internet.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore AWS. However, sticking to a single cloud provider
    can be a problem for migration later. So, we will use a tool called Terraform
    to define and create our resources. Terraform is an **Infrastructure as Code**
    (**IaC**) tool that is cloud-agnostic. We provision an EC2 instance and an API
    Gateway in order to properly deploy our **Representational State Transfer** (**REST**)
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics for working with AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IaC with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is an API Gateway required?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing AWS API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other API Gateways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software should be pre-installed for running the code samples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating system: Linux (Ubuntu 18.04)/Windows 10/Mac OS X>= 10.13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go stable version compiler >= 1.13.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker version >= 18.09.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform version >= 0.12.18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter13](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter13).
    Clone the code, and use the code samples in the `chapter13` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Basics for working with AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS is a cloud provider that manages the infrastructure for cloud applications.
    The other big players are Microsoft Azure and **Google Cloud Platform** (**GCP**).
    Each of them is equipped with many diverse solutions for managing a variety of
    artifacts, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker image management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event buses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple types of managed services for running applications. We'll
    discuss a few in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Managed services for applications from AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application should be hosted on a cloud server to serve an API to the public
    internet. That server can be an independent machine or a container. AWS provides
    a standalone server called a **virtual machine **(**VM**), in the form of EC2\.
    AWS EC2 is a managed service that provides easy creation and teardown of VMs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elastic Container Service** (**ECS**), another managed service from AWS,
    allows developers to run their applications in containers. A Go application can
    be bundled into a Docker image and deployed on AWS ECS.'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Lambda** is another managed service that can run serverless functions.
    This is a service that runs Go functions. These functions are short-lived and
    suitable for use cases such as **Extract-Transform-Load** (**ETL) **on data. A
    lambda function definition takes compiled Go code and can run thousands of lambda
    instances on demand.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the use case, we should pick the right service for running our
    application. The Docker container-based ECS is preferable over EC2 for running
    long-running services as well as short-lived applications because of its simplified
    build, push, and deploy cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will try to leverage AWS EC2 to deploy an API server. Next,
    we secure our server using Amazon API Gateway. The following chart can guide you
    about picking the right AWS service for managing a Go application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Where To Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `AWS Lambda` | Functions that live less than 15 minutes (as per the time
    of writing) |'
  prefs: []
  type: TYPE_TB
- en: '| `AWS ECS` | Short-lived and long-running services with AWS-managed containers
    |'
  prefs: []
  type: TYPE_TB
- en: '| `AWS EC2` | Long-running services with a self-managed VM |'
  prefs: []
  type: TYPE_TB
- en: In the next section, we'll see how to set up an AWS Free Tier account. We will
    use that account for all our code examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an AWS account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need an AWS account to work on this chapter. If you don't have one, you can
    try AWS for 1 year, using the Free Tier program: [https://aws.amazon.com/free/](https://aws.amazon.com/free/).
  prefs: []
  type: TYPE_NORMAL
- en: After signing up for the Free Tier, we can get access to our AWS account by
    setting a password. AWS accounts have a custom URL, where account administrators
    and other users can log in to the account dashboard: [https://console.aws.amazon.com/billing/home?#/account](https://console.aws.amazon.com/billing/home?#/account).
  prefs: []
  type: TYPE_NORMAL
- en: All the main services are free, but with a few limits. So, always monitor the
    free-tier usage of AWS services while testing. AWS offers a unique model of roles
    called **Identity and Access Management** (**IAM**). This enables new users to
    be created and gives permissions to various services.
  prefs: []
  type: TYPE_NORMAL
- en: After we set up our AWS account, we should create IAM users and roles. But for
    the sake of simplicity, we will proceed with the account we created previously,
    where the creator is automatically an admin. We should allow programmatic access
    to our AWS account in order to deploy applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways we can interact with AWS to provision managed services:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS **Command-Line Interface** (**CLI**) tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party **Software Development Kit** (**SDK**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first option, a user logs in to an AWS account and manually configures
    the AWS resources. In the second one, a user can install the client on their machine
    and manage resources using a command-line API. The third option is very low-level,
    where third-party libraries wrap the AWS API and provide a clean interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second and third options, a security credential has to be generated.
    A security credential consists of two keys:'
  prefs: []
  type: TYPE_NORMAL
- en: Access Key ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret access key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This security credential is used to authenticate any third-party applications
    with AWS. It can be obtained by navigating to IAM| Users| User| Name| Security
    Credentials on the AWS account and performing a Create Access Key operation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an `access_key_id` also generates a `secret_access_key`. These should
    be stored in a safe place. If you lose your secret key, you have to delete it
    from the IAM security credentials and create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Once a user obtains an access key ID and a secret access key successfully, they
    should create two files in the `.aws` directory in the `home` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux and Mac OS X, create two files with the names `credentials` and `config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`~/.aws/credentials`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`~/.aws/config`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The credential file holds information about the access key and the secret access
    key in order to authenticate with AWS. The configuration file configures settings
    such as the AWS region in operation and the AWS CLI output format, such as JSON,
    XML, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, files should be created in `C:\> dir "%UserProfile%\.aws"`.
  prefs: []
  type: TYPE_NORMAL
- en: You have to replace the `YOUR_ACCESS_KEY_ID` and  `YOUR_SECRET_KEY` variables
    with actual security credentials from your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: The region in the configuration file is the geographical location where the
    application is hosted. In the preceding configuration, we picked Frankfurt(eu-central-1)
    as the preferred region. You should select the region that's closed to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to run an application behind the API Gateway on AWS. Instead of
    doing that manually from the AWS console, we are going to use a tool called Terraform.
    Terraform provides IaC, where we can have Terraform scripts record the resource
    creation on AWS. AWS provides an in-house IaC solution called **CloudFormation**.
    Terraform is much simpler—as well as less verbose—than AWS CloudFormation. In
    the next section, we'll explore Terraform and its internals.
  prefs: []
  type: TYPE_NORMAL
- en: IaC with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Terraform** is a software tool for provisioning infrastructure on cloud platforms,
    including AWS. Using Terraform, we can create, configure, or delete resources.
    Terraform allows automatic resource provisioning compared to the AWS Console.
    When compared to low-level REST APIs and SDKs, Terraform has a clean, high-level
    API. Terraform stores the current state of provisioned infrastructure in a state
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's say the infrastructure provisioned on an account should be replicated
    on another account as part of disaster recovery. If we do not have IaC, all resources
    have to be reconfigured manually. However, if the whole infrastructure is modeled
    in the form of Terraform scripts, then it is easy to replay the infrastructure
    on any number of accounts. This approach is very readable and maintainable compared
    to hand-wiring infrastructure on the AWS console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform provisions almost all AWS managed services on the Cloud. It should
    be run from a local machine. It generates state files while provisioning. See
    the following diagram for provisioning direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33ebc2b1-eda6-439e-b579-ee40bfd9dcf7.png)'
  prefs: []
  type: TYPE_IMG
- en: A Terraform installation binary for all platforms can be obtained here: [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux and Mac OS X, copy the executable to the respective binary paths
    so that it is available system-wide. Confirm your installation with this command.
    It prints out the `version` of the `Terraform` software you''ve installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To give a brisk introduction to Terraform, let us provision an EC2 instance
    for our REST API server using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project directory called `intro` to hold the script for the provisioning
    EC2 instance, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All Terraform files have a `.tf` file extension. So, add a script called `api_server.tf`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The language syntax of a Terraform file looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, a Terraform script is made up of four fundamental building blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block Type**: A set of predefined block types by Terraform—for example, resource
    and data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block Label**: The namespace of a block type in a Terraform script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifier**: The variable inside a block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expression**: The value of the variable inside a block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check out all the possible values of these four entities in the Terraform
    configuration language at [https://www.terraform.io/docs/configuration/index.html](https://www.terraform.io/docs/configuration/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the actual script, `api_server.tf`. It should have two blocks, `provider`
    and `resource` like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `provider` block defines the type of cloud provider to use and configures
    the security credentials and region. The `resource` block is used to define the
    type of resource to be provisioned and its attributes. Here, we are provisioning
    an EC2 instance, thus we provided `aws_instance` as the resource type. The `api_server`
    is the name of the instance that gets created. There are many instance types provided
    by EC2\. Here, we use the smaller-capacity instance called `t2.micro`.
  prefs: []
  type: TYPE_NORMAL
- en: AWS uses an **Amazon Machine Image** (**AMI**) to create a virtual machine.
    We picked Ubuntu 18.04 as the `ami-03818140b4ac9ae2b` operating system image in
    the Terraform file. You can find the AMI image closest to your region here: [https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/).
  prefs: []
  type: TYPE_NORMAL
- en: The attributes can change according to the resource type. So, if we pick a different
    resource, we have to check the Terraform documentation for appropriate attributes.
    In the preceding resource block, we only defined two attributes: `ami` and `instance_type`.
    Those two attributes are mandatory for the AWS EC2 API. All other attributes—such
    as network, security groups, and CPU—default to reasonable values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the script from the `intro` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The script outputs the following message, and also asks for confirmation of
    the `apply` process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It successfully created the EC2 instance. We can navigate to the EC2 section
    on the AWS console to see our instance up and running, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/846fd16e-1287-408a-878b-ccf8f1b7551f.png)'
  prefs: []
  type: TYPE_IMG
- en: Details such as Availability Zone, Public IP, and so on are automatically assigned
    because we didn't specify them as attributes in the Terraform file. AWS creates
    a default **Virtual Private Cloud** (**VPC**), subnets, and a public **Domain
    Name System** (**DNS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you observe carefully, `terraform apply` generates the following additional
    files in the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`terraform.tfstate`: This holds the JSON plan that is executed with AWS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.terraform`: This is a directory that holds plugins, depending on the provider.
    In our case, the provider type is AWS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform installs a provider-related executable in the project's `.terraform`
    directory. This is to reduce the file size of the Terraform binary, which excludes
    the packages for compiling scripts to other cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: The plugin version in `.terraform/plugins` also has a version. You should have
    the latest plugin to benefit from up-to-date Terraform syntax. Otherwise, the
    syntax for referencing one resource in another may raise errors. To be safe, please
    upgrade the plugin to the latest version using this command: `terraform 0.12upgrade`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have successfully provisioned an EC2 instance, but it is useless until we
    can SSH into it. For that, we should provide a key pair. Let''s look at the steps
    to do that, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate a public/private key pair on your local machine like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This generates public and private key files in the `~/.ssh` directory. A public
    key is for other parties to encrypt data, and a private key is for the owner to
    decrypt that data. Your public key file's default name is `id_rsa.pub` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new resource type called `aws_key_pair` in the `api_server.tf` file,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding block, Terraform creates a new AWS key-pair resource called
    `api_server_key`. It takes a `key_name` and a `public_key`. This is your newly
    created public key. AWS adds this key to `~/.ssh/known_hosts` on an EC2 instance
    so that you can log in to the VM once the provision is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should link this newly created resource to our main resource `aws_instance`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see the plan that Terraform executes with the `terraform plan`
    command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As it clearly states in the preceding log, Terraform performs the creation of
    one new resource, `aws_key_pair`, and recreates the server. The Terraform `plan`
    step is a good way to inspect changes before applying them on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us actually apply the changes with the `terraform apply` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the AWS account console (browser), navigate to the EC2| NETWORK &
    SECURITY| Key Pairs section. You will find the newly added key pair there, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/77b9c398-3eb8-448a-85e7-4d04f88501ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, in order to SSH into our EC2 instance, we need the public DNS of the instance.
    We can get the public DNS either from the AWS console or from the `terraform.tfstate`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The public DNS, in our case, is `ec2-52-59-192-138.eu-central-1.compute.amazonaws.com`.
    We can now SSH into this system as a Ubuntu user, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This command picks the `~/.ssh` folder and locates the private key. It then
    does a handshake with the public key we linked with the EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: The Ubuntu image comes almost zero configured. Software such as the Go compiler,
    Docker, and docker-compose is not installed by default on the Ubuntu EC2 instance.
    We have to install them before deploying our application. Make sure you SSH into
    the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the latest version of the Go compiler and Docker, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `docker-compose`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you may have notice, the username we used for SSH is `ubuntu`. It depends
    on the AMI used for instance provision. For example, if the image is an Amazon
    Linux Image, then the SSH username will be `ec2-user`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll walk through the deployment of a REST API on an EC2
    instance. We will use the previously provisioned machine in our journey.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a service on EC2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we''ve provisioned an EC2 instance with a public DNS. Now, we need an
    API to deploy on the instance. Let us use the `bookServer` containerized application from
    [Chapter 12](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml), *Containerizing REST
    Services for Deployment*. There, we developed a Go API server that serves book
    details on an endpoint. In this section, let us try to deploy that ecosystem on
    an AWS EC2 instance. Let''s look at the steps to deploy `bookServer` on AWS EC2,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the code from `chapter12/deploySetup` into the `/home/ubuntu` directory
    of the instance. You can do that using the `scp` command, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command copies the source code from [Chapter 12](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml), *Containerizing
    REST Services for Deployment*,to the target instance. We have our application
    code ready. The code has a `Makefile` that builds the Go binary and deploys various
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember building the `deploySetup` application from [Chapter 12](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml), *Containerizing
    REST Services for Deployment*, then you''ll remember that we can launch nginx,
    the application server, and `supervisord` using the `make` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This step builds and starts Docker containers in the background, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We need to use `sudo make` instead of `make` because of user permissions. The
    default `ubuntu` user doesn't have permissions to the Docker daemon by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the nginx container and app container are up and running. We can confirm
    this with the `docker ps` command, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This shows that our nginx and app containers are up and running on the EC2 instance,
    and nginx is serving on port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: Get the public IP from the AWS console or the `terraform.tfstate` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always confirm the ports that have been exposed for Docker containers. The format
    `0.0.0.0:80->80/tcp` means the container TCP port `80` forwards packets to the
    host port `80`. In our case, the host is an EC2 instance and the container is
    nginx.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the instance''s public IP is `52.59.192.138`. Refer to the following
    screenshot to see where we can find out the public IP from the AWS console EC2
    instances section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0c339c0-a385-40c2-b165-e759991ed3b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make a `curl` request to the `http://public-ip/api/books` endpoint from your
    host machine (not from the EC2 instance). You''ll get a JSON response back from
    the server, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Hurray! Our API has been published to the web and is accessible worldwide.
    Here, nginx is acting as an entry point to HTTP requests. The setup we deployed
    is a minimal way to publish an API on AWS. In a real-world scenario, you have
    to do a few more things, such as the following, to secure the API:'
  prefs: []
  type: TYPE_NORMAL
- en: Serve requests on HTTPS (by adding certificates)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the VPC, subnets, and security groups properly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the preceding recommendations to our EC2 instance is out of the scope
    of this book. Please refer to the AWS documentation on these topics for more information.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll configure our EC2 instance with Amazon API Gateway.
    As we discussed at the beginning of this chapter, an AWS Gateway is a primary
    way to secure EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: Why is an API Gateway required?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose a company named `XYZ` developed an API for its internal purposes. There
    are two ways in which it exposes that API for external use:'
  prefs: []
  type: TYPE_NORMAL
- en: It exposes it using authentication from known clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It exposes it as an API as a service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, this API is consumed by the other services inside the company.
    Since they are internal, we don't restrict access. But in the second case, since
    the API details are given to the outside world, we need a broker in-between to
    check and validate the requests. This broker is the API Gateway. An API Gateway
    is a broker that sits in-between the client and the server and forwards the request
    to the server, on the passing of specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the company `XYZ` has an API written in Go and also in Java. There are
    a few common things that apply to any API:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging of requests and responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without an API Gateway, we need to write another server that tracks things such
    as requests and authentication of the API. This can be hectic to implement and
    maintain when new APIs keep being added to the organization. To take care of these
    basic things, an API Gateway is a fine piece of middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, an API Gateway does these things:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging is the way in which we track requests and responses. In contrast to
    application-level logging, which happens in the Go web server, an API Gateway
    can support organization-level logging across multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is a part of securing applications. It can be basic authentication,
    token-based authentication, OAuth2.0, and so on. It is essential to restrict access
    to the API for valid customers/clients.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic control comes into play when an API is a paid service. When an organization
    sells data as an API, it needs to limit the operations per client. For example,
    a client can make 10,000 API requests per month. The rate can be set according
    to the plan the client has opted for. This is a very important feature.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is for modifying the request before it hits the application server
    or for modifying the response before it is sent back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b421c07d-fa75-4a71-8ee2-2b9b2b7223ca.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts an **API Gateway** accepting all **client** requests.
    The API Gateway can forward requests to respective API servers based on HTTP headers,
    URL path prefix, or IP address. Once the API server finishes its job, the **API
    Gateway** collects an intermediate response and returns it to the **Client**.
    In this chapter, we'll try to leverage Amazon API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Amazon API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Amazon API Gateway has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse proxy service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverse proxying** is the process of passing a REST API request to another
    endpoint. Amazon API Gateway can register a REST endpoint with a custom path and
    method. It forwards a matching request to the application server. It can also
    authenticate using AWS user credentials, as well as security tokens. The user
    has to be created on AWS IAM in order to access the API.'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring is possible by writing Gateway rules. The logs can be directed to
    AWS CloudWatch, which is another Amazon-offered service. When there are suspicious
    incoming requests, the Gateway can also raise a CloudWatch alarm. A CloudWatch
    alarm is a notification for special situations. These notifications can trigger
    other actions, such as sending an email or logging an event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us provision an API Gateway for our EC2 instance. The architecture
    diagram looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94e89dba-b3fb-4c2b-9d9b-b5d3baedd344.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, the Amazon API Gateway defines methods and integrations.
    The target is an EC2 instance where a `books` API is deployed. We should configure
    six types of components to run API Gateway on AWS. Those are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Gateway REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway Method Request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway Method Response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway Integration Request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway Integration Response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why do we have to create the preceding components? The Amazon API Gateway architecture
    defines these components in its design. See the following diagram to see how an
    API is represented on Amazon API Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d505974d-9119-47f8-8426-3d921edecf71.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Client** request is sent through the **Gateway Method Request** and **Integration
    Request** stages. The Integration Request stage then forwards the request to a
    configured API endpoint. That endpoint will be `/api/books` with the `GET` method
    and will be running on an EC2 instance. This finishes the request life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the endpoint returns a response from the EC2 instance. This response is
    forwarded to the **Integration Response** stage and then to the **Gateway Method
    Response** stage. This finishes the response life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage can be configured further to transform responses into different formats.
    For simplicity, we leave the default settings as they are for each stage. In the
    next section, we'll try to build the preceding components in Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Manually create the API Gateway for our API in the AWS console before writing
    Terraform scripts. This helps you understand the basic vocabulary of Amazon API
    Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying our service behind Amazon API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pausing the theory, let us quickly jump into an example. Our goal is to set
    up the API Gateway for the previously deployed `books` API as a target. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a new project and write a new Terraform script that creates and
    deploys an API on Amazon API Gateway, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It also links our EC2 instance and API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add the Gateway REST API component to the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes a few important attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: Name of the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: Text about the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoint_configuration`: Defines which mode of the API to publish (`REGIONAL` or `EDGE`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These details are used to identify an API in the Amazon API Gateway. We named
    our API `EC2Example`. The `aws_api_gateway_rest_api` resource type is a Terraform
    resource type. Our resource name is `test`. From here on, we will see similar
    names for all other resource types we create.
  prefs: []
  type: TYPE_NORMAL
- en: When AWS creates the `aws_api_gateway_rest_api` component, it also creates a
    default Gateway Resource on AWS. A Gateway Resource is a relative path for endpoints
    we configure as part of the integration.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have to create a gateway method called `test`. It takes the `rest_api_id`,
    `resource_id`, and `http_method` attributes. These three attributes are common
    for all components. Let us call these `DEFAULT_ATTRIBUTES`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition, we set `Authorization=NONE` on this component. If we set authorization
    to `AWS_IAM`, then a client has to provide AWS access keys and a token along with
    the request. We are disabling the gateway authentication for now, as shown in
    the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the method request, we should add the method response component.
    This also takes `DEFAULT_ATTRIBUTES` plus `status_code`. That means whenever a
    method response receives `200` `OK` from an integration response, it passes it
    to the client as a successful message, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the integration components. There are two integration components,
    as we recollect from the API architecture diagram in the previous section. The
    `integration response` component is similar to the `method_response` component,
    as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The main link between the API Gateway and our API running on an EC2 instance
    is created in the `integration request` component. It takes `DEFAULT_ATTRIBUTES`,
    plus three important attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`integration_http_method`: Decides which HTTP method should be called on the
    endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: Denotes which type of endpoint is being used: `HTTP`, `Lambda`, or `AWS_PROXY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uri`: The actual reference of the endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, because we want to link the Gateway and the EC2 instance, we use
    `HTTP` as our `type`, and the public DNS of our EC2 instance as `uri`. The Terraform
    block looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have set `integration_http_method` to `GET` because our `books` API only
    has an endpoint with the GET method. For the `uri` attribute value, we are referencing
    `public_dns` from the `aws_instance.api_server` EC2 instance resource. Since both
    the Terraform scripts— `api_server.tf` and `api_gateway.tf`—are in the same `intro` project
    directory, we can import the resources from another.
  prefs: []
  type: TYPE_NORMAL
- en: 'This finishes all five crucial components of the API. We have to deploy the
    API using a test environment. Terraform provides a resource type called `aws_api_gateway_deployment`
    to create a deployment. Deployments are useful for testing or publishing Amazon
    API Gateway endpoints to the web. The deployment takes the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A deployment also depends on an `integration request`, so we added a `depends_on`
    attribute. The `stage_name` attribute can take stage, `"test"`, or prod environment
    types. This finishes our API Gateway creation. Let us run the script to create
    and deploy our API on Amazon API Gateway, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, where can clients access the new URL of the API Gateway? You can get the
    `invoke_url` from the `terraform.tfstate` file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`invoke_url` is the API Gateway endpoint. This endpoint should be attached
    to a custom domain while publishing an API. If you make a `curl` request to the
    preceding URL, you should receive books as a JSON response, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This confirms that all the components are functioning properly and that all
    requests/responses are routed through API Gateway. You can define many such endpoints
    and configure components to achieve the desired behavior. Adding authentication
    is left as an exercise to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip for solving this exercise: Try to modify the right component to authenticate
    and authorize client requests.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll mention other important API Gateways that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Other API Gateways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other API Gateway providers available in the market. As we mentioned
    earlier, all gateways provide the same set of features. Similar to AWS API Gateway,
    Apigee is another well-known API Gateway technology that is a part of Google Cloud.
    The problem with cloud providers is that they can cause vendor lock (that is,
    they cannot easily migrate to another platform). There are many open source API
    Gateways available on the market.
  prefs: []
  type: TYPE_NORMAL
- en: 'The right way to pick an API Gateway depends on the conditions of the business.
    If the API server is living on the AWS cloud, AWS API Gateway is a nice choice.
    For a company that can manage a gateway by itself, it is worth trying the following
    open source alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tyk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KrakenD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no best choice, but if workloads are not so big, nginx can also be
    used as an API Gateway. See [https://www.nginx.com/learn/api-gateway/](https://www.nginx.com/learn/api-gateway/) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)) can be a wise
    choice for those who like to manage the API Gateway by themselves. Also, another
    good reason to use Kubernetes is that it is getting widely adapted.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon also provides the **Elastic Kubernetes Service** (**EKS**) for running highly
    available clusters over different regions. With EKS, the API Gateway is included
    as an installed component.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with the basics of working with AWS. Amazon provides
    a free-tier to experiment with their cloud. Once we sign up for the free-tier,
    we should get access to the AWS console and be able to create security credentials.
    These security credentials are required for applications to access AWS.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw how a tool such as Terraform can provision cloud resources. We picked
    AWS EC2 as our choice to deploy an API. We wrote a Terraform script to provision
    an EC2 instance, along with a key pair. This key pair was required to log in to
    the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Once we were able to log in to the EC2 instance, we installed all the dependencies
    for our API server. We reused the project code from [Chapter 12](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml), *Containerizing
    REST Services for Deployment*, where we prepared an API ecosystem. We successfully
    deployed the `books` API from the EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: A simple API server has fewer capabilities in terms of rate-limiting to clients,
    authentication, and authorization. We need a dedicated API Gateway that can pass
    the requests to the API server. AWS provides a managed gateway solution called
    `Amazon API Gateway`. We saw the architecture of Amazon API Gateway and provisioned
    an API on the gateway using Terraform. The architecture has six important components,
    which discussed in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we mentioned other gateway solutions available in the market. In the
    next chapter, we will discuss API authentication patterns, including **JSON Web
    Token** (**JWT**) authentication, in detail.
  prefs: []
  type: TYPE_NORMAL
