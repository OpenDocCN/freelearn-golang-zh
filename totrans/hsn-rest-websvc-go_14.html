<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Handling Authentication for our REST Services</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we are going to explore <strong>Representational State Transfer</strong> (<strong>REST</strong>) API authentication patterns. These patterns are session-based authentication, <strong>JSON Web Tokens</strong> (<strong>JWT</strong>), and <strong>Open Authentication 2</strong> (<strong>OAuth 2.0</strong>). We will try to leverage the Gorilla package's <kbd>sessions</kbd> library to create basic sessions. Then, we will move on to advanced REST API authentication strategies, such as stateless JWT. Finally, we will discuss the OAuth 2.0 authentication pattern and the security aspects of an API. In the previous chapter, the <strong>Amazon Web Services</strong> (<strong>AWS</strong>) API Gateway took care of authentication (using <strong>Identity and Access Management</strong> (<strong>IAM</strong>) roles) for us. If an API Gateway is not present, how do we secure our API? You will find the answer in this chapter.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How simple authentication works</li>
<li>Introducing Postman, a visual client for testing a REST API</li>
<li>Persisting client sessions with Redis</li>
<li>Introducing JWT and OAuth 2.0</li>
<li>JWT in an OAuth 2.0 workflow</li>
<li>Exercise for the reader</li>
<li>Security aspects of an API</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements </h1>
                </header>
            
            <article>
                
<p>The following software should be pre-installed for running the code samples:</p>
<ul>
<li>Operating system: Linux (Ubuntu 18.04)/Windows 10/<span>Mac OS X</span>  &gt;= 10.13</li>
<li>Go stable version compiler &gt;= 1.13.5</li>
<li>Dep: A dependency management tool for Go &gt;= 0.5.3</li>
<li>Docker version &gt;= 18.09.2</li>
</ul>
<p>You can download the code for this chapter from <a href="https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter14" target="_blank">https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter14</a>. Clone the code, and use the code samples in the <kbd>chapter14</kbd> directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How simple authentication works</h1>
                </header>
            
            <article>
                
<p>Traditionally, authentication—or simple authentication—works with sessions. The flow starts like this. A client sends an authentication request to the server using user credentials. The server takes those credentials and matches them with the credentials stored on the server. If a match is successful, it writes something called a <strong>cookie</strong> in the response. This cookie is a small piece of information that is transferred by the client for all subsequent requests. Modern websites are being designed to be <strong>single-page applications</strong> (<strong>SPAs</strong>). In those websites, static assets such as HTML and JavaScript files are served from a <strong>Content Delivery Network</strong> (<strong>CDN</strong>) to render the web page initially. After that, the communication between the web page and application server happens only through the REST API/web services.</p>
<p>A <strong>session</strong> is a nice way to record user communication in a given period of time. A session is a concept whereby authentication information is stored in a cookie. The following diagram explains what happens in a basic session-based authentication:</p>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/474314d9-b218-4c16-ae15-8c72dcd32b49.png"/></div>
<p>Now, let's look at a practical approach. A <strong>Client</strong> (for example, a browser) sends a request to the <strong>Login API</strong> of the <strong>Server</strong>. The server tries to check those credentials with the database and, if the credentials exist, writes a <strong>cookie</strong> back onto the response saying that this user is authenticated.</p>
<p>A <strong>cookie</strong> is a message consumed by the server at a later point in time. When the client receives the response, it stores that cookie locally. After that, the client can ask for resources from the server by showing the cookie as the key for passage.</p>
<p>When a client decides to terminate the session, it calls the logout API on the server. The server destroys the session in the response. This process is repeated for every login/logout. The server can also place an expiration on cookies so that the authentication window is valid for a certain time if there is no activity. This is how many websites work.</p>
<p>Now, we'll try to implement one such system using the <kbd>gorilla/sessions</kbd> package. We already learned about gorilla/mux in the initial chapters. We need to install the package first by using the following command:</p>
<pre>go get github.com/gorilla/mux<br/>go get github.com/gorilla/sessions</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Alternatively, we could do this by using the Dep tool, as follows:</p>
<pre>dep init<br/>dep ensure -add github.com/gorilla/mux<br/>dep ensure -add github.com/gorilla/sessions</pre>
<p>We can create a new session using the <kbd>NewCookieStore</kbd> method from the <kbd>sessions</kbd> package, like this:</p>
<pre>var store = sessions.NewCookieStore([]byte("secret_key"))</pre>
<p>That <kbd>secret_key</kbd> should be the key that <kbd>gorilla/sessions</kbd> uses to encrypt the session cookies. If we add a session as a normal text, anyone can read it. So, the server needs to encrypt a message to a random string. For that, it asks to provide a secret key. This secret key can be any randomly generated string.</p>
<p>Keeping secret keys in code is not a good idea, so we try to store it as an environment variable and read it in code on the fly. In the next section, we'll look at an example of session authentication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A simple authentication example</h1>
                </header>
            
            <article>
                
<p>Let's build a secure API that gives access to clients only after logging in. In the process, we will define three endpoints:</p>
<ul>
<li><kbd>/login</kbd></li>
<li><kbd>/logout</kbd></li>
<li><kbd>/healthcheck</kbd></li>
</ul>
<p><kbd>/healthcheck</kbd> is the data API, but it first has to log in using the /login endpoint. Our API should reject all unauthenticated requests. Create a project directory called <kbd>simpleAuth</kbd>, like this:</p>
<pre><strong>mkdir -p $GOPATH/src/github.com/git-user/chapter14/simpleAuth</strong><br/><strong>touch $GOPATH/src/github.com/git-user/chapter14/simpleAuth/main.go</strong></pre>
<p>In the program, we can see how to enable session-based authentication to API endpoints using the gorilla/ sessions package. Follow these steps:</p>
<ol>
<li>We need imports for our program. The main ones are <kbd>mux</kbd> and <kbd>sessions</kbd>, as seen in the following code block:</li>
</ol>
<div>
<pre style="padding-left: 60px">package main<br/>import (<br/>    "log"<br/>    "net/http"<br/>    "os"<br/>    "time"<br/>    "github.com/gorilla/mux"<br/>    "github.com/gorilla/sessions"<br/>)</pre></div>
<ol start="2">
<li>Now, create a cookie store to store the written cookie information. We can do that using the <kbd>sessions.NewCookieStore</kbd> method. It takes a byte array of the secret key. The secret key is fetched from the <kbd>SESSION_SECRET</kbd> environment variable, like this:</li>
</ol>
<pre style="padding-left: 60px">var store = sessions.NewCookieStore([]byte(os.Getenv("SESSION_SECRET")))</pre>
<p style="padding-left: 60px">You can set any key you wish to that environment variable.</p>
<ol start="3">
<li>Let us create mock <kbd>usernames</kbd> and a <kbd>password</kbd> as we don't have a signup mechanism, as follows:</li>
</ol>
<pre style="padding-left: 60px">var users = map[string]string{"naren": "passme", "admin": "password"}</pre>
<p style="padding-left: 60px">These mock username/password combinations are checked against a client request.</p>
<ol start="4">
<li>Now, add a login handler that sets the cookie. The API is a <kbd>POST</kbd> request with credentials supplied in the <span class="packt_screen">POST</span> body, as follows:</li>
</ol>
<pre style="padding-left: 60px">func LoginHandler(w http.ResponseWriter, r *http.Request) {<br/>   ...<br/>}</pre>
<ol start="5">
<li>In this function, we should first parse the <span class="packt_screen">POS</span><span class="packt_screen">T</span> body, and get the <kbd>username</kbd> and <kbd>password</kbd>, like this:</li>
</ol>
<pre style="padding-left: 60px">err := r.ParseForm()<br/><br/>if err != nil {<br/>http.Error(w, "Please pass the data as URL form encoded",<br/> http.StatusBadRequest)<br/>    return<br/>}<br/>username := r.PostForm.Get("username")<br/>password := r.PostForm.Get("password")</pre>
<ol start="6">
<li>Once we have collected the <kbd>username</kbd> and <kbd>password</kbd>, our plan is to validate them with the mock data. If the credentials are matching, then set the request session to authenticated. Otherwise, show the error message accordingly, as follows:</li>
</ol>
<pre style="padding-left: 60px">if originalPassword, ok := users[username]; ok {<br/>    session, _ := store.Get(r, "session.id")<br/>    if password == originalPassword {<br/>        session.Values["authenticated"] = true<br/>        session.Save(r, w)<br/>    } else {<br/>        http.Error(w, "Invalid Credentials", http.StatusUnauthorized)<br/>        return<br/>    }<br/>} else {<br/>    http.Error(w, "User is not found", http.StatusNotFound)<br/>    return<br/>}<br/>w.Write([]byte("Logged In successfully"))</pre>
<p style="padding-left: 60px">This completes the login handler.</p>
<ol start="7">
<li>In a similar way, let us define the logout handler. The logout handler takes an incoming <kbd>GET</kbd> request and sets the session variable authenticated to <kbd>false</kbd>, like this:</li>
</ol>
<pre style="padding-left: 60px">// LogoutHandler removes the session<br/>func LogoutHandler(w http.ResponseWriter, r *http.Request) {<br/>    session, _ := store.Get(r, "session.id")<br/>    session.Values["authenticated"] = false<br/>    session.Save(r, w)<br/>    w.Write([]byte(""))<br/>}</pre>
<ol start="8">
<li>If you see the logout handler implementation, then we have modified the <kbd>session</kbd> object to invalidate the client session, as follows:</li>
</ol>
<pre style="padding-left: 60px">session, _ := store.Get(r, "session.id")
session.Values["authenticated"] = false
session.Save(r, w)</pre>
<ol start="9"/>
<ol start="9">
<li>In this way, simple authentication can be implemented using client sessions in any programming language, including Go.</li>
</ol>
<p style="padding-left: 60px">Don't forget to save the cookie after modifying it. The code for this is <kbd>session.Save(r, w)</kbd>.</p>
<ol start="10">
<li>Now, let us define our <kbd>/healthcheck</kbd>. data API. It is an API that sends the system time back. It returns a response if the client session is authenticated. Otherwise, it returns a <kbd>403 Forbidden response</kbd>. The <kbd>session</kbd> object from the request can be used for the validity check, as follows:</li>
</ol>
<pre style="padding-left: 60px">// HealthcheckHandler returns the date and time<br/>func HealthcheckHandler(w http.ResponseWriter, r *http.Request) {<br/>    session, _ := store.Get(r, "session.id")<br/>    if (session.Values["authenticated"] != nil) &amp;&amp; session.Values<br/>    ["authenticated"] != false {<br/>        w.Write([]byte(time.Now().String()))<br/>    } else {<br/>        http.Error(w, "Forbidden", http.StatusForbidden)<br/>    }<br/>}</pre>
<ol start="11">
<li>All the API handlers are ready. We have to write the <kbd>main</kbd> function, where we map API endpoints (routes) to the preceding handlers. We use the <kbd>mux</kbd> router for that purpose. Then, we pass this router to an HTTP server that runs on <kbd>http://localhost:8000</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">func main() {<br/>    r := mux.NewRouter()<br/>    r.HandleFunc("/login", LoginHandler)<br/>    r.HandleFunc("/healthcheck", HealthcheckHandler)<br/>    r.HandleFunc("/logout", LogoutHandler)<br/>    http.Handle("/", r)<br/><br/>    srv := &amp;http.Server{<br/>        Handler: r,<br/>        Addr:    "127.0.0.1:8000",<br/>        // Good practice: enforce timeouts for servers you create!<br/>        WriteTimeout: 15 * time.Second,<br/>        ReadTimeout:  15 * time.Second,<br/>    }<br/>    log.Fatal(srv.ListenAndServe())<br/>}</pre>
<ol start="12">
<li>This finishes the secured application. We can run the program from the  <kbd>simpleAuth</kbd> root directory by typing the following code:</li>
</ol>
<pre style="padding-left: 60px">go run main.go</pre>
<p>This starts the server on <kbd>http://localhost:8000</kbd>.</p>
<p class="mce-root">The error codes can mean different things. For example, <kbd>Forbidden (403)</kbd> is issued when the user tries to access a resource without authentication, whereas <kbd>Resource Not Found (404)</kbd> is issued when the given resource does not exist on the server.</p>
<p>In the next section, we'll introduce a new tool to query an API, called Postman. The Postman tool has a nice <strong>User Interface</strong> (<strong>UI</strong>) and runs on all platforms. We are going to test the <kbd>simpleAuth</kbd> example with this new tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Postman, a visual client for testing a REST API</h1>
                </header>
            
            <article>
                
<p><strong>Postman</strong> is a great UI client that allows Windows, Mac OS X, and Linux users to make HTTP API requests. You can download it from here: <a href="https://www.getpostman.com/product/api-client" target="_blank">https://www.getpostman.com/product/api-client</a><a href="https://www.getpostman.com/product/api-client">.</a> Instead of making an API request with <kbd>curl</kbd>, let us use the Postman tool. We will pick the <kbd>simpleAuth</kbd> example from the previous section. See the following steps:</p>
<ol>
<li>Post-installation, open the Postman tool, then try a <a href="http://www.example.org" target="_blank">www.example.org</a> URL in the <span class="packt_screen">Enter request URL</span> input text. You can select the type of request from the dropdown (<span class="packt_screen">GET</span>, <span class="packt_screen">POST</span>, and so on). For each request, you can configure many settings such as <span class="packt_screen">Headers</span>, <span class="packt_screen">POST</span> body, and other details as a menu under <span class="packt_screen">URL</span>. Play with the options and get comfortable with them.</li>
</ol>
<div class="packt_infobox" style="padding-left: 60px">Please go through the Postman documentation for more details. It comes with various options for replaying API queries. Take some time to explore the features at <a href="https://learning.postman.com/getting-started/">https://learning.postman.com/getting-started/</a><a href="https://docs.api.getpostman.com/?version=latest"/></div>
<p>Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2c388dc6-8bf9-47fb-ad5f-b937ce2150ea.png"/></div>
<p style="padding-left: 60px">The <span class="packt_screen">Builder</span> is the top-level menu item, where we can add/edit requests. The preceding screenshot shows the empty builder, where we try to make requests.</p>
<ol start="2">
<li>Next, run the <kbd>main.go</kbd> file in the preceding <kbd>simpleAuth</kbd> project and try to call the <kbd>/healthcheck</kbd> API. Click on the <span class="packt_screen">Send</span> button. You will see that the response is <span class="packt_screen">403 Forbidden</span>, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1cddf709-f83d-4317-96d9-f08741f7d390.png"/></p>
<p style="padding-left: 60px">This is because we are not logged in yet. Postman automatically saves the cookie once authentication is successful.</p>
<ol start="3">
<li>Now, call the login API by changing the method type from <span class="packt_screen">GET</span> to <span class="packt_screen">POST</span>, and the <span class="packt_screen">URL</span> to <span class="packt_screen">http://localhost:8000/login</span>. We should pass the credentials as <kbd>multipart/form-data</kbd>. We should see the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/96b735c6-b1b4-45de-8a9a-d1ffba88ff29.png" style="width:36.33em;height:20.25em;"/></p>
<ol start="4">
<li>Hit the blue<span class="packt_screen"> Send</span> button. This makes a login request to our previously run server. It returns a message, saying <span class="packt_screen">Logged In successfully</span>. We can inspect the cookies by clicking on the <span class="packt_screen">Cookies</span> link, just following the <span class="packt_screen">Save</span> button on the right-hand side.</li>
</ol>
<p style="padding-left: 60px">It shows the list of cookies saved, and you will find a cookie called <kbd>session.id</kbd> there for the localhost site. The content will look like this:</p>
<pre style="padding-left: 60px">session.id=MTU3NzI4NTk2NXxEdi1CQkFFQ180SUFBUkFCRUFBQUpmLUNBQUVHYzNSeWFXNW5EQThBRFdGMWRHaGxiblJwWTJGMFpXUUVZbTl2YkFJQ0FBRT18Be0S-fIy6T7U-hnASBnPxLU2gFJ0jnAdaKWI6X04GPo=; path=/; domain=localhost; Expires=Fri, 24 Jan 2020 14:59:25 GMT;</pre>
<ol start="5">
<li>Try to call the <kbd>/healthcheck</kbd> API again, which returns the system date and time as a response, like this:</li>
</ol>
<pre style="padding-left: 60px">2019-12-25 16:00:03.501678 +0100 CET m=+169.811215440</pre>
<p style="padding-left: 60px">Let's say a client makes another <kbd>GET</kbd> request to the <kbd>logout</kbd> API, like this:</p>
<pre style="padding-left: 60px">http://localhost:8000/logout</pre>
<p class="mce-root">If this happens, the session will be invalidated, and access to the resource will be forbidden until another login request is done.</p>
<p class="mce-root">The admin and password credentials used in our examples are only for illustration purposes and should never be used in a production environment.<br/>
<br/>
Always use randomly generated strong passwords!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Persisting client sessions with Redis</h1>
                </header>
            
            <article>
                
<p>The sessions we've created so far are stored in the program memory. This means if the program crashes or restarts, all the logged sessions will be lost. It needs the client to log in once again to get a new session cookie. This is not helpful for auditing cookies. In order to save sessions somewhere, we can use Redis.</p>
<p>We have discussed running Redis in a Docker container in <a href="4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml" target="_blank">Chapter 9</a>, <em>Asynchronous API Design</em>. To recap, the Redis server stores key-value pairs. It provides basic data types such as strings, lists, hashes, sets, and so on. For more details, visit <a href="https://redis.io/topics/data-types" target="_blank">https://redis.io/topics/data-types</a>.</p>
<p>Now, it is time to put our Redis knowledge into action. We are going to modify our project from <kbd>simpleAuth</kbd> to <kbd>simpleAuthWithRedis</kbd>. The new project should now use Redis as a session store. Copy the code from the previous example to the new one.</p>
<p>In <a href="4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml" target="_blank">Chapter 9</a>, <em>Asynchronous API Design</em>, we used the <kbd>go-redis</kbd> package to interact with the Redis server from a Go program. In this chapter, we'll introduce a new convenient package called <kbd>redistore.v1</kbd> so that we can store sessions in Redis.</p>
<p class="mce-root">Install the package with the following <kbd>dep</kbd> command:</p>
<pre>dep init<br/>dep ensure -add gopkg.in/boj/redistore.v1</pre>
<p>Create a new program, with a few modifications. Here, instead of using the <kbd>gorilla/sessions</kbd> package, we will use the <kbd>redistore</kbd> package. <kbd>redistore</kbd> has a function called <kbd>NewRediStore</kbd> that takes Redis configuration as its arguments, along with the secret key. It returns the same session object as <kbd>gorilla/sessions</kbd>.</p>
<p>The rest of the code remains the same. For brevity, these are the only changes we have to make:</p>
<div>
<pre>package main<br/>import (<br/>    ...<br/>    redistore "gopkg.in/boj/redistore.v1"<br/>)<br/><br/>var store, err = redistore.NewRediStore(10, "tcp", ":6379", "", []byte(os.Getenv("SESSION_SECRET")))</pre></div>
<p style="padding-left: 30px">In the logout handler, you will see this code:</p>
<div>
<pre>session.Values["authenticated"] = false</pre></div>
<p>Change the preceding code to this:</p>
<pre>  session.Options.MaxAge = -1</pre>
<p>This step removes the key from the Redis store, which is equivalent to revoking authentication from the client. This improved program works in a very similar way to the previous one, except the session is now saved in Redis.</p>
<p>Run the new program, repeating the API query from the Postman tool. Once login is successful, launch <kbd>redis-cli</kbd> in the Docker container, like this:</p>
<pre>docker exec -i -t some-redis redis-cli</pre>
<p><kbd>some-redis</kbd> is the Redis server running the container name. Now, type the <kbd>KEYS *</kbd> command in the shell to see the newly stored session, as follows:</p>
<pre>127.0.0.1:6379&gt; KEYS *<br/>1) "session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA"<br/>127.0.0.1:6379&gt;</pre>
<p>The lengthy <kbd>session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA</kbd> <br/>
key is the key stored by the <kbd>redistore</kbd> package. If we delete that key, the client will lose access to the <kbd>/healthcheck</kbd> API. Now, stop the running program and restart it. You will see that the session is not lost. In this way, we can save the client session.</p>
<p class="mce-root">Redis can serve the purpose of caching for your web applications. It can store temporary data such as sessions, frequently requested user content, and so on. It is usually compared to memcached.</p>
<p>In the next section, we'll explore a new way of authentication, called JWT. It deviates from sessions, and stores no cookies on the client machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing JWT and OAuth2</h1>
                </header>
            
            <article>
                
<p>The modern REST API implements token-based authentication. Here, tokens can be any strings generated by the server, which allows the client to access resources by producing a token. The token is computed in such a way that only the client and the server know how to encode/decode the token.</p>
<p>The previous example relates to session-based authentication. This has a limitation of managing sessions by saving them in the program memory, or Redis/SQLite3. JWT takes a different approach and creates tokens that can be passed around for authentication.</p>
<p class="mce-root">Whenever a <strong>Client</strong> passes the authentication details to the <strong>Server</strong>, the server generates a token and passes it back to the <strong>Client</strong>. The client saves that in some kind of storage, such as AWS Secrets Manager, a database, or local storage (in the case of a browser). The <strong>Client</strong> uses that token to ask for resources from any API defined by the server. This process can be seen in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/288b80ee-76aa-424c-a781-dd4c8cc7af5a.png" style="width:37.83em;height:25.92em;"/></div>
<p>The steps shown in the preceding diagram can be summarized more briefly, as follows:</p>
<ol>
<li>The <strong>Client</strong> passes the <strong>username/password</strong> in a <kbd>POST</kbd> request to the login API.</li>
<li>The <strong>Server</strong> authenticates the details and, if successful, it generates a <strong>JWT</strong> and returns it instead of creating a cookie. It is the client's responsibility to store this token.</li>
<li>Now, the <strong>Client</strong> has the JWT. It needs to add this in the headers section to make subsequent REST API calls.</li>
<li>The <strong>Server</strong> checks the JWT from the header and if it is successfully decoded, the server authenticates the client.</li>
</ol>
<p class="mce-root">JWT ensures that the data is sent from the correct client. The technique for creating a token takes care of that logic. JWT leverages secret key-based encryption.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JWT format</h1>
                </header>
            
            <article>
                
<p>Everything we discussed in the preceding section was about passing a JWT token. In this section, we will see what a JWT looks like, and how it is generated. These are the high-level steps for generating a JWT:</p>
<ol>
<li>Create a <kbd>JWT</kbd> header by doing <kbd>Base64Url</kbd> encoding on the JSON header.</li>
<li>Create a <kbd>JWT</kbd> payload by doing <kbd>Base64Url</kbd> encoding on the JSON payload.</li>
<li>Create a signature by encrypting the appended header and payload using a secret key.</li>
<li>A JWT string can be obtained by appending the <kbd>JWT</kbd> header, <kbd>JWT</kbd> payload, and signature.</li>
</ol>
<p>A header is a simple JSON object. It looks like the following code snippet in Go:</p>
<pre>{<br/>  "alg": "HS256",<br/>  "typ": "JWT"<br/>}</pre>
<p><kbd>HS256</kbd> is a short form for the algorithm (HMAC with SHA-256) that's used for creating a signature. The message type is <kbd>JWT</kbd>. This will be common for all the headers. The algorithm may change, depending on the system.</p>
<p class="mce-root"/>
<p>A payload looks like this:</p>
<pre>{<br/>  "sub": "1234567890",<br/>  "username": "Indiana Jones",<br/>  "admin": true<br/>}</pre>
<p>Keys in a payload object are called <strong>claims</strong>. A claim is a key that specifies some special meaning to the server. There are three types of claims:</p>
<ul>
<li>Reserved claims</li>
<li>Private claims (more important)</li>
<li>Public claims</li>
</ul>
<p>We'll discuss each of these claims in detail in the upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reserved claims</h1>
                </header>
            
            <article>
                
<p><strong>Reserved claims</strong> are the ones defined by the JWT standard. They are as follows:</p>
<ul>
<li><strong>iat</strong>: Issued at the time</li>
<li><strong>iss</strong>: Issuer name</li>
<li><strong>sub</strong>: Subject text</li>
<li><strong>aud</strong>: Audience name</li>
<li><strong>exp</strong>: Expiration time</li>
</ul>
<p>For example, the server, while generating a token, can set an exp claim in the payload. The client then uses that token to access API resources. The server validates the token each time. When the expiration time is passed, the server will no longer validate the token. The client needs to generate a new token by logging in again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Private claims</h1>
                </header>
            
            <article>
                
<p><strong>Private claims</strong> are used to identify one token from another. They can be used for authorization. <strong>Authorization</strong> is a process of identifying which client made the request. <strong>Multi-tenancy</strong> refers to the situation of multiple clients accessing an API on a system. The server can set a private claim called <strong>username</strong> on the payload of the token. Next time, the server can read this payload back and get the username, and then use that username to authorize and customize the API response. It is similar to a cookie but in a different way.</p>
<p>For example, <kbd>username</kbd>: <kbd>Indiana Jones</kbd> is a private claim in the following payload:</p>
<pre>{<br/>  "sub": "1234567890",<br/>  "username": "Indiana Jones",<br/>  "admin": true<br/>}</pre>
<p><strong>Public claims</strong> are similar to private claims, but they should be registered with the IANA JWT Registry to make them as a standard. We limit the use of these.</p>
<p>A signature can be created by performing this operation (this is not code, just an illustration):</p>
<pre>signature = HMACSHA256(<br/>  base64UrlEncode(header) + "." +<br/>  base64UrlEncode(payload),<br/>  secret)</pre>
<p>This is simply performing an encryption algorithm on the Base64Url-encoded header and payload with a secret. This secret can be any string. It is exactly the same as the secret we used in the previous cookie session. This secret is usually saved in the environment variable and loaded into the program.</p>
<p>Now, we append the encoded header, encoded payload, and signature to get our token string, as follows:</p>
<pre>tokenString = base64UrlEncode(header) + "." + base64UrlEncode(payload) + "." + signature</pre>
<p class="mce-root">This is how a JWT token is generated. There are a few Go packages that can generate and verify a JWT. One such popular package is <kbd>jwt-go</kbd>. We are going to create a project in the next section that uses <kbd>jwt-go</kbd> to sign a JWT and also verify it. We can install this package using the following <kbd>dep</kbd> command:</p>
<pre class="mce-root">dep ensure -add github.com/dgrijalva/jwt-go </pre>
<p>This is the official GitHub page for the project: <a href="https://github.com/dgrijalva/jwt-go" target="_blank">https://github.com/dgrijalva/jwt-go</a>. </p>
<p>The package provides a few functions that allow us to create tokens. There are many other packages with different additional features. You can see all the available packages and features that are supported at <a href="https://jwt.io/#libraries-io" target="_blank">https://jwt.io/#libraries-io</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a JWT in Go</h1>
                </header>
            
            <article>
                
<p>The <kbd>jwt-go</kbd> package has a function called <kbd>NewWithClaims</kbd> that takes two arguments:</p>
<ul>
<li>A signing method such as <kbd>HMAC256</kbd>, <kbd>RSA</kbd>, and so on</li>
<li>A claims map</li>
</ul>
<p>For example, it looks like the following code snippet:</p>
<pre>token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
    "username": "admin",
    "iat":time.Now().Unix(),
})</pre>
<p><kbd>jwt.SigningMethodHS256</kbd> is an encryption algorithm that is available within the package. The second argument is a map with claims such as private (here, username) and reserved (issued iat). Now, we can generate a <kbd>tokenString</kbd> using the <kbd>SignedString</kbd> function on a token, as follows:</p>
<pre>tokenString, err := token.SignedString("my_secret_key")</pre>
<p>This <kbd>tokenString</kbd> should then be sent back to the client as part of a successful login response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading a JWT in Go</h1>
                </header>
            
            <article>
                
<p><kbd>jwt-go</kbd> also gives us the API to parse a given JWT string. The Parse function takes a string and key function as arguments. The key function is a custom function that validates whether the algorithm is real or not. Let us say this is a sample token string generated by the preceding encoding:</p>
<pre>tokenString = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoiMTUwODc0MTU5MTQ2NiJ9.5m6KkuQFCgyaGS_xcVy4xWakwDgtAG3ILGGTBgYVBmE"<br/><br/></pre>
<p>We can parse and get back the original JSON using the following code:</p>
<pre>token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
    // key function
    if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
        return nil, fmt.Errorf("Unexpected signing method: %v",<br/>         token.Header["alg"])
    }
    return "my_secret_key", nil
})

if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid {<br/>    // Use claims for authorization if token is valid
    fmt.Println(claims["username"], claims["iat"])
} else {
    fmt.Println(err)
}</pre>
<p><kbd>token.Claims</kbd> is implemented by a map called <strong>MapClaims</strong>. We can get the original JSON key-value pairs from that map.</p>
<p>In the next section, we'll discuss the OAuth 2.0 workflow and the difference between authentication and authorization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JWT in an OAuth2.0 workflow</h1>
                </header>
            
            <article>
                
<p><strong>OAuth 2.0</strong> is an authentication framework that is used to create an authentication pattern between different systems. here, the client, instead of making a request to the resource server, makes an initial request to an entity called <strong>resource owner</strong>. This resource owner sends back the authentication grant for the client (if the credentials are authenticated). The client now sends this authentication grant to another entity called an <strong>authentication server</strong>. The authentication server takes the grant and returns an access token. The access token is a</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication versus authorization</h1>
                </header>
            
            <article>
                
<p><strong>Authentication</strong> is the process of identifying whether a client is genuine or not. When a server authenticates a client, it checks the username/password pair and creates a session <kbd>cookie/JWT</kbd>.</p>
<p><strong>Authorization</strong> is the process of evaluating whether a user has access to a given resource. In cloud services, there should be a mechanism to limit the scope of resource access for certain users/roles, and authorization enables it.</p>
<p>In simple words, authentication decides who is the customer of a service, and authorization determines what are the customer's boundaries for resource access.</p>
<p>OAuth 2.0 is a protocol for authenticating multiple clients to a service, whereas JWT is a token format. We need to encode/decode JWT tokens to implement the second stage (dashed lines in the following diagram) of OAuth 2.0:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="assets/af069940-c17a-4f2e-81b5-ae551da3746b.png" style="width:43.33em;height:27.17em;"/></div>
<p>In the preceding diagram, the dotted section is where a <strong>Client</strong> requests an access token from the <strong>Authentication Server</strong>. This is where a JWT life cycle begins.</p>
<p>In the next section, we'll present a development exercise for you to complete. This exercise can be completed by combining all the concepts we have learned about so far.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercise</h1>
                </header>
            
            <article>
                
<p>Can you design the following requirements?</p>
<p>Develop a <kbd>/healthcheck</kbd> API with token authentication. Its main responsibilities should be as follows:</p>
<ul>
<li>Authenticate the client and return a JWT string</li>
<li>Authorize client API requests by validating the JWT</li>
</ul>
<p>You should use the knowledge you gained about the <kbd>jwt-go</kbd> package from the previous section. You have to build two endpoints, as follows:</p>
<ul>
<li><kbd>/getToken</kbd></li>
<li><kbd>/healthcheck</kbd></li>
</ul>
<p>The first endpoint should successfully log in a client and return a JWT token. The client should then use the second endpoint with the token to receive a successful response.</p>
<p>Post-development, the final API testing scenario should look something similar to this:</p>
<ol>
<li class="mce-root">If you make a <kbd>GET</kbd> request to the <kbd>/healthcheck</kbd> API without any token, you should receive an <kbd>Access Denied</kbd> message, as shown here:</li>
</ol>
<pre style="padding-left: 60px">Access Denied; Please check the access token</pre>
<ol start="2">
<li>You should be able to authenticate and get a JWT token from the API server with a <kbd>POST</kbd> request, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7b838296-b9e0-42b7-96c3-a7de42d20fb1.png"/></p>
<ol start="3">
<li>With the returned JWT, you can now make a successful <kbd>GET</kbd> request to <kbd>/healthcheck</kbd> with an <span class="packt_screen">access_token</span> header, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b7d4a20e-60cf-4197-a395-45466f0e5769.png"/></p>
<p>If you can implement the preceding requirements, you have already got a nice understanding of JWT. If not, do not worry. The solution for the challenge is available in the <kbd>chapter14/jwtauth</kbd> project directory.</p>
<p class="mce-root">Token-based authentication doesn't usually provide a logout API or an API for deleting the tokens that are provided in session-based authentication. The server gives the authorized resources to the client as long as the JWT hasn't expired. Once it expires, the client needs to refresh the token—that is to say, ask the server for a new token.</p>
<p>In the next section, we'll discuss a few tips for securing an API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security aspects of an API</h1>
                </header>
            
            <article>
                
<p>Every REST API that is developed can be either open or protected. An open API has no limit regarding the number of clients requesting the resources. But most business APIs are protected. So, what are the important things to keep in mind about security? In the following list, we'll point out all the factors that should be taken care of to secure a REST API:</p>
<ul>
<li>Always use HTTPS to deliver the API <strong>Transport Layer Security</strong> (<strong>TLS</strong>).</li>
<li>Rate limit the API by using user access tokens.</li>
<li>Design various authentication and authorization roles on the API.</li>
<li>Use public key/private key encryption to sign a JWT when the client and server are internal.</li>
<li>Never store user credentials in plain files.</li>
<li>Sanitize the URL query parameters; use a <span class="packt_screen">POST</span> body for incoming requests.</li>
<li>As we mentioned in the previous chapter, use an API Gateway for better performance and protection.</li>
<li>Use cloud services such as AWS Secrets Manager to store keys/passwords.</li>
</ul>
<p>Most modern APIs are run as containers/<strong>Virtual Private Servers</strong> (<strong>VPS</strong>) on cloud providers. The security there can be applied at two levels:</p>
<ul>
<li>Network level</li>
<li>Application level</li>
</ul>
<p>An API developer who develops and deploys their application on the cloud should be aware of the preceding levels. Knowledge of security breach-counteracting measures and patching up the API is a key security skill you will need.</p>
<p>Also, an exposed REST API is the easiest victim for attacks such as <strong>Denial of Service</strong> (<strong>DoS</strong>) attacks. Deploying an API behind a firewall service can increase security from those attacks. In the case of an internal API, where a company's service communicates only with other internal services but from different geographical regions, a  VPN is desirable.</p>
<p>Security is a beast of its own domain and needs to be carefully monitored in every aspect of API development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we introduced the process of authentication. We saw how authentication usually works. Authentication can be of three types: basic authentication, session-based, or token-based. With basic authentication, every HTTP request supplies a <kbd>username</kbd> and <kbd>password</kbd>. Session-based authentication uses a saved session to authenticate a client.</p>
<p>Sessions stored in program memory are lost once a web server crashes/restarts. Redis can be used with a package called <kbd>redistore</kbd> to help store session cookies. </p>
<p>Next, we learned about JWT, a token-based authentication whereby a client requests a JWT token from the server. Once the client has the JWT token, it can pass that token in the HTTP header while requesting API resources.</p>
<p>We then introduced OAuth 2.0, an authentication framework. There, we saw how the client requests a grant from the resource owner. Once it gets the grant, it requests an access token from the authentication server. After getting the access token from the authentication server, the client can use the token to request an API.</p>
<p>We tested all our APIs with curl and Postman. Postman is a great tool that helps us test our APIs quickly on any machine, whereas curl is limited to Linux and <span>Mac OS X</span> .</p>
<p>We came a long way from the first chapter by learning how to create HTTP routes, middleware, and handlers. We then explored various SQL and NoSQL storage backends for an API. After the basics, we explored performance-tuning aspects such as asynchronous design, the GraphQL API, and microservices. Finally, we learned how to deploy our web services to the cloud and also secure them by enabling authentication.</p>


            </article>

            
        </section>
    </body></html>