["```go\ngo get github.com/gorilla/mux\ngo get github.com/gorilla/sessions\n```", "```go\ndep init\ndep ensure -add github.com/gorilla/mux\ndep ensure -add github.com/gorilla/sessions\n```", "```go\nvar store = sessions.NewCookieStore([]byte(\"secret_key\"))\n```", "```go\nmkdir -p $GOPATH/src/github.com/git-user/chapter14/simpleAuth\ntouch $GOPATH/src/github.com/git-user/chapter14/simpleAuth/main.go\n```", "```go\npackage main\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n    \"github.com/gorilla/mux\"\n    \"github.com/gorilla/sessions\"\n)\n```", "```go\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_SECRET\")))\n```", "```go\nvar users = map[string]string{\"naren\": \"passme\", \"admin\": \"password\"}\n```", "```go\nfunc LoginHandler(w http.ResponseWriter, r *http.Request) {\n   ...\n}\n```", "```go\nerr := r.ParseForm()\n\nif err != nil {\nhttp.Error(w, \"Please pass the data as URL form encoded\",\n http.StatusBadRequest)\n    return\n}\nusername := r.PostForm.Get(\"username\")\npassword := r.PostForm.Get(\"password\")\n```", "```go\nif originalPassword, ok := users[username]; ok {\n    session, _ := store.Get(r, \"session.id\")\n    if password == originalPassword {\n        session.Values[\"authenticated\"] = true\n        session.Save(r, w)\n    } else {\n        http.Error(w, \"Invalid Credentials\", http.StatusUnauthorized)\n        return\n    }\n} else {\n    http.Error(w, \"User is not found\", http.StatusNotFound)\n    return\n}\nw.Write([]byte(\"Logged In successfully\"))\n```", "```go\n// LogoutHandler removes the session\nfunc LogoutHandler(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session.id\")\n    session.Values[\"authenticated\"] = false\n    session.Save(r, w)\n    w.Write([]byte(\"\"))\n}\n```", "```go\nsession, _ := store.Get(r, \"session.id\")\nsession.Values[\"authenticated\"] = false\nsession.Save(r, w)\n```", "```go\n// HealthcheckHandler returns the date and time\nfunc HealthcheckHandler(w http.ResponseWriter, r *http.Request) {\n    session, _ := store.Get(r, \"session.id\")\n    if (session.Values[\"authenticated\"] != nil) && session.Values\n    [\"authenticated\"] != false {\n        w.Write([]byte(time.Now().String()))\n    } else {\n        http.Error(w, \"Forbidden\", http.StatusForbidden)\n    }\n}\n```", "```go\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/login\", LoginHandler)\n    r.HandleFunc(\"/healthcheck\", HealthcheckHandler)\n    r.HandleFunc(\"/logout\", LogoutHandler)\n    http.Handle(\"/\", r)\n\n    srv := &http.Server{\n        Handler: r,\n        Addr:    \"127.0.0.1:8000\",\n        // Good practice: enforce timeouts for servers you create!\n        WriteTimeout: 15 * time.Second,\n        ReadTimeout:  15 * time.Second,\n    }\n    log.Fatal(srv.ListenAndServe())\n}\n```", "```go\ngo run main.go\n```", "```go\nsession.id=MTU3NzI4NTk2NXxEdi1CQkFFQ180SUFBUkFCRUFBQUpmLUNBQUVHYzNSeWFXNW5EQThBRFdGMWRHaGxiblJwWTJGMFpXUUVZbTl2YkFJQ0FBRT18Be0S-fIy6T7U-hnASBnPxLU2gFJ0jnAdaKWI6X04GPo=; path=/; domain=localhost; Expires=Fri, 24 Jan 2020 14:59:25 GMT;\n```", "```go\n2019-12-25 16:00:03.501678 +0100 CET m=+169.811215440\n```", "```go\nhttp://localhost:8000/logout\n```", "```go\ndep init\ndep ensure -add gopkg.in/boj/redistore.v1\n```", "```go\npackage main\nimport (\n    ...\n    redistore \"gopkg.in/boj/redistore.v1\"\n)\n\nvar store, err = redistore.NewRediStore(10, \"tcp\", \":6379\", \"\", []byte(os.Getenv(\"SESSION_SECRET\")))\n```", "```go\nsession.Values[\"authenticated\"] = false\n```", "```go\n  session.Options.MaxAge = -1\n```", "```go\ndocker exec -i -t some-redis redis-cli\n```", "```go\n127.0.0.1:6379> KEYS *\n1) \"session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA\"\n127.0.0.1:6379>\n```", "```go\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```", "```go\n{\n  \"sub\": \"1234567890\",\n  \"username\": \"Indiana Jones\",\n  \"admin\": true\n}\n```", "```go\n{\n  \"sub\": \"1234567890\",\n  \"username\": \"Indiana Jones\",\n  \"admin\": true\n}\n```", "```go\nsignature = HMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n```", "```go\ntokenString = base64UrlEncode(header) + \".\" + base64UrlEncode(payload) + \".\" + signature\n```", "```go\ndep ensure -add github.com/dgrijalva/jwt-go \n```", "```go\ntoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n    \"username\": \"admin\",\n    \"iat\":time.Now().Unix(),\n})\n```", "```go\ntokenString, err := token.SignedString(\"my_secret_key\")\n```", "```go\ntokenString = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoiMTUwODc0MTU5MTQ2NiJ9.5m6KkuQFCgyaGS_xcVy4xWakwDgtAG3ILGGTBgYVBmE\"\n\n```", "```go\ntoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n    // key function\n    if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n        return nil, fmt.Errorf(\"Unexpected signing method: %v\",\n         token.Header[\"alg\"])\n    }\n    return \"my_secret_key\", nil\n})\n\nif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n    // Use claims for authorization if token is valid\n    fmt.Println(claims[\"username\"], claims[\"iat\"])\n} else {\n    fmt.Println(err)\n}\n```", "```go\nAccess Denied; Please check the access token\n```"]