- en: Handling Authentication for our REST Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理我们的REST服务的认证
- en: In this chapter, we are going to explore **Representational State Transfer**
    (**REST**) API authentication patterns. These patterns are session-based authentication, **JSON
    Web Tokens** (**JWT**), and **Open Authentication 2** (**OAuth 2.0**). We will
    try to leverage the Gorilla package's `sessions` library to create basic sessions.
    Then, we will move on to advanced REST API authentication strategies, such as
    stateless JWT. Finally, we will discuss the OAuth 2.0 authentication pattern and
    the security aspects of an API. In the previous chapter, the **Amazon Web Services**
    (**AWS**) API Gateway took care of authentication (using **Identity and Access
    Management** (**IAM**) roles) for us. If an API Gateway is not present, how do
    we secure our API? You will find the answer in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**表示状态转移**（**REST**）API认证模式。这些模式是基于会话的认证、**JSON Web Tokens**（**JWT**）和**开放认证2**（**OAuth
    2.0**）。我们将尝试利用Gorilla包的`sessions`库来创建基本会话。然后，我们将继续探讨高级REST API认证策略，如无状态JWT。最后，我们将讨论OAuth
    2.0认证模式以及API的安全方面。在前一章中，**亚马逊网络服务**（**AWS**）API网关为我们处理了认证（使用**身份和访问管理**（**IAM**）角色）。如果没有API网关，我们如何保护我们的API？您将在本章中找到答案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How simple authentication works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单认证是如何工作的
- en: Introducing Postman, a visual client for testing a REST API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Postman，一个用于测试REST API的视觉客户端
- en: Persisting client sessions with Redis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis持久化客户端会话
- en: Introducing JWT and OAuth 2.0
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍JWT和OAuth 2.0
- en: JWT in an OAuth 2.0 workflow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0工作流程中的JWT
- en: Exercise for the reader
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者练习
- en: Security aspects of an API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的安全方面
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software should be pre-installed for running the code samples:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行代码示例，以下软件应预先安装：
- en: 'Operating system: Linux (Ubuntu 18.04)/Windows 10/Mac OS X  >= 10.13'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux (Ubuntu 18.04)/Windows 10/Mac OS X >= 10.13
- en: Go stable version compiler >= 1.13.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go稳定版本编译器 >= 1.13.5
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dep：Go >= 0.5.3的依赖管理工具
- en: Docker version >= 18.09.2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker版本 >= 18.09.2
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter14](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter14).
    Clone the code, and use the code samples in the `chapter14` directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter14](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter14)下载本章的代码。克隆代码，并使用`chapter14`目录中的代码示例。
- en: How simple authentication works
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单认证是如何工作的
- en: Traditionally, authentication—or simple authentication—works with sessions.
    The flow starts like this. A client sends an authentication request to the server
    using user credentials. The server takes those credentials and matches them with
    the credentials stored on the server. If a match is successful, it writes something
    called a **cookie** in the response. This cookie is a small piece of information
    that is transferred by the client for all subsequent requests. Modern websites
    are being designed to be **single-page applications** (**SPAs**). In those websites, static
    assets such as HTML and JavaScript files are served from a **Content Delivery
    Network** (**CDN**) to render the web page initially. After that, the communication
    between the web page and application server happens only through the REST API/web
    services.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，认证或简单认证与会话一起工作。流程开始如下。客户端使用用户凭据向服务器发送认证请求。服务器获取这些凭据并将它们与服务器上存储的凭据进行匹配。如果匹配成功，它将在响应中写入一个称为**cookie**的东西。这个cookie是一小段信息，客户端会将其传输给所有后续请求。现代网站正在被设计成**单页应用程序**（**SPAs**）。在这些网站上，静态资源如HTML和JavaScript文件最初是从**内容分发网络**（**CDN**）提供的，以渲染网页。之后，网页与应用服务器之间的通信仅通过REST
    API/网络服务进行。
- en: 'A **session** is a nice way to record user communication in a given period
    of time. A session is a concept whereby authentication information is stored in
    a cookie. The following diagram explains what happens in a basic session-based
    authentication:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话**是一种记录特定时间段内用户通信的好方法。会话是一个概念，其中认证信息存储在cookie中。以下图表解释了基于会话的基本认证过程中发生了什么：'
- en: '![](img/474314d9-b218-4c16-ae15-8c72dcd32b49.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/474314d9-b218-4c16-ae15-8c72dcd32b49.png)'
- en: Now, let's look at a practical approach. A **Client** (for example, a browser)
    sends a request to the **Login API** of the **Server**. The server tries to check
    those credentials with the database and, if the credentials exist, writes a **cookie**
    back onto the response saying that this user is authenticated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个实际的方法。一个**客户端**（例如，浏览器）向**服务器**的**登录API**发送请求。服务器会尝试与数据库核对那些凭证，如果凭证存在，就会在响应中写回一个**cookie**，表示该用户已认证。
- en: A **cookie** is a message consumed by the server at a later point in time. When
    the client receives the response, it stores that cookie locally. After that, the
    client can ask for resources from the server by showing the cookie as the key
    for passage.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**cookie**是一个在稍后时间由服务器消费的消息。当客户端收到响应时，它会将cookie本地存储。之后，客户端可以通过显示cookie作为通行证的关键来从服务器请求资源。'
- en: When a client decides to terminate the session, it calls the logout API on the
    server. The server destroys the session in the response. This process is repeated
    for every login/logout. The server can also place an expiration on cookies so
    that the authentication window is valid for a certain time if there is no activity.
    This is how many websites work.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端决定终止会话时，它会在服务器上调用注销API。服务器在响应中销毁会话。对于每个登录/注销，这个过程都会重复。服务器还可以对cookies设置过期时间，这样在没有活动的情况下，认证窗口在一定时间内有效。这就是许多网站的工作方式。
- en: 'Now, we''ll try to implement one such system using the `gorilla/sessions` package.
    We already learned about gorilla/mux in the initial chapters. We need to install
    the package first by using the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试使用`gorilla/sessions`包实现这样一个系统。我们在第一章中已经学习了gorilla/mux。首先，我们需要使用以下命令安装该包：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, we could do this by using the Dep tool, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过使用Dep工具来完成这项工作，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can create a new session using the `NewCookieStore` method from the `sessions`
    package, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`sessions.NewCookieStore`方法从`sessions`包中创建一个新的会话，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That `secret_key` should be the key that `gorilla/sessions` uses to encrypt
    the session cookies. If we add a session as a normal text, anyone can read it.
    So, the server needs to encrypt a message to a random string. For that, it asks
    to provide a secret key. This secret key can be any randomly generated string.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`secret_key`应该是`gorilla/sessions`用来加密会话cookie的密钥。如果我们以普通文本添加会话，任何人都可以读取它。因此，服务器需要将消息加密为随机字符串。为此，它要求提供秘密密钥。这个秘密密钥可以是任何随机生成的字符串。
- en: Keeping secret keys in code is not a good idea, so we try to store it as an
    environment variable and read it in code on the fly. In the next section, we'll
    look at an example of session authentication.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将秘密密钥保存在代码中不是一个好主意，所以我们尝试将其存储为环境变量，并在代码中即时读取。在下一节中，我们将查看一个会话认证的示例。
- en: A simple authentication example
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的认证示例
- en: 'Let''s build a secure API that gives access to clients only after logging in.
    In the process, we will define three endpoints:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个安全的API，只有登录后才能让客户端访问。在这个过程中，我们将定义三个端点：
- en: '`/login`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/login`'
- en: '`/logout`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/logout`'
- en: '`/healthcheck`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/healthcheck`'
- en: '`/healthcheck` is the data API, but it first has to log in using the /login
    endpoint. Our API should reject all unauthenticated requests. Create a project
    directory called `simpleAuth`, like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`/healthcheck`是数据API，但首先必须使用`/login`端点进行登录。我们的API应该拒绝所有未经认证的请求。创建一个名为`simpleAuth`的项目目录，如下所示：'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the program, we can see how to enable session-based authentication to API
    endpoints using the gorilla/ sessions package. Follow these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，我们可以看到如何使用gorilla/sessions包来启用基于会话的API端点认证。按照以下步骤操作：
- en: 'We need imports for our program. The main ones are `mux` and `sessions`, as
    seen in the following code block:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的程序导入一些内容。主要的是`mux`和`sessions`，如下面的代码块所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, create a cookie store to store the written cookie information. We can
    do that using the `sessions.NewCookieStore` method. It takes a byte array of the
    secret key. The secret key is fetched from the `SESSION_SECRET` environment variable,
    like this:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个cookie存储来存储写入的cookie信息。我们可以使用`sessions.NewCookieStore`方法来完成。它需要一个包含秘密密钥的字节序列。秘密密钥从`SESSION_SECRET`环境变量中获取，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can set any key you wish to that environment variable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置任何您想要的键到那个环境变量中。
- en: 'Let us create mock `usernames` and a `password` as we don''t have a signup
    mechanism, as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有注册机制，让我们创建一些模拟的`用户名`和`密码`，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These mock username/password combinations are checked against a client request.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模拟的用户名/密码组合将与客户端请求进行核对。
- en: 'Now, add a login handler that sets the cookie. The API is a `POST` request
    with credentials supplied in the POST body, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个设置 cookie 的登录处理程序。API 是一个带有在 POST 主体中提供的凭据的 `POST` 请求，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this function, we should first parse the POST body, and get the `username`
    and `password`, like this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先应该解析 POST 主体，并获取 `username` 和 `password`，如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once we have collected the `username` and `password`, our plan is to validate
    them with the mock data. If the credentials are matching, then set the request
    session to authenticated. Otherwise, show the error message accordingly, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们收集了 `username` 和 `password`，我们的计划是使用模拟数据验证它们。如果凭据匹配，则将请求会话设置为已认证。否则，相应地显示错误消息，如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This completes the login handler.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了登录处理程序。
- en: 'In a similar way, let us define the logout handler. The logout handler takes
    an incoming `GET` request and sets the session variable authenticated to `false`,
    like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式，让我们定义注销处理程序。注销处理程序接收一个进入的 `GET` 请求并将会话变量 authenticated 设置为 `false`，如下所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you see the logout handler implementation, then we have modified the `session`
    object to invalidate the client session, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您看到了注销处理程序的实现，那么我们已经修改了 `session` 对象以使客户端会话无效，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this way, simple authentication can be implemented using client sessions
    in any programming language, including Go.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式，可以使用任何编程语言中的客户端会话来实现简单的身份验证，包括 Go。
- en: Don't forget to save the cookie after modifying it. The code for this is `session.Save(r,
    w)`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在修改后保存 cookie。这个操作的代码是 `session.Save(r, w)`。
- en: 'Now, let us define our `/healthcheck`. data API. It is an API that sends the
    system time back. It returns a response if the client session is authenticated.
    Otherwise, it returns a `403 Forbidden response`. The `session` object from the
    request can be used for the validity check, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的 `/healthcheck` 数据 API。这是一个发送系统时间的 API。如果客户端会话已认证，则返回响应。否则，返回 `403
    Forbidden` 响应。请求中的 `session` 对象可用于有效性检查，如下所示：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'All the API handlers are ready. We have to write the `main` function, where
    we map API endpoints (routes) to the preceding handlers. We use the `mux` router
    for that purpose. Then, we pass this router to an HTTP server that runs on `http://localhost:8000`,
    as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 API 处理程序都已就绪。我们必须编写 `main` 函数，在该函数中将 API 端点（路由）映射到前面的处理程序。我们为此使用 `mux` 路由器。然后，我们将此路由器传递到在
    `http://localhost:8000` 上运行的 HTTP 服务器，如下所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This finishes the secured application. We can run the program from the  `simpleAuth` root
    directory by typing the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样就完成了受保护的应用程序。我们可以通过在 `simpleAuth` 根目录下输入以下代码来运行程序：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This starts the server on `http://localhost:8000`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `http://localhost:8000` 上启动服务器。
- en: The error codes can mean different things. For example, `Forbidden (403)` is
    issued when the user tries to access a resource without authentication, whereas
    `Resource Not Found (404)` is issued when the given resource does not exist on
    the server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码可以表示不同的含义。例如，当用户尝试未经认证访问资源时，会发出 `Forbidden (403)`，而当给定的资源在服务器上不存在时，会发出 `Resource
    Not Found (404)`。
- en: In the next section, we'll introduce a new tool to query an API, called Postman.
    The Postman tool has a nice **User Interface** (**UI**) and runs on all platforms.
    We are going to test the `simpleAuth` example with this new tool.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一个新的查询 API 的工具，称为 Postman。Postman 工具有一个很好的 **用户界面**（**UI**），并且运行在所有平台上。我们将使用这个新工具测试
    `simpleAuth` 示例。
- en: Introducing Postman, a visual client for testing a REST API
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Postman，一个用于测试 REST API 的可视化客户端
- en: '**Postman** is a great UI client that allows Windows, Mac OS X, and Linux users
    to make HTTP API requests. You can download it from here: [https://www.getpostman.com/product/api-client](https://www.getpostman.com/product/api-client)[.](https://www.getpostman.com/product/api-client)
    Instead of making an API request with `curl`, let us use the Postman tool. We
    will pick the `simpleAuth` example from the previous section. See the following
    steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Postman** 是一个优秀的 UI 客户端，允许 Windows、Mac OS X 和 Linux 用户进行 HTTP API 请求。您可以从这里下载它：[https://www.getpostman.com/product/api-client](https://www.getpostman.com/product/api-client)[.](https://www.getpostman.com/product/api-client)
    我们将使用 Postman 工具而不是使用 `curl` 来发送 API 请求。我们将从上一节中的 `simpleAuth` 示例中选择。请看以下步骤：'
- en: Post-installation, open the Postman tool, then try a [www.example.org](http://www.example.org) URL
    in the Enter request URL input text. You can select the type of request from the
    dropdown (GET, POST, and so on). For each request, you can configure many settings
    such as Headers, POST body, and other details as a menu under URL. Play with the
    options and get comfortable with them.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，打开 Postman 工具，然后在“输入请求 URL”输入框中尝试一个 [www.example.org](http://www.example.org)
    URL。您可以从下拉菜单中选择请求类型（GET、POST 等）。对于每个请求，您都可以配置许多设置，如 Headers、POST 主体和其他细节，这些都可以在
    URL 下作为菜单进行配置。玩转这些选项，并熟悉它们。
- en: Please go through the Postman documentation for more details. It comes with
    various options for replaying API queries. Take some time to explore the features
    at [https://learning.postman.com/getting-started/](https://learning.postman.com/getting-started/)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请查阅 Postman 文档以获取更多详细信息。它提供了多种重放 API 查询的选项。花些时间探索 [https://learning.postman.com/getting-started/](https://learning.postman.com/getting-started/)
    中的功能。
- en: 'Take a look at the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/2c388dc6-8bf9-47fb-ad5f-b937ce2150ea.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c388dc6-8bf9-47fb-ad5f-b937ce2150ea.png)'
- en: The Builder is the top-level menu item, where we can add/edit requests. The
    preceding screenshot shows the empty builder, where we try to make requests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器是顶级菜单项，我们可以在这里添加/编辑请求。前面的截图显示了空白的构建器，我们在这里尝试发送请求。
- en: 'Next, run the `main.go` file in the preceding `simpleAuth` project and try
    to call the `/healthcheck` API. Click on the Send button. You will see that the
    response is 403 Forbidden, as shown in the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行前面 `simpleAuth` 项目中的 `main.go` 文件，并尝试调用 `/healthcheck` API。点击“发送”按钮。您将看到响应是
    403 禁止，如下面的截图所示：
- en: '![](img/1cddf709-f83d-4317-96d9-f08741f7d390.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1cddf709-f83d-4317-96d9-f08741f7d390.png)'
- en: This is because we are not logged in yet. Postman automatically saves the cookie
    once authentication is successful.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们还没有登录。Postman 在身份验证成功后自动保存 cookie。
- en: 'Now, call the login API by changing the method type from GET to POST, and the
    URL to http://localhost:8000/login. We should pass the credentials as `multipart/form-data`. We
    should see the following:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将方法类型从 GET 改为 POST，并将 URL 改为 http://localhost:8000/login，调用登录 API。我们应该以
    `multipart/form-data` 的形式传递凭证。我们应该看到以下内容：
- en: '![](img/96b735c6-b1b4-45de-8a9a-d1ffba88ff29.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96b735c6-b1b4-45de-8a9a-d1ffba88ff29.png)'
- en: Hit the blue Send button. This makes a login request to our previously run server.
    It returns a message, saying Logged In successfully. We can inspect the cookies
    by clicking on the Cookies link, just following the Save button on the right-hand
    side.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色“发送”按钮。这会向之前运行的服务器发送登录请求。它返回一条消息，表示登录成功。我们可以通过点击“Cookies”链接来检查 cookies，就在右侧的“保存”按钮旁边。
- en: 'It shows the list of cookies saved, and you will find a cookie called `session.id`
    there for the localhost site. The content will look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了保存的 cookies 列表，您将在 localhost 网站找到一个名为 `session.id` 的 cookie。内容看起来像这样：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Try to call the `/healthcheck` API again, which returns the system date and
    time as a response, like this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试调用 `/healthcheck` API，该 API 返回系统日期和时间作为响应，如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s say a client makes another `GET` request to the `logout` API, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设客户端向 `logout` API 发送另一个 `GET` 请求，如下所示：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If this happens, the session will be invalidated, and access to the resource
    will be forbidden until another login request is done.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，会话将被无效化，直到完成另一个登录请求，否则将禁止访问资源。
- en: The admin and password credentials used in our examples are only for illustration
    purposes and should never be used in a production environment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中使用的管理员和密码凭证仅用于说明目的，不应在生产环境中使用。
- en: Always use randomly generated strong passwords!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用随机生成的强密码！
- en: Persisting client sessions with Redis
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redis 持久化客户端会话
- en: The sessions we've created so far are stored in the program memory. This means
    if the program crashes or restarts, all the logged sessions will be lost. It needs
    the client to log in once again to get a new session cookie. This is not helpful
    for auditing cookies. In order to save sessions somewhere, we can use Redis.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的会话存储在程序内存中。这意味着如果程序崩溃或重启，所有已记录的会话都将丢失。它需要客户端再次登录以获取新的会话 cookie。这对审计
    cookie 没有帮助。为了将会话存储在某个地方，我们可以使用 Redis。
- en: We have discussed running Redis in a Docker container in [Chapter 9](4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml),
    *Asynchronous API Design*. To recap, the Redis server stores key-value pairs.
    It provides basic data types such as strings, lists, hashes, sets, and so on.
    For more details, visit [https://redis.io/topics/data-types](https://redis.io/topics/data-types).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 9 章](4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml)，*异步 API 设计* 中讨论了在 Docker
    容器中运行 Redis。为了回顾，Redis 服务器存储键值对。它提供了基本的数据类型，如字符串、列表、散列、集合等。更多详情，请访问 [https://redis.io/topics/data-types](https://redis.io/topics/data-types)。
- en: Now, it is time to put our Redis knowledge into action. We are going to modify
    our project from `simpleAuth` to `simpleAuthWithRedis`. The new project should
    now use Redis as a session store. Copy the code from the previous example to the
    new one.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将我们的 Redis 知识付诸实践了。我们将修改我们的项目，从 `simpleAuth` 更改为 `simpleAuthWithRedis`。新的项目现在应该使用
    Redis 作为会话存储。将前一个示例中的代码复制到新的项目中。
- en: In [Chapter 9](4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml), *Asynchronous API
    Design*, we used the `go-redis` package to interact with the Redis server from
    a Go program. In this chapter, we'll introduce a new convenient package called
    `redistore.v1` so that we can store sessions in Redis.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9 章](4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml)，*异步 API 设计* 中，我们使用了 `go-redis`
    包从 Go 程序与 Redis 服务器交互。在本章中，我们将介绍一个新的方便的包 `redistore.v1`，这样我们就可以在 Redis 中存储会话。
- en: 'Install the package with the following `dep` command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 `dep` 命令安装包：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a new program, with a few modifications. Here, instead of using the `gorilla/sessions`
    package, we will use the `redistore` package. `redistore` has a function called
    `NewRediStore` that takes Redis configuration as its arguments, along with the
    secret key. It returns the same session object as `gorilla/sessions`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的程序，进行一些修改。在这里，我们不会使用 `gorilla/sessions` 包，而是使用 `redistore` 包。`redistore`
    包有一个名为 `NewRediStore` 的函数，它接受 Redis 配置作为其参数，以及密钥。它返回与 `gorilla/sessions` 相同的会话对象。
- en: 'The rest of the code remains the same. For brevity, these are the only changes
    we have to make:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其他部分保持不变。为了简洁，我们只需做出以下更改：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the logout handler, you will see this code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在注销处理程序中，你会看到以下代码：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Change the preceding code to this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码更改为以下内容：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This step removes the key from the Redis store, which is equivalent to revoking
    authentication from the client. This improved program works in a very similar
    way to the previous one, except the session is now saved in Redis.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤从 Redis 存储中删除密钥，相当于从客户端撤销认证。这个改进的程序与之前的程序非常相似，只是会话现在保存在 Redis 中。
- en: 'Run the new program, repeating the API query from the Postman tool. Once login
    is successful, launch `redis-cli` in the Docker container, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新的程序，重复使用 Postman 工具中的 API 查询。一旦登录成功，在 Docker 容器中启动 `redis-cli`，如下所示：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`some-redis` is the Redis server running the container name. Now, type the `KEYS
    *` command in the shell to see the newly stored session, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`some-redis` 是运行容器的 Redis 服务器名称。现在，在 shell 中输入 `KEYS *` 命令以查看新存储的会话，如下所示：'
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The lengthy `session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 长达 `session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA`
- en: key is the key stored by the `redistore` package. If we delete that key, the
    client will lose access to the `/healthcheck` API. Now, stop the running program
    and restart it. You will see that the session is not lost. In this way, we can
    save the client session.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`key` 是由 `redistore` 包存储的密钥。如果我们删除该密钥，客户端将无法访问 `/healthcheck` API。现在，停止运行程序并重新启动它。你会看到会话没有被丢失。这样，我们可以保存客户端会话。'
- en: Redis can serve the purpose of caching for your web applications. It can store
    temporary data such as sessions, frequently requested user content, and so on.
    It is usually compared to memcached.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 可以作为你的 Web 应用程序的缓存服务。它可以存储临时数据，如会话、频繁请求的用户内容等。它通常与 memcached 相比。
- en: In the next section, we'll explore a new way of authentication, called JWT.
    It deviates from sessions, and stores no cookies on the client machine.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一种新的认证方式，称为 JWT。它不同于会话，并且不会在客户端机器上存储任何 cookies。
- en: Introducing JWT and OAuth2
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 JWT 和 OAuth2
- en: The modern REST API implements token-based authentication. Here, tokens can
    be any strings generated by the server, which allows the client to access resources
    by producing a token. The token is computed in such a way that only the client
    and the server know how to encode/decode the token.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的 REST API 实现基于令牌的认证。在这里，令牌可以是服务器生成的任何字符串，允许客户端通过生成令牌来访问资源。令牌的计算方式使得只有客户端和服务器知道如何编码/解码令牌。
- en: The previous example relates to session-based authentication. This has a limitation
    of managing sessions by saving them in the program memory, or Redis/SQLite3\.
    JWT takes a different approach and creates tokens that can be passed around for
    authentication.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子与基于会话的身份验证相关。这有一个限制，即通过在程序内存中保存会话或Redis/SQLite3来管理会话。JWT采取不同的方法，创建了可以用于身份验证的令牌。
- en: 'Whenever a **Client** passes the authentication details to the **Server**,
    the server generates a token and passes it back to the **Client**. The client
    saves that in some kind of storage, such as AWS Secrets Manager, a database, or
    local storage (in the case of a browser). The **Client** uses that token to ask
    for resources from any API defined by the server. This process can be seen in
    the following diagram:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当**Client**将身份验证详细信息传递给**Server**时，服务器生成令牌并将其返回给**Client**。客户端将其保存在某种存储中，例如AWS
    Secrets Manager、数据库或本地存储（在浏览器的情况下）。**Client**使用该令牌从服务器定义的任何API请求资源。这个过程可以在以下图中看到：
- en: '![](img/288b80ee-76aa-424c-a781-dd4c8cc7af5a.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/288b80ee-76aa-424c-a781-dd4c8cc7af5a.png)'
- en: 'The steps shown in the preceding diagram can be summarized more briefly, as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中所显示的步骤可以更简要地总结如下：
- en: The **Client** passes the **username/password** in a `POST` request to the login
    API.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Client**在登录API的`POST`请求中传递**用户名/密码**。'
- en: The **Server** authenticates the details and, if successful, it generates a
    **JWT** and returns it instead of creating a cookie. It is the client's responsibility
    to store this token.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Server**验证详细信息，如果成功，则生成**JWT**并将其返回而不是创建cookie。存储此令牌是客户端的责任。'
- en: Now, the **Client** has the JWT. It needs to add this in the headers section
    to make subsequent REST API calls.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，**Client**拥有了JWT。它需要将其添加到头部部分以进行后续的REST API调用。
- en: The **Server** checks the JWT from the header and if it is successfully decoded,
    the server authenticates the client.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Server**检查来自头部的JWT，如果成功解码，则服务器验证客户端。'
- en: JWT ensures that the data is sent from the correct client. The technique for
    creating a token takes care of that logic. JWT leverages secret key-based encryption.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JWT确保数据是从正确的客户端发送的。创建令牌的技术负责处理这种逻辑。JWT利用基于密钥的加密。
- en: JWT format
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT格式
- en: 'Everything we discussed in the preceding section was about passing a JWT token.
    In this section, we will see what a JWT looks like, and how it is generated. These
    are the high-level steps for generating a JWT:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中讨论的每一件事都是关于传递JWT令牌。在本节中，我们将看到JWT的样子以及它是如何生成的。生成JWT的高级步骤如下：
- en: Create a `JWT` header by doing `Base64Url` encoding on the JSON header.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对JSON头部进行`Base64Url`编码来创建一个`JWT`头部。
- en: Create a `JWT` payload by doing `Base64Url` encoding on the JSON payload.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对JSON有效载荷进行`Base64Url`编码来创建一个`JWT`有效载荷。
- en: Create a signature by encrypting the appended header and payload using a secret
    key.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用密钥加密附加的头部和有效载荷来创建一个签名。
- en: A JWT string can be obtained by appending the `JWT` header, `JWT` payload, and
    signature.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过附加JWT头部、JWT有效载荷和签名可以获得JWT字符串。
- en: 'A header is a simple JSON object. It looks like the following code snippet
    in Go:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 头部是一个简单的JSON对象。它看起来像以下Go代码片段：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`HS256` is a short form for the algorithm (HMAC with SHA-256) that''s used
    for creating a signature. The message type is `JWT`. This will be common for all
    the headers. The algorithm may change, depending on the system.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`HS256`是用于创建签名的算法（HMAC与SHA-256）的简称。消息类型是`JWT`。这将是所有头部的常见格式。算法可能会根据系统而变化。'
- en: 'A payload looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷看起来像这样：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Keys in a payload object are called **claims**. A claim is a key that specifies
    some special meaning to the server. There are three types of claims:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷对象中的键称为**声明**。声明是一个键，它指定了对于服务器的一些特殊含义。有三种类型的声明：
- en: Reserved claims
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留声明
- en: Private claims (more important)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有声明（更重要）
- en: Public claims
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共声明
- en: We'll discuss each of these claims in detail in the upcoming sections.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细讨论这些声明。
- en: Reserved claims
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留声明
- en: '**Reserved claims** are the ones defined by the JWT standard. They are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**保留声明**是由JWT标准定义的。它们如下：'
- en: '**iat**: Issued at the time'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iat**: 发布时间'
- en: '**iss**: Issuer name'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iss**: 发布者名称'
- en: '**sub**: Subject text'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sub**: 主题文本'
- en: '**aud**: Audience name'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**aud**: 受众名称'
- en: '**exp**: Expiration time'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exp**: 过期时间'
- en: For example, the server, while generating a token, can set an exp claim in the
    payload. The client then uses that token to access API resources. The server validates
    the token each time. When the expiration time is passed, the server will no longer
    validate the token. The client needs to generate a new token by logging in again.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，服务器在生成令牌时，可以在有效负载中设置一个exp声明。然后客户端使用该令牌来访问API资源。服务器每次都会验证令牌。当过期时间过去后，服务器将不再验证令牌。客户端需要再次登录以生成新的令牌。
- en: Private claims
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有声明
- en: '**Private claims** are used to identify one token from another. They can be
    used for authorization. **Authorization** is a process of identifying which client
    made the request. **Multi-tenancy** refers to the situation of multiple clients
    accessing an API on a system. The server can set a private claim called **username**
    on the payload of the token. Next time, the server can read this payload back
    and get the username, and then use that username to authorize and customize the
    API response. It is similar to a cookie but in a different way.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有声明**用于区分一个令牌与另一个令牌。它们可用于授权。**授权**是一个识别哪个客户端发出了请求的过程。**多租户**指的是多个客户端访问系统上的API的情况。服务器可以在令牌的有效负载上设置一个名为**用户名**的私有声明。下次，服务器可以读取这个有效负载并获取用户名，然后使用该用户名进行授权并定制API响应。这与cookie类似，但方式不同。'
- en: 'For example, `username`: `Indiana Jones` is a private claim in the following
    payload:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`username`: `Indiana Jones`是以下有效负载中的私有声明：'
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Public claims** are similar to private claims, but they should be registered
    with the IANA JWT Registry to make them as a standard. We limit the use of these.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共声明**与私有声明类似，但它们应该在IANA JWT注册表中注册，以使其成为标准。我们限制这些的使用。'
- en: 'A signature can be created by performing this operation (this is not code,
    just an illustration):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行此操作创建签名（这不是代码，只是一个说明）：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is simply performing an encryption algorithm on the Base64Url-encoded header
    and payload with a secret. This secret can be any string. It is exactly the same
    as the secret we used in the previous cookie session. This secret is usually saved
    in the environment variable and loaded into the program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对Base64Url编码的头部和有效负载使用一个秘密进行加密算法。这个秘密可以是任何字符串。它与我们在上一个cookie会话中使用的秘密完全相同。这个秘密通常保存在环境变量中，并加载到程序中。
- en: 'Now, we append the encoded header, encoded payload, and signature to get our
    token string, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编码的头部、编码的有效负载和签名附加在一起，以获取我们的令牌字符串，如下所示：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is how a JWT token is generated. There are a few Go packages that can
    generate and verify a JWT. One such popular package is `jwt-go`. We are going
    to create a project in the next section that uses `jwt-go` to sign a JWT and also
    verify it. We can install this package using the following `dep` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JWT令牌的生成方式。有几个Go包可以生成和验证JWT。其中一个流行的包是`jwt-go`。在下一节中，我们将创建一个使用`jwt-go`来签名JWT并验证它的项目。我们可以使用以下`dep`命令安装此包：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is the official GitHub page for the project: [https://github.com/dgrijalva/jwt-go](https://github.com/dgrijalva/jwt-go).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是项目的官方GitHub页面：[https://github.com/dgrijalva/jwt-go](https://github.com/dgrijalva/jwt-go)。
- en: The package provides a few functions that allow us to create tokens. There are
    many other packages with different additional features. You can see all the available
    packages and features that are supported at [https://jwt.io/#libraries-io](https://jwt.io/#libraries-io).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 包提供了一些函数，允许我们创建令牌。还有许多其他具有不同附加功能的包。您可以在[https://jwt.io/#libraries-io](https://jwt.io/#libraries-io)查看所有可用的包和受支持的特性。
- en: Creating a JWT in Go
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中创建JWT
- en: 'The `jwt-go` package has a function called `NewWithClaims` that takes two arguments:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`jwt-go`包有一个名为`NewWithClaims`的函数，它接受两个参数：'
- en: A signing method such as `HMAC256`, `RSA`, and so on
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种签名方法，如`HMAC256`、`RSA`等
- en: A claims map
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明映射
- en: 'For example, it looks like the following code snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它看起来像以下代码片段：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`jwt.SigningMethodHS256` is an encryption algorithm that is available within
    the package. The second argument is a map with claims such as private (here, username)
    and reserved (issued iat). Now, we can generate a `tokenString` using the `SignedString`
    function on a token, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`jwt.SigningMethodHS256`是包内可用的加密算法。第二个参数是一个包含声明，如私有（这里，用户名）和保留（发行iat）的映射。现在，我们可以使用令牌上的`SignedString`函数生成`tokenString`，如下所示：'
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This `tokenString` should then be sent back to the client as part of a successful
    login response.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应该将此`tokenString`作为成功登录响应的一部分发送回客户端。
- en: Reading a JWT in Go
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中读取JWT
- en: '`jwt-go` also gives us the API to parse a given JWT string. The Parse function
    takes a string and key function as arguments. The key function is a custom function
    that validates whether the algorithm is real or not. Let us say this is a sample
    token string generated by the preceding encoding:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`jwt-go` 还为我们提供了解析给定 JWT 字符串的 API。`Parse` 函数接受一个字符串和一个键函数作为参数。键函数是一个自定义函数，用于验证算法是否真实。让我们假设这是一个由前面的编码生成的示例令牌字符串：'
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can parse and get back the original JSON using the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码解析并获取原始 JSON：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`token.Claims` is implemented by a map called **MapClaims**. We can get the
    original JSON key-value pairs from that map.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`token.Claims` 是通过一个名为 **MapClaims** 的映射实现的。我们可以从该映射中获取原始 JSON 的键值对。'
- en: In the next section, we'll discuss the OAuth 2.0 workflow and the difference
    between authentication and authorization.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 OAuth 2.0 的工作流程以及认证和授权之间的区别。
- en: JWT in an OAuth2.0 workflow
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT 在 OAuth2.0 的工作流程中
- en: '**OAuth 2.0** is an authentication framework that is used to create an authentication
    pattern between different systems. here, the client, instead of making a request
    to the resource server, makes an initial request to an entity called **resource
    owner**. This resource owner sends back the authentication grant for the client
    (if the credentials are authenticated). The client now sends this authentication
    grant to another entity called an **authentication server**. The authentication
    server takes the grant and returns an access token. The access token is a'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth 2.0** 是一个用于在不同系统之间创建认证模式的认证框架。在这里，客户端不是向资源服务器发出请求，而是向一个称为 **资源所有者**
    的实体发出初始请求。这个资源所有者会向客户端发送认证授权（如果凭证已验证）。客户端现在将这个认证授权发送给另一个称为 **认证服务器** 的实体。认证服务器接收授权并返回访问令牌。访问令牌是一个'
- en: Authentication versus authorization
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证与授权的比较
- en: '**Authentication** is the process of identifying whether a client is genuine
    or not. When a server authenticates a client, it checks the username/password
    pair and creates a session `cookie/JWT`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证** 是识别客户端是否真实的过程。当服务器认证客户端时，它会检查用户名/密码对并创建一个会话 `cookie/JWT`。'
- en: '**Authorization** is the process of evaluating whether a user has access to
    a given resource. In cloud services, there should be a mechanism to limit the
    scope of resource access for certain users/roles, and authorization enables it.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权** 是评估用户是否有权访问给定资源的过程。在云服务中，应该有一种机制来限制某些用户/角色的资源访问范围，而授权正是实现这一点的手段。'
- en: In simple words, authentication decides who is the customer of a service, and
    authorization determines what are the customer's boundaries for resource access.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，认证决定了一个服务的客户是谁，而授权决定了客户在资源访问方面的界限。
- en: 'OAuth 2.0 is a protocol for authenticating multiple clients to a service, whereas
    JWT is a token format. We need to encode/decode JWT tokens to implement the second
    stage (dashed lines in the following diagram) of OAuth 2.0:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0 是一个用于认证多个客户端到服务的协议，而 JWT 是一种令牌格式。我们需要对 JWT 令牌进行编码/解码以实现 OAuth 2.0
    的第二阶段（以下图中虚线部分）：
- en: '![](img/af069940-c17a-4f2e-81b5-ae551da3746b.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af069940-c17a-4f2e-81b5-ae551da3746b.png)'
- en: In the preceding diagram, the dotted section is where a **Client** requests
    an access token from the **Authentication Server**. This is where a JWT life cycle
    begins.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，虚线部分是客户端从 **认证服务器** 请求访问令牌的地方。这就是 JWT 生命周期开始的地方。
- en: In the next section, we'll present a development exercise for you to complete.
    This exercise can be completed by combining all the concepts we have learned about
    so far.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将提供一个开发练习供您完成。这个练习可以通过结合我们迄今为止学到的所有概念来完成。
- en: Exercise
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Can you design the following requirements?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您能设计以下要求吗？
- en: 'Develop a `/healthcheck` API with token authentication. Its main responsibilities
    should be as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个使用令牌认证的 `/healthcheck` API。其主要职责应如下：
- en: Authenticate the client and return a JWT string
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证客户端并返回 JWT 字符串
- en: Authorize client API requests by validating the JWT
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过验证 JWT 授权客户端 API 请求
- en: 'You should use the knowledge you gained about the `jwt-go` package from the
    previous section. You have to build two endpoints, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用上一节中关于 `jwt-go` 包的知识。您必须构建两个端点，如下所示：
- en: '`/getToken`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/getToken`'
- en: '`/healthcheck`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/healthcheck`'
- en: The first endpoint should successfully log in a client and return a JWT token.
    The client should then use the second endpoint with the token to receive a successful
    response.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个端点应该成功登录客户端并返回JWT令牌。然后客户端应使用带有令牌的第二个端点来接收成功响应。
- en: 'Post-development, the final API testing scenario should look something similar
    to this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 开发完成后，最终的API测试场景应该看起来类似于以下内容：
- en: 'If you make a `GET` request to the `/healthcheck` API without any token, you
    should receive an `Access Denied` message, as shown here:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你向`/healthcheck` API发出没有令牌的`GET`请求，你应该收到一个`访问被拒绝`的消息，如下所示：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should be able to authenticate and get a JWT token from the API server
    with a `POST` request, as shown in the following screenshot:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能够通过`POST`请求从API服务器进行认证并获取JWT令牌，如下面的截图所示：
- en: '![](img/7b838296-b9e0-42b7-96c3-a7de42d20fb1.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b838296-b9e0-42b7-96c3-a7de42d20fb1.png)'
- en: 'With the returned JWT, you can now make a successful `GET` request to `/healthcheck`
    with an access_token header, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用返回的JWT，你现在可以成功地向`/healthcheck`发出带有access_token头的`GET`请求，如下所示：
- en: '![](img/b7d4a20e-60cf-4197-a395-45466f0e5769.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7d4a20e-60cf-4197-a395-45466f0e5769.png)'
- en: If you can implement the preceding requirements, you have already got a nice
    understanding of JWT. If not, do not worry. The solution for the challenge is
    available in the `chapter14/jwtauth` project directory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够实现前面的要求，你已经对JWT有了很好的理解。如果没有，不要担心。挑战的解决方案可以在`chapter14/jwtauth`项目目录中找到。
- en: Token-based authentication doesn't usually provide a logout API or an API for
    deleting the tokens that are provided in session-based authentication. The server
    gives the authorized resources to the client as long as the JWT hasn't expired.
    Once it expires, the client needs to refresh the token—that is to say, ask the
    server for a new token.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的认证通常不提供退出API或删除基于会话认证提供的令牌的API。只要JWT没有过期，服务器就会将授权资源提供给客户端。一旦它过期，客户端就需要刷新令牌——也就是说，请求服务器提供一个新的令牌。
- en: In the next section, we'll discuss a few tips for securing an API.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一些确保API安全的技巧。
- en: Security aspects of an API
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API的安全方面
- en: 'Every REST API that is developed can be either open or protected. An open API
    has no limit regarding the number of clients requesting the resources. But most
    business APIs are protected. So, what are the important things to keep in mind
    about security? In the following list, we''ll point out all the factors that should
    be taken care of to secure a REST API:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发的REST API都可以是公开的或受保护的。公开API对请求资源的客户端数量没有限制。但大多数商业API都是受保护的。那么，关于安全性，我们应该注意哪些重要事项？在以下列表中，我们将指出所有应该注意的因素，以确保REST
    API的安全：
- en: Always use HTTPS to deliver the API **Transport Layer Security** (**TLS**).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是使用HTTPS来提供API的**传输层安全性**（**TLS**）。
- en: Rate limit the API by using user access tokens.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户访问令牌来限制API的速率。
- en: Design various authentication and authorization roles on the API.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在API上设计各种认证和授权角色。
- en: Use public key/private key encryption to sign a JWT when the client and server
    are internal.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端和服务器内部时，使用公钥/私钥加密来签名JWT。
- en: Never store user credentials in plain files.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要将用户凭证存储在明文文件中。
- en: Sanitize the URL query parameters; use a POST body for incoming requests.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理URL查询参数；使用POST体来处理传入的请求。
- en: As we mentioned in the previous chapter, use an API Gateway for better performance
    and protection.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在上一章中提到的，使用API网关以获得更好的性能和保护。
- en: Use cloud services such as AWS Secrets Manager to store keys/passwords.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用云服务，如AWS Secrets Manager来存储密钥/密码。
- en: 'Most modern APIs are run as containers/**Virtual Private Servers** (**VPS**) on
    cloud providers. The security there can be applied at two levels:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代API都在云提供商上作为容器/**虚拟专用服务器**（**VPS**）运行。那里的安全性可以在两个级别上应用：
- en: Network level
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络级别
- en: Application level
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序级别
- en: An API developer who develops and deploys their application on the cloud should
    be aware of the preceding levels. Knowledge of security breach-counteracting measures
    and patching up the API is a key security skill you will need.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在云上开发和部署应用程序的API开发者应该意识到上述级别。了解安全漏洞的应对措施和对API进行修补是您将需要的核心安全技能。
- en: Also, an exposed REST API is the easiest victim for attacks such as **Denial
    of Service** (**DoS**) attacks. Deploying an API behind a firewall service can
    increase security from those attacks. In the case of an internal API, where a
    company's service communicates only with other internal services but from different
    geographical regions, a  VPN is desirable.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，暴露的 REST API 是攻击如**拒绝服务**（**DoS**）攻击的最容易受害的目标。在防火墙服务后面部署 API 可以增加对这些攻击的安全性。在内部
    API 的情况下，公司服务仅与其他内部服务通信，但来自不同的地理区域，VPN 是理想的选择。
- en: Security is a beast of its own domain and needs to be carefully monitored in
    every aspect of API development.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是其自身领域的猛兽，需要在 API 开发的各个方面进行仔细监控。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we introduced the process of authentication. We saw how authentication
    usually works. Authentication can be of three types: basic authentication, session-based,
    or token-based. With basic authentication, every HTTP request supplies a `username`
    and `password`. Session-based authentication uses a saved session to authenticate
    a client.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了身份验证的过程。我们看到了身份验证通常是如何工作的。身份验证可以是三种类型之一：基本身份验证、基于会话的身份验证或基于令牌的身份验证。基本身份验证要求每个
    HTTP 请求都提供 `用户名` 和 `密码`。基于会话的身份验证使用保存的会话来验证客户端。
- en: Sessions stored in program memory are lost once a web server crashes/restarts.
    Redis can be used with a package called `redistore` to help store session cookies.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在程序内存中的会话一旦网络服务器崩溃/重启就会丢失。可以使用名为 `redistore` 的软件包与 Redis 一起使用，以帮助存储会话 cookie。
- en: Next, we learned about JWT, a token-based authentication whereby a client requests
    a JWT token from the server. Once the client has the JWT token, it can pass that
    token in the HTTP header while requesting API resources.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了 JWT（基于令牌的认证），客户端从服务器请求 JWT 令牌。一旦客户端拥有 JWT 令牌，它可以在请求 API 资源时将令牌传递到
    HTTP 头部。
- en: We then introduced OAuth 2.0, an authentication framework. There, we saw how
    the client requests a grant from the resource owner. Once it gets the grant, it
    requests an access token from the authentication server. After getting the access
    token from the authentication server, the client can use the token to request
    an API.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了 OAuth 2.0，这是一个身份验证框架。在那里，我们看到了客户端如何从资源所有者请求授权。一旦获得授权，它就会从身份验证服务器请求访问令牌。在从身份验证服务器获得访问令牌后，客户端可以使用该令牌来请求
    API。
- en: We tested all our APIs with curl and Postman. Postman is a great tool that helps
    us test our APIs quickly on any machine, whereas curl is limited to Linux and Mac
    OS X .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 curl 和 Postman 测试了所有我们的 API。Postman 是一款出色的工具，它可以帮助我们在任何机器上快速测试我们的 API，而
    curl 则仅限于 Linux 和 Mac OS X。
- en: We came a long way from the first chapter by learning how to create HTTP routes,
    middleware, and handlers. We then explored various SQL and NoSQL storage backends
    for an API. After the basics, we explored performance-tuning aspects such as asynchronous
    design, the GraphQL API, and microservices. Finally, we learned how to deploy
    our web services to the cloud and also secure them by enabling authentication.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何创建 HTTP 路由、中间件和处理程序，我们从第一章走了很长的路。然后我们探索了 API 的各种 SQL 和 NoSQL 存储后端。在基础知识之后，我们探讨了性能调优方面，如异步设计、GraphQL
    API 和微服务。最后，我们学习了如何将我们的网络服务部署到云端，并通过启用身份验证来确保它们的安全。
