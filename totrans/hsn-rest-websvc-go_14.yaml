- en: Handling Authentication for our REST Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore **Representational State Transfer**
    (**REST**) API authentication patterns. These patterns are session-based authentication, **JSON
    Web Tokens** (**JWT**), and **Open Authentication 2** (**OAuth 2.0**). We will
    try to leverage the Gorilla package's `sessions` library to create basic sessions.
    Then, we will move on to advanced REST API authentication strategies, such as
    stateless JWT. Finally, we will discuss the OAuth 2.0 authentication pattern and
    the security aspects of an API. In the previous chapter, the **Amazon Web Services**
    (**AWS**) API Gateway took care of authentication (using **Identity and Access
    Management** (**IAM**) roles) for us. If an API Gateway is not present, how do
    we secure our API? You will find the answer in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How simple authentication works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Postman, a visual client for testing a REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting client sessions with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing JWT and OAuth 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JWT in an OAuth 2.0 workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise for the reader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security aspects of an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software should be pre-installed for running the code samples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating system: Linux (Ubuntu 18.04)/Windows 10/Mac OS X  >= 10.13'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go stable version compiler >= 1.13.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker version >= 18.09.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter14](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter14).
    Clone the code, and use the code samples in the `chapter14` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How simple authentication works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, authentication—or simple authentication—works with sessions.
    The flow starts like this. A client sends an authentication request to the server
    using user credentials. The server takes those credentials and matches them with
    the credentials stored on the server. If a match is successful, it writes something
    called a **cookie** in the response. This cookie is a small piece of information
    that is transferred by the client for all subsequent requests. Modern websites
    are being designed to be **single-page applications** (**SPAs**). In those websites, static
    assets such as HTML and JavaScript files are served from a **Content Delivery
    Network** (**CDN**) to render the web page initially. After that, the communication
    between the web page and application server happens only through the REST API/web
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **session** is a nice way to record user communication in a given period
    of time. A session is a concept whereby authentication information is stored in
    a cookie. The following diagram explains what happens in a basic session-based
    authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/474314d9-b218-4c16-ae15-8c72dcd32b49.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's look at a practical approach. A **Client** (for example, a browser)
    sends a request to the **Login API** of the **Server**. The server tries to check
    those credentials with the database and, if the credentials exist, writes a **cookie**
    back onto the response saying that this user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: A **cookie** is a message consumed by the server at a later point in time. When
    the client receives the response, it stores that cookie locally. After that, the
    client can ask for resources from the server by showing the cookie as the key
    for passage.
  prefs: []
  type: TYPE_NORMAL
- en: When a client decides to terminate the session, it calls the logout API on the
    server. The server destroys the session in the response. This process is repeated
    for every login/logout. The server can also place an expiration on cookies so
    that the authentication window is valid for a certain time if there is no activity.
    This is how many websites work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll try to implement one such system using the `gorilla/sessions` package.
    We already learned about gorilla/mux in the initial chapters. We need to install
    the package first by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could do this by using the Dep tool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a new session using the `NewCookieStore` method from the `sessions`
    package, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That `secret_key` should be the key that `gorilla/sessions` uses to encrypt
    the session cookies. If we add a session as a normal text, anyone can read it.
    So, the server needs to encrypt a message to a random string. For that, it asks
    to provide a secret key. This secret key can be any randomly generated string.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping secret keys in code is not a good idea, so we try to store it as an
    environment variable and read it in code on the fly. In the next section, we'll
    look at an example of session authentication.
  prefs: []
  type: TYPE_NORMAL
- en: A simple authentication example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build a secure API that gives access to clients only after logging in.
    In the process, we will define three endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/login`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/logout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/healthcheck`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/healthcheck` is the data API, but it first has to log in using the /login
    endpoint. Our API should reject all unauthenticated requests. Create a project
    directory called `simpleAuth`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the program, we can see how to enable session-based authentication to API
    endpoints using the gorilla/ sessions package. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need imports for our program. The main ones are `mux` and `sessions`, as
    seen in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a cookie store to store the written cookie information. We can
    do that using the `sessions.NewCookieStore` method. It takes a byte array of the
    secret key. The secret key is fetched from the `SESSION_SECRET` environment variable,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can set any key you wish to that environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create mock `usernames` and a `password` as we don''t have a signup
    mechanism, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These mock username/password combinations are checked against a client request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a login handler that sets the cookie. The API is a `POST` request
    with credentials supplied in the POST body, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we should first parse the POST body, and get the `username`
    and `password`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have collected the `username` and `password`, our plan is to validate
    them with the mock data. If the credentials are matching, then set the request
    session to authenticated. Otherwise, show the error message accordingly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This completes the login handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, let us define the logout handler. The logout handler takes
    an incoming `GET` request and sets the session variable authenticated to `false`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see the logout handler implementation, then we have modified the `session`
    object to invalidate the client session, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this way, simple authentication can be implemented using client sessions
    in any programming language, including Go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't forget to save the cookie after modifying it. The code for this is `session.Save(r,
    w)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us define our `/healthcheck`. data API. It is an API that sends the
    system time back. It returns a response if the client session is authenticated.
    Otherwise, it returns a `403 Forbidden response`. The `session` object from the
    request can be used for the validity check, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All the API handlers are ready. We have to write the `main` function, where
    we map API endpoints (routes) to the preceding handlers. We use the `mux` router
    for that purpose. Then, we pass this router to an HTTP server that runs on `http://localhost:8000`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This finishes the secured application. We can run the program from the  `simpleAuth` root
    directory by typing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This starts the server on `http://localhost:8000`.
  prefs: []
  type: TYPE_NORMAL
- en: The error codes can mean different things. For example, `Forbidden (403)` is
    issued when the user tries to access a resource without authentication, whereas
    `Resource Not Found (404)` is issued when the given resource does not exist on
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll introduce a new tool to query an API, called Postman.
    The Postman tool has a nice **User Interface** (**UI**) and runs on all platforms.
    We are going to test the `simpleAuth` example with this new tool.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Postman, a visual client for testing a REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Postman** is a great UI client that allows Windows, Mac OS X, and Linux users
    to make HTTP API requests. You can download it from here: [https://www.getpostman.com/product/api-client](https://www.getpostman.com/product/api-client)[.](https://www.getpostman.com/product/api-client)
    Instead of making an API request with `curl`, let us use the Postman tool. We
    will pick the `simpleAuth` example from the previous section. See the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Post-installation, open the Postman tool, then try a [www.example.org](http://www.example.org) URL
    in the Enter request URL input text. You can select the type of request from the
    dropdown (GET, POST, and so on). For each request, you can configure many settings
    such as Headers, POST body, and other details as a menu under URL. Play with the
    options and get comfortable with them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please go through the Postman documentation for more details. It comes with
    various options for replaying API queries. Take some time to explore the features
    at [https://learning.postman.com/getting-started/](https://learning.postman.com/getting-started/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c388dc6-8bf9-47fb-ad5f-b937ce2150ea.png)'
  prefs: []
  type: TYPE_IMG
- en: The Builder is the top-level menu item, where we can add/edit requests. The
    preceding screenshot shows the empty builder, where we try to make requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the `main.go` file in the preceding `simpleAuth` project and try
    to call the `/healthcheck` API. Click on the Send button. You will see that the
    response is 403 Forbidden, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1cddf709-f83d-4317-96d9-f08741f7d390.png)'
  prefs: []
  type: TYPE_IMG
- en: This is because we are not logged in yet. Postman automatically saves the cookie
    once authentication is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, call the login API by changing the method type from GET to POST, and the
    URL to http://localhost:8000/login. We should pass the credentials as `multipart/form-data`. We
    should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/96b735c6-b1b4-45de-8a9a-d1ffba88ff29.png)'
  prefs: []
  type: TYPE_IMG
- en: Hit the blue Send button. This makes a login request to our previously run server.
    It returns a message, saying Logged In successfully. We can inspect the cookies
    by clicking on the Cookies link, just following the Save button on the right-hand
    side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It shows the list of cookies saved, and you will find a cookie called `session.id`
    there for the localhost site. The content will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to call the `/healthcheck` API again, which returns the system date and
    time as a response, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say a client makes another `GET` request to the `logout` API, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If this happens, the session will be invalidated, and access to the resource
    will be forbidden until another login request is done.
  prefs: []
  type: TYPE_NORMAL
- en: The admin and password credentials used in our examples are only for illustration
    purposes and should never be used in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Always use randomly generated strong passwords!
  prefs: []
  type: TYPE_NORMAL
- en: Persisting client sessions with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sessions we've created so far are stored in the program memory. This means
    if the program crashes or restarts, all the logged sessions will be lost. It needs
    the client to log in once again to get a new session cookie. This is not helpful
    for auditing cookies. In order to save sessions somewhere, we can use Redis.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed running Redis in a Docker container in [Chapter 9](4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml),
    *Asynchronous API Design*. To recap, the Redis server stores key-value pairs.
    It provides basic data types such as strings, lists, hashes, sets, and so on.
    For more details, visit [https://redis.io/topics/data-types](https://redis.io/topics/data-types).
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to put our Redis knowledge into action. We are going to modify
    our project from `simpleAuth` to `simpleAuthWithRedis`. The new project should
    now use Redis as a session store. Copy the code from the previous example to the
    new one.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml), *Asynchronous API
    Design*, we used the `go-redis` package to interact with the Redis server from
    a Go program. In this chapter, we'll introduce a new convenient package called
    `redistore.v1` so that we can store sessions in Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the package with the following `dep` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Create a new program, with a few modifications. Here, instead of using the `gorilla/sessions`
    package, we will use the `redistore` package. `redistore` has a function called
    `NewRediStore` that takes Redis configuration as its arguments, along with the
    secret key. It returns the same session object as `gorilla/sessions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the code remains the same. For brevity, these are the only changes
    we have to make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the logout handler, you will see this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This step removes the key from the Redis store, which is equivalent to revoking
    authentication from the client. This improved program works in a very similar
    way to the previous one, except the session is now saved in Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the new program, repeating the API query from the Postman tool. Once login
    is successful, launch `redis-cli` in the Docker container, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`some-redis` is the Redis server running the container name. Now, type the `KEYS
    *` command in the shell to see the newly stored session, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The lengthy `session_VPJ54LWRE4DNTYCLEJWAUN5SDLVW6LN6MLB26W2OB4JDT26CR2GA`
  prefs: []
  type: TYPE_NORMAL
- en: key is the key stored by the `redistore` package. If we delete that key, the
    client will lose access to the `/healthcheck` API. Now, stop the running program
    and restart it. You will see that the session is not lost. In this way, we can
    save the client session.
  prefs: []
  type: TYPE_NORMAL
- en: Redis can serve the purpose of caching for your web applications. It can store
    temporary data such as sessions, frequently requested user content, and so on.
    It is usually compared to memcached.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll explore a new way of authentication, called JWT.
    It deviates from sessions, and stores no cookies on the client machine.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JWT and OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modern REST API implements token-based authentication. Here, tokens can
    be any strings generated by the server, which allows the client to access resources
    by producing a token. The token is computed in such a way that only the client
    and the server know how to encode/decode the token.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example relates to session-based authentication. This has a limitation
    of managing sessions by saving them in the program memory, or Redis/SQLite3\.
    JWT takes a different approach and creates tokens that can be passed around for
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a **Client** passes the authentication details to the **Server**,
    the server generates a token and passes it back to the **Client**. The client
    saves that in some kind of storage, such as AWS Secrets Manager, a database, or
    local storage (in the case of a browser). The **Client** uses that token to ask
    for resources from any API defined by the server. This process can be seen in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/288b80ee-76aa-424c-a781-dd4c8cc7af5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The steps shown in the preceding diagram can be summarized more briefly, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Client** passes the **username/password** in a `POST` request to the login
    API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Server** authenticates the details and, if successful, it generates a
    **JWT** and returns it instead of creating a cookie. It is the client's responsibility
    to store this token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the **Client** has the JWT. It needs to add this in the headers section
    to make subsequent REST API calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Server** checks the JWT from the header and if it is successfully decoded,
    the server authenticates the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JWT ensures that the data is sent from the correct client. The technique for
    creating a token takes care of that logic. JWT leverages secret key-based encryption.
  prefs: []
  type: TYPE_NORMAL
- en: JWT format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything we discussed in the preceding section was about passing a JWT token.
    In this section, we will see what a JWT looks like, and how it is generated. These
    are the high-level steps for generating a JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `JWT` header by doing `Base64Url` encoding on the JSON header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `JWT` payload by doing `Base64Url` encoding on the JSON payload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a signature by encrypting the appended header and payload using a secret
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A JWT string can be obtained by appending the `JWT` header, `JWT` payload, and
    signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A header is a simple JSON object. It looks like the following code snippet
    in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`HS256` is a short form for the algorithm (HMAC with SHA-256) that''s used
    for creating a signature. The message type is `JWT`. This will be common for all
    the headers. The algorithm may change, depending on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A payload looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Keys in a payload object are called **claims**. A claim is a key that specifies
    some special meaning to the server. There are three types of claims:'
  prefs: []
  type: TYPE_NORMAL
- en: Reserved claims
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private claims (more important)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public claims
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll discuss each of these claims in detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved claims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reserved claims** are the ones defined by the JWT standard. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iat**: Issued at the time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iss**: Issuer name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sub**: Subject text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**aud**: Audience name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exp**: Expiration time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the server, while generating a token, can set an exp claim in the
    payload. The client then uses that token to access API resources. The server validates
    the token each time. When the expiration time is passed, the server will no longer
    validate the token. The client needs to generate a new token by logging in again.
  prefs: []
  type: TYPE_NORMAL
- en: Private claims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Private claims** are used to identify one token from another. They can be
    used for authorization. **Authorization** is a process of identifying which client
    made the request. **Multi-tenancy** refers to the situation of multiple clients
    accessing an API on a system. The server can set a private claim called **username**
    on the payload of the token. Next time, the server can read this payload back
    and get the username, and then use that username to authorize and customize the
    API response. It is similar to a cookie but in a different way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `username`: `Indiana Jones` is a private claim in the following
    payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Public claims** are similar to private claims, but they should be registered
    with the IANA JWT Registry to make them as a standard. We limit the use of these.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A signature can be created by performing this operation (this is not code,
    just an illustration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is simply performing an encryption algorithm on the Base64Url-encoded header
    and payload with a secret. This secret can be any string. It is exactly the same
    as the secret we used in the previous cookie session. This secret is usually saved
    in the environment variable and loaded into the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we append the encoded header, encoded payload, and signature to get our
    token string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how a JWT token is generated. There are a few Go packages that can
    generate and verify a JWT. One such popular package is `jwt-go`. We are going
    to create a project in the next section that uses `jwt-go` to sign a JWT and also
    verify it. We can install this package using the following `dep` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is the official GitHub page for the project: [https://github.com/dgrijalva/jwt-go](https://github.com/dgrijalva/jwt-go).
  prefs: []
  type: TYPE_NORMAL
- en: The package provides a few functions that allow us to create tokens. There are
    many other packages with different additional features. You can see all the available
    packages and features that are supported at [https://jwt.io/#libraries-io](https://jwt.io/#libraries-io).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JWT in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `jwt-go` package has a function called `NewWithClaims` that takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A signing method such as `HMAC256`, `RSA`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A claims map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, it looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`jwt.SigningMethodHS256` is an encryption algorithm that is available within
    the package. The second argument is a map with claims such as private (here, username)
    and reserved (issued iat). Now, we can generate a `tokenString` using the `SignedString`
    function on a token, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This `tokenString` should then be sent back to the client as part of a successful
    login response.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a JWT in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`jwt-go` also gives us the API to parse a given JWT string. The Parse function
    takes a string and key function as arguments. The key function is a custom function
    that validates whether the algorithm is real or not. Let us say this is a sample
    token string generated by the preceding encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can parse and get back the original JSON using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`token.Claims` is implemented by a map called **MapClaims**. We can get the
    original JSON key-value pairs from that map.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll discuss the OAuth 2.0 workflow and the difference
    between authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: JWT in an OAuth2.0 workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OAuth 2.0** is an authentication framework that is used to create an authentication
    pattern between different systems. here, the client, instead of making a request
    to the resource server, makes an initial request to an entity called **resource
    owner**. This resource owner sends back the authentication grant for the client
    (if the credentials are authenticated). The client now sends this authentication
    grant to another entity called an **authentication server**. The authentication
    server takes the grant and returns an access token. The access token is a'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication versus authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Authentication** is the process of identifying whether a client is genuine
    or not. When a server authenticates a client, it checks the username/password
    pair and creates a session `cookie/JWT`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization** is the process of evaluating whether a user has access to
    a given resource. In cloud services, there should be a mechanism to limit the
    scope of resource access for certain users/roles, and authorization enables it.'
  prefs: []
  type: TYPE_NORMAL
- en: In simple words, authentication decides who is the customer of a service, and
    authorization determines what are the customer's boundaries for resource access.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth 2.0 is a protocol for authenticating multiple clients to a service, whereas
    JWT is a token format. We need to encode/decode JWT tokens to implement the second
    stage (dashed lines in the following diagram) of OAuth 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af069940-c17a-4f2e-81b5-ae551da3746b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the dotted section is where a **Client** requests
    an access token from the **Authentication Server**. This is where a JWT life cycle
    begins.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll present a development exercise for you to complete.
    This exercise can be completed by combining all the concepts we have learned about
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you design the following requirements?
  prefs: []
  type: TYPE_NORMAL
- en: 'Develop a `/healthcheck` API with token authentication. Its main responsibilities
    should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticate the client and return a JWT string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorize client API requests by validating the JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should use the knowledge you gained about the `jwt-go` package from the
    previous section. You have to build two endpoints, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/getToken`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/healthcheck`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first endpoint should successfully log in a client and return a JWT token.
    The client should then use the second endpoint with the token to receive a successful
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Post-development, the final API testing scenario should look something similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you make a `GET` request to the `/healthcheck` API without any token, you
    should receive an `Access Denied` message, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to authenticate and get a JWT token from the API server
    with a `POST` request, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7b838296-b9e0-42b7-96c3-a7de42d20fb1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the returned JWT, you can now make a successful `GET` request to `/healthcheck`
    with an access_token header, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b7d4a20e-60cf-4197-a395-45466f0e5769.png)'
  prefs: []
  type: TYPE_IMG
- en: If you can implement the preceding requirements, you have already got a nice
    understanding of JWT. If not, do not worry. The solution for the challenge is
    available in the `chapter14/jwtauth` project directory.
  prefs: []
  type: TYPE_NORMAL
- en: Token-based authentication doesn't usually provide a logout API or an API for
    deleting the tokens that are provided in session-based authentication. The server
    gives the authorized resources to the client as long as the JWT hasn't expired.
    Once it expires, the client needs to refresh the token—that is to say, ask the
    server for a new token.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll discuss a few tips for securing an API.
  prefs: []
  type: TYPE_NORMAL
- en: Security aspects of an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every REST API that is developed can be either open or protected. An open API
    has no limit regarding the number of clients requesting the resources. But most
    business APIs are protected. So, what are the important things to keep in mind
    about security? In the following list, we''ll point out all the factors that should
    be taken care of to secure a REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use HTTPS to deliver the API **Transport Layer Security** (**TLS**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limit the API by using user access tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design various authentication and authorization roles on the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use public key/private key encryption to sign a JWT when the client and server
    are internal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never store user credentials in plain files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitize the URL query parameters; use a POST body for incoming requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned in the previous chapter, use an API Gateway for better performance
    and protection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cloud services such as AWS Secrets Manager to store keys/passwords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most modern APIs are run as containers/**Virtual Private Servers** (**VPS**) on
    cloud providers. The security there can be applied at two levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Network level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An API developer who develops and deploys their application on the cloud should
    be aware of the preceding levels. Knowledge of security breach-counteracting measures
    and patching up the API is a key security skill you will need.
  prefs: []
  type: TYPE_NORMAL
- en: Also, an exposed REST API is the easiest victim for attacks such as **Denial
    of Service** (**DoS**) attacks. Deploying an API behind a firewall service can
    increase security from those attacks. In the case of an internal API, where a
    company's service communicates only with other internal services but from different
    geographical regions, a  VPN is desirable.
  prefs: []
  type: TYPE_NORMAL
- en: Security is a beast of its own domain and needs to be carefully monitored in
    every aspect of API development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced the process of authentication. We saw how authentication
    usually works. Authentication can be of three types: basic authentication, session-based,
    or token-based. With basic authentication, every HTTP request supplies a `username`
    and `password`. Session-based authentication uses a saved session to authenticate
    a client.'
  prefs: []
  type: TYPE_NORMAL
- en: Sessions stored in program memory are lost once a web server crashes/restarts.
    Redis can be used with a package called `redistore` to help store session cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned about JWT, a token-based authentication whereby a client requests
    a JWT token from the server. Once the client has the JWT token, it can pass that
    token in the HTTP header while requesting API resources.
  prefs: []
  type: TYPE_NORMAL
- en: We then introduced OAuth 2.0, an authentication framework. There, we saw how
    the client requests a grant from the resource owner. Once it gets the grant, it
    requests an access token from the authentication server. After getting the access
    token from the authentication server, the client can use the token to request
    an API.
  prefs: []
  type: TYPE_NORMAL
- en: We tested all our APIs with curl and Postman. Postman is a great tool that helps
    us test our APIs quickly on any machine, whereas curl is limited to Linux and Mac
    OS X .
  prefs: []
  type: TYPE_NORMAL
- en: We came a long way from the first chapter by learning how to create HTTP routes,
    middleware, and handlers. We then explored various SQL and NoSQL storage backends
    for an API. After the basics, we explored performance-tuning aspects such as asynchronous
    design, the GraphQL API, and microservices. Finally, we learned how to deploy
    our web services to the cloud and also secure them by enabling authentication.
  prefs: []
  type: TYPE_NORMAL
