<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Best Practices for Writing Clean and Maintainable Go Code</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"Any fool can write code that a computer can understand. Good programmers write code that humans can understand."</div>
<div class="packt_quote CDPAlignRight CDPAlign">- Martin Fowler <sup>[8]</sup></div>
<p>Writing clean code that is easy to test and maintain is much harder than it seems at first glance. Fortunately, Go, as a programming language, is quite opinionated and comes with its own set of best practices.</p>
<p>If you take a look at some of the available material for learning Go (for example, Effective Go<span> </span><sup><span class="citation">[6]</span></sup>) or watch some talks by prominent members of the core Go team such as Rob Pike, it becomes evident that software engineers are gently <em>nudged</em> toward applying those principles when working on their own Go projects. From my perspective and experience, these best practices tend to have a measurable positive effect on the code quality metrics associated with a code base and at the same time aid in minimizing the accumulation of technical debt.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the SOLID principles of object-oriented design through the eyes of a Go engineer</li>
<li>Organizing source code at the package level</li>
<li>Helpful tips and tools for writing lean and easy-to-maintain code in Go</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The SOLID principles of object-oriented design</h1>
                </header>
            
            <article>
                
<p>The <strong>SOLID</strong> principles are essentially a set of rules for helping you write clean and maintainable object-oriented code. Let's go over what the initials stand for:</p>
<ul>
<li><strong>Single responsibility</strong></li>
<li><strong>Open/closed</strong></li>
<li><strong>Liskov substitution</strong></li>
<li><strong>Interface segregation</strong></li>
<li><strong>Dependency inversion</strong></li>
</ul>
<p>But hold on a minute! Is Go an object-oriented language or is it a functional programming language with some syntactic sugar tacked on top?</p>
<div class="packt_infobox">Contrary to other, traditional object-oriented programming languages, such as C++ or Java, Go has no built-in support for classes. However, it<span> </span><em>does</em><span> </span>support the concepts of<span> </span><em>interfaces</em> and <em>structs</em>. Structs allow you to define objects as a collection of fields and associated methods. Even though objects and interfaces can be<span> </span><em>composed</em><span> </span>together, there is,<span> </span><em>by design</em>, no support for classic object-oriented inheritance.</div>
<p>With these observations in mind, we should be referring to Go as an<span> </span><em>object-based</em><span> </span>programming language and, as such, the following principles are still valid. Let's take a look at each principle in more detail from the perspective of a Go software engineer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single responsibility</h1>
                </header>
            
            <article>
                
<p>The<span> </span><strong>single responsibility<span> </span>principle</strong> (<strong>SRP</strong>) was described by Robert Martin<span> </span><sup><span class="citation">[23]</span></sup>, a seasoned software engineer who offers, under the nickname of<span> </span><em>Uncle Bob</em>, advice about best practices for software development. The SRP states the following:</p>
<div class="packt_quote">"In any well-designed system, objects should only have a single responsibility."</div>
<p>In a nutshell, object implementations should focus on doing one thing well, and in an efficient way. To understand how this principle works, let's examine a piece of code that<span> </span><em>violates</em><span> </span>it. In the following imaginary scenario, we are working for the ACME drone company where we are using Go to build a drone-based goods delivery system.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following code excerpt illustrates one of our initial attempts at defining a set of methods for the<span> </span><kbd>Drone</kbd><span> </span>type:</p>
<div>
<pre><a>// NavigateTo applies any required changes to the drone's speed </a>
<a>// vector so that its eventual position matches dst.</a>
<a>func (d *Drone) NavigateTo(dst Vec3) error { //... }</a>

<a>// Position returns the current drone position vector.</a>
<a>func (d *Drone) Position() Vec3 { //... }</a>

<a>// Position returns the current drone speed vector.</a>
<a>func (d *Drone) Speed() Vec3 { //... }</a>

<a>// DetectTargets captures an image of the drone's field of view (FoV) using</a>
<a>// the on-board camera and feeds it to a pre-trained SSD MobileNet V1 neural</a>
<a>// network to detect and classify interesting nearby targets. For more info</a>
<a>// on this model see: </a>
<a>// https://github.com/tensorflow/models/tree/master/research/object_detection</a>
<a>func (d *Drone) DetectTargets() ([]*Target, error) { //... }</a></pre></div>
<p>The preceding code violates the SRP by conflating two separate responsibilities:</p>
<ul>
<li>Navigating the drone</li>
<li>Detecting targets in close proximity to the drone</li>
</ul>
<p>As the case may be, this is a valid, working solution. However, the extra coupling that is introduced makes the implementation harder to maintain and extend. For instance, what if we want to evaluate different neural network models for object-recognition purposes? What if we want to use the same object recognition code for different <kbd>Drone</kbd> types?</p>
<p>So, how can we apply the SRP to improve our design? To begin with, while operating under the assumption that all drones come with an on-board camera, we can expose a method on the<span> </span><kbd>Drone</kbd><span> </span>object to capture and return an image using the camera. At this point, you may be thinking: wait, isn't image capturing a<span> </span><em>different </em>responsibility than navigation? The answer is: it's all a matter of perspective! Describing and assigning responsibilities to objects is an art in itself, and quite a subjective one. Conversely, we could counter-argue that navigation needs access to various sources of sensor data, and the camera is one of them. In that sense, the proposed refactoring is<span> </span><em>not</em><span> </span>violating the SRP.</p>
<p class="mce-root"/>
<p>In a second refactoring step, we can extract the target detection code into a separate, standalone object that would allow us to move on with the object-recognition model evaluation without having to modify any of the<span> code in the </span><kbd>Drone</kbd><span> type</span>. The second iteration of the implementation might look something like this:</p>
<div class="sourceCode">
<pre><a><span class="co">// NavigateTo applies any required changes to the drone's speed vector </span></a>
<a><span class="co">// so that its eventual position matches dst.</span></a>
<a><span class="kw">func</span> (d *Drone) NavigateTo(dst Vec3) <span class="dt">error</span> { <span class="co">//... }</span></a>

<a><span class="co">// Position returns the current drone position vector.</span></a>
<a><span class="kw">func</span> (d *Drone) Position() Vec3 { <span class="co">//... }</span></a>

<a><span class="co">// Position returns the current drone speed vector.</span></a>
<a><span class="kw">func</span> (d *Drone) Speed() Vec3 { <span class="co">//... }</span></a>

<a><span class="co">// CaptureImage records and returns an image of the drone's field of </span></a>
<a><span class="co">// view using the on-board drone camera.</span></a>
<a><span class="kw">func</span> (d *Drone) CaptureImage() (*image.RGBA, <span class="dt">error</span>) { <span class="co">//... }</span></a></pre></div>
<p>In a separate file (possibly in a different package too), we would define the <kbd>MobileNet</kbd> type, which contains the implementation for our target detector:</p>
<div class="sourceCode">
<pre><a><span class="co">// MobileNet performs target detection for drones using the </span></a>
<a><span class="co">// SSD MobileNet V1 NN.</span></a>
<a><span class="co">// For more info on this model see:</span></a>
<a><span class="co">// https://github.com/tensorflow/models/tree/master/research/object_detection</span></a>
<a><span class="kw">type</span> MobileNet {</a>
<a>    <span class="co">// various attributes...</span></a>
<a>}</a>

<a><span class="co">// DetectTargets captures an image of the drone's field of view and feeds</span></a>
<a><span class="co">// it to a neural network to detect and classify interesting nearby <br/>// targets.</span></a>
<a><span class="kw">func</span> (mn *MobileNet) DetectTargets(d *drone.Drone) ([]*Target, <span class="dt">error</span>){</a>
<a>    <span class="co">//...</span></a>
<a>}</a></pre></div>
<p>Success! We have split our original implementation into two separate objects, with each one having a single responsibility.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Open/closed principle</h1>
                </header>
            
            <article>
                
<p>The<span> </span><strong>open/closed</strong><span> </span>principle was coined by Bertrand Meyer<span> </span><sup><span class="citation">[24]</span></sup>, who stated the following:</p>
<div class="packt_quote">"A software module should be open for extension but closed for modification."</div>
<p>Almost all Go programs import and use types from a host of other packages, some being part of the Go standard library whereas other packages are provided by third parties. <span>Any software engineer that imports a package into their code base should always safely assume that all the types that are exported by said package adhere to a contract that is guaranteed to be immutable</span>. In other words, a package should not be able to modify the behavior of the types that are exported by<span> </span><em>other</em><span> </span>packages. While some programming languages allow this type of modification (via a technique colloquially referred to as<span> </span><em>monkey patching</em>), the Go designers put safety mechanisms in place to ensure that this type of modification is strictly forbidden. Otherwise, Go programs would be able to violate the<span> </span><strong>closed</strong><span> </span>principle with unforeseen consequences for code that's deployed to production.</p>
<p>At this point, you may be wondering: does the closed principle also apply to code confined<span> </span><em>within</em><span> </span>the scope of a package? Additionally, how does Go implement the<span> </span><strong>open</strong><span> </span>principle? By Meyer's definition, we should be able to use object-oriented principles such as inheritance or composition to extend existing code with additional functionality without having to modify the original code units. As we discussed at the beginning of the chapter, Go does not support inheritance; that leaves<span> </span><em>composition</em><span> </span>as the only viable approach for extending existing code.</p>
<p>Let's examine how these principles are intertwined through a simple example. After a brief stint in drone design, we decided to switch industries and focus on building role-playing games instead. In the following code, you can see the definition of a generic <kbd>Sword</kbd> type for our upcoming game:</p>
<div class="sourceCode">
<pre><a><span class="kw">type</span> Sword <span class="kw">struct</span> {</a>
<a>    name <span class="dt">string</span> <span class="co">// Important tip for RPG players: always name your swords!</span></a>
<a>}</a>
<a><span class="co">// Damage returns the damage dealt by this sword.</span></a>
<a><span class="kw">func</span> (Sword) Damage() <span class="dt">int</span> {</a>
<a>    <span class="kw">return</span> <span class="dv">2</span></a>
<a>}</a>

<a><span class="co">// String implements fmt.Stringer for the Sword type.</span></a>
<a><span class="kw">func</span> (s Sword) String() <span class="dt">string</span> {</a>
<a>    <span class="kw">return</span> fmt.Sprintf(</a>
<a>        <span class="st">"%s is a sword that can deal %d points of damage to opponents"</span>,</a>
<a>        s.name, s.Damage(),</a>
<a>    )</a>
<a>}</a></pre></div>
<p>One of our design requirements states that we need to support magic items, for example, an enchanted sword. Since our enchanted sword is merely a generic sword that deals a different amount of damage, we will apply the<span> </span><strong>open </strong>principle and use<span> </span><em>composition</em><span> </span>to create a new type that embeds the<span> </span><kbd>Sword</kbd><span> </span>type and overrides the implementation of the<span> </span><kbd>Damage</kbd><span> </span>method:</p>
<div class="sourceCode">
<pre><a><span class="kw">type</span> EnchantedSword <span class="kw">struct</span> {</a>
<a>    <span class="co">// Embed the Sword type</span></a>
<a>    Sword</a>
<a>}</a>

<a><span class="co">// Damage returns the damage dealt by the enchanted sword.</span></a>
<a><span class="kw">func</span> (EnchantedSword) Damage() <span class="dt">int</span> {</a>
<a>    <span class="kw">return</span> <span class="dv">42</span></a>
<a>}</a></pre></div>
<div class="sourceCode">
<p>However, our implementation could not be complete without writing a few table-driven tests! The first test function that we will be creating is called<span> </span><kbd>TestSwordDamage</kbd><span> </span>and its purpose, as you can probably guess by its name, is to check whether calling<span> </span><kbd>Damage</kbd><span> </span>on the types we've defined so far produces the expected result. Here is how we would go about defining our expectations in a table-driven manner:</p>
<div class="sourceCode">
<pre><a>specs := []<span class="kw">struct</span> {</a>
<a>    sword <span class="kw">interface</span> {</a>
<a>        Damage() <span class="dt">int</span></a>
<a>    }</a>
<a>    exp <span class="dt">int</span></a>
<a>}{</a>
<a>    {</a>
<a>        sword: Sword{name: <span class="st">"Silver Saber"</span>},</a>
<a>        exp:   <span class="dv">2</span>,</a>
<a>    }, </a>
<a>    {</a>
<a>        sword: EnchantedSword{Sword{name: <span class="st">"Dragon's Greatsword"</span>}},</a>
<a>        exp:   <span class="dv">42</span>,</a>
<a>    },</a>
<a>}</a></pre></div>
<p>The implementation of<span> </span><kbd>TestSwordDamage</kbd><span> </span>just iterates over the defined expectations and verifies that each one is met:</p>
<div class="sourceCode">
<pre><a><span class="kw">func</span> TestSwordDamage(t *testing.T) {</a>
<a>    specs := ... <span class="co">// see above code snippet for the spec definitions</span></a>

<a>    <span class="kw">for</span> specIndex, spec := <span class="kw">range</span> specs {</a>
<a>        <span class="kw">if</span> got := spec.sword.Damage(); got != spec.exp {</a>
<a>            t.Errorf(<span class="st">"[spec %d] expected to get damage %d; got %d"</span>, specIndex, spec.exp, got)</a>
<a>        }</a>
<a>    }</a>
<a>}</a></pre></div>
<p>Our second test comes with its own list of expectations. This time, the goal is to make sure that the output of the<span> </span><kbd>String</kbd><span> </span>methods for the types we defined previously produces the correct output:</p>
<div class="sourceCode">
<pre><a>specs := []<span class="kw">struct</span> {</a>
<a>    sword fmt.Stringer</a>
<a>    exp   <span class="dt">string</span></a>
<a>}{</a>
<a>    {</a>
<a>        sword: Sword{name: <span class="st">"Silver Saber"</span>},</a>
<a>        exp:   <span class="st">"Silver Saber is a sword that can deal 2 points of damage to opponents"</span>,</a>
<a>    }, </a>
<a>    {</a>
<a>        sword: EnchantedSword{Sword{name: <span class="st">"Dragon's Greatsword"</span>}},</a>
<a>        exp:   <span class="st">"Dragon's Greatsword is a sword that can deal 42 points of <br/>         damage to opponents"</span>,</a>
<a>    },</a>
<a>}</a></pre></div>
<p>Here is the implementation of<span> </span><kbd>TestSwordToString</kbd><span>, </span>which looks more or less the same as <kbd>TestSwordDamage</kbd>; no surprises here:</p>
<div class="sourceCode">
<pre><a><span class="kw">func</span> TestSwordToString(t *testing.T) {</a>
<a>    specs := ... <span class="co">// see above code snippet for the spec definitions</span></a>

<a>    <span class="kw">for</span> specIndex, spec := <span class="kw">range</span> specs {</a>
<a>        <span class="kw">if</span> got := spec.sword.String(); got != spec.exp {</a>
<a>            t.Errorf(<span class="st">"[spec %d] expected to get</span><span class="ch">\n</span><span class="st">%q</span><span class="ch">\n</span><span class="st">got:</span><span class="ch">\n</span><span class="st">%q"</span>, <br/>             specIndex, spec.exp, got)</a>
<a>        }</a>
<a>    }</a>
<a>}</a></pre></div>
</div>
<p>Now, we can run <kbd>go test</kbd><span>. However,</span><span> one of our tests fails:</span></p>
<pre class="console">$ go test -v
=== RUN   TestSwordDamage
--- PASS: TestSwordDamage (0.00s)
=== RUN   TestSwordToString
--- FAIL: TestSwordToString (0.00s)
        sword_test.go:55: [spec 1] expected to get
                "Dragon's Greatsword is a sword that can deal 42 points of<br/>                 damage to opponents"
                got:
                "Dragon's Greatsword is a sword that can deal 2 points of <br/>                  damage to opponents"</pre>
<p>So, what caused the second test to fail? To uncover the reason behind the failed test, we need to dig a bit deeper into how Go methods work under the hood. Go methods are nothing more than syntactic sugar for invoking a<span> </span><em>function</em><span> </span>with an object instance as an argument (also known as a receiver). In the preceding code snippet,<span> </span><kbd>String</kbd><span> </span>is always invoked with a<span> </span><kbd>Sword</kbd><span> </span>receiver and as a result, the call to the<span> </span><kbd>Damage</kbd><span> </span>method<span> </span><em>always</em><strong> </strong>gets dispatched to the implementation that's been defined by<span> </span><kbd>Sword</kbd><span> </span>type.</p>
<p>This is a prime example of the<span> </span><strong>closed</strong><span> </span>principle in action:<span> </span><kbd>Sword</kbd><span> </span>is<span> </span><em>not aware of</em><span> </span>any type that may embed it and its set of methods<span> </span><em>cannot be altered</em><span> </span>by objects it is embedded into. It is important to point out that while the<span> </span><kbd>EnchantedSword</kbd><span> </span>type cannot modify the implementation of the methods that have been defined on the embedded<span> </span><kbd>Sword</kbd><span> </span>instance, it can still<span> </span><em>access</em><span> </span>and<span> </span><em>mutate</em><span> </span>any fields defined by it (including private ones if both types are defined in the same package).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Liskov substitution</h1>
                </header>
            
            <article>
                
<p>The third principle from SOLID that we will be exploring is the<span> </span><strong>Liskov substitution principle</strong><span> </span>(<strong>LSP</strong>). It was introduced by Barbara Liskov in 1987 while delivering a keynote session at the <strong>Object-Oriented Programming Systems, Languages, and Applications</strong> (<strong>OOPSLA</strong>) conference<span> </span><sup><span class="citation">[22]</span></sup>. The formal definition of LSP is as follows:</p>
<div class="packt_quote">If, for each object, <kbd>O1</kbd> of type <kbd>S</kbd> there is an object <kbd>O2</kbd> of type <kbd>T</kbd> such that for all programs <kbd>P</kbd> defined in terms of <kbd>T</kbd>, the behavior of <kbd>P</kbd> is unchanged when <kbd>O1</kbd> is substituted for <kbd>O2</kbd>, then <kbd>S</kbd> is a subtype of <kbd>T</kbd>.</div>
<p>In layman's terms, two types are<span> </span><em>substitutable</em><span> </span>if their exhibited behavior follows exactly the same contract, thereby making it<span> </span><em>impossible</em><span> </span>for<span> </span><em>callers</em><span> </span>to distinguish between them. Thinking in pure OO terms, this is probably the textbook use case for abstract and concrete classes. As we mentioned in a previous section, Go does not support the concept of classes or inheritance but instead relies on<span> </span><em>interfaces</em><span> </span>as the means for facilitating type substitutions.</p>
<p>One interesting peculiarity of Go, at least for people coming from a Java or C++ background, is that Go interfaces are<span> </span><em>implicit</em>. Each Go type defines an implicit interface consisting of all the methods it implements. This design decision allows the Go compiler to perform a<span> </span><em>compile-time</em><span> </span>variant of<span> </span><strong>duck typing</strong><span> </span>(the formal term for this is<span> </span><strong>structural typing</strong>) when deciding whether an object instance can be passed as a substitute to a function or method that expects a particular interface as its argument.</p>
<p class="mce-root"/>
<p>The term duck typing has its roots in an old adage referred to as the<span> </span><em>duck test</em>:</p>
<div class="packt_quote">"If it looks like a duck and it quacks like a duck, then it is a duck."</div>
<p>Essentially, when given an object and an interface, the object can be used in place of the interface<span> </span><em>if</em><span> </span>its method set contains methods whose name and signature match the ones defined by the interface. Not having to explicitly indicate which interfaces a type implements is quite a handy feature. It helps us decouple the definition of an object (which may be an external or third-party package) from the place where the interface is defined and/or used.</p>
<p>In the following code snippet, we're defining the<span> </span><kbd>Adder</kbd><span> </span>interface and a simple function called<span> </span><kbd>PrintSum</kbd><span> </span>that uses any type that satisfies this interface to add two numbers together:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> main</a>

<a><span class="kw">import</span> <span class="st">"fmt"</span></a>

<a><span class="co">// Adder is implemented by objects that can add two integers together.</span></a>
<a><span class="kw">type</span> Adder <span class="kw">interface</span> {</a>
<a>    Add(<span class="dt">int</span>, <span class="dt">int</span>) <span class="dt">int</span></a>
<a>}</a>

<a><span class="kw">func</span> PrintSum(a, b <span class="dt">int</span>, adder Adder) {</a>
<a>    fmt.Printf(<span class="st">"%d + %d = %d"</span>, a, b, adder.Add(a, b))</a>
<a>}</a></pre></div>
<p>The<span> </span><kbd>adder</kbd><span> </span>package includes the<span> </span><kbd>Int</kbd><span> </span>type, which satisfies the<span> </span><kbd>Adder</kbd><span> </span>interface, and another type called<span> </span><kbd>Double</kbd>, which doesn't; even though it defines a function called<span> </span><kbd>Add</kbd><span>, you will notice that </span>the argument <em>types</em> are different:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> adder</a>

<a><span class="co">// Int adds two integer values.</span></a>
<a><span class="kw">type</span> Int <span class="kw">struct</span>{}</a>

<a><span class="co">// Add returns the sum a+b.</span></a>
<a><span class="kw">func</span> (Int) Add(a, b <span class="dt">int</span>) <span class="dt">int</span> { <span class="kw">return</span> a + b }</a>

<a><span class="co">// Double adds two double values.</span></a>
<a><span class="kw">type</span> Double <span class="kw">struct</span>{}</a>

<a><span class="co">// Add returns the sum a+b.</span></a>
<a><span class="kw">func</span> (Double) Add(a, b <span class="dt">float64</span>) <span class="dt">float64</span> { <span class="kw">return</span> a + b }</a></pre></div>
<p class="mce-root"/>
<p class="mce-root">The following code snippet illustrates how compile-time interface substitution checks work. We can safely pass<span> </span><kbd>Int</kbd><span> </span>instances to<span> </span><kbd>PrintSum</kbd><span> </span>as <kbd>Int</kbd><span> </span>implicitly satisfies the<span> </span><kbd>Adder</kbd><span> </span>interface. However, attempting to pass an instance of<span> </span><kbd>Double</kbd><span> </span>to<span> </span><kbd>PrintSum</kbd><span> </span>will trigger a compile-time error:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> main</a>

<a><span class="kw">import</span> <span class="st">"github.com/foo/adder"</span></a>

<a><span class="kw">func</span> main() {</a>
<a>    PrintSum(<span class="dv">1</span>, <span class="dv">2</span>, adder.Int{}) <span class="co">// prints: "1 + 2 = 3"</span></a>

<a>    <span class="co">// This line will trigger a compile-time error:</span></a>
<strong><a>    <span class="co">//  cannot use adder.Double literal (type adder.Double) as type Adder </span></a>
<a>    <span class="co">//  in argument to PrintSum: adder.Double does not implement Adder </span></a>
<a>    <span class="co">//  (wrong type for Add method) </span></a>
<a>    <span class="co">//      have Add(float64, float64) float64</span></a>
<a>    <span class="co">//      want Add(int, int) int</span></a></strong>
<a>    PrintSum(<span class="dv">1</span>, <span class="dv">2</span>, adder.Double{})</a>
<a>}</a></pre></div>
<p>In the cases where the type of the object to be substituted is not known at compile time, the compiler will automatically generate code to perform the check at runtime:</p>
<div class="sourceCode">
<pre><a><span class="kw">var</span> placeholder <span class="kw">interface</span>{}</a>

<a><span class="co">// Cast to io.Reader works; os.Stdin implements io.Reader</span></a>
<a>placeholder = os.Stdin</a>
<a>_ = placeholder.(io.Reader)</a>

<a><span class="co">// Cast to io.Reader triggers a run-time panic:</span></a>
<strong><a><span class="co">// "panic: interface conversion: string is not io.Reader: missing method Read"</span></a></strong>
<a>placeholder = <span class="st">"cast check"</span></a>
<a>_ = placeholder.(io.Reader)</a>

<a><span class="co">// Cast to io.Reader fails and isReader is set to false</span></a>
<a>placeholder = <span class="st">"cast check"</span></a>
<a><span class="kw">if</span> _, isReader := placeholder.(io.Reader); !isReader {</a>
<a>    fmt.Printf(<span class="st">"%T does not implement io.Reader</span><span class="ch">\n</span><span class="st">"</span>, placeholder)</a>
<a>}</a></pre></div>
<div class="packt_tip">When you aren't sure whether a type instance or an<span> </span><kbd>interface{}</kbd><span> </span>can be cast to another type or interface at runtime, it is often good practice to use the dual return value variant of the cast operator (the <em>last</em> case in the preceding code sample) to avoid potential panics while your program is executing.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interface segregation</h1>
                </header>
            
            <article>
                
<p>Similar to the SRP, the <strong>interface segregation principle</strong> (<strong>ISP</strong>) was also coined by Robert Martin. According to this principle, clients should not be forced to depend upon the interfaces that they do not use.</p>
<p>This principle is quite important as it forms the basis for applying the other principles we've discussed so far. Going back to our previous RPG example, let's assume that we have augmented our<span> </span><kbd>Sword</kbd><span> </span>object with a few more interesting methods:</p>
<div class="sourceCode">
<pre><a><span class="co">// Sharpen increases the damage dealt by this sword using a whetstone.</span></a>
<a><span class="kw">func</span> (Sword) Sharpen() {</a>
<a>    <span class="co">//...</span></a>
<a>}</a>

<a><span class="co">// MakeBlunt decreases the damage dealt by this sword due to constant use.</span></a>
<a><span class="kw">func</span> (Sword) MakeBlunt(){</a>
<a>    <span class="co">//...</span></a>
<a>}</a>

<a><span class="co">// Drop places the sword on the ground allowing others to pick it up.</span></a>
<a><span class="kw">func</span> (Sword) Drop(){</a>
<a>    <span class="co">//...</span></a>
<a>}</a></pre></div>
<p>So, how are we going to use weapons in our game? Obviously, we need to introduce some<span> </span><em>monsters</em><span> </span>for the player to attack! This is what the signature of an<span> </span><kbd>Attack</kbd><span> </span>function<span> </span>could<span> </span>potentially look like:</p>
<div class="sourceCode">
<pre><a><span class="co">// Attack deals damage to a monster using a sword.</span></a>
<a><span class="kw">func</span> Attack(m *Monster, s *Sword) {</a>
<a>    <span class="co">//...</span></a>
<a>}</a></pre></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>However, there are a few issues with the preceding definition.</p>
<p>The<span> </span><em>implicit</em><span> </span>(see the previous section)<span> </span><kbd>Sword</kbd><span> </span>interface is quite<span> </span><em>open</em>, that is, it includes a bunch of other methods that our<span> </span><kbd>Attack</kbd><span> </span>implementation has no need for. In fact, the software engineer implementing<span> </span><kbd>Attack</kbd><span> </span>may be tempted to include additional<span> </span><em>business logic</em><span> </span>rules that rely on the availability of those methods:</p>
<ul>
<li>Make the sword blunt after a number of attacks</li>
<li>Cause the player to drop the sword if the monster uses some special armor</li>
</ul>
<p>Going down this path would lead to a violation of the SRP and potentially make unit testing of the code harder. In addition, the proposed definition of <kbd>Attack</kbd> induces a strong coupling with objects that either <span>are </span>of the <kbd>Sword</kbd> type or are other types that <em>embed</em> it.</p>
<p>These two observations fully justify the existence of a famous Go proverb that was originally attributed to Rob Pike:</p>
<div class="packt_quote">"The bigger the interface, the weaker the abstraction."</div>
<p>While Go implicit interfaces (see the previous section) would allow us to pass<span> </span><em>any</em><span> </span>type that embeds<span> </span><kbd>Sword</kbd><span> </span>(perhaps an<span> </span><kbd>EnchantedSword</kbd><span> </span>from our previous example), our requirements will undoubtedly state that<span> </span><kbd>Attack</kbd><span> </span>must be able to work with other types of weapons, for example, projectiles or magic spells.</p>
<p>On the other hand,<span> </span><kbd>Attack</kbd><span> </span>expects a<span> </span><kbd>Monster</kbd><span> </span>instance as its first argument. It stands to reason that the player should be able to use weapons to deal damage to non-monster entities, for example, to break down a bolted door or to cut the rope suspending the chandelier from the ceiling. Moreover, ideally, we would want to reuse the same implementation when monsters attack the player.</p>
<p>These are all great use cases for applying the ISP. Let's assume that our<span> </span><kbd>Attack</kbd><span> </span>implementation only needs the following:</p>
<ul>
<li>To figure out the amount of damage that's caused by a weapon</li>
<li>Some mechanism to apply the damage to a particular<span> </span><em>target</em></li>
</ul>
<p>With the preceding observations, we could change the signature of<span> </span><kbd>Attack</kbd><span> </span>to accept two explicit interfaces as arguments:</p>
<div class="sourceCode">
<pre><a><span class="co">// DamageReceiver is implemented by objects that can receive weapon damage.</span></a>
<a><span class="kw">type</span> DamageReceiver <span class="kw">interface</span> {</a>
<a>    ApplyDamage(<span class="dt">int</span>)</a>
<a>}</a>

<a><span class="co">// Damager is implemented by objects that can be used as weapons.</span></a>
<a><span class="kw">type</span> Damager <span class="kw">interface</span> {</a>
<a>    Damage(<span class="dt">int</span>)</a>
<a>}</a>

<a><span class="co">// Attack deals weapon damage to target.</span></a>
<a><span class="kw">func</span> Attack(target DamageReceiver, weapon Damager) {</a>
<a>    <span class="co">//...</span></a>
<a>}</a></pre></div>
<p>With this rather simple change, we kill two birds with one stone. Firstly, our code is more abstract and it's much easier to test its behavior by providing our own test types that implement the required interfaces. Secondly, our interfaces are, quite literally, the smallest possible; this fact not only makes the SRP application possible but it also alludes to a simpler implementation. As evidenced by a quick scan of the Go standard library, single-method interfaces (for example, <kbd>Reader</kbd> and <kbd>Writer</kbd> interfaces in the<span> </span><kbd>io</kbd><span> </span>package) are a rather prevailing idiom between the Go authors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency inversion</h1>
                </header>
            
            <article>
                
<p>Yet another principle identified by Robert Martin is the<span> </span><strong>dependency inversion<span> </span>principle</strong> (<strong>DIP</strong>). It is, slightly verbosely, defined as follows:</p>
<div class="packt_quote">"High-level modules should not depend on low-level modules. Both should depend on abstractions. <span>Abstractions should not depend on details. Details should depend on abstractions."</span></div>
<p>The DIP essentially summarizes all the other principles we've discussed so far. If you have been applying the rest of the SOLID principles to your code base, you will find that it already adheres to the preceding definition!</p>
<p>The introduction and use of interfaces aids in decoupling high-level and low-level modules. The open/closed principle ensures that interfaces themselves are immutable but does not preclude us from coming up with any number of alternative implementations (the <em>details</em> bit in the preceding definition) that satisfy an implicit or explicit interface. At the same time, the LSP guarantees that we can rely on the established abstractions while also having the flexibility to swap the underlying implementation at compile time or even runtime without worrying about breaking our applications.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying the SOLID principles</h1>
                </header>
            
            <article>
                
<p>If you decide to apply these principles to your own projects, you will achieve greater flexibility in the way you design, connect to, and test software components, with the added benefit of requiring less time to extend the code base in the future.</p>
<p>However, one thing to keep in mind is that there is<span> </span><em>no such thing as a free lunch</em>. What you gain in flexibility, you lose in the increased size of your code base; this could adversely affect the complexity metrics associated with the project.</p>
<p>In my view, this trade-off is not necessarily a bad thing. By following the best practices around testing your code (a subject that will be explored in detail in upcoming chapters), you can tame any potential increase in code complexity. At the same time, encountering difficulties while writing tests is often a good sign that your code is probably violating one or more of the SOLID principles and needs refactoring.</p>
<p>Finally, I would like to stress that even though we analyzed the SOLID principles through the eyes of a Go engineer, the principles themselves have a much wider scope and can also be applied to system design in general. For instance, in a microservice-based deployment, you should be aiming to build and deploy services with a single purpose (SRP) that communicate through clearly defined contracts and boundaries (ISP).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizing code into packages</h1>
                </header>
            
            <article>
                
<p>As we saw in the previous section, the application of the SOLID principles works as a guide for splitting our code base into smaller packages where each package implements a specific bit of functionality <span>and its interfaces serve as the glue for wiring packages together when building larger systems.</span></p>
<p>In this section, we will be examining the idiomatic Go way for naming packages, as well as some common potential pitfalls you may encounter while authoring code that relies on a complex package dependency graph.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Naming conventions for Go packages</h1>
                </header>
            
            <article>
                
<p>Let's say you come across a package named<span> </span><kbd>server</kbd>. Is that a good name, as per the preceding suggestion? Well,<span> </span><em>obviously</em><span>, </span>we can guess that it's some<span> </span><em>kind</em><span> </span>of server, but what kind is that? Is it an HTTP server, for instance, a TCP-based server implementing a text-based wire protocol, or maybe a UDP-based server for an online game? Some of you may argue that the package might export a type or function that alludes to the package's purpose (for example,<span> </span><kbd>NewHTTPServer</kbd>). That certainly disambiguates things, but it also introduces a bit of repetition: in this particular case, the<span> </span><em>server</em><span> </span>literal is present in both the package name and a function exposed by it. As we will see in the <em>Improving code quality metrics with the help of linters</em> section, this practice is considered an anti-pattern and may cause linter warnings.</p>
<div class="packt_tip">Go<span> package names should be short and concise and provide a clear indication of their purpose to the</span><span> </span><em>intended</em><span> </span><span>users of the package.</span></div>
<p>By browsing the code of the Go standard library, we can find quite a few characteristic examples of this clear package-naming philosophy:</p>
<ul>
<li>The<span> </span><kbd>net</kbd><span> </span>package provides mechanisms for creating various types of network listeners (tcp, udp, Unix domain sockets, and more).</li>
<li>The<span> </span><kbd>net/http</kbd><span> </span>package provides, among other things, an HTTP server implementation: the<span> </span><kbd>http.Server</kbd><span> </span>type name is pretty unambiguous with respect to its use.</li>
</ul>
<p>While package names should be kept short, you should avoid coming up with package names that can potentially clash with variable names that are commonly used by the code importing the package. Otherwise, package users would have to import the package using an<span> </span><em>alias</em><span> </span>(that is, import <em>blah</em> path-to-package). In such cases, it is usually better to abbreviate the package name (if possible). Typical examples from the Go standard library include the<span> </span><kbd>fmt</kbd><span> </span>and<span> </span><kbd>bufio</kbd><span> </span>packages. More specifically, the<span> </span><kbd>bufio</kbd><span> </span>package is named as such to avoid name clashes with<span> </span><kbd>buf</kbd>, a variable name you are very likely to encounter when dealing with a piece of code that uses buffers.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, in contrast to other programming languages whose standard libraries usually come with utility libraries or packages with generic-sounding names such as <em>common</em><span> </span>or<span> </span><em>util</em>, Go is quite opinionated<span> </span><em>against</em><span> </span>this practice. This is actually justified from the SOLID principles' point of view as those packages are more likely to be violating the SRP versus aptly named packages whose name enforces a logical boundary for their contents. <span>To add to this, as the number of published Go packages grows over time, searching for and locating packages with generic-sounding names will become more and more difficult</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Circular dependencies</h1>
                </header>
            
            <article>
                
<p>For a Go program to be well formed, its import graph must be acyclic; in other words, it must not contain any loops. Any violation of this predicate will cause the Go compiler to emit an error. As the systems you are building grow in complexity, so does the probability of eventually hitting the dreaded<span> </span><em>import cycle detected</em><strong> </strong>error.</p>
<p>Usually, import cycles are an indication of a fault in the design of a software solution. Fortunately, in many cases, we can refactor our code and work around most import cycles. Let's take a closer look at some common cases where circular dependencies occur and some strategies for dealing with them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking circular dependencies via implicit interfaces</h1>
                </header>
            
            <article>
                
<p>In the following imaginary scenario, we are working for a start-up company that is building the software that's responsible for controlling fully automated warehouses. Autonomous robots equipped with gripping arms and lasers (what could possibly go wrong?) are busy moving around the warehouse floor locating and picking up order items from the shelves and placing them in cardboard boxes that are then shipped to the customers.</p>
<p>This is a tentative definition for a warehouse<span> </span><kbd>Robot</kbd>:</p>
<div class="sourceCode">
<div class="sourceCode">
<pre><a><span class="kw">package</span> warehouse</a>

<a><span class="kw">import</span> <span class="st">"context"</span></a>

<a><span class="co">// Robot navigates the warehouse floor and fetches items for packing.</span></a>
<a><span class="kw">type</span> Robot <span class="kw">struct</span> {</a>
<a>    <span class="co">// various fields</span></a>
<a>}</a>

<a><span class="co">// AcquireRobot blocks until a Robot becomes available or until the <br/>// context expires.</span></a>
<a><span class="kw">func</span> AcquireRobot(ctx context.Context) *Robot { <span class="co">//...  }</span></a>

<a><span class="co">// Pack instructs the robot to pick up an item from its shelf and place </span></a>
<a><span class="co">// it into a box that will be shipped to the customer.</span></a>
<a><span class="kw">func</span> (r *Robot) Pack(item *entity.Item, to *entity.Box) <span class="dt">error</span> { <span class="co">//...  }</span></a></pre></div>
</div>
<p>In the preceding code snippet, the<span> </span><kbd>Item</kbd><span> </span>and<span> </span><kbd>Box</kbd><span> types </span>live in an external package called<span> </span><kbd>entity</kbd>. All goes well until one day when someone attempts to introduce a new helper method to the<span> </span><kbd>Box</kbd><span> </span>type, which, unfortunately, introduces an import cycle:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> entity</a>

<a><span class="co">// Box contains a list of items that are shipped to the customer.</span></a>
<a><span class="kw">type</span> Box <span class="kw">struct</span> {</a>
<a>    <span class="co">// various fields</span></a>
<a>}</a>

<a><span class="co">// Pack qty items of type i into the box.</span></a>
<a><span class="kw">func</span> (b *Box) Pack(i *Item, qty <span class="dt">int</span>) <span class="dt">error</span> {</a>
<a>    robot := warehouse.Acquire() <span class="co">// <strong>compile error: import cycle detected</strong></span></a>
<a>    <span class="co">// ...</span></a>
<a>}</a></pre></div>
<p>Technically speaking, this is a bad design decision: boxes and items should not really be aware of the robot's existence. However, for the sake of this argument, we will ignore this design flaw and try to work around this problem using Go's support for implicit interfaces. The first step would be to define a<span> </span><kbd>Packer</kbd><span> </span>interface within the<span> </span><kbd>entity</kbd><span> </span>package. Secondly, we would need to provide an abstraction for obtaining an instance of<span> </span><kbd>Packer</kbd>, as shown in the following code snippet:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> entity </a>

<a><span class="kw">import</span> <span class="st">"context"</span></a>

<a><span class="co">// Packer is implemented by objects that can pack an Item into a Box.</span></a>
<a><span class="kw">type</span> Packer <span class="kw">interface</span> {</a>
<a>    Pack(*Item, *Box) <span class="dt">error</span></a>
<a>}</a>

<a><span class="co">// AcquirePacker returns a Packer instance.</span></a>
<a><span class="kw">var</span> AcquirePacker <span class="kw">func</span>(context.Context) Packer</a></pre></div>
<p>With these two mechanisms in place, the helper method can work<span> </span><em>without</em><span> </span>the need to import the<span> </span><kbd>warehouse</kbd><span> </span>package:</p>
<div class="sourceCode">
<pre><a><span class="co">// Pack qty items of type i into the box.</span></a>
<a><span class="kw">func</span> (b *Box) Pack(i *Item, qty <span class="dt">int</span>) <span class="dt">error</span> {</a>
<a>    p := AcquirePacker(context.Background())</a>
<a>    <span class="kw">for</span> j := <span class="dv">0</span>; j &lt; qty; j++ {</a>
<a>        <span class="kw">if</span> err := p.Pack(i, b); err != <span class="ot">nil</span> {</a>
<a>            <span class="kw">return</span> err </a>
<a>        }</a>
<a>    }</a>
<a>    <span class="kw">return</span> <span class="ot">nil</span></a>
<a>}</a></pre></div>
<p>The last bit of the puzzle that we need to address is how we are going to initialize<span> </span><kbd>AcquirePacker</kbd><span> </span>without importing the<span> </span><kbd>warehouse</kbd><span> </span>package. The only way we can do that is via a <em>third</em> package that imports the<span> </span><kbd>warehouse</kbd><span> </span>and <kbd>entity</kbd><span> </span>packages:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> main</a>

<a><span class="kw">import</span> <span class="st">"github.com/achilleasa/logistics/entity"</span></a>
<a><span class="kw">import</span> <span class="st">"github.com/achilleasa/logistics/warehouse"</span></a>

<a><span class="kw">func</span> wireComponents() {</a>
<a>    entity.AcquirePacker = <span class="kw">func</span>(ctx context.Context) entity.Packer {</a>
<a>        <span class="kw">return</span> warehouse.AcquireRobot(ctx)</a>
<a>    }</a>
<a>}</a></pre></div>
<p>In the preceding code snippet, the<span> </span><kbd>wireComponents</kbd><span> </span>function ensures that the<span> </span><kbd>warehouse</kbd><span> </span>and <kbd>entity</kbd><span> </span>packages are wired together without triggering any circular dependency errors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sometimes, code repetition is not a bad idea!</h1>
                </header>
            
            <article>
                
<p>You have probably heard of the<span> </span><strong>don't repeat yourself</strong><span> </span>(<strong>DRY</strong>) principle before. The main idea behind DRY is to avoid code repetition by aiming to write reusable code that can be included where required. But is DRY<span> </span><em>always</em><span> </span>a good idea?</p>
<p>Go packages serve as a nice abstraction for organizing code into modular, reusable units. But, generally speaking, a good practice for writing Go programs is to try to keep your import dependency graph shallow and wide; this sounds counter-intuitive considering it's probably the exact opposite of what the DRY principle advocates:<span> </span><em>include instead of repeat</em>.</p>
<p>When the dependency graph becomes deeper, circular dependencies become more likely, this time due to<span> </span><em>transitive</em><span> </span>dependencies, that is, dependencies of packages that your code imports. In the following example, we have three packages:<span> </span><kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd>.</p>
<p class="mce-root"/>
<p>Package<span> </span><em>y</em><span> </span>defines a helper function called<span> </span><kbd>IsPrime</kbd><span>, </span>which, as you can probably guess by its name, returns a Boolean indicating whether its input is a prime number or not. The same package imports and uses some types from package <kbd><em>z</em></kbd>:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> y</a>

<a><span class="kw">import</span> <span class="st">"z"</span></a>

<a><span class="kw">func</span> IsPrime(v <span class="dt">uint64</span>) <span class="dt">bool</span> {</a>
<a>    <span class="co">// ... </span></a>
<a>}</a>

<a><span class="co">// Other functions referencing types exported from package z</span></a></pre></div>
<p>Package<span> </span><kbd>z</kbd><span> </span>imports some types from package<span> </span><kbd>x</kbd>:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> z</a>

<a><span class="kw">import</span> <span class="st">"x"</span></a>

<a><span class="co">// functions referencing types exported from package x</span></a></pre></div>
<p>So far, so good. A few days go by and then we decide to add a new helper function to package <kbd>x</kbd> called<span> </span><kbd>IsValid</kbd>. The function needs to perform a primality test and, since package<span> </span><kbd>y</kbd><span> </span>already provides<span> </span><kbd>IsPrime</kbd><span>, </span>we decide to follow the DRY approach and import<span> </span><em>y</em><span> </span>into our code, causing a circular dependency:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> x</a>

<a><span class="kw">import</span> <span class="st">"y"</span> <span class="co">// circular dependency: x imports y, y imports z and z imports x</span></a>

<a><span class="kw">func</span> IsValid(v <span class="dt">uint64</span>) <span class="dt">bool</span> {</a>
<a>    <span class="kw">return</span> v != <span class="dv">0</span> &amp;&amp; y.IsPrime(v)</a>
<a>}</a></pre></div>
<p>In cases like this, and assuming the code we need from the included package is small enough, we can just duplicate it (along with its tests) and avoid the extra import that triggers a circular dependency. As a popular Go proverb goes:</p>
<div class="packt_quote">"A little copying is better than a little dependency."</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tips and tools for writing lean and easy-to-maintain Go code</h1>
                </header>
            
            <article>
                
<p>In the upcoming sections, we will be covering some techniques, tools, and best practices that can assist you in writing more concise and clean code that is easier to test and at the same time help you get some praise from your colleagues and code reviewers.</p>
<p>Most of the topics that we will be discussing are specific to Go, but some of the principles can be generalized and applied to other programming languages and software engineering in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimizing function implementations for readability</h1>
                </header>
            
            <article>
                
<p>During my early university days, my CS professors would be adamant about keeping function blocks short and concise. Their advice went along the lines of the following:</p>
<div class="packt_quote">"If a function implementation does not fit on a single screen, then it must be split up into smaller functions."</div>
<p>Keep in mind that these guidelines have their roots in an era when by<span> </span><em>screen</em>, people were referring to the amount of code that could fit in an 80×25 character terminal! Fast forward to today where things have changed: software engineers have access to high-resolution monitors, editors, and bespoke IDEs that come preloaded a wide gamut of sophisticated analysis and refactoring tools. Still, the same bit of advice is just as important for writing code that is easy for<span> </span><em>others</em><span> </span>to review, extend, and maintain.</p>
<p>In the <em>Single responsibility</em> section, we discussed the merits of the SRP. Unsurprisingly, the same principle also applies to function blocks and is something to keep at the back of your mind when coding.</p>
<p>By decomposing a complex function into smaller functions, the code becomes easier to read and reason about. This may not seem important at first, but think about a case where you don't touch the code for a couple of months and then need to dive back into it while trying to track down a bug. As a bonus, the isolated bits of logic also become easier to test, especially if you are following the practice of writing table-driven tests.</p>
<p class="mce-root"/>
<p>Naturally, it follows that the same approach can be applied to existing code. If you find yourself navigating through a lengthy function that contains deeply nested <kbd>if</kbd>/<kbd>else</kbd> blocks, repeated blocks of code, or its implementation tackles several seemingly unrelated concerns, it would be a great opportunity to apply some drive-by refactoring and extract any potential self-contained blocks of logic into separate functions.</p>
<p>Additionally, when creating new functions or splitting existing functions into smaller ones, a good idea is to arrange the functions so that they appear in call order within the file they are defined in, that is, if<span> </span><kbd>A()</kbd> calls <kbd>B()</kbd> and <kbd>C()</kbd>, then both <kbd>B()</kbd> and <kbd>C()</kbd> must appear below, but not necessarily immediately after, <kbd>A()</kbd>. This makes it much easier for other engineers (or people just curious to understand how something works) to skim through existing code.</p>
<p>Each rule comes with exceptions and this rule is no different. Unless the compiler is very good at inlining functions, splitting the business logic across functions sometimes takes a toll on performance. Although the performance hit is, in many cases, insignificant, when the end goal is to produce high-performance code that contains tight inner loops or code that is expected to be called with high frequency, it may be a good idea to keep the implementation neatly tucked within a single function to avoid the extra Go runtime overhead that's incurred when making function calls (for example, pushing arguments to the stack, checking that the stack is large enough for the callee, and popping things off the stack when the function call returns).</p>
<div class="packt_tip">There is always a trade-off between code readability and performance. When dealing with complex systems, readability is oftentimes preferred, but at the end of the day, it's up to you and your team to figure out which mix of readability versus performance works best for your particular use case.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variable naming conventions</h1>
                </header>
            
            <article>
                
<p>There is an ongoing debate regarding the ideal length for variables and type names in Go programs. On one hand, there are the proponents of the belief that all variables should have clear and self-descriptive names. This is a fairly common philosophy for people who have spent some time authoring code in the Java ecosystem. On the other side of the fence, we have the<span> </span><em>minimalists</em>, that is, people who advocate for shorter identifier names, arguing that longer identifiers are too verbose.</p>
<p class="mce-root"/>
<p>The Go language authors certainly seem to be members of the latter camp. Case in point, here is the definition of two of the most popular Go interfaces: <kbd>io.Reader</kbd><span> </span>and <kbd>io.Writer</kbd>:</p>
<div class="sourceCode">
<pre><a><span class="kw">type</span> Reader <span class="kw">interface</span> {</a>
<a>    Read(p []<span class="dt">byte</span>) (n <span class="dt">int</span>, err <span class="dt">error</span>)</a>
<a>}</a>

<a><span class="kw">type</span> Writer <span class="kw">interface</span> {</a>
<a>    Write(p []<span class="dt">byte</span>) (n <span class="dt">int</span>, err <span class="dt">error</span>)</a>
<a>}</a></pre></div>
<p>The same short identifier pattern is widely used throughout the Go standard library code base. My take on this is that using<span> </span><em>shorter</em><span> </span>but still<span> </span><em>descriptive</em><span> </span>variable names is a good thing as long as other engineers that will be called to work on the code base in the future can easily understand their purpose within the scope that each variable is being used in.</p>
<p>The most common example of this approach is naming index variables for nested loops where, typically, a single-letter variable such as <kbd>i</kbd>, <kbd>j</kbd>, and so on is used. In the following code snippet, however, the index variables are used to access an element of the multi-dimensional slice<span> </span><kbd>s</kbd>:</p>
<div class="sourceCode">
<pre><a><span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="bu">len</span>(s); i++ {</a>
<a>    <span class="kw">for</span> j := <span class="dv">0</span>; j &lt; <span class="bu">len</span>(s[i]); j++ {</a>
<a>        value := s[i][j]</a>
<a>        <span class="co">// ...</span></a>
<a>    }</a>
<a>}</a></pre></div>
<p>If someone who's not familiar with this part of the code is tasked with reviewing a pull request containing the preceding loop, they may find themselves struggling to figure out what <kbd>s</kbd><span> is </span>and what each index level represents! Since the shortened variable names provide almost no information regarding their true purpose, to answer these questions, the reviewer would have to jump around the code base looking for clues: look up the type for <kbd>s</kbd>, then go to its definition, and so on and so forth. Now, contrast the preceding code block with the following one, which performs exactly the same function but uses<span> </span><em>slightly longer</em><span> </span>variable names. In my opinion, the second approach has higher information content while at the same time avoids being too verbose:</p>
<div class="sourceCode">
<pre><a><span class="kw">for</span> dateIdx := <span class="dv">0</span>; dateIdx &lt; <span class="bu">len</span>(tickers); dateIdx++ {</a>
<a>    <span class="kw">for</span> stockIdx := <span class="dv">0</span>; stockIdx &lt; <span class="bu">len</span>(tickers[dateIdx]); stockIdx++ {</a>
<a>        value := tickers[dateIdx][stockIdx]</a>
<a>        <span class="co">// ...</span></a>
<a>    }</a>
<a>}</a></pre></div>
<div class="packt_tip">At the end of the day, each engineer has their own preferred variable naming approach and philosophy. When deciding on which approach to adopt, try to take a few minutes to consider how your variable naming choices affect other engineers that collaborate with you on shared code bases.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Go interfaces effectively</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"Accept interfaces, return structs."</div>
<div class="packt_quote CDPAlignRight CDPAlign"><em><span>- Jack Lindamood</span></em></div>
<p>The key point behind organizing code into packages is to make it reusable and available to external consumers in a frictionless way by providing a clean, well-documented API surface that consumers can build on. When authoring functions or methods that accept concrete types as arguments, we place an artificial constraint on the usefulness of our implementation: it only works with instances of a particular type.</p>
<p>While this may not always be an issue, in some cases, requiring a concrete type instance can potentially make testing non-trivial and slow, especially if the construction of such an instance is a costly operation. The following excerpt is part of a system that collects and publishes performance metrics to a <strong>key-value</strong> (<strong>KV</strong>) store.</p>
<p>The KV store implementation looks like this:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> kv</a>

<a><span class="co">// Store implements a key-value store which stores data to disk.</span></a>
<a><span class="kw">type</span> Store <span class="kw">struct</span> { <span class="co">// ...  }</span></a>

<a><span class="kw">func</span> Open(path <span class="dt">string</span>) (*Store, <span class="dt">error</span>) { <span class="co">// Open path, load and verify data, replay pending transactions etc.  }</span></a>

<a><span class="co">// Put persists (key, value) to the store.</span></a>
<a><span class="kw">func</span> (s *Store) Put(key <span class="dt">string</span>, value <span class="kw">interface</span>{}) <span class="dt">error</span> { <span class="co">// ...  }</span></a>

<a><span class="co">// Get looks up the value associated with key.</span></a>
<a><span class="kw">func</span> (s *Store) Get(key <span class="dt">string</span>) (<span class="kw">interface</span>{}, <span class="dt">error</span>) { <span class="co">// ...  }</span></a>

<a><span class="co">// Close waits for any pending transactions to complete and then  </span></a>
<a><span class="co">// cleanly shuts down the KV store.</span></a>
<a><span class="kw">func</span> (s *Store) Close() <span class="dt">error</span> { <span class="co">// ...  }</span></a></pre></div>
<p class="mce-root"/>
<p>Within the<span> </span><kbd>metrics</kbd><span> </span>package, we can find the definition of the<span> </span><kbd>ReportMetrics</kbd><span> </span>function. It receives a<span> </span><kbd>kv.Store</kbd><span> </span>instance as an argument and persists the collected metrics to it:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> metrics</a>

<a><span class="co">// ReportMetrics writes the collected metrics to a KV store instance.</span></a>
<a><span class="kw">func</span> (c *Collector) ReportMetrics(s *kv.Store) <span class="dt">error</span> {</a>
<a>    <span class="co">// for each metric call s.Put(k, v)</span></a>
<a>}</a>

<a><span class="co">// Observe records a value for a particular metric.</span></a>
<a><span class="kw">func</span> (c *Collector) Observe(metric <span class="dt">string</span>, value <span class="kw">interface</span>{}) {</a>
<a>    <span class="co">// ...</span></a>
<a>}</a></pre></div>
<p>Based on the previous discussion around SOLID principles, you should have already identified an issue with this code:<span> </span><em>it only works with a specific KV store implementation</em>! What if we want to publish the metrics to a network socket, write them to a CSV file, or perhaps log them to the console?</p>
<p>There is, however, yet another issue with this bit of code: testing it requires quite a bit of effort. To understand why, let's put ourselves in the shoes of a consumer of this package. As part of our integration test suite, we want to make sure that all the collected metrics are actually written to the KV store instance.</p>
<p>First, our test code would have to create an instance of the KV store. Since the<span> </span><kbd>Open</kbd><span> </span>method requires a file and we could be running multiple tests concurrently, we would need to create a temporary unique file and pass it as an argument to<span> </span><kbd>Open</kbd>. Of course, we shouldn't leave temporary files hanging around after our test run completes, so we need to make sure our test will clean up after itself:</p>
<div class="sourceCode">
<pre><a><span class="co">// Generate a random file for the KV store</span></a>
<a>tmpfile, err := ioutil.TempFile(<span class="st">""</span>, <span class="st">"metrics"</span>)</a>
<a><span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a>    t.Fatal(err)</a>
<a>}</a>
<a><span class="kw">defer</span> <span class="kw">func</span>() { _ = os.Remove(tmpfile.Name()) }() <span class="co">// clean up when we are <br/>                                                 // done</span></a>
<a>_ = tmpfile.Close()</a>

<a><span class="co">// Create KV store</span></a>
<a>s, err := kv.Open(tmpfile.Name())</a>
<a><span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a>    t.Fatal(err)</a>
<a>}</a>
<a><span class="kw">defer</span> <span class="kw">func</span>() { _ = s.Close() }()</a></pre></div>
<p class="mce-root"/>
<p>That brings us to the meat of the test: creating a metrics collector, populating it with a bunch of measurements, reporting the captured metrics to the KV store, and verifying that everything has been written to the store properly:</p>
<div class="sourceCode">
<pre><a>c := metrics.NewCollector()</a>
<a><span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">100</span>; i++ {</a>
<a>    c.Observe(fmt.Sprintf(<span class="st">"metric_%d"</span>, i), i)</a>
<a>}</a>

<a><span class="kw">if</span> err = c.ReportMetrics(s); err != <span class="ot">nil</span> {</a>
<a>    t.Fatal(err)</a>
<a>}</a>

<a><span class="co">// Ensure that all metrics have been written to the store</span></a>
<a><span class="co">// ...</span></a>
<a>}</a></pre></div>
<p>This test is pretty straightforward but it requires quite a bit of boilerplate code for setting it up. Additionally,<span> </span><kbd>kv.Open</kbd><span> </span>seems like it is quite an expensive call to make; imagine the overhead involved if our test suite was comprised of hundreds of tests where each one required a<span> </span><em>real</em><span> </span><kbd>kv.Store</kbd><span> </span>instance. If, on the other hand,<span> </span><kbd>ReportMetrics</kbd><span> </span>received an interface as an argument, we could pass an in-memory mock while testing and also retain the flexibility to report the metrics to any destination that satisfies that particular interface. Therefore, we can improve the preceding code by introducing an interface:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> metrics </a>

<a><span class="co">// Sink is implemented by objects that metrics can be reported to.</span></a>
<a><span class="kw">type</span> Sink <span class="kw">interface</span> {</a>
<a>    Put(k <span class="dt">string</span>, v <span class="kw">interface</span>{}) <span class="dt">error</span></a>
<a>}</a>

<a><span class="co">// ReportMetrics writes the collected metrics to a Sink.</span></a>
<a><span class="kw">func</span> (c *Collector) ReportMetrics(s Sink) <span class="dt">error</span> {</a>
<a>    <span class="co">// for each metric call s.Put(k, v)</span></a>
<a>}</a></pre></div>
<p>This small change makes testing a breeze! We can test the<span> </span><kbd>kv.Store</kbd><span> </span>code in isolation and switch to an in-memory store to run all our unit tests:</p>
<div class="sourceCode">
<pre><a><span class="kw">func</span> TestReportMetrics(t *testing.T) {</a>
<a>    <span class="co">// Use in-memory store defined inside the test package</span></a>
<a>    s := <span class="bu">new</span>(inMemStore)</a>

<a>    <span class="co">// Create collector and populate some metrics</span></a>
<a>    c := metrics.NewCollector()</a>
<a>    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">100</span>; i++ {</a>
<a>        c.Observe(fmt.Sprintf(<span class="st">"metric_%d"</span>, i), i)</a>
<a>    }</a>

<a>    <span class="kw">if</span> err = c.ReportMetrics(s); err != <span class="ot">nil</span> {</a>
<a>        t.Fatal(err)</a>
<a>    }</a>

<a>    <span class="co">// Ensure that all metrics have been written to the store...</span></a>
<a>}</a></pre></div>
<p>The other piece of advice from Lindamood states that we should always try to return concrete types rather than interfaces. This advice actually makes sense: as a package consumer, if I am calling a function that creates a type,<span> </span><kbd>Foo</kbd>, I am probably interested in calling one or more methods that are specific to that type. If the<span> </span><kbd>NewFoo</kbd><span> </span>function returns an interface, the client code would have to manually cast it to<span> </span><kbd>Foo</kbd><span> </span>so that it can invoke the <kbd>Foo</kbd>-specific methods; this would defeat the purpose of returning an interface in the first place.</p>
<p>It is also important to point out that, in the majority of cases, the implementation will create an instance of a concrete type; the main reason why we would opt to return an interface to begin with is to ensure that our concrete type always satisfies a particular interface. In essence, we are adding a compile-time check to our code! However, there are simpler ways to introduce such compile-time checks and still retain the ability for constructors to return concrete instances:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> metrics</a>

<a><span class="kw">import</span> <span class="st">"fmt"</span></a>

<a><span class="co">// Compile-time checks for ensuring a type implements a particular <br/>// interface.</span></a>
<a><span class="kw">var</span> (</a>
<a>    <span class="co">// Works but allocates a dummy Foo instance on the heap.</span></a>
<a>    _ fmt.Stringer = &amp;Foo{}</a>

<a>    <span class="co">// Preferred way that does not allocate anything on the heap.</span></a>
<a>    _ fmt.Stringer = (*Foo)(<span class="ot">nil</span>)</a>
<a>)</a>

<a><span class="kw">type</span> Foo <span class="kw">struct</span> { }</a>

<a><span class="kw">func</span> (*Foo) String() <span class="dt">string</span> { <span class="kw">return</span> <span class="st">"Foo"</span> }</a></pre></div>
<p>The preceding code snippet outlines two fairly common approaches to achieve this compile-time check by defining a pair of global variables that use the reserved<span> </span><em>blank identifier</em><span> </span>as a hint to the compiler that they are not actually used.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Zero values are your friends</h1>
                </header>
            
            <article>
                
<p>One great feature that Go offers is that each type is automatically assigned its zero value when it gets instantiated. Some interesting examples from Go and its standard library are as follows:</p>
<ul>
<li>Go channels; nil channels indefinitely block go-routines attempting to read off them</li>
<li>The zero value for a Go slice; this is an empty slice that things can be appended to</li>
<li>The<span> </span><kbd>sync.Mutex</kbd><span> </span>type, whose zero value indicates that the mutex is unlocked</li>
<li>The<span> </span><kbd>bytes.Buffer</kbd><span> </span>type, whose zero value indicates an empty buffer</li>
</ul>
<p>By relying on zero values when designing new types, we can provide implementations that work out of the box without the need to explicitly invoke a constructor or any other initializer method. The following code snippet defines a simple, thread-safe map:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> main</a>

<a><span class="kw">import</span> (</a>
<a>    <span class="st">"fmt"</span></a>
<a>    <span class="st">"sync"</span></a>
<a>)</a>

<a><span class="co">// SyncMap implements a thread-safe map. The zero SyncMap value is ready <br/>// to use.</span></a>
<a><span class="kw">type</span> SyncMap <span class="kw">struct</span> {</a>
<a>    mu   sync.RWMutex</a>
<a>    data <span class="kw">map</span>[<span class="dt">string</span>]<span class="kw">interface</span>{}</a>
<a>}</a></pre></div>
<p>The actual Go map that will be used to store the<span> </span><kbd>SyncMap</kbd><span> </span>data will be lazily allocated when we attempt to add an item to the map. Acquiring a<span> </span><em>writer</em><span> </span>mutex before working with the underlying map ensures that both the initialization of the map and the insertion of items happen in an atomic fashion:</p>
<div class="sourceCode">
<pre><a><span class="co">// Put inserts a key-value pair into the map.</span></a>
<a><span class="kw">func</span> (sm *SyncMap) Put(key <span class="dt">string</span>, value <span class="kw">interface</span>{}) {</a>
<a>    sm.mu.Lock()</a>
<a>    <span class="kw">defer</span> sm.mu.Unlock()</a>

<a>    <span class="kw">if</span> sm.data == <span class="ot">nil</span> {</a>
<a>        sm.data = <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">string</span>]<span class="kw">interface</span>{})</a>
<a>    }</a>

<a>    sm.data[key] = value</a>
<a>}</a></pre></div>
<p>The lookup implementation is pretty straightforward. One noticeable difference compared to the implementation of <kbd>Put</kbd><span> is that</span><span> </span><kbd>Get</kbd><span> </span>acquires a<span> </span><em>reader</em><span> </span>mutex before performing lookups. The use of a reader/writer mutex provides concurrent access to multiple readers while only allowing a single writer to mutate the map's contents:</p>
<div class="sourceCode">
<pre><a><span class="co">// Get returns the value associate by key and a boolean value indicating</span></a>
<a><span class="co">// whether key is present in the map.</span></a>
<a><span class="kw">func</span> (sm *SyncMap) Get(key <span class="dt">string</span>) (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {</a>
<a>    sm.mu.RLock()</a>
<a>    <span class="kw">defer</span> sm.mu.RUnlock()</a>

<a>    <span class="kw">if</span> sm.data == <span class="ot">nil</span> {</a>
<a>        <span class="kw">return</span> <span class="ot">nil</span>, <span class="ot">false</span></a>
<a>    }</a>

<a>    return sm.data[key]</a>
<a>}</a></pre></div>
<p>Contrary to the built-in Go map type, which requires explicit initialization via a call to <kbd>make</kbd>, the zero value of a<span> </span><kbd>SyncMap</kbd><span> </span>can be safely used as is:</p>
<div class="sourceCode">
<pre><a><span class="kw">func</span> main() {</a>
<a>    <span class="kw">var</span> sm SyncMap <span class="co">// we are using the zero value of the map</span></a>
<a>    sm.Put(<span class="st">"foo"</span>, <span class="st">"bar"</span>)</a>
<a>    fmt.Println(sm.Get(<span class="st">"foo"</span>)) <span class="co">// Prints: bar true</span></a>
<a>}</a></pre></div>
<p>What's more, we can<span> </span><em>embed</em><span> </span>the preceding<span> </span><kbd>SyncMap</kbd><span> </span>implementation into other types that follow the same zero value pattern to provide complex types that require no initialization:</p>
<div class="sourceCode">
<pre><a><span class="kw">type</span> Foo <span class="kw">struct</span> {</a>
<a>    bar Bar</a>
<a>}</a>

<a><span class="kw">type</span> Bar <span class="kw">struct</span> {</a>
<a>    sm SyncMap</a>
<a>}</a>


<a><span class="kw">func</span> main() {</a>
<a>    <span class="kw">var</span> foo Foo <span class="co">// still using a zero value</span></a>
<a>    foo.bar.sm.Put(<span class="st">"answer"</span>, <span class="dv">42</span>) <span class="co">// storing into the embedded map also <br/>                                 // works.</span></a>
<a>}</a></pre></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the preceding code snippet, the<span> </span><kbd>SyncMap</kbd><span> </span>instance is ready to use and can be accessed directly through an instance of<span> </span><kbd>Foo</kbd><span> </span>without having to type any additional code to set it up.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using tools to analyze and manipulate Go programs</h1>
                </header>
            
            <article>
                
<p>Go programs are inherently easy to parse. In fact, the Go library provides built-in packages that can parse Go programs into <strong>abstract syntax trees</strong> (<strong>ASTs</strong>), which can be traversed, modified, and transformed back into Go code. Let's go through a simple example to show you how easy it is to work with these packages.</p>
<p>First, we need a helper function to convert a Go program into an AST representation. The<span> following </span><kbd>parse</kbd><span> </span>function does exactly that:</p>
<div class="sourceCode">
<pre><a><span class="kw">import</span> (</a>
<a>    <span class="st">"fmt"</span></a>
<a>    <span class="st">"go/ast"</span></a>
<a>    <span class="st">"go/parser"</span></a>
<a>    <span class="st">"go/token"</span></a>
<a>)</a>

<a><span class="co">// parse a Go program into an AST representation.</span></a>
<a><span class="kw">func</span> parse(program <span class="dt">string</span>) (*token.FileSet, *ast.File, <span class="dt">error</span>) {</a>
<a>    fs := token.NewFileSet()</a>
<a>    tree, err := parser.ParseFile(fs, <span class="st">"example.go"</span>, program, <span class="dv">0</span>)</a>
<a>    <span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a>        <span class="kw">return</span> <span class="ot">nil</span>, <span class="ot">nil</span>, err</a>
<a>    }</a>
<a>    <span class="kw">return</span> fs, tree, <span class="ot">nil</span></a>
<a>}</a></pre></div>
<p>The<span> </span><kbd>ast</kbd><span> </span>package provides a couple of helpers that implement the visitor pattern and invokes a user-defined callback for each node in the AST. For this particular example, we will define a function called <kbd>inspectVariables</kbd> that visits every node in the AST, looking for nodes that correspond to identifiers (<span>package, constant, type, variable, function, or label). For each discovered identifier, the function will check its <kbd>Kind</kbd> attribute and print out its name if the identifier represents a variable: </span>  </p>
<div class="sourceCode">
<pre><a><span class="co">// inspectVariables visits each AST node and prints any encountered Go variable.</span></a>
<a><span class="kw">func</span> inspectVariables(fs *token.FileSet, tree *ast.File) {</a>
<a>    ast.Inspect(tree, <span class="kw">func</span>(n ast.Node) <span class="dt">bool</span> {</a>
<a>        ident, ok := n.(*ast.Ident)</a>
<a>        <span class="kw">if</span> !ok || ident.Obj == <span class="ot">nil</span> || ident.Obj.Kind != ast.Var {</a>
<a>            <span class="kw">return</span> <span class="ot">true</span></a>
<a>        }</a>

<a>        fmt.Printf(<span class="st">"%s:</span><span class="ch">\t</span><span class="st">variable %q</span><span class="ch">\n</span><span class="st">"</span>, fs.Position(n.Pos()), ident)</a>
<a>        <span class="kw">return</span> <span class="ot">true</span></a>
<a>    })</a>
<a>}</a></pre></div>
<p>To complete our example, we need to provide a <kbd>main</kbd> function that will parse a simple program and call<span> </span><kbd>inspectVariables</kbd><span> </span>on the resulting AST:</p>
<div class="sourceCode">
<pre><a><span class="kw">func</span> main() {</a>
<a>    fs, tree, err := parse(<span class="st">`</span></a>
<a><span class="st">        package foo </span></a>

<a><span class="st">        var global = "foo"</span></a>

<a><span class="st">        func main(){ x := 42 }</span></a>
<a><span class="st">    `</span>)</a>

<a>    <span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a>        fmt.Printf(<span class="st">"ERROR: %v</span><span class="ch">\n</span><span class="st">"</span>, err)</a>
<a>        <span class="kw">return</span></a>
<a>    }</a>

<a>    inspectVariables(fs, tree)</a>
<a>}</a></pre></div>
<p>Running the preceding program produces the following output:</p>
<pre class="console">$ go run print_vars.go
example.go:4:7: variable "global"
example.go:6:16: variable "x"</pre>
<p>The Go ecosystem contains a plethora of tools that build on top of this parsing infrastructure and provide analysis, code modification, and generation services to software engineers. In the upcoming sections, we will examine a short list of such tools that can make your software development life easier.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking care of formatting and imports (gofmt, goimports)</h1>
                </header>
            
            <article>
                
<p>Tabs or spaces? Should opening braces be preceded by line breaks? All engineers eventually face this dilemma when the time comes to choose a particular code formatting style for a new project or a project they've just inherited.</p>
<p>Source code formatting styles have always been the subject of long, often heated, arguments between team members. Contrary to other programming languages, Go is, by design, strongly opinionated toward a specific formatting style and ships with tools that help enforce that particular style. This design decision makes sense as Go was initially created with the goal of being used by the thousands of engineers employed by Google. At this massive development scale, uniformity in the authored code is not just a nicety <span>–</span> it's actually vital for ensuring that code can be handed off between development teams.</p>
<p>The<span> </span><kbd>gofmt</kbd><span> </span>tool<span> </span><sup><span class="citation">[11]</span></sup><span> </span>is available as part of the standard Go distribution. You provide it with the paths to one or more files and it can perform the following tasks:</p>
<ul>
<li>Format code according to the recommended standard</li>
<li>Simplify code (<kbd>gofmt -s example.go</kbd>)</li>
<li>Perform simple rewrites (<kbd>gofmt -r ‘a[b:len(a)] -&gt; a[len(a):b]’ example.go</kbd>)</li>
</ul>
<p>By default,<span> </span><kbd>gofmt</kbd><span> </span>will output the formatted programs to the standard output. However, users may pass the<span> </span><kbd>-w</kbd><em> </em>flag to force<span> </span><kbd>gofmt</kbd><span> </span>to write its output back to the source file that it just processed.</p>
<p>The<span> </span><kbd>goimports</kbd><span> </span>tool<span> </span><sup><span class="citation">[12]</span></sup><span> </span>is a drop-in replacement for<span> </span><kbd>gofmt</kbd><span> </span>that can be installed by running<span> </span><kbd>go get golang.org/x/tools/cmd/goimports</kbd>. In addition to providing code-formatting facilities that match the output of<span> </span><kbd>gofmt</kbd>, <kbd>goimports</kbd><span> </span>also manages Go import lines: it can fill in missing imports and remove the ones that aren't referenced by the processed file. What's more,<span> </span><kbd>goimports</kbd><span> </span>also ensures that packages are sorted alphabetically and grouped together, depending on whether they belong to the standard library or are third-party packages.</p>
<p>The following is an example of a Go program that exhibits a couple of issues: missing imports, unused imports, extraneous whitespace, and incorrect indentation:</p>
<div class="sourceCode">
<div class="sourceCode">
<pre><a><span class="kw">package</span> main</a>

<a><span class="kw">import</span> (</a>
<a>    <span class="st">"net"</span> <span class="co">// Mixed stdlib and third-party packages</span></a>
<a>    <span class="st">"github.com/achilleasa/kv"</span></a>
<a>    <span class="st">"fmt"</span> <span class="co">// Unused package </span></a>
<a>)</a>

<a><span class="kw">type</span> Server <span class="kw">struct</span> {</a>
<a>    ctx    context.Context <span class="co">// missing referenced import</span></a>
<a>    socket net.Conn</a>
<a>store *kv.Store <span class="co">// Incorrectly indented field definition</span></a>
<a>}</a>


<a><span class="kw">func</span> foo(){} <span class="co">// Redundant line-breaks above foo()</span></a></pre></div>
<p>The typical use case for these tools is to execute them as post-save hooks from your favorite editor or IDE. If we run<span> </span><kbd>goimports</kbd><span> </span>on the preceding code snippet, we will get a neatly formatted output:</p>
<div class="sourceCode">
<pre><a><span class="kw">package</span> main</a>

<a><span class="kw">import</span> (</a>
<a>    <span class="st">"context"</span></a>
<a>    <span class="st">"net"</span></a>

<a>    <span class="st">"github.com/achilleasa/kv"</span></a>
<a>)</a>

<a><span class="kw">type</span> Server <span class="kw">struct</span> {</a>
<a>    ctx    context.Context</a>
<a>    socket net.Conn</a>
<a>    store *kv.Store</a>
<a>}</a>

<a><span class="kw">func</span> foo() {}</a></pre></div>
</div>
<p>As you can see, the import statements have been cleaned up and sorted, the missing packages have been imported, and unused packages have been removed. Adding to this, the code is now properly indented and all the extraneous whitespace has been removed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring code across packages (gorename, gomvpkg, fix)</h1>
                </header>
            
            <article>
                
<p>Oftentimes, you may come across a variable within a function that has a strange or non-descriptive name that you are quite keen on renaming. Performing such a rename operation is quite simple; just select the function block and run a find-and-replace operation. Simple as pie!</p>
<p class="mce-root"/>
<p>But what if you want to rename a public struct field or a function that is exported from your package? This is definitely not a trivial task as you need to track down all the references to the thing being renamed (the list may also include other packages) and update them to use the new name. This type of rename operation takes us into the realm of code refactoring; fortunately, there is a tool at our disposal for automating this tedious task:<span> </span><kbd>gorename</kbd><span> </span><sup><span class="citation">[16]</span></sup>. It can be installed by running<span> </span><kbd>go get golang.org/x/tools/cmd/gorenam<em>e</em></kbd>.</p>
<p>One interesting feature of<span> </span><kbd>gorename</kbd>, besides the fact that it works across packages, is that it is<span> </span><em>type-aware</em>. <span>Since it relies on parsing the program before it applies any rename operation, it is intelligent enough to tell the difference between a function called </span><kbd>Foo</kbd><span> and a struct field with the same name. Furthermore, it includes an extra layer of safety in that it will only apply rename operations as long as the end result is a piece of code that can compile without errors.</span></p>
<p>Sometimes, you may find yourself needing to rename a Go package or even move it to a different location either within the same project or across projects. The<span> </span><kbd>gomvpkg</kbd><span> </span>tool<span> </span><sup><span class="citation">[15]</span></sup><span> </span>can assist in that matter while also taking care of tracking down packages that depend on the renamed/moved package and updating their import statements to point to the new package location. It can be installed by running<span> </span><kbd>go get golang.org/x/tools/cmd/gomvpkg</kbd>. Moving a package is as simple as running the following command:</p>
<pre class="console"># Rename foo to bar and update all imports for packages depending on foo.
$ gomvpkg -from foo -to bar</pre>
<p>The Go standard library has changed a lot over the years since the release of the first stable Go version back in 2011. New APIs were introduced while other APIs were deprecated and eventually removed. In some cases, existing APIs are modified, often in a non-backward-compatible way, whereas in other cases, external or experimental packages eventually got accepted for inclusion in the standard library.</p>
<p>A relevant example is the<span> </span><kbd>context</kbd><span> </span>package. Prior to Go 1.7, this package was available at<span> </span><kbd>golang.org/x/net/context</kbd><em> </em>and quite a few Go programs were actively using it. But with the release of Go 1.7, that package became a part of the standard library and moved to a standalone <kbd>context</kbd> package. As soon as engineers switched to the new import path for the context package, their code would instantly become incompatible with code still using the old import path. Therefore, someone would have to undertake the task of reviewing the existing code base and rewriting existing imports to point to the new location for the context package!</p>
<p>The Go designers foresaw such issues and created a rule-based tool to detect code that relies on old, deprecated APIs or packages, and automatically rewrite it to use newer APIs. The tool, aptly named<span> </span><kbd>fix</kbd> (<a href="https://golang.org/cmd/fix/">https://golang.org/cmd/fix/</a>), ships with each new Go release and can be invoked each time you switch to a newer Go version by running<span> </span><kbd>go tool fix $path</kbd>. It is important to point out that all applied fixes are<span> </span><em>idempotent</em>; therefore, it is safe to run the tool multiple times without the risk of your code base becoming corrupted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving code quality metrics with the help of linters</h1>
                </header>
            
            <article>
                
<p>Linters are specialized static analysis tools that parse Go files and attempt to detect, flag, and report cases where the following occurs:</p>
<ul>
<li>The code does not adhere to the standard formatting style guide; for example, it contains extraneous whitespace, is incorrectly indented, or contains comments with spelling typos</li>
<li>The program contains possible logic bugs; for example, a variable declaration<span> </span><em>shadowing</em><span> </span>a previous variable declaration with the same name, calling<span> functions such as </span><kbd>fmt.Printf</kbd><span> </span>with an incorrect argument count or with arguments whose types do not match the format string, assigning values to variables but not actually using them, not checking errors returned by function calls, and so on</li>
<li>The code may contain security vulnerabilities; for example, it contains hardcoded security credentials or points to where an SQL injection might be possible using insecure random number sources or cryptographically broken hash primitives (DES, RC4, MD5, or SHA1)</li>
<li>The code exhibits high complexity (for example, deeply nested <kbd>if</kbd>/<kbd>else</kbd> blocks) or contains unnecessary type conversions, unused local or global variables, or code paths that are never invoked</li>
</ul>
<p><span>The following table </span>summarizes the most popular Go linters that you can invoke to check your programs and improve the quality metrics of the code that you author:</p>
<table style="width: 100%;border-collapse: collapse" border="1">
<tbody>
<tr>
<td><strong>Category</strong></td>
<td><strong>Linter</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="odd">
<td>Logic bugs</td>
<td><kbd>bodyclose</kbd><span> </span><sup><span class="citation">[2]</span></sup></td>
<td>Check if<span> </span><kbd>http.Response</kbd><span> </span>bodies are always closed.</td>
</tr>
<tr class="even">
<td>Logic bugs</td>
<td><kbd>errcheck</kbd><span> </span><sup><span class="citation">[7]</span></sup></td>
<td>Identify cases where returned errors are not being checked.</td>
</tr>
<tr class="odd">
<td>Logic bugs</td>
<td><kbd>gosumcheck</kbd><span> </span><sup><span class="citation">[19]</span></sup></td>
<td>Ensure that all possible cases of a type switch are handled properly.</td>
</tr>
<tr class="even">
<td>Logic bugs</td>
<td><kbd>go vet</kbd> (<a href="https://golang.org/cmd/vet/">https://golang.org/cmd/vet/</a>)<span> </span><sup><span class="citation">[20]</span></sup></td>
<td>Report suspicious constructs, for example, calling <kbd>fmt.Printf</kbd> with the wrong arguments.</td>
</tr>
<tr class="odd">
<td>Logic bugs</td>
<td><kbd>ineffassign</kbd><span> </span><sup><span class="citation">[21]</span></sup></td>
<td>Detect variable assignments that are not being used.</td>
</tr>
<tr class="even">
<td>Code smell</td>
<td><kbd>deadcode</kbd> (<a href="https://github.com/tsenart/deadcode">https://github.com/tsenart/deadcode</a>)<span> </span><sup><span class="citation">[4]</span></sup></td>
<td>Report unused blocks of code.</td>
</tr>
<tr class="odd">
<td>Code smell</td>
<td><kbd>dupl</kbd><span> (<a href="https://github.com/mibk/dupl">https://github.com/mibk/dupl</a>) </span><sup><span class="citation">[5]</span></sup></td>
<td>Report potentially duplicated blocks of code.</td>
</tr>
<tr class="even">
<td>Code smell</td>
<td><kbd>goconst</kbd><span> (<a href="https://github.com/jgautheron/goconst">https://github.com/jgautheron/goconst</a>) </span><sup><span class="citation">[9]</span></sup></td>
<td>Flag repeated strings that can be replaced with constants.</td>
</tr>
<tr class="odd">
<td>Code smell</td>
<td><kbd>structcheck</kbd><span> (<a href="https://gitlab.com/opennota/check">https://gitlab.com/opennota/check</a>) </span><sup><span class="citation">[30]</span></sup></td>
<td>Identify unused struct fields.</td>
</tr>
<tr class="even">
<td>Code smell</td>
<td><kbd>unconvert</kbd><span> (<a href="https://github.com/mdempsky/unconvert">https://github.com/mdempsky/unconvert</a>) </span><sup><span class="citation">[31]</span></sup></td>
<td>Detect unnecessary type conversions.</td>
</tr>
<tr class="odd">
<td>Code smell</td>
<td><kbd>unparam</kbd> (<a href="https://github.com/mvdan/unparam">https://github.com/mvdan/unparam</a>)<span> </span><sup><span class="citation">[33]</span></sup></td>
<td>Detect unused function parameters.</td>
</tr>
<tr class="even">
<td>Code smell</td>
<td><kbd>varcheck</kbd><span> </span><sup><span class="citation">[34]</span></sup></td>
<td>Detect unused variables and constants.</td>
</tr>
<tr class="odd">
<td>Performance</td>
<td><kbd>aligncheck</kbd><span> </span><sup><span class="citation">[1]</span></sup></td>
<td>Identify inefficiently packed structs that take up more space due to padding.</td>
</tr>
<tr class="even">
<td>Performance</td>
<td><kbd>copyfighter</kbd> (<a href="https://github.com/jmhodges/copyfighter">https://github.com/jmhodges/copyfighter</a>)<span> </span><sup><span class="citation">[3]</span></sup></td>
<td>Reports functions that pass large structs by value; this pattern triggers memory allocations and increases pressure on the garbage collector.</td>
</tr>
<tr class="odd">
<td>Performance</td>
<td><kbd>prealloc</kbd><span> </span><sup><span class="citation">[26]</span></sup></td>
<td>Identify slice declarations that could be preallocated.</td>
</tr>
<tr class="even">
<td>Complexity</td>
<td><kbd>gocyclo</kbd><span> </span><sup><span class="citation">[10]</span></sup></td>
<td>Calculate cyclomatic complexities of Go functions.</td>
</tr>
<tr class="odd">
<td>Complexity</td>
<td><kbd>gosimple</kbd><span> </span><sup><span class="citation">[18]</span></sup></td>
<td>Report code that can be potentially simplified.</td>
</tr>
<tr class="even">
<td>Complexity</td>
<td><kbd>splint</kbd><span> </span><sup><span class="citation">[29]</span></sup></td>
<td>Identify functions that are too long or receive too many arguments.</td>
</tr>
<tr class="odd">
<td>Security</td>
<td><kbd>gosec</kbd> (<a href="https://github.com/securego/gosec">https://github.com/securego/gosec</a>)<span> </span><sup><span class="citation">[17]</span></sup></td>
<td>Scan source code for potential security issues.</td>
</tr>
<tr class="even">
<td>Security</td>
<td><kbd>safesql</kbd> (<a href="https://github.com/stripe/safesql">https://github.com/stripe/safesql</a>)<sup><span> </span><span class="citation">[28]</span></sup></td>
<td>Check for potential SQL injection points.</td>
</tr>
<tr class="odd">
<td>Style</td>
<td><kbd>gofmt -s</kbd><span> (<a href="https://golang.org/cmd/gofmt/">https://golang.org/cmd/gofmt/</a>) </span><sup><span class="citation">[11]</span></sup></td>
<td>Ensure that a file is formatted according to <kbd>gofmt</kbd> rules.</td>
</tr>
<tr class="even">
<td>Style</td>
<td><kbd>golint</kbd> (<a href="https://github.com/golang/lint">https://github.com/golang/lint</a>)<span> </span><sup><span class="citation">[14]</span></sup></td>
<td>Report stylistic deviations from the recommendations outlined in<span> </span>Effective Go<span> </span><sup><span class="citation">[6]</span></sup>.</td>
</tr>
<tr class="odd">
<td>Style</td>
<td><kbd>misspell</kbd> (<a href="https://github.com/client9/misspell">https://github.com/client9/misspell</a>)<span> </span><sup><span class="citation">[25]</span></sup></td>
<td>Use a dictionary to identify spelling mistakes in comments.</td>
</tr>
<tr class="even">
<td>Style</td>
<td><kbd>unindent</kbd><span> (<a href="https://github.com/mvdan/unindent">https://github.com/mvdan/unindent</a>) </span><sup><span class="citation">[32]</span></sup></td>
<td>Identify code that isn't indented correctly.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Using the preceding linters in your projects comes with a few caveats that you need to be aware of. First of all, each linter uses its own output format to report detected issues. The lack of a standardized way to report issues becomes a problem when you attempt to integrate the linters with your preferred editor or IDE workflows (for example, jump to the code location where an issue was detected). Secondly, each linter is oblivious to the existence of other linters. Consequently,<span> </span><em>each</em><span> </span>linter needs to reparse all the packages when it runs. This is usually not an issue when you're dealing with small code bases, but it becomes annoying when you're working with larger projects, as an end-to-end run of all the linters can take up to a few minutes to complete.</p>
<p>To address the preceding issues, you can use a<span> </span><strong>meta-linter</strong><span> </span>(also known as a<span> </span><strong>linter output aggregator</strong>) tool such as<span> </span><kbd>golangci-lint</kbd><span> </span><sup><span class="citation">[13]</span></sup><span> </span>(a drop-in replacement for the now-deprecated<span> </span>gometalinter) or<span> </span>revive<span> </span><sup><span class="citation">[27]</span></sup>. These tools are designed to execute a configurable list of linters in parallel, normalize their output, eliminate duplicate warnings, or even suppress warnings based on regular expressions (quite a handy feature when your project includes files that are autogenerated by other tools). What's more, they also seamlessly integrate with the majority of editors that are used by engineers working on Go programs. An easy way to invoke these meta-linter tools is to add a target to your project's<span> </span><em>makefile</em>:</p>
<pre class="make">lint: 
    golangci-lint run \
      --no-config --issues-exit-code=0 --deadline=30m \
      --disable-all --enable=deadcode  --enable=gocyclo --enable=golint \
      --enable=varcheck --enable=structcheck --enable=errcheck \
      --enable=dupl --enable=ineffassign \
      --enable=unconvert --enable=goconst --enable=gosec</pre>
<p>Having a makefile rule for linting makes it easy to run the linters as part of your regular CI pipeline and block pull requests from being merged until the lint errors are addressed. At the same time, it offers you the flexibility of running the linters locally while you are working on the code base.</p>
<div class="packt_tip">It is quite common for engineers to forgo running the linters before creating a pull request, thereby requiring additional commits just to address lint errors. You can avoid such situations by exploiting the fact that most version control systems (Git is one example) support some kind of pre-commit or pre-push hook and have your VCS run the linters automatically for you.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In the first section of this chapter, <em>The SOLID principles of object-oriented design</em>, we performed a deep dive into each of the SOLID principles and how they can be applied toward writing clean Go code:</p>
<ul>
<li><strong>SRP</strong>: Group structs and functions based on their purpose and organize them into packages with clear logical boundaries.</li>
<li><strong>Open/Closed principle</strong>: Use composition and embedding of simple types to construct more complex types that still retain the same implicit interface as the types they consist of.</li>
<li><strong>LSP</strong>: Avoid unnecessary coupling by using interfaces rather than concrete types to define the contract between packages.</li>
<li><strong>ISP</strong>: Make sure your function or method signatures only depend on the behaviors they need and nothing more; use the smallest possible interface to describe function/method arguments and avoid coupling to the implementation details of concrete types.</li>
<li><strong>DIP</strong>: Use the appropriate level of abstraction when designing your code to decouple high-level and low-level modules while at the same time ensuring that the implementation details rely on the abstractions and not the other way round.</li>
</ul>
<p>Halfway through this chapter, we touched on the subject of organizing code into packages, identified common package naming pitfalls that you should avoid, and discussed the concept of import cycles, including their causes. Then, we outlined strategies for mitigating the issue of circular dependencies.</p>
<p>Finally, we discussed useful tips and tools that you can use to facilitate writing clean code that is easy to reason about and for your software engineering colleagues to review and maintain.</p>
<p>As your Go projects grow in size, you will undoubtedly notice a bump in the number of package import statements throughout the code base. This is quite normal and, frankly, expected if you are applying the SOLID principles when creating packages. However, the increased number of imports, especially if they are authored by third parties that you do not control, also necessitate some kind of process to ensure that your programs can still compile as expected, even if an external dependency changes. This is the main topic of the next chapter.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol type="1">
<li>What do the SOLID acronym initials stand for?</li>
<li>Why does the following piece of code violate the SRP? How would you refactor it to make sure it doesn't violate it?</li>
</ol>
<div class="sourceCode">
<pre style="padding-left: 60px"><a><span class="kw">import</span> (</a>
<a>    <span class="st">"crypto/ecdsa"</span></a>
<a>)</a>

<a><span class="kw">type</span> Document <span class="kw">struct</span> { <span class="co">//... }</span></a>

<a><span class="co">// Append adds a line to the end of the document.</span></a>
<a><span class="kw">func</span> (d *Document) Append(line <span class="dt">string</span>) { <span class="co">//...  }</span></a>

<a><span class="co">// Content returns the document contents as a string.</span></a>
<a><span class="kw">func</span> (d *Document) Content() <span class="dt">string</span> { <span class="co">//... }</span></a>

<a><span class="co">// Sign calculates a hash for the document contents, signs it with the</span></a>
<a><span class="co">// provided private key and returns back the result.</span></a>
<a><span class="kw">func</span> (d *Document) Sign(pk *ecdsa.PrivateKey) (<span class="dt">string</span>, <span class="dt">error</span>) { <span class="co">//... }</span></a></pre></div>
<ol start="3" type="1">
<li>What is the main concept behind the ISP? Discuss how would you apply it to improve the following function signature:</li>
</ol>
<div class="sourceCode">
<pre style="padding-left: 60px"><a><span class="co">// write a set of lines to a file. </span></a>
<a><span class="kw">func</span> write(lines []<span class="dt">string</span>, f *os.File) <span class="dt">error</span> {</a>
<a>    <span class="co">//...</span></a>
<a>}</a></pre></div>
<ol start="4" type="1">
<li>Explain why<span> </span><em>util</em><span> </span>is considered to be a less-than-ideal name for a Go package.</li>
<li>Why are import cycles an issue for Go programs?</li>
<li>Name some of the advantages of using the zero value when designing new Go types.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ol>
<li><kbd>aligncheck</kbd>: Identify inefficiently packed structs. URL:<span> </span><a href="https://gitlab.com/opennota/check">https://gitlab.com/opennota/check</a>.</li>
<li><kbd>bodyclose</kbd>: A static analysis tool that checks whether <kbd>res.Body</kbd> is correctly closed. URL:<span> </span><a href="https://github.com/timakin/bodyclose">https://github.com/timakin/bodyclose</a>.</li>
<li><kbd>copyfighter</kbd>: Statically analyze Go code and report functions while passing large structs by value. URL:<span> </span><a href="https://github.com/jmhodges/copyfighter">https://github.com/jmhodges/copyfighter</a>.</li>
<li><kbd>deadcode</kbd>: Report unused blocks of code. URL:<span> </span><a href="https://github.com/tsenart/deadcode">https://github.com/tsenart/deadcode</a>.</li>
<li><kbd>dupl</kbd>: Report potentially duplicated blocks of code. URL:<span> </span><a href="https://github.com/mibk/dupl">https://github.com/mibk/dupl</a>.</li>
<li>Effective Go: Tips for writing clear, idiomatic Go code.</li>
<li><kbd>errcheck</kbd>: Ensure that returned errors are checked. URL:<span> </span><a href="https://github.com/kisielk/errcheck">https://github.com/kisielk/errcheck</a>.</li>
<li><span class="smallcaps">Fowler, Martin</span>:<span> </span><em>Refactoring: Improving the Design of Existing Code.</em> Boston, MA, USA: Addison-Wesley, 1999 — ISBN 0-201-48567-2 (<a href="https://www.worldcat.org/title/refactoring-improving-the-design-of-existing-code/oclc/863697997">https://www.worldcat.org/title/refactoring-improving-the-design-of-existing-code/oclc/863697997</a>).</li>
<li><kbd>goconst</kbd>: Flag repeated strings that can be replaced with constants. URL:<span> </span><a href="https://github.com/jgautheron/goconst">https://github.com/jgautheron/goconst</a>.</li>
<li><kbd>gocyclo</kbd>: Calculate cyclomatic complexity of code. URL:<span> </span><a href="https://github.com/alecthomas/gocyclo">https://github.com/alecthomas/gocyclo</a>.</li>
<li><kbd>gofmt</kbd>: Format Go programs or check that they are properly formatted. URL:<span> </span><a href="https://golang.org/cmd/gofmt/">https://golang.org/cmd/gofmt/</a>.</li>
<li><kbd>goimports</kbd>: Update Go import lines by adding missing ones and removing unreferenced ones. URL:<span> </span><a href="https://godoc.org/golang.org/x/tools/cmd/goimports">https://godoc.org/golang.org/x/tools/cmd/goimports</a>.</li>
<li><kbd>golangci-lint</kbd>: Linter runner. URL:<span> </span><a href="https://github.com/golangci/golangci-lint">https://github.com/golangci/golangci-lint</a>.</li>
<li><kbd>golint</kbd>: Report style issues in Go programs. URL:<span> </span><a href="https://github.com/golang/lint">https://github.com/golang/lint</a>.</li>
<li><kbd>gomvpkg</kbd>: Move Go packages and update import declarations. URL:<span> </span><a href="https://godoc.org/golang.org/x/tools/cmd/gomvpkg">https://godoc.org/golang.org/x/tools/cmd/gomvpkg</a>.</li>
<li><kbd>gorename</kbd>: Perform precise type-safe renaming of identifiers in Go source code. URL:<span> </span><a href="https://godoc.org/golang.org/x/tools/cmd/gorename">https://godoc.org/golang.org/x/tools/cmd/gorename</a>.</li>
</ol>
<ol start="17">
<li><kbd>gosec</kbd>: Scan source code for potential security issues. URL:<span> </span><a href="https://github.com/securego/gosec">https://github.com/securego/gosec</a>.</li>
<li><kbd>gosimple</kbd>: Report code that can be potentially simplified. URL:<span> </span><a href="https://github.com/dominikh/go-tools/tree/master/cmd/gosimple">https://github.com/dominikh/go-tools/tree/master/cmd/gosimple</a>.</li>
<li><kbd>gosumcheck</kbd>: Ensure that all possible types in a type switch are properly handled. URL:<span> </span><a href="https://github.com/haya14busa/gosum">https://github.com/haya14busa/gosum</a>.</li>
<li><kbd>go vet</kbd>: Examine Go source code and report suspicious constructs, such as <kbd>printf</kbd> calls whose arguments do not align with the format string or shadowed variables. URL:<span> </span><a href="https://golang.org/cmd/vet/">https://golang.org/cmd/vet/</a>.</li>
<li><kbd>ineffassign</kbd>: Detect variable assignments that are not being used. URL:<span> </span><a href="https://github.com/gordonklaus/ineffassign">https://github.com/gordonklaus/ineffassign</a>.</li>
<li><span class="smallcaps">Liskov, Barbara</span>: Keynote Address <span>–</span> Data Abstraction and Hierarchy. In:<span> </span><em>Addendum to the Proceedings on Object-oriented Programming Systems, Languages and Applications (Addendum)</em>,<span> </span>OOPSLA '87. New York, NY, USA : ACM, 1987 — ISBN 0-89791-266-7 (<a href="https://www.worldcat.org/title/oopsla-87-addendum-to-the-proceedings-object-oriented-programming-systems-languages-and-applications-october-4-8-1987-orlando-florida/oclc/220450625">https://www.worldcat.org/title/oopsla-87-addendum-to-the-proceedings-object-oriented-programming-systems-languages-and-applications-october-4-8-1987-orlando-florida/oclc/220450625</a>), S. 17–34.</li>
<li><span class="smallcaps">Martin, Robert C.</span>:<em><span> </span>Clean Architecture: A Craftsman's Guide to Software Structure and Design</em>,<span> </span>Robert C. Martin Series. Boston, MA: Prentice Hall, 2017 — ISBN 978-0-13-449416-6 (<a href="https://www.worldcat.org/title/clean-architecture-a-craftsmans-guide-to-software-structure-and-design-first-edition/oclc/1105785924">https://www.worldcat.org/title/clean-architecture-a-craftsmans-guide-to-software-structure-and-design-first-edition/oclc/1105785924</a>).</li>
<li><span class="smallcaps">Meyer, Bertrand</span>:<span> </span><em>Object-Oriented Software Construction.</em> 1st. Aufl. Upper Saddle River, NJ, USA: Prentice-Hall, Inc., 1988 — ISBN 0136290493 (<a href="https://www.worldcat.org/title/object-oriented-software-construction/oclc/1134860513">https://www.worldcat.org/title/object-oriented-software-construction/oclc/1134860513</a>).</li>
<li><kbd>misspell</kbd>: Check source code for spelling mistakes. URL:<span> </span><a href="https://github.com/client9/misspell">https://github.com/client9/misspell</a>.</li>
<li><kbd>prealloc</kbd>: Identify slice declarations that could be pre-allocated. URL:<span> </span><a href="https://github.com/alexkohler/prealloc">https://github.com/alexkohler/prealloc</a>.</li>
<li><kbd>revive</kbd>: A stricter, configurable, extensible, and beautiful drop-in replacement for golint. URL:<span> </span><a href="https://github.com/mgechev/revive">https://github.com/mgechev/revive</a>.</li>
<li><kbd>safesql</kbd>: Checks code for potential SQL injection points. URL:<span> </span><a href="https://github.com/stripe/safesql">https://github.com/stripe/safesql</a>.</li>
<li><kbd>splint</kbd>: Identify functions that are too long or receive too many arguments. URL:<span> </span><a href="https://github.com/stathat/splint">https://github.com/stathat/splint</a>.</li>
</ol>
<ol start="30">
<li><kbd>structcheck</kbd>: Identify unused struct fields. URL:<span> </span><a href="https://gitlab.com/opennota/check">https://gitlab.com/opennota/check</a>.</li>
<li><kbd>unconvert</kbd>: Detect unnecessary type conversions. URL:<span> </span><a href="https://github.com/mdempsky/unconvert">https://github.com/mdempsky/unconvert</a>.</li>
<li><kbd>unindent</kbd>: Identify code that is incorrectly indented. URL:<span> </span><a href="https://github.com/mvdan/unindent">https://github.com/mvdan/unindent</a>.</li>
<li><kbd>unparam</kbd>: Detect unused function parameters. URL:<span> </span><a href="https://github.com/mvdan/unparam">https://github.com/mvdan/unparam</a>.</li>
<li><kbd>varcheck</kbd>: Detect unused variables and constants. URL:<span> </span><a href="https://github.com/opennota/check">https://github.com/opennota/check</a>.</li>
</ol>


            </article>

            
        </section>
    </body></html>