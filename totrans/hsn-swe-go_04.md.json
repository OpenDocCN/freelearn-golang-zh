["```go\n// NavigateTo applies any required changes to the drone's speed \n// vector so that its eventual position matches dst.\nfunc (d *Drone) NavigateTo(dst Vec3) error { //... }\n\n// Position returns the current drone position vector.\nfunc (d *Drone) Position() Vec3 { //... }\n\n// Position returns the current drone speed vector.\nfunc (d *Drone) Speed() Vec3 { //... }\n\n// DetectTargets captures an image of the drone's field of view (FoV) using\n// the on-board camera and feeds it to a pre-trained SSD MobileNet V1 neural\n// network to detect and classify interesting nearby targets. For more info\n// on this model see: \n// https://github.com/tensorflow/models/tree/master/research/object_detection\nfunc (d *Drone) DetectTargets() ([]*Target, error) { //... }\n```", "```go\n// NavigateTo applies any required changes to the drone's speed vector \n// so that its eventual position matches dst.\nfunc (d *Drone) NavigateTo(dst Vec3) error { //... }\n\n// Position returns the current drone position vector.\nfunc (d *Drone) Position() Vec3 { //... }\n\n// Position returns the current drone speed vector.\nfunc (d *Drone) Speed() Vec3 { //... }\n\n// CaptureImage records and returns an image of the drone's field of \n// view using the on-board drone camera.\nfunc (d *Drone) CaptureImage() (*image.RGBA, error) { //... }\n```", "```go\n// MobileNet performs target detection for drones using the \n// SSD MobileNet V1 NN.\n// For more info on this model see:\n// https://github.com/tensorflow/models/tree/master/research/object_detection\ntype MobileNet {\n // various attributes...\n}\n\n// DetectTargets captures an image of the drone's field of view and feeds\n// it to a neural network to detect and classify interesting nearby \n// targets.\nfunc (mn *MobileNet) DetectTargets(d *drone.Drone) ([]*Target, error){\n //...\n}\n```", "```go\ntype Sword struct {\n name string // Important tip for RPG players: always name your swords!\n}\n// Damage returns the damage dealt by this sword.\nfunc (Sword) Damage() int {\n return 2\n}\n\n// String implements fmt.Stringer for the Sword type.\nfunc (s Sword) String() string {\n return fmt.Sprintf(\n \"%s is a sword that can deal %d points of damage to opponents\",\n s.name, s.Damage(),\n )\n}\n```", "```go\ntype EnchantedSword struct {\n // Embed the Sword type\n Sword\n}\n\n// Damage returns the damage dealt by the enchanted sword.\nfunc (EnchantedSword) Damage() int {\n return 42\n}\n```", "```go\nspecs := []struct {\n sword interface {\n Damage() int\n }\n exp int\n}{\n {\n sword: Sword{name: \"Silver Saber\"},\n exp:   2,\n }, \n {\n sword: EnchantedSword{Sword{name: \"Dragon's Greatsword\"}},\n exp:   42,\n },\n}\n```", "```go\nfunc TestSwordDamage(t *testing.T) {\n specs := ... // see above code snippet for the spec definitions\n\n for specIndex, spec := range specs {\n if got := spec.sword.Damage(); got != spec.exp {\n t.Errorf(\"[spec %d] expected to get damage %d; got %d\", specIndex, spec.exp, got)\n }\n }\n}\n```", "```go\nspecs := []struct {\n sword fmt.Stringer\n exp   string\n}{\n {\n sword: Sword{name: \"Silver Saber\"},\n exp:   \"Silver Saber is a sword that can deal 2 points of damage to opponents\",\n }, \n {\n sword: EnchantedSword{Sword{name: \"Dragon's Greatsword\"}},\n exp:   \"Dragon's Greatsword is a sword that can deal 42 points of \n         damage to opponents\",\n },\n}\n```", "```go\nfunc TestSwordToString(t *testing.T) {\n specs := ... // see above code snippet for the spec definitions\n\n for specIndex, spec := range specs {\n if got := spec.sword.String(); got != spec.exp {\n t.Errorf(\"[spec %d] expected to get\\n%q\\ngot:\\n%q\", \n             specIndex, spec.exp, got)\n }\n }\n}\n```", "```go\n$ go test -v\n=== RUN   TestSwordDamage\n--- PASS: TestSwordDamage (0.00s)\n=== RUN   TestSwordToString\n--- FAIL: TestSwordToString (0.00s)\n        sword_test.go:55: [spec 1] expected to get\n                \"Dragon's Greatsword is a sword that can deal 42 points of\n                 damage to opponents\"\n                got:\n                \"Dragon's Greatsword is a sword that can deal 2 points of \n                  damage to opponents\"\n```", "```go\npackage main\n\nimport \"fmt\"\n\n// Adder is implemented by objects that can add two integers together.\ntype Adder interface {\n Add(int, int) int\n}\n\nfunc PrintSum(a, b int, adder Adder) {\n fmt.Printf(\"%d + %d = %d\", a, b, adder.Add(a, b))\n}\n```", "```go\npackage adder\n\n// Int adds two integer values.\ntype Int struct{}\n\n// Add returns the sum a+b.\nfunc (Int) Add(a, b int) int { return a + b }\n\n// Double adds two double values.\ntype Double struct{}\n\n// Add returns the sum a+b.\nfunc (Double) Add(a, b float64) float64 { return a + b }\n```", "```go\npackage main\n\nimport \"github.com/foo/adder\"\n\nfunc main() {\n PrintSum(1, 2, adder.Int{}) // prints: \"1 + 2 = 3\"\n\n // This line will trigger a compile-time error:\n //  cannot use adder.Double literal (type adder.Double) as type Adder \n //  in argument to PrintSum: adder.Double does not implement Adder \n //  (wrong type for Add method) \n //      have Add(float64, float64) float64\n //      want Add(int, int) int\n PrintSum(1, 2, adder.Double{})\n}\n```", "```go\nvar placeholder interface{}\n\n// Cast to io.Reader works; os.Stdin implements io.Reader\nplaceholder = os.Stdin\n_ = placeholder.(io.Reader)\n\n// Cast to io.Reader triggers a run-time panic:\n// \"panic: interface conversion: string is not io.Reader: missing method Read\"\nplaceholder = \"cast check\"\n_ = placeholder.(io.Reader)\n\n// Cast to io.Reader fails and isReader is set to false\nplaceholder = \"cast check\"\nif _, isReader := placeholder.(io.Reader); !isReader {\n fmt.Printf(\"%T does not implement io.Reader\\n\", placeholder)\n}\n```", "```go\n// Sharpen increases the damage dealt by this sword using a whetstone.\nfunc (Sword) Sharpen() {\n //...\n}\n\n// MakeBlunt decreases the damage dealt by this sword due to constant use.\nfunc (Sword) MakeBlunt(){\n //...\n}\n\n// Drop places the sword on the ground allowing others to pick it up.\nfunc (Sword) Drop(){\n //...\n}\n```", "```go\n// Attack deals damage to a monster using a sword.\nfunc Attack(m *Monster, s *Sword) {\n //...\n}\n```", "```go\n// DamageReceiver is implemented by objects that can receive weapon damage.\ntype DamageReceiver interface {\n ApplyDamage(int)\n}\n\n// Damager is implemented by objects that can be used as weapons.\ntype Damager interface {\n Damage(int)\n}\n\n// Attack deals weapon damage to target.\nfunc Attack(target DamageReceiver, weapon Damager) {\n //...\n}\n```", "```go\npackage warehouse\n\nimport \"context\"\n\n// Robot navigates the warehouse floor and fetches items for packing.\ntype Robot struct {\n // various fields\n}\n\n// AcquireRobot blocks until a Robot becomes available or until the \n// context expires.\nfunc AcquireRobot(ctx context.Context) *Robot { //...  }\n\n// Pack instructs the robot to pick up an item from its shelf and place \n// it into a box that will be shipped to the customer.\nfunc (r *Robot) Pack(item *entity.Item, to *entity.Box) error { //...  }\n```", "```go\npackage entity\n\n// Box contains a list of items that are shipped to the customer.\ntype Box struct {\n // various fields\n}\n\n// Pack qty items of type i into the box.\nfunc (b *Box) Pack(i *Item, qty int) error {\n robot := warehouse.Acquire() // **compile error: import cycle detected**\n // ...\n}\n```", "```go\npackage entity \n\nimport \"context\"\n\n// Packer is implemented by objects that can pack an Item into a Box.\ntype Packer interface {\n Pack(*Item, *Box) error\n}\n\n// AcquirePacker returns a Packer instance.\nvar AcquirePacker func(context.Context) Packer\n```", "```go\n// Pack qty items of type i into the box.\nfunc (b *Box) Pack(i *Item, qty int) error {\n p := AcquirePacker(context.Background())\n for j := 0; j < qty; j++ {\n if err := p.Pack(i, b); err != nil {\n return err \n }\n }\n return nil\n}\n```", "```go\npackage main\n\nimport \"github.com/achilleasa/logistics/entity\"\nimport \"github.com/achilleasa/logistics/warehouse\"\n\nfunc wireComponents() {\n entity.AcquirePacker = func(ctx context.Context) entity.Packer {\n return warehouse.AcquireRobot(ctx)\n }\n}\n```", "```go\npackage y\n\nimport \"z\"\n\nfunc IsPrime(v uint64) bool {\n // ... \n}\n\n// Other functions referencing types exported from package z\n```", "```go\npackage z\n\nimport \"x\"\n\n// functions referencing types exported from package x\n```", "```go\npackage x\n\nimport \"y\" // circular dependency: x imports y, y imports z and z imports x\n\nfunc IsValid(v uint64) bool {\n return v != 0 && y.IsPrime(v)\n}\n```", "```go\ntype Reader interface {\n Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n Write(p []byte) (n int, err error)\n}\n```", "```go\nfor i := 0; i < len(s); i++ {\n for j := 0; j < len(s[i]); j++ {\n value := s[i][j]\n // ...\n }\n}\n```", "```go\nfor dateIdx := 0; dateIdx < len(tickers); dateIdx++ {\n for stockIdx := 0; stockIdx < len(tickers[dateIdx]); stockIdx++ {\n value := tickers[dateIdx][stockIdx]\n // ...\n }\n}\n```", "```go\npackage kv\n\n// Store implements a key-value store which stores data to disk.\ntype Store struct { // ...  }\n\nfunc Open(path string) (*Store, error) { // Open path, load and verify data, replay pending transactions etc.  }\n\n// Put persists (key, value) to the store.\nfunc (s *Store) Put(key string, value interface{}) error { // ...  }\n\n// Get looks up the value associated with key.\nfunc (s *Store) Get(key string) (interface{}, error) { // ...  }\n\n// Close waits for any pending transactions to complete and then \n// cleanly shuts down the KV store.\nfunc (s *Store) Close() error { // ...  }\n```", "```go\npackage metrics\n\n// ReportMetrics writes the collected metrics to a KV store instance.\nfunc (c *Collector) ReportMetrics(s *kv.Store) error {\n // for each metric call s.Put(k, v)\n}\n\n// Observe records a value for a particular metric.\nfunc (c *Collector) Observe(metric string, value interface{}) {\n // ...\n}\n```", "```go\n// Generate a random file for the KV store\ntmpfile, err := ioutil.TempFile(\"\", \"metrics\")\nif err != nil {\n t.Fatal(err)\n}\ndefer func() { _ = os.Remove(tmpfile.Name()) }() // clean up when we are \n                                                 // done\n_ = tmpfile.Close()\n\n// Create KV store\ns, err := kv.Open(tmpfile.Name())\nif err != nil {\n t.Fatal(err)\n}\ndefer func() { _ = s.Close() }()\n```", "```go\nc := metrics.NewCollector()\nfor i := 0; i < 100; i++ {\n c.Observe(fmt.Sprintf(\"metric_%d\", i), i)\n}\n\nif err = c.ReportMetrics(s); err != nil {\n t.Fatal(err)\n}\n\n// Ensure that all metrics have been written to the store\n// ...\n}\n```", "```go\npackage metrics \n\n// Sink is implemented by objects that metrics can be reported to.\ntype Sink interface {\n Put(k string, v interface{}) error\n}\n\n// ReportMetrics writes the collected metrics to a Sink.\nfunc (c *Collector) ReportMetrics(s Sink) error {\n // for each metric call s.Put(k, v)\n}\n```", "```go\nfunc TestReportMetrics(t *testing.T) {\n // Use in-memory store defined inside the test package\n s := new(inMemStore)\n\n // Create collector and populate some metrics\n c := metrics.NewCollector()\n for i := 0; i < 100; i++ {\n c.Observe(fmt.Sprintf(\"metric_%d\", i), i)\n }\n\n if err = c.ReportMetrics(s); err != nil {\n t.Fatal(err)\n }\n\n // Ensure that all metrics have been written to the store...\n}\n```", "```go\npackage metrics\n\nimport \"fmt\"\n\n// Compile-time checks for ensuring a type implements a particular \n// interface.\nvar (\n // Works but allocates a dummy Foo instance on the heap.\n _ fmt.Stringer = &Foo{}\n\n // Preferred way that does not allocate anything on the heap.\n _ fmt.Stringer = (*Foo)(nil)\n)\n\ntype Foo struct { }\n\nfunc (*Foo) String() string { return \"Foo\" }\n```", "```go\npackage main\n\nimport (\n \"fmt\"\n \"sync\"\n)\n\n// SyncMap implements a thread-safe map. The zero SyncMap value is ready \n// to use.\ntype SyncMap struct {\n mu   sync.RWMutex\n data map[string]interface{}\n}\n```", "```go\n// Put inserts a key-value pair into the map.\nfunc (sm *SyncMap) Put(key string, value interface{}) {\n sm.mu.Lock()\n defer sm.mu.Unlock()\n\n if sm.data == nil {\n sm.data = make(map[string]interface{})\n }\n\n sm.data[key] = value\n}\n```", "```go\n// Get returns the value associate by key and a boolean value indicating\n// whether key is present in the map.\nfunc (sm *SyncMap) Get(key string) (interface{}, bool) {\n sm.mu.RLock()\n defer sm.mu.RUnlock()\n\n if sm.data == nil {\n return nil, false\n }\n\n return sm.data[key]\n}\n```", "```go\nfunc main() {\n var sm SyncMap // we are using the zero value of the map\n sm.Put(\"foo\", \"bar\")\n fmt.Println(sm.Get(\"foo\")) // Prints: bar true\n}\n```", "```go\ntype Foo struct {\n bar Bar\n}\n\ntype Bar struct {\n sm SyncMap\n}\n\nfunc main() {\n var foo Foo // still using a zero value\n foo.bar.sm.Put(\"answer\", 42) // storing into the embedded map also \n                                 // works.\n}\n```", "```go\nimport (\n \"fmt\"\n \"go/ast\"\n \"go/parser\"\n \"go/token\"\n)\n\n// parse a Go program into an AST representation.\nfunc parse(program string) (*token.FileSet, *ast.File, error) {\n fs := token.NewFileSet()\n tree, err := parser.ParseFile(fs, \"example.go\", program, 0)\n if err != nil {\n return nil, nil, err\n }\n return fs, tree, nil\n}\n```", "```go\n// inspectVariables visits each AST node and prints any encountered Go variable.\nfunc inspectVariables(fs *token.FileSet, tree *ast.File) {\n ast.Inspect(tree, func(n ast.Node) bool {\n ident, ok := n.(*ast.Ident)\n if !ok || ident.Obj == nil || ident.Obj.Kind != ast.Var {\n return true\n }\n\n fmt.Printf(\"%s:\\tvariable %q\\n\", fs.Position(n.Pos()), ident)\n return true\n })\n}\n```", "```go\nfunc main() {\n fs, tree, err := parse(`\n package foo \n\n var global = \"foo\"\n\n func main(){ x := 42 }\n `)\n\n if err != nil {\n fmt.Printf(\"ERROR: %v\\n\", err)\n return\n }\n\n inspectVariables(fs, tree)\n}\n```", "```go\n$ go run print_vars.go\nexample.go:4:7: variable \"global\"\nexample.go:6:16: variable \"x\"\n```", "```go\npackage main\n\nimport (\n \"net\" // Mixed stdlib and third-party packages\n \"github.com/achilleasa/kv\"\n \"fmt\" // Unused package \n)\n\ntype Server struct {\n ctx    context.Context // missing referenced import\n socket net.Conn\nstore *kv.Store // Incorrectly indented field definition\n}\n\nfunc foo(){} // Redundant line-breaks above foo()\n```", "```go\npackage main\n\nimport (\n \"context\"\n \"net\"\n\n \"github.com/achilleasa/kv\"\n)\n\ntype Server struct {\n ctx    context.Context\n socket net.Conn\n store *kv.Store\n}\n\nfunc foo() {}\n```", "```go\n# Rename foo to bar and update all imports for packages depending on foo.\n$ gomvpkg -from foo -to bar\n```", "```go\nlint: \n    golangci-lint run \\\n      --no-config --issues-exit-code=0 --deadline=30m \\\n      --disable-all --enable=deadcode  --enable=gocyclo --enable=golint \\\n      --enable=varcheck --enable=structcheck --enable=errcheck \\\n      --enable=dupl --enable=ineffassign \\\n      --enable=unconvert --enable=goconst --enable=gosec\n```", "```go\nimport (\n \"crypto/ecdsa\"\n)\n\ntype Document struct { //... }\n\n// Append adds a line to the end of the document.\nfunc (d *Document) Append(line string) { //...  }\n\n// Content returns the document contents as a string.\nfunc (d *Document) Content() string { //... }\n\n// Sign calculates a hash for the document contents, signs it with the\n// provided private key and returns back the result.\nfunc (d *Document) Sign(pk *ecdsa.PrivateKey) (string, error) { //... }\n```", "```go\n// write a set of lines to a file. \nfunc write(lines []string, f *os.File) error {\n //...\n}\n```"]