- en: Best Practices for Writing Clean and Maintainable Go Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写干净且易于维护的 Go 代码的最佳实践
- en: '"Any fool can write code that a computer can understand. Good programmers write
    code that humans can understand."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"任何傻瓜都能写出计算机能理解的代码。优秀的程序员写出人类能理解的代码。"'
- en: '- Martin Fowler ^([8])'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Martin Fowler ^([8])'
- en: Writing clean code that is easy to test and maintain is much harder than it
    seems at first glance. Fortunately, Go, as a programming language, is quite opinionated
    and comes with its own set of best practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编写易于测试和维护的干净代码比乍看之下要困难得多。幸运的是，作为编程语言，Go 非常具有意见性，并自带一套最佳实践。
- en: If you take a look at some of the available material for learning Go (for example,
    Effective Go ^([6])) or watch some talks by prominent members of the core Go team
    such as Rob Pike, it becomes evident that software engineers are gently *nudged*
    toward applying those principles when working on their own Go projects. From my
    perspective and experience, these best practices tend to have a measurable positive
    effect on the code quality metrics associated with a code base and at the same
    time aid in minimizing the accumulation of technical debt.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一些学习 Go 的可用材料（例如，Effective Go ^([6]））或观看核心 Go 团队杰出成员（如 Rob Pike）的演讲，就会很明显，软件工程师在处理自己的
    Go 项目时会被温和地 *引导* 应用这些原则。从我的视角和经验来看，这些最佳实践往往对代码质量指标有可衡量的积极影响，同时也有助于最小化技术债务的积累。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the SOLID principles of object-oriented design through the eyes
    of a Go engineer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Go 工程师的眼镜理解面向对象设计的 SOLID 原则
- en: Organizing source code at the package level
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包级别组织源代码
- en: Helpful tips and tools for writing lean and easy-to-maintain code in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中编写精简且易于维护的代码的有用技巧和工具
- en: The SOLID principles of object-oriented design
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象设计的 SOLID 原则
- en: 'The **SOLID** principles are essentially a set of rules for helping you write
    clean and maintainable object-oriented code. Let''s go over what the initials
    stand for:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 原则本质上是一套规则，旨在帮助你编写干净且易于维护的面向对象代码。让我们回顾一下这些首字母代表什么：
- en: '**Single responsibility**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**'
- en: '**Open/closed**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**'
- en: '**Liskov substitution**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**'
- en: '**Interface segregation**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**'
- en: '**Dependency inversion**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**'
- en: But hold on a minute! Is Go an object-oriented language or is it a functional
    programming language with some syntactic sugar tacked on top?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！Go 是面向对象的编程语言，还是一种带有一些语法糖的功能性编程语言？
- en: Contrary to other, traditional object-oriented programming languages, such as
    C++ or Java, Go has no built-in support for classes. However, it *does* support
    the concepts of *interfaces* and *structs*. Structs allow you to define objects
    as a collection of fields and associated methods. Even though objects and interfaces
    can be *composed* together, there is, *by design*, no support for classic object-oriented
    inheritance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他传统面向对象编程语言（如 C++ 或 Java）不同，Go 没有内置对类的支持。然而，它 *确实* 支持接口和结构体的概念。结构体允许你将对象定义为字段的集合和相关方法。尽管对象和接口可以组合在一起，但根据设计，没有对经典面向对象继承的支持。
- en: With these observations in mind, we should be referring to Go as an *object-based* programming
    language and, as such, the following principles are still valid. Let's take a
    look at each principle in more detail from the perspective of a Go software engineer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些观察结果，我们应该将 Go 作为一个 *基于对象* 的编程语言来引用，并且因此，以下原则仍然有效。让我们从 Go 软件工程师的角度更详细地审视每个原则。
- en: Single responsibility
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责
- en: 'The **single responsibility principle** (**SRP**) was described by Robert Martin ^([23]),
    a seasoned software engineer who offers, under the nickname of *Uncle Bob*, advice
    about best practices for software development. The SRP states the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**（SRP）是由 Robert Martin ^([23]）描述的，他是一位经验丰富的软件工程师，以 *Uncle Bob* 的昵称提供关于软件开发最佳实践的指导。SRP
    表述如下：'
- en: '"In any well-designed system, objects should only have a single responsibility."'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '"在任何设计良好的系统中，对象应该只具有单一职责。"'
- en: In a nutshell, object implementations should focus on doing one thing well,
    and in an efficient way. To understand how this principle works, let's examine
    a piece of code that *violates* it. In the following imaginary scenario, we are
    working for the ACME drone company where we are using Go to build a drone-based
    goods delivery system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对象实现应该专注于做好一件事情，并且以高效的方式进行。为了理解这个原则是如何工作的，让我们检查一段违反该原则的代码。在以下虚构的场景中，我们为ACME无人机公司工作，我们正在使用Go构建基于无人机的货物配送系统。
- en: 'The following code excerpt illustrates one of our initial attempts at defining
    a set of methods for the `Drone` type:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们为`Drone`类型定义一组方法的一个初始尝试：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code violates the SRP by conflating two separate responsibilities:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过混淆两个不同的责任违反了SRP：
- en: Navigating the drone
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驾驶无人机
- en: Detecting targets in close proximity to the drone
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无人机附近检测目标
- en: As the case may be, this is a valid, working solution. However, the extra coupling
    that is introduced makes the implementation harder to maintain and extend. For
    instance, what if we want to evaluate different neural network models for object-recognition
    purposes? What if we want to use the same object recognition code for different
    `Drone` types?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这是一个有效、可行的解决方案。然而，引入的额外耦合使得实现更难维护和扩展。例如，如果我们想评估不同的神经网络模型进行物体识别，怎么办？如果我们想将相同的物体识别代码用于不同的`Drone`类型，怎么办？
- en: 'So, how can we apply the SRP to improve our design? To begin with, while operating
    under the assumption that all drones come with an on-board camera, we can expose
    a method on the `Drone` object to capture and return an image using the camera.
    At this point, you may be thinking: wait, isn''t image capturing a *different *responsibility
    than navigation? The answer is: it''s all a matter of perspective! Describing
    and assigning responsibilities to objects is an art in itself, and quite a subjective
    one. Conversely, we could counter-argue that navigation needs access to various
    sources of sensor data, and the camera is one of them. In that sense, the proposed
    refactoring is *not* violating the SRP.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何应用单一职责原则（SRP）来改进我们的设计呢？首先，在假设所有无人机都配备有摄像头的情况下，我们可以在`Drone`对象上公开一个方法来捕获并返回使用摄像头拍摄的照片。此时，你可能正在想：等等，图像捕获难道不是与导航不同的责任吗？答案是：这完全取决于视角！描述和分配对象的责任本身就是一门艺术，而且相当主观。相反，我们也可以反驳说，导航需要访问各种传感器数据源，而摄像头就是其中之一。从这个意义上说，所提出的重构并没有违反SRP。
- en: 'In a second refactoring step, we can extract the target detection code into
    a separate, standalone object that would allow us to move on with the object-recognition
    model evaluation without having to modify any of the code in the `Drone` type.
    The second iteration of the implementation might look something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个重构步骤中，我们可以将目标检测代码提取到一个独立的、独立的对象中，这样我们就可以在不修改`Drone`类型中的任何代码的情况下继续进行对象识别模型评估。实现的第二次迭代可能看起来像这样：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In a separate file (possibly in a different package too), we would define the
    `MobileNet` type, which contains the implementation for our target detector:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的文件中（可能也在不同的包中），我们将定义`MobileNet`类型，其中包含我们的目标检测器的实现：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Success! We have split our original implementation into two separate objects,
    with each one having a single responsibility.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经将原始实现拆分成了两个独立的对象，每个对象都只有一个单一的责任。
- en: Open/closed principle
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: 'The **open/closed** principle was coined by Bertrand Meyer ^([24]), who stated
    the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放/封闭**原则是由伯特兰·迈耶提出的^([24])，他提出了以下观点：'
- en: '"A software module should be open for extension but closed for modification."'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “一个软件模块应该对扩展开放，但对修改封闭。”
- en: Almost all Go programs import and use types from a host of other packages, some
    being part of the Go standard library whereas other packages are provided by third
    parties. Any software engineer that imports a package into their code base should
    always safely assume that all the types that are exported by said package adhere
    to a contract that is guaranteed to be immutable. In other words, a package should
    not be able to modify the behavior of the types that are exported by *other* packages.
    While some programming languages allow this type of modification (via a technique
    colloquially referred to as *monkey patching*), the Go designers put safety mechanisms
    in place to ensure that this type of modification is strictly forbidden. Otherwise,
    Go programs would be able to violate the **closed** principle with unforeseen
    consequences for code that's deployed to production.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的 Go 程序都会导入并使用来自众多其他包的类型，其中一些是 Go 标准库的一部分，而其他包则由第三方提供。任何将包导入其代码库的软件工程师都应该始终安全地假设该包导出的所有类型都遵循一个保证不可变的契约。换句话说，一个包不应该能够修改由
    *其他* 包导出的类型的行怍。虽然一些编程语言允许这种修改（通过一种俗称为 *猴子补丁* 的技术），但 Go 设计者已经设置了安全机制来确保这种类型的修改是严格禁止的。否则，Go
    程序将能够违反 *封闭* 原则，对部署到生产环境的代码产生不可预见的后果。
- en: 'At this point, you may be wondering: does the closed principle also apply to
    code confined *within* the scope of a package? Additionally, how does Go implement
    the **open** principle? By Meyer''s definition, we should be able to use object-oriented
    principles such as inheritance or composition to extend existing code with additional
    functionality without having to modify the original code units. As we discussed
    at the beginning of the chapter, Go does not support inheritance; that leaves *composition* as
    the only viable approach for extending existing code.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道：封闭原则也适用于包 *内部* 的代码吗？此外，Go 是如何实现 *开放* 原则的？根据 Meyer 的定义，我们应该能够使用面向对象的原则，如继承或组合，以扩展现有代码并添加额外的功能，而无需修改原始代码单元。正如我们在本章开头讨论的那样，Go
    不支持继承；这留下了 *组合* 作为扩展现有代码的唯一可行方法。
- en: 'Let''s examine how these principles are intertwined through a simple example.
    After a brief stint in drone design, we decided to switch industries and focus
    on building role-playing games instead. In the following code, you can see the
    definition of a generic `Sword` type for our upcoming game:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来考察这些原则是如何交织在一起的。在短暂的无人机设计经历之后，我们决定转换行业，专注于构建角色扮演游戏。在下面的代码中，你可以看到为即将推出的游戏定义的泛型
    `Sword` 类型：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One of our design requirements states that we need to support magic items,
    for example, an enchanted sword. Since our enchanted sword is merely a generic
    sword that deals a different amount of damage, we will apply the **open **principle
    and use *composition* to create a new type that embeds the `Sword` type and overrides
    the implementation of the `Damage` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计要求之一是我们需要支持魔法物品，例如，一把附魔剑。由于我们的附魔剑仅仅是一个通用的剑，造成不同的伤害量，我们将应用 *开放* 原则，并使用 *组合*
    来创建一个新的类型，该类型嵌入 `Sword` 类型并覆盖 `Damage` 方法的实现：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, our implementation could not be complete without writing a few table-driven
    tests! The first test function that we will be creating is called `TestSwordDamage` and
    its purpose, as you can probably guess by its name, is to check whether calling `Damage` on
    the types we''ve defined so far produces the expected result. Here is how we would
    go about defining our expectations in a table-driven manner:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有编写一些基于表格的测试，我们的实现就不可能完整！我们将创建的第一个测试函数被命名为 `TestSwordDamage`，根据其名称，你可以猜到其目的是检查调用我们迄今为止定义的类型上的
    `Damage` 是否产生预期的结果。以下是我们将如何以表格驱动的方式定义我们的期望：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The implementation of `TestSwordDamage` just iterates over the defined expectations
    and verifies that each one is met:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestSwordDamage` 的实现只是遍历定义的期望并验证每个期望是否得到满足：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our second test comes with its own list of expectations. This time, the goal
    is to make sure that the output of the `String` methods for the types we defined
    previously produces the correct output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个测试附带其自己的期望列表。这次的目标是确保我们之前定义的类型上的 `String` 方法的输出是正确的：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the implementation of `TestSwordToString`, which looks more or less
    the same as `TestSwordDamage`; no surprises here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `TestSwordToString` 的实现，它与 `TestSwordDamage` 几乎相同；这里没有惊喜：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can run `go test`. However, one of our tests fails:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行“go test”。然而，我们的测试中有一个失败了：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, what caused the second test to fail? To uncover the reason behind the failed
    test, we need to dig a bit deeper into how Go methods work under the hood. Go
    methods are nothing more than syntactic sugar for invoking a *function* with an
    object instance as an argument (also known as a receiver). In the preceding code
    snippet, `String` is always invoked with a `Sword` receiver and as a result, the
    call to the `Damage` method *always*gets dispatched to the implementation that's
    been defined by `Sword` type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么导致了第二个测试失败？为了揭示失败测试背后的原因，我们需要深入挖掘 Go 方法在底层是如何工作的。Go 方法不过是调用一个以对象实例作为参数的**函数**（也称为接收器）的语法糖。在前面的代码片段中，“String”总是以“剑”接收器调用，因此对“Damage”方法的调用**总是**被调度到由“剑”类型定义的实现。
- en: This is a prime example of the **closed** principle in action: `Sword` is *not
    aware of* any type that may embed it and its set of methods *cannot be altered* by
    objects it is embedded into. It is important to point out that while the `EnchantedSword` type
    cannot modify the implementation of the methods that have been defined on the
    embedded `Sword` instance, it can still *access* and *mutate* any fields defined
    by it (including private ones if both types are defined in the same package).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**封闭**原则在行动中的典型例子：“剑”**不知道**任何可能包含它的类型，并且它的方法集**不能**被它所嵌入的对象所改变。重要的是要指出，尽管“魔法剑”类型不能修改在嵌入的“剑”实例上定义的方法的实现，但它仍然可以**访问**和**修改**它定义的任何字段（如果两种类型都在同一个包中定义，包括私有字段）。
- en: Liskov substitution
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里氏替换
- en: 'The third principle from SOLID that we will be exploring is the **Liskov substitution
    principle** (**LSP**). It was introduced by Barbara Liskov in 1987 while delivering
    a keynote session at the **Object-Oriented Programming Systems, Languages, and
    Applications** (**OOPSLA**) conference ^([22]). The formal definition of LSP is
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的 SOLID 的第三个原则是**里氏替换原则**（**LSP**）。它是由 Barbara Liskov 在 1987 年在**面向对象编程系统、语言和应用**（**OOPSLA**）会议上的主题演讲中提出的。LSP
    的正式定义如下：
- en: If, for each object, `O1` of type `S` there is an object `O2` of type `T` such
    that for all programs `P` defined in terms of `T`, the behavior of `P` is unchanged
    when `O1` is substituted for `O2`, then `S` is a subtype of `T`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对于每个类型为“S”的对象“O1”，存在一个类型为“T”的对象“O2”，并且对于所有以“T”定义的程序“P”，当用“O1”替换“O2”时，程序“P”的行为保持不变，那么“S”是“T”的子类型。
- en: In layman's terms, two types are *substitutable* if their exhibited behavior
    follows exactly the same contract, thereby making it *impossible* for *callers* to
    distinguish between them. Thinking in pure OO terms, this is probably the textbook
    use case for abstract and concrete classes. As we mentioned in a previous section,
    Go does not support the concept of classes or inheritance but instead relies on *interfaces* as
    the means for facilitating type substitutions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用通俗的话来说，如果两种类型的展现行为完全遵循相同的契约，那么它们是**可替换的**，因此**调用者**无法区分它们。从纯面向对象的角度思考，这可能是抽象类和具体类的典型用例。正如我们在前面的部分提到的，Go
    不支持类或继承的概念，而是依靠**接口**作为促进类型替换的手段。
- en: One interesting peculiarity of Go, at least for people coming from a Java or
    C++ background, is that Go interfaces are *implicit*. Each Go type defines an
    implicit interface consisting of all the methods it implements. This design decision
    allows the Go compiler to perform a *compile-time* variant of **duck typing** (the
    formal term for this is **structural typing**) when deciding whether an object
    instance can be passed as a substitute to a function or method that expects a
    particular interface as its argument.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言的一个有趣特性，至少对于来自 Java 或 C++ 背景的人来说是这样，就是 Go 接口是**隐式的**。每个 Go 类型定义了一个隐式的接口，该接口由它实现的所有方法组成。这个设计决策允许
    Go 编译器在决定一个对象实例是否可以作为函数或方法参数的替代品时，执行一个**编译时**的**鸭子类型**变体（这个术语的正式名称是**结构化类型**）。
- en: 'The term duck typing has its roots in an old adage referred to as the *duck
    test*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型这个术语的根源在于一个古老的谚语，被称为**鸭子测试**：
- en: '"If it looks like a duck and it quacks like a duck, then it is a duck."'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “如果它看起来像一只鸭子，并且它像鸭子一样嘎嘎叫，那么它就是一只鸭子。”
- en: Essentially, when given an object and an interface, the object can be used in
    place of the interface *if* its method set contains methods whose name and signature
    match the ones defined by the interface. Not having to explicitly indicate which
    interfaces a type implements is quite a handy feature. It helps us decouple the
    definition of an object (which may be an external or third-party package) from
    the place where the interface is defined and/or used.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，当给定一个对象和一个接口时，如果该对象的方法集包含与接口定义的方法名称和签名匹配的方法，则该对象可以用作接口的替代。无需显式指出类型实现了哪些接口是一个非常方便的特性。它帮助我们解耦对象的定义（可能是外部或第三方包）与接口定义和/或使用的地方。
- en: 'In the following code snippet, we''re defining the `Adder` interface and a
    simple function called `PrintSum` that uses any type that satisfies this interface
    to add two numbers together:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们定义了`Adder`接口和一个简单的名为`PrintSum`的函数，该函数使用满足此接口的任何类型将两个数字相加：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `adder` package includes the `Int` type, which satisfies the `Adder` interface,
    and another type called `Double`, which doesn''t; even though it defines a function
    called `Add`, you will notice that the argument *types* are different:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`adder`包包括`Int`类型，它满足`Adder`接口，还有一个名为`Double`的类型，它不满足；尽管它定义了一个名为`Add`的函数，但你将注意到*参数类型*是不同的：'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code snippet illustrates how compile-time interface substitution
    checks work. We can safely pass `Int` instances to `PrintSum` as `Int` implicitly
    satisfies the `Adder` interface. However, attempting to pass an instance of `Double` to `PrintSum` will
    trigger a compile-time error:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了编译时接口替换检查是如何工作的。我们可以安全地将`Int`实例传递给`PrintSum`，因为`Int`隐式满足`Adder`接口。然而，尝试将`Double`实例传递给`PrintSum`将触发编译时错误：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the cases where the type of the object to be substituted is not known at
    compile time, the compiler will automatically generate code to perform the check
    at runtime:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象要替换的类型在编译时未知的情况下，编译器将自动生成代码以在运行时执行检查：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you aren't sure whether a type instance or an `interface{}` can be cast
    to another type or interface at runtime, it is often good practice to use the
    dual return value variant of the cast operator (the *last* case in the preceding
    code sample) to avoid potential panics while your program is executing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定类型实例或`interface{}`在运行时是否可以转换为另一个类型或接口时，通常是一个好习惯使用双重返回值的类型转换操作符（前述代码样本中的*最后一个*情况）来避免程序执行时的潜在恐慌。
- en: Interface segregation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离
- en: Similar to the SRP, the **interface segregation principle** (**ISP**) was also
    coined by Robert Martin. According to this principle, clients should not be forced
    to depend upon the interfaces that they do not use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与SRP类似，**接口隔离原则**（ISP）也是由罗伯特·马丁提出的。根据这个原则，客户端不应该被迫依赖于它们不使用的接口。
- en: 'This principle is quite important as it forms the basis for applying the other
    principles we''ve discussed so far. Going back to our previous RPG example, let''s
    assume that we have augmented our `Sword` object with a few more interesting methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则非常重要，因为它构成了应用我们之前讨论的其他原则的基础。回到我们之前的RPG示例，假设我们已经给我们的`Sword`对象添加了一些更有趣的方法：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So, how are we going to use weapons in our game? Obviously, we need to introduce
    some *monsters* for the player to attack! This is what the signature of an `Attack` function could potentially
    look like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在游戏中使用武器呢？显然，我们需要引入一些*怪物*供玩家攻击！这可能是一个`Attack`函数的潜在签名：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, there are a few issues with the preceding definition.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前述定义存在一些问题。
- en: 'The *implicit* (see the previous section) `Sword` interface is quite *open*,
    that is, it includes a bunch of other methods that our `Attack` implementation
    has no need for. In fact, the software engineer implementing `Attack` may be tempted
    to include additional *business logic* rules that rely on the availability of
    those methods:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐式*（参见上一节）的`Sword`接口非常*开放*，也就是说，它包含了一堆我们的`Attack`实现不需要的其他方法。实际上，实现`Attack`的软件工程师可能会倾向于包括一些额外的*业务逻辑*规则，这些规则依赖于那些方法的可用性：'
- en: Make the sword blunt after a number of attacks
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在攻击了一定次数后使剑变钝
- en: Cause the player to drop the sword if the monster uses some special armor
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果怪物使用一些特殊装甲，导致玩家丢弃剑
- en: Going down this path would lead to a violation of the SRP and potentially make
    unit testing of the code harder. In addition, the proposed definition of `Attack` induces
    a strong coupling with objects that either are of the `Sword` type or are other
    types that *embed* it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这条道路走下去将违反 SRP，并可能使代码的单元测试变得更加困难。此外，提出的`Attack`定义与`Sword`类型或嵌入它的其他类型的对象产生了强烈的耦合。
- en: 'These two observations fully justify the existence of a famous Go proverb that
    was originally attributed to Rob Pike:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个观察结果完全证明了以下著名的 Go 谚语的合理性，该谚语最初归功于 Rob Pike：
- en: '"The bigger the interface, the weaker the abstraction."'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '"接口越大，抽象越弱。"'
- en: While Go implicit interfaces (see the previous section) would allow us to pass *any* type
    that embeds `Sword` (perhaps an `EnchantedSword` from our previous example), our
    requirements will undoubtedly state that `Attack` must be able to work with other
    types of weapons, for example, projectiles or magic spells.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 的隐式接口（见上一节）允许我们传递任何嵌入`Sword`（例如，可能是我们之前示例中的`EnchantedSword`）的类型，但我们的要求无疑会声明`Attack`必须能够与其他类型的武器一起工作，例如，投射物或魔法咒语。
- en: On the other hand, `Attack` expects a `Monster` instance as its first argument.
    It stands to reason that the player should be able to use weapons to deal damage
    to non-monster entities, for example, to break down a bolted door or to cut the
    rope suspending the chandelier from the ceiling. Moreover, ideally, we would want
    to reuse the same implementation when monsters attack the player.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Attack`期望其第一个参数是一个`Monster`实例。从逻辑上讲，玩家应该能够使用武器对非怪物实体造成伤害，例如，破坏螺栓固定的门或切断悬挂在天花板上的吊灯的绳子。此外，理想情况下，我们希望当怪物攻击玩家时能够重用相同的实现。
- en: 'These are all great use cases for applying the ISP. Let''s assume that our `Attack` implementation
    only needs the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是应用 ISP 的绝佳用例。假设我们的`Attack`实现只需要以下内容：
- en: To figure out the amount of damage that's caused by a weapon
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确定武器造成的伤害量
- en: Some mechanism to apply the damage to a particular *target*
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种将伤害应用于特定**目标**的机制
- en: 'With the preceding observations, we could change the signature of `Attack` to
    accept two explicit interfaces as arguments:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上述观察，我们可以将`Attack`函数的签名更改为接受两个显式接口作为参数：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this rather simple change, we kill two birds with one stone. Firstly, our
    code is more abstract and it's much easier to test its behavior by providing our
    own test types that implement the required interfaces. Secondly, our interfaces
    are, quite literally, the smallest possible; this fact not only makes the SRP
    application possible but it also alludes to a simpler implementation. As evidenced
    by a quick scan of the Go standard library, single-method interfaces (for example, `Reader`
    and `Writer` interfaces in the `io` package) are a rather prevailing idiom between
    the Go authors.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个相当简单的改动，我们一举两得。首先，我们的代码更加抽象，通过提供我们自己的实现所需接口的测试类型，可以更容易地测试其行为。其次，我们的接口实际上是最小的；这一事实不仅使得SRP的应用成为可能，而且也暗示了一个更简单的实现。正如对
    Go 标准库的快速浏览所证实的，单方法接口（例如，`io`包中的`Reader`和`Writer`接口）是 Go 作者之间相当普遍的惯用法。
- en: Dependency inversion
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置
- en: 'Yet another principle identified by Robert Martin is the **dependency inversion principle**
    (**DIP**). It is, slightly verbosely, defined as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个由罗伯特·马丁（Robert Martin）提出的原理是**依赖倒置原则**（DIP）。它稍微有点冗长，定义如下：
- en: '"High-level modules should not depend on low-level modules. Both should depend
    on abstractions. Abstractions should not depend on details. Details should depend
    on abstractions."'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '"高级模块不应依赖于低级模块。两者都应依赖于抽象。抽象不应依赖于细节。细节应依赖于抽象。"'
- en: The DIP essentially summarizes all the other principles we've discussed so far.
    If you have been applying the rest of the SOLID principles to your code base,
    you will find that it already adheres to the preceding definition!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DIP 实质上总结了我们迄今为止讨论的所有其他原则。如果你已经将 SOLID 原则的其余部分应用于你的代码库，你会发现它已经符合前面的定义！
- en: The introduction and use of interfaces aids in decoupling high-level and low-level
    modules. The open/closed principle ensures that interfaces themselves are immutable
    but does not preclude us from coming up with any number of alternative implementations
    (the *details* bit in the preceding definition) that satisfy an implicit or explicit
    interface. At the same time, the LSP guarantees that we can rely on the established
    abstractions while also having the flexibility to swap the underlying implementation
    at compile time or even runtime without worrying about breaking our applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的引入和使用有助于解耦高级和低级模块。开放/封闭原则确保接口本身是不可变的，但这并不妨碍我们提出任何数量的替代实现（前述定义中的*细节*部分），以满足隐式或显式的接口。同时，LSP保证我们可以在依赖既定抽象的同时，也拥有在编译时甚至运行时灵活替换底层实现的能力，而不用担心破坏我们的应用程序。
- en: Applying the SOLID principles
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用SOLID原则
- en: If you decide to apply these principles to your own projects, you will achieve
    greater flexibility in the way you design, connect to, and test software components,
    with the added benefit of requiring less time to extend the code base in the future.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定将这些原则应用到自己的项目中，你将在设计、连接和测试软件组件的方式上获得更大的灵活性，并且在未来扩展代码库时所需的时间会更少。
- en: However, one thing to keep in mind is that there is *no such thing as a free
    lunch*. What you gain in flexibility, you lose in the increased size of your code
    base; this could adversely affect the complexity metrics associated with the project.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一点需要记住的是，*没有免费的午餐*。你在灵活性方面获得的收益，你会在代码库的增大中失去；这可能会对项目的复杂度指标产生不利影响。
- en: In my view, this trade-off is not necessarily a bad thing. By following the
    best practices around testing your code (a subject that will be explored in detail
    in upcoming chapters), you can tame any potential increase in code complexity.
    At the same time, encountering difficulties while writing tests is often a good
    sign that your code is probably violating one or more of the SOLID principles
    and needs refactoring.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这种权衡并不一定是坏事。通过遵循测试代码的最佳实践（将在后续章节中详细探讨），你可以驯服任何潜在的代码复杂度增加。同时，在编写测试时遇到困难通常是代码可能违反一个或多个SOLID原则并需要重构的好迹象。
- en: Finally, I would like to stress that even though we analyzed the SOLID principles
    through the eyes of a Go engineer, the principles themselves have a much wider
    scope and can also be applied to system design in general. For instance, in a
    microservice-based deployment, you should be aiming to build and deploy services
    with a single purpose (SRP) that communicate through clearly defined contracts
    and boundaries (ISP).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想强调的是，尽管我们是通过Go工程师的视角来分析SOLID原则，但原则本身具有更广泛的适用范围，也可以应用于系统设计。例如，在基于微服务的部署中，你应该旨在构建和部署具有单一目的（SRP）的服务，并通过明确定义的合同和边界进行通信（ISP）。
- en: Organizing code into packages
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码组织成包
- en: As we saw in the previous section, the application of the SOLID principles works
    as a guide for splitting our code base into smaller packages where each package
    implements a specific bit of functionality and its interfaces serve as the glue
    for wiring packages together when building larger systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，应用SOLID原则可以作为指导，将我们的代码库拆分成更小的包，其中每个包实现特定的功能，其接口在构建更大系统时作为连接包的粘合剂。
- en: In this section, we will be examining the idiomatic Go way for naming packages,
    as well as some common potential pitfalls you may encounter while authoring code
    that relies on a complex package dependency graph.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨命名包的Go语言惯用方法，以及你在编写依赖于复杂包依赖图的代码时可能遇到的一些常见潜在陷阱。
- en: Naming conventions for Go packages
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go包的命名约定
- en: 'Let''s say you come across a package named `server`. Is that a good name, as
    per the preceding suggestion? Well, *obviously*, we can guess that it''s some *kind* of
    server, but what kind is that? Is it an HTTP server, for instance, a TCP-based
    server implementing a text-based wire protocol, or maybe a UDP-based server for
    an online game? Some of you may argue that the package might export a type or
    function that alludes to the package''s purpose (for example, `NewHTTPServer`).
    That certainly disambiguates things, but it also introduces a bit of repetition:
    in this particular case, the *server* literal is present in both the package name
    and a function exposed by it. As we will see in the *Improving code quality metrics
    with the help of linters* section, this practice is considered an anti-pattern
    and may cause linter warnings.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你遇到一个名为 `server` 的包。根据前面的建议，这个名字好吗？嗯，*显然*，我们可以猜测它是一种服务器，但那是什么类型的服务器呢？是 HTTP
    服务器，比如基于 TCP 实现基于文本的线协议的服务器，或者可能是一个基于 UDP 的在线游戏服务器？有些人可能会争论，这个包可能导出一种类型或函数，暗示了包的目的（例如，`NewHTTPServer`）。这确实消除了歧义，但也引入了一点重复：在这个特定的情况下，*server*
    文字既出现在包名中，也出现在它暴露的函数中。正如我们将在 *使用 linter 提高代码质量指标* 部分中看到的那样，这种做法被认为是一种反模式，可能会导致
    linter 警告。
- en: Go package names should be short and concise and provide a clear indication
    of their purpose to the *intended* users of the package.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Go 包名应简短、简洁，并为包的 *预期* 用户提供对其用途的明确指示。
- en: 'By browsing the code of the Go standard library, we can find quite a few characteristic
    examples of this clear package-naming philosophy:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览 Go 标准库的代码，我们可以找到许多这种清晰包命名哲学的特征性例子：
- en: The `net` package provides mechanisms for creating various types of network
    listeners (tcp, udp, Unix domain sockets, and more).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net` 包提供了创建各种类型网络监听器的机制（TCP、UDP、Unix 域套接字等）。'
- en: 'The `net/http` package provides, among other things, an HTTP server implementation:
    the `http.Server` type name is pretty unambiguous with respect to its use.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http` 包提供了许多功能，其中包括 HTTP 服务器实现：`http.Server` 类型名称在用途上相当明确。'
- en: While package names should be kept short, you should avoid coming up with package
    names that can potentially clash with variable names that are commonly used by
    the code importing the package. Otherwise, package users would have to import
    the package using an *alias* (that is, import *blah* path-to-package). In such
    cases, it is usually better to abbreviate the package name (if possible). Typical
    examples from the Go standard library include the `fmt` and `bufio` packages.
    More specifically, the `bufio` package is named as such to avoid name clashes
    with `buf`, a variable name you are very likely to encounter when dealing with
    a piece of code that uses buffers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应该保持包名简短，但你应避免提出可能与其他代码中常用变量名冲突的包名。否则，包用户将不得不使用别名（即导入 *blah* path-to-package）来导入包。在这种情况下，通常最好（如果可能的话）缩写包名。Go
    标准库中的典型例子包括 `fmt` 和 `bufio` 包。更具体地说，`bufio` 包之所以命名为如此，是为了避免与 `buf` 这个变量名发生冲突，你很可能在处理使用缓冲区的代码时会遇到这个变量名。
- en: Finally, in contrast to other programming languages whose standard libraries
    usually come with utility libraries or packages with generic-sounding names such
    as *common* or *util*, Go is quite opinionated *against* this practice. This is
    actually justified from the SOLID principles' point of view as those packages
    are more likely to be violating the SRP versus aptly named packages whose name
    enforces a logical boundary for their contents. To add to this, as the number
    of published Go packages grows over time, searching for and locating packages
    with generic-sounding names will become more and more difficult.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与其他标准库通常附带实用库或具有通用名称（如 *common* 或 *util*）的包的编程语言相比，Go 对这种做法持 *反对* 的态度。这实际上是从
    SOLID 原则的角度来看是有道理的，因为这些包更有可能违反 SRP，而恰当地命名的包则通过其名称强制内容具有逻辑边界。此外，随着发布的 Go 包数量随着时间的推移而增长，搜索和定位具有通用名称的包将变得越来越困难。
- en: Circular dependencies
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环依赖
- en: For a Go program to be well formed, its import graph must be acyclic; in other
    words, it must not contain any loops. Any violation of this predicate will cause
    the Go compiler to emit an error. As the systems you are building grow in complexity,
    so does the probability of eventually hitting the dreaded *import cycle detected*error.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Go 程序结构良好，其导入图必须是无环的；换句话说，它不能包含任何循环。任何违反此谓词的行为都会导致 Go 编译器发出错误。随着你构建的系统复杂性增加，最终遇到令人讨厌的“检测到导入循环”错误的概率也会增加。
- en: Usually, import cycles are an indication of a fault in the design of a software
    solution. Fortunately, in many cases, we can refactor our code and work around
    most import cycles. Let's take a closer look at some common cases where circular
    dependencies occur and some strategies for dealing with them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，导入循环是软件解决方案设计中存在缺陷的迹象。幸运的是，在许多情况下，我们可以重构我们的代码，并绕过大多数导入循环。让我们更仔细地看看循环依赖通常发生的一些常见情况以及处理它们的策略。
- en: Breaking circular dependencies via implicit interfaces
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过隐式接口打破循环依赖
- en: In the following imaginary scenario, we are working for a start-up company that
    is building the software that's responsible for controlling fully automated warehouses.
    Autonomous robots equipped with gripping arms and lasers (what could possibly
    go wrong?) are busy moving around the warehouse floor locating and picking up
    order items from the shelves and placing them in cardboard boxes that are then
    shipped to the customers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下虚构的场景中，我们为一家初创公司工作，该公司正在构建负责控制全自动仓库的软件。配备抓取臂和激光的自主机器人（可能出什么问题？）正忙于在仓库地板上移动，定位并从货架上取订单物品，并将它们放入随后被运送给客户的纸箱中。
- en: 'This is a tentative definition for a warehouse `Robot`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是仓库 `Robot` 的一个临时定义：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code snippet, the `Item` and `Box` types live in an external
    package called `entity`. All goes well until one day when someone attempts to
    introduce a new helper method to the `Box` type, which, unfortunately, introduces
    an import cycle:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`Item` 和 `Box` 类型位于一个名为 `entity` 的外部包中。一切顺利，直到有一天有人试图向 `Box` 类型引入一个新的辅助方法，不幸的是，这引入了一个导入循环：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Technically speaking, this is a bad design decision: boxes and items should
    not really be aware of the robot''s existence. However, for the sake of this argument,
    we will ignore this design flaw and try to work around this problem using Go''s
    support for implicit interfaces. The first step would be to define a `Packer` interface
    within the `entity` package. Secondly, we would need to provide an abstraction
    for obtaining an instance of `Packer`, as shown in the following code snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，这是一个糟糕的设计决策：箱子和物品实际上不应该知道机器人的存在。然而，为了这个论点，我们将忽略这个设计缺陷，并尝试使用 Go 对隐式接口的支持来解决这个问题。第一步是在
    `entity` 包内定义一个 `Packer` 接口。其次，我们需要提供一个获取 `Packer` 实例的抽象，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these two mechanisms in place, the helper method can work *without* the
    need to import the `warehouse` package:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个机制到位的情况下，辅助方法可以在不需要导入 `warehouse` 包的情况下工作：*无需* 导入 `warehouse` 包。
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last bit of the puzzle that we need to address is how we are going to initialize `AcquirePacker` without
    importing the `warehouse` package. The only way we can do that is via a *third*
    package that imports the `warehouse` and `entity` packages:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的最后一个难题是如何在不导入 `warehouse` 包的情况下初始化 `AcquirePacker`。我们唯一能这样做的方式是通过一个导入
    `warehouse` 和 `entity` 包的 *第三个* 包：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code snippet, the `wireComponents` function ensures that the `warehouse` and
    `entity` packages are wired together without triggering any circular dependency
    errors.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`wireComponents` 函数确保 `warehouse` 和 `entity` 包被连接在一起，而不会触发任何循环依赖错误。
- en: Sometimes, code repetition is not a bad idea!
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有时候，代码重复并不是一个坏主意！
- en: You have probably heard of the **don't repeat yourself** (**DRY**) principle
    before. The main idea behind DRY is to avoid code repetition by aiming to write
    reusable code that can be included where required. But is DRY *always* a good
    idea?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前听说过 **不要重复自己** （**DRY**）原则。DRY 的主要思想是通过编写可重用的代码来避免代码重复，这些代码可以在需要的地方包含。但
    DRY 是否 *总是* 一个好主意？
- en: Go packages serve as a nice abstraction for organizing code into modular, reusable
    units. But, generally speaking, a good practice for writing Go programs is to
    try to keep your import dependency graph shallow and wide; this sounds counter-intuitive
    considering it's probably the exact opposite of what the DRY principle advocates: *include
    instead of repeat*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Go包作为组织代码到模块化和可重用单元的不错抽象。但，一般来说，编写Go程序的良好实践是尽量保持你的导入依赖图浅而宽；考虑到这可能是DRY原则所倡导的“包含而非重复”的相反，这听起来可能有些反直觉。
- en: When the dependency graph becomes deeper, circular dependencies become more
    likely, this time due to *transitive* dependencies, that is, dependencies of packages
    that your code imports. In the following example, we have three packages: `x`, `y`, and `z`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖图变得更深时，循环依赖的可能性也会增加，这次是由于**传递性**依赖，即你代码导入的包的依赖。在以下示例中，我们有三个包：`x`、`y`和`z`。
- en: 'Package *y* defines a helper function called `IsPrime`, which, as you can probably
    guess by its name, returns a Boolean indicating whether its input is a prime number
    or not. The same package imports and uses some types from package `*z*`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 包`y`定义了一个名为`IsPrime`的辅助函数，正如你可能从其名称中猜测到的，它返回一个布尔值，指示其输入是否为素数。同一个包导入并使用来自包`z`的一些类型：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Package `z` imports some types from package `x`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 包`z`从包`x`导入了一些类型：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So far, so good. A few days go by and then we decide to add a new helper function
    to package `x` called `IsValid`. The function needs to perform a primality test
    and, since package `y` already provides `IsPrime`, we decide to follow the DRY
    approach and import *y* into our code, causing a circular dependency:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。几天后，我们决定向包`x`添加一个新的辅助函数，名为`IsValid`。该函数需要进行素性测试，由于包`y`已经提供了`IsPrime`，我们决定遵循DRY原则，将`y`导入到我们的代码中，从而造成循环依赖：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In cases like this, and assuming the code we need from the included package
    is small enough, we can just duplicate it (along with its tests) and avoid the
    extra import that triggers a circular dependency. As a popular Go proverb goes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们需要的包含包中的代码足够小，我们可以直接复制它（包括其测试）并避免触发循环依赖的额外导入。正如一句流行的Go谚语所说：
- en: '"A little copying is better than a little dependency."'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: “一点复制胜过一点依赖。”
- en: Tips and tools for writing lean and easy-to-maintain Go code
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写精简且易于维护的Go代码的技巧和工具
- en: In the upcoming sections, we will be covering some techniques, tools, and best
    practices that can assist you in writing more concise and clean code that is easier
    to test and at the same time help you get some praise from your colleagues and
    code reviewers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍一些技术、工具和最佳实践，这些可以帮助你编写更简洁、更易于测试的代码，同时也能帮助你从同事和代码审查员那里获得一些赞誉。
- en: Most of the topics that we will be discussing are specific to Go, but some of
    the principles can be generalized and applied to other programming languages and
    software engineering in general.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的大部分主题都是特定于Go语言的，但其中的一些原则可以推广并应用于其他编程语言和软件工程领域。
- en: Optimizing function implementations for readability
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化函数实现以提高可读性
- en: 'During my early university days, my CS professors would be adamant about keeping
    function blocks short and concise. Their advice went along the lines of the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我大学早期，我的计算机科学教授们会坚决主张保持函数块短小精悍。他们的建议如下：
- en: '"If a function implementation does not fit on a single screen, then it must
    be split up into smaller functions."'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: “如果一个函数实现无法适应单个屏幕，那么它必须被拆分成更小的函数。”
- en: 'Keep in mind that these guidelines have their roots in an era when by *screen*,
    people were referring to the amount of code that could fit in an 80×25 character
    terminal! Fast forward to today where things have changed: software engineers
    have access to high-resolution monitors, editors, and bespoke IDEs that come preloaded
    a wide gamut of sophisticated analysis and refactoring tools. Still, the same
    bit of advice is just as important for writing code that is easy for *others* to
    review, extend, and maintain.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些指南的根源在于一个时代，那时人们通过“屏幕”来指代能够适应80×25字符终端的代码量！快进到今天，情况已经发生了变化：软件工程师可以访问高分辨率的显示器、编辑器和预装了广泛复杂分析和重构工具的定制IDE。尽管如此，对于编写易于他人审查、扩展和维护的代码，这些建议依然同样重要。
- en: In the *Single responsibility* section, we discussed the merits of the SRP.
    Unsurprisingly, the same principle also applies to function blocks and is something
    to keep at the back of your mind when coding.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在*单一职责*部分，我们讨论了SRP的优点。不出所料，同样的原则也适用于函数块，这是你在编码时需要牢记在心的事情。
- en: By decomposing a complex function into smaller functions, the code becomes easier
    to read and reason about. This may not seem important at first, but think about
    a case where you don't touch the code for a couple of months and then need to
    dive back into it while trying to track down a bug. As a bonus, the isolated bits
    of logic also become easier to test, especially if you are following the practice
    of writing table-driven tests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将复杂函数分解为更小的函数，代码变得更加易于阅读和推理。这起初可能看起来并不重要，但想想这种情况：你几个月没有接触代码，然后需要重新深入其中，同时试图追踪一个错误。作为额外的好处，独立的逻辑块也更容易进行测试，特别是如果你遵循编写表格驱动测试的实践。
- en: Naturally, it follows that the same approach can be applied to existing code.
    If you find yourself navigating through a lengthy function that contains deeply
    nested `if`/`else` blocks, repeated blocks of code, or its implementation tackles
    several seemingly unrelated concerns, it would be a great opportunity to apply
    some drive-by refactoring and extract any potential self-contained blocks of logic
    into separate functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，同样的方法也可以应用于现有代码。如果你发现自己正在导航一个包含深层嵌套的`if`/`else`块、重复的代码块或其实施处理几个看似不相关的关注点的长函数，那么应用一些即兴重构并提取任何潜在的独立逻辑块到单独的函数中将会是一个极好的机会。
- en: Additionally, when creating new functions or splitting existing functions into
    smaller ones, a good idea is to arrange the functions so that they appear in call
    order within the file they are defined in, that is, if `A()` calls `B()` and `C()`,
    then both `B()` and `C()` must appear below, but not necessarily immediately after, `A()`.
    This makes it much easier for other engineers (or people just curious to understand
    how something works) to skim through existing code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在创建新函数或将现有函数拆分为更小的函数时，一个好的主意是将函数排列得在它们定义的文件中按调用顺序出现，也就是说，如果`A()`调用`B()`和`C()`，那么`B()`和`C()`都必须出现在下面，但不一定紧接在`A()`之后。这使得其他工程师（或只是好奇想了解某物是如何工作的普通人）浏览现有代码变得更加容易。
- en: Each rule comes with exceptions and this rule is no different. Unless the compiler
    is very good at inlining functions, splitting the business logic across functions
    sometimes takes a toll on performance. Although the performance hit is, in many
    cases, insignificant, when the end goal is to produce high-performance code that
    contains tight inner loops or code that is expected to be called with high frequency,
    it may be a good idea to keep the implementation neatly tucked within a single
    function to avoid the extra Go runtime overhead that's incurred when making function
    calls (for example, pushing arguments to the stack, checking that the stack is
    large enough for the callee, and popping things off the stack when the function
    call returns).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每条规则都有例外，这条规则也不例外。除非编译器非常擅长内联函数，否则将业务逻辑分散到多个函数中有时会对性能造成影响。尽管在许多情况下性能损失微不足道，但当最终目标是生成包含紧密内循环或预期高频调用的代码时，将实现整齐地封装在单个函数中可能是一个好主意，以避免在调用函数时产生的额外Go运行时开销（例如，将参数推送到栈上，检查调用者是否有足够的栈空间，以及函数调用返回时从栈上弹出东西）。
- en: There is always a trade-off between code readability and performance. When dealing
    with complex systems, readability is oftentimes preferred, but at the end of the
    day, it's up to you and your team to figure out which mix of readability versus
    performance works best for your particular use case.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的可读性和性能之间总是存在权衡。当处理复杂系统时，可读性通常更受欢迎，但最终，这取决于你和你的团队来确定哪种可读性和性能的混合最适合你的特定用例。
- en: Variable naming conventions
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量命名约定
- en: There is an ongoing debate regarding the ideal length for variables and type
    names in Go programs. On one hand, there are the proponents of the belief that
    all variables should have clear and self-descriptive names. This is a fairly common
    philosophy for people who have spent some time authoring code in the Java ecosystem.
    On the other side of the fence, we have the *minimalists*, that is, people who
    advocate for shorter identifier names, arguing that longer identifiers are too
    verbose.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Go 程序中变量和类型名称的理想长度，存在持续的争论。一方面，有支持所有变量都应该有清晰且自我描述性名称的信仰者。这对于在 Java 生态系统编写过代码的人来说是一种相当常见的哲学。另一方面，我们有*简约主义者*，即那些主张使用较短标识符名称的人，他们认为较长的标识符太冗长。
- en: 'The Go language authors certainly seem to be members of the latter camp. Case
    in point, here is the definition of two of the most popular Go interfaces: `io.Reader` and `io.Writer`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言作者显然属于后一种阵营。以两个最受欢迎的 Go 接口`io.Reader`和`io.Writer`的定义为例：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The same short identifier pattern is widely used throughout the Go standard
    library code base. My take on this is that using *shorter* but still *descriptive* variable
    names is a good thing as long as other engineers that will be called to work on
    the code base in the future can easily understand their purpose within the scope
    that each variable is being used in.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的短标识符模式在 Go 标准库代码库中被广泛使用。我认为，只要未来的工程师能够轻松理解它们在各自作用域内的用途，使用*较短*但仍然*描述性*的变量名是好事。
- en: 'The most common example of this approach is naming index variables for nested
    loops where, typically, a single-letter variable such as `i`, `j`, and so on is
    used. In the following code snippet, however, the index variables are used to
    access an element of the multi-dimensional slice `s`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的常见例子是为嵌套循环命名索引变量，通常使用单个字母变量，如`i`、`j`等。然而，在以下代码片段中，索引变量被用来访问多维切片`s`的元素：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If someone who''s not familiar with this part of the code is tasked with reviewing
    a pull request containing the preceding loop, they may find themselves struggling
    to figure out what `s` is and what each index level represents! Since the shortened
    variable names provide almost no information regarding their true purpose, to
    answer these questions, the reviewer would have to jump around the code base looking
    for clues: look up the type for `s`, then go to its definition, and so on and
    so forth. Now, contrast the preceding code block with the following one, which
    performs exactly the same function but uses *slightly longer* variable names.
    In my opinion, the second approach has higher information content while at the
    same time avoids being too verbose:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人不熟悉这段代码，被分配去审查包含前面循环的拉取请求，他们可能会发现自己难以弄清楚`s`是什么以及每个索引级别代表什么！由于缩写的变量名几乎不提供关于它们真正用途的信息，为了回答这些问题，审查者将不得不在代码库中四处寻找线索：查找`s`的类型，然后转到其定义，等等。现在，将前面的代码块与以下一个执行完全相同功能的代码块进行对比，它使用了*略微更长*的变量名。在我看来，第二种方法具有更高的信息量，同时避免了过于冗长：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At the end of the day, each engineer has their own preferred variable naming
    approach and philosophy. When deciding on which approach to adopt, try to take
    a few minutes to consider how your variable naming choices affect other engineers
    that collaborate with you on shared code bases.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个工程师都有自己的首选变量命名方法和哲学。在决定采用哪种方法时，试着花几分钟考虑一下你的变量命名选择如何影响与你共同在共享代码库上协作的其他工程师。
- en: Using Go interfaces effectively
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效使用 Go 接口
- en: '"Accept interfaces, return structs."'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '"接受接口，返回结构体。"'
- en: '*- Jack Lindamood*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*- 杰克·林达穆德*'
- en: 'The key point behind organizing code into packages is to make it reusable and
    available to external consumers in a frictionless way by providing a clean, well-documented
    API surface that consumers can build on. When authoring functions or methods that
    accept concrete types as arguments, we place an artificial constraint on the usefulness
    of our implementation: it only works with instances of a particular type.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码组织成包背后的关键点是，通过提供一个干净、文档齐全的 API 界面，使代码可重用，并以无摩擦的方式供外部消费者使用。当编写接受具体类型作为参数的函数或方法时，我们对我们实现的有用性施加了一个人为的限制：它只能与特定类型的实例一起工作。
- en: While this may not always be an issue, in some cases, requiring a concrete type
    instance can potentially make testing non-trivial and slow, especially if the
    construction of such an instance is a costly operation. The following excerpt
    is part of a system that collects and publishes performance metrics to a **key-value**
    (**KV**) store.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不一定总是问题，但在某些情况下，要求具体的类型实例可能会使测试变得复杂且缓慢，尤其是如果构建此类实例是一个昂贵的操作。以下摘录是关于一个收集并将性能指标发布到键值存储的系统的一部分。
- en: 'The KV store implementation looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储的实现如下所示：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within the `metrics` package, we can find the definition of the `ReportMetrics` function.
    It receives a `kv.Store` instance as an argument and persists the collected metrics
    to it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `metrics` 包中，我们可以找到 `ReportMetrics` 函数的定义。它接收一个 `kv.Store` 实例作为参数，并将收集到的指标持久化到其中：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Based on the previous discussion around SOLID principles, you should have already
    identified an issue with this code: *it only works with a specific KV store implementation*!
    What if we want to publish the metrics to a network socket, write them to a CSV
    file, or perhaps log them to the console?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前关于 SOLID 原则的讨论，你应该已经发现了这段代码的问题：*它只与特定的键值存储实现一起工作*！如果我们想将指标发布到网络套接字、写入 CSV
    文件，或者可能记录到控制台会怎样呢？
- en: 'There is, however, yet another issue with this bit of code: testing it requires
    quite a bit of effort. To understand why, let''s put ourselves in the shoes of
    a consumer of this package. As part of our integration test suite, we want to
    make sure that all the collected metrics are actually written to the KV store
    instance.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码还有一个问题：测试它需要相当多的努力。为了理解原因，让我们设身处地地考虑一下这个包的消费者。作为我们集成测试套件的一部分，我们想要确保所有收集到的指标实际上都写入了键值存储实例。
- en: 'First, our test code would have to create an instance of the KV store. Since
    the `Open` method requires a file and we could be running multiple tests concurrently,
    we would need to create a temporary unique file and pass it as an argument to `Open`.
    Of course, we shouldn''t leave temporary files hanging around after our test run
    completes, so we need to make sure our test will clean up after itself:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的测试代码必须创建一个键值存储的实例。由于 `Open` 方法需要一个文件，而我们可能会同时运行多个测试，因此我们需要创建一个临时的唯一文件，并将其作为参数传递给
    `Open`。当然，我们不应该在测试运行完成后留下临时文件，因此我们需要确保我们的测试会在自己完成后进行清理：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That brings us to the meat of the test: creating a metrics collector, populating
    it with a bunch of measurements, reporting the captured metrics to the KV store,
    and verifying that everything has been written to the store properly:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了测试的核心：创建一个指标收集器，用大量测量值填充它，将捕获的指标报告给键值存储，并验证一切是否已正确写入存储：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This test is pretty straightforward but it requires quite a bit of boilerplate
    code for setting it up. Additionally, `kv.Open` seems like it is quite an expensive
    call to make; imagine the overhead involved if our test suite was comprised of
    hundreds of tests where each one required a *real* `kv.Store` instance. If, on
    the other hand, `ReportMetrics` received an interface as an argument, we could
    pass an in-memory mock while testing and also retain the flexibility to report
    the metrics to any destination that satisfies that particular interface. Therefore,
    we can improve the preceding code by introducing an interface:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试相当直接，但设置它需要相当多的样板代码。此外，`kv.Open` 看起来是一个相当昂贵的调用；想象一下，如果我们的测试套件由数百个测试组成，每个测试都需要一个真实的
    `kv.Store` 实例，那么涉及的额外开销有多大。另一方面，如果 `ReportMetrics` 接收一个接口作为参数，我们就可以在测试时传递一个内存模拟，同时保留将指标报告到满足该特定接口的任何目的地的灵活性。因此，我们可以通过引入一个接口来改进前面的代码：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This small change makes testing a breeze! We can test the `kv.Store` code in
    isolation and switch to an in-memory store to run all our unit tests:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小小的改动让测试变得轻而易举！我们可以单独测试 `kv.Store` 代码，并切换到内存存储来运行所有单元测试：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The other piece of advice from Lindamood states that we should always try to
    return concrete types rather than interfaces. This advice actually makes sense:
    as a package consumer, if I am calling a function that creates a type, `Foo`,
    I am probably interested in calling one or more methods that are specific to that
    type. If the `NewFoo` function returns an interface, the client code would have
    to manually cast it to `Foo` so that it can invoke the `Foo`-specific methods;
    this would defeat the purpose of returning an interface in the first place.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 林达穆德给出的另一条建议是，我们应该始终尝试返回具体类型而不是接口。这条建议实际上是有道理的：作为一个包的消费者，如果我在调用创建类型`Foo`的函数，我可能对调用该类型特定的一个或多个方法感兴趣。如果`NewFoo`函数返回一个接口，客户端代码将不得不手动将其转换为`Foo`，以便调用`Foo`特定的方法；这会违背最初返回接口的目的。
- en: 'It is also important to point out that, in the majority of cases, the implementation
    will create an instance of a concrete type; the main reason why we would opt to
    return an interface to begin with is to ensure that our concrete type always satisfies
    a particular interface. In essence, we are adding a compile-time check to our
    code! However, there are simpler ways to introduce such compile-time checks and
    still retain the ability for constructors to return concrete instances:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 还很重要的一点是指出，在大多数情况下，实现将创建一个具体类型的实例；我们最初选择返回接口的主要原因是为了确保我们的具体类型始终满足特定的接口。本质上，我们正在给代码添加一个编译时检查！然而，有更简单的方法引入这样的编译时检查，同时仍然保留构造函数返回具体实例的能力：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code snippet outlines two fairly common approaches to achieve
    this compile-time check by defining a pair of global variables that use the reserved *blank
    identifier* as a hint to the compiler that they are not actually used.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段概述了两种相当常见的方法，通过定义一对使用保留的*空白标识符*作为提示的全球变量来实现编译时检查，该提示告知编译器它们实际上没有被使用。
- en: Zero values are your friends
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零值是你的朋友
- en: 'One great feature that Go offers is that each type is automatically assigned
    its zero value when it gets instantiated. Some interesting examples from Go and
    its standard library are as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供的一个很棒的功能是，每个类型在实例化时都会自动分配其零值。Go及其标准库中的一些有趣示例如下：
- en: Go channels; nil channels indefinitely block go-routines attempting to read
    off them
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go通道；空通道会无限期阻塞尝试从中读取的goroutine
- en: The zero value for a Go slice; this is an empty slice that things can be appended
    to
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go切片的零值；这是一个可以添加内容的空切片
- en: The `sync.Mutex` type, whose zero value indicates that the mutex is unlocked
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Mutex`类型，其零值表示互斥锁处于解锁状态'
- en: The `bytes.Buffer` type, whose zero value indicates an empty buffer
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes.Buffer`类型，其零值表示一个空缓冲区'
- en: 'By relying on zero values when designing new types, we can provide implementations
    that work out of the box without the need to explicitly invoke a constructor or
    any other initializer method. The following code snippet defines a simple, thread-safe
    map:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在设计新类型时依赖零值，我们可以提供开箱即用的实现，无需显式调用构造函数或其他初始化方法。以下代码片段定义了一个简单、线程安全的映射：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The actual Go map that will be used to store the `SyncMap` data will be lazily
    allocated when we attempt to add an item to the map. Acquiring a *writer* mutex
    before working with the underlying map ensures that both the initialization of
    the map and the insertion of items happen in an atomic fashion:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上用于存储`SyncMap`数据的Go映射实例将在我们尝试向映射中添加项时懒加载。在处理底层映射之前获取一个*写者*互斥锁确保映射的初始化和项的插入以原子方式发生：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The lookup implementation is pretty straightforward. One noticeable difference
    compared to the implementation of `Put` is that `Get` acquires a *reader* mutex
    before performing lookups. The use of a reader/writer mutex provides concurrent
    access to multiple readers while only allowing a single writer to mutate the map''s
    contents:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 查找实现相当直接。与`Put`实现的明显不同之处在于，`Get`在执行查找之前会获取一个*读者*互斥锁。使用读者/写者互斥锁提供了对多个读者的并发访问，同时只允许单个写者修改映射的内容：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Contrary to the built-in Go map type, which requires explicit initialization
    via a call to `make`, the zero value of a `SyncMap` can be safely used as is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与需要通过调用`make`显式初始化的内置Go映射类型不同，`SyncMap`的零值可以直接安全使用：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What''s more, we can *embed* the preceding `SyncMap` implementation into other
    types that follow the same zero value pattern to provide complex types that require
    no initialization:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们可以将前面的`SyncMap`实现嵌入到遵循相同零值模式的其它类型中，以提供需要无初始化的复杂类型：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code snippet, the `SyncMap` instance is ready to use and can
    be accessed directly through an instance of `Foo` without having to type any additional
    code to set it up.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`SyncMap`实例已经准备好可以使用，并且可以通过`Foo`实例直接访问，而无需编写任何额外的代码来设置它。
- en: Using tools to analyze and manipulate Go programs
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工具分析和操作Go程序
- en: Go programs are inherently easy to parse. In fact, the Go library provides built-in
    packages that can parse Go programs into **abstract syntax trees** (**ASTs**),
    which can be traversed, modified, and transformed back into Go code. Let's go
    through a simple example to show you how easy it is to work with these packages.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序本身很容易解析。事实上，Go库提供了内置的包，可以将Go程序解析为**抽象语法树**（**ASTs**），这些树可以被遍历、修改，并转换回Go代码。让我们通过一个简单的例子来看看使用这些包有多容易。
- en: 'First, we need a helper function to convert a Go program into an AST representation.
    The following `parse` function does exactly that:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个辅助函数将Go程序转换为AST表示。下面的`parse`函数正是这样做的：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ast` package provides a couple of helpers that implement the visitor pattern
    and invokes a user-defined callback for each node in the AST. For this particular
    example, we will define a function called `inspectVariables` that visits every
    node in the AST, looking for nodes that correspond to identifiers (package, constant,
    type, variable, function, or label). For each discovered identifier, the function
    will check its `Kind` attribute and print out its name if the identifier represents
    a variable:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ast` 包提供了一些辅助函数，实现了访问者模式，并为AST中的每个节点调用用户定义的回调。对于这个特定的例子，我们将定义一个名为`inspectVariables`的函数，该函数将访问AST中的每个节点，寻找对应于标识符（包、常量、类型、变量、函数或标签）的节点。对于每个发现的标识符，该函数将检查其`Kind`属性，如果标识符代表变量，则打印其名称：'
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To complete our example, we need to provide a `main` function that will parse
    a simple program and call `inspectVariables` on the resulting AST:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的示例，我们需要提供一个`main`函数，该函数将解析一个简单的程序，并在生成的AST上调用`inspectVariables`：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running the preceding program produces the following output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序会产生以下输出：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Go ecosystem contains a plethora of tools that build on top of this parsing
    infrastructure and provide analysis, code modification, and generation services
    to software engineers. In the upcoming sections, we will examine a short list
    of such tools that can make your software development life easier.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Go生态系统包含大量工具，这些工具建立在解析基础设施之上，并为软件工程师提供分析、代码修改和生成服务。在接下来的章节中，我们将考察一些这样的工具，它们可以使您的软件开发生活更加轻松。
- en: Taking care of formatting and imports (gofmt, goimports)
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意格式化和导入（gofmt，goimports）
- en: Tabs or spaces? Should opening braces be preceded by line breaks? All engineers
    eventually face this dilemma when the time comes to choose a particular code formatting
    style for a new project or a project they've just inherited.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 制表符还是空格？开括号前是否应该有换行符？所有工程师在需要为新项目或刚刚继承的项目选择特定的代码格式化风格时，最终都会面临这个困境。
- en: Source code formatting styles have always been the subject of long, often heated,
    arguments between team members. Contrary to other programming languages, Go is,
    by design, strongly opinionated toward a specific formatting style and ships with
    tools that help enforce that particular style. This design decision makes sense
    as Go was initially created with the goal of being used by the thousands of engineers
    employed by Google. At this massive development scale, uniformity in the authored
    code is not just a nicety – it's actually vital for ensuring that code can be
    handed off between development teams.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码格式化风格一直是团队成员之间长期、有时激烈的争论的主题。与其它编程语言相反，Go在设计上对特定的格式化风格有很强的意见，并附带工具来帮助强制执行该特定风格。这个设计决策是有意义的，因为Go最初是为了被成千上万的谷歌雇佣的工程师使用而创建的。在这个庞大的开发规模下，作者代码的一致性不仅仅是一种优雅，实际上对于确保代码可以在开发团队之间传递是至关重要的。
- en: 'The `gofmt` tool ^([11]) is available as part of the standard Go distribution.
    You provide it with the paths to one or more files and it can perform the following
    tasks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`gofmt` 工具^([11])作为标准Go发行版的一部分提供。您提供它一个或多个文件的路径，它可以执行以下任务：'
- en: Format code according to the recommended standard
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照推荐的标准格式化代码
- en: Simplify code (`gofmt -s example.go`)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化代码 (`gofmt -s example.go`)
- en: Perform simple rewrites (`gofmt -r ‘a[b:len(a)] -> a[len(a):b]’ example.go`)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行简单的重写 (`gofmt -r 'a[b:len(a)] -> a[len(a):b]' example.go`)
- en: By default, `gofmt` will output the formatted programs to the standard output.
    However, users may pass the `-w`flag to force `gofmt` to write its output back
    to the source file that it just processed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`gofmt` 将格式化后的程序输出到标准输出。然而，用户可以通过传递 `-w` 标志来强制 `gofmt` 将其输出写回到它刚刚处理的源文件。
- en: 'The `goimports` tool ^([12]) is a drop-in replacement for `gofmt` that can
    be installed by running `go get golang.org/x/tools/cmd/goimports`. In addition
    to providing code-formatting facilities that match the output of `gofmt`, `goimports` also
    manages Go import lines: it can fill in missing imports and remove the ones that
    aren''t referenced by the processed file. What''s more, `goimports` also ensures
    that packages are sorted alphabetically and grouped together, depending on whether
    they belong to the standard library or are third-party packages.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`goimports` 工具^([12]) 是 `gofmt` 的一个直接替代品，可以通过运行 `go get golang.org/x/tools/cmd/goimports`
    来安装。除了提供与 `gofmt` 输出匹配的代码格式化功能外，`goimports` 还管理 Go 的导入行：它可以填充缺失的导入并删除未被处理文件引用的导入。更重要的是，`goimports`
    还确保包按字母顺序排序并分组，这取决于它们是否属于标准库或第三方包。'
- en: 'The following is an example of a Go program that exhibits a couple of issues:
    missing imports, unused imports, extraneous whitespace, and incorrect indentation:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个展示了一些问题的 Go 程序示例：缺失的导入、未使用的导入、多余的空白字符和错误的缩进：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The typical use case for these tools is to execute them as post-save hooks
    from your favorite editor or IDE. If we run `goimports` on the preceding code
    snippet, we will get a neatly formatted output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的典型用法是将它们作为你最喜欢的编辑器或 IDE 的后保存钩子来执行。如果我们对前面的代码片段运行 `goimports`，我们将得到一个整洁的格式化输出：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, the import statements have been cleaned up and sorted, the missing
    packages have been imported, and unused packages have been removed. Adding to
    this, the code is now properly indented and all the extraneous whitespace has
    been removed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，导入语句已经被清理和排序，缺失的包已经被导入，未使用的包已经被删除。除此之外，代码现在已经被正确缩进，并且所有多余的空白字符都被移除了。
- en: Refactoring code across packages (gorename, gomvpkg, fix)
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在包之间重构代码（gorename, gomvpkg, fix）
- en: Oftentimes, you may come across a variable within a function that has a strange
    or non-descriptive name that you are quite keen on renaming. Performing such a
    rename operation is quite simple; just select the function block and run a find-and-replace
    operation. Simple as pie!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会在函数中遇到一个具有奇怪或非描述性名称的变量，你非常想重命名它。执行此类重命名操作非常简单；只需选择函数块并运行查找和替换操作。简单得就像做饼一样！
- en: But what if you want to rename a public struct field or a function that is exported
    from your package? This is definitely not a trivial task as you need to track
    down all the references to the thing being renamed (the list may also include
    other packages) and update them to use the new name. This type of rename operation
    takes us into the realm of code refactoring; fortunately, there is a tool at our
    disposal for automating this tedious task: `gorename` ^([16]). It can be installed
    by running `go get golang.org/x/tools/cmd/gorenam*e*`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要重命名一个公共结构体字段或从你的包中导出的函数呢？这绝对不是一个简单任务，因为你需要追踪所有对要重命名的对象（列表可能还包括其他包）的引用，并将它们更新为使用新名称。这种重命名操作将我们带入代码重构的领域；幸运的是，我们有工具可以自动化这个繁琐的任务：`gorename`^([16])。可以通过运行
    `go get golang.org/x/tools/cmd/gorenam*e*` 来安装它。
- en: One interesting feature of `gorename`, besides the fact that it works across
    packages, is that it is *type-aware*. Since it relies on parsing the program before
    it applies any rename operation, it is intelligent enough to tell the difference
    between a function called `Foo` and a struct field with the same name. Furthermore,
    it includes an extra layer of safety in that it will only apply rename operations
    as long as the end result is a piece of code that can compile without errors.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`gorename` 的一个有趣特性，除了它可以在包之间工作之外，还在于它是 *类型感知的*。由于它在应用任何重命名操作之前依赖于解析程序，因此它足够智能，可以区分名为
    `Foo` 的函数和具有相同名称的结构体字段。此外，它还增加了一层额外的安全性，即它只会应用重命名操作，只要最终结果是能够无错误编译的代码片段。'
- en: 'Sometimes, you may find yourself needing to rename a Go package or even move
    it to a different location either within the same project or across projects.
    The `gomvpkg` tool ^([15]) can assist in that matter while also taking care of
    tracking down packages that depend on the renamed/moved package and updating their
    import statements to point to the new package location. It can be installed by
    running `go get golang.org/x/tools/cmd/gomvpkg`. Moving a package is as simple
    as running the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要重命名一个 Go 包，甚至将其移动到同一项目或不同项目中的不同位置。`gomvpkg` 工具 ^([15]) 可以在此方面提供帮助，同时还会追踪依赖于重命名/移动包的包，并更新它们的导入语句以指向新的包位置。可以通过运行
    `go get golang.org/x/tools/cmd/gomvpkg` 来安装它。移动包就像运行以下命令一样简单：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The Go standard library has changed a lot over the years since the release of
    the first stable Go version back in 2011\. New APIs were introduced while other
    APIs were deprecated and eventually removed. In some cases, existing APIs are
    modified, often in a non-backward-compatible way, whereas in other cases, external
    or experimental packages eventually got accepted for inclusion in the standard
    library.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2011 年首次稳定版 Go 版本发布以来，Go 标准库在多年中发生了很大变化。在引入新 API 的同时，其他 API 被弃用并最终被移除。在某些情况下，现有的
    API 被修改，通常是非向后兼容的方式，而在其他情况下，外部或实验性包最终被接受纳入标准库。
- en: A relevant example is the `context` package. Prior to Go 1.7, this package was
    available at `golang.org/x/net/context`and quite a few Go programs were actively
    using it. But with the release of Go 1.7, that package became a part of the standard
    library and moved to a standalone `context` package. As soon as engineers switched
    to the new import path for the context package, their code would instantly become
    incompatible with code still using the old import path. Therefore, someone would
    have to undertake the task of reviewing the existing code base and rewriting existing
    imports to point to the new location for the context package!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的例子是 `context` 包。在 Go 1.7 之前，这个包位于 `golang.org/x/net/context`，并且许多 Go 程序都在积极使用它。但随着
    Go 1.7 的发布，该包成为了标准库的一部分，并移动到了独立的 `context` 包。一旦工程师切换到上下文包的新导入路径，他们的代码就会立即与仍在使用旧导入路径的代码不兼容。因此，有人必须承担审查现有代码库并重写现有导入以指向上下文包新位置的艰巨任务！
- en: The Go designers foresaw such issues and created a rule-based tool to detect
    code that relies on old, deprecated APIs or packages, and automatically rewrite
    it to use newer APIs. The tool, aptly named `fix` ([https://golang.org/cmd/fix/](https://golang.org/cmd/fix/)),
    ships with each new Go release and can be invoked each time you switch to a newer
    Go version by running `go tool fix $path`. It is important to point out that all
    applied fixes are *idempotent*; therefore, it is safe to run the tool multiple
    times without the risk of your code base becoming corrupted.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Go 设计者预见到了这些问题，并创建了一个基于规则的工具来检测依赖于旧、已弃用的 API 或包的代码，并自动将其重写为使用新 API。这个工具被恰当地命名为
    `fix` ([https://golang.org/cmd/fix/](https://golang.org/cmd/fix/))，它随着每个新的 Go
    版本一起发布，每次切换到新版本的 Go 时都可以通过运行 `go tool fix $path` 来调用它。重要的是要指出，所有应用到的修复都是 *幂等的*；因此，可以安全地多次运行该工具，而不会使代码库损坏。
- en: Improving code quality metrics with the help of linters
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 linters 提高代码质量指标
- en: 'Linters are specialized static analysis tools that parse Go files and attempt
    to detect, flag, and report cases where the following occurs:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Linters 是专门用于解析 Go 文件并尝试检测、标记和报告以下情况的静态分析工具：
- en: The code does not adhere to the standard formatting style guide; for example, it
    contains extraneous whitespace, is incorrectly indented, or contains comments
    with spelling typos
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码不符合标准格式化风格指南；例如，它包含多余的空白，缩进不正确，或包含有拼写错误的注释
- en: The program contains possible logic bugs; for example, a variable declaration *shadowing* a
    previous variable declaration with the same name, calling functions such as `fmt.Printf` with
    an incorrect argument count or with arguments whose types do not match the format
    string, assigning values to variables but not actually using them, not checking
    errors returned by function calls, and so on
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序中可能存在逻辑错误；例如，变量声明 *覆盖* 前一个具有相同名称的变量声明，以错误的参数数量或与格式字符串类型不匹配的参数调用函数，如 `fmt.Printf`，将值赋给变量但实际上没有使用它们，没有检查函数调用返回的错误，等等
- en: The code may contain security vulnerabilities; for example, it contains hardcoded
    security credentials or points to where an SQL injection might be possible using
    insecure random number sources or cryptographically broken hash primitives (DES,
    RC4, MD5, or SHA1)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可能包含安全漏洞；例如，它包含硬编码的安全凭证或指向可能使用不安全的随机数源或密码学上损坏的哈希原语（DES、RC4、MD5 或 SHA1）进行SQL注入的位置
- en: The code exhibits high complexity (for example, deeply nested `if`/`else` blocks)
    or contains unnecessary type conversions, unused local or global variables, or
    code paths that are never invoked
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码表现出高复杂度（例如，深度嵌套的 `if`/`else` 块）或包含不必要的类型转换、未使用的局部或全局变量，或从未被调用的代码路径
- en: 'The following table summarizes the most popular Go linters that you can invoke
    to check your programs and improve the quality metrics of the code that you author:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '以下表格总结了您可以使用以检查您的程序并提高您编写的代码质量指标的最受欢迎的Go代码检查工具： '
- en: '| **Category** | **Linter** | **Description** |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **代码检查工具** | **描述** |'
- en: '| Logic bugs | `bodyclose` ^([2]) | Check if `http.Response` bodies are always
    closed. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑错误 | `bodyclose` ^([2]) | 检查 `http.Response` 主体是否始终关闭。 |'
- en: '| Logic bugs | `errcheck` ^([7]) | Identify cases where returned errors are
    not being checked. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑错误 | `errcheck` ^([7]) | 识别未检查返回的错误的情况。 |'
- en: '| Logic bugs | `gosumcheck` ^([19]) | Ensure that all possible cases of a type
    switch are handled properly. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑错误 | `gosumcheck` ^([19]) | 确保正确处理类型切换的所有可能情况。 |'
- en: '| Logic bugs | `go vet` ([https://golang.org/cmd/vet/](https://golang.org/cmd/vet/)) ^([20])
    | Report suspicious constructs, for example, calling `fmt.Printf` with the wrong
    arguments. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑错误 | `go vet` ([https://golang.org/cmd/vet/](https://golang.org/cmd/vet/)) ^([20])
    | 报告可疑的结构，例如，使用错误的参数调用 `fmt.Printf`。 |'
- en: '| Logic bugs | `ineffassign` ^([21]) | Detect variable assignments that are
    not being used. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑错误 | `ineffassign` ^([21]) | 检测未被使用的变量赋值。 |'
- en: '| Code smell | `deadcode` ([https://github.com/tsenart/deadcode](https://github.com/tsenart/deadcode)) ^([4])
    | Report unused blocks of code. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 代码异味 | `deadcode` ([https://github.com/tsenart/deadcode](https://github.com/tsenart/deadcode)) ^([4])
    | 报告未使用的代码块。 |'
- en: '| Code smell | `dupl` ([https://github.com/mibk/dupl](https://github.com/mibk/dupl)) ^([5])
    | Report potentially duplicated blocks of code. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 代码异味 | `dupl` ([https://github.com/mibk/dupl](https://github.com/mibk/dupl)) ^([5])
    | 报告可能重复的代码块。 |'
- en: '| Code smell | `goconst` ([https://github.com/jgautheron/goconst](https://github.com/jgautheron/goconst)) ^([9])
    | Flag repeated strings that can be replaced with constants. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 代码异味 | `goconst` ([https://github.com/jgautheron/goconst](https://github.com/jgautheron/goconst)) ^([9])
    | 标记可以替换为常量的重复字符串。 |'
- en: '| Code smell | `structcheck` ([https://gitlab.com/opennota/check](https://gitlab.com/opennota/check)) ^([30])
    | Identify unused struct fields. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 代码异味 | `structcheck` ([https://gitlab.com/opennota/check](https://gitlab.com/opennota/check)) ^([30])
    | 识别未使用的结构体字段。 |'
- en: '| Code smell | `unconvert` ([https://github.com/mdempsky/unconvert](https://github.com/mdempsky/unconvert)) ^([31])
    | Detect unnecessary type conversions. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 代码异味 | `unconvert` ([https://github.com/mdempsky/unconvert](https://github.com/mdempsky/unconvert)) ^([31])
    | 检测不必要的类型转换。 |'
- en: '| Code smell | `unparam` ([https://github.com/mvdan/unparam](https://github.com/mvdan/unparam)) ^([33])
    | Detect unused function parameters. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 代码异味 | `unparam` ([https://github.com/mvdan/unparam](https://github.com/mvdan/unparam)) ^([33])
    | 检测未使用的函数参数。 |'
- en: '| Code smell | `varcheck` ^([34]) | Detect unused variables and constants.
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 代码异味 | `varcheck` ^([34]) | 检测未使用的变量和常量。 |'
- en: '| Performance | `aligncheck` ^([1]) | Identify inefficiently packed structs
    that take up more space due to padding. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | `aligncheck` ^([1]) | 识别由于填充而占用更多空间的低效打包的结构体。 |'
- en: '| Performance | `copyfighter` ([https://github.com/jmhodges/copyfighter](https://github.com/jmhodges/copyfighter)) ^([3])
    | Reports functions that pass large structs by value; this pattern triggers memory
    allocations and increases pressure on the garbage collector. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | `copyfighter` ([https://github.com/jmhodges/copyfighter](https://github.com/jmhodges/copyfighter)) ^([3])
    | 报告通过值传递大型结构体的函数；这种模式触发内存分配并增加垃圾收集器的压力。 |'
- en: '| Performance | `prealloc` ^([26]) | Identify slice declarations that could
    be preallocated. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | `prealloc` ^([26]) | 识别可以预先分配的切片声明。 |'
- en: '| Complexity | `gocyclo` ^([10]) | Calculate cyclomatic complexities of Go
    functions. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 复杂度 | `gocyclo` ^([10]) | 计算Go函数的圈复杂度。 |'
- en: '| Complexity | `gosimple` ^([18]) | Report code that can be potentially simplified.
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 复杂度 | `gosimple` ^([18]) | 报告可以简化的代码。 |'
- en: '| Complexity | `splint` ^([29]) | Identify functions that are too long or receive
    too many arguments. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 复杂度 | `splint` ^([29]) | 识别过长或接收过多参数的函数。 |'
- en: '| Security | `gosec` ([https://github.com/securego/gosec](https://github.com/securego/gosec)) ^([17])
    | Scan source code for potential security issues. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 安全 | `gosec` ([https://github.com/securego/gosec](https://github.com/securego/gosec)) ^([17])
    | 扫描源代码以查找潜在的安全问题。 |'
- en: '| Security | `safesql` ([https://github.com/stripe/safesql](https://github.com/stripe/safesql))^( [28])
    | Check for potential SQL injection points. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 安全 | `safesql` ([https://github.com/stripe/safesql](https://github.com/stripe/safesql))^( [28])
    | 检查潜在的 SQL 注入点。 |'
- en: '| Style | `gofmt -s` ([https://golang.org/cmd/gofmt/](https://golang.org/cmd/gofmt/)) ^([11])
    | Ensure that a file is formatted according to `gofmt` rules. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 风格 | `gofmt -s` ([https://golang.org/cmd/gofmt/](https://golang.org/cmd/gofmt/)) ^([11])
    | 确保文件格式符合 `gofmt` 规则。 |'
- en: '| Style | `golint` ([https://github.com/golang/lint](https://github.com/golang/lint)) ^([14])
    | Report stylistic deviations from the recommendations outlined in Effective Go ^([6]).
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 风格 | `golint` ([https://github.com/golang/lint](https://github.com/golang/lint)) ^([14])
    | 报告与《Effective Go》中概述的建议不符的样式偏差。 |'
- en: '| Style | `misspell` ([https://github.com/client9/misspell](https://github.com/client9/misspell)) ^([25])
    | Use a dictionary to identify spelling mistakes in comments. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 风格 | `misspell` ([https://github.com/client9/misspell](https://github.com/client9/misspell)) ^([25])
    | 使用字典来识别注释中的拼写错误。 |'
- en: '| Style | `unindent` ([https://github.com/mvdan/unindent](https://github.com/mvdan/unindent)) ^([32])
    | Identify code that isn''t indented correctly. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 风格 | `unindent` ([https://github.com/mvdan/unindent](https://github.com/mvdan/unindent)) ^([32])
    | 识别未正确缩进的代码。 |'
- en: Using the preceding linters in your projects comes with a few caveats that you
    need to be aware of. First of all, each linter uses its own output format to report
    detected issues. The lack of a standardized way to report issues becomes a problem
    when you attempt to integrate the linters with your preferred editor or IDE workflows
    (for example, jump to the code location where an issue was detected). Secondly,
    each linter is oblivious to the existence of other linters. Consequently, *each* linter
    needs to reparse all the packages when it runs. This is usually not an issue when
    you're dealing with small code bases, but it becomes annoying when you're working
    with larger projects, as an end-to-end run of all the linters can take up to a
    few minutes to complete.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目中使用上述 linters 伴随着一些需要注意的问题。首先，每个 linter 都使用自己的输出格式来报告检测到的问题。当您尝试将 linters
    与您首选的编辑器或 IDE 工作流程集成时，缺乏标准化的报告问题方式成为一个问题（例如，跳转到检测到问题的代码位置）。其次，每个 linter 都不知道其他
    linter 的存在。因此，每次运行时，每个 linter 都需要重新解析所有包。当您处理小型代码库时，这通常不是问题，但当您处理大型项目时，这会变得令人烦恼，因为所有
    linters 的完整运行可能需要几分钟才能完成。
- en: 'To address the preceding issues, you can use a **meta-linter** (also known
    as a **linter output aggregator**) tool such as `golangci-lint` ^([13]) (a drop-in
    replacement for the now-deprecated gometalinter) or revive ^([27]). These tools
    are designed to execute a configurable list of linters in parallel, normalize
    their output, eliminate duplicate warnings, or even suppress warnings based on
    regular expressions (quite a handy feature when your project includes files that
    are autogenerated by other tools). What''s more, they also seamlessly integrate
    with the majority of editors that are used by engineers working on Go programs.
    An easy way to invoke these meta-linter tools is to add a target to your project''s *makefile*:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决上述问题，您可以使用**元 linter**（也称为**linter 输出聚合器**）工具，例如 `golangci-lint` ^([13])（现在已弃用的
    gometalinter 的替代品）或 revive ^([27]）。这些工具旨在并行执行可配置的 linter 列表，标准化它们的输出，消除重复警告，甚至根据正则表达式抑制警告（当您的项目包含由其他工具自动生成的文件时，这是一个非常实用的功能）。更重要的是，它们还无缝集成到工程师使用的绝大多数编辑器中。调用这些元
    linter 工具的一个简单方法是向您的项目 *makefile* 中添加一个目标：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Having a makefile rule for linting makes it easy to run the linters as part
    of your regular CI pipeline and block pull requests from being merged until the
    lint errors are addressed. At the same time, it offers you the flexibility of
    running the linters locally while you are working on the code base.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为 linting 创建一个 makefile 规则，使得将 linters 作为常规 CI 流程的一部分运行变得容易，并且直到 lint 错误得到解决，阻止拉取请求合并。同时，它还提供了在您在代码库上工作时本地运行
    linters 的灵活性。
- en: It is quite common for engineers to forgo running the linters before creating
    a pull request, thereby requiring additional commits just to address lint errors.
    You can avoid such situations by exploiting the fact that most version control
    systems (Git is one example) support some kind of pre-commit or pre-push hook
    and have your VCS run the linters automatically for you.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师在创建拉取请求之前跳过运行linters是很常见的情况，这需要额外的提交来处理lint错误。您可以通过利用大多数版本控制系统（Git是一个例子）支持某种预提交或预推送钩子，并让您的VCS自动为您运行linters来避免这种情况。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In the first section of this chapter, *The SOLID principles of object-oriented
    design*, we performed a deep dive into each of the SOLID principles and how they
    can be applied toward writing clean Go code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一节“面向对象设计的SOLID原则”中，我们深入探讨了每个SOLID原则及其如何应用于编写干净的Go代码：
- en: '**SRP**: Group structs and functions based on their purpose and organize them
    into packages with clear logical boundaries.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SRP**：根据目的将结构体和函数分组，并将它们组织到具有清晰逻辑边界的包中。'
- en: '**Open/Closed principle**: Use composition and embedding of simple types to
    construct more complex types that still retain the same implicit interface as
    the types they consist of.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放/封闭原则**：使用简单类型的组合和嵌入来构建更复杂类型，同时仍然保留它们所包含类型的相同隐式接口。'
- en: '**LSP**: Avoid unnecessary coupling by using interfaces rather than concrete
    types to define the contract between packages.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LSP**：通过使用接口而不是具体类型来定义包之间的合同，避免不必要的耦合。'
- en: '**ISP**: Make sure your function or method signatures only depend on the behaviors
    they need and nothing more; use the smallest possible interface to describe function/method
    arguments and avoid coupling to the implementation details of concrete types.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISP**：确保您的函数或方法签名只依赖于它们需要的操作，而不需要更多；使用尽可能小的接口来描述函数/方法参数，并避免与具体类型的实现细节耦合。'
- en: '**DIP**: Use the appropriate level of abstraction when designing your code
    to decouple high-level and low-level modules while at the same time ensuring that
    the implementation details rely on the abstractions and not the other way round.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DIP**：在设计代码时使用适当的抽象级别，以解耦高级和低级模块，同时确保实现细节依赖于抽象而不是相反。'
- en: Halfway through this chapter, we touched on the subject of organizing code into
    packages, identified common package naming pitfalls that you should avoid, and
    discussed the concept of import cycles, including their causes. Then, we outlined
    strategies for mitigating the issue of circular dependencies.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的中间部分，我们讨论了将代码组织到包中的主题，确定了您应该避免的常见包命名陷阱，并讨论了导入循环的概念，包括其成因。然后，我们概述了缓解循环依赖问题的策略。
- en: Finally, we discussed useful tips and tools that you can use to facilitate writing
    clean code that is easy to reason about and for your software engineering colleagues
    to review and maintain.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了一些有用的技巧和工具，您可以使用它们来帮助编写易于推理和您的软件工程同事审查和维护的干净代码。
- en: As your Go projects grow in size, you will undoubtedly notice a bump in the
    number of package import statements throughout the code base. This is quite normal
    and, frankly, expected if you are applying the SOLID principles when creating
    packages. However, the increased number of imports, especially if they are authored
    by third parties that you do not control, also necessitate some kind of process
    to ensure that your programs can still compile as expected, even if an external
    dependency changes. This is the main topic of the next chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的Go项目规模的增长，您无疑会注意到代码库中包导入语句数量的增加。这是相当正常的，坦白说，如果您在创建包时应用SOLID原则，这是预期的。然而，导入数量的增加，尤其是如果它们是由您无法控制的第三方编写的，这也需要某种过程来确保即使外部依赖项发生变化，您的程序仍然可以按预期编译。这是下一章的主要内容。
- en: Questions
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What do the SOLID acronym initials stand for?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SOLID首字母缩略词代表什么？
- en: Why does the following piece of code violate the SRP? How would you refactor
    it to make sure it doesn't violate it?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下代码片段违反了SRP？您会如何重构它以确保它不违反SRP？
- en: '[PRE48]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'What is the main concept behind the ISP? Discuss how would you apply it to
    improve the following function signature:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ISP背后的主要概念是什么？讨论您将如何应用它来改进以下函数签名：
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Explain why *util* is considered to be a less-than-ideal name for a Go package.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么*util*被认为是一个不太理想的Go包名称。
- en: Why are import cycles an issue for Go programs?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么导入循环是Go程序的问题？
- en: Name some of the advantages of using the zero value when designing new Go types.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举使用零值设计新 Go 类型的优点。
- en: Further reading
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '`aligncheck`: Identify inefficiently packed structs. URL: [https://gitlab.com/opennota/check](https://gitlab.com/opennota/check).'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aligncheck`: 识别效率低下的结构体打包。URL: [https://gitlab.com/opennota/check](https://gitlab.com/opennota/check).'
- en: '`bodyclose`: A static analysis tool that checks whether `res.Body` is correctly
    closed. URL: [https://github.com/timakin/bodyclose](https://github.com/timakin/bodyclose).'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bodyclose`: 一个静态分析工具，用于检查 `res.Body` 是否正确关闭。URL: [https://github.com/timakin/bodyclose](https://github.com/timakin/bodyclose).'
- en: '`copyfighter`: Statically analyze Go code and report functions while passing
    large structs by value. URL: [https://github.com/jmhodges/copyfighter](https://github.com/jmhodges/copyfighter).'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`copyfighter`: 静态分析 Go 代码并在通过值传递大结构体时报告函数。URL: [https://github.com/jmhodges/copyfighter](https://github.com/jmhodges/copyfighter).'
- en: '`deadcode`: Report unused blocks of code. URL: [https://github.com/tsenart/deadcode](https://github.com/tsenart/deadcode).'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`deadcode`: 报告未使用的代码块。URL: [https://github.com/tsenart/deadcode](https://github.com/tsenart/deadcode).'
- en: '`dupl`: Report potentially duplicated blocks of code. URL: [https://github.com/mibk/dupl](https://github.com/mibk/dupl).'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dupl`: 报告潜在的代码块重复。URL: [https://github.com/mibk/dupl](https://github.com/mibk/dupl).'
- en: 'Effective Go: Tips for writing clear, idiomatic Go code.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Effective Go: 编写清晰、惯用的 Go 代码的技巧。'
- en: '`errcheck`: Ensure that returned errors are checked. URL: [https://github.com/kisielk/errcheck](https://github.com/kisielk/errcheck).'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`errcheck`: 确保返回的错误被检查。URL: [https://github.com/kisielk/errcheck](https://github.com/kisielk/errcheck).'
- en: 'Fowler, Martin: *Refactoring: Improving the Design of Existing Code.* Boston,
    MA, USA: Addison-Wesley, 1999 — ISBN 0-201-48567-2 ([https://www.worldcat.org/title/refactoring-improving-the-design-of-existing-code/oclc/863697997](https://www.worldcat.org/title/refactoring-improving-the-design-of-existing-code/oclc/863697997)).'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 佛勒，马丁：*重构：现有代码的设计改进.* 波士顿，马萨诸塞州，美国：Addison-Wesley，1999 — ISBN 0-201-48567-2
    ([https://www.worldcat.org/title/refactoring-improving-the-design-of-existing-code/oclc/863697997](https://www.worldcat.org/title/refactoring-improving-the-design-of-existing-code/oclc/863697997)).
- en: '`goconst`: Flag repeated strings that can be replaced with constants. URL: [https://github.com/jgautheron/goconst](https://github.com/jgautheron/goconst).'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`goconst`: 标记可以替换为常量的重复字符串。URL: [https://github.com/jgautheron/goconst](https://github.com/jgautheron/goconst).'
- en: '`gocyclo`: Calculate cyclomatic complexity of code. URL: [https://github.com/alecthomas/gocyclo](https://github.com/alecthomas/gocyclo).'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gocyclo`: 计算代码的圈复杂度。URL: [https://github.com/alecthomas/gocyclo](https://github.com/alecthomas/gocyclo).'
- en: '`gofmt`: Format Go programs or check that they are properly formatted. URL: [https://golang.org/cmd/gofmt/](https://golang.org/cmd/gofmt/).'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gofmt`: 格式化 Go 程序或检查它们是否格式正确。URL: [https://golang.org/cmd/gofmt/](https://golang.org/cmd/gofmt/).'
- en: '`goimports`: Update Go import lines by adding missing ones and removing unreferenced
    ones. URL: [https://godoc.org/golang.org/x/tools/cmd/goimports](https://godoc.org/golang.org/x/tools/cmd/goimports).'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`goimports`: 通过添加缺失的导入行和删除未引用的导入行来更新 Go 导入行。URL: [https://godoc.org/golang.org/x/tools/cmd/goimports](https://godoc.org/golang.org/x/tools/cmd/goimports).'
- en: '`golangci-lint`: Linter runner. URL: [https://github.com/golangci/golangci-lint](https://github.com/golangci/golangci-lint).'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`golangci-lint`: 检查器运行器。URL: [https://github.com/golangci/golangci-lint](https://github.com/golangci/golangci-lint).'
- en: '`golint`: Report style issues in Go programs. URL: [https://github.com/golang/lint](https://github.com/golang/lint).'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`golint`: 报告 Go 程序中的样式问题。URL: [https://github.com/golang/lint](https://github.com/golang/lint).'
- en: '`gomvpkg`: Move Go packages and update import declarations. URL: [https://godoc.org/golang.org/x/tools/cmd/gomvpkg](https://godoc.org/golang.org/x/tools/cmd/gomvpkg).'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gomvpkg`: 移动 Go 包并更新导入声明。URL: [https://godoc.org/golang.org/x/tools/cmd/gomvpkg](https://godoc.org/golang.org/x/tools/cmd/gomvpkg).'
- en: '`gorename`: Perform precise type-safe renaming of identifiers in Go source
    code. URL: [https://godoc.org/golang.org/x/tools/cmd/gorename](https://godoc.org/golang.org/x/tools/cmd/gorename).'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gorename`: 在 Go 源代码中执行精确的类型安全重命名。URL: [https://godoc.org/golang.org/x/tools/cmd/gorename](https://godoc.org/golang.org/x/tools/cmd/gorename).'
- en: '`gosec`: Scan source code for potential security issues. URL: [https://github.com/securego/gosec](https://github.com/securego/gosec).'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gosec`: 扫描源代码以查找潜在的安全问题。URL: [https://github.com/securego/gosec](https://github.com/securego/gosec).'
- en: '`gosimple`: Report code that can be potentially simplified. URL: [https://github.com/dominikh/go-tools/tree/master/cmd/gosimple](https://github.com/dominikh/go-tools/tree/master/cmd/gosimple).'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gosimple`: 报告可以潜在简化的代码。URL: [https://github.com/dominikh/go-tools/tree/master/cmd/gosimple](https://github.com/dominikh/go-tools/tree/master/cmd/gosimple).'
- en: '`gosumcheck`: Ensure that all possible types in a type switch are properly
    handled. URL: [https://github.com/haya14busa/gosum](https://github.com/haya14busa/gosum).'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gosumcheck`：确保类型切换中所有可能的类型都得到适当处理。URL：[https://github.com/haya14busa/gosum](https://github.com/haya14busa/gosum)。'
- en: '`go vet`: Examine Go source code and report suspicious constructs, such as
    `printf` calls whose arguments do not align with the format string or shadowed
    variables. URL: [https://golang.org/cmd/vet/](https://golang.org/cmd/vet/).'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go vet`：检查Go源代码并报告可疑结构，例如参数与格式字符串不匹配的`printf`调用或被遮蔽的变量。URL：[https://golang.org/cmd/vet/](https://golang.org/cmd/vet/)。'
- en: '`ineffassign`: Detect variable assignments that are not being used. URL: [https://github.com/gordonklaus/ineffassign](https://github.com/gordonklaus/ineffassign).'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ineffassign`：检测未被使用的变量赋值。URL：[https://github.com/gordonklaus/ineffassign](https://github.com/gordonklaus/ineffassign)。'
- en: 'Liskov, Barbara: Keynote Address – Data Abstraction and Hierarchy. In: *Addendum
    to the Proceedings on Object-oriented Programming Systems, Languages and Applications
    (Addendum)*, OOPSLA ''87\. New York, NY, USA : ACM, 1987 — ISBN 0-89791-266-7
    ([https://www.worldcat.org/title/oopsla-87-addendum-to-the-proceedings-object-oriented-programming-systems-languages-and-applications-october-4-8-1987-orlando-florida/oclc/220450625](https://www.worldcat.org/title/oopsla-87-addendum-to-the-proceedings-object-oriented-programming-systems-languages-and-applications-october-4-8-1987-orlando-florida/oclc/220450625)),
    S. 17–34.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Liskov, Barbara: 主题演讲 - 数据抽象和层次结构。在：《面向对象编程系统、语言和应用（增补）会议论文集》，OOPSLA ''87。纽约，纽约，美国：ACM，1987
    — ISBN 0-89791-266-7 ([https://www.worldcat.org/title/oopsla-87-addendum-to-the-proceedings-object-oriented-programming-systems-languages-and-applications-october-4-8-1987-orlando-florida/oclc/220450625](https://www.worldcat.org/title/oopsla-87-addendum-to-the-proceedings-object-oriented-programming-systems-languages-and-applications-october-4-8-1987-orlando-florida/oclc/220450625))，第17-34页。'
- en: 'Martin, Robert C.:* Clean Architecture: A Craftsman''s Guide to Software Structure
    and Design*, Robert C. Martin Series. Boston, MA: Prentice Hall, 2017 — ISBN 978-0-13-449416-6
    ([https://www.worldcat.org/title/clean-architecture-a-craftsmans-guide-to-software-structure-and-design-first-edition/oclc/1105785924](https://www.worldcat.org/title/clean-architecture-a-craftsmans-guide-to-software-structure-and-design-first-edition/oclc/1105785924)).'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Martin, Robert C.：*《整洁架构：软件结构和设计的工匠指南》，罗伯特·C·马丁系列*。波士顿，马萨诸塞州：普伦蒂斯·霍尔，2017 —
    ISBN 978-0-13-449416-6 ([https://www.worldcat.org/title/clean-architecture-a-craftsmans-guide-to-software-structure-and-design-first-edition/oclc/1105785924](https://www.worldcat.org/title/clean-architecture-a-craftsmans-guide-to-software-structure-and-design-first-edition/oclc/1105785924))。
- en: 'Meyer, Bertrand: *Object-Oriented Software Construction.* 1st. Aufl. Upper
    Saddle River, NJ, USA: Prentice-Hall, Inc., 1988 — ISBN 0136290493 ([https://www.worldcat.org/title/object-oriented-software-construction/oclc/1134860513](https://www.worldcat.org/title/object-oriented-software-construction/oclc/1134860513)).'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Meyer, Bertrand：*面向对象软件构造*。第1版。上萨德尔河，新泽西州，美国：普伦蒂斯-霍尔公司，1988 — ISBN 0136290493
    ([https://www.worldcat.org/title/object-oriented-software-construction/oclc/1134860513](https://www.worldcat.org/title/object-oriented-software-construction/oclc/1134860513))。
- en: '`misspell`: Check source code for spelling mistakes. URL: [https://github.com/client9/misspell](https://github.com/client9/misspell).'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`misspell`：检查源代码中的拼写错误。URL：[https://github.com/client9/misspell](https://github.com/client9/misspell)。'
- en: '`prealloc`: Identify slice declarations that could be pre-allocated. URL: [https://github.com/alexkohler/prealloc](https://github.com/alexkohler/prealloc).'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`prealloc`：识别可以预先分配的切片声明。URL：[https://github.com/alexkohler/prealloc](https://github.com/alexkohler/prealloc)。'
- en: '`revive`: A stricter, configurable, extensible, and beautiful drop-in replacement
    for golint. URL: [https://github.com/mgechev/revive](https://github.com/mgechev/revive).'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`revive`：golint的更严格、可配置、可扩展且美观的替代品。URL：[https://github.com/mgechev/revive](https://github.com/mgechev/revive)。'
- en: '`safesql`: Checks code for potential SQL injection points. URL: [https://github.com/stripe/safesql](https://github.com/stripe/safesql).'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`safesql`：检查代码中潜在的SQL注入点。URL：[https://github.com/stripe/safesql](https://github.com/stripe/safesql)。'
- en: '`splint`: Identify functions that are too long or receive too many arguments.
    URL: [https://github.com/stathat/splint](https://github.com/stathat/splint).'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`splint`：识别过长或接收过多参数的函数。URL：[https://github.com/stathat/splint](https://github.com/stathat/splint)。'
- en: '`structcheck`: Identify unused struct fields. URL: [https://gitlab.com/opennota/check](https://gitlab.com/opennota/check).'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`structcheck`：识别未使用的结构体字段。URL：[https://gitlab.com/opennota/check](https://gitlab.com/opennota/check)。'
- en: '`unconvert`: Detect unnecessary type conversions. URL: [https://github.com/mdempsky/unconvert](https://github.com/mdempsky/unconvert).'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unconvert`：检测不必要的类型转换。URL：[https://github.com/mdempsky/unconvert](https://github.com/mdempsky/unconvert)。'
- en: '`unindent`: Identify code that is incorrectly indented. URL: [https://github.com/mvdan/unindent](https://github.com/mvdan/unindent).'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unindent`: 识别错误缩进的代码。URL: [https://github.com/mvdan/unindent](https://github.com/mvdan/unindent).'
- en: '`unparam`: Detect unused function parameters. URL: [https://github.com/mvdan/unparam](https://github.com/mvdan/unparam).'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unparam`: 检测未使用的函数参数。URL: [https://github.com/mvdan/unparam](https://github.com/mvdan/unparam).'
- en: '`varcheck`: Detect unused variables and constants. URL: [https://github.com/opennota/check](https://github.com/opennota/check).'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`varcheck`: 检测未使用的变量和常量。URL: [https://github.com/opennota/check](https://github.com/opennota/check).'
