- en: Best Practices for Writing Clean and Maintainable Go Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Any fool can write code that a computer can understand. Good programmers write
    code that humans can understand."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Martin Fowler ^([8])'
  prefs: []
  type: TYPE_NORMAL
- en: Writing clean code that is easy to test and maintain is much harder than it
    seems at first glance. Fortunately, Go, as a programming language, is quite opinionated
    and comes with its own set of best practices.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at some of the available material for learning Go (for example,
    Effective Go ^([6])) or watch some talks by prominent members of the core Go team
    such as Rob Pike, it becomes evident that software engineers are gently *nudged*
    toward applying those principles when working on their own Go projects. From my
    perspective and experience, these best practices tend to have a measurable positive
    effect on the code quality metrics associated with a code base and at the same
    time aid in minimizing the accumulation of technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the SOLID principles of object-oriented design through the eyes
    of a Go engineer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing source code at the package level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helpful tips and tools for writing lean and easy-to-maintain code in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SOLID principles of object-oriented design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **SOLID** principles are essentially a set of rules for helping you write
    clean and maintainable object-oriented code. Let''s go over what the initials
    stand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open/closed**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov substitution**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface segregation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency inversion**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But hold on a minute! Is Go an object-oriented language or is it a functional
    programming language with some syntactic sugar tacked on top?
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to other, traditional object-oriented programming languages, such as
    C++ or Java, Go has no built-in support for classes. However, it *does* support
    the concepts of *interfaces* and *structs*. Structs allow you to define objects
    as a collection of fields and associated methods. Even though objects and interfaces
    can be *composed* together, there is, *by design*, no support for classic object-oriented
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: With these observations in mind, we should be referring to Go as an *object-based* programming
    language and, as such, the following principles are still valid. Let's take a
    look at each principle in more detail from the perspective of a Go software engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **single responsibility principle** (**SRP**) was described by Robert Martin ^([23]),
    a seasoned software engineer who offers, under the nickname of *Uncle Bob*, advice
    about best practices for software development. The SRP states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"In any well-designed system, objects should only have a single responsibility."'
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, object implementations should focus on doing one thing well,
    and in an efficient way. To understand how this principle works, let's examine
    a piece of code that *violates* it. In the following imaginary scenario, we are
    working for the ACME drone company where we are using Go to build a drone-based
    goods delivery system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code excerpt illustrates one of our initial attempts at defining
    a set of methods for the `Drone` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code violates the SRP by conflating two separate responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the drone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting targets in close proximity to the drone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the case may be, this is a valid, working solution. However, the extra coupling
    that is introduced makes the implementation harder to maintain and extend. For
    instance, what if we want to evaluate different neural network models for object-recognition
    purposes? What if we want to use the same object recognition code for different
    `Drone` types?
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we apply the SRP to improve our design? To begin with, while operating
    under the assumption that all drones come with an on-board camera, we can expose
    a method on the `Drone` object to capture and return an image using the camera.
    At this point, you may be thinking: wait, isn''t image capturing a *different *responsibility
    than navigation? The answer is: it''s all a matter of perspective! Describing
    and assigning responsibilities to objects is an art in itself, and quite a subjective
    one. Conversely, we could counter-argue that navigation needs access to various
    sources of sensor data, and the camera is one of them. In that sense, the proposed
    refactoring is *not* violating the SRP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a second refactoring step, we can extract the target detection code into
    a separate, standalone object that would allow us to move on with the object-recognition
    model evaluation without having to modify any of the code in the `Drone` type.
    The second iteration of the implementation might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In a separate file (possibly in a different package too), we would define the
    `MobileNet` type, which contains the implementation for our target detector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Success! We have split our original implementation into two separate objects,
    with each one having a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **open/closed** principle was coined by Bertrand Meyer ^([24]), who stated
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A software module should be open for extension but closed for modification."'
  prefs: []
  type: TYPE_NORMAL
- en: Almost all Go programs import and use types from a host of other packages, some
    being part of the Go standard library whereas other packages are provided by third
    parties. Any software engineer that imports a package into their code base should
    always safely assume that all the types that are exported by said package adhere
    to a contract that is guaranteed to be immutable. In other words, a package should
    not be able to modify the behavior of the types that are exported by *other* packages.
    While some programming languages allow this type of modification (via a technique
    colloquially referred to as *monkey patching*), the Go designers put safety mechanisms
    in place to ensure that this type of modification is strictly forbidden. Otherwise,
    Go programs would be able to violate the **closed** principle with unforeseen
    consequences for code that's deployed to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you may be wondering: does the closed principle also apply to
    code confined *within* the scope of a package? Additionally, how does Go implement
    the **open** principle? By Meyer''s definition, we should be able to use object-oriented
    principles such as inheritance or composition to extend existing code with additional
    functionality without having to modify the original code units. As we discussed
    at the beginning of the chapter, Go does not support inheritance; that leaves *composition* as
    the only viable approach for extending existing code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine how these principles are intertwined through a simple example.
    After a brief stint in drone design, we decided to switch industries and focus
    on building role-playing games instead. In the following code, you can see the
    definition of a generic `Sword` type for our upcoming game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'One of our design requirements states that we need to support magic items,
    for example, an enchanted sword. Since our enchanted sword is merely a generic
    sword that deals a different amount of damage, we will apply the **open **principle
    and use *composition* to create a new type that embeds the `Sword` type and overrides
    the implementation of the `Damage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, our implementation could not be complete without writing a few table-driven
    tests! The first test function that we will be creating is called `TestSwordDamage` and
    its purpose, as you can probably guess by its name, is to check whether calling `Damage` on
    the types we''ve defined so far produces the expected result. Here is how we would
    go about defining our expectations in a table-driven manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `TestSwordDamage` just iterates over the defined expectations
    and verifies that each one is met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our second test comes with its own list of expectations. This time, the goal
    is to make sure that the output of the `String` methods for the types we defined
    previously produces the correct output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the implementation of `TestSwordToString`, which looks more or less
    the same as `TestSwordDamage`; no surprises here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run `go test`. However, one of our tests fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, what caused the second test to fail? To uncover the reason behind the failed
    test, we need to dig a bit deeper into how Go methods work under the hood. Go
    methods are nothing more than syntactic sugar for invoking a *function* with an
    object instance as an argument (also known as a receiver). In the preceding code
    snippet, `String` is always invoked with a `Sword` receiver and as a result, the
    call to the `Damage` method *always*gets dispatched to the implementation that's
    been defined by `Sword` type.
  prefs: []
  type: TYPE_NORMAL
- en: This is a prime example of the **closed** principle in action: `Sword` is *not
    aware of* any type that may embed it and its set of methods *cannot be altered* by
    objects it is embedded into. It is important to point out that while the `EnchantedSword` type
    cannot modify the implementation of the methods that have been defined on the
    embedded `Sword` instance, it can still *access* and *mutate* any fields defined
    by it (including private ones if both types are defined in the same package).
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third principle from SOLID that we will be exploring is the **Liskov substitution
    principle** (**LSP**). It was introduced by Barbara Liskov in 1987 while delivering
    a keynote session at the **Object-Oriented Programming Systems, Languages, and
    Applications** (**OOPSLA**) conference ^([22]). The formal definition of LSP is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If, for each object, `O1` of type `S` there is an object `O2` of type `T` such
    that for all programs `P` defined in terms of `T`, the behavior of `P` is unchanged
    when `O1` is substituted for `O2`, then `S` is a subtype of `T`.
  prefs: []
  type: TYPE_NORMAL
- en: In layman's terms, two types are *substitutable* if their exhibited behavior
    follows exactly the same contract, thereby making it *impossible* for *callers* to
    distinguish between them. Thinking in pure OO terms, this is probably the textbook
    use case for abstract and concrete classes. As we mentioned in a previous section,
    Go does not support the concept of classes or inheritance but instead relies on *interfaces* as
    the means for facilitating type substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting peculiarity of Go, at least for people coming from a Java or
    C++ background, is that Go interfaces are *implicit*. Each Go type defines an
    implicit interface consisting of all the methods it implements. This design decision
    allows the Go compiler to perform a *compile-time* variant of **duck typing** (the
    formal term for this is **structural typing**) when deciding whether an object
    instance can be passed as a substitute to a function or method that expects a
    particular interface as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term duck typing has its roots in an old adage referred to as the *duck
    test*:'
  prefs: []
  type: TYPE_NORMAL
- en: '"If it looks like a duck and it quacks like a duck, then it is a duck."'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, when given an object and an interface, the object can be used in
    place of the interface *if* its method set contains methods whose name and signature
    match the ones defined by the interface. Not having to explicitly indicate which
    interfaces a type implements is quite a handy feature. It helps us decouple the
    definition of an object (which may be an external or third-party package) from
    the place where the interface is defined and/or used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we''re defining the `Adder` interface and a
    simple function called `PrintSum` that uses any type that satisfies this interface
    to add two numbers together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `adder` package includes the `Int` type, which satisfies the `Adder` interface,
    and another type called `Double`, which doesn''t; even though it defines a function
    called `Add`, you will notice that the argument *types* are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet illustrates how compile-time interface substitution
    checks work. We can safely pass `Int` instances to `PrintSum` as `Int` implicitly
    satisfies the `Adder` interface. However, attempting to pass an instance of `Double` to `PrintSum` will
    trigger a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the cases where the type of the object to be substituted is not known at
    compile time, the compiler will automatically generate code to perform the check
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you aren't sure whether a type instance or an `interface{}` can be cast
    to another type or interface at runtime, it is often good practice to use the
    dual return value variant of the cast operator (the *last* case in the preceding
    code sample) to avoid potential panics while your program is executing.
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the SRP, the **interface segregation principle** (**ISP**) was also
    coined by Robert Martin. According to this principle, clients should not be forced
    to depend upon the interfaces that they do not use.
  prefs: []
  type: TYPE_NORMAL
- en: 'This principle is quite important as it forms the basis for applying the other
    principles we''ve discussed so far. Going back to our previous RPG example, let''s
    assume that we have augmented our `Sword` object with a few more interesting methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how are we going to use weapons in our game? Obviously, we need to introduce
    some *monsters* for the player to attack! This is what the signature of an `Attack` function could potentially
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, there are a few issues with the preceding definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *implicit* (see the previous section) `Sword` interface is quite *open*,
    that is, it includes a bunch of other methods that our `Attack` implementation
    has no need for. In fact, the software engineer implementing `Attack` may be tempted
    to include additional *business logic* rules that rely on the availability of
    those methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the sword blunt after a number of attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cause the player to drop the sword if the monster uses some special armor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going down this path would lead to a violation of the SRP and potentially make
    unit testing of the code harder. In addition, the proposed definition of `Attack` induces
    a strong coupling with objects that either are of the `Sword` type or are other
    types that *embed* it.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two observations fully justify the existence of a famous Go proverb that
    was originally attributed to Rob Pike:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The bigger the interface, the weaker the abstraction."'
  prefs: []
  type: TYPE_NORMAL
- en: While Go implicit interfaces (see the previous section) would allow us to pass *any* type
    that embeds `Sword` (perhaps an `EnchantedSword` from our previous example), our
    requirements will undoubtedly state that `Attack` must be able to work with other
    types of weapons, for example, projectiles or magic spells.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `Attack` expects a `Monster` instance as its first argument.
    It stands to reason that the player should be able to use weapons to deal damage
    to non-monster entities, for example, to break down a bolted door or to cut the
    rope suspending the chandelier from the ceiling. Moreover, ideally, we would want
    to reuse the same implementation when monsters attack the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are all great use cases for applying the ISP. Let''s assume that our `Attack` implementation
    only needs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To figure out the amount of damage that's caused by a weapon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some mechanism to apply the damage to a particular *target*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding observations, we could change the signature of `Attack` to
    accept two explicit interfaces as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this rather simple change, we kill two birds with one stone. Firstly, our
    code is more abstract and it's much easier to test its behavior by providing our
    own test types that implement the required interfaces. Secondly, our interfaces
    are, quite literally, the smallest possible; this fact not only makes the SRP
    application possible but it also alludes to a simpler implementation. As evidenced
    by a quick scan of the Go standard library, single-method interfaces (for example, `Reader`
    and `Writer` interfaces in the `io` package) are a rather prevailing idiom between
    the Go authors.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yet another principle identified by Robert Martin is the **dependency inversion principle**
    (**DIP**). It is, slightly verbosely, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"High-level modules should not depend on low-level modules. Both should depend
    on abstractions. Abstractions should not depend on details. Details should depend
    on abstractions."'
  prefs: []
  type: TYPE_NORMAL
- en: The DIP essentially summarizes all the other principles we've discussed so far.
    If you have been applying the rest of the SOLID principles to your code base,
    you will find that it already adheres to the preceding definition!
  prefs: []
  type: TYPE_NORMAL
- en: The introduction and use of interfaces aids in decoupling high-level and low-level
    modules. The open/closed principle ensures that interfaces themselves are immutable
    but does not preclude us from coming up with any number of alternative implementations
    (the *details* bit in the preceding definition) that satisfy an implicit or explicit
    interface. At the same time, the LSP guarantees that we can rely on the established
    abstractions while also having the flexibility to swap the underlying implementation
    at compile time or even runtime without worrying about breaking our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you decide to apply these principles to your own projects, you will achieve
    greater flexibility in the way you design, connect to, and test software components,
    with the added benefit of requiring less time to extend the code base in the future.
  prefs: []
  type: TYPE_NORMAL
- en: However, one thing to keep in mind is that there is *no such thing as a free
    lunch*. What you gain in flexibility, you lose in the increased size of your code
    base; this could adversely affect the complexity metrics associated with the project.
  prefs: []
  type: TYPE_NORMAL
- en: In my view, this trade-off is not necessarily a bad thing. By following the
    best practices around testing your code (a subject that will be explored in detail
    in upcoming chapters), you can tame any potential increase in code complexity.
    At the same time, encountering difficulties while writing tests is often a good
    sign that your code is probably violating one or more of the SOLID principles
    and needs refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I would like to stress that even though we analyzed the SOLID principles
    through the eyes of a Go engineer, the principles themselves have a much wider
    scope and can also be applied to system design in general. For instance, in a
    microservice-based deployment, you should be aiming to build and deploy services
    with a single purpose (SRP) that communicate through clearly defined contracts
    and boundaries (ISP).
  prefs: []
  type: TYPE_NORMAL
- en: Organizing code into packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous section, the application of the SOLID principles works
    as a guide for splitting our code base into smaller packages where each package
    implements a specific bit of functionality and its interfaces serve as the glue
    for wiring packages together when building larger systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be examining the idiomatic Go way for naming packages,
    as well as some common potential pitfalls you may encounter while authoring code
    that relies on a complex package dependency graph.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions for Go packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say you come across a package named `server`. Is that a good name, as
    per the preceding suggestion? Well, *obviously*, we can guess that it''s some *kind* of
    server, but what kind is that? Is it an HTTP server, for instance, a TCP-based
    server implementing a text-based wire protocol, or maybe a UDP-based server for
    an online game? Some of you may argue that the package might export a type or
    function that alludes to the package''s purpose (for example, `NewHTTPServer`).
    That certainly disambiguates things, but it also introduces a bit of repetition:
    in this particular case, the *server* literal is present in both the package name
    and a function exposed by it. As we will see in the *Improving code quality metrics
    with the help of linters* section, this practice is considered an anti-pattern
    and may cause linter warnings.'
  prefs: []
  type: TYPE_NORMAL
- en: Go package names should be short and concise and provide a clear indication
    of their purpose to the *intended* users of the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'By browsing the code of the Go standard library, we can find quite a few characteristic
    examples of this clear package-naming philosophy:'
  prefs: []
  type: TYPE_NORMAL
- en: The `net` package provides mechanisms for creating various types of network
    listeners (tcp, udp, Unix domain sockets, and more).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `net/http` package provides, among other things, an HTTP server implementation:
    the `http.Server` type name is pretty unambiguous with respect to its use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While package names should be kept short, you should avoid coming up with package
    names that can potentially clash with variable names that are commonly used by
    the code importing the package. Otherwise, package users would have to import
    the package using an *alias* (that is, import *blah* path-to-package). In such
    cases, it is usually better to abbreviate the package name (if possible). Typical
    examples from the Go standard library include the `fmt` and `bufio` packages.
    More specifically, the `bufio` package is named as such to avoid name clashes
    with `buf`, a variable name you are very likely to encounter when dealing with
    a piece of code that uses buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in contrast to other programming languages whose standard libraries
    usually come with utility libraries or packages with generic-sounding names such
    as *common* or *util*, Go is quite opinionated *against* this practice. This is
    actually justified from the SOLID principles' point of view as those packages
    are more likely to be violating the SRP versus aptly named packages whose name
    enforces a logical boundary for their contents. To add to this, as the number
    of published Go packages grows over time, searching for and locating packages
    with generic-sounding names will become more and more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Circular dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a Go program to be well formed, its import graph must be acyclic; in other
    words, it must not contain any loops. Any violation of this predicate will cause
    the Go compiler to emit an error. As the systems you are building grow in complexity,
    so does the probability of eventually hitting the dreaded *import cycle detected*error.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, import cycles are an indication of a fault in the design of a software
    solution. Fortunately, in many cases, we can refactor our code and work around
    most import cycles. Let's take a closer look at some common cases where circular
    dependencies occur and some strategies for dealing with them.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking circular dependencies via implicit interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following imaginary scenario, we are working for a start-up company that
    is building the software that's responsible for controlling fully automated warehouses.
    Autonomous robots equipped with gripping arms and lasers (what could possibly
    go wrong?) are busy moving around the warehouse floor locating and picking up
    order items from the shelves and placing them in cardboard boxes that are then
    shipped to the customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a tentative definition for a warehouse `Robot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the `Item` and `Box` types live in an external
    package called `entity`. All goes well until one day when someone attempts to
    introduce a new helper method to the `Box` type, which, unfortunately, introduces
    an import cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically speaking, this is a bad design decision: boxes and items should
    not really be aware of the robot''s existence. However, for the sake of this argument,
    we will ignore this design flaw and try to work around this problem using Go''s
    support for implicit interfaces. The first step would be to define a `Packer` interface
    within the `entity` package. Secondly, we would need to provide an abstraction
    for obtaining an instance of `Packer`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With these two mechanisms in place, the helper method can work *without* the
    need to import the `warehouse` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The last bit of the puzzle that we need to address is how we are going to initialize `AcquirePacker` without
    importing the `warehouse` package. The only way we can do that is via a *third*
    package that imports the `warehouse` and `entity` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `wireComponents` function ensures that the `warehouse` and
    `entity` packages are wired together without triggering any circular dependency
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, code repetition is not a bad idea!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have probably heard of the **don't repeat yourself** (**DRY**) principle
    before. The main idea behind DRY is to avoid code repetition by aiming to write
    reusable code that can be included where required. But is DRY *always* a good
    idea?
  prefs: []
  type: TYPE_NORMAL
- en: Go packages serve as a nice abstraction for organizing code into modular, reusable
    units. But, generally speaking, a good practice for writing Go programs is to
    try to keep your import dependency graph shallow and wide; this sounds counter-intuitive
    considering it's probably the exact opposite of what the DRY principle advocates: *include
    instead of repeat*.
  prefs: []
  type: TYPE_NORMAL
- en: When the dependency graph becomes deeper, circular dependencies become more
    likely, this time due to *transitive* dependencies, that is, dependencies of packages
    that your code imports. In the following example, we have three packages: `x`, `y`, and `z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package *y* defines a helper function called `IsPrime`, which, as you can probably
    guess by its name, returns a Boolean indicating whether its input is a prime number
    or not. The same package imports and uses some types from package `*z*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Package `z` imports some types from package `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. A few days go by and then we decide to add a new helper function
    to package `x` called `IsValid`. The function needs to perform a primality test
    and, since package `y` already provides `IsPrime`, we decide to follow the DRY
    approach and import *y* into our code, causing a circular dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases like this, and assuming the code we need from the included package
    is small enough, we can just duplicate it (along with its tests) and avoid the
    extra import that triggers a circular dependency. As a popular Go proverb goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A little copying is better than a little dependency."'
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tools for writing lean and easy-to-maintain Go code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the upcoming sections, we will be covering some techniques, tools, and best
    practices that can assist you in writing more concise and clean code that is easier
    to test and at the same time help you get some praise from your colleagues and
    code reviewers.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the topics that we will be discussing are specific to Go, but some of
    the principles can be generalized and applied to other programming languages and
    software engineering in general.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing function implementations for readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During my early university days, my CS professors would be adamant about keeping
    function blocks short and concise. Their advice went along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"If a function implementation does not fit on a single screen, then it must
    be split up into smaller functions."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that these guidelines have their roots in an era when by *screen*,
    people were referring to the amount of code that could fit in an 80×25 character
    terminal! Fast forward to today where things have changed: software engineers
    have access to high-resolution monitors, editors, and bespoke IDEs that come preloaded
    a wide gamut of sophisticated analysis and refactoring tools. Still, the same
    bit of advice is just as important for writing code that is easy for *others* to
    review, extend, and maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Single responsibility* section, we discussed the merits of the SRP.
    Unsurprisingly, the same principle also applies to function blocks and is something
    to keep at the back of your mind when coding.
  prefs: []
  type: TYPE_NORMAL
- en: By decomposing a complex function into smaller functions, the code becomes easier
    to read and reason about. This may not seem important at first, but think about
    a case where you don't touch the code for a couple of months and then need to
    dive back into it while trying to track down a bug. As a bonus, the isolated bits
    of logic also become easier to test, especially if you are following the practice
    of writing table-driven tests.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, it follows that the same approach can be applied to existing code.
    If you find yourself navigating through a lengthy function that contains deeply
    nested `if`/`else` blocks, repeated blocks of code, or its implementation tackles
    several seemingly unrelated concerns, it would be a great opportunity to apply
    some drive-by refactoring and extract any potential self-contained blocks of logic
    into separate functions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when creating new functions or splitting existing functions into
    smaller ones, a good idea is to arrange the functions so that they appear in call
    order within the file they are defined in, that is, if `A()` calls `B()` and `C()`,
    then both `B()` and `C()` must appear below, but not necessarily immediately after, `A()`.
    This makes it much easier for other engineers (or people just curious to understand
    how something works) to skim through existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Each rule comes with exceptions and this rule is no different. Unless the compiler
    is very good at inlining functions, splitting the business logic across functions
    sometimes takes a toll on performance. Although the performance hit is, in many
    cases, insignificant, when the end goal is to produce high-performance code that
    contains tight inner loops or code that is expected to be called with high frequency,
    it may be a good idea to keep the implementation neatly tucked within a single
    function to avoid the extra Go runtime overhead that's incurred when making function
    calls (for example, pushing arguments to the stack, checking that the stack is
    large enough for the callee, and popping things off the stack when the function
    call returns).
  prefs: []
  type: TYPE_NORMAL
- en: There is always a trade-off between code readability and performance. When dealing
    with complex systems, readability is oftentimes preferred, but at the end of the
    day, it's up to you and your team to figure out which mix of readability versus
    performance works best for your particular use case.
  prefs: []
  type: TYPE_NORMAL
- en: Variable naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an ongoing debate regarding the ideal length for variables and type
    names in Go programs. On one hand, there are the proponents of the belief that
    all variables should have clear and self-descriptive names. This is a fairly common
    philosophy for people who have spent some time authoring code in the Java ecosystem.
    On the other side of the fence, we have the *minimalists*, that is, people who
    advocate for shorter identifier names, arguing that longer identifiers are too
    verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go language authors certainly seem to be members of the latter camp. Case
    in point, here is the definition of two of the most popular Go interfaces: `io.Reader` and `io.Writer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The same short identifier pattern is widely used throughout the Go standard
    library code base. My take on this is that using *shorter* but still *descriptive* variable
    names is a good thing as long as other engineers that will be called to work on
    the code base in the future can easily understand their purpose within the scope
    that each variable is being used in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common example of this approach is naming index variables for nested
    loops where, typically, a single-letter variable such as `i`, `j`, and so on is
    used. In the following code snippet, however, the index variables are used to
    access an element of the multi-dimensional slice `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If someone who''s not familiar with this part of the code is tasked with reviewing
    a pull request containing the preceding loop, they may find themselves struggling
    to figure out what `s` is and what each index level represents! Since the shortened
    variable names provide almost no information regarding their true purpose, to
    answer these questions, the reviewer would have to jump around the code base looking
    for clues: look up the type for `s`, then go to its definition, and so on and
    so forth. Now, contrast the preceding code block with the following one, which
    performs exactly the same function but uses *slightly longer* variable names.
    In my opinion, the second approach has higher information content while at the
    same time avoids being too verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the day, each engineer has their own preferred variable naming
    approach and philosophy. When deciding on which approach to adopt, try to take
    a few minutes to consider how your variable naming choices affect other engineers
    that collaborate with you on shared code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Using Go interfaces effectively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Accept interfaces, return structs."'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Jack Lindamood*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point behind organizing code into packages is to make it reusable and
    available to external consumers in a frictionless way by providing a clean, well-documented
    API surface that consumers can build on. When authoring functions or methods that
    accept concrete types as arguments, we place an artificial constraint on the usefulness
    of our implementation: it only works with instances of a particular type.'
  prefs: []
  type: TYPE_NORMAL
- en: While this may not always be an issue, in some cases, requiring a concrete type
    instance can potentially make testing non-trivial and slow, especially if the
    construction of such an instance is a costly operation. The following excerpt
    is part of a system that collects and publishes performance metrics to a **key-value**
    (**KV**) store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The KV store implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `metrics` package, we can find the definition of the `ReportMetrics` function.
    It receives a `kv.Store` instance as an argument and persists the collected metrics
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Based on the previous discussion around SOLID principles, you should have already
    identified an issue with this code: *it only works with a specific KV store implementation*!
    What if we want to publish the metrics to a network socket, write them to a CSV
    file, or perhaps log them to the console?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, yet another issue with this bit of code: testing it requires
    quite a bit of effort. To understand why, let''s put ourselves in the shoes of
    a consumer of this package. As part of our integration test suite, we want to
    make sure that all the collected metrics are actually written to the KV store
    instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our test code would have to create an instance of the KV store. Since
    the `Open` method requires a file and we could be running multiple tests concurrently,
    we would need to create a temporary unique file and pass it as an argument to `Open`.
    Of course, we shouldn''t leave temporary files hanging around after our test run
    completes, so we need to make sure our test will clean up after itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'That brings us to the meat of the test: creating a metrics collector, populating
    it with a bunch of measurements, reporting the captured metrics to the KV store,
    and verifying that everything has been written to the store properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This test is pretty straightforward but it requires quite a bit of boilerplate
    code for setting it up. Additionally, `kv.Open` seems like it is quite an expensive
    call to make; imagine the overhead involved if our test suite was comprised of
    hundreds of tests where each one required a *real* `kv.Store` instance. If, on
    the other hand, `ReportMetrics` received an interface as an argument, we could
    pass an in-memory mock while testing and also retain the flexibility to report
    the metrics to any destination that satisfies that particular interface. Therefore,
    we can improve the preceding code by introducing an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This small change makes testing a breeze! We can test the `kv.Store` code in
    isolation and switch to an in-memory store to run all our unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The other piece of advice from Lindamood states that we should always try to
    return concrete types rather than interfaces. This advice actually makes sense:
    as a package consumer, if I am calling a function that creates a type, `Foo`,
    I am probably interested in calling one or more methods that are specific to that
    type. If the `NewFoo` function returns an interface, the client code would have
    to manually cast it to `Foo` so that it can invoke the `Foo`-specific methods;
    this would defeat the purpose of returning an interface in the first place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also important to point out that, in the majority of cases, the implementation
    will create an instance of a concrete type; the main reason why we would opt to
    return an interface to begin with is to ensure that our concrete type always satisfies
    a particular interface. In essence, we are adding a compile-time check to our
    code! However, there are simpler ways to introduce such compile-time checks and
    still retain the ability for constructors to return concrete instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet outlines two fairly common approaches to achieve
    this compile-time check by defining a pair of global variables that use the reserved *blank
    identifier* as a hint to the compiler that they are not actually used.
  prefs: []
  type: TYPE_NORMAL
- en: Zero values are your friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One great feature that Go offers is that each type is automatically assigned
    its zero value when it gets instantiated. Some interesting examples from Go and
    its standard library are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go channels; nil channels indefinitely block go-routines attempting to read
    off them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zero value for a Go slice; this is an empty slice that things can be appended
    to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sync.Mutex` type, whose zero value indicates that the mutex is unlocked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bytes.Buffer` type, whose zero value indicates an empty buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By relying on zero values when designing new types, we can provide implementations
    that work out of the box without the need to explicitly invoke a constructor or
    any other initializer method. The following code snippet defines a simple, thread-safe
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual Go map that will be used to store the `SyncMap` data will be lazily
    allocated when we attempt to add an item to the map. Acquiring a *writer* mutex
    before working with the underlying map ensures that both the initialization of
    the map and the insertion of items happen in an atomic fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The lookup implementation is pretty straightforward. One noticeable difference
    compared to the implementation of `Put` is that `Get` acquires a *reader* mutex
    before performing lookups. The use of a reader/writer mutex provides concurrent
    access to multiple readers while only allowing a single writer to mutate the map''s
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrary to the built-in Go map type, which requires explicit initialization
    via a call to `make`, the zero value of a `SyncMap` can be safely used as is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s more, we can *embed* the preceding `SyncMap` implementation into other
    types that follow the same zero value pattern to provide complex types that require
    no initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `SyncMap` instance is ready to use and can
    be accessed directly through an instance of `Foo` without having to type any additional
    code to set it up.
  prefs: []
  type: TYPE_NORMAL
- en: Using tools to analyze and manipulate Go programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go programs are inherently easy to parse. In fact, the Go library provides built-in
    packages that can parse Go programs into **abstract syntax trees** (**ASTs**),
    which can be traversed, modified, and transformed back into Go code. Let's go
    through a simple example to show you how easy it is to work with these packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a helper function to convert a Go program into an AST representation.
    The following `parse` function does exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ast` package provides a couple of helpers that implement the visitor pattern
    and invokes a user-defined callback for each node in the AST. For this particular
    example, we will define a function called `inspectVariables` that visits every
    node in the AST, looking for nodes that correspond to identifiers (package, constant,
    type, variable, function, or label). For each discovered identifier, the function
    will check its `Kind` attribute and print out its name if the identifier represents
    a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our example, we need to provide a `main` function that will parse
    a simple program and call `inspectVariables` on the resulting AST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding program produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The Go ecosystem contains a plethora of tools that build on top of this parsing
    infrastructure and provide analysis, code modification, and generation services
    to software engineers. In the upcoming sections, we will examine a short list
    of such tools that can make your software development life easier.
  prefs: []
  type: TYPE_NORMAL
- en: Taking care of formatting and imports (gofmt, goimports)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tabs or spaces? Should opening braces be preceded by line breaks? All engineers
    eventually face this dilemma when the time comes to choose a particular code formatting
    style for a new project or a project they've just inherited.
  prefs: []
  type: TYPE_NORMAL
- en: Source code formatting styles have always been the subject of long, often heated,
    arguments between team members. Contrary to other programming languages, Go is,
    by design, strongly opinionated toward a specific formatting style and ships with
    tools that help enforce that particular style. This design decision makes sense
    as Go was initially created with the goal of being used by the thousands of engineers
    employed by Google. At this massive development scale, uniformity in the authored
    code is not just a nicety – it's actually vital for ensuring that code can be
    handed off between development teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gofmt` tool ^([11]) is available as part of the standard Go distribution.
    You provide it with the paths to one or more files and it can perform the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Format code according to the recommended standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify code (`gofmt -s example.go`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform simple rewrites (`gofmt -r ‘a[b:len(a)] -> a[len(a):b]’ example.go`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, `gofmt` will output the formatted programs to the standard output.
    However, users may pass the `-w`flag to force `gofmt` to write its output back
    to the source file that it just processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `goimports` tool ^([12]) is a drop-in replacement for `gofmt` that can
    be installed by running `go get golang.org/x/tools/cmd/goimports`. In addition
    to providing code-formatting facilities that match the output of `gofmt`, `goimports` also
    manages Go import lines: it can fill in missing imports and remove the ones that
    aren''t referenced by the processed file. What''s more, `goimports` also ensures
    that packages are sorted alphabetically and grouped together, depending on whether
    they belong to the standard library or are third-party packages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a Go program that exhibits a couple of issues:
    missing imports, unused imports, extraneous whitespace, and incorrect indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The typical use case for these tools is to execute them as post-save hooks
    from your favorite editor or IDE. If we run `goimports` on the preceding code
    snippet, we will get a neatly formatted output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the import statements have been cleaned up and sorted, the missing
    packages have been imported, and unused packages have been removed. Adding to
    this, the code is now properly indented and all the extraneous whitespace has
    been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring code across packages (gorename, gomvpkg, fix)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oftentimes, you may come across a variable within a function that has a strange
    or non-descriptive name that you are quite keen on renaming. Performing such a
    rename operation is quite simple; just select the function block and run a find-and-replace
    operation. Simple as pie!
  prefs: []
  type: TYPE_NORMAL
- en: But what if you want to rename a public struct field or a function that is exported
    from your package? This is definitely not a trivial task as you need to track
    down all the references to the thing being renamed (the list may also include
    other packages) and update them to use the new name. This type of rename operation
    takes us into the realm of code refactoring; fortunately, there is a tool at our
    disposal for automating this tedious task: `gorename` ^([16]). It can be installed
    by running `go get golang.org/x/tools/cmd/gorenam*e*`.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting feature of `gorename`, besides the fact that it works across
    packages, is that it is *type-aware*. Since it relies on parsing the program before
    it applies any rename operation, it is intelligent enough to tell the difference
    between a function called `Foo` and a struct field with the same name. Furthermore,
    it includes an extra layer of safety in that it will only apply rename operations
    as long as the end result is a piece of code that can compile without errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you may find yourself needing to rename a Go package or even move
    it to a different location either within the same project or across projects.
    The `gomvpkg` tool ^([15]) can assist in that matter while also taking care of
    tracking down packages that depend on the renamed/moved package and updating their
    import statements to point to the new package location. It can be installed by
    running `go get golang.org/x/tools/cmd/gomvpkg`. Moving a package is as simple
    as running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The Go standard library has changed a lot over the years since the release of
    the first stable Go version back in 2011\. New APIs were introduced while other
    APIs were deprecated and eventually removed. In some cases, existing APIs are
    modified, often in a non-backward-compatible way, whereas in other cases, external
    or experimental packages eventually got accepted for inclusion in the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: A relevant example is the `context` package. Prior to Go 1.7, this package was
    available at `golang.org/x/net/context`and quite a few Go programs were actively
    using it. But with the release of Go 1.7, that package became a part of the standard
    library and moved to a standalone `context` package. As soon as engineers switched
    to the new import path for the context package, their code would instantly become
    incompatible with code still using the old import path. Therefore, someone would
    have to undertake the task of reviewing the existing code base and rewriting existing
    imports to point to the new location for the context package!
  prefs: []
  type: TYPE_NORMAL
- en: The Go designers foresaw such issues and created a rule-based tool to detect
    code that relies on old, deprecated APIs or packages, and automatically rewrite
    it to use newer APIs. The tool, aptly named `fix` ([https://golang.org/cmd/fix/](https://golang.org/cmd/fix/)),
    ships with each new Go release and can be invoked each time you switch to a newer
    Go version by running `go tool fix $path`. It is important to point out that all
    applied fixes are *idempotent*; therefore, it is safe to run the tool multiple
    times without the risk of your code base becoming corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Improving code quality metrics with the help of linters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linters are specialized static analysis tools that parse Go files and attempt
    to detect, flag, and report cases where the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: The code does not adhere to the standard formatting style guide; for example, it
    contains extraneous whitespace, is incorrectly indented, or contains comments
    with spelling typos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program contains possible logic bugs; for example, a variable declaration *shadowing* a
    previous variable declaration with the same name, calling functions such as `fmt.Printf` with
    an incorrect argument count or with arguments whose types do not match the format
    string, assigning values to variables but not actually using them, not checking
    errors returned by function calls, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code may contain security vulnerabilities; for example, it contains hardcoded
    security credentials or points to where an SQL injection might be possible using
    insecure random number sources or cryptographically broken hash primitives (DES,
    RC4, MD5, or SHA1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code exhibits high complexity (for example, deeply nested `if`/`else` blocks)
    or contains unnecessary type conversions, unused local or global variables, or
    code paths that are never invoked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table summarizes the most popular Go linters that you can invoke
    to check your programs and improve the quality metrics of the code that you author:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Linter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Logic bugs | `bodyclose` ^([2]) | Check if `http.Response` bodies are always
    closed. |'
  prefs: []
  type: TYPE_TB
- en: '| Logic bugs | `errcheck` ^([7]) | Identify cases where returned errors are
    not being checked. |'
  prefs: []
  type: TYPE_TB
- en: '| Logic bugs | `gosumcheck` ^([19]) | Ensure that all possible cases of a type
    switch are handled properly. |'
  prefs: []
  type: TYPE_TB
- en: '| Logic bugs | `go vet` ([https://golang.org/cmd/vet/](https://golang.org/cmd/vet/)) ^([20])
    | Report suspicious constructs, for example, calling `fmt.Printf` with the wrong
    arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| Logic bugs | `ineffassign` ^([21]) | Detect variable assignments that are
    not being used. |'
  prefs: []
  type: TYPE_TB
- en: '| Code smell | `deadcode` ([https://github.com/tsenart/deadcode](https://github.com/tsenart/deadcode)) ^([4])
    | Report unused blocks of code. |'
  prefs: []
  type: TYPE_TB
- en: '| Code smell | `dupl` ([https://github.com/mibk/dupl](https://github.com/mibk/dupl)) ^([5])
    | Report potentially duplicated blocks of code. |'
  prefs: []
  type: TYPE_TB
- en: '| Code smell | `goconst` ([https://github.com/jgautheron/goconst](https://github.com/jgautheron/goconst)) ^([9])
    | Flag repeated strings that can be replaced with constants. |'
  prefs: []
  type: TYPE_TB
- en: '| Code smell | `structcheck` ([https://gitlab.com/opennota/check](https://gitlab.com/opennota/check)) ^([30])
    | Identify unused struct fields. |'
  prefs: []
  type: TYPE_TB
- en: '| Code smell | `unconvert` ([https://github.com/mdempsky/unconvert](https://github.com/mdempsky/unconvert)) ^([31])
    | Detect unnecessary type conversions. |'
  prefs: []
  type: TYPE_TB
- en: '| Code smell | `unparam` ([https://github.com/mvdan/unparam](https://github.com/mvdan/unparam)) ^([33])
    | Detect unused function parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| Code smell | `varcheck` ^([34]) | Detect unused variables and constants.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | `aligncheck` ^([1]) | Identify inefficiently packed structs
    that take up more space due to padding. |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | `copyfighter` ([https://github.com/jmhodges/copyfighter](https://github.com/jmhodges/copyfighter)) ^([3])
    | Reports functions that pass large structs by value; this pattern triggers memory
    allocations and increases pressure on the garbage collector. |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | `prealloc` ^([26]) | Identify slice declarations that could
    be preallocated. |'
  prefs: []
  type: TYPE_TB
- en: '| Complexity | `gocyclo` ^([10]) | Calculate cyclomatic complexities of Go
    functions. |'
  prefs: []
  type: TYPE_TB
- en: '| Complexity | `gosimple` ^([18]) | Report code that can be potentially simplified.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Complexity | `splint` ^([29]) | Identify functions that are too long or receive
    too many arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| Security | `gosec` ([https://github.com/securego/gosec](https://github.com/securego/gosec)) ^([17])
    | Scan source code for potential security issues. |'
  prefs: []
  type: TYPE_TB
- en: '| Security | `safesql` ([https://github.com/stripe/safesql](https://github.com/stripe/safesql))^( [28])
    | Check for potential SQL injection points. |'
  prefs: []
  type: TYPE_TB
- en: '| Style | `gofmt -s` ([https://golang.org/cmd/gofmt/](https://golang.org/cmd/gofmt/)) ^([11])
    | Ensure that a file is formatted according to `gofmt` rules. |'
  prefs: []
  type: TYPE_TB
- en: '| Style | `golint` ([https://github.com/golang/lint](https://github.com/golang/lint)) ^([14])
    | Report stylistic deviations from the recommendations outlined in Effective Go ^([6]).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Style | `misspell` ([https://github.com/client9/misspell](https://github.com/client9/misspell)) ^([25])
    | Use a dictionary to identify spelling mistakes in comments. |'
  prefs: []
  type: TYPE_TB
- en: '| Style | `unindent` ([https://github.com/mvdan/unindent](https://github.com/mvdan/unindent)) ^([32])
    | Identify code that isn''t indented correctly. |'
  prefs: []
  type: TYPE_TB
- en: Using the preceding linters in your projects comes with a few caveats that you
    need to be aware of. First of all, each linter uses its own output format to report
    detected issues. The lack of a standardized way to report issues becomes a problem
    when you attempt to integrate the linters with your preferred editor or IDE workflows
    (for example, jump to the code location where an issue was detected). Secondly,
    each linter is oblivious to the existence of other linters. Consequently, *each* linter
    needs to reparse all the packages when it runs. This is usually not an issue when
    you're dealing with small code bases, but it becomes annoying when you're working
    with larger projects, as an end-to-end run of all the linters can take up to a
    few minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address the preceding issues, you can use a **meta-linter** (also known
    as a **linter output aggregator**) tool such as `golangci-lint` ^([13]) (a drop-in
    replacement for the now-deprecated gometalinter) or revive ^([27]). These tools
    are designed to execute a configurable list of linters in parallel, normalize
    their output, eliminate duplicate warnings, or even suppress warnings based on
    regular expressions (quite a handy feature when your project includes files that
    are autogenerated by other tools). What''s more, they also seamlessly integrate
    with the majority of editors that are used by engineers working on Go programs.
    An easy way to invoke these meta-linter tools is to add a target to your project''s *makefile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Having a makefile rule for linting makes it easy to run the linters as part
    of your regular CI pipeline and block pull requests from being merged until the
    lint errors are addressed. At the same time, it offers you the flexibility of
    running the linters locally while you are working on the code base.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite common for engineers to forgo running the linters before creating
    a pull request, thereby requiring additional commits just to address lint errors.
    You can avoid such situations by exploiting the fact that most version control
    systems (Git is one example) support some kind of pre-commit or pre-push hook
    and have your VCS run the linters automatically for you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first section of this chapter, *The SOLID principles of object-oriented
    design*, we performed a deep dive into each of the SOLID principles and how they
    can be applied toward writing clean Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SRP**: Group structs and functions based on their purpose and organize them
    into packages with clear logical boundaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open/Closed principle**: Use composition and embedding of simple types to
    construct more complex types that still retain the same implicit interface as
    the types they consist of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LSP**: Avoid unnecessary coupling by using interfaces rather than concrete
    types to define the contract between packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ISP**: Make sure your function or method signatures only depend on the behaviors
    they need and nothing more; use the smallest possible interface to describe function/method
    arguments and avoid coupling to the implementation details of concrete types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DIP**: Use the appropriate level of abstraction when designing your code
    to decouple high-level and low-level modules while at the same time ensuring that
    the implementation details rely on the abstractions and not the other way round.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Halfway through this chapter, we touched on the subject of organizing code into
    packages, identified common package naming pitfalls that you should avoid, and
    discussed the concept of import cycles, including their causes. Then, we outlined
    strategies for mitigating the issue of circular dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed useful tips and tools that you can use to facilitate writing
    clean code that is easy to reason about and for your software engineering colleagues
    to review and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: As your Go projects grow in size, you will undoubtedly notice a bump in the
    number of package import statements throughout the code base. This is quite normal
    and, frankly, expected if you are applying the SOLID principles when creating
    packages. However, the increased number of imports, especially if they are authored
    by third parties that you do not control, also necessitate some kind of process
    to ensure that your programs can still compile as expected, even if an external
    dependency changes. This is the main topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do the SOLID acronym initials stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does the following piece of code violate the SRP? How would you refactor
    it to make sure it doesn't violate it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the main concept behind the ISP? Discuss how would you apply it to
    improve the following function signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Explain why *util* is considered to be a less-than-ideal name for a Go package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are import cycles an issue for Go programs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some of the advantages of using the zero value when designing new Go types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`aligncheck`: Identify inefficiently packed structs. URL: [https://gitlab.com/opennota/check](https://gitlab.com/opennota/check).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bodyclose`: A static analysis tool that checks whether `res.Body` is correctly
    closed. URL: [https://github.com/timakin/bodyclose](https://github.com/timakin/bodyclose).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`copyfighter`: Statically analyze Go code and report functions while passing
    large structs by value. URL: [https://github.com/jmhodges/copyfighter](https://github.com/jmhodges/copyfighter).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`deadcode`: Report unused blocks of code. URL: [https://github.com/tsenart/deadcode](https://github.com/tsenart/deadcode).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dupl`: Report potentially duplicated blocks of code. URL: [https://github.com/mibk/dupl](https://github.com/mibk/dupl).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Effective Go: Tips for writing clear, idiomatic Go code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`errcheck`: Ensure that returned errors are checked. URL: [https://github.com/kisielk/errcheck](https://github.com/kisielk/errcheck).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fowler, Martin: *Refactoring: Improving the Design of Existing Code.* Boston,
    MA, USA: Addison-Wesley, 1999 — ISBN 0-201-48567-2 ([https://www.worldcat.org/title/refactoring-improving-the-design-of-existing-code/oclc/863697997](https://www.worldcat.org/title/refactoring-improving-the-design-of-existing-code/oclc/863697997)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`goconst`: Flag repeated strings that can be replaced with constants. URL: [https://github.com/jgautheron/goconst](https://github.com/jgautheron/goconst).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gocyclo`: Calculate cyclomatic complexity of code. URL: [https://github.com/alecthomas/gocyclo](https://github.com/alecthomas/gocyclo).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gofmt`: Format Go programs or check that they are properly formatted. URL: [https://golang.org/cmd/gofmt/](https://golang.org/cmd/gofmt/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`goimports`: Update Go import lines by adding missing ones and removing unreferenced
    ones. URL: [https://godoc.org/golang.org/x/tools/cmd/goimports](https://godoc.org/golang.org/x/tools/cmd/goimports).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`golangci-lint`: Linter runner. URL: [https://github.com/golangci/golangci-lint](https://github.com/golangci/golangci-lint).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`golint`: Report style issues in Go programs. URL: [https://github.com/golang/lint](https://github.com/golang/lint).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gomvpkg`: Move Go packages and update import declarations. URL: [https://godoc.org/golang.org/x/tools/cmd/gomvpkg](https://godoc.org/golang.org/x/tools/cmd/gomvpkg).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gorename`: Perform precise type-safe renaming of identifiers in Go source
    code. URL: [https://godoc.org/golang.org/x/tools/cmd/gorename](https://godoc.org/golang.org/x/tools/cmd/gorename).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gosec`: Scan source code for potential security issues. URL: [https://github.com/securego/gosec](https://github.com/securego/gosec).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gosimple`: Report code that can be potentially simplified. URL: [https://github.com/dominikh/go-tools/tree/master/cmd/gosimple](https://github.com/dominikh/go-tools/tree/master/cmd/gosimple).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gosumcheck`: Ensure that all possible types in a type switch are properly
    handled. URL: [https://github.com/haya14busa/gosum](https://github.com/haya14busa/gosum).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`go vet`: Examine Go source code and report suspicious constructs, such as
    `printf` calls whose arguments do not align with the format string or shadowed
    variables. URL: [https://golang.org/cmd/vet/](https://golang.org/cmd/vet/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ineffassign`: Detect variable assignments that are not being used. URL: [https://github.com/gordonklaus/ineffassign](https://github.com/gordonklaus/ineffassign).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Liskov, Barbara: Keynote Address – Data Abstraction and Hierarchy. In: *Addendum
    to the Proceedings on Object-oriented Programming Systems, Languages and Applications
    (Addendum)*, OOPSLA ''87\. New York, NY, USA : ACM, 1987 — ISBN 0-89791-266-7
    ([https://www.worldcat.org/title/oopsla-87-addendum-to-the-proceedings-object-oriented-programming-systems-languages-and-applications-october-4-8-1987-orlando-florida/oclc/220450625](https://www.worldcat.org/title/oopsla-87-addendum-to-the-proceedings-object-oriented-programming-systems-languages-and-applications-october-4-8-1987-orlando-florida/oclc/220450625)),
    S. 17–34.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Martin, Robert C.:* Clean Architecture: A Craftsman''s Guide to Software Structure
    and Design*, Robert C. Martin Series. Boston, MA: Prentice Hall, 2017 — ISBN 978-0-13-449416-6
    ([https://www.worldcat.org/title/clean-architecture-a-craftsmans-guide-to-software-structure-and-design-first-edition/oclc/1105785924](https://www.worldcat.org/title/clean-architecture-a-craftsmans-guide-to-software-structure-and-design-first-edition/oclc/1105785924)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Meyer, Bertrand: *Object-Oriented Software Construction.* 1st. Aufl. Upper
    Saddle River, NJ, USA: Prentice-Hall, Inc., 1988 — ISBN 0136290493 ([https://www.worldcat.org/title/object-oriented-software-construction/oclc/1134860513](https://www.worldcat.org/title/object-oriented-software-construction/oclc/1134860513)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`misspell`: Check source code for spelling mistakes. URL: [https://github.com/client9/misspell](https://github.com/client9/misspell).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`prealloc`: Identify slice declarations that could be pre-allocated. URL: [https://github.com/alexkohler/prealloc](https://github.com/alexkohler/prealloc).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`revive`: A stricter, configurable, extensible, and beautiful drop-in replacement
    for golint. URL: [https://github.com/mgechev/revive](https://github.com/mgechev/revive).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`safesql`: Checks code for potential SQL injection points. URL: [https://github.com/stripe/safesql](https://github.com/stripe/safesql).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`splint`: Identify functions that are too long or receive too many arguments.
    URL: [https://github.com/stathat/splint](https://github.com/stathat/splint).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`structcheck`: Identify unused struct fields. URL: [https://gitlab.com/opennota/check](https://gitlab.com/opennota/check).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unconvert`: Detect unnecessary type conversions. URL: [https://github.com/mdempsky/unconvert](https://github.com/mdempsky/unconvert).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unindent`: Identify code that is incorrectly indented. URL: [https://github.com/mvdan/unindent](https://github.com/mvdan/unindent).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unparam`: Detect unused function parameters. URL: [https://github.com/mvdan/unparam](https://github.com/mvdan/unparam).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`varcheck`: Detect unused variables and constants. URL: [https://github.com/opennota/check](https://github.com/opennota/check).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
