["```go\n// SemVer contains the major, minor, patch components of a semantic version\n// string.\ntype SemVer [3]int\n\n// GreaterThan returns true if the receiver version is greater than other.\nfunc (sv SemVer) GreaterThan(other SemVer) bool {\n for i, v := range sv {\n if v != other[i] {\n return v > other[i]\n }\n }\n\n return false\n}\n```", "```go\npackage weather\n\n// Prediction describes a weather prediction.\ntype Prediction uint8\n\n// The supported weather prediction types.\nconst (\n Sunny Prediction = iota\n Rain\n Overcast\n Snow\n Unknown\n)\n\n// predictAtCoords returns a weather prediction for the specified GPS coordinates.\nfunc predictAtCoords(lat, long float64) (Prediction, error) { // ... }\n```", "```go\n// PredictAtCoords returns a weather prediction for the specified GPS coordinates.\nfunc PredictAtCoords(lat, long float64) (Prediction, error) {\n // ...\n}\n```", "```go\n// PredictAtPlusCode the weather at the location specified by a plus code.\nfunc PredictAtPlusCode(code string) (Prediction, error) {\n // ...\n}\n```", "```go\npackage weather \n\n// Locator is implemented by objects that can represent a location as a\n// pair of GPS coordinates.\ntype Locator interface {\n Coords() (float64, float64, error)\n}\n\n// Predict the weather at the specified location.\nfunc Predict(loc Locator) (Prediction, error) {\n coords, err := loc.Coords()\n if err != nil {\n return Unknown, err\n }\n // ...\n}\n```", "```go\npackage location\n\n// GPSCoords holds a lat/long coordinate pair.\ntype GPSCoords [2]float64\n\n// PlusCode encodes a location using a plus code.\ntype PlusCode string\n\n// Address encapsulates the components of an address.\ntype Address struct {\n Street   string\n City     string\n PostCode string\n Country  string\n}\n```", "```go\nfunc (g GPSCoords) Coords() (float64, float64, error) { \n return g[0], g[1], nil \n}\n\nfunc (pc PlusCode) Coords() (float64, float64, error) { \n // Decode plus code to gps coordinates... \n}\n\nfunc (a Address) Coords() (float64, float64, error) { \n // Use an external geocoding service to convert the address into a set \n // of GPS coordinates...\n}\n```", "```go\nimport (\n \"fmt\"\n\n \"github.com/weather-as-a-service/weather/v2\"\n \"github.com/weather-as-a-service/weather/v2/location\"\n)\n\nfunc makePrediction() error{\n loc := location.PlusCode(\"9C3XGV00+\")\n pred, err := weather.Predict(loc)\n if err != nil {\n return err \n }\n fmt.Printf(\"The weather prediction for London is: %v\", pred)\n}\n```", "```go\nimport (\n \"fmt\"\n\n \"gopkg.in/weather-as-a-service/weather.v2\"\n \"gopkg.in/weather-as-a-service/weather.v2/location\"\n)\n```", "```go\n[[constraint]]\n  name = \"github.com/sirupsen/logrus\"\n  branch = \"master\"\n```", "```go\n[[constraint]]\n  name = \"github.com/sirupsen/logrus\"\n  branch = \"master\"\n\n  # Pull the package sources from this alternative repository\n  source = \"github.com/achilleasa/logrus\" \n```", "```go\npackage main\n\nimport (\n \"fmt\"\n \"os\"\n\n \"github.com/go-yaml/yaml\"\n)\n\nfunc main() {\n var data map[string]interface{}\n if err := yaml.NewDecoder(os.Stdin).Decode(&data); err == nil {\n fmt.Printf(\"%v\\n\", data)\n }\n}\n```", "```go\nmodule parser\n\ngo 1.12\n```", "```go\n$ go build\ngo: finding github.com/go-yaml/yaml v2.1.0+incompatible\ngo: downloading github.com/go-yaml/yaml v2.1.0+incompatible\ngo: extracting github.com/go-yaml/yaml v2.1.0+incompatible\n```", "```go\nimport (\n \"github.com/go-yaml/yaml\" // V2.1.0\n v4 \"github.com/go-yaml/yaml/v4\" // The V4 version of the package.\n)\n```"]