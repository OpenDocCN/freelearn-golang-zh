- en: Dependency Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项管理
- en: '"If at first you don''t succeed, call it version 1.0."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “如果一开始没有成功，那就叫它1.0版本。”
- en: '- Pat Rice'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Pat Rice'
- en: Being strong believers in the SOLID principles we discussed in the previous
    chapter, several prominent figures in the Go community strongly advise software
    engineers to organize their code into self-contained and reusable packages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对前一章中讨论的SOLID原则的坚定信仰者，Go社区中的几位知名人士强烈建议软件工程师将他们的代码组织成自包含和可重用的包。
- en: When our code imports an external package, its dependency graph is augmented
    not only with the imported package but also with its set of transitive dependencies—that
    is, any other packages (and *their* dependencies) required by the packages that
    we import. As our projects grow larger in size, it becomes necessary to efficiently
    manage the versions of all our dependencies to ensure that changes in upstream
    transitive dependencies do not cause unexpected side effects (crashes, changes
    in behavior, and so on) to our own programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码导入外部包时，其依赖图不仅增加了导入的包，还增加了其传递依赖集——即我们导入的包所需的任何其他包（及其依赖）。随着我们的项目规模不断扩大，有必要有效地管理所有依赖项的版本，以确保上游传递依赖项的变化不会对我们自己的程序造成意外的副作用（崩溃、行为变化等）。
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下主题：
- en: The importance of versioning for software
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件版本化的重要性
- en: Ways to apply semantic versioning for Go packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Go包应用语义版本化的方法
- en: Strategies for managing the source code for multiversioned packages and tools
    that allow you to import a particular package version from your code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多版本包的源代码的策略以及允许您从代码中导入特定包版本的工具
- en: The pros and cons of dependency vendoring and how it can be used to facilitate
    repeatable builds
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项版本管理的优缺点以及如何用它来促进可重复构建
- en: The most popular approaches and tools for vendoring Go packages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的Go包版本管理方法和工具
- en: What's all the fuss about software versioning?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于软件版本化，为什么会有这么多的争议？
- en: The idea of versioning is ingrained into everything around us. People all over
    the world are accustomed to using various forms of versioning on a daily basis.
    Note that I am not just talking about software here. The vast majority of physical
    products that you are using are associated with some sort of versioning scheme.
    Uses of versioning range from your computer's CPU to your mobile phone, and from
    the revision of the algorithm book on your bookshelf to your favorite superhero
    (or alternatively light-saber-wielding rebel) movie.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 版本化的概念已经深入到我们周围的每一件事中。世界各地的人们习惯于每天使用各种形式的版本化。请注意，我这里不仅仅是在谈论软件。你使用的绝大多数物理产品都与某种版本化方案相关联。版本化的用途从你的电脑CPU到你的手机，从你书架上的算法书修订版到你的最爱超级英雄（或光剑挥舞的反叛者）电影。
- en: 'When we move to the realm of software, the concept of versioning becomes even
    more important. Nowadays, as more and more software engineers ascribe to the *release
    fast* mantra, having a sane versioning system in place makes it possible to do
    the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入软件领域时，版本化的概念变得更加重要。如今，随着越来越多的软件工程师信奉“快速发布”的箴言，建立一个合理的版本化系统使得以下操作成为可能：
- en: Validate that a particular piece of software can be used as a safe drop-in replacement
    for an older piece of software that we are using as part of our production systems.
    This is especially important from a security standpoint, as *all* software, unless
    formally verified, may contain potential security bugs that can be discovered
    at any point in time—even weeks or years after it has been deployed to production.
    It is therefore of paramount importance for us to be able to mitigate such issues
    by upgrading to a newer release as soon as bug fixes become available.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证特定的软件可以作为我们生产系统中使用的老版本软件的安全替代品。这在安全方面尤为重要，因为**所有**软件，除非经过正式验证，都可能包含潜在的漏洞，这些漏洞可能在任何时间被发现——甚至是在部署到生产后数周或数年后。因此，我们能够通过在修复可用时尽快升级到新版本来减轻此类问题至关重要。
- en: Pin down each dependency of our applications to a particular package version.
    This is a key prerequisite for setting up CI pipelines to implement the concept
    of repeatable builds. Having access to repeatable builds makes it possible to
    recompile, at any time, an exact copy of the software that a customer runs in
    production and use it as a reference when investigating bug reports.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们应用程序的每个依赖项固定到特定的软件包版本。这是设置 CI 管道以实现可重复构建概念的关键前提条件。能够访问可重复构建使得在任何时候都可以重新编译客户在生产中运行的软件的确切副本，并在调查错误报告时将其用作参考。
- en: In the following sections, we will delve into the details behind *semantic versioning*,
    a very popular approach for not only managing the version of your software packages
    but also for notifying the users that depend on them of upcoming and potentially
    breaking changes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将深入了解语义版本背后的细节，这是一种非常流行的方法，不仅用于管理软件包的版本，而且还用于通知依赖它们的用户即将到来的和可能破坏性的更改。
- en: Semantic versioning
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义版本化
- en: '**Semantic versioning** ^([11]) is a widely popular system for describing software
    versions in a way that makes it quite straightforward for the intended software
    users to figure out which versions are safe to upgrade to and which versions contain
    breaking API changes and therefore require development effort and time when upgrading.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义版本化** ^([11]) 是一个广泛流行的系统，用于以使目标软件用户能够轻松地确定哪些版本可以升级，哪些版本包含破坏性 API 变更，因此在升级时需要开发工作和时间。'
- en: 'Semantic versions are formatted as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本号格式如下：
- en: '`MAJOR.MINOR.PATCH`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAJOR.MINOR.PATCH`'
- en: Depending on the use case, additional suffixes may be optionally appended to
    indicate a prerelease (for example, alpha, beta, or RC (or release candidate))
    or to convey other build-related information (for example, the Git SHA for the
    branch that is used to build a release or perhaps a timestamp for when the build
    artifacts were generated).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用情况，可以可选地附加额外的后缀来表示预发布版本（例如，alpha、beta 或 RC（或发布候选））或传达其他与构建相关的信息（例如，用于构建发布的分支的
    Git SHA 或构建工件生成的日期和时间戳）。
- en: When working with Go packages, the three-component approach employed by semantic
    versioning makes it easy for package authors to let users of the package know
    what *type* of changes each release contains. For example, the `PATCH` field is
    incremented whenever a *backward-compatible bug fix* is applied to the code. Conversely,
    the `MINOR` field is incremented when *new functionality* gets added to a package,
    but, most importantly, only when this new functionality is added in a manner that
    ensures that the new version *remains backward compatible* with older package
    versions. Of course, as packages evolve over time, it is inevitable that at some
    point some breaking changes will have to be introduced. For instance, an existing
    function signature may need to be changed to support additional use cases. For
    those kinds of scenarios, the `MAJOR` component of the version string will need
    to be incremented.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 Go 软件包一起工作时，语义版本使用的三部分方法使得软件包作者能够让软件包的用户知道每个发布包含的**类型**的更改。例如，每当对代码应用**向后兼容的错误修复**时，`PATCH`
    字段就会增加。相反，当向软件包添加**新功能**时，`MINOR` 字段会增加，但最重要的是，只有当这种新功能以确保新版本**保持向后兼容**旧软件包版本的方式添加时。当然，随着软件包随时间发展，在某个时候引入一些破坏性更改是不可避免的。例如，可能需要更改现有的函数签名以支持额外的用例。对于这类场景，版本字符串的
    `MAJOR` 组件需要增加。
- en: Comparing semantic versions
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较语义版本
- en: 'If we are given two semantic versions, `a.b.c` and `x.y.z`*,* how can we tell
    which one is more recent? To compare two semantic versions, we need to compare
    each one of their individual components from left to right. Here is a short piece
    of code demonstrating how we can compare two semantic versions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给定两个语义版本，`a.b.c` 和 `x.y.z`，我们如何判断哪个更新？要比较两个语义版本，我们需要从左到右比较它们的各个组成部分。以下是一段简短的代码示例，展示了我们如何比较两个语义版本：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Comparing or sorting semantic versions is quite an easy task for humans to perform,
    but nevertheless, as is evident in the preceding code snippet, it requires additional
    effort when performed by machines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 比较或排序语义版本对人类来说是一项相当容易的任务，但正如前述代码片段所示，当由机器执行时，这需要额外的努力。
- en: You have probably encountered this problem first hand if you have ever worked
    on makefile rules that check for the presence of a minimum version of a particular
    library or if you have ever attempted to sort a list of folders that follow this
    versioning scheme using the standard command-line tools. This is considered a
    caveat of semantic versioning compared to alternative versioning schemes that
    are either based on monotonically increasing build numbers or build dates in the `YYYMMDD` format.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经亲自遇到过这个问题，那么你可能曾经编写过检查特定库最低版本的makefile规则，或者尝试使用标准命令行工具对遵循此版本控制方案的文件夹列表进行排序。这被认为是与基于单调递增的构建号或`YYYMMDD`格式的构建日期的版本控制方案相比，语义版本控制的一个注意事项。
- en: Applying semantic versioning to Go packages
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将语义版本控制应用于Go包
- en: The semantic versioning definition that we discussed in the previous section
    left a few questions unanswered. To begin with, what should be the *initial* version
    number for a new package? What is more, as an external user of the package, how
    would we know when the package API has been stable enough for us to use it safely
    in our code?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中讨论的语义版本控制定义留下了一些未回答的问题。首先，新包的**初始**版本号应该是什么？更重要的是，作为包的外部用户，我们如何知道包API已经足够稳定，可以在我们的代码中安全使用？
- en: 'There is no better way to answer these questions than with the help of a small
    example. Let''s consider the following code snippet from an as *yet unreleased* package
    that deals with weather predictions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比用一个小的例子更有助于回答这些问题的方法了。让我们考虑以下来自一个尚未发布的包的代码片段，该包处理天气预测：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we are talking about a brand new package, we need to decide on an *initial* version
    string. Given that the package is not exposing any public interface, we can start
    with *0.1.0* as our initial version number. The *0* value for the major version
    component serves as a warning to potential users of the package that it is still
    work in progress and the package implementation may frequently change in potentially
    breaking ways. In other words: *use the package at your own risk*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论一个全新的包，我们需要决定一个**初始**的版本字符串。鉴于该包没有暴露任何公共接口，我们可以从**0.1.0**作为我们的初始版本号开始。主版本组件中的**0**值作为对潜在用户的警告，表明该包仍在开发中，包的实现可能会频繁地以可能破坏的方式更改。换句话说：**使用该包请自行承担风险**。
- en: 'After a few iterations and extensive refactoring of the package code (each
    time bumping the *minor* version of the package), we eventually reach version *0.9.0*.
    At this point, we decide that the package is safe to use *internally* on our production
    systems. To this end, we need to expose a *public API* so that our existing Go
    packages can interface with the new package. This is facilitated by a simple rename
    operation—change `predictAtCoords` to `PredictAtCoords` (and of course update
    all relevant unit tests), as shown in the following code block:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次迭代和包代码的广泛重构（每次都提升包的**次要**版本），我们最终达到了版本**0.9.0**。在这个时候，我们决定该包可以在我们的生产系统内部安全使用。为此，我们需要公开一个**公共API**，以便我们的现有Go包可以与新的包进行接口交互。这通过一个简单的重命名操作实现——将`predictAtCoords`改为`PredictAtCoords`（当然，还需要更新所有相关的单元测试），如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Following a successful rollout to production, we should feel comfortable enough
    to make this package publicly available so other people can import and use it.
    The package is released as version *1.0.0* and it turns out to be a big hit in
    the weather-forecasting community!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功推广到生产环境之后，我们应该足够自信地将这个包公开，以便其他人可以导入和使用它。该包以版本**1.0.0**发布，并最终在天气预报社区中取得了巨大成功！
- en: 'That is, until one day, when a user of the package opens a GitHub issue with
    a bug: *passing a certain combination of lat/long parameters causes* `PredictAtCoords`
    *to panic*. We revisit the code, create a reproducer for the bug, and after a
    bit of digging around, we discover the root cause for the bug: the lack of proper
    checks allows a division by zero to occur. The fix is quite simple and does not
    alter the functionality of the package in any way, so we bump the *patch* version
    of the package and release *1.0.1*.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，直到有一天，当包的用户在GitHub上打开一个带有错误的issue时：**传递某些经纬度参数的组合会导致** `PredictAtCoords`
    **崩溃**。我们重新审视代码，创建了一个用于复现错误的程序，并在一番调查后，我们发现错误的根本原因：缺乏适当的检查导致发生了除以零的情况。修复非常简单，并且以任何方式都没有改变包的功能，因此我们提升了包的**补丁**版本，并发布了**1.0.1**。
- en: 'As more and more people start depending on our released package, we start receiving
    requests to add new features, for instance: to predict the weather for a location
    identified by a *plus code* ^([10]). To implement this new feature, we introduce
    a new public function to the package:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的人开始依赖我们发布的包，我们开始收到添加新功能的请求，例如：预测由*加码*识别的位置的天气^([10])。为了实现这个新功能，我们向包中引入了一个新的公共函数：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This change introduces new functionality to the package, but the package itself
    is still backward compatible with older versions. Therefore, we now need to bump
    the *minor* version component and release version *1.1.1* of the package. Similarly,
    we add functions for predicting the weather for a city or a specific address.
    After each addition, we make sure to bump the *minor* version of our package.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这次更改向包中引入了新功能，但包本身仍然与旧版本向后兼容。因此，我们现在需要将*次要*版本组件提升，并发布包的版本*1.1.1*。同样，我们添加了预测城市或特定地址天气的功能。每次添加后，我们都要确保提升包的*次要*版本。
- en: 'So far, so good. However, after a careful inspection of the code in our latest
    package version, we notice that the current implementation involves quite a bit
    of repetition—the public API consists of a set of functions that perform more
    or less the same task: predict the weather at a *location*. The only difference
    is that each function expects the location to be encoded in a particular way (that
    is, as GPS coordinates, a plus code, or an address).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。然而，在仔细检查我们最新包版本的代码后，我们发现当前实现涉及相当多的重复——公共API由一组执行更多或更少相同任务的功能组成：预测*位置*的天气。唯一的区别是每个函数期望位置以特定的方式编码（即，作为GPS坐标、加码或地址）。
- en: 'In an attempt to simplify the package API and apply the **interface segregation
    principle** (**ISP**), as we discussed in [Chapter 2](96fb70cb-8134-4156-bd3e-48ca53224683.xhtml),
    *Best Practices for Writing Clean and Maintainable Go Code*, we decide to introduce
    a series of *breaking* API changes. To begin with, we define the `Locator` interface,
    which provides a necessary abstraction for converting locations into a set of
    GPS coordinates. Secondly, we replace the various `PredictAtXYZ` functions from
    the package with a new function called `Predict` that receives a `Locator` instance
    as its argument:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试简化包API并应用我们在[第2章](96fb70cb-8134-4156-bd3e-48ca53224683.xhtml)中讨论的**接口隔离原则**（**ISP**），即《编写干净且可维护的Go代码的最佳实践》中，我们决定引入一系列*破坏性*API更改。首先，我们定义了`Locator`接口，它为将位置转换为一系列GPS坐标提供了必要的抽象。其次，我们用一个新的函数`Predict`替换了包中的各种`PredictAtXYZ`函数，该函数接收一个`Locator`实例作为其参数：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By refactoring `Predict`, as shown in the preceding code, we can now extract
    the various types that can be used to represent locations into their own standalone
    package, aptly called `location`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，通过重构`Predict`，我们现在可以将用于表示位置的各类类型提取到它们自己的独立包中，这个包恰当地命名为`location`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Thanks to the magic of implicit interfaces, all we need to do to use these
    new types with the `Predict` function is to add methods that satisfy the `Locator` interface
    from the `weather` package:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了隐式接口的魔力，我们使用这些新类型与`Predict`函数一起使用时，只需添加满足`weather`包中`Locator`接口的方法：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This change definitely improves the quality of the weather package, but at the
    cost of breaking backward compatibility. To indicate this to the users of the
    package, we bump the *major* version component and publish version *2.0.0* of
    the package.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这次更改无疑提高了天气包的质量，但代价是破坏了向后兼容性。为了向包的用户表明这一点，我们将*主*版本组件提升，并发布包的版本*2.0.0*。
- en: By adopting semantic versioning for our packages, we not only allow package
    users to select which API version they want to work with, but also offer them
    the flexibility to upgrade to a newer package version at their own pace without
    any risk of breaking existing production systems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为我们的包采用语义版本控制，我们不仅允许包用户选择他们想要使用的API版本，还提供了他们根据自己的节奏升级到新包版本的灵活性，而不会对现有的生产系统造成任何风险。
- en: Managing the source code for multiple package versions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理多个包版本的源代码
- en: One thing that may have you as odd about the previous section is the fact that
    while I keep going on about the *publishing* version `x.y.z` of the weather package,
    the section content itself is devoid of any information regarding the actual *process*
    involved in publishing a package.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个部分可能让您感到奇怪的一点是，尽管我一直在谈论发布天气包的版本`x.y.z`，但该节内容本身没有任何关于实际**发布**包的过程的信息。
- en: At this point, you might also be asking yourself the question,* if we have released
    multiple major versions of a package, how do we manage the source code for each
    released versi**on?* After all, as the package authors, we can opt to maintain
    and support several major or major/minor combinations of package versions in parallel
    and each version can potentially follow its own release cycle. For example, we
    can work on extending the API for the *2.x.x* line while still continuing to fix
    bugs or apply security patches to the *1.x.x* line. And how are the end users
    expected to import a particular version of a Go package?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能也会问自己一个问题，*如果我们发布了多个主要版本的包，我们如何管理每个发布版本的源代码？* 因为毕竟，作为包作者，我们可以选择并行维护和支持几个主要版本或主要/次要组合的包版本，每个版本可以潜在地遵循其自己的发布周期。例如，我们可以在继续修复*1.x.x*线的错误或应用安全补丁的同时，为*2.x.x*线扩展API。那么，最终用户应该如何导入特定的Go包版本呢？
- en: To answer all these questions, we need to explore a few alternative approaches
    to versioning Go packages in depth.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答所有这些问题，我们需要深入探讨几种替代方法来对Go包进行版本控制。
- en: Single repository with versioned folders
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一存储库与版本化文件夹
- en: Using a single repository with versioned folders requires us to maintain the
    source code for all supported versions within a *single* repository. The simplest
    way to achieve this is to create a folder for each version at the root of the
    repository and copy all the version-specific files and subpackages inside.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有版本化文件夹的单一存储库要求我们在**单一**存储库中维护所有支持版本的源代码。实现这一点的最简单方法是在存储库的根目录下为每个版本创建一个文件夹，并将所有版本特定的文件和子包复制进去。
- en: 'Let''s revisit the `weather` package example from the previous section. Let''s
    assume that we use Git as our VCS and that we host our package on GitHub under
    the `weather-as-a-service` account in a repository called `weather`. The following
    flowchart illustrates how the folder layout would look using this approach:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下上一节中的`weather`包示例。假设我们使用Git作为我们的版本控制系统，并且我们将包托管在GitHub上的`weather-as-a-service`账户下的名为`weather`的存储库中。以下流程图说明了使用这种方法文件夹布局将如何看起来：
- en: '![](img/87683c40-568a-463c-95a3-2779754eaa8e.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87683c40-568a-463c-95a3-2779754eaa8e.png)'
- en: Figure 1: Managing multiple versions of a package in a single repository
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：在单一存储库中管理包的多个版本
- en: 'It is important to point out that even though the `weather.go` files are located
    under the `v1` and `v2` folders, *both* of them declare a package named `weather`.
    This trick allows users of the package to explicitly select which package version
    they want to import and refer to its contents using the `weather` selector, as
    illustrated in the following code block:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，尽管`weather.go`文件位于`v1`和`v2`文件夹下，但**两者**都声明了一个名为`weather`的包。这个技巧允许包的用户明确选择他们想要导入的包版本，并使用`weather`选择器来引用其内容，如下面的代码块所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This approach has a few benefits, both for package authors and for the intended
    end users of the package:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对包作者和包的预期最终用户都有一些好处：
- en: The use of a single repository for all versions makes maintenance easier, as
    package authors can work on each version of the package in isolation.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单一存储库来存储所有版本使得维护更加容易，因为包作者可以在隔离的情况下对包的每个版本进行工作。
- en: The repository always contains the latest release for each package version.
    The end users of the package can use a single command to get/update *all* versions
    of the package (for example, `go get -u github.com/weather-as-a-service/weather`).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库始终包含每个包版本的最新发布版。包的最终用户可以使用单个命令来获取/更新**所有**版本的包（例如，`go get -u github.com/weather-as-a-service/weather`）。
- en: As the end user of the package, you have the option (although it is probably
    something you should probably avoid) to import and use *different* versions of
    the same package from within the same code base.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为该包的最终用户，您有选择（尽管可能应该避免）在同一个代码库中导入和使用**不同版本**的同一包的选项。
- en: 'On the other hand, there are some caveats associated with this approach:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这种方法也有一些需要注意的事项：
- en: Code duplication! Each versioned folder includes a full copy of the package
    implementation, which may also include one or more subpackages. This could prove
    to be a challenge for the package authors, especially if a security issue is identified
    whose fix requires patching the same code in different folders.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重复！每个版本化的文件夹都包含软件包实现的完整副本，也可能包括一个或多个子包。这可能对软件包作者构成挑战，特别是如果发现了一个需要在不同文件夹中修补相同代码的安全问题。
- en: As an end user of the package, how would you know whether a particular package
    utilizes this particular versioning scheme, or which versions are available to
    use? To answer these questions you would most likely need to visit the repository
    page on GitHub and examine the folder structure.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为该软件包的最终用户，您如何知道某个特定的软件包是否使用了这种特定的版本控制方案，或者可以使用哪些版本？要回答这些问题，您很可能会需要访问GitHub上的存储库页面并检查文件夹结构。
- en: Single repository – multiple branches
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个存储库 – 多个分支
- en: 'A much better approach would be to still use a single repository but maintain
    a *different branch* (in Git terminology) for each major package version, extra
    feature, or development branches for ongoing work. If we were to apply this approach
    to the case of the weather package that we discussed before, our repository would
    normally contain the following branches:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法仍然是使用单个存储库，但为每个主要软件包版本、额外功能或正在进行的工作的开发分支维护不同的分支（在Git术语中）。如果我们将这种方法应用于我们之前讨论的天气软件包案例，我们的存储库通常将包含以下分支：
- en: '`v1`: This is the branch where the released *1.x.y* line of the weather package
    is located.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v1`：这是存放天气软件包已发布*1.x.y*线的分支。'
- en: '`v2`: Another branch for the *2.x.y* release of the weather package.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2`：另一个分支用于天气软件包的*2.x.y*发布。'
- en: '`develop`: Code in development branches is generally considered to be work
    in progress, and therefore unstable for use. Eventually, once the code stabilizes,
    it will be merged back into one or more of the stable release branches.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`develop`：开发分支中的代码通常被认为是正在进行的工作，因此不稳定，不适合使用。最终，一旦代码稳定，它将被合并回一个或多个稳定发布分支。'
- en: Similar to the versioned folder approach, the multibranch approach also ensures
    that the tip or head of each release branch contains the *latest* release version
    for a package; however, it is sometimes useful to be able to refer to an older
    semantic version of the package. A typical use case for this is repeatable builds,
    where we always want to compile against a specific version of the package and
    not the latest, albeit stable, version from a particular package line.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与版本化文件夹方法类似，多分支方法也确保每个发布分支的尖端或头部包含软件包的*最新*发布版本；然而，有时能够引用软件包的较旧语义版本也是有用的。一个典型的用例是可重复构建，我们总是希望针对软件包的特定版本进行编译，而不是从特定软件包系列中获取的尽管稳定但最新的版本。
- en: To satisfy the preceding requirement, we can exploit the VCS's capability to *tag* each
    release so we can easily locate it in the future without having to scan the commit
    history. I am using Git as an example here as it is my preferred VCS, but concepts
    such as tagging generalize to other VCS as well (tags in SVN, labels in Perforce,
    and so on).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足上述要求，我们可以利用版本控制系统（VCS）的*标记*功能，以便我们可以在未来轻松地找到它，而无需扫描提交历史。在这里，我以Git为例，因为我更喜欢Git，但像标记这样的概念也适用于其他VCS（如SVN的标签、Perforce的标签等）。
- en: 'This leads us to yet another question: if each version has its own branch,
    how do we import it from our code? If we are talking about a public package that
    is hosted on GitHub, the answer is that we need to use a redirect service such,
    as `gopkg.in` ^([7]).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个问题：如果每个版本都有自己的分支，我们如何从我们的代码中导入它？如果我们谈论的是托管在GitHub上的公共软件包，答案是，我们需要使用重定向服务，例如`gopkg.in`^([7])。
- en: The `gopkg.in` service functions as a proxy for redirecting Go tools to the
    sources that correspond to a *specific* version of a Go package. The service achieves
    this by exposing a series of *versioned* URLs that, when accessed by `go get`,
    automatically resolve to a particular branch or tag within the repository where
    the package is hosted.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`gopkg.in`服务作为Go工具重定向到对应Go包特定版本的代理。该服务通过公开一系列*版本化*URL来实现，当通过`go get`访问时，会自动解析到存储库中托管该包的特定分支或标签。'
- en: This convention not only yields cleaner and shorter package URLs, but more importantly, it
    also ensures that dependent packages can cleanly compile using the latest minor
    version of the packages they depend on, even if new major versions of those packages
    get released.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约定不仅会产生更干净、更短的包URL，更重要的是，它还确保依赖包可以干净地编译使用它们依赖的包的最新次要版本，即使这些包发布了新的主要版本。
- en: What's more, when the same URLs are accessed via a web browser, users are presented
    with a neat landing page that provides additional information regarding the purpose
    of the package and the commands needed to fetch or import it. The same page also
    contains links to the package sources and documentation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当通过网页浏览器访问相同的URL时，用户将看到一个整洁的着陆页，该页提供了有关包用途和获取或导入所需命令的附加信息。同一页还包含到包源和文档的链接。
- en: 'For example, when you visit a `gopkg.in` URL for a particular package with
    your browser for the popular logging package called `logrus`, you will see a page
    that looks similar to the following screenshot. The left side of the page displays
    the `import` command that we need to use for the selected version of the package. The
    panel on the right side of the page states the available package versions (in
    this example: v1 and v0) and the actual branch or tag that they resolve to:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当您使用浏览器访问特定包的`gopkg.in` URL，例如流行的`logrus`日志包时，您将看到一个类似于以下截图的页面。页面的左侧显示我们需要为所选版本的包使用的`import`命令。页面的右侧面板声明了可用的包版本（在本例中：v1和v0）以及它们解析到的实际分支或标签：
- en: '![](img/0e43f8a3-c15b-4707-b97b-bc46cfc8ca6f.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e43f8a3-c15b-4707-b97b-bc46cfc8ca6f.png)'
- en: Figure 2: The gopkg.in page for the popular logrus package
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：`gopkg.in`页面的流行`logrus`包
- en: 'Let''s go back to the weather example from the previous section and update
    the imports to use `gopkg.in` URLs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上一节中的天气示例，并更新导入以使用`gopkg.in` URL：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we run `go get -u ...` within the folder where the preceding example lives,
    it will always pull the *latest* *v2* version of the weather package. You may
    be wondering how `gopkg.in` knows which one is the latest version and where that
    version lives. In order to correctly resolve a version request, `gopkg.in` first
    parses the list of available branches and tags for the project. Depending on the
    version selector suffix (the `.v2`, in this example), `gopkg.in` will always attempt
    to return the highest matching version of the package whose *major* version component
    matches the requested selector. This implies that the service is not only capable
    of working with the other versioning schemes we briefly mentioned before (for
    example, monotonically increasing build or version numbers, timestamps, and so
    on), but that it is also smart enough to parse and compare semantic versions of
    packages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在前面示例所在的文件夹中运行`go get -u ...`，它将始终拉取天气包的*最新* *v2*版本。您可能想知道`gopkg.in`如何知道哪个是最新版本以及该版本在哪里。为了正确解析版本请求，`gopkg.in`首先解析项目的可用分支和标签列表。根据版本选择器后缀（本例中的`.v2`），`gopkg.in`将始终尝试返回与请求选择器匹配的包的最高匹配版本，其*主*版本组件与请求的选择器相匹配。这意味着该服务不仅能够处理我们之前简要提到的其他版本控制方案（例如，单调递增的构建或版本号、时间戳等），而且它足够智能，可以解析和比较包的语义版本。
- en: 'For example, let''s assume that the weather package repository contains the
    following mix of tags and branches:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设天气包仓库包含以下标签和分支的混合：
- en: '| **Name** | **Type** | **Notes** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型** | **说明** |'
- en: '| v1.0.10 | Tag |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| v1.0.10 | 标签 |  |'
- en: '| v1.1.9 | Tag |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| v1.1.9 | 标签 |  |'
- en: '| v1 | Branch | Contents match v1.1.0 tag |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| v1 | 分支 | 内容与v1.1.0标签匹配 |'
- en: '| v2.0 | Tag |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| v2.0 | 标签 |  |'
- en: '| v3~dev | Branch | Development branch for the upcoming v3 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| v3~dev | 分支 | 即将发布的v3的开发分支 |'
- en: 'This is how `gopkg.in` would resolve the preceding imports depending on the
    value of the version selector suffix:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`gopkg.in`根据版本选择器后缀的值解析前面导入的方式：
- en: '| **Selector** | **Resolves to** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **选择器** | **解析为** |'
- en: '| v1 | v.1.1.9 (Tag) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| v1 | v.1.1.9 (标签) |'
- en: '| v2 | v2.0 (Tag) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| v2 | v2.0 (标签) |'
- en: '| v3 | v3~dev (Branch) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| v3 | v3~dev (分支) |'
- en: 'To make a project compatible with the `gopkg.in` service, you need to make
    sure that either your branches or your tags match the expected patterns that `gopkg.in`
    looks for: `vx`, `vx.y`, `vx.y.z`, and so on.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使项目与`gopkg.in`服务兼容，您需要确保您的分支或标签与`gopkg.in`寻找的预期模式相匹配：`vx`、`vx.y`、`vx.y.z`等。
- en: As the majority of the software engineering teams are quite opinionated when
    it comes to selecting a development flow (for example, Git flow versus GitHub
    flow) or branch naming conventions, my personal recommendation would be to stick
    to using tags for labeling package versions using the format that `gopkg.in` expects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数软件工程团队在选择开发流程（例如，Git flow 与 GitHub flow）或分支命名约定时都有很强的观点，因此我的个人建议是坚持使用标签来标记包版本，格式符合
    `gopkg.in` 的期望。
- en: Vendoring – the good, the bad, and the ugly
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商模式——好的、坏的、丑的
- en: The fact that services such as `gopkg.in` always redirect the `go get` tool
    to the *latest* available major version for a given version selector is, technically
    speaking, a show-stopper for engineering teams that endeavor to set up a development
    pipeline that guarantees repeatable builds. The typical CI pipeline will always
    pull both compile and test dependencies via a command such as `go get -t -u ...` prior
    to building the final output artifact. As a result, even if your code has not
    changed between builds, your service or application binary may be different because
    of changes in the dependencies that get pulled in.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，服务如 `gopkg.in` 总是重定向 `go get` 工具到给定版本选择器的**最新**可用主要版本，这对于努力设置保证可重复构建的开发管道的工程团队来说是一个障碍。典型的
    CI 管道将在构建最终输出工件之前，通过如 `go get -t -u ...` 这样的命令拉取编译和测试依赖项。因此，即使你的代码在构建之间没有变化，由于拉入的依赖项发生变化，你的服务或应用程序的二进制文件可能也会不同。
- en: However, what if I told you that there *is* actually a way to retain the benefits
    of lazy package resolution *and* at the same time have the flexibility to *pin
    down* package versions for each build? The mechanism that will assist us in this
    matter is called **vendoring**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我说实际上有一种方法可以保留延迟包解析的好处，同时又能灵活地为每个构建“锁定”包版本，你会怎么想？将帮助我们处理这个问题的机制被称为**供应商模式**。
- en: In the context of Go programming, we refer to vendoring as the *process* where **immutable** snapshots
    (also known as **vendored dependencies**) for all nodes in the import graph of
    a Go application get created. The vendored dependencies are used instead of the
    original imported packages whenever a Go application is compiled.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 编程的上下文中，我们将供应商模式称为创建 Go 应用程序导入图所有节点的**不可变快照**（也称为**供应商依赖项**）的过程。当编译 Go
    应用程序时，使用供应商依赖项而不是原始导入的包。
- en: 'As we will see in the following sections, there are a few different approaches
    to creating dependency snapshots:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将看到创建依赖项快照的几种不同方法：
- en: Fork the repository that contains each imported dependency and update the import
    statements in the code base to point to the forked resources.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对包含每个导入依赖项的存储库进行分支，并更新代码库中的导入语句以指向分支资源。
- en: Create a manifest that includes the current (that is, at the time a snapshot
    is made) commit identifiers (for example, Git SHAs) for each imported package
    and its transitive dependencies. The manifest, a small, human-readable YAML- or
    JSON-based file is generally committed to the VCS and used to fetch the appropriate
    versions of each dependency prior to invoking the compiler.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个清单，其中包含每个导入的包及其传递依赖项当前的提交标识符（例如，Git SHA）。该清单是一个小型、可读的基于 YAML 或 JSON 的文件，通常提交到版本控制系统（VCS）中，并在调用编译器之前用于获取每个依赖项的适当版本。
- en: Cache the imported dependencies locally (typically in a folder called `vendor`)
    and commit them together with the project files to the VCS. Contrary to the preceding
    approaches, local caching enables us to check out our project and immediately
    compile it without having to fetch any dependencies first.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地缓存导入的依赖项（通常在一个名为 `vendor` 的文件夹中）并将它们与项目文件一起提交到 VCS。与前面的方法相反，本地缓存使我们能够在不首先获取任何依赖项的情况下立即检出我们的项目并编译它。
- en: Before we dive a bit deeper into each one of these approaches, let's take a
    few minutes to discuss the pros and cons of dependency vendoring.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨这些方法的每一个之前，让我们花几分钟时间讨论依赖项供应商的优缺点。
- en: Benefits of vendoring dependencies
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商依赖项的好处
- en: First and foremost, the key promise of vendoring is nothing other than the capability
    to run reproducible builds. Many customers, especially larger corporations, tend
    to stick to stable or LTS releases for the software they deploy and forego upgrading
    their systems unless it's absolutely necessary. Being able to check out the exact
    software version that a customer uses and generate a bit-for-bit identical binary
    for use in a test environment is an invaluable tool for any field engineer attempting
    to diagnose and reproduce bugs that the customers are facing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，vendoring的关键承诺不过是运行可重复构建的能力。许多客户，尤其是大型企业，往往坚持使用稳定的或LTS版本部署软件，除非绝对必要，否则不会升级他们的系统。能够检出客户使用的确切软件版本，并为测试环境生成位对位的相同二进制文件，对于任何试图诊断和重现客户面临的bug的现场工程师来说，这是一件无价之宝。
- en: Another benefit of vendoring is that it serves as a safety net in case an upstream
    dependency suddenly disappears from the place where it is hosted (for example,
    a GitHub or GitLab repository), thereby breaking builds for software that depends
    on it. If you are thinking that this is a highly unlikely scenario, let me take
    you back to 2016 and share an interesting engineering horror story from the world
    of Node.js!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: vendoring的另一个好处是，它作为一个安全网，以防万一上游依赖突然从其托管的地方（例如，GitHub或GitLab仓库）消失，从而破坏依赖于它的软件的构建。如果你认为这是一个极不可能的场景，让我带你回到2016年，分享一个来自Node.js世界的有趣工程恐怖故事！
- en: You may have heard of the now-infamous *left-pad* package. In case you haven't,
    it is just a single-function package that, as you can probably figure out by its
    name, provides a function to pad a string up to a specific length with a specific
    character. Nothing really scary so far... except that this small package was a
    direct dependency of over 500 packages, which in turn were transient dependencies
    of several other packages, and so on. Everything went fine until one day, the
    left-pad package maintainer received a cease-and-desist letter for one of his other packages
    and decided, as a form of protest, to take down *all* of his packages, including
    left-pad.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过现在臭名昭著的*left-pad*包。如果你还没有听说过，它只是一个单功能包，正如你可能会从它的名字中猜到的，它提供了一个函数，可以将字符串填充到特定的长度，并用特定的字符填充。到目前为止，并没有什么真正可怕的事情...但是，这个小型包是超过500个包的直接依赖，而这些包又是其他几个包的临时依赖，以此类推。一切都很顺利，直到有一天，left-pad包的维护者收到了他其他包的一封停止侵权通知，并决定作为一种抗议形式，撤下他所有的包，包括left-pad。
- en: Now, picture the chaos that ensued as peoples' CI builds started breaking one
    after the other. But engineering teams that had been judiciously vendoring their
    dependencies were not affected by this issue at all.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下人们的CI构建开始一个接一个地崩溃所引发的混乱。但是，那些明智地vendoring其依赖项的工程团队根本未受此问题影响。
- en: Is vendoring always a good idea?
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: vendoring总是好主意吗？
- en: The previous section went into great effort to extol the virtues of vendoring.
    But is vendoring the panacea for all dependency management problems? This section
    attempts to dig a bit deeper into some of the caveats associated with vendoring.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个部分不遗余力地赞扬了vendoring的优点。但是，vendoring真的是所有依赖项管理问题的万能药吗？本节试图深入探讨与vendoring相关的一些注意事项。
- en: One common problem across engineering teams is that in spite of the fact that
    engineers are keen on vendoring their dependencies, they often *forget* to periodically
    refresh them. As I argued in a previous section, all code can contain potential
    security bugs. It is therefore likely that some security bugs (perhaps from a
    transitive dependency of an imported package) will eventually end up in production.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 工程团队之间一个常见的问题是，尽管工程师们热衷于vendoring他们的依赖项，但他们经常*忘记*定期刷新它们。正如我在前一个部分所论证的，所有代码都可能包含潜在的安全漏洞。因此，一些安全漏洞（可能是导入包的传递依赖）最终可能会出现在生产环境中。
- en: Security-related or not, when bugs are reported to the package maintainers,
    a fix is usually promptly released and the package version is incremented accordingly
    (that is, if a package is using semantic versioning). As large-scale projects
    tend to import a large volume of packages, it is not feasible to monitor each
    imported package's repository for security fixes. Even if this was possible, we
    couldn't realistically do this for their transitive dependencies. As a result,
    production code can remain unpatched for a long time even though the affected
    upstream packages have already been patched.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论与安全相关与否，当向包维护者报告错误时，通常会迅速发布修复程序并相应地增加包版本（即，如果包使用语义版本控制）。由于大型项目倾向于导入大量包，因此无法实际监控每个导入包的仓库以查找安全修复。即使这可能实现，我们也无法现实地对其传递依赖关系进行此操作。因此，即使受影响的上游包已经修复，生产代码也可能长时间未打补丁。
- en: Strategies and tools for vendoring dependencies
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商依赖关系的策略和工具
- en: Initially, Go had no support for vendoring packages. This made sense at the
    time, as Google, the primary user of Go, would host all of their package dependencies
    in a single repository (commonly referred to as a mono-repo).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Go不支持供应商包。在当时，这很有意义，因为作为Go的主要用户，谷歌会将所有包依赖项托管在单个仓库中（通常称为单仓库）。
- en: However, as the Go community began growing and more and more companies began
    porting their code bases to Go, dependency management became an issue. With the
    release of Go 1.5, the Go team added experimental support for *vendoring folders*.
    Users could enable this feature by defining an environment variable named `GO15VENDOREXPERIMENT`*.*
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着Go社区的不断发展以及越来越多的公司将代码库迁移到Go，依赖关系管理成为一个问题。随着Go 1.5的发布，Go团队添加了对*vendoring文件夹*的实验性支持。用户可以通过定义名为`GO15VENDOREXPERIMENT`*.*的环境变量来启用此功能。
- en: When this feature is enabled, each time the Go compiler attempts to resolve
    an import, it will *first* check whether the imported package exists inside the
    vendor folder and use it if found; otherwise, it will proceed, as usual, to scan
    each entry in the `$GOPATH` looking for the package.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当此功能启用时，每次Go编译器尝试解析导入时，它将首先检查导入的包是否存在于供应商文件夹中，如果找到则使用它；否则，它将像往常一样继续扫描`$GOPATH`中的每个条目以查找该包。
- en: As soon as this functionality became available, multiple third parties spearheaded
    initiatives to produce tools that took advantage of it. The brief, but not exhaustive,
    list of now deprecated tools for dealing with dependencies includes `godep` ^([5]), `govendor` ^([9]), `glide` ^([3]), and `gvt` ^([4]).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这项功能可用，多个第三方就带头推出了利用这项功能的工具。以下是一些现在已弃用的处理依赖关系的工具列表，但并不详尽，包括`godep` ^([5])、`govendor`
    ^([9])、`glide` ^([3])和`gvt` ^([4])。
- en: 'Nowadays, tooling around vendoring is much more streamlined. The following
    sections explore the recommended approaches to vendoring Go packages at the time
    of writing:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，围绕供应商的工具链已经变得更加流畅。以下章节探讨了撰写本文时推荐的供应商Go包的方法：
- en: The *dep* tool
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dep`工具'
- en: '*Go modules*'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Go模块*'
- en: Manual forking of dependencies
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系的手动分叉
- en: The dep tool
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`dep`工具'
- en: The Go team—being well aware that having several competing tools for managing
    dependencies could result in the fragmentation of the Go ecosystem and encumber
    the growth of the Go community—decided to assemble a committee and produce an
    official specification document detailing the way to move forward regarding Go
    package dependency management. The dep tool ^([2]) is the first tool that conforms
    to the published specification. It began its life some time around 2017 as an
    *official experiment* that was made available to users who upgraded to Go 1.9.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go团队——深知拥有多个用于管理依赖关系的竞争性工具可能会导致Go生态系统的碎片化并阻碍Go社区的成长——决定组建一个委员会并制定一份官方规范文档，详细说明了关于Go包依赖关系管理的未来发展方式。`dep`工具^([2])是第一个符合已发布规范的工具。它大约在2017年开始，作为一个*官方实验*提供给升级到Go
    1.9的用户。
- en: 'The dep tool provides precompiled binaries for various operating systems; however,
    it is probably easier to build it from the source by running `go get -u github.com/golang/dep/cmd/dep`.
    The first time that you want to use the dep tool for one of your projects, you
    need to run `dep init` within the root folder of the project to initialize the
    dep tool''s state. Unless your import graph is shallow and small in size, this
    step will take a bit of time, as dep does the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: dep 工具为各种操作系统提供了预编译的二进制文件；然而，通过运行 `go get -u github.com/golang/dep/cmd/dep`
    从源代码构建它可能更容易一些。当你第一次想要在你的项目中使用 dep 工具时，你需要在项目的根目录下运行 `dep init` 来初始化 dep 工具的状态。除非你的导入图浅且规模小，否则这一步会花费一些时间，因为
    dep 会执行以下操作：
- en: Identifies all imported packages, their transitive dependencies, and whether
    or not they also use dep.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别所有导入的包、它们的传递依赖以及它们是否也使用 dep。
- en: Selects the highest possible version for each node in the dependency graph.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择依赖图中的每个节点的最高可能版本。
- en: Downloads the selected packages to the `vendor` folder that lives in the project's
    root folder. Dep will additionally cache the downloaded packages locally at `$GOPATH/pkg/dep/sources` to
    speed up dependency lookups for other projects that might also be using dep.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将选定的包下载到位于项目根目录中的 `vendor` 文件夹。Dep 还会在本地缓存下载的包在 `$GOPATH/pkg/dep/sources`，以加快其他可能也使用
    dep 的项目的依赖项查找。
- en: If *none* of the dependencies uses dep, then the selected version is simply
    the *current* version of each dependency as it appears in `$GOPATH`. Things get
    a bit more interesting when some (or all) of the imported dependencies also use
    dep. In that case, dep treats the versions requested by each dep-enabled package
    as constraints that are then fed into the constraint solver engine that is bundled
    with the dep tool.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**没有**依赖项使用 dep，则所选版本简单地是每个依赖项在 `$GOPATH` 中出现的**当前**版本。当一些（或所有）导入的依赖项也使用 dep
    时，事情会变得更有趣。在这种情况下，dep 将每个 dep 启用包请求的版本视为约束，然后将这些约束输入到与 dep 工具捆绑的约束求解器引擎中。
- en: Constraint solver engines, such as the one used by the dep tool, transform the
    list of input constraints into a Boolean **satisfiability problem** (**SAT**)
    and then attempt to identify a solution, if one exists. SAT problems are typically
    represented as complex Boolean expressions; the solver's job is to find the right
    combination of values for the expression variables so that the expression evaluates
    to `TRUE`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 约束求解器，如 dep 工具所使用的，将输入约束列表转换为布尔**可满足性问题**（**SAT**）并尝试识别一个解决方案（如果存在）。SAT 问题通常表示为复杂的布尔表达式；求解器的任务是找到表达式变量的正确组合，以便表达式评估为
    `TRUE`。
- en: 'For example, given the expression `((A and B) or C) and not D`, here is a subset
    of the total solutions that a SAT could suggest:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定表达式 `((A and B) or C) and not D`，以下是 SAT 可能建议的总解决方案的一个子集：
- en: '| **Solution** | **A** | **B** | **C** | **D** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **Solution** | **A** | **B** | **C** | **D** |'
- en: '| 1 | TRUE | TRUE | FALSE | FALSE |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 1 | TRUE | TRUE | FALSE | FALSE |'
- en: '| 2 | FALSE | FALSE | TRUE | FALSE |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 2 | FALSE | FALSE | TRUE | FALSE |'
- en: '| 3 | TRUE | FALSE | TRUE | FALSE |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 3 | TRUE | FALSE | TRUE | FALSE |'
- en: SAT solving is one of the first problems that have been proven to be NP-complete ^([1]).
    Over the course of the years, several algorithms have been proposed that can scale
    to larger SAT problems and yield solutions in a reasonable amount of time. The
    particular SAT solver implementation used by the dep tool is based on a variant
    of the **conflict-driven clause learning** (**CDCL**) algorithm ^([12]) that has
    been tweaked to work for the Go package management use case. If all this has piqued
    your interest, you can take a look at its implementation, which is in the [github.com/golang/dep/gps](https://github.com/golang/dep/tree/master/gps) package.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: SAT 求解是第一个被证明为 NP 完全的问题之一。多年来，已经提出了几个算法，可以扩展到更大的 SAT 问题并在合理的时间内提供解决方案。dep 工具使用的特定
    SAT 求解器实现基于 **conflict-driven clause learning**（**CDCL**）算法的一个变体，该算法已被调整以适用于 Go
    包管理用例。如果你对此感兴趣，可以查看其实现，该实现位于 [github.com/golang/dep/gps](https://github.com/golang/dep/tree/master/gps)
    包中。
- en: The output of the dep constraints solver is the *highest possible supported* version
    across *all* dependencies. The dep tool creates two text-based files in the project's
    root folder that the user *must* commit to their VCS: `Gopkg.toml`and`Gopkg.lock`.
    To speed up CI builds, users may also *optionally* commit the populated `vendor `folder
    to version control. Alternatively, assuming that both `Gopkg.toml` and `Gopkg.lock`
    are available, a prebuild hook can populate the vendor folder on the fly by running `dep
    ensure -vendor-only`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: dep约束求解器的输出是所有依赖项中*最高可能支持的*版本。dep工具在项目的根目录中创建两个基于文本的文件，用户*必须*将其提交到他们的版本控制系统中：`Gopkg.toml`和`Gopkg.lock`。为了加快CI构建，用户也可以*可选地*将填充的`vendor`文件夹提交到版本控制。或者，假设`Gopkg.toml`和`Gopkg.lock`都可用，可以通过运行`dep
    ensure -vendor-only`来动态填充供应商文件夹。
- en: The Gopkg.toml file
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gopkg.toml文件
- en: The `Gopkg.toml` file serves as a manifest for controlling the dep tool's behavior.
    The `dep init` invocation will analyze the import graph of the project and produce
    a `Gopkg.toml` file with an initial set of constraints. From that point on, whenever
    a constraint needs to be updated (usually to bump the minimum supported version),
    users need to *manually* modify the generated `Gopkg.toml` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gopkg.toml`文件作为控制dep工具行为的清单。`dep init`调用将分析项目的导入图并生成一个包含初始约束集的`Gopkg.toml`文件。从那时起，每当需要更新约束（通常是为了提高最低支持的版本）时，用户需要*手动*修改生成的`Gopkg.toml`文件。'
- en: 'So what does the content of a `Gopkg.toml` file look like? `Gopkg.toml` files
    are composed of a list of blocks or stanzas. Each stanza contains one of the dep-supported
    rule types. The most frequently used rule types are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`Gopkg.toml`文件的内容是什么样的呢？`Gopkg.toml`文件由一系列块或节组成。每个节包含dep支持的规则类型之一。最常用的规则类型如下：
- en: '**Constraints**, which specify the range of compatible dependency versions'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**约束**，指定兼容依赖项版本的范围'
- en: '**Overrides**, which can force a particular package version when the dep tool
    cannot automatically find a version that satisfies the aggregated set of constraints
    specified by multiple `Gopkg.toml` files'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖**，当dep工具无法自动找到满足多个`Gopkg.toml`文件指定的聚合约束集的版本时，可以强制使用特定的包版本'
- en: 'For the full list of supported rule types that the dep tool recognizes, you
    can refer to the `Gopkg.toml` format specification document ^([8]). The following
    example defines a constraint that instructs go dep to fetch the package sources
    from the `master` branch of the package''s GitHub repository:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于dep工具识别的支持的规则类型完整列表，您可以参考`Gopkg.toml`格式规范文档^([8])。以下示例定义了一个约束，指示go dep从包的GitHub存储库的`master`分支获取包源代码：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Alternatively, instead of `branch`, a constraint rule can include one of the
    following two keywords: `revision` or `version`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，除了`branch`之外，约束规则可以包括以下两个关键字之一：`revision`或`version`。
- en: The `revision` keyword allows a package dependency to be pinned down to a particular
    commit identifier (for example, a Git SHA). It exists for compatibility purposes,
    and dep users are strongly encouraged to avoid using it unless there is no better
    way to describe a version.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`revision`关键字允许将包依赖项固定到特定的提交标识符（例如，Git SHA）。它存在是为了兼容性目的，强烈建议dep用户除非没有更好的方式来描述版本，否则避免使用它。'
- en: On the other hand, the `version` keyword is much more versatile in that it allows
    us to target a specific VCS tag or semantic version range. The following table
    lists the operators that dep understands when processing version-based constraints.
    If the version string *does not* contain an operator, the dep tool will work as
    if the caret (`^`) operator was used. For example, dep would interpret version `1.2.5` as
    if the following constraint had been specified instead: `>= 1.2.5 and < 1.3`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`version`关键字在允许我们针对特定的VCS标签或语义版本范围方面更加灵活。以下表格列出了dep在处理基于版本的约束时理解的运算符。如果版本字符串*不包含*运算符，dep工具将像使用了连字符(`^`)运算符一样工作。例如，dep将版本`1.2.5`解释为如果指定了以下约束：`>=
    1.2.5 and < 1.3`。
- en: '| **Operator** | **Description** | **Example** | **Constraint interpretation**
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** | **约束解释** |'
- en: '| = | Equals | "=1.2.4" | Select version 1.2.4 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| = | 等于 | "=1.2.4" | 选择版本1.2.4 |'
- en: '| != | Not equal | "!=0.1" | Exclude version 0.1 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 | "!=0.1" | 排除版本0.1 |'
- en: '| > | Greater than | ">1.2" | Versions newer than 1.3.0 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 | ">1.2" | 新于1.3.0的版本 |'
- en: '| < | Less than | "<2.0" | Versions older than 2.0.0 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 | "<2.0" | 低于2.0.0的版本 |'
- en: '| - | Literal range | "1.2-1.4" | Versions >= 1.2 and <= 1.4 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| - | 文字范围 | "1.2-1.4" | 版本 >= 1.2 且 <= 1.4 |'
- en: '| ~ | Minor range | "~1.2.5" | Versions >= 1.2.5 and < 1.3 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| ~ | 小范围 | "~1.2.5" | 版本 >= 1.2.5 且 < 1.3 |'
- en: '| ^ | Major range | "~1.2.5" | Versions >= 1.2.5 and < 2 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| ^ | 主范围 | "~1.2.5" | 版本 >= 1.2.5 且 < 2 |'
- en: One other quite helpful keyword that you may encounter when working with `Gopkg.toml`
    files is the `source` keyword. The default behavior of the dep tool is to fetch
    package sources from the repository whose name matches the package name specified
    by the constraint.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 `Gopkg.toml` 文件时，你可能会遇到另一个非常有用的关键字，那就是 `source` 关键字。dep 工具的默认行为是从与约束中指定的包名匹配的仓库中获取包源。
- en: 'There are some cases, however, where we may want to pull the package from a
    different location. One scenario where this can happen is if we have forked the
    imported package, pushed some experimental changes, and want to try them out in
    a code base that imports the original package. To demonstrate this, let''s edit
    the `Gopkg.toml` file from the preceding example and have it pull the master branch
    from `github.com/achilleasa/logrus` instead of `github.com/sirupsen/logrus`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们可能希望从不同的位置拉取包。这种情况可能发生在我们分叉了导入的包，推送了一些实验性更改，并想在导入原始包的代码库中尝试这些更改。为了演示这一点，让我们编辑前一个示例中的
    `Gopkg.toml` 文件，并让它从 `github.com/achilleasa/logrus` 而不是 `github.com/sirupsen/logrus`
    拉取 master 分支：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we mentioned at the beginning of the section, the `Gopkg.toml` file is only
    a manifest that users can change at will. For the changes to actually take effect,
    we need to run `dep ensure` to do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，`Gopkg.toml` 文件仅是一个用户可以随意更改的清单。为了使更改生效，我们需要运行 `dep ensure` 来执行以下操作：
- en: Scan the code for any new dependencies
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查代码中是否有任何新的依赖项
- en: Invoke the constraints solver to calculate the required version for each dependency
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用约束求解器计算每个依赖项所需的版本
- en: Figure out which of the packages in the `vendor `folder are stale and update
    them
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定哪个 `vendor` 文件夹中的包已过时并更新它们
- en: Update the `Gopkg.lock` file
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 `Gopkg.lock` 文件
- en: The Gopkg.lock file
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gopkg.lock 文件
- en: The second file that gets generated by the dep tool when running either `dep
    init` or `dep ensure` is called `Gopkg.lock`. As you can probably tell by its
    extension, it is something that is not meant to be modified by end users.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 `dep init` 或 `dep ensure` 时，dep 工具生成的第二个文件称为 `Gopkg.lock`。正如你可能从其扩展名中猜到的，它不是用户打算修改的东西。
- en: The `Gopkg.lock` file stores a textual representation of the dep tool's constraint
    solver output. More specifically, it includes the complete list of dependencies,
    both direct and transient, that are required for compiling the project source
    code. Each dependency is pinned down to the particular commit identifier (for
    example, a Git SHA) that, according to the solver, satisfies all constraints that
    were supplied to it by the dep tool.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gopkg.lock` 文件存储了 dep 工具的约束求解器输出的文本表示。更具体地说，它包括编译项目源代码所需的完整依赖项列表，包括直接和临时依赖项。每个依赖项都被固定到特定的提交标识符（例如，Git
    SHA），根据求解器的判断，该标识符满足 dep 工具提供的所有约束。'
- en: By committing the `Gopkg.lock` file to the VCS, the dep support in Go 1.9+ guarantees
    that we can produce repeatable builds, provided, of course, that all referenced
    dependencies remain available.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `Gopkg.lock` 文件提交到版本控制系统（VCS），Go 1.9+ 中的 dep 支持确保我们可以生成可重复构建，当然前提是所有引用的依赖项仍然可用。
- en: Go modules – the way forward
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 模块 – 前进之路
- en: 'One limitation of the dep tool is that it does not let us use multiple major
    versions of a package in our projects, as each path to an imported package must
    be unique. The following diagram illustrates a simple scenario where packages A and B depend
    on the same version of package C:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: dep 工具的一个限制是它不允许我们在项目中使用一个包的多个主要版本，因为每个导入包的路径必须是唯一的。以下图表说明了 A 和 B 包依赖于相同版本 C
    包的简单场景：
- en: '![](img/781d9b9b-f9e3-4d9c-aeb9-8b809c389ad5.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/781d9b9b-f9e3-4d9c-aeb9-8b809c389ad5.png)'
- en: Figure 3: Two packages importing the same version of the C package
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：两个导入相同版本 C 包的包
- en: 'Let''s say now that we want to test drive *v2.0.0*, the new major version of
    theCpackage. The point here is to *gradually update* the packages importing C to
    import the new major version in order to assess that everything works as expected.
    So we update the `Gopkg.toml` file in B to reference the new major version of C.
    Our dependency tree now looks as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在我们想要测试驱动C包的新主要版本*v2.0.0*。这里的目的是*逐步更新*导入C的包，以便评估一切是否按预期工作。因此，我们将B中的`Gopkg.toml`文件更新为引用C的新主要版本。我们的依赖关系树现在如下所示：
- en: '![](img/da8920a4-d755-4ed6-9dc3-99b6b0d18ade.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da8920a4-d755-4ed6-9dc3-99b6b0d18ade.png)'
- en: Figure 4: Each package imports a different version of the C package
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：每个包导入C包的不同版本
- en: 'This change causes no problems for packages A and B as their import graphs
    are disjointed; each package references a different version of C. Then, we decide
    to introduce a new package, say D, into the picture, which imports *both* A and B (as
    shown in the following figure). Now we have a problem! As both packages cannot
    use the *same* import path, the Go compiler will now bail out with an error when
    we try to build D:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改对包A和B没有问题，因为它们的导入图是分离的；每个包引用C的不同版本。然后，我们决定引入一个新的包，比如D，到这个场景中，它导入*两者*（如图所示）。现在我们遇到了问题！因为这两个包不能使用*相同的*导入路径，所以当我们尝试构建D时，Go编译器会因错误而退出：
- en: '![](img/020e823e-caa2-4c77-8472-f20680a03f7d.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/020e823e-caa2-4c77-8472-f20680a03f7d.png)'
- en: Figure 5: Package D imports both A and B, which depend on different major versions
    of C. This causes a conflict and prevents us from building D
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：包D同时导入A和B，它们依赖于C的不同主要版本。这导致冲突，阻止我们构建D
- en: The only way to make the preceding use case work with the dep tool is to change
    the constraints (`Gopkg.toml`) file for *all* packages (A and B in this case)
    to depend on *v2.0.0* of package C. It goes without saying that this is not a
    solution that can scale to projects that import a large number of packages. With
    that in mind, the Go team led an initiative to come up with an official vendoring
    solution that could support scenarios such as the preceding one.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要使前面的用例与dep工具一起工作，唯一的办法是将所有包（在这个例子中是A和B）的约束（`Gopkg.toml`）文件改为依赖于C的*v2.0.0*版本。不用说，这不是一个可以扩展到导入大量包的项目解决方案。考虑到这一点，Go团队领导了一项倡议，旨在提出一个官方的
    vendoring 解决方案，以支持上述场景。
- en: 'Go modules were introduced as an experimental feature in Go 1.11 that users
    could enable via the `GO111MODULE` environment variable (for example, `export
    GO111MODULE=on`). At the time of writing, the current Go version is 1.12.5, and
    Go modules are expected to be finalized just in time for the release of Go 1.13\.
    The major difference of Go modules compared to the dep tool are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块是在Go 1.11中作为实验性功能引入的，用户可以通过`GO111MODULE`环境变量（例如，`export GO111MODULE=on`）来启用它。在撰写本文时，当前的Go版本是1.12.5，预计Go模块将在Go
    1.13发布时最终确定。与dep工具相比，Go模块的主要区别如下：
- en: Go modules fully integrate with the various commands, such as `go get`, `go
    build`, and `go test`.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go模块完全集成了各种命令，如`go get`、`go build`和`go test`。
- en: While the dep tool selects the *highest* common version for a package, Go modules
    select the *minimum* viable version.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然dep工具选择一个包的最高公共版本，但Go模块选择*最小*可行的版本。
- en: Go modules support multiversioned dependencies.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go模块支持多版本依赖。
- en: Go modules do away with the `vendor` folder, which is used by the dep tool.
    For backward-compatibility purposes, Go modules come with an extra command to
    populate the `vendor` folder: `go mod vendor`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go模块取消了dep工具使用的`vendor`文件夹。出于向后兼容的目的，Go模块提供了一个额外的命令来填充`vendor`文件夹：`go mod vendor`。
- en: 'The following simple example uses the popular `go-yaml` package to read a YAML
    stream from the standard input and output it as a Go map:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的示例使用流行的`go-yaml`包从标准输入读取YAML流并将其输出为Go映射：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To begin using Go modules, we first need to declare a new Go module by running `go
    mod init parser` in the folder where the preceding example is located. This will
    generate a file called `go.mod`. Its initial contents look pretty boring:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Go模块，我们首先需要在包含前面示例的文件夹中运行`go mod init parser`来声明一个新的Go模块。这将生成一个名为`go.mod`的文件。它的初始内容看起来相当无聊：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The real magic happens when we try to run a command such as `go build`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行`go build`等命令时，真正的魔法发生了：
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, Go realized that we needed to fetch a new dependency, so it
    tried to work out the *current* version of the `go-``yaml` package and resolved
    it to *v2.1.0*. It then proceeded to download the package and cache it locally
    under `$GOPATH/pkg/mod`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Go意识到我们需要获取一个新的依赖项，因此它试图确定`go-yaml`包的当前版本，并将其解析为`v2.1.0`。然后，它继续下载该包并将其缓存到`$GOPATH/pkg/mod`目录下。
- en: If you list the contents of the project's folder, you will notice a new file
    called `go.sum`. This file stores the cryptographic hashes of the dependencies
    that have been downloaded and serves as a safeguard for ensuring that the contents
    of the packages have not been modified between builds (that is, a package maintainer
    force-pushed some changes, overwriting the previous version); a very useful feature
    when aiming for repeatable builds.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你列出项目的文件夹内容，你会注意到一个名为`go.sum`的新文件。此文件存储已下载依赖项的加密哈希值，并在确保包内容在构建之间未被修改（即，包维护者强制推送了一些更改，覆盖了先前的版本）方面提供保护；这是一个在追求可重复构建时的非常有用的功能。
- en: The `go.mod` and `go.sum` files serve the same purpose as the `Gopkg.toml` and `Gopkg.lock` files
    used by the dep tool, and they also need to be committed to your version control
    system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`go.mod`和`go.sum`文件的作用与dep工具使用的`Gopkg.toml`和`Gopkg.lock`文件相同，并且它们也需要提交到你的版本控制系统。'
- en: 'Whenever a new dependency gets added, a line is appended to the `go.mod` file.
    In this case, the added line reads `require github.com/go-yaml/yaml v2.1.0+incompatible`.
    Each `require `line in the `go.mod` file defines the *minimum* supported version
    for a particular dependency. So, from our module''s perspective, `v2.1.0 `of the `go-yaml/yaml` package
    is the *minimum* version requirement for building the module. Even if a newer
    version is available, Go will *always* use this particular version unless we run
    one of the following commands:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每当添加一个新的依赖项时，都会在`go.mod`文件中添加一行。在这种情况下，添加的行是`require github.com/go-yaml/yaml
    v2.1.0+incompatible`。`go.mod`文件中的每一行`require`定义了特定依赖项的*最低*支持版本。因此，从我们的模块角度来看，`go-yaml/yaml`包的`v2.1.0`是构建模块的*最低*版本要求。即使有新版本可用，Go也*始终*使用这个特定的版本，除非我们运行以下命令之一：
- en: '`go get -u`: To upgrade to the most recent minor or patch release'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go get -u`：升级到最新的次要或补丁版本'
- en: '`go get -u=patch`: To upgrade to the most recent patch release'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go get -u=patch`：升级到最新的补丁版本'
- en: '`go get package-name@version`: To force the specified version for the package'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go get package-name@version`：强制指定包的指定版本'
- en: 'Now that we have a basic understanding of how Go modules work, let''s revisit
    our initial use case: how can we use two different major versions of the same
    package inside our code base? As I mentioned before, Go import paths must be unique;
    that''s something that is set in stone and cannot be overridden.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Go模块的工作原理有了基本的了解，让我们回顾一下我们的初始用例：我们如何在代码库中使用同一包的两个不同主要版本？正如我之前提到的，Go导入路径必须是唯一的；这是不可更改的，不能被覆盖。
- en: 'The `+incompatible` suffix in the `require` line indicates that while this
    package defines a valid semantic version, it hasn''t actively opted in to using
    Go modules by defining its own `go.mod `file. If, however, a new version appeared
    in the future (say, v4) that did provide a `go.mod` file, Go modules would allow
    us to import it via a mechanism referred to as *semantic import versioning*. To
    put it in layman''s terms, semantic import paths are just regular import paths
    that also carry an additional *version suffix*. The suffix addition creates a
    unique path for the package and effectively allows us to import and use multiple
    versions of the package even within the same file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`行中的`+incompatible`后缀表示，尽管这个包定义了一个有效的语义版本，但它并没有通过定义自己的`go.mod`文件来主动选择使用Go模块。然而，如果将来出现一个新版本（比如v4）并提供了一个`go.mod`文件，Go模块将允许我们通过称为*语义导入版本控制*的机制导入它。用简单的话来说，语义导入路径只是带有附加*版本后缀*的常规导入路径。后缀的添加为包创建了一个唯一的路径，并有效地允许我们在同一文件中导入和使用多个版本的包：'
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That concludes our short tour of Go modules. A deep dive into all operations
    and patterns supported by the Go modules extension is outside of the scope of
    this book; however, if you are interested in learning more about using Go modules,
    you can find a great amount of information by browsing the relevant articles on
    the Golang blog ^([6]).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Go模块的简要游览。关于Go模块扩展支持的所有操作和模式的深入探讨超出了本书的范围；然而，如果你对学习更多关于使用Go模块的信息感兴趣，你可以在Golang博客上浏览相关的文章^([6])。
- en: Fork packages
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分叉包
- en: With the dep tool and Go modules at our disposal, why would we ever need to
    manually fork any of the packages we depend on? Before we answer this question,
    let me first elaborate on how this process works.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拥有 dep 工具和 Go modules 的情况下，我们为什么还需要手动分支我们依赖的任何包呢？在我们回答这个问题之前，让我首先详细说明这个过程是如何工作的。
- en: 'Firstly, we need to fork the dependency we are interested in. If the package
    sources are available on a platform such as GitHub, GitLab, or BitBucket, then
    forking the package is as simple as visiting the repository page and clicking
    a button (see the following screenshot); otherwise, we would need to rely on the
    functionality provided by our preferred VCS to persist a copy of the dependency
    to a location under our control:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要分支我们感兴趣的依赖项。如果包源代码在 GitHub、GitLab 或 BitBucket 等平台上可用，那么分支包就像访问存储库页面并点击一个按钮一样简单（参见以下截图）；否则，我们就需要依赖我们首选的
    VCS 提供的功能，将依赖项的副本持久化到我们控制的位置：
- en: '![](img/61cabb4a-cf10-4027-8adb-79bf97b6abe1.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61cabb4a-cf10-4027-8adb-79bf97b6abe1.png)'
- en: Figure 6: Forking a package repository on a platform such as GitHub, GitLab,
    or BitBucket is as simple as clicking a button
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6：在 GitHub、GitLab 或 BitBucket 等平台上分支包存储库就像点击一个按钮一样简单
- en: After forking the repo, we would need to scan through the code base and replace
    the imports for the original package to point to our forked version. Of course,
    a much better alternative would be to use the dep tool's provided escape hatch
    for overriding the source for a package dependency. In the latter case, we wouldn't
    need to modify any of the import statements in our code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在分支存储库之后，我们需要扫描代码库并替换原始包的导入，使其指向我们的分支版本。当然，一个更好的选择是使用 dep 工具提供的逃生舱口来覆盖包依赖项的源。在后一种情况下，我们就不需要修改代码中的任何导入语句。
- en: 'That brings us back to the original question: why fork in the first place?
    When working for companies that process sensitive data, such as the ones that
    operate in the fintech or healthcare domains, it is quite common to have an in-house
    security team that must audit each imported dependency for potential security
    flaws before the engineering teams are allowed to use it in their code.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这又带我们回到了最初的问题：为什么一开始就要进行分支？当为处理敏感数据的公司工作，例如在金融科技或医疗保健领域运营的公司时，拥有一个内部安全团队是相当常见的，这个团队必须审计每个导入的依赖项，以检查潜在的安全漏洞，然后工程团队才能在他们的代码中使用它。
- en: Performing a full security audit on a package is quite a lengthy process; it
    stands to reason that auditing each package from scratch each time a new release
    becomes available is neither feasible nor cost-effective. As a result, security
    teams seek to amortize the initial audit cost by forking packages, performing
    a full audit, and then vet and cherry-pick any upstream changes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个包进行全面的安全审计是一个相当耗时的过程；从逻辑上讲，每次新版本发布时都从头开始审计每个包既不可行也不经济。因此，安全团队通过分支包、进行全面审计，然后验证和选择任何上游更改来分摊初始审计成本。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the reasons that necessitate the use of versioning
    for not only the packages that our code imports, but also the code itself that
    we, as software engineers, author. We then defined the concept of semantic versioning
    and the circumstances where each component of a semantic version needs to be incremented.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了为什么需要使用版本控制，这不仅包括我们代码导入的包，还包括我们作为软件工程师编写的代码本身。然后我们定义了语义版本控制的概念以及何时需要增加语义版本中的每个组件。
- en: The meat of the chapter dealt with the concepts of vendoring as the primary
    mechanism for ensuring repeatable builds for our projects. After elaborating on
    the pros and cons of vendoring as a process, we examined the current state of
    vendoring in the Go ecosystem and provided a brief tour of the state-of-the-art
    tools (*dep* and *Go modules*) that engineers should use to manage their package
    dependencies.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是介绍作为确保项目可重复构建的主要机制的 vendoring。在详细阐述了 vendoring 作为一种流程的优缺点之后，我们考察了 Go 生态系统中的
    vendoring 现状，并简要介绍了工程师应使用的最先进工具（*dep* 和 *Go modules*）来管理他们的包依赖。
- en: Of course, as our code base evolves and the version requirements for our imports
    change over time, it is likely that, at some point, a newer version of one of
    the packages we depend on will break our code. Obviously, we want to be able to
    catch such regressions as early as possible. One way to achieve this, and the
    central theme of the next chapter, is to have a solid testing infrastructure in
    place.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，随着我们的代码库的发展以及我们导入的版本要求随时间变化，我们很可能在某个时候，我们依赖的某个包的新版本会破坏我们的代码。显然，我们希望尽可能早地捕捉到这样的回归。实现这一目标的一种方法，也是下一章的中心主题，就是建立一个坚实的测试基础设施。
- en: Questions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is software versioning important?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件版本控制为什么很重要？
- en: What does a semantic version look like and when are its individual components
    incremented?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语义版本看起来是什么样的，以及它的各个组成部分何时会增加？
- en: Which component of a package's semantic version would you increment in the following
    cases?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下情况下，您会增加一个包的语义版本中的哪个组件？
- en: A new API is introduced.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入了一个新的API。
- en: An existing API is modified and a new, *required* parameter is added to it.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改了现有的API，并添加了一个新的、*必需的*参数。
- en: A fix for a security bug is committed.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交了一个安全漏洞的修复。
- en: Name some alternative versioning schemes that we could use besides semantic
    versioning.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了语义版本控制之外，我们还可以使用哪些替代版本控制方案？
- en: What are the pros and cons of vendoring?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: vendoring的优缺点是什么？
- en: Name some of the differences between the dep tool and Go modules.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些dep工具和Go模块之间的不同之处。
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Cook, Stephen A., 'The Complexity of Theorem-proving Procedures', *Proceedings
    of the Third Annual ACM Symposium on Theory of Computing*, STOC '71\. New York,
    NY, USA, ACM, 1971, S. 151–8
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cook, Stephen A.，《定理证明过程复杂性》，*第三届年度ACM理论计算研讨会论文集*，STOC '71。纽约，纽约，美国，ACM，1971年，第151-158页
- en: 'dep: a dependency management tool for Go: [https://github.com/golang/dep](https://github.com/golang/dep)'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: dep：Go的依赖管理工具：[https://github.com/golang/dep](https://github.com/golang/dep)
- en: glide: [https://github.com/Masterminds/glide](https://github.com/Masterminds/glide)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: glide：[https://github.com/Masterminds/glide](https://github.com/Masterminds/glide)
- en: gvt: [https://github.com/FiloSottile/gvt](https://github.com/FiloSottile/gvt)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: gvt：[https://github.com/FiloSottile/gvt](https://github.com/FiloSottile/gvt)
- en: godep: [https://github.com/tools/godep](https://github.com/tools/godep)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: godep：[https://github.com/tools/godep](https://github.com/tools/godep)
- en: 'Golang blog: using Go modules: [https://blog.golang.org/using-go-modules](https://blog.golang.org/using-go-modules)'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Golang博客：使用Go模块：[https://blog.golang.org/using-go-modules](https://blog.golang.org/using-go-modules)
- en: '`Gopkg.in`: stable APIs for the Go language: [https://labix.org/gopkg.in](https://labix.org/gopkg.in)'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Gopkg.in`：Go语言的稳定API：[https://labix.org/gopkg.in](https://labix.org/gopkg.in)'
- en: '`Gopkg.toml` format specification: [https://golang.github.io/dep/docs/Gopkg.toml.html](https://golang.github.io/dep/docs/Gopkg.toml.html)'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Gopkg.toml`格式规范：[https://golang.github.io/dep/docs/Gopkg.toml.html](https://golang.github.io/dep/docs/Gopkg.toml.html)'
- en: 'govendor: [https://github.com/kardianos/govendor](https://github.com/kardianos/govendor)'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: govendor：[https://github.com/kardianos/govendor](https://github.com/kardianos/govendor)
- en: 'Plus codes: short codes for locations, for places that don''t have their own
    street address: [https://plus.codes/](https://plus.codes/)'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Plus codes：为没有自己的街道地址的位置提供的简短代码：[https://plus.codes/](https://plus.codes/)
- en: Semantic versioning 2.0.0: [https://semver.org/](https://semver.org/)
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语义版本控制2.0.0：[https://semver.org/](https://semver.org/)
- en: 'Silva, João P. Marques; Lynce, Inês; Malik, Sharad, Biere, A.; Heule, M. ; Maaren,
    H. van; Walsh, T. (Hrsg.), ''Conflict-Driven Clause Learning SAT Solvers'', *Handbook
    of Satisfiability, Frontiers in Artificial Intelligence and Applications*, Bd.
    185 : IOS Press, 2009, ISBN 978-1-58603-929-5 ([https://www.worldcat.org/title/handbook-of-satisfiability/oclc/840409693](https://www.worldcat.org/title/handbook-of-satisfiability/oclc/840409693)),
    S. 131–53'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Silva, João P. Marques；Lynce, Inês；Malik, Sharad，Biere, A.；Heule, M.；Maaren,
    H. van；Walsh, T.（主编），《冲突驱动的子句学习SAT求解器》，*可满足性手册，人工智能应用前沿*，第185卷：IOS Press，2009年，ISBN
    978-1-58603-929-5 ([https://www.worldcat.org/title/handbook-of-satisfiability/oclc/840409693](https://www.worldcat.org/title/handbook-of-satisfiability/oclc/840409693))，第131-153页
