["```go\n// Challenger is implemented by objects that can generate CAPTCHA image \n// challenges.\ntype Challenger interface {\n Challenge() (img image.Image, imgText string)\n}\n\n// Prompter is implemented by objects that display a CAPTCHA image to the \n// user, ask them to type their contents and return back their response.\ntype Prompter interface {\n Prompt(img image.Image) string\n}\n```", "```go\nfunc ChallengeUser(c Challenger, p Prompter) bool {\n img, expAnswer := c.Challenge()\n userAnswer := p.Prompt(img)\n\n if subtle.ConstantTimeEq(int32(len(expAnswer)), int32(len(userAnswer))) \n     == 0 {\n return false\n }\n\n return subtle.ConstantTimeCompare([]byte(userAnswer), []byte(expAnswer)) == 1\n}\n```", "```go\ntype stubChallenger string\n\nfunc (c stubChallenger) Challenge() (image.Image, string) {\n return image.NewRGBA(image.Rect(0, 0, 100, 100)), string(c)\n}\ntype stubPrompter string\n\nfunc (p stubPrompter) Prompt(_ image.Image) string {\n return string(p)\n}\n```", "```go\nfunc TestChallengeUserSuccess(t *testing.T) {\n got := captcha.ChallengeUser(stubChallenger(\"42\"), stubPrompter(\"42\"))\n if got != true {\n t.Fatal(\"expected ChallengeUser to return true\")\n }\n}\n\nfunc TestChallengeUserFail(t *testing.T) {\n got := captcha.ChallengeUser(stubChallenger(\"lorem ipsum\"), stubPrompter(\"42\"))\n if got != false {\n t.Fatal(\"expected ChallengeUser to return false\")\n }\n}\n```", "```go\n// Publisher is implemented by objects that can send a message to a user.\ntype Publisher interface {\n Publish(userID, message string) error\n}\n\ntype Room struct {\n pub Publisher\n mu    sync.RWMutex\n users []string\n}\n\n// NewRoom creates a new chat root instance that used pub to broadcast \n// messages.\nfunc NewRoom(pub Publisher) *Room {\n return &Room{pub: pub}\n}\n```", "```go\ntype entry struct {\n user    string\n message string\n}\n\ntype spyPublisher struct {\n published []entry\n}\n\nfunc (p *spyPublisher) Publish(user, message string) error {\n p.published = append(p.published, entry{user: user, message: message})\n return nil\n}\n```", "```go\nfunc TestChatRoomBroadcast(t *testing.T) {\n pub := new(spyPublisher)\n room := chat.NewRoom(pub)\n room.AddUser(\"bob\")\n room.AddUser(\"alice\")\n _ = room.Broadcast(\"hi\")\n exp := []entry{\n {user: \"bob\", message: \"hi\"},\n {user: \"alice\", message: \"hi\"},\n }\n if got := pub.published; !reflect.DeepEqual(got, exp) {\n t.Fatalf(\"expected the following messages:\\n%#+v\\ngot:\\n%#+v\", exp, got)\n }\n}\n```", "```go\n$ go get github.com/golang/mock/gomock\n$ go install github.com/golang/mock/mockgen\n```", "```go\ntype API interface {\n // ListDependencies returns the list of direct dependency IDs for a\n // particular project ID or an error if a non-project ID argument is\n // provided.\n ListDependencies(projectID string) ([]string, error)\n\n // DependencyType returns the type of a particular dependency.\n DependencyType(dependencyID string) (DepType, error)\n}\n```", "```go\nfunc (c *Collector) AllDependencies(projectID string) ([]string, error) {\n ctx := newDepContext(projectID)\n for ctx.HasUncheckedDeps() {\n projectID = ctx.NextUncheckedDep()\n projectDeps, err := c.api.ListDependencies(projectID)\n if err != nil {\n return nil, xerrors.Errorf(\"unable to list dependencies for project %q: %w\", projectID, err)\n }\n if err = c.scanProjectDependencies(ctx, projectDeps); err != nil {\n return nil, err\n }\n }\n return ctx.depList, nil\n}\n```", "```go\nfunc (c *Collector) scanProjectDependencies(ctx *depCtx, depList []string) error {\n for _, depID := range depList {\n if ctx.AlreadyChecked(depID) {\n continue\n }\n ctx.AddToDepList(depID)\n depType, err := c.api.DependencyType(depID)\n if err != nil {\n return xerrors.Errorf(\"unable to get dependency type for id %q: %w\", depID, err)\n }\n if depType == DepTypeProject {\n ctx.AddToUncheckedList(depID)\n }\n }\n return nil\n}\n```", "```go\n$ mockgen \\\n    -destination mock/dependency.go \\\n    github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang/Chapter04/dependency \\\n    API\n```", "```go\n// Create a controller to manage all our mock objects and make sure\n// that all expectations were met before completing the test\nctrl := gomock.NewController(t)\ndefer ctrl.Finish()\n\n// Obtain a mock instance that implements API and associate it with the controller.\napi := mock_dependency.NewMockAPI(ctrl)\n```", "```go\ngomock.InOrder(\n api.EXPECT().\n ListDependencies(\"proj0\").Return([]string{\"proj1\", \"res1\"}, nil),\n api.EXPECT().\n DependencyType(\"proj1\").Return(dependency.DepTypeProject, nil),\n api.EXPECT().\n DependencyType(\"res1\").Return(dependency.DepTypeResource, nil),\n api.EXPECT().\n ListDependencies(\"proj1\").Return([]string{\"res1\", \"res2\"}, nil),\n api.EXPECT().\n DependencyType(\"res2\").Return(dependency.DepTypeResource, nil),\n)\n```", "```go\ncollector := dependency.NewCollector(api)\ndepList, err := collector.AllDependencies(\"proj0\")\nif err != nil {\n t.Fatal(err)\n}\n\nif exp := []string{\"proj1\", \"res1\", \"res2\"}; !reflect.DeepEqual(depList, exp) {\n t.Fatalf(\"expected dependency list to be:\\n%v\\ngot:\\n%v\", exp, depList)\n}\n```", "```go\ntype Device interface {\n Square([]float32) []float32\n Sum([]float32) float32\n}\n```", "```go\nfunc SumOfSquares(c Device, in []float32) float32 {\n sq := c.Square(in)\n return c.Sum(sq)\n}\n```", "```go\ntype cpuComputeDevice struct{}\n\nfunc (d cpuComputeDevice) Square(in []float32) []float32 {\n for i := 0; i < len(in); i++ {\n in[i] *= in[i]\n }\n return in\n}\n\nfunc (d cpuComputeDevice) Sum(in []float32) (sum float32) {\n for _, v := range in {\n sum += v\n }\n return sum\n}\n```", "```go\nfunc TestSumOfSquares(t *testing.T) {\n var dev compute.Device\n if os.Getenv(\"USE_GPU\") != \"\" {\n t.Log(\"using GPU device\")\n dev = gpu.NewDevice()\n } else {\n t.Log(\"using CPU device\")\n dev = cpuComputeDevice{}\n }\n // Generate deterministic sample data and return the expected sum\n in, expSum := genTestData(1024)\n if gotSum := compute.SumOfSquares(dev, in); gotSum != expSum {\n t.Fatalf(\"expected SumOfSquares to return %f; got %f\", expSum, gotSum)\n }\n}\n```", "```go\n{\n \"price\": 10.0,\n \"currency\": \"GBP\"\n}\n```", "```go\n{\n \"vat_rate\": 0.29\n}\n```", "```go\nfunc spinUpTestServer(t *testing.T, res map[string]interface{}) *httptest.Server {\n encResponse, err := json.Marshal(res)\n if err != nil {\n t.Fatal(err)\n }\n\n return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n w.Header().Set(\"Content-Type\", \"application/json\")\n if _, wErr := w.Write(encResponse); wErr != nil {\n t.Fatal(wErr)\n }\n }))\n}\n```", "```go\n// t is a testing.T instance\npriceSvc := spinUpTestServer(t, map[string]interface{}{\n \"price\": 10.0,\n})\ndefer priceSvc.Close()\n\nvatSvc := spinUpTestServer(t, map[string]interface{}{\n \"vat_rate\": 0.29,\n})\ndefer vatSvc.Close()\n```", "```go\npc := retail.NewPriceCalculator(priceSvc.URL, vatSvc.URL)\ngot, err := pc.PriceForItem(\"1b6f8e0f-bbda-4f4e-ade5-aa1abcc99586\")\nif err != nil {\n t.Fatal(err)\n}\n\nif exp := 12.9; got != exp {\n t.Fatalf(\"expected calculated retail price to be %f; got %f\", exp, got)\n}\n```", "```go\ntype PriceCalculator struct {\n priceSvc svcCaller\n vatSvc   svcCaller\n}\n```", "```go\ntype svcCaller interface {\n Call(req map[string]interface{}) (io.ReadCloser, error)\n}\n```", "```go\nfunc (pc *PriceCalculator) PriceForItemAtDate(itemUUID string, date time.Time) (float64, error) {\n priceRes := struct {\n Price float64 `json:\"price\"`\n }{}\n vatRes := struct {\n Rate float64 `json:\"vat_rate\"`\n }{}\n req := map[string]interface{}{\"item\": itemUUID, \"period\": date}\n if err := pc.callService(pc.priceSvc, req, &priceRes); err != nil {\n return 0, xerrors.Errorf(\"unable to retrieve item price: %w\", err)\n }\n req = map[string]interface{}{\"period\": date}\n if err := pc.callService(pc.vatSvc, req, &vatRes); err != nil {\n return 0, xerrors.Errorf(\"unable to retrieve vat percent: %w\", err)\n }\n return vatInclusivePrice(priceRes.Price, vatRes.Rate), nil\n}\n```", "```go\nfunc (pc *PriceCalculator) callService(svc svcCaller, req map[string]interface{}, res interface{}) error {\n svcRes, err := svc.Call(req)\n if err != nil {\n return xerrors.Errorf(\"call to remote service failed: %w\", err)\n }\n defer drainAndClose(svcRes)\n\n if err = json.NewDecoder(svcRes).Decode(res); err != nil {\n return xerrors.Errorf(\"unable to decode remote service response: %w\", err)\n }\n return nil\n}\n```", "```go\nfunc TestVatInclusivePrice(t *testing.T) {\n specs := []struct {\n price   float64\n vatRate float64\n exp     float64\n }{\n {42.0, 0.1, 46.2},\n {10.0, 0, 10.0},\n }\n for specIndex, spec := range specs {\n if got := vatInclusivePrice(spec.price, spec.vatRate); got != spec.exp {\n t.Errorf(\"[spec %d] expected to get: %f; got: %f\", specIndex, spec.exp, got)\n }\n }\n}\n```", "```go\ntype stubSvcCaller map[string]interface{}\n\nfunc (c stubSvcCaller) Call(map[string]interface{}) (io.ReadCloser, error) {\n data, err := json.Marshal(c)\n if err != nil {\n return nil, err\n }\n\n return ioutil.NopCloser(bytes.NewReader(data)), nil\n}\n```", "```go\nfunc TestPriceForItem(t *testing.T) {\n pc := &PriceCalculator{\n priceSvc: stubSvcCaller{ \"price\": 42.0, },\n vatSvc: stubSvcCaller{ \"vat_rate\": 0.10, },\n }\n\n got, err := pc.PriceForItem(\"foo\")\n if err != nil {\n t.Fatal(err)\n }\n\n if exp := 46.2; got != exp {\n t.Fatalf(\"expected calculated retail price to be %f; got %f\", exp, got)\n }\n}\n```", "```go\ntype stubErrCaller struct {\n err error\n}\n\nfunc (c stubErrCaller) Call(map[string]interface{}) (io.ReadCloser, error) { \n return nil, c.err \n}\n```", "```go\nfunc TestVatSvcErrorHandling(t *testing.T) {\n pc := &PriceCalculator{\n priceSvc: stubSvcCaller{ \"price\": 42.0, },\n vatSvc: stubErrCaller{\n err: errors.New(\"unexpected response status code: 404\"),\n },\n }\n\n expErr := \"unable to retrieve vat percent: call to remote service failed: unexpected response status code: 404\"\n _, err := pc.PriceForItem(\"foo\")\n if err == nil || err.Error() != expErr {\n t.Fatalf(\"expected to get error:\\n %s\\ngot:\\n %v\", expErr, err)\n }\n}\n```", "```go\nfunc Evaluate(n int) string {\n if n != 0 {\n switch {\n case n%3 == 0 && n%5 == 0:\n return \"FizzBuzz\"\n case n%3 == 0:\n return \"Fizz\"\n case n%5 == 0:\n return \"Buzz\"\n }\n }\n return fmt.Sprint(n)\n}\n```", "```go\nspecs := []struct {\n descr string\n input int\n exp   string\n}{\n {descr: \"evenly divisible by 3\", input: 9, exp: \"Fizz\"},\n {descr: \"evenly divisible by 5\", input: 25, exp: \"Buzz\"},\n {descr: \"evenly divisible by 3 and 5\", input: 15, exp: \"FizzBuzz\"},\n // The following case is intentionally wrong to trigger a test failure!\n {descr: \"example of incorrect expectation\", input: 0, exp: \"FizzBuzz\"},\n {descr: \"edge case\", input: 0, exp: \"0\"},\n}\n```", "```go\nfor specIndex, spec := range specs {\n if got := fizzbuzz.Evaluate(spec.input); got != spec.exp {\n t.Errorf(\"[spec %d: %s] expected to get %q; got %q\", specIndex, spec.descr, spec.exp, got)\n }\n}\n```", "```go\nRun(description string, func(t *testing.T)) \n```", "```go\nfunc TestXYZ(t *testing.T){\n // Run suite setup code...\n\n t.Run(\"test1\", func(t *testing.T){\n // test1 code\n })\n\n t.Run(\"test2\", func(t *testing.T){\n // test2 code\n })\n\n // Run suite tear-down code...\n}\n```", "```go\nfunc TestFizzBuzzTableDrivenSubtests(t *testing.T) {\n specs := []struct {\n descr, exp string\n input      int\n }{\n {descr: \"evenly divisible by 3\", input: 9, exp: \"Fizz\"},\n {descr: \"evenly divisible by 3 and 5\", input: 15, exp: \"FizzBuzz\"},\n {descr: \"edge case\", input: 0, exp: \"0\"},\n }\n for specIndex, spec := range specs {\n t.Run(spec.descr, func(t *testing.T) {\n if got := fizzbuzz.Evaluate(spec.input); got != spec.exp {\n t.Errorf(\"[spec %d: %s] expected to get %q; got %q\", specIndex, spec.descr, spec.exp, got)\n }\n })\n }\n}\n```", "```go\ngo test -run TestFizzBuzzTableDrivenSubtests/evenly_divisible_by_3_and_5\n```", "```go\nimport (\n \"testing\"\n\n \"gopkg.in/check.v1\"\n)\n\ntype MySuite struct{}\n\n// Register suite with go check\nvar _ = check.Suite(new(MySuite))\n\n// Hook up gocheck into the \"go test\" runner.\nfunc Test(t *testing.T) { check.TestingT(t) }\n```", "```go\nAssert(obtained interface{}, checker Checker, args ...interface{}) \n```", "```go\nfunc TestDBConnection(t *testing.T) {\n host, port, dbName, user, pass := os.Getenv(\"DB_HOST\"), os.Getenv(\"DB_PORT\"),\n os.Getenv(\"DB_NAME\"), os.Getenv(\"DB_USER\"), os.Getenv(\"DB_PASS\")\n\n db, err := sql.Open(\"postgres\", makeDSN(user, pass, dbName, host, port))\n if err != nil {\n t.Fatal(err)\n }\n _ = db.Close()\n t.Log(\"Connection to DB succeeded\")\n}\n```", "```go\nif host == \"\" {\n t.Skip(\"Skipping test as DB connection info is not present\")\n}\n```", "```go\n// +build tag1 ... tagN\n\npackage some_package\n```", "```go\nfunc RoundtripTime(host string) (time.Duration, error) {\n var argList = []string{host}\n if runtime.GOOS == \"windows\" {\n argList = append(argList, \"-n\", \"1\", \"-l\", \"32\")\n } else {\n argList = append(argList, \"-c\", \"1\", \"-s\", \"32\")\n }\n\n out, err := exec.Command(\"ping\", argList...).Output()\n if err != nil {\n return 0, xerrors.Errorf(\"command execution failed: %w\", err)\n }\n return extractRTT(string(out))\n}\n```", "```go\n#!/bin/bash \ncat <<!!!EOF!!! | perl -pe 'chomp if eof'\n%s\n!!!EOF!!!\nexit %d\n```", "```go\n@echo off\ntype %s\nexit /B %d\n```", "```go\nfunc (s *PingerSuite) TestFakePing(c *check.C) {\n mock := \"32 bytes from 127.0.0.1: icmp_seq=0 ttl=32 time=42000 ms\"\n mockCmdOutput(c, \"ping\", mock, 0)\n\n got, err := pinger.RoundtripTime(\"127.0.0.1\")\n c.Assert(err, check.IsNil)\n c.Assert(got, check.Equals, 42*time.Second)\n}\n```", "```go\nfunc NewRetryingDialer(ctx context.Context, dialFunc DialFunc, maxAttempts int) *RetryingDialer {\n if maxAttempts > 31 {\n panic(\"maxAttempts cannot exceed 31\")\n }\n\n return &RetryingDialer{\n ctx:         ctx,\n dialFunc:    dialFunc,\n maxAttempts: maxAttempts,\n }\n}\n```", "```go\nfunc (d *RetryingDialer) Dial(network, address string) (conn net.Conn, err error) {\n for attempt := 1; attempt <= d.maxAttempts; attempt++ {\n if conn, err = d.dialFunc(network, address); err == nil {\n return conn, nil\n }\n\n log.Printf(\"dial %q: attempt %d failed; retrying after %s\", address, attempt, expBackoff(attempt))\n select {\n case <-time.After(expBackoff(attempt)): // Try again\n case <-d.ctx.Done():\n return nil, d.ctx.Err()\n }\n }\n return nil, ErrMaxRetriesExceeded\n}\n```", "```go\nfunc TestRetryingDialerWithRealClock(t *testing.T) {\n log.SetFlags(0)\n\n // Dial a random local port that nothing is listening on.\n d := dialer.NewRetryingDialer(context.Background(), net.Dial, 20)\n _, err := d.Dial(\"tcp\", \"127.0.0.1:65000\")\n if err !=  {\n t.Fatal(err)\n }\n}\n```", "```go\ndoneCh := make(chan struct{})\ndefer close(doneCh)\nclk := testclock.NewClock(time.Now())\ngo func() {\n for {\n select {\n case <-doneCh: // test completed; exit go-routine\n return\n default:\n clk.Advance(1 * time.Minute)\n }\n }\n}()\n```"]