- en: The Art of Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的艺术
- en: '"Program testing can be used to show the presence of bugs, but never to show
    their absence!"'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"程序测试可以用来显示错误的存在，但永远不能显示它们的缺失！"'
- en: '- Edsger Dijkstra'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 艾德加·迪杰斯特拉'
- en: 'Software systems are destined to grow and evolve over time. Open or closed
    source software projects have one thing in common: their *complexity* seems to
    follow an upward curve as the number of engineers working on the code base increases.
    To this end, having a comprehensive set of tests for the code base is of paramount
    importance. This chapter performs a deep dive into the different types of testing
    that can be applied to Go projects.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统注定会随着时间的推移而增长和演变。开源或闭源软件项目有一个共同点：随着在代码库上工作的工程师数量的增加，它们的*复杂性*似乎呈上升趋势。因此，拥有一个全面的代码库测试集至关重要。本章深入探讨了可以应用于Go项目的不同类型的测试。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Identifying the differences between high-level primitives such as stubs, mocks,
    spies, and fake objects that you can use while writing unit tests as substitutes
    for objects that are used inside the code under test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别在编写单元测试时可以用作测试代码内部使用对象的替代品的高级原语，如桩（stubs）、模拟（mocks）、间谍（spies）和伪造对象（fake objects）
- en: 'Comparing black-box and white-box testing: what''s the difference and why both
    are needed for writing comprehensive test suites'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较黑盒和白盒测试：两者的区别以及为什么两者都是编写全面测试套件所必需的
- en: Differences between integration and functional (end-to-end) testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试和功能（端到端）测试之间的区别
- en: 'Advanced test concepts: smoke tests, and one of my personal favorites – chaos
    tests!'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级测试概念：烟雾测试，以及我个人最喜欢的一种测试 – 混乱测试！
- en: Tips and tricks for writing clean tests in Go and pitfalls that you need to
    avoid
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中编写干净测试的技巧和窍门以及需要避免的陷阱
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The full code for the topics discussed within this chapter have been published
    to this book's GitHub repository under the `Chapter04` folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题的完整代码已发布到本书的GitHub仓库中的`Chapter04`文件夹下。
- en: You can access this book's GitHub repository by going to [https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang](https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问[https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang](https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang)来获取本书的GitHub仓库。
- en: 'To get you up and running as quickly as possible, each example project includes
    a makefile that defines the following set of targets:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您尽快开始，每个示例项目都包含一个makefile，它定义了以下目标集：
- en: '| **Makefile target** | **Description** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **Makefile目标** | **描述** |'
- en: '| `deps` | Install any required dependencies |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `deps` | 安装任何必需的依赖项 |'
- en: '| `test` | Run all the tests and report coverage |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `test` | 运行所有测试并报告覆盖率 |'
- en: '| `lint` | Check for lint errors |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `lint` | 检查lint错误 |'
- en: As with all the chapters in this book, you will need a fairly recent version
    of Go, which you can download at [https://golang.org/dl/](https://golang.org/dl/)*.*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的所有章节一样，您需要一个相当新的Go版本，您可以在[https://golang.org/dl/](https://golang.org/dl/)下载它。
- en: Unit testing
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: By definition, a unit is the smallest possible bit of code that we can test.
    In the context of Go programming, this would typically be a *single function*.
    However, according to the SOLID design principles that we explored in the previous
    chapters, each *Go package* could also be construed as an independent unit and
    tested as such.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，单元是我们能测试的最小可能的代码块。在Go编程的上下文中，这通常是一个*单个函数*。然而，根据我们在前几章中探讨的SOLID设计原则，每个*Go包*也可以被视为一个独立的单元，并以此进行测试。
- en: The term *unit testing* refers to the process of testing each *unit* of an application
    in *isolation* to verify that its behavior conforms to a particular set of specifications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*单元测试*指的是对应用程序的每个*单元*进行*隔离*测试的过程，以验证其行为是否符合特定的规范集。
- en: In this section, we will dive into the different methodologies of unit testing
    at our disposal (black- versus white-box testing). We will also examine strategies
    for making our code easier to unit test and cover the built-in Go testing packages,
    as well as third-party packages, that are designed to make writing tests more
    streamlined.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解我们可用的不同单元测试方法（黑盒与白盒测试）。我们还将检查使我们的代码更容易进行单元测试的策略，以及内置的Go测试包以及旨在使编写测试更加流畅的第三方包。
- en: Mocks, stubs, fakes, and spies – commonalities and differences
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟、桩、伪造和间谍 – 共同点和不同点
- en: Before digging deeper into the concepts behind unit testing, we need to discuss
    and disambiguate some of the terms that we will be using in the upcoming sections.
    While these terms have been out there for years, software engineers tend to occasionally
    conflate them when writing tests. A great example of such confusion becomes evident
    when you hear engineers use the terms *mock* and *stub *interchangeably.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨单元测试背后的概念之前，我们需要讨论和澄清我们将在接下来的部分中使用的某些术语。虽然这些术语已经存在多年，但软件工程师在编写测试时偶尔会将它们混淆。一个很好的例子是，当工程师交替使用*mock*和*stub*这两个术语时，这种混淆变得明显。
- en: 'To establish some common ground for a fruitful discussion and to clear any
    confusion around this terminology, let''s examine the definition of each term,
    as outlined by Gerard Meszaros ^([5]) in his *XUnit Test Patterns: Refactoring
    Test Code* book on test patterns.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '为了建立一些共同的基础，以便进行富有成效的讨论，并消除关于这个术语的任何混淆，让我们根据Gerard Meszaros在*《XUnit Test Patterns:
    Refactoring Test Code》*一书中对测试模式的概述，来检查每个术语的定义。'
- en: Stubs and spies!
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: stubs和spies！
- en: A **stub** is the simplest test pattern that we can use in our tests. Stubs
    typically implement a particular interface and don't contain any real logic; they
    just provide fixed answers to calls that are performed through the course of a
    test.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**stub**是我们可以在测试中使用的最简单的测试模式。stubs通常实现特定的接口，不包含任何实际逻辑；它们只是提供固定答案以响应测试过程中进行的调用。'
- en: Let's dissect a short code example that illustrates how we can effectively use
    the concept of stubs for our tests. The `Chapter04/captcha` package implements
    the verification logic behind a CAPTCHA test.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剖析一个简短的代码示例，说明我们如何有效地使用stub的概念进行测试。`Chapter04/captcha`包实现了CAPTCHA测试背后的验证逻辑。
- en: CAPTCHA is a fairly straightforward way to determine whether a system is interacting
    with a human user or another program. This is achieved by displaying a random,
    often noisy, image containing a distorted sequence of letters and numbers and
    then prompting the user to type the text content of the image.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CAPTCHA是一种相当直接的方法，可以确定系统是在与人类用户还是另一个程序交互。这是通过显示一个随机、通常带有噪声的图像，其中包含扭曲的字母和数字序列，然后提示用户输入图像的文本内容来实现的。
- en: 'As a big fan of the SOLID principles, I opted to define two interfaces, `Challenger` and `Prompter`,
    to abstract the CAPTCHA image generation and the user-prompting implementation.
    After all, there is a plethora of different approaches out there for generating
    CAPTCHA images: we could pick a random image from a fixed set of images, generate
    them using a neural network, or perhaps even call out to a third-party image generation
    service. The same could be said about the way we actually prompt our users for
    an answer. This is how the two interfaces are defined:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为SOLID原则的大粉丝，我选择定义两个接口，`Challenger`和`Prompter`，以抽象CAPTCHA图像生成和用户提示的实现。毕竟，有大量的不同方法可以生成CAPTCHA图像：我们可以从一组固定的图像中随机选择一个，使用神经网络生成，或者甚至调用第三方图像生成服务。同样，我们实际上提示用户回答的方式也是如此。以下是这两个接口的定义：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At the end of the day, the actual business logic doesn''t really care how the
    CAPTCHA images or the users'' answers were obtained. All we need to do is fetch
    a challenge, prompt the user, and then perform a simple string comparison operation,
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实际的业务逻辑并不真正关心CAPTCHA图像或用户的答案是如何获得的。我们所需做的就是获取一个挑战，提示用户，然后执行一个简单的字符串比较操作，如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: One interesting, at least in my opinion, aspect of the preceding code is that
    it uses constant-time string comparisons instead of using the built-in equality
    operator for comparing the expected answer and the user's response.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的一个有趣之处，至少在我看来，是它使用常数时间字符串比较，而不是使用内置的相等运算符来比较预期的答案和用户的响应。
- en: Constant-time comparison checks are a common pattern in security-related code
    as it prevents information leaks, which can be exploited by adversaries to perform
    a timing side-channel attack. When executing a timing attack, the attacker provides
    variable-length inputs to a system and then employs statistical analysis to collect
    additional information about the system's implementation based on the time it
    takes to execute a particular action.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 常数时间比较检查是安全相关代码中的一种常见模式，因为它可以防止信息泄露，而信息泄露可能会被对手利用来执行时间侧信道攻击。当执行时间攻击时，攻击者向系统提供可变长度的输入，然后通过统计分析收集关于系统实现的信息，这些信息基于执行特定操作所需的时间。
- en: 'Imagine if, in the preceding CAPTCHA scenario we had used a simple string comparison
    that essentially compares each character and returns false on the *first mismatch*.
    Here''s how an attacker could slowly brute-force the answer via a timing attack:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在前面的 CAPTCHA 场景中，如果我们使用了一个简单的字符串比较，本质上是比较每个字符，并在**第一个不匹配**时返回 false，攻击者会如何通过时间攻击缓慢地暴力破解答案：
- en: Start by providing answers following the `$a` pattern and measuring the time
    it takes to get a response. The `$` symbol is a placeholder for all possible alphanumeric
    characters. In essence, we try combinations such as `aa`, `ba`, and so on.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先按照 `$a` 模式提供答案，并测量获取响应所需的时间。`$` 符号是所有可能的字母数字字符的占位符。本质上，我们尝试组合，如 `aa`、`ba`
    等。
- en: Once we have identified an operation that takes *longer than the rest*, we can
    assume that that particular value of `$` (say, `4`) is the expected first character
    of the CAPTCHA answer! The reason this takes longer is that the string comparison
    code matched the first character and then tried matching the next character instead
    of immediately returning it, like it would if there was a mismatch.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们确定了一个比其他操作**耗时更长**的操作，我们就可以假设那个特定的 `$` 值（比如，`4`）是 CAPTCHA 答案的预期第一个字符！这个操作耗时较长的原因是字符串比较代码匹配了第一个字符，然后尝试匹配下一个字符，而不是立即返回，就像在出现不匹配时那样。
- en: Continue the same process of providing answers but this time using the `4$a` pattern
    and keep extending the pattern until the expected CAPTCHA answer can be recovered.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续提供答案的过程，但这次使用 `4$a` 模式，并不断扩展模式，直到可以恢复预期的 CAPTCHA 答案。
- en: 'In order to test the `ChallengeUser` function, we need to create a stub for
    each of its arguments. This would provide us with complete control over the inputs
    to the comparison business logic. Here''s what the stubs might look like:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `ChallengeUser` 函数，我们需要为它的每个参数创建一个存根。这将使我们能够完全控制比较业务逻辑的输入。以下是一些可能看起来像的存根：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Pretty simple, right? As you can see, the stubs are devoid of any logic; they
    just return a canned answer. With the two stubs in place, we can write two test
    functions that exercise the match/non-match code paths:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？正如你所见，存根没有任何逻辑；它们只是返回一个预设的答案。有了这两个存根，我们可以编写两个测试函数来测试匹配/不匹配代码路径：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have a general understanding of how stubs work, let''s look at
    another useful test pattern: spies! A **spy** is nothing more than a stub that
    keeps a detailed log of all the methods that are invoked on it. For each method
    invocation, the spy records the arguments that were provided by the caller and
    makes them available for inspection by the test code.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对存根的工作原理有了大致的了解，让我们看看另一种有用的测试模式：间谍！一个**间谍**不过是一个记录所有对其调用的方法的详细日志的存根。对于每次方法调用，间谍记录调用者提供的参数，并使它们可供测试代码检查。
- en: 'Surely, when it comes to Go, the most popular spy implementation is the venerable `ResponseRecorder` type,
    which is provided by the `net/http/httptest` package. `ResponseRecorder` implements
    the `http.ResponseWriter` interface and can be used for testing HTTP request handling
    code without the need to spin up an actual HTTP server. However, HTTP server testing
    is not that interesting; let''s take a look at a slightly more engaging example.
    The `Chapter04/chat` package contains a simple chatroom implementation that is
    perfect for applying the spy test pattern. The following is the definition of
    the `Room` type and its constructor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当谈到 Go 语言时，最受欢迎的间谍实现是来自 `net/http/httptest` 包的古老而值得尊敬的 `ResponseRecorder`
    类型。`ResponseRecorder` 实现了 `http.ResponseWriter` 接口，可以用来测试 HTTP 请求处理代码，而无需启动实际的
    HTTP 服务器。然而，HTTP 服务器测试并不那么有趣；让我们看看一个稍微更有趣的例子。`Chapter04/chat` 包含一个简单的聊天室实现，非常适合应用间谍测试模式。以下是对
    `Room` 类型及其构造函数的定义：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, `Room` contains a `Publisher` instance that gets initialized
    by the value that's passed to the `NewRoom` constructor. The other interesting
    public methods that are exposed by the `Room` type (not shown here but available
    in this book's GitHub repo) are `AddUser` and `Broadcast`. The first method adds
    new users to the room, while the latter can be used to broadcast a particular
    message to all the users currently in the room.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Room` 包含一个由 `NewRoom` 构造函数传入的值初始化的 `Publisher` 实例。`Room` 类型公开的其他有趣的方法（这里未展示，但在本书的
    GitHub 仓库中可用）包括 `AddUser` 和 `Broadcast`。第一个方法向房间添加新用户，而后者可以用来向房间内所有当前用户广播特定消息。
- en: 'Before we write our actual testing code, let''s create a spy instance that
    implements the `Publisher` interface and records any published messages:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写实际的测试代码之前，让我们创建一个实现`Publisher`接口的spy实例，并记录任何发布的消息：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding spy implementation, each time the `Publish` method is invoked,
    the stub will append a `{user, message}` tuple to the `published` slice. With
    our spy ready to be used, writing the actual test is a piece of cake:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的spy实现中，每次调用`Publish`方法时，stub都会将一个`{user, message}`元组追加到`published`切片中。当我们的spy准备好使用时，编写实际的测试就变得轻而易举：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This test scenario involves creating a new room, adding some users to it, and
    broadcasting a message to everyone who has joined the room. The test runner's
    task is to verify that the call to `Broadcast` did in fact broadcast the message
    to all the users. We can achieve this by examining the list of messages that have
    been recorded by our injected spy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试场景涉及创建一个新的房间，向其中添加一些用户，并向所有加入房间的用户广播消息。测试运行器的任务是验证对`Broadcast`的调用实际上确实向所有用户广播了消息。我们可以通过检查我们的注入spy记录的消息列表来实现这一点。
- en: Mocks
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocks
- en: You can think of **mocks** as stubs on steroids! Contrary to the fixed behavior
    exhibited by stubs, mocks allow us to specify, in a *declarative*way, not only
    the list of calls that the mock is expected to receive but also their order and
    expected argument values. In addition, mocks allow us to specify different return
    values for each method invocation, depending on the argument tuple provided by
    the method caller.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将**mocks**视为增强版的stubs！与stub展示的固定行为相反，mocks允许我们以*声明性*的方式指定mock期望接收的调用列表，以及它们的顺序和期望的参数值。此外，mocks允许我们根据方法调用者提供的参数元组为每个方法调用指定不同的返回值。
- en: All things considered, mocks are a very powerful primitive at our disposal for
    writing advanced tests. However, building mocks from scratch for every single
    object we want to substitute as part of our tests is quite a tedious task. This
    is why it's often better to use an external tool and code generation to automate
    the creation of the mocks that are needed for our tests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有因素，mocks是我们可用的非常强大的原始工具，用于编写高级测试。然而，为测试中想要替换的每个对象从头开始构建mock是一个相当繁琐的任务。这就是为什么通常更好的做法是使用外部工具和代码生成来自动化创建测试所需的mock。
- en: Introducing gomock
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍gomock
- en: In this section, we will be introducing `gomock` ^([4]), a very popular mocking
    framework for Go that leverages reflection and code generation to automatically
    create mocks based on Go interface definitions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 `gomock` ^([4])，这是一个非常流行的Go语言mocking框架，它利用反射和代码生成自动根据Go接口定义创建mock。
- en: 'The framework and its supporting tools can be installed by running the following
    commands:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架及其支持工具可以通过运行以下命令进行安装：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `mockgen` tool is responsible for analyzing either individual Go files
    or entire packages and generating mocks for all (or specific) interfaces that
    are defined within them. It supports two modes of operation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockgen`工具负责分析单个Go文件或整个包，并为其中定义的所有（或特定）接口生成mock。它支持两种操作模式：'
- en: '**Source code scanning**: We pass a Gi file to `mockgen`, which is then parsed
    in order to detect interface definitions.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码扫描**：我们将Gi文件传递给`mockgen`，然后对其进行解析以检测接口定义。'
- en: '**Reflection-assisted mode**: We pass a package and a list of interfaces to
    `mockgen`. The tool uses the Go reflection package to analyze the structure of
    each interface.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反射辅助模式**：我们将一个包和接口列表传递给`mockgen`。该工具使用Go反射包分析每个接口的结构。'
- en: '`gomock` provides a simple and concise API for specifying the expected behavior
    of mock instances that are created via the `mockgen` tool. To access this API,
    you need to create a new instance of the mock and invoke its oddly-cased `EXPECT` method. `EXPECT` returns
    a special object (a *recorder*, in `gomock` terminology) that provides the means
    for us to declare the behavior of the method calls that are performed against
    the mock.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`gomock`为通过`mockgen`工具创建的mock实例指定预期行为提供了一个简单且简洁的API。要访问此API，你需要创建一个mock的新实例并调用其奇特的`EXPECT`方法。`EXPECT`返回一个特殊对象（在`gomock`术语中称为*recorder*），为我们提供了声明针对mock执行的方法调用行为的方式。'
- en: 'To register a new expectation, we need to do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册新的期望，我们需要执行以下操作：
- en: Declare the name of the method that we expect to be called, along with its arguments.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明我们期望被调用的方法及其参数。
- en: Specify the return value (or values) that the mock should return to the caller
    when it invokes the method with the specified set of arguments.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定当模拟调用带有指定参数集的方法时，模拟应该返回给调用者的返回值（或值）。
- en: Optionally, we need to specify the number of times that the caller is expected
    to invoke the method.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，我们需要指定调用者预期调用的方法次数。
- en: 'To further streamline the creation of tests, `mockgen` populates the returned
    recorder instances with methods whose names match the interfaces that we are trying
    to mock. All we need to do is invoke those methods on the recorder object and
    specify the arguments that the mock expects to receive from the caller as a variadic
    list of `interface{}` values. When defining the expected set of arguments, you
    basically have two options:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步简化测试的创建，`mockgen`将返回的记录器实例填充了与我们要模拟的接口名称匹配的方法。我们只需要在记录器对象上调用这些方法，并将模拟期望从调用者接收到的参数作为`interface{}`值的可变列表指定。当定义预期的参数集时，你基本上有两个选择：
- en: Specify a value whose *type* matches the one from the method signature (for
    example, `foo` if the argument is of the `string` type). `gomock` will only match
    a call to an expectation if the input argument, *value*, is *strictly equal* to
    the value that's specified as part of the expectation.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定一个与方法签名中类型匹配的值（例如，如果参数是`string`类型，则为`foo`）。`gomock`只有在输入参数、*值*严格等于预期中指定的值时，才会匹配到期望的调用。
- en: Provide a value that implements the `gomock.Matcher` interface. In this case,
    `gomock` will delegate the comparison to the matcher itself. This powerful feature
    gives us the flexibility to model any custom test predicate that we can think
    of. `gomock` already defines a few handy built-in matchers that we can use in
    our tests: `Any`, `AssignableToTypeOf`, `Nil`, and `Not`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个实现了`gomock.Matcher`接口的值。在这种情况下，`gomock`将委托比较给匹配器本身。这个强大的功能让我们能够模拟任何可以想到的自定义测试谓词。`gomock`已经定义了一些方便的内置匹配器，我们可以在测试中使用：`Any`、`AssignableToTypeOf`、`Nil`和`Not`。
- en: After specifying the expected method call and its arguments, `gomock` will return
    an expectation object that provides auxiliary methods so that we can configure
    the expected behavior further. For instance, we can use the expectation object's `Return` method
    to define the set of values to be returned to the caller once the expectation
    is matched. It is also important to note that unless we *explicitly* specify the
    expected number of calls to the mocked method, `gomock` will assume that the method
    can only be invoked *o**nce* and will trigger a test failure if the method is
    not invoked at all or is invoked multiple times. If you require more fine-grained
    control over the number of expected invocations, the returned expectation object
    provides the following set of helper methods: `Times`, `MinTimes`, and `MaxTimes`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定了预期的方法调用及其参数后，`gomock`将返回一个期望对象，该对象提供辅助方法，以便我们可以进一步配置预期的行为。例如，我们可以使用期望对象的`Return`方法来定义一旦期望匹配，将返回给调用者的值集。还重要的是要注意，除非我们*明确地*指定期望的模拟方法调用次数，否则`gomock`将假设该方法只能调用一次，如果方法根本未调用或多次调用，将触发测试失败。如果您需要更精细地控制期望调用次数，返回的期望对象提供了以下一组辅助方法：`Times`、`MinTimes`和`MaxTimes`。
- en: In the next two sections, we will analyze an example project and go through
    all the individual steps for writing a complete, mock-based unit test for it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两节中，我们将分析一个示例项目，并逐步讲解如何为它编写一个完整的、基于模拟的单元测试。
- en: Exploring the details of the project we want to write tests for
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索我们想要编写测试的项目细节
- en: 'For the purpose of demonstrating the creation and use of mocks in our code,
    we will be working with the example code from the `Chapter04/dependency` package.
    This package defines a `Collector` type whose purpose is to assemble a set of
    direct and indirect (transitive) dependencies for a given project ID. To make
    things a bit more interesting, let''s assume that each dependency can belong to
    one of the following two categories:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示在我们的代码中创建和使用模拟，我们将使用来自`Chapter04/dependency`包的示例代码。这个包定义了一个`Collector`类型，其目的是为给定的项目ID组装一组直接和间接（传递）依赖。为了使事情更有趣，让我们假设每个依赖项可以属于以下两个类别之一：
- en: A resource that we need to include (for example, an image file) or reserve (for
    example, a block of memory or an amount of disk space)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要包含（例如，一个图像文件）或预留（例如，一块内存或磁盘空间）的资源
- en: Another project with its *own set of dependencies*
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个拥有其*自己依赖集*的项目
- en: 'To obtain the list of *direct* dependencies and their respective types, the
    `Collector` dependency will be performing a series of calls to an external service.
    To ensure that the implementation lends itself to easier testing, we will not
    be working with a concrete client instance for the external service. Instead,
    we will define an interface with the set of required methods for accessing the
    service and have our test code inject a mock that satisfies that interface. Consider
    the following definition for the `API` interface:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取直接依赖及其相应类型的列表，`Collector`依赖将执行一系列调用到外部服务的操作。为了确保实现更容易测试，我们不会与外部服务的具体客户端实例一起工作。相反，我们将定义一个接口，其中包含访问服务所需的方法集，并在我们的测试代码中注入一个满足该接口的模拟。以下是对`API`接口的以下定义：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To create a new `Collector` instance, we need to invoke the `NewCollector`
    constructor (not shown) and provide an API instance as an argument. Then, the
    *unique* set of dependencies for a particular project ID can be obtained via a
    call to the `AllDependencies` method. It''s a pretty short method whose full implementation
    is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的`Collector`实例，我们需要调用`NewCollector`构造函数（未显示）并提供一个API实例作为参数。然后，可以通过调用`AllDependencies`方法来获取特定项目ID的*独特*依赖集。这是一个相当简短的方法，其完整实现如下：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding block of code is nothing more than a **breadth-first search**
    (**BFS**) algorithm in disguise! The `ctx` variable stores an auxiliary structure
    that contains the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块实际上是一个伪装的**广度优先搜索**（BFS）算法！`ctx`变量存储一个辅助结构，其中包含以下内容：
- en: '*A queue* whose entries correspond to the set of dependencies (resources or
    projects) that we haven''t visited yet. As we visit the nodes of the project dependency
    graph, any newly discovered dependencies will be appended to the tail of the queue
    so that they can be visited in a future search loop iteration.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个队列*，其条目对应于我们尚未访问的依赖集（资源或项目）。当我们访问项目依赖图中的节点时，任何新发现的依赖将被追加到队列的末尾，以便在未来的搜索循环迭代中访问。'
- en: The unique set of discovered dependency IDs that are returned to the caller
    once all the entries in the queue have been processed.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦队列中的所有条目都已被处理，就会返回给调用者一组独特的已发现依赖ID。
- en: 'To seed the search, initially, we populate the queue with the `projectID` value
    that was passed in as an argument to the method. With each loop iteration, we
    dequeue an unchecked dependency ID and invoke the `ListDependencies` API call
    to get a list of all its direct dependencies. The obtained list of dependency
    IDs is then passed as input to the `scanProjectDependencies` method, whose role
    is to examine the dependency list and update the contents of the `ctx` variable.
    The method''s implementation is pretty straightforward:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化搜索，最初，我们将传递给方法作为参数的`projectID`值填充到队列中。在每次循环迭代中，我们取出一个未检查的依赖ID，并调用`ListDependencies`
    API调用以获取其所有直接依赖的列表。然后，获取到的依赖ID列表被传递给`scanProjectDependencies`方法，该方法的角色是检查依赖列表并更新`ctx`变量的内容。该方法实现相当直接：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While iterating the dependency list, the implementation automatically skips
    any dependency that has already been visited. On the other hand, new dependency
    IDs are appended to the set of unique dependencies that have been tracked by the
    `ctx` variable via a call to the `AddToDepList` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代依赖列表时，实现会自动跳过任何已经访问过的依赖。另一方面，新的依赖ID通过调用`AddToDepList`方法被追加到`ctx`变量跟踪的唯一依赖集。
- en: As we mentioned previously, if the dependency corresponds to another project,
    we need to *recursively* visit its own dependencies and add them to our set as *transitive*dependencies*.*
    The `DependencyType` method from the `API` interface provides us with the means
    for querying the type of a dependency by its ID. If the dependency does in fact
    point to a *project*, we append it to the tail of the unvisited dependencies queue
    via a call to the `AddToUncheckedList` method. The last step guarantees that the
    dependency will eventually be processed by the search loop inside the `AllDependencies`
    method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，如果依赖对应于另一个项目，我们需要*递归地*访问其自己的依赖并将它们作为*传递性依赖*添加到我们的集合中。`API`接口中的`DependencyType`方法为我们提供了通过其ID查询依赖类型的方式。如果依赖确实指向一个*项目*，我们通过调用`AddToUncheckedList`方法将其追加到未访问依赖队列的末尾。最后一步保证了依赖最终将由`AllDependencies`方法内部的搜索循环处理。
- en: Leveraging gomock to write a unit test for our application
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用gomock编写应用程序的单元测试
- en: 'Now that we are aware of the implementation details of our example project,
    we can go ahead and write a simple, mock-based unit test for it. Before we begin,
    we need to create a mock for the `API` interface. This can be achieved by invoking the `mockgen` tool with
    the following options:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了示例项目的实现细节，我们可以继续编写一个简单的基于模拟的单元测试。在我们开始之前，我们需要为`API`接口创建一个模拟。这可以通过使用以下选项调用`mockgen`工具来实现：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding command does the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令执行以下操作：
- en: Creates a `mock` folder in the `dependency` package
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`dependency`包中创建一个`mock`文件夹
- en: Generates a file called `dependency.go`with the appropriate code for mocking
    the `API` interface and places it in the `mock` folder
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个名为`dependency.go`的文件，其中包含模拟`API`接口的适当代码，并将其放置在`mock`文件夹中
- en: To save you the trouble of having to manually type in the preceding command,
    the `Makefile` in the `Chapter04/dependency` folder includes a predefined target
    for rebuilding the mocks that were used in this example. All you need to do is
    switch to the folder with the example code in it and run `make mocks`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免您手动输入前面的命令，`Chapter04/dependency`文件夹中的`Makefile`包含了一个预定义的目标，用于重建在此示例中使用的模拟。您需要做的只是切换到包含示例代码的文件夹，并运行`make
    mocks`。
- en: 'So far, so good. How can we use the mock in our tests though? The first thing
    we need to do is create a `gomock` *controller* and associate it with the `testing.T` instance
    that gets passed to our test function by the Go standard library. The controller
    instance defines a `Finish` method that our code *must always run before returning
    from the test* (for example, via a *defer* statement). This method checks the
    expectations that were registered on each mock object and automatically fails
    the test if they were not met. Here''s what the preamble of our test function
    would look like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。那么我们如何在测试中使用模拟呢？首先，我们需要创建一个`gomock`控制器并将其与Go标准库通过测试函数传递给我们的`testing.T`实例关联起来。控制器实例定义了一个`Finish`方法，我们的代码必须在返回测试之前始终运行此方法（例如，通过`defer`语句）。此方法检查每个模拟对象上注册的期望，如果未满足，则自动失败测试。以下是我们的测试函数前缀可能的样子：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The purpose of this particular unit test is to verify that a call to the `AllDependencies`
    method with a specific input yields an expected list of dependency IDs. As we
    saw in the previous section, the implementation of the `AllDependencies` method
    uses an externally-provided `API` instance to retrieve information about each
    dependency. Given that our test will inject a mocked API instance into the `Collector`
    dependency, our test code must declare the expected set of calls to the mock.
    Consider the following block of code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此特定单元测试的目的是验证对`AllDependencies`方法的特定输入调用是否产生预期的依赖项ID列表。正如我们在上一节中看到的，`AllDependencies`方法的实现使用外部提供的`API`实例来检索每个依赖项的信息。鉴于我们的测试将向`Collector`依赖项注入模拟的API实例，我们的测试代码必须声明对模拟的预期调用集。考虑以下代码块：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Under normal circumstances, `gomock` would just check that the method call expectations
    are met, *regardless of the order that they were invoked in*. However, if a test
    relies on a sequence of method calls being performed in a particular order, it
    can specify this to `gomock` by invoking the `gomock.InOrder` helper function
    with an ordered list of expectations as arguments. This particular pattern can
    be seen in the preceding code snippet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，`gomock`只会检查方法调用期望是否满足，而不管它们被调用的顺序如何。然而，如果一个测试依赖于一系列方法调用以特定顺序执行，它可以指定这一点给`gomock`，通过使用带有有序期望列表的`gomock.InOrder`辅助函数。这种特定模式可以在前面的代码片段中看到。
- en: 'With the mock expectations in place, we can complete our unit by introducing
    the necessary logic to wire everything together, invoke the `AllDependencies`
    method with the input (`proj0`) that our mock expects, and validate that the returned
    output matches a predefined value (`"proj1", "res1", "res2"`):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好模拟期望后，我们可以通过引入必要的逻辑来连接所有组件，调用`AllDependencies`方法，传入模拟所期望的输入（`proj0`），并验证返回的输出是否与预定义的值（`"proj1",
    "res1", "res2"`）匹配，来完成我们的单元测试：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This concludes our short example about using `gomock` to accelerate the authoring
    of mock-based tests. As a fun learning activity, you can experiment with changing
    the expected output for the preceding test so that the test fails. Then, you can
    work backward and try to figure out how to tweak the mock expectations to make
    the test pass again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于使用 `gomock` 加速基于模拟的测试编写的简短示例。作为一个有趣的学习活动，你可以尝试更改前面测试的预期输出，以便测试失败。然后，你可以逆向工作并尝试找出如何调整模拟期望，以便再次使测试通过。
- en: Fake objects
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪造对象
- en: In a similar fashion to the other test patterns that we have discussed so far, **fake
    objects** also adhere to a specific interface, which allows us to inject them
    into the subject under test. The main difference is that fake objects do, in fact,
    contain a *fully working* implementation whose behavior matches the objects that
    they are meant to substitute.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前讨论的其他测试模式类似，**伪造对象** 也遵循一个特定的接口，这允许我们将它们注入到被测试的主题中。主要区别在于，伪造对象实际上包含一个*完全工作*的实现，其行为与它们打算替代的对象相匹配。
- en: So, what's the catch? Fake object implementations are typically optimized for
    running tests and, as such, they are not meant to be used in production. For example,
    we could provide an in-memory key-value store implementation for our tests, but
    our production deployments would require something with better availability guarantees.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有什么问题吗？伪造对象实现通常是针对运行测试进行优化的，因此它们并不打算在生产环境中使用。例如，我们可以为我们的测试提供一个内存中的键值存储实现，但我们的生产部署需要更好的可用性保证。
- en: To achieve a better understanding of how fake objects work, let's take a look
    at the contents of the `Chapter04/compute` package. This package exports a function
    called `SumOfSquares`, which operates on a slice of 32-bit floating-point values.
    The function squares each element of the slice, adds the results together, and
    returns their sum. Note that we are using a single function purely for demonstration
    purposes; in a real-world scenario, we would compose this function with other
    similar functions to form a compute graph that our implementation would then proceed
    to evaluate.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解伪造对象的工作原理，让我们看看 `Chapter04/compute` 包的内容。这个包导出一个名为 `SumOfSquares` 的函数，它对一个
    32 位浮点数值的切片进行操作。该函数对切片中的每个元素进行平方，将结果相加，并返回它们的总和。请注意，我们在这里使用单个函数纯粹是为了演示目的；在现实世界的场景中，我们会将这个函数与其他类似函数组合，形成一个计算图，然后我们的实现将对其进行评估。
- en: To purposefully add a bit of extra complexity to this particular scenario, let's
    assume that the input slices that are passed to this function typically contain
    a *very large number of values*. It is still possible, of course, to use the CPU
    to calculate the result. Unfortunately, the production service that depends on
    this functionality has a pretty strict time budget, so using the CPU is not an
    option. To this end, we have decided to implement a vectorized solution by offloading
    the work to a GPU.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了故意给这个特定的场景增加一些额外的复杂性，让我们假设传递给这个函数的输入切片通常包含一个非常大的数值数量。当然，仍然可以使用 CPU 来计算结果。不幸的是，依赖于这个功能的实际生产服务有一个相当严格的时间预算，因此使用
    CPU 并不是一个选择。为此，我们决定通过将工作卸载到 GPU 来实现一个矢量化解决方案。
- en: 'The `Device` interface describes the set of operations that can be offloaded
    to the GPU:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Device` 接口描述了可以卸载到 GPU 的操作集：'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Given an object instance that implements `Device`, we can define the `SumOfSquares` function
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个实现了 `Device` 的对象实例，我们可以定义 `SumOfSquares` 函数如下：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Nothing too complicated here... Alas, it wasn't until we started working on
    our tests that we realized that while the compute nodes where we normally run
    our production code do provide beefy GPUs, the same could not be said for *each
    one* of the machines that's used locally by our engineers or the CI environment
    that runs our tests each time we create a new pull request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么太复杂的...唉，直到我们开始编写测试，我们才意识到，虽然我们通常运行生产代码的计算节点确实提供了强大的 GPU，但同样的话并不能适用于我们工程师本地使用的每台机器，或者每次创建新的拉取请求时运行我们的测试的
    CI 环境。
- en: 'Obviously, even though our real workload deals with lengthy inputs, there is
    no strict requirement to do the same within our tests; as we will see in the following
    sections, this is a job for an end-to-end test. Therefore, we can fall back to
    a CPU implementation if a GPU is not available when our tests are running. This
    is an excellent example of where a fake object could help us out. So, let''s start
    by defining a `Device` implementation that uses the CPU for all its calculations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，尽管我们的实际工作负载处理的是长输入，但我们的测试中并没有严格的相同要求；正如我们将在以下部分看到的那样，这是端到端测试的工作。因此，如果我们的测试运行时没有GPU可用，我们可以回退到CPU实现。这是一个很好的例子，说明模拟对象如何帮助我们。那么，让我们首先定义一个使用CPU进行所有计算的`Device`实现：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our test code can then switch between the GPU- or the CPU-based implementation
    on the fly, perhaps by inspecting the value of an environment variable or some
    command-line flag that gets passed as an argument to the test:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的测试代码可以在GPU或CPU基于的实现之间动态切换，可能通过检查环境变量的值或作为测试参数传递的某些命令行标志：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the help of a fake object, we can always run our tests while still offering
    this ability to engineers who do have local access to GPUs to run the tests using
    the GPU-based implementation. Success!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个模拟对象，我们可以在仍然提供这种能力的同时运行我们的测试，让那些有本地访问GPU的工程师使用基于GPU的实现来运行测试。成功！
- en: Black-box versus white-box testing for Go packages – an example
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑盒测试与白盒测试在Go包中的应用——一个示例
- en: Black- and white-box testing are two different approaches to authoring unit
    tests. Each approach has its own set of merits and goals. Consequently, we shouldn't
    treat them as competing approaches but rather as one complementing the other.
    So, what is the major difference between these two types of tests?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试和白盒测试是编写单元测试的两种不同方法。每种方法都有其自身的优点和目标。因此，我们不应将它们视为相互竞争的方法，而应将它们视为相互补充。那么，这两种测试类型之间主要的区别是什么？
- en: Black-box testing works under the assumption that the underlying implementation
    details of the package that we test, also known as the **subject under test** (**SUT**),
    are totally opaque (hence the name black-box) to us, the tester. As a result,
    we can only test the **public interface** or behavior of a particular package
    and make sure it adheres to its advertised contract.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试是在假设我们测试的包的底层实现细节（也称为**被测试对象**（**SUT**））对我们，即测试者，是完全透明的（因此得名黑盒）的情况下进行的。结果，我们只能测试特定包的**公共接口**或行为，并确保它遵守其宣传的合同。
- en: On the other hand, white-box testing assumes that we have *prior* knowledge
    of the implementation details of a particular package. This allows the tester
    to either craft each test so that it exercises a particular code path within the
    package or to directly test the package's internal implementation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，白盒测试假设我们事先了解特定包的实现细节。这允许测试者要么为每个测试构建，以便在包内执行特定的代码路径，要么直接测试包的内部实现。
- en: To understand the difference between these two approaches, let's take a look
    at a short example. The `Chapter04/retail` package implements a *facade* called `PriceCalculator`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这两种方法之间的区别，让我们看看一个简短的例子。`Chapter04/retail`包实现了一个名为`PriceCalculator`的**外观**。
- en: A facade is a software design pattern that abstracts the complexity of one or
    more software components behind a simple interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 外观是一种软件设计模式，它通过一个简单的接口抽象了一个或多个软件组件的复杂性。
- en: In the context of microservice-based design, the facade pattern allows us to
    transparently compose or aggregate data across multiple, specialized microservices
    while providing a simple API for the facade clients to access it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的设计背景下，外观模式允许我们透明地组合或聚合多个、专业的微服务中的数据，同时为外观客户端提供一个简单的API来访问它。
- en: In this particular scenario, the facade receives a UUID representing an item
    and a date representing the period we are interested in as input. Then, it communicates
    with two backend microservices to retrieve information about the item's price
    and the VAT rate that was applied on that particular date. Finally, it returns
    the VAT-inclusive price for the item to the facade's client.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的场景中，外观接收一个表示项目的UUID和一个表示我们感兴趣的日期的日期作为输入。然后，它与两个后端微服务通信，以检索有关项目价格和特定日期应用的增值税率的详细信息。最后，它将包含增值税的项目价格返回给外观的客户端。
- en: The services behind the facade
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观背后的服务
- en: Before we dive deeper into the inner workings of the price calculator, let's
    spend a bit of time examining how the two microservice dependencies work; after
    all, we will need this information to write our tests.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨价格计算器的内部工作原理之前，让我们花点时间检查这两个微服务依赖项是如何工作的；毕竟，我们将需要这些信息来编写我们的测试。
- en: 'The `price` microservice provides a REST endpoint for retrieving an item''s
    published price on a particular date. The service responds with a JSON payload
    that looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`price` 微服务提供了一个用于检索特定日期某项商品发布价格的 REST 端点。该服务以类似以下的 JSON 有效负载响应：'
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second microservice in this example is called `vat` and is also RESTful.
    It exposes an endpoint for retrieving the VAT rate that was applicable on a particular
    date. The service responds with a JSON payload as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中的第二个微服务被称为 `vat`，它也是 RESTful 的。它提供了一个用于检索特定日期适用的增值税率的端点。该服务以以下 JSON 有效负载响应：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the returned JSON payload is quite simple and it would be trivial
    for our test code to mock it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，返回的 JSON 有效负载非常简单，因此我们的测试代码模拟它将是微不足道的。
- en: Writing black-box tests
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写黑盒测试
- en: For the purpose of writing our black-box tests, we will start by examining the *public *interface
    of the `retail` package. A quick browse of the `retail.go` file reveals a `NewPriceCalculator` function
    that receives the URLs to the `price` and `vat` services as arguments and returns
    a `PriceCalculator` instance. The calculator instance can be used to obtain an
    item's VAT-inclusive price by invoking the `PriceForItem` method and passing the
    item's UUID as an argument. On the other hand, if we are interested in obtaining
    a VAT-inclusive item price for a particular date in the past, we can invoke the `PriceForItemAtDate` method,
    which also accepts a time period argument.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写我们的黑盒测试，我们将首先检查 `retail` 包的 *公共* 接口。快速浏览 `retail.go` 文件揭示了 `NewPriceCalculator`
    函数，该函数接收 `price` 和 `vat` 服务的 URL 作为参数，并返回一个 `PriceCalculator` 实例。计算器实例可以通过调用 `PriceForItem`
    方法并传递商品的 UUID 作为参数来获取商品的增值税包含价格。另一方面，如果我们对获取过去特定日期的增值税包含商品价格感兴趣，我们可以调用 `PriceForItemAtDate`
    方法，该方法也接受一个时间段参数。
- en: The black-box tests will live *in a separate package* with the name `retail_test`.
    The `$PACKAGE_test` naming convention is, more or less, the standard way for doing
    black-box testing as the name itself alludes to the package being tested while
    at the same time preventing our test code from accessing the internals of the
    package under test.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试将存在于名为 `retail_test` 的单独包中。`$PACKAGE_test` 命名约定，或多或少，是进行黑盒测试的标准方式，因为其名称本身暗示了正在测试的包，同时防止我们的测试代码访问正在测试的包的内部。
- en: 'One caveat of black-box testing is that we need to mock/stub any external objects
    and/or services that the tested code depends on. In this particular case, we need
    to provide stubs for the `price` and `vat` services. Fortunately, the `net/http/httptest` package,
    which ships with the Go standard library provides a convenient helper for spinning
    up a local HTTPS server using random, unused ports. Since we need to spin up two
    servers for our tests, let''s create a small helper function to do exactly that:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试的一个缺点是我们需要模拟/存根任何测试代码所依赖的外部对象和/或服务。在这种情况下，我们需要为 `price` 和 `vat` 服务提供存根。幸运的是，与
    Go 标准库一起提供的 `net/http/httptest` 包提供了一个方便的辅助函数，用于使用随机、未使用的端口启动本地 HTTPS 服务器。由于我们需要为我们的测试启动两个服务器，让我们创建一个小的辅助函数来完成这项工作：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Nothing too complicated here; the `spinUpTestServer` function receives a map
    with the expected response''s content and returns a server (which our test code
    needs to explicitly close) that always responds with the response payload formatted
    in JSON. With this helper function in place, setting up the stubs for our services
    becomes really easy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么太复杂的；`spinUpTestServer` 函数接收一个包含预期响应内容的映射，并返回一个服务器（我们的测试代码需要显式关闭），该服务器始终以
    JSON 格式响应有效负载。有了这个辅助函数，设置我们服务的存根变得非常容易：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, all we need to do now is call the `NewPriceCalculator` constructor and
    pass the addresses of the two fake servers. Hold on a minute! If those servers
    always listen on a random port, how do we know which addresses to pass to the
    constructor? One particularly convenient feature of the `Server` implementation
    that''s provided by the `httptest` package is that it exposes the endpoint where
    the server is listening for incoming connections via a public attribute called `URL`.
    Here''s what the rest of our black-box test would look like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在需要做的就是调用`NewPriceCalculator`构造函数并传递两个假服务器的地址。等等！如果这些服务器总是监听随机端口，我们如何知道要将哪些地址传递给构造函数？`httptest`包提供的`Server`实现的一个特别方便的特性是它通过一个名为`URL`的公共属性公开服务器监听传入连接的端点。以下是我们的黑盒测试其余部分的样子：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we mentioned previously, the preceding code snippet lives in a different
    package, so our tests must import the package under test and access its public
    contents using the `retail` selector.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，前面的代码片段位于不同的包中，因此我们的测试必须导入测试包并使用`retail`选择器访问其公共内容。
- en: 'We could add a few more tests, for example, to validate the `PriceForItem` behavior
    when one or both of the services return an error, but that''s as far as we can
    test using black-box testing alone! Let''s run our test and see what sort of coverage
    we can get:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一些额外的测试，例如，验证当其中一个或两个服务返回错误时`PriceForItem`的行为，但仅使用黑盒测试我们就无法测试到这里！让我们运行我们的测试并看看我们能获得什么样的覆盖率：
- en: '![](img/3d8416ee-3964-412c-a36d-c15033cb4867.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d8416ee-3964-412c-a36d-c15033cb4867.png)'
- en: 'Figure 1: Running just the black-box tests'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：仅运行黑盒测试
- en: Not bad at all! However, if we need to boost our test coverage metrics further,
    we'll need to invest some time and come up with some white-box tests.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这点不错！然而，如果我们需要进一步提高测试覆盖率指标，我们需要投入一些时间并想出一些白盒测试。
- en: Boosting code coverage via white-box tests
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过白盒测试提高代码覆盖率
- en: One major difference compared to the tests we wrote in the previous section
    is that the new set of tests will live in the *same* package as the package we
    are testing. To differentiate from the black-box tests that we authored previously
    and hint to other engineers perusing the test code that these are internal tests,
    we will place the new tests in a file named `retail_internal_test.go`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一节中编写的测试相比，一个主要的不同之处在于新的一组测试将位于我们正在测试的包的**同一**包中。为了区分我们之前编写的黑盒测试并提示其他工程师查看测试代码，我们将新测试放在一个名为`retail_internal_test.go`的文件中。
- en: 'Now, it''s time to pull the curtain back and examine the implementation details
    of the `retail` package! The public API of the package is always a good place
    to begin our exploratory work. An effective strategy would be to identify each
    exported function and then (mentally) follow its call-graph to locate other candidate
    functions/methods that we can exercise via our white-box tests. In the unlikely
    case that the package does not export any functions, we can shift our attention
    to other exported symbols, such as structs or interfaces. For instance, here is
    the definition of the `PriceCalculator` struct from the `retail` package:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候揭开`retail`包的实现细节了！包的公共API始终是我们探索工作的好起点。一个有效的策略是识别每个导出的函数，然后（在心中）跟随其调用图来定位其他候选函数/方法，我们可以通过我们的白盒测试来执行它们。在不太可能的情况下，如果包没有导出任何函数，我们可以将注意力转移到其他导出符号上，例如结构体或接口。例如，以下是`retail`包中`PriceCalculator`结构体的定义：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we can see, the struct contains two private fields of the `svcCaller` type
    whose names clearly indicate they are somehow linked to the two services that
    the facade needs to call out to. If we keep browsing through the code, we will
    discover that `svcCaller` is actually an interface:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该结构体包含两个`svcCaller`类型的私有字段，其名称清楚地表明它们以某种方式与门面需要调用的两个服务相关联。如果我们继续浏览代码，我们将发现`svcCaller`实际上是一个接口：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Call` method receives a map of request parameters and returns a response
    stream as an `io.ReadCloser`. From the perspective of a test writer, the use of
    such an abstraction should make us quite happy since it provides us with an easy
    avenue for mocking the actual calls to the two services!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Call`方法接收一个请求参数映射并返回一个响应流作为`io.ReadCloser`。从测试编写者的角度来看，这种抽象的使用应该让我们感到非常高兴，因为它为我们提供了轻松模拟对两个实际服务调用的一条途径！'
- en: 'As we saw in the previous section, the public API exposed by the `PriceCalculator` type
    is composed of two methods:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节中看到的，`PriceCalculator`类型公开的公共API由两个方法组成：
- en: '`PriceForItem`, which returns the price of an item at this point in time'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PriceForItem`，它返回特定时间点的物品价格'
- en: '`PriceForItemAtDate`, which returns the price of an item at a particular point
    intime'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PriceForItemAtDate`，它返回特定时间点的物品价格'
- en: 'Since the `PriceForItem` method is a simple wrapper that calls `PriceForItemAtDate` with
    the current date/time as an argument, we will focus our analysis on the latter.
    The implementation of `PriceForItemAtDate` is presented as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PriceForItem`方法是一个简单的包装器，它使用当前日期/时间作为参数调用`PriceForItemAtDate`，我们将重点关注后者。`PriceForItemAtDate`的实现如下所示：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code block makes use of a helper called `callService` to send
    out a request to the `price` and `vat` services and unpack their responses into
    the `priceRes` and `vatRes` variables. To gain a clearer understanding of what
    happens under the hood, let''s take a quick peek into the implementation of `callService`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码块使用了名为`callService`的辅助函数来向`price`和`vat`服务发送请求，并将它们的响应解包到`priceRes`和`vatRes`变量中。为了更清楚地了解底层发生了什么，让我们快速查看`callService`的实现：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `callService` method implementation is pretty straightforward. All it does
    is invoke the `Call` method on the provided `svcCaller` instance, treats the returned
    output as a JSON stream, and attempts to unmarshal it into the `res` argument
    that's provided by the caller.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`callService`方法实现相当简单。它所做的只是调用提供的`svcCaller`实例上的`Call`方法，将返回的输出作为JSON流处理，并尝试将其反序列化到调用者提供的`res`参数中。'
- en: Now, let's go back to the implementation of the `PriceForItemAtDate` method.
    Assuming that no error occurred while contacting the remote services, their individual responses
    are passed as arguments to the `vatInclusivePrice` helper function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`PriceForItemAtDate`方法的实现。假设在联系远程服务时没有发生错误，它们的个别响应作为参数传递给`vatInclusivePrice`辅助函数。
- en: 'As you can probably tell by its name, it implements the business logic of applying
    VAT rates to prices. Keeping the business logic separate from the code that is
    responsible for talking to other services is not only a good indicator of a well-thought-out
    design but it also makes our test-writing job easier. Let''s add a small table-driven
    test to validate the business logic:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从其名称中看出，它实现了将增值税率应用于价格的业务逻辑。将业务逻辑与负责与其他服务通信的代码分开不仅是一个良好设计的良好指标，而且也使我们的测试编写工作更容易。让我们添加一个小型的表格驱动测试来验证业务逻辑：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With that test in place, the next thing we want to test is `PriceForItem`. To
    do that, we need to somehow control access to the external services. Although
    we will be using stubs for simplicity, we could also use any of the other test
    patterns that we discussed in the previous section. Here is a stub that implements
    the same approach as the test server from our black-box tests but without the
    need to actually spin up a server!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试到位后，接下来我们想要测试的是`PriceForItem`。为了做到这一点，我们需要以某种方式控制对外部服务的访问。虽然我们将使用存根来简化，但我们也可以使用之前章节中讨论的任何其他测试模式。这里有一个存根，它实现了与我们的黑盒测试中的测试服务器相同的策略，但无需实际启动服务器！
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using the preceding stub definition, let''s add a test for the `PriceForItem` method''s
    happy path:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的存根定义，让我们为`PriceForItem`方法的正常路径添加一个测试：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Of course, our tests wouldn''t really be complete without explicitly testing
    what happens when a required dependency fails! For this, we need yet another stub,
    which always returns an error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有明确测试当必需的依赖项失败时会发生什么，我们的测试就不会真正完整！为此，我们需要另一个存根，它总是返回一个错误：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With this stub implementation, we can test how the `PriceCalculator` method behaves
    when particular *classes of errors* occur. For example, here is a test that simulates
    a 404 response from the `vat` service to indicate to the caller that no VAT rate
    data is available for the specified time period:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个存根实现，我们可以测试当特定*错误类别*发生时`PriceCalculator`方法的行为。例如，这里有一个模拟`vat`服务返回404响应的测试，以向调用者指示在指定时间段内没有可用的增值税率数据：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s run the black- and white-box tests together to check how the total coverage
    has changed now that we''ve introduced the new tests:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起运行黑盒和白盒测试，以检查在引入新测试后总覆盖率如何变化：
- en: '![](img/5f2ba14b-73df-4fe4-b95f-f14bcdfcc3ba.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f2ba14b-73df-4fe4-b95f-f14bcdfcc3ba.png)'
- en: Figure 2: Running both black- and white-box tests
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：运行黑盒和白盒测试
- en: While the ratio of white-box and black-box tests in the Go standard library's
    sources seems to strongly favor white-box testing, this should not be construed
    as a hint that you shouldn't be writing black-box tests! Black-box tests certainly
    have their place and are very useful when you're attempting to replicate the exact
    set of conditions and inputs that trigger the particular bug that you are trying
    to track down. What's more, as we will see in the upcoming sections, black-box
    tests can often serve as templates for constructing another class of tests, commonly
    referred to as *integration tests*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Go标准库的源代码中，白盒测试和黑盒测试的比例似乎强烈倾向于白盒测试，但这并不意味着你不应该编写黑盒测试！黑盒测试当然有自己的位置，当你试图复制触发特定错误的特定条件和输入集时，它们非常有用。更重要的是，正如我们将在接下来的章节中看到的，黑盒测试通常可以作为构建另一类测试的模板，这类测试通常被称为*集成测试*。
- en: Table-driven tests versus subtests
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格驱动测试与子测试
- en: In this section, we will be comparing two slightly different approaches when
    it comes to grouping and executing multiple test cases together. These two approaches,
    namely table-driven tests and subtests, can easily be implemented using the basic
    primitives provided by Go's built-in `testing` package. For each approach, we
    will discuss the pros and cons and eventually outline a strategy to fuse the two
    approaches together so that we can get the best of both worlds.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较两种不同的方法，用于分组和执行多个测试用例。这两种方法，即表格驱动测试和子测试，可以很容易地使用Go内置的`testing`包提供的基本原语来实现。对于每种方法，我们将讨论其优缺点，并最终概述一种策略，将两种方法结合起来，以便我们可以取长补短。
- en: Table-driven tests
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格驱动测试
- en: 'Table-driven tests are a quite compact and rather terse way to efficiently
    test the behavior of a particular piece of code in a host of different scenarios.
    The format of a typical table-driven test consists of two distinct parts: the
    test case definitions and the test-runner code.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 表格驱动测试是一种相当紧凑且相当简洁的方式来高效地测试特定代码片段在不同场景下的行为。典型的表格驱动测试的格式由两个不同的部分组成：测试用例定义和测试运行代码。
- en: 'To demonstrate this, let''s examine a possible implementation of the infamous
    `FizzBuzz` test: given a number, *N*, the `FizzBuzz` implementation is expected
    to return `Fizz` if the number is evenly divisible by 3, `Buzz` if the number
    is evenly divisible by 5, `FizzBuzz` if the number is evenly divisible by *both* 3
    and 5, or the number itself in all other cases. Here is a listing from the `Chapter04/table-driven/fizzbuzz.go` file,
    which contains the implementation we will be working with:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们考察一个著名的`FizzBuzz`测试的实现：给定一个数字N，`FizzBuzz`实现预期在数字能被3整除时返回`Fizz`，在数字能被5整除时返回`Buzz`，在数字能被3和5同时整除时返回`FizzBuzz`，在其他所有情况下返回该数字本身。以下是从`Chapter04/table-driven/fizzbuzz.go`文件中的列表，其中包含我们将要使用到的实现：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the majority of cases, test scenarios will only be accessed by a single
    test function. With that in mind, a good strategy would be to encapsulate the
    scenario list inside the test function with the help of a pretty nifty Go feature:
    anonymous structs. Here is how you would go about defining the struct that contains
    the scenarios and a scenario list using a single block of code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，测试场景将只被一个测试函数访问。考虑到这一点，一个很好的策略是使用Go的一个非常酷的特性：匿名结构体，将场景列表封装在测试函数中。以下是如何使用单块代码定义包含场景和场景列表的结构体的方法：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code snippet, you may have noticed that I included a description
    for each test case. This is more of a personal preference, but in my opinion,
    it makes the test code more pleasant to the eyes and, more importantly, helps
    us easily locate the specs for failing test cases as opposed to visually scanning
    the entire list looking for the N^([th]) scenario that corresponds to a failed
    test. Granted, either approach would be efficient for the *preceding* example
    where every test case is neatly laid out in a single line, but think how much
    more difficult things would be if each spec block contained nested objects and
    thus each spec was defined using a variable number of lines.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可能已经注意到我为每个测试用例都包含了一个描述。这更多的是一种个人偏好，但在我看来，这使测试代码看起来更令人愉悦，更重要的是，它帮助我们轻松地定位失败的测试用例的规格，而不是在视觉上扫描整个列表寻找与失败的N^(th)场景相对应的场景。当然，对于前面那个每个测试用例都整齐地放在一行中的例子，任何一种方法都会很有效，但想想如果每个规格块都包含嵌套对象，并且每个规格都使用不同数量的行来定义，事情会变得多么困难。
- en: 'Once we have written down our specs, making sure that we have also included
    any *edge* cases that we can think of, it is time to run the test. This is actually
    the easy part! All we need to do is iterate the list of specs, invoke the subject
    under test with the input(s) provided by each spec, and verify that the outputs
    conform to the expected values:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们写下了我们的规范，确保我们也包括了我们可以想到的所有任何*边缘*案例，就是时候运行测试了。这实际上是容易的部分！我们只需要遍历规范列表，使用每个规范提供的输入调用被测试的主题，并验证输出是否符合预期值：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'One important aspect of the preceding test-runner implementation is that even
    when a test case fails, we don''t *immediately* abort the test by invoking any
    of the `t.Fail/FailNow` or `t.Fatal/f` helpers, but rather exhaust our list of
    test cases. This is intentional as it allows us to see an overview of all the
    failing cases in one go. If we were to run the preceding code, we would get the
    following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前述测试运行器实现的一个重要方面是，即使测试案例失败，我们也不会通过调用任何`t.Fail/FailNow`或`t.Fatal/f`辅助函数来立即终止测试，而是耗尽我们的测试案例列表。这是故意的，因为它允许我们一次性查看所有失败的案例。如果我们运行前面的代码，我们会得到以下输出：
- en: '![](img/75062476-12f6-4b38-93e9-280da38a2930.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75062476-12f6-4b38-93e9-280da38a2930.png)'
- en: Figure 3: Example of a failing case in a table-driven test
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：表格驱动测试中失败案例的示例
- en: One unfortunate caveat of this approach is that we cannot request for the `go
    test` command to explicitly target a specific test case. We can always ask `go
    test` to only run a *specific test function* in isolation (for example, `go test
    -run TestFizzBuzzTableDriven`), but not to *only* run the failing test case number
    3 within that test function; we need to sequentially test all the cases every
    single time! Being able to target specific test cases would be a time-saver if
    our test-runner code was complex and each test case took quite a bit of time to
    execute.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个不幸的缺点是我们不能请求`go test`命令明确地针对一个特定的测试案例。我们可以始终请求`go test`只独立运行一个*特定的测试函数*（例如，`go
    test -run TestFizzBuzzTableDriven`），但不能只运行该测试函数中的失败测试案例编号3；我们需要每次都顺序测试所有案例！如果我们的测试运行器代码复杂，每个测试案例执行时间较长，能够针对特定的测试案例将节省大量时间。
- en: Subtests
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子测试
- en: With the release of Go 1.7, the built-in *testing* package gained support for
    running subtests. Subtests are nothing more than a hierarchy of test functions
    that are executed sequentially. This hierarchical structuring of the test code
    is akin to the notion of a test suite that you may have been exposed to in other
    programming languages.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Go 1.7 的发布，内置的 *testing* 包增加了运行子测试的支持。子测试不过是一系列按顺序执行的测试函数的层次结构。这种测试代码的层次结构类似于你在其他编程语言中可能接触到的测试套件的概念。
- en: 'So, how does it work? The `testing.T` type has been augmented with a new method
    called `Run` that has the following signature:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的呢？`testing.T`类型已经增加了一个名为`Run`的新方法，它具有以下签名：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This new method provides a new mechanism for spawning subtests that will run
    in isolation while still retaining the ability to use the parent test function
    to perform any required setup and teardown steps.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新方法提供了一种生成子测试的新机制，这些子测试将在独立运行的同时，仍然保留使用父测试函数执行任何必需的设置和清理步骤的能力。
- en: 'As you might expect, since each subtest function receives its own `testing.T` instance
    argument, it can, in turn, spawn additional subtests that are nested underneath
    it. Here''s what a typical test would look like when following this approach:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，由于每个子测试函数都接收自己的`testing.T`实例参数，它可以反过来生成附加的子测试，这些子测试位于其下方。以下是按照这种方法的一个典型测试的示例：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: What's more, each subtest gets its own unique name, which is generated by concatenating
    the names of all its ancestor test functions and the description string that gets
    passed to the invocation of `Run`. This makes it easy to target any subtest in
    a particular hierarchy tree by specifying its name to the `-run` argument when
    invoking `go test`. For example, in the preceding code snippet, we can target `test2` by
    running `go test -run TestXYZ/test2`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，每个子测试都有自己的唯一名称，该名称通过连接所有祖先测试函数的名称和传递给`Run`调用的描述字符串生成。这使得通过在调用`go test`时指定名称，可以轻松地针对特定层次结构树中的任何子测试。例如，在前面代码片段中，我们可以通过运行`go
    test -run TestXYZ/test2`来针对`test2`。
- en: One disadvantage of subtests compared to their test-driven brethren is that
    they are defined in a much more verbose way. This could prove to be a bit of a
    challenge if we need to define a large number of test scenarios.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与其测试驱动的兄弟相比，子测试的一个缺点是它们定义得更加冗长。如果我们需要定义大量测试场景，这可能会带来一些挑战。
- en: The best of both worlds
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两者之最佳
- en: 'At the end of the day, nothing precludes us from combining these two approaches
    into a hybrid approach that gives us the best of both worlds: the terseness of
    table-driven tests and the selective targeting of subtests.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，没有什么阻止我们将这两种方法结合起来，形成一个混合方法，它结合了两种方法的优点：表格驱动测试的简洁性和子测试的选择性定位。
- en: 'To achieve this, we need to define our table-driven specs, just like we did
    before. Following that, we iterate the spec list and spawn a subtest for each
    test case. Here''s how we could adapt our `FizzBuzz` tests so that they follow
    this pattern:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要定义我们的表格驱动规范，就像我们之前做的那样。然后，我们遍历规范列表，并为每个测试案例启动一个子测试。以下是如何调整我们的`FizzBuzz`测试以遵循此模式的方法：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s say we wanted to only run the second test case. We can easily achieve
    this by passing its fully qualified name as the value of the `-run` flag when
    running `go test`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想运行第二个测试案例。我们可以通过在运行`go test`时将它的完全限定名称作为`-run`标志的值来轻松实现这一点：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using third-party testing frameworks
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方测试框架
- en: 'One great thing about testing Go code is that the language itself comes with
    batteries included: it ships with a built-in, albeit minimalistic, framework for
    authoring and running tests.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Go代码的一个好处是，该语言本身自带电池：它附带了一个内置的、尽管是简约的、用于编写和运行测试的框架。
- en: From a purist's perspective, that's all that you need to be up and running!
    The built-in `testing` package provides all the required mechanisms for running,
    skipping, or failing tests. All the software engineer needs to do is set up the
    required test dependencies and write the appropriate predicates for each test.
    One caveat of using the `testing` package is that it does not provide any of the
    more sophisticated test primitives, such as assertions or mocks, that you may
    be used to if you've come from a Java, Ruby, or Python background. Of course,
    nothing prevents you from implementing these yourself!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹主义者的角度来看，这就是你需要的一切来启动运行！内置的`testing`包提供了运行、跳过或失败测试所需的所有机制。软件工程师需要做的只是设置所需的测试依赖项，并为每个测试编写适当的谓词。使用`testing`包的一个缺点是它不提供你从Java、Ruby或Python背景可能习惯的更复杂的测试原语，如断言或模拟。当然，没有什么阻止你自己实现这些！
- en: Alternatively, if importing additional test dependencies is something you don't
    object to, you can make use of one of the several readily available third-party
    packages that provide all these missing features. Since a full, detailed listing
    of all third-party test packages is outside of the scope of this book, we will
    focus our attention on one of the most popular test framework packages out there: `gocheck`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你不反对导入额外的测试依赖项，你可以使用几个现成的第三方包之一，这些包提供了所有这些缺失的功能。由于本书的范围不包括所有第三方测试包的完整、详细列表，我们将关注其中最受欢迎的测试框架包之一：`gocheck`。
- en: The `gocheck` package ^([3]) can be installed by running `go get gopkg.in/check.v1`.
    It builds on top of the standard Go `testing` package and provides support for
    organizing tests into test suites. Each suite is defined using a regular Go struct
    that you can also exploit so that it stores any additional bits of information
    that might be needed by your tests.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`gocheck`包^([3])可以通过运行`go get gopkg.in/check.v1`来安装。它建立在标准的Go `testing`包之上，并为将测试组织成测试套件提供支持。每个套件都是使用一个常规的Go结构定义的，你也可以利用它来存储测试可能需要的任何额外信息。'
- en: 'In order to run each test suite as part of your tests, you need to register
    it with `gocheck` and hook `gocheck` to the Go testing package. The following
    is a short example of how to do that:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将每个测试套件作为测试的一部分运行，你需要将其注册到`gocheck`中，并将`gocheck`钩子连接到Go测试包。以下是一个简短的示例，说明如何做到这一点：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you would expect of any framework that supports test suites, `gocheck` allows
    you to optionally specify setup and teardown methods for both the suite and each
    test by defining any of the following methods on the suite type:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，任何支持测试套件的框架都允许你通过在套件类型上定义以下任何方法，为套件和每个测试可选地指定设置和清理方法：
- en: '`SetUpSuite(c *check.C)`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetUpSuite(c *check.C)`'
- en: '`SetUpTest(c *check.C)`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetUpTest(c *check.C)`'
- en: '`TearDownTest(c *check.C)`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TearDownTest(c *check.C)`'
- en: '`TearDownSuite(c *check.C)`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TearDownSuite(c *check.C)`'
- en: 'Likewise, any suite method matching the `TestXYZ(c *check.C)` pattern will
    be treated as a test and executed when the suit runs. The `check.C` type gives
    you access to some useful methods, such as the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，任何匹配 `TestXYZ(c *check.C)` 模式的 suite 方法都将被视为测试，并在 suite 运行时执行。`check.C` 类型提供了访问一些有用方法的能力，例如以下内容：
- en: '`Log/Logf`: Prints a message to the test log'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log/Logf`: 将消息打印到测试日志'
- en: '`MkDir`: Creates a temporary folder that is automatically removed after the *suite* finishes
    running'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MkDir`: 创建一个在 *suite* 运行完成后自动删除的临时文件夹'
- en: '`Succeed/SucceedNow/Fail/FailNow/Fatal/Fatalf`: Controls the outcome of a running
    test'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Succeed/SucceedNow/Fail/FailNow/Fatal/Fatalf`: 控制正在运行的测试的结果'
- en: '`Assert`: Fails the test if the specified predicate condition isn''t met'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert`: 如果指定的谓词条件不满足，则测试失败'
- en: By *default*, `gocheck` buffers all its output and only emits it when a test
    fails. While this helps cut down the noise and speeds up the execution of chatty
    tests, you might prefer to see all the output. Fortunately, `gocheck` supports
    two levels of verbosity that can be controlled via command-line flags that are
    passed to the `go test` invocation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`gocheck` 缓存所有输出，仅在测试失败时才发出。虽然这有助于减少噪音并加快嘈杂测试的执行速度，但您可能希望看到所有输出。幸运的是，`gocheck`
    支持两个级别的详细程度，可以通过传递给 `go test` 调用的命令行标志来控制。
- en: To force `gocheck` to output its buffered debug log for all tests, regardless
    of their pass/fail status, you can run `go test` with the `-check.v` argument.
    The fact that `gocheck` prefers to buffer all the logging output is less than
    ideal when you're trying to figure out why one of your tests hangs. For such situations,
    you can dial up the verbosity and disable buffering by running `gocheck` with
    the `-check.vv` argument. Finally, if you wish to run a particular test from a
    test suite (akin to `go test -run XYZ`), you can run `gocheck` with `-check.f
    XYZ`, where `XYZ` is a regular expression matching the names of the test(s) you
    wish to run.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制 `gocheck` 为所有测试输出缓存的调试日志，无论其通过/失败状态如何，您可以在 `go test` 中使用 `-check.v` 参数。当您试图找出为什么某个测试挂起时，`gocheck`
    倾向于缓存所有日志输出并不是最佳选择。在这种情况下，您可以通过使用 `-check.vv` 参数来提高详细程度并禁用缓存。最后，如果您希望从测试套件中运行特定的测试（类似于
    `go test -run XYZ`），您可以使用 `-check.f XYZ` 运行 `gocheck`，其中 `XYZ` 是匹配您希望运行的测试（s）名称的正则表达式。
- en: 'While we mentioned that the `check.C` object provides an `Assert` method, we
    haven''t really gone into any detail on how it works or how the assertion predicates
    are defined. The signature of `Assert` is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们提到了 `check.C` 对象提供了一个 `Assert` 方法，但我们并没有深入探讨其工作原理或断言谓词是如何定义的。`Assert` 方法的签名如下：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The following table contains a list of useful `Checker` implementations provided
    by `gocheck` that you can use to write your test assertions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下表包含由 `gocheck` 提供的实用 `Checker` 实现列表，您可以使用它来编写测试断言。
- en: '| **Checker** | **Description** | **Example** |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| **Checker** | **描述** | **示例** |'
- en: '| `Equals` | Check for equality | `c.Assert(res, check.Equals, 42)` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `Equals` | 检查相等性 | `c.Assert(res, check.Equals, 42)` |'
- en: '| `DeepEquals` | Check interfaces, slices, and others for equality | `c.Assert(res,
    check.DeepEquals, []string{"hello", "world"})` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `DeepEquals` | 检查接口、切片和其他对象是否相等 | `c.Assert(res, check.DeepEquals, []string{"hello",
    "world"})` |'
- en: '| `IsNil` | Check if the value is nil | `c.Assert(err, check.IsNil)` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `IsNil` | 检查值是否为 nil | `c.Assert(err, check.IsNil)` |'
- en: '| `HasLen` | Check the length of the slice/map/channel/strings | `c.Assert(list,
    check.HasLen, 2)` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `HasLen` | 检查切片/映射/通道/字符串的长度 | `c.Assert(list, check.HasLen, 2)` |'
- en: '| `Matches` | Check that the string matches the regex | `c.Assert(val, check.Matches,
    ".*hi.*")` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `Matches` | 检查字符串是否与正则表达式匹配 | `c.Assert(val, check.Matches, ".*hi.*")` |'
- en: '| `ErrorMatches` | Check that the error message matches the regex | `c.Assert(err,
    check.Matches, ".*not found")` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `ErrorMatches` | 检查错误消息是否与正则表达式匹配 | `c.Assert(err, check.Matches, ".*not
    found")` |'
- en: '| `FitsTypeOf` | Check that the argument is assigned to a variable with the
    given type | `c.Assert(impl, check.FitsTypeOf, os.Error(nil)` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `FitsTypeOf` | 检查参数是否被分配给具有给定类型的变量 | `c.Assert(impl, check.FitsTypeOf, os.Error(nil))`
    |'
- en: '| `Not` | Invert the check result | `c.Assert(val, check.Not(check.Equals)),
    42)` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `Not` | 反转检查结果 | `c.Assert(val, check.Not(check.Equals)), 42)` |'
- en: Of course, if your tests require more sophisticated predicates than the ones
    built into `gocheck`, you can always roll your own by implementing the `Checker` interface.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您的测试需要比 `gocheck` 内置的谓词更复杂的谓词，您始终可以通过实现 `Checker` 接口来自定义。
- en: This concludes our tour of `gocheck`. If you are interested in using it in your
    projects, I would definitely recommend visiting the package home ^([3]) and reading
    its excellent documentation. If you already use `gocheck` but want to explore
    other popular testing frameworks for Go, I would suggest taking a look at the `stretchr/testify` package ^([7]), which
    offers similar functionality (test suites, assertions, and so on) to `gocheck`
    but also includes support for more advanced test primitives such as mocks.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对`gocheck`的浏览。如果您对在项目中使用它感兴趣，我肯定会推荐您访问包主页^([3])并阅读其优秀的文档。如果您已经使用`gocheck`但想探索其他流行的Go测试框架，我建议您看看`stretchr/testify`包^([7])，它提供了类似于`gocheck`的功能（测试套件、断言等），但也包括对更高级测试原语（如模拟）的支持。
- en: Integration versus functional testing
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试与功能测试
- en: In this section, we will attempt to dispel any confusion between the definitions
    of two very important and useful types of testing: **integration** tests and **functional** tests.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试消除对两种非常重要且有用的测试类型定义之间的任何混淆：**集成**测试和**功能**测试。
- en: Integration tests
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests pick up from where unit testing left off. Whereas unit testing
    ensures that each individual unit of a system works correctly in isolation, integration
    testing ensures that different units (or services, in a microservice architecture)
    interoperate correctly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试从单元测试结束的地方开始。而单元测试确保系统中的每个单独单元在隔离状态下正确工作，集成测试确保不同的单元（或微服务架构中的服务）正确交互。
- en: 'Let''s consider a hypothetical scenario where we are building an e-shop application.
    Following the SOLID design principles, we have split our backend implementation
    into a bunch of microservices. Each microservice comes with its own set of unit
    tests and, by design, exposes an API that adheres to a contract agreed on by *all* engineering
    teams. For the purpose of this demonstration, and to keep things simple, we want
    to focus our efforts on authoring an integration test for the following two microservices:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个假设的场景，即我们正在构建一个电子商务应用程序。遵循SOLID设计原则，我们将后端实现拆分成了多个微服务。每个微服务都附带其自己的单元测试集，并且按照设计，提供了一个遵守所有工程团队达成的协议的API。为了本演示的目的，并且为了保持简单，我们希望将精力集中在编写以下两个微服务的集成测试上：
- en: 'The **product** microservice performs the following functions:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商品**微服务执行以下功能：'
- en: It exposes a mechanism for manipulating and querying product metadata; for example,
    to add or remove products, return information about item prices, descriptions,
    and so on
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个用于操作和查询商品元数据的机制；例如，添加或删除产品，返回有关商品价格、描述等信息
- en: It provides a notification mechanism for metadata changes that other services
    can subscribe to
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个通知机制，其他服务可以订阅元数据更改
- en: The **basket** microservice stores the list of items that have been selected
    by the customer. When a new item is inserted into a customer's basket, the basket
    service queries the product service for the item metadata and updates the price
    summary for the basket. At the same time, it subscribes to the product service
    change stream and updates the basket's contents if the product metadata is updated.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**篮子**微服务存储客户已选商品列表。当新商品被插入客户的篮子时，篮子服务查询商品服务以获取商品元数据并更新篮子的价格摘要。同时，它订阅了商品服务的变更流，并在商品元数据更新时更新篮子的内容。'
- en: One important implementation aspect to be aware of is that each microservice
    uses its own dedicated data store. Keep in mind though that this approach does
    not necessarily mean that the data stores are physically separated. Perhaps we
    are using a single database server and each microservice gets its own database
    on that server.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要实现方面是，每个微服务都使用自己的专用数据存储。但请记住，这种方法并不一定意味着数据存储在物理上是分离的。也许我们正在使用单个数据库服务器，并且每个微服务都在该服务器上拥有自己的数据库。
- en: 'The integration test for these two services would live in a separate Go test
    file, perhaps with an `_integration_test.go` suffix so that we can immediately
    tell its purpose just by looking at the filename. The setup phase of the tests
    expects that the DB instance(s) that are required by the services have already
    been externally prepared. As we will see later in this chapter, a simple way to
    provide DB connection settings to our tests is via the use of environment variables.
    The tests would proceed to spin up the services that we want to test and then
    run the following integration scenarios:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个服务的集成测试将位于一个单独的Go测试文件中，可能带有`_integration_test.go`后缀，这样我们只需查看文件名就能立即知道其目的。测试的设置阶段期望所需的数据库实例已经由外部准备就绪。正如我们将在本章后面看到的那样，通过使用环境变量提供数据库连接设置是一种简单的方法。测试将继续启动我们想要测试的服务，然后运行以下集成场景：
- en: Invoke the product service API to insert a new product into the catalog. Then,
    it would use the basket service API to add the product to a customer basket and
    verify that the DB that's used by the basket service contains an entry with the
    correct product metadata.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用产品服务API将新产品插入目录。然后，它会使用购物车服务API将产品添加到客户购物车中，并验证用于购物车服务的数据库中包含具有正确产品元数据的条目。
- en: Add a product to a customer basket. Then, it would use the product service API
    to mutate the item description and verify that the relevant basket DB entry is
    updated correctly.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将产品添加到客户购物车中。然后，它会使用产品服务API修改项目描述，并验证相关的购物车数据库条目是否正确更新。
- en: One caveat of integration tests is that we need to maintain strict isolation
    between individual tests. Consequently, before running each test scenario, we
    must ensure that the internal state of each service is reset properly. Typically,
    this means that we need to flush the database that's used by each service and
    perhaps also restart the services in case they also maintain any additional in-memory
    state.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的一个注意事项是我们需要在各个测试之间保持严格的隔离。因此，在运行每个测试场景之前，我们必须确保每个服务的内部状态已正确重置。通常，这意味着我们需要清除每个服务使用的数据库，也许还需要重启服务，以防它们还维护任何额外的内存状态。
- en: Evidently, the effort that's required to set up, wire together, and prime the
    various components that are needed for each integration test makes writing such
    tests quite a tedious process. Not to diminish the significance of integration
    testing, it is my belief that engineers can make better use of their time by writing
    a large number of unit tests and just a handful of integration tests.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，设置、连接和准备每个集成测试所需的各种组件所需的努力使得编写此类测试变得相当繁琐。尽管不降低集成测试的重要性，但我相信工程师可以通过编写大量单元测试和少量集成测试来更好地利用他们的时间。
- en: Functional tests
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: Functional or end-to-end tests take system testing to a whole new level. The
    primary purpose of functional testing is to ensure that the *complete *system
    is working as expected. To this end, functional tests are designed to model complex
    interaction scenarios that involve multiple system components. A very common use
    case for functional tests is to verify end-to-end correctness by simulating a
    user's journey through the system.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试或端到端测试将系统测试提升到了全新的水平。功能测试的主要目的是确保整个系统按预期工作。为此，功能测试旨在模拟涉及多个系统组件的复杂交互场景。功能测试的一个非常常见的用例是通过模拟用户在系统中的旅程来验证端到端正确性。
- en: For instance, a functional test for an online music streaming service would
    act as a new user who would subscribe to the service, search for a particular
    song, add it to their playlist, and perhaps submit a rating for the song once
    it's done playing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对一个在线音乐流媒体服务的功能测试将模拟为新用户订阅服务，搜索特定歌曲，将其添加到他们的播放列表中，并在播放完成后可能为该歌曲提交评分。
- en: It is important to clarify that all the preceding interactions are meant to
    occur via the web browser. This is a clear-cut case where we need to resort to
    a *scriptable* browser automation framework such as Selenium ^([6]) in order to
    accurately model all the required button clicks that we expect a real user to
    perform while using the system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要明确，所有前面的交互都旨在通过网页进行。这是一个需要求助于可脚本化的浏览器自动化框架，如Selenium ^([6])，以便准确模拟我们期望真实用户在使用系统时执行的所有所需按钮点击的明确案例。
- en: While you could probably find a package that provides Go bindings for Selenium,
    the truth of the matter is that Go is not the best tool for writing functional
    tests. Contrary to unit and integration tests, which live within Go files, functional
    tests are normally written in languages such as Python, JavaScript, or Ruby. Another
    important distinction is that, due to their increased complexity, functional tests
    take a *significantly* longer time to run.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能能找到一个提供Selenium Go绑定的包，但事实是，Go并不是编写功能测试的最佳工具。与存在于Go文件中的单元测试和集成测试相反，功能测试通常是用Python、JavaScript或Ruby等语言编写的。另一个重要的区别是，由于它们的复杂性增加，功能测试的运行时间通常**显著**更长。
- en: While it's not uncommon for software engineers working on a particular feature
    to also provide functional test suites, in the majority of cases, the task of
    authoring functional tests is one of the primary responsibilities of the **quality
    assurance** (**QA**) team. As a matter of fact, functional tests are the front
    and center part of the pre-release workflow that's followed by QA engineers before
    they can give the green light for a new release.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然软件工程师在开发特定功能时也提供功能测试套件并不罕见，但在大多数情况下，编写功能测试的任务是**质量保证**（**QA**）团队的主要职责之一。事实上，功能测试是QA工程师在为新版本发出绿灯之前遵循的预发布工作流程的前沿和中心部分。
- en: Functional tests don't usually target production systems; you wouldn't want
    to fill up your production DB with dummy user accounts, right? Instead, functional
    tests target **staging environments**, which are isolated and often downsized
    sandboxes that mirror the setup of the actual production environment. This includes
    all the services and resources (databases, message queues, and so on ) that are
    needed for the system to operate. One exception is that access to external third-party
    services such as payment gateways or email providers is typically mocked unless
    a particular functional test requests otherwise.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试通常不针对生产系统；你肯定不希望用虚拟用户账户填满你的生产数据库，对吧？相反，功能测试针对的是**预发布环境**，这些环境是隔离的，通常是缩小规模的沙盒，它们反映了实际生产环境的设置。这包括系统运行所需的所有服务和资源（数据库、消息队列等）。一个例外是，访问外部第三方服务，如支付网关或电子邮件提供商，通常会被模拟，除非特定的功能测试有其他要求。
- en: Functional tests part deux – testing in production!
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试之二——在生产环境中测试！
- en: That's not to say that you cannot actually run your functional tests in a live
    production environment! Surely whether that's a good or bad idea is a debatable
    point, but if you do decide to go down that route, there are a few patterns that
    you can apply to achieve this in a *safe* and *controlled* way.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说你实际上不能在实时生产环境中运行你的功能测试！当然，这究竟是好是坏是一个有争议的问题，但如果你决定走这条路，你可以应用一些模式来以**安全**和**可控**的方式实现这一点。
- en: To get the ball rolling, you can begin by revising your DB schemas so that they
    include a field that indicates whether each row contains real data or is part
    of a test run. Each service could then silently ignore any test records when it
    handles live traffic.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始行动，你可以从修订你的数据库模式开始，使它们包括一个字段，指示每行是否包含真实数据或测试运行的一部分。然后，每个服务在处理实时流量时可以默默地忽略任何测试记录。
- en: If you are working with a microservice architecture, you can engineer your services
    so that they do not talk to other services directly but rather to do so via a
    local proxy that is deployed in tandem with each service as a *sidecar* process.
    This pattern is known as the *ambassador* pattern and opens up the possibility
    of implementing a wide range of really cool tricks, as we will see later in this
    chapter.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用微服务架构，你可以设计你的服务，使它们不直接与其他服务通信，而是通过本地代理进行通信，该代理作为**边车**进程与每个服务一起部署。这种模式被称为**大使**模式，并开辟了实现一系列真正酷炫技巧的可能性，正如我们将在本章后面看到的。
- en: Since all the proxies are initially configured to talk to the already deployed
    services, nothing prevents us from deploying a newer version of a particular service
    and have it run side-by-side with the existing version. Since no traffic can reach
    the newly deployed service, it is common to use the term **dark launch** to refer
    to this kind of deployment.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有代理最初都配置为与已部署的服务通信，因此没有任何东西阻止我们部署特定服务的较新版本，并使其与现有版本并行运行。由于新部署的服务无法接收流量，因此通常使用术语**暗启动**来指代这种部署方式。
- en: 'Once the new versions of the services that we need to test against have been
    successfully deployed, each functional test can reconfigure the local proxies
    to divert *test* traffic (identified perhaps by an HTTP header or an other type
    of tag) to the newly deployed services. This can be seen in the following diagram:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们需要的测试服务的版本成功部署，每个功能测试都可以重新配置本地代理，将*测试*流量（可能通过HTTP头或其他类型的标签识别）重定向到新部署的服务。这可以在以下图中看到：
- en: '![](img/bcc8ab64-b290-42f0-899b-63dfc6b4a975.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bcc8ab64-b290-42f0-899b-63dfc6b4a975.png)'
- en: Figure 4: Using the ambassador pattern to test in production
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：使用大使模式在生产中进行测试
- en: This neat trick allows us to run our tests in production without interfering
    with live traffic. As you can tell, live testing requires substantially more preparation
    effort compared to testing in a sandbox. This is probably one of the reasons why
    QA teams seem to prefer using staging environments instead.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个巧妙的方法允许我们在生产环境中运行测试，而不干扰实时流量。正如你所知，与沙盒测试相比，实时测试需要更多的准备工作。这可能是QA团队似乎更喜欢使用预发布环境的原因之一。
- en: In my view, if your system is built in such a way that you can easily introduce
    one of these patterns to facilitate live testing, you should definitely go for
    it. After all, there is only so much data that you can collect when running in
    an isolated environment whose load and traffic profiles don't really align with
    the ones of your production systems.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，如果你的系统构建得可以轻松引入这些模式之一以方便实时测试，你绝对应该这样做。毕竟，在运行在一个负载和流量配置文件与生产系统不真正一致的隔离环境中时，你能收集到的数据量是有限的。
- en: Smoke tests
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 烟雾测试
- en: Smoke tests or build acceptance tests constitute a special family of tests that
    are traditionally used as early sanity checks by QA teams.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 烟雾测试或构建验收测试构成了一类特殊的测试，这些测试传统上被QA团队用作早期合理性检查。
- en: The use of the word *smoke* alludes to the old adage that *wherever there is
    smoke, there is also fire*. These checks are explicitly designed to identify early
    warning signals that something is wrong. It goes without saying that any issue
    uncovered by a smoke test is treated by the QA team as a show-stopper; if smoke
    tests fail, no further testing is performed. The QA team reports its findings
    to the development team and waits for a revised release candidate to be submitted
    for testing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单词*smoke*指的是古老的谚语“哪里有烟，哪里就有火”。这些检查明确设计用来识别早期预警信号，表明可能存在问题。不言而喻，任何烟雾测试中发现的任何问题都被QA团队视为一个阻止器；如果烟雾测试失败，则不再进行进一步测试。QA团队向开发团队报告其发现，并等待提交修订的候选版本以进行测试。
- en: 'Once the smoke tests successfully pass, the QA team proceeds to run their suite
    of functional tests before giving the green light for release. The following diagram
    summarizes the process of running smoke tests for QA purposes:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦烟雾测试成功通过，QA团队将继续运行他们的功能测试套件，然后在发布前给出绿灯。以下图总结了为QA目的运行烟雾测试的过程：
- en: '![](img/18852742-a560-4427-8b00-fed2b5b8b59d.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18852742-a560-4427-8b00-fed2b5b8b59d.png)'
- en: Figure 5: Running smoke tests as part of the QA process
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：将烟雾测试作为QA过程的一部分运行
- en: 'When it comes to execution, smoke tests are the exact antithesis of functional
    tests. While functional tests are allowed to execute for long periods of time,
    smoke tests must execute as quickly as possible. As a result, smoke tests are
    crafted so as to exercise specific, albeit limited, flows in the user-facing parts
    of a system that are deemed critical for the system''s operation. For example,
    smoke tests for a social network application would verify the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到执行时，烟雾测试是功能测试的完全对立面。虽然功能测试可以长时间执行，但烟雾测试必须尽可能快地执行。因此，烟雾测试被精心设计，以测试系统用户界面部分中特定、尽管有限的流程，这些流程被认为是系统操作的关键。例如，社交网络应用的烟雾测试将验证以下内容：
- en: A user can login with a valid username and password
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以使用有效的用户名和密码登录
- en: Clicking the like button on a post increases the like counter for that post
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击帖子上的点赞按钮会增加该帖子的点赞计数器
- en: Deleting a contact removes them from the user's friends list
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除联系人会将他们从用户的联系人列表中删除
- en: Clicking the logout button signs the user out of the service
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击注销按钮将用户从服务中注销
- en: 'The responsibility for authoring, evolving, and maintaining smoke tests usually
    falls on the shoulders of the QA team. Consequently, it makes sense for the QA
    team to maintain smoke tests in a separate, dedicated repository that they own
    and control. An interesting question here is whether the QA team will opt to execute
    the smoke tests manually or invest the time and effort that''s required to automate
    the process. The logical, albeit slightly cliché, answer is: it depends...'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 编写、演进和维护烟雾测试的责任通常落在QA团队身上。因此，QA团队在单独的、专用的存储库中维护烟雾测试是有意义的，他们拥有并控制这个存储库。这里有一个有趣的问题：QA团队会选择手动执行烟雾测试，还是投入时间和精力来自动化这个过程？逻辑上，尽管有点陈词滥调，答案是：这取决于...
- en: At the end of the day, the decision boils down to the size of the QA team, the
    individual preferences of the team's members, and the test infrastructure that's
    available and is at the team's disposal. Needless to say, automated smoke tests
    are, hands down, the recommended option since the QA team can efficiently verify
    a plethora of scenarios in a small amount of time. On the other hand, if the build
    release frequency is low, you could argue that doing manual smoke tests has a
    smaller cost and makes better use of the QA team's time and resources.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，决策取决于QA团队的大小、团队成员的个人偏好，以及可供团队使用的测试基础设施。不用说，自动化烟雾测试无疑是首选方案，因为QA团队能够在短时间内高效地验证大量场景。另一方面，如果构建发布的频率较低，那么手动进行烟雾测试可能成本更低，并且能更好地利用QA团队的时间和资源。
- en: Chaos testing – breaking your systems in fun and interesting ways!
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混沌测试——以有趣和有趣的方式破坏你的系统！
- en: Let me begin this section with a question! How confident are you about the quality
    of your current software stack? If your answer happens to be something along the
    lines of, *I don't really know until I make it fail*, then we are in total agreement!
    If not, let me introduce you to the concept of **chaos testing**.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从一个问题开始这个部分！你对当前软件栈的质量有多自信？如果你的回答是“我真的不知道，直到我让它失败”，那么我们完全一致！如果不是这样，让我向你介绍**混沌测试**的概念。
- en: 'Chaos testing is a term that was initially coined by the engineering team at
    Netflix. The key point behind chaos testing is to evaluate your system''s behavior
    when various components exhibit different types of failure. So, what kinds of
    failure are we talking about here? Here are a few interesting examples, ordered
    by their relative severity (low to high):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌测试是一个最初由Netflix工程团队提出的术语。混沌测试背后的关键点是评估系统在各个组件表现出不同类型的故障时的行为。那么，我们在这里讨论的是哪些类型的故障呢？以下是一些按相对严重程度（从低到高）排序的有趣示例：
- en: A service fails to reach another service it depends on
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务无法到达它所依赖的另一个服务
- en: Calls between services exhibit high latency/jitter
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务之间的调用表现出高延迟/抖动
- en: Network links experience packet loss
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络链路出现数据包丢失
- en: A database node fails
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库节点故障
- en: We lose a critical piece of storage
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们失去了一块关键的存储设备
- en: Our cloud provider suffers an outage in an entire availability zone
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们云服务提供商在整个可用区发生故障
- en: Netflix engineers point out that we shouldn't be afraid of failure but rather
    embrace it and learn as much as we can about it. All these learnings can be applied
    to fine-tune the design of our systems so that they become incrementally more
    and more robust and resilient against failure.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix工程师指出，我们不应该害怕失败，而应该拥抱它，尽可能多地了解它。所有这些学习都可以应用于微调我们系统的设计，使它们在对抗失败方面变得更加稳健和有弹性。
- en: Some of these types of failure have a low likelihood of occurring. Nevertheless,
    it's better if we are prepared to mitigate them when they actually *do* occur.
    After all, from a system stability perspective, it's always preferred to operate
    in a preventive fashion rather than trying to react (often under lots of pressure)
    when an outage occurs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的故障发生的可能性很低。尽管如此，如果我们能准备好在它们实际发生时减轻它们的影响，那就更好了。毕竟，从系统稳定性的角度来看，预防性地操作总是优于在出现故障时（通常是在巨大的压力下）试图做出反应。
- en: 'You might be wondering: *but, if some failures are statistically unlikely to
    occur, how can we trigger them in the first place?* The only way to do this is
    to engineer our systems in such a way that failure can be injected on demand.
    In the *Functional tests part deux – testing in production!* section, we talked
    about the ambassador pattern, which can help us achieve exactly that.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：*但是，如果某些故障在统计上不太可能发生，我们最初如何触发它们呢？* 唯一的方法是以一种方式设计我们的系统，以便可以根据需要注入故障。在*功能测试第二部分
    – 生产中的测试*部分，我们讨论了大使模式，它可以帮助我们实现这一点。
- en: The ambassador pattern decouples service discovery and communication from the
    actual service implementation. This is achieved with the help of a sidecar process
    that gets deployed with each service and acts as a proxy.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 大使模式将服务发现和通信与实际服务实现解耦。这是通过每个服务部署的边车进程实现的，该进程充当代理。
- en: The sidecar proxy service can be used for other purposes, such as conditionally
    routing traffic based on tags or headers, acting as a circuit breaker, bifurcating
    traffic to perform A/B testing, logging requests, enforcing security rules, or
    to *inject artificial failures into the system*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 边车代理服务可用于其他用途，例如根据标签或头部条件路由流量，充当断路器，将流量分支以执行A/B测试，记录请求，强制执行安全规则，或者向系统中*注入人工故障*。
- en: 'From a chaos engineering perspective, the sidecar proxy is an easy avenue for
    introducing failures. Let''s look at some examples of how we can exploit the proxy
    to inject failure into the system:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 从混沌工程的角度来看，边车代理是引入故障的简单途径。让我们看看一些我们可以利用代理将故障注入系统的例子：
- en: Instruct the proxy to delay outgoing requests or wait before returning upstream
    responses to the service that initiated the request. This is an effective way
    to model latency. If we opt not to use fixed intervals but to randomize them,
    we can inject jitter into intra-service communication.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示代理延迟发送请求或等待在返回上游响应给发起请求的服务之前。这是一种模拟延迟的有效方法。如果我们选择不使用固定间隔，而是随机化它们，我们可以在服务间通信中注入抖动。
- en: Configure the proxy to drop outgoing requests with probability *P*. This emulates
    a degraded network connection.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置代理以以概率*P*丢弃出站请求。这模拟了降级网络连接。
- en: Configure the proxy for a single service to drop all outgoing traffic to another
    service. At the same time, all the other service proxies are set up to forward
    traffic as usual. This emulates a network partition.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置代理以使单个服务丢弃发送到另一个服务的所有出站流量。同时，所有其他服务代理都设置为按常规转发流量。这模拟了网络分区。
- en: That's not all. We can take chaos testing even further if we are running our
    systems on a cloud provider that provides us with an API that we can use to break
    even more things! For instance, we could use such an API to randomly start killing
    nodes or to take down one or all of our load balancers and check whether our system
    can automatically recover by itself. With chaos testing, the only limit is your
    own imagination!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部。如果我们运行在提供API的云服务提供商上，该API可以帮助我们破坏更多东西，我们可以将混沌测试进一步推进！例如，我们可以使用这样的API随机终止节点或关闭一个或所有负载均衡器，并检查我们的系统是否可以自动恢复。在混沌测试中，唯一的限制是你的想象力！
- en: Tips and tricks for writing tests
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试的技巧和窍门
- en: In this section, I will be going through some interesting ideas that can help
    super-charge your daily test workflow. What's more, we will also be exploring
    some neat tricks that you can use to isolate tests, mock calls to system binaries,
    and control time within your tests.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍一些可以帮助提升你日常测试工作流程的有趣想法。更重要的是，我们还将探索一些你可以在测试中使用的巧妙技巧，以隔离测试、模拟对系统二进制的调用以及控制测试中的时间。
- en: Using environment variables to set up or skip tests
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境变量设置或跳过测试
- en: In a project of any size, you are eventually bound to come across a series of
    tests that depend on external resources that are created or configured in an ad
    hoc fashion.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何规模的项目中，你最终都会遇到一系列依赖于外部资源的测试，这些资源以临时方式创建或配置。
- en: A typical example of such a use case would be a test suite that talks to a database.
    As the engineers working locally on the code base, we would probably spin up a
    local database instance with a more or less predictable endpoint and use that
    for testing. However, when running under CI, we might be required to use an already
    provisioned database instance on some cloud provider or, more often than not,
    the CI setup phase may need to start a database in a Docker container, a process
    that would yield a non-predictable endpoint to be connected to.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的用例的一个典型例子是一个与数据库通信的测试套件。作为在代码库上本地工作的工程师，我们可能会启动一个具有或多或少可预测端点的本地数据库实例，并使用它进行测试。然而，当在CI下运行时，我们可能需要使用某些云提供商上已经配置好的数据库实例，或者更常见的是，CI设置阶段可能需要在Docker容器中启动数据库，这个过程会产生一个不可预测的端点来连接。
- en: 'To support scenarios such as these, we must avoid hardcoding the location of
    resource endpoints to our tests and *defer* their discovery and configuration
    until the time when the test runs. To this end, one solution would be to use a
    set of environment variables to supply this information to our tests. Here is
    a simple test example from the `Chapter04/db` package that illustrates how this
    can be achieved:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持此类场景，我们必须避免在测试中硬编码资源端点的位置，并*推迟*它们的发现和配置，直到测试运行时。为此，一个解决方案是使用一组环境变量来向我们的测试提供这些信息。以下是从`Chapter04/db`包中的一个简单测试示例，说明了如何实现这一点：
- en: '[PRE42]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding example makes testing a breeze, regardless of whether we run the
    tests locally or in a CI environment. But what if our tests require a specialized
    DB that is not that easy to spin up locally? Maybe we need a DB that operates
    in a clustered configuration or one whose memory requirements exceed the memory
    that's available on our development machine. Wouldn't it be great if we could
    just *skip* that test when running locally?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使得无论我们在本地还是CI环境中运行测试，测试都变得非常简单。但如果我们需要运行本地难以启动的专用数据库，情况会怎样呢？可能我们需要一个在集群配置下运行的数据库，或者内存需求超过我们开发机上可用内存的数据库。如果我们可以简单地*跳过*本地运行时的这个测试，那岂不是很好？
- en: 'It turns out that this is also quite easy to achieve with exactly the same
    mechanism that we used for configuring our DB endpoint. To be more precise, the *absence* of
    the required configuration settings could serve as a hint to the test that it
    needs to be skipped. In the preceding example, we can achieve this by adding a
    simple `if` block after fetching the environment values for the DB configuration:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，使用与我们配置数据库端点相同的机制也可以很容易地实现这一点。更准确地说，所需配置设置的*缺失*可以作为测试需要跳过的提示。在先前的示例中，我们可以在获取数据库配置的环境值后添加一个简单的`if`块来实现这一点：
- en: '[PRE43]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Excellent! Now, if we don't export the `DB_HOST` environment variable before
    running our tests, this particular test will be skipped.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，如果我们没有在运行测试之前导出`DB_HOST`环境变量，这个特定的测试将被跳过。
- en: Speeding up testing for local development
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速本地开发中的测试
- en: In this section, we will be covering a couple of approaches to accelerating
    testing when working locally. Just to clarify, I am assuming that you already
    have a proper CI infrastructure in place; no matter what shortcuts we will be
    taking here, the CI will always run all the tests.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些在本地工作时加速测试的方法。为了澄清，我假设您已经建立了一个适当的持续集成（CI）基础设施；无论我们在这里采取什么捷径，CI都会始终运行所有测试。
- en: The first item on our agenda is slow versus fast tests. For the sake of argument,
    say that we find ourselves in a situation where we are writing a fully-fledged,
    pure CPU ray tracer implementation in Go. To ensure correctness and avoid regressions
    while we are tweaking our implementation, we have introduced a test suite that
    renders a sequence of example scenes and compares the ray tracer output to a series
    of prerendered reference images.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们议程上的第一项是慢速测试与快速测试的比较。为了辩论的目的，假设我们发现自己处于编写一个完整的、纯CPU的Go语言射线追踪器实现的情况。为了确保正确性并避免在调整实现时出现回归，我们引入了一个测试套件，该套件渲染一系列示例场景，并将射线追踪器的输出与一系列预渲染的参考图像进行比较。
- en: Since this is a pure CPU implementation and our tests render at full-HD resolution,
    running each test would take, as you can imagine, quite a bit of time. This is
    not an issue when running on the CI but can definitely be an impediment when working
    locally.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个纯CPU实现，并且我们的测试以全高清分辨率渲染，因此可以想象，运行每个测试都会花费相当多的时间。在CI上运行时这不是问题，但在本地工作时可能会成为障碍。
- en: To make matters worse, `go test` will try to run all the tests, even if one
    of them fails. Additionally, it will automatically fail tests that take a long
    time (over 10 minutes) to run. Fortunately, the `go test` command supports some
    really useful flags that we can use to rectify these issues.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，`go test`会尝试运行所有测试，即使其中一个失败了。此外，它还会自动失败运行时间过长的测试（超过10分钟）。幸运的是，`go test`命令支持一些非常有用的标志，我们可以使用这些标志来解决这些问题。
- en: To begin with, we can notify long-running tests that they should try to shorten
    their runtime by passing the `-short` flag to the `go test` invocation. This flag
    gets exposed by the `testing` package via the `Short` helper function, which returns `true` when
    the `-short` flag is defined. So, how can we use this flag to make our ray tracer
    tests run faster?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过将`-short`标志传递给`go test`调用，通知长时间运行的测试尝试缩短它们的运行时间。这个标志通过`testing`包的`Short`辅助函数暴露出来，当定义了`-short`标志时，它返回`true`。那么，我们如何使用这个标志来使我们的光线追踪器测试运行得更快呢？
- en: One approach would be to simply skip tests that are known to take a really long
    time to run. A much better alternative would be to detect the presence of the `-short` flag
    and *dial down* the output resolution of the ray tracer, say, to something such
    as a quarter of the original resolution. This change would still allow us to verify
    the rendering output when testing locally while at the same time would constrain
    the total runtime of our tests to an acceptable level.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法就是简单地跳过已知运行时间非常长的测试。一个更好的替代方案是检测到`-short`标志的存在，并将光线追踪器的输出分辨率降低，例如，降低到原始分辨率的四分之一。这种改变仍然允许我们在本地测试时验证渲染输出，同时将我们测试的总运行时间限制在可接受的水平。
- en: Coming back to the issue of `go test` running all the tests, even if one of
    them fails, we can actually instruct `go test` to immediately abort if it detects
    a failing test by passing the `-failfast` command-line flag. Moreover, we can
    tune the maximum, per-test execution time with the help of the `-timeout` flag.
    It accepts any string that can be parsed by the `time.Duration` type (for example, *1h*),
    but if your tests take an unpredictable amount of time to run, you could also
    pass a timeout value of *0* to disable timeouts.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`go test`运行所有测试的问题，即使其中一个失败了，我们实际上可以指示`go test`在检测到失败的测试时立即终止，通过传递`-failfast`命令行标志。此外，我们可以使用`-timeout`标志来调整每个测试的最大执行时间。它接受任何可以被`time.Duration`类型解析的字符串（例如，`*1h*`），但如果你的测试运行时间不可预测，你也可以传递一个`*0*`的超时值来禁用超时。
- en: Excluding classes of tests via build flags
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过构建标志排除测试类别
- en: So far, we have discussed white- and black-box tests, integration, and end-to-end
    tests. By including tests from all these categories in our projects, we can rest
    assured that the code base will behave as expected in a multitude of different
    scenarios.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了白盒测试、黑盒测试、集成测试和端到端测试。通过在我们的项目中包含所有这些类别的测试，我们可以确信代码库将在多种不同的场景中按预期行为。
- en: Now, imagine we are working on a particular feature and we *only* want to run
    the unit tests. Alternatively, we may *only* need to run the integration tests
    to ensure that our changes do not introduce regression to other packages. How
    can we do that?
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们正在处理一个特定的功能，我们只想运行单元测试。或者，我们可能只需要运行集成测试来确保我们的更改不会引入其他包的回归。我们该如何做到这一点？
- en: The rather simplistic approach would be to maintain separate folders for each
    test category, but that would veer away from what is considered to be idiomatic
    Go. Another alternative would be to add the category name as a prefix or suffix
    to our tests and run `go test` with the `-run` flag (or with the `-check.f` flag
    if we are using a third-party package such as `gocheck` ^([3])) to only run the
    tests whose names match a particular regular expression. It stands to reason that
    while this approach will work, it's quite error-prone; for larger code bases,
    we would need to compose elaborate regular expressions that might not match all
    the tests that we need to run.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 相对简单的方法是为每个测试类别维护单独的文件夹，但这会偏离被认为是Go语言习惯的做法。另一个替代方案是在我们的测试中添加类别名称作为前缀或后缀，并使用带有`-run`标志的`go
    test`（如果我们使用第三方包如`gocheck`则使用`-check.f`标志）来仅运行名称与特定正则表达式匹配的测试。从这个角度来看，虽然这种方法可行，但它很容易出错；对于大型代码库，我们需要编写复杂的正则表达式，这些表达式可能无法匹配所有需要运行的测试。
- en: A smarter solution would be to take advantage of Go's support for conditional
    compilation and repurpose it to serve our needs. This is a great time to explain
    what conditional compilation is all about and, most importantly, how it works
    under the hood.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更聪明的解决方案是利用 Go 对条件编译的支持，并将其重新用于满足我们的需求。这是一个很好的时机来解释什么是条件编译，以及最重要的是，它在底层是如何工作的。
- en: 'When a package is being built, the `go build` command scans the comments inside
    each Go file, looking for special keywords that can be interpreted as compiler
    directives. **Build tags** are one example of such an annotation. They are used
    by `go build` to decide whether a particular Go file in a package should be passed
    to the Go compiler. The general syntax for a build tag is as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个包正在构建时，`go build` 命令会扫描每个 Go 文件内的注释，寻找可以解释为编译器指令的特殊关键字。**构建标签** 是这类注释的一个例子。`go
    build` 使用构建标签来决定一个包中的特定 Go 文件是否应该传递给 Go 编译器。构建标签的一般语法如下：
- en: '[PRE44]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To be correctly recognized by `go build`, all the build tags must appear as
    a comment at the *top* of a Go file. While you are allowed to define multiple
    build tags, it is very important that the *last* build tag is separated with a
    blank (non-comment) line from the package name declaration. Otherwise, `go build` will
    just assume that the build tag is part of a package-level comment and simply ignore
    it. Software engineers that are new to the concept of Go build tags occasionally
    fall into this trap, so if you find yourself scratching your head, wondering why
    build tags are not being picked up, the lack of a blank line after the build tag
    is the most likely suspect.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了被 `go build` 正确识别，所有的构建标签都必须作为注释出现在 Go 文件的 *顶部*。虽然你可以定义多个构建标签，但非常重要的一点是，*最后一个*
    构建标签必须与包名声明之间有一个空白（非注释）行分隔。否则，`go build` 将假设构建标签是包级注释的一部分，并简单地忽略它。对于刚开始接触 Go 构建标签的软件工程师来说，偶尔会陷入这个陷阱，所以如果你发现自己感到困惑，不知道为什么构建标签没有被识别，那么构建标签后面缺少空白行可能是最有可能的原因。
- en: 'Let''s take a closer look at the intricacies of the tag syntax and elaborate
    on the rules that are applied by `go build` to interpret the list of tags following
    the `+build` keyword:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看标签语法的复杂性，并阐述 `go build` 如何应用规则来解释 `+build` 关键字后面的标签列表：
- en: Tags separated by *whitespace* are evaluated as a list of OR conditions.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 *空白字符* 分隔的标签被视为一系列 OR 条件。
- en: Tags separated by a *comma* are evaluated as a list of AND conditions.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 *逗号* 分隔的标签被视为一系列 AND 条件。
- en: Tags beginning with `!` are treated as NOT conditions.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `!` 开头的标签被视为 NOT 条件。
- en: If multiple `+build` lines are defined, they are joined together as an AND condition.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果定义了多个 `+build` 行，它们将被作为一个 AND 条件合并在一起。
- en: The `go build` command recognizes several predefined tags for the target operating
    system (for example, `linux, windows, darwin`), CPU architecture (for example, `amd64,
    386, arm64`), and even the version of the Go compiler (for example, `go1.10` to
    specify Go 1.10 onward). The following table shows a few examples that use tags
    to model complex build constraints.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`go build` 命令识别针对目标操作系统（例如，`linux, windows, darwin`）、CPU 架构（例如，`amd64, 386,
    arm64`）以及 Go 编译器版本（例如，`go1.10` 以指定 Go 1.10 及以后的版本）的几个预定义标签。以下表格展示了使用标签来建模复杂构建约束的一些示例。'
- en: '| **Build Target Scenario** | **Build tag** |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| **构建目标场景** | **构建标签** |'
- en: '| Only when the target is Linux | linux |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 仅当目标是 Linux | linux |'
- en: '| Linux or macOS | linux darwin |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| Linux 或 macOS | linux darwin |'
- en: '| x64 targets but only with Go compiler >= 1.10 | amd64,go1.10 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| x64 目标，但仅当 Go 编译器 >= 1.10 | amd64,go1.10 |'
- en: '| 32-bit Linux OR 64-bit all platforms *except* OS X | linux,386 amd64,!darwin
    |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 32 位 Linux 或 64 位所有平台 *除了* OS X | linux,386 amd64,!darwin |'
- en: By now, you should have a better understanding of how build tags work. But how
    does all this information apply to our particular use case? First of all, let
    me highlight the fact that test files are also regular Go files and, as such,
    they are also scanned for the presence of build tags! Secondly, we are not limited
    to the built-in tags – we can also define our own custom tags and pass them to `go
    build` *or* `go test` via the `-tags` command-line flag.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对构建标签的工作方式有了更好的理解。但是，所有这些信息如何应用到我们的特定用例中呢？首先，让我强调一点，测试文件也是常规的 Go 文件，因此它们也会被扫描以查找构建标签的存在！其次，我们不仅限于内置的标签，我们还可以定义自己的自定义标签，并通过
    `-tags` 命令行标志将它们传递给 `go build` 或 `go test`。
- en: 'You can probably see where I am going with this… We can start by defining a
    build tag for each family of tests, for example, `integration_tests`, `unit_tests`, and `e2e_tests`.
    Additionally, we will define an `all_tests` tag since we need to retain the capability
    to run all the tests together. Finally, we will edit our test files and add the
    following build tag annotations:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到了我要去哪里了……我们可以从为每个测试系列定义一个构建标签开始，例如，`integration_tests`、`unit_tests` 和
    `e2e_tests`。此外，我们将定义一个 `all_tests` 标签，因为我们需要保留一起运行所有测试的能力。最后，我们将编辑我们的测试文件并添加以下构建标签注释：
- en: '`+build unit_tests all_tests` to the files containing the unit tests'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+build unit_tests all_tests` 添加到包含单元测试的文件中'
- en: '`+build integration_tests all_tests` to the files containing the integration
    tests'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+build integration_tests all_tests` 添加到包含集成测试的文件中'
- en: '`+build e2e_tests all_tests` to the files containing the end-to-end tests'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+build e2e_tests all_tests` 添加到包含端到端测试的文件中'
- en: If you wish to experiment with the preceding example, you can check out the
    contents of the `Chapter04/buildtags` package.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望尝试前面的示例，你可以查看 `Chapter04/buildtags` 包的内容。
- en: This is not the output you are looking for – mocking calls to external binaries
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这不是你想要的输出 – 模拟对外部二进制文件的调用
- en: Have you ever struggled when trying to test code that calls out to an external
    process and then uses the output as part of the implemented business logic? In
    some cases, it might be possible to use some of the tricks we have discussed so
    far to decorate our code with hooks that tests can use to mock the executed command's
    output. Unfortunately, sometimes this will not be possible. For instance, the
    code under test could import a third-party package that is actually the one that's
    responsible for executing some external command.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你在尝试测试调用外部进程并使用其输出作为实现业务逻辑一部分的代码时是否遇到过困难？在某些情况下，可能可以使用我们之前讨论的一些技巧来装饰我们的代码，以便测试可以使用钩子来模拟执行命令的输出。不幸的是，有时这将是不可行的。例如，被测试的代码可能导入了一个第三方包，而这个包实际上负责执行某些外部命令。
- en: 'The `Chapter04/pinger` package exports a function called `RoundtripTime`. Its
    job is to calculate the round-trip time for reaching a remote host. Under the
    hood, it calls out to the `ping` command and parses its output. This is how it
    is implemented:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter04/pinger` 包导出一个名为 `RoundtripTime` 的函数。其任务是计算到达远程主机的往返时间。在底层，它调用 `ping`
    命令并解析其输出。这是它的实现方式：'
- en: '[PRE45]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since the `ping` command flag names are slightly different between Unix-like
    systems and Windows, the code relies on OS sniffing to select the appropriate
    set of flags so that `ping` will send out a single request with a 32-byte payload.
    The `extractRTT` helper function just applies a regular expression to extract
    the timing information and convert it into a `time.Duration` value.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Unix-like系统和Windows之间的 `ping` 命令标志名称略有不同，代码依赖于操作系统嗅探来选择适当的标志集，以便 `ping` 发送一个带有32字节有效载荷的单个请求。`extractRTT`
    辅助函数只是应用正则表达式来提取时间信息并将其转换为 `time.Duration` 值。
- en: For the purpose of this demonstration, let's assume that we are operating a
    video streaming service and our business logic (which lives in another Go package)
    uses the `RoundtripTime` results to redirect our customers to the edge server
    that is closest to them. We have been tasked with writing an *end-to-end* test
    for the service so, unfortunately, we are not allowed to mock any of the calls to
    the `RoundtripTime` function; our test actually needs to invoke the `ping` command!
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示的目的，让我们假设我们正在运营一个视频流媒体服务，我们的业务逻辑（位于另一个Go包中）使用 `RoundtripTime` 结果将我们的客户重定向到离他们最近的边缘服务器。我们被分配编写该服务的
    *端到端* 测试，因此，不幸的是，我们不允许模拟对 `RoundtripTime` 函数的任何调用；我们的测试实际上需要调用 `ping` 命令！
- en: If you ever find yourself in a similar situation, let me suggest a nice trick
    that you can use to mock calls to external processes. I came across the concept
    that I am about to describe when I first joined Canonical to work on the juju code
    base. In hindsight, the idea is pretty straightforward. The implementation, however,
    is not something immediately obvious and requires some platform-specific tweaks,
    so kudos to the engineers that came up with it.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己处于类似的情况，让我建议一个很好的技巧，你可以用它来模拟对外部进程的调用。当我第一次加入Canonical公司并开始处理 juju 代码库时，我遇到了这个概念。事后看来，这个想法相当简单。然而，实现并不是一目了然的，需要一些平台特定的调整，所以向提出这个想法的工程师致敬。
- en: This approach exploits the fact that when you try to execute a binary (for example,
    using the `Command` function from the `os/exec` package), the operating system
    will look for the binary in the current working directory and if that fails, it
    will sequentially scan each entry in the system's `PATH` environment variable,
    trying to locate it. To our advantage, both Unix-like systems and Windows follow
    the same logic. Another interesting observation is that when you ask Windows to
    execute a command named `foo`, it will search for an executable called `foo.exe` *or* a
    batch file called `foo.bat`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法利用了这样一个事实：当你尝试执行一个二进制文件（例如，使用`os/exec`包中的`Command`函数）时，操作系统会在当前工作目录中查找该二进制文件，如果失败，它将按顺序扫描系统`PATH`环境变量中的每个条目，尝试找到它。对我们有利的是，类Unix系统和Windows遵循相同的逻辑。另一个有趣的观察是，当你要求Windows执行名为`foo`的命令时，它会搜索名为`foo.exe`的可执行文件或名为`foo.bat`的批处理文件。
- en: 'To mock an external process, we need to provide two pieces of information:
    the expected process output and an appropriate status code; an exit status code
    of *zero* would indicate that the process completed successfully. Therefore, if
    we could somehow create an *executable* shell script that prints out the expected
    output before exiting with a particular status code and prepend its path to the *front* of
    the system''s `PATH` variable, we could trick the operating system into executing
    our script instead of the real binary!'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟外部进程，我们需要提供两块信息：预期的进程输出和适当的状态码；状态码为*零*表示进程成功完成。因此，如果我们能够创建一个*可执行*的shell脚本，在退出时以特定的状态码打印出预期的输出，并将它的路径添加到系统`PATH`变量的*前面*，我们就可以欺骗操作系统执行我们的脚本而不是真正的二进制文件！
- en: 'At this point, we are entering the realm of OS-specific code. This practice
    will probably be frowned upon by some engineers, with the argument that Go programs
    are *usually* supposed to be portable across operating systems and CPU architectures.
    In this case, however, we just need to deal with two operating system families
    so we can probably get away with it. Let''s take a look at the templates for the
    Unix and Windows shell scripts that our test code will be injecting. Here is the
    one for Unix:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们正在进入特定于操作系统的代码领域。这种做法可能会被一些工程师所不齿，他们认为Go程序应该是跨操作系统和CPU架构可移植的。然而，在这种情况下，我们只需要处理两个操作系统家族，所以我们可能可以这样做。让我们看看我们的测试代码将要注入的Unix和Windows
    shell脚本的模板。以下是Unix的模板：
- en: '[PRE46]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The script uses the here document syntax ^([1]) to output the text between the
    two `!!!EOF!!!` labels in verbatim. Since here documents include an extra, trailing
    line-feed character, we pipe the output to a Perl one-liner to strip it off. The `%s` placeholder
    will be replaced with the text (which can span several lines) that we want our
    command to output. Finally, the `%d` placeholder will be replaced with the exit
    code that the command will return.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用here文档语法`^([1])`来输出两个`!!!EOF!!!`标签之间的文本。由于here文档包含一个额外的、尾随的换行符，我们将输出通过Perl单行命令管道传递，以去除它。`%s`占位符将被我们希望命令输出的文本（可能跨越多行）替换。最后，`%d`占位符将被命令返回的退出码替换。
- en: 'The Windows version is much simpler since here documents are not supported
    by the built-in shell interpreter (`cmd.exe`). Due to this, I have opted to write
    the output to a file and just have the shell script print it to the standard output.
    Here''s what this looks like:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 版本要简单得多，因为在这里文档不支持内置的shell解释器（`cmd.exe`）。因此，我选择将输出写入文件，并让shell脚本将其打印到标准输出。下面是这个过程的示例：
- en: '[PRE47]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, the `%s` placeholder will be replaced with the path to the external
    file containing the output for the mocked command and, as before, the `%d` placeholder
    will be replaced with the exit code for the command.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`%s`占位符将被替换为包含模拟命令输出的外部文件的路径，并且，像之前一样，`%d`占位符将被替换为命令的退出码。
- en: 'In our test file, we will define a helper function called `mockCmdOutput`.
    Due to space constraints, I will not be including the full listing of the function
    here but rather a short synopsis of how it works (for the full implementation,
    you can check out the `Chapter04/pinger` sources). In a nutshell, `mockCmdOutput` does
    the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试文件中，我们将定义一个名为`mockCmdOutput`的辅助函数。由于空间限制，我不会在这里列出函数的完整代码，而是简要说明其工作原理（完整实现，您可以查看`Chapter04/pinger`源代码）。简而言之，`mockCmdOutput`执行以下操作：
- en: Creates a temporary folder that will be automatically removed after the test
    completes
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个临时文件夹，测试完成后将自动删除
- en: Selects the appropriate shell script template, depending on the operating system
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据操作系统选择合适的shell脚本模板
- en: Writes the shell script to the temporary folder and changes its permissions
    so that it becomes executable (important for Unix-like systems)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将shell脚本写入临时文件夹，并更改其权限以便使其可执行（对于类Unix系统来说很重要）
- en: Prepends the temporary folder to the beginning of the `PATH` environment variable
    for the currently running process (`go test`)
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将临时文件夹添加到当前运行进程（`go test`）的`PATH`环境变量开头
- en: 'Since `mockCmdOutput` modifies the system path, we *must* ensure that it gets
    reset to its original value *before* each of our tests runs. We can easily achieve
    this by grouping our tests into a `gocheck` test suite and providing a test setup
    function to save the original `PATH` value and a test teardown function to restore
    it from the saved value. With all the plumbing in place, here is how we can write
    a test function that mocks the output of `ping`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`mockCmdOutput`修改了系统路径，我们必须确保在每个测试运行之前将其重置到原始值。我们可以通过将我们的测试分组到一个`gocheck`测试套件中，并提供一个保存原始`PATH`值的测试设置函数以及一个从保存值中恢复的测试清理函数来轻松实现这一点。在所有管道就绪后，以下是我们可以编写模拟`ping`输出的测试函数的方法：
- en: '[PRE48]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To make sure that the command was mocked correctly, we set up our test to do
    a round-trip measurement to localhost (typically taking 1 ms or less) and mock
    the `ping` command to return a ridiculously high number (42 seconds). Try running
    the test on OS X, Linux, or Windows; you will always get consistent results.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保命令被正确模拟，我们设置测试以对localhost进行往返测量（通常需要1毫秒或更少的时间）并模拟`ping`命令返回一个荒谬的高数值（42秒）。尝试在OS
    X、Linux或Windows上运行测试；你将始终得到一致的结果。
- en: Testing timeouts is easy when you have all the time in the world!
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你有无限的时间时，测试超时变得非常简单！
- en: I am pretty sure that, at some point, you have written some code that relies
    on the time-keeping functions provided by the standard library's `time` package.
    Perhaps it's some code that periodically polls a remote endpoint – a great case
    for using `time.NewTicker` – or maybe you are using `time.After` to implement
    a timeout mechanism inside a go-routine that waits for an event to occur. In a
    slightly different scenario, using `time.NewTimer` to provide your server code
    with ample time to drain all its connections before shutting down would also be
    a stellar idea.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确定，在某个时候，你编写过一些依赖于标准库`time`包提供的时间管理函数的代码。可能是一些定期轮询远程端点的代码——使用`time.NewTicker`是一个很好的案例——或者你可能正在使用`time.After`在等待事件发生的goroutine中实现超时机制。在稍微不同的场景中，使用`time.NewTimer`为你的服务器代码提供足够的时间在关闭前清空所有连接也是一个绝妙的主意。
- en: However, testing code that uses any of these patterns is not a trivial thing.
    For example, let's say that you are trying to test a piece of code that blocks
    until an event is received or a specific amount of time elapses without receiving
    an event. In the latter case, it would return some sort of timeout error to the
    caller. To verify that the timeout logic works as expected and to avoid locking
    up the test runner if the blocking code never returns, the typical approach would
    be to spin up a go-routine that runs the blocking code and then signals (for example, over
    a channel) when the expected error is returned. The test function that starts
    the go-routine would then use a `select` block to wait for either a success signal
    from the go-routine or for a fixed amount of time to elapse, after which it would
    automatically fail the test.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试使用这些模式中的任何一种的代码并不是一件简单的事情。例如，假设你正在尝试测试一段代码，该代码会阻塞直到接收到事件或在没有接收到事件的情况下经过特定的时间。在后一种情况下，它会向调用者返回某种超时错误。为了验证超时逻辑按预期工作，并避免如果阻塞代码永远不会返回而导致测试运行器锁定，典型的做法是启动一个goroutine来运行阻塞代码，并在返回预期的错误时通过（例如，通过一个channel）发出信号。启动goroutine的测试函数将使用`select`块等待goroutine的成功信号或固定时间的流逝，之后它会自动失败测试。
- en: If we were to apply this approach, how long should such a test wait for before
    giving up? If the max wait time for the blocking piece of code is known in advance
    (for example, defined as a *constant*), then things are relatively easy; our test
    needs to wait for at least that amount of time, *plus* some extra time to account
    for speed discrepancies when running tests in different environments (for example, locally
    versus on the CI). Failure to account for these discrepancies can lead to flaky
    tests – tests that *randomly* fail, making your CI system vehemently complain.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采用这种方法，这样的测试在放弃之前应该等待多长时间？如果已知阻塞代码的最大等待时间（例如，定义为*常量*），那么事情相对简单；我们的测试至少需要等待那么长时间，*加上*一些额外时间来考虑在不同环境中运行测试时的速度差异（例如，本地与CI）。未能考虑到这些差异可能导致测试不稳定——这些测试可能会*随机*失败，让你的CI系统激烈地抱怨。
- en: Things are much easier if the timeout is configurable or at least specified
    as a *global variable* that our tests can patch while they are executing. What
    if, however, the test time is specified as a constant, but its value is in the
    order of a couple of seconds. Clearly, having several tests that run for that
    amount of time literally doing *nothing but waiting* is counter-productive.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果超时是可配置的，或者至少指定为一个*全局变量*，我们的测试可以在执行时修补它，事情就会容易得多。然而，如果测试时间被指定为一个常量，但其值仅为几秒钟的量级，显然，有多个测试运行了那么长时间实际上只是在*等待*，这是适得其反的。
- en: Similarly, in some cases, timeouts might be calculated via some formula that
    includes a random component. That would make the timeout much harder to predict
    in a deterministic way without resorting to hacks such as setting the random number
    generator's seed to a specific value. Of course, in this scenario, our tests would
    just break if another engineer even slightly tweaked the formula that's used to
    calculate the timeouts.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在某些情况下，超时可能通过包含随机因子的公式来计算。这将使得在没有求助于诸如将随机数生成器的种子设置为特定值之类的技巧的情况下，以确定性的方式预测超时变得更加困难。当然，在这种情况下，如果另一个工程师稍微调整了用于计算超时的公式，我们的测试就会直接失败。
- en: 'The `Chapter04/dialer` package is an interesting case for further examination
    as it exhibits both issues that I''ve described here: long wait times that are
    calculated via a formula! This package provides a dialing wrapper that overlays
    an exponential backoff retry mechanism on top of a network dialing function (for
    example, `net.Dial`).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter04/dialer`包是一个值得进一步研究的有趣案例，因为它展示了我在这里描述的两个问题：通过公式计算的长等待时间！这个包提供了一个拨号包装器，它将指数退避重试机制叠加在网络拨号函数（例如，`net.Dial`）之上。'
- en: 'To create a new retrying dialer, we need to call the `NewRetryingDialer` constructor:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的重试拨号器，我们需要调用`NewRetryingDialer`构造函数：
- en: '[PRE49]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The caller provides a `context.Context` instance, which can be used to abort
    pending dial attempts if, for instance, the application receives a signal to shut
    down. Now, let''s move on to the meat of the dialer implementation – the `Dial` call:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者提供了一个`context.Context`实例，它可以用来在例如，应用程序收到关闭信号时取消挂起的拨号尝试。现在，让我们继续探讨拨号器实现的要点——`Dial`调用：
- en: '[PRE50]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is a pretty straightforward implementation: each time a dial attempt fails,
    we invoke the `expBackoff` helper to calculate the wait time for the next attempt.
    Then, we block until the wait time elapses or the context gets cancelled. Finally,
    if we happen to exceed the maximum configured number of retry attempts, the code
    will automatically bail out and return an error to the caller. How about writing
    a short test to verify that the preceding code handles timeouts as expected? This
    is what it would look like:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的实现：每次拨号尝试失败时，我们调用`expBackoff`辅助函数来计算下一次尝试的等待时间。然后，我们阻塞直到等待时间结束或上下文被取消。最后，如果我们意外地超过了配置的最大重试次数，代码将自动退出并返回错误给调用者。写一个简短的测试来验证前面的代码是否按预期处理超时如何？这将是它的样子：
- en: '[PRE51]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Running the preceding test yields the following output:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的测试会产生以下输出：
- en: '![](img/a8d7fa75-add5-4684-aae9-153d9ffdff2b.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8d7fa75-add5-4684-aae9-153d9ffdff2b.png)'
- en: 'Figure 6: Testing the retrying dialer with a real clock'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：使用真实时钟测试重试拨号器
- en: Success! The test passed. But hold on a minute; look at the test's runtime! *9
    seconds*!!! Surely we can do better than this. Wouldn't it be great if we could
    somehow mock time in Go as we do when writing tests for other programming languages?
    It turns out that it is indeed possible with the help of packages such as `jonboulle/clockwork` ^([2]) and `juju/clock` ^([8]).
    We will be using the latter package for our testing purposes as it also supports
    mock timers.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！测试通过了。但是等等；看看测试的运行时间！*9秒*！！！我们难道不能做得更好吗？如果我们可以像为其他编程语言编写测试时那样在Go中模拟时间，那岂不是太棒了？实际上，借助像`jonboulle/clockwork`和`juju/clock`这样的包，这是可能的[2]。我们将使用后者包进行测试，因为它还支持模拟计时器。
- en: The `juju/clock` package exposes a `Clock` interface whose method signatures
    match the functions that are exported by the built-in `time` package. What's more,
    it provides a real clock implementation (`juju.WallClock`) that we should be injecting
    into production code, as well as a fake clock implementation that we can manipulate
    within our tests.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`juju/clock`包暴露了一个`Clock`接口，其方法签名与内置`time`包导出的函数相匹配。更重要的是，它提供了一个真实的时钟实现（`juju.WallClock`），我们应该将其注入到生产代码中，以及一个我们可以操纵于测试中的模拟时钟实现。'
- en: 'If we can inject a `clock.Clock` instance into the `RetryingDialer` struct,
    we can use it as a replacement for the `time.After` call in the retry code. That''s
    easy: just modify the dialer constructor argument list so that it includes a clock
    instance.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将一个`clock.Clock`实例注入到`RetryingDialer`结构体中，我们就可以用它来替换重试代码中的`time.After`调用。这很简单：只需修改dialer构造函数参数列表，使其包括一个时钟实例。
- en: 'Now, let''s create a copy of the previous test but this time inject a fake
    clock into the dialer. To control the time, we will spin up a go-routine to keep
    advancing the clock by a fixed amount of time until the test completes. For brevity,
    the following listing only includes the code for controlling the clock; other
    than that, the rest of the test''s setup and its expectations are exactly the
    same as before:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个之前测试的副本，但这次将一个模拟时钟注入到dialer中。为了控制时间，我们将启动一个go-routine，通过固定的时间间隔不断推进时钟，直到测试完成。为了简洁，以下列表仅包括控制时钟的代码；除此之外，测试的其余设置及其期望与之前完全相同：
- en: '[PRE52]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As expected, our new test also passes successfully. However, compared to the
    previous test run, the new test ran in a fraction of the time – just 0.010s:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们的新测试也成功通过了。然而，与之前的测试运行相比，新的测试只用了极短的时间——仅为0.010秒：
- en: '![](img/ce947238-e5ef-42b5-906b-4a67e19babaf.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图7](img/ce947238-e5ef-42b5-906b-4a67e19babaf.png)'
- en: 'Figure 7: Testing the retrying dialer with a fake clock'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：使用模拟时钟测试重试dialer
- en: Personally speaking, fake clocks are one of my favorite test primitives. If
    you are not using fake clocks in your tests, I would strongly recommend that you
    at least experiment with them. I am sure that you will also reach the conclusion
    that fake clocks are a great tool for writing well-behaved tests for any piece
    of code that deals with some aspect of time. Moreover, increasing the stability
    of your test suites is a fair trade-off for the small bit of refactoring that's
    required to introduce clocks into your existing code base.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，模拟时钟是我最喜欢的测试原语之一。如果你在测试中没有使用模拟时钟，我强烈建议你至少尝试一下。我相信你也会得出结论，模拟时钟是编写任何处理时间方面的代码的良好行为的测试的绝佳工具。此外，通过在现有的代码库中引入时钟进行少量重构来提高测试套件的稳定性，这是一个合理的权衡。
- en: Summary
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'As the old proverb goes: you cannot build a house without good foundations.
    The same principle also applies to software engineering. Having a solid test infrastructure
    in place goes a long way to allowing engineers to work on new features while being
    confident that their changes will not break the existing code.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如同古老的谚语所说：没有良好的基础就无法建造房屋。同样的原则也适用于软件工程。拥有一个稳固的测试基础设施对于工程师在开发新功能的同时，有信心他们的更改不会破坏现有代码，起到了至关重要的作用。
- en: Through the course of this chapter, we performed a deep dive into the different
    types of testing that you need to be aware of when working on medium- to large-scale
    systems. To begin with, we discussed the concept of unit testing, the essential
    *must-have* type of test for all projects, regardless of size, whose primary role
    is to ensure that individual units of code work as expected in isolation. Then,
    we tackled more complex patterns, such as integration and functional testing,
    which verify that units and, by extension, the complete system work harmoniously
    together. The last part of this chapter was dedicated to exploring advanced test
    concepts such as smoke tests and chaos testing and concluded with a list of practical
    tips and tricks for writing tests in a more efficient manner.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了在开发中到大型系统时需要了解的不同类型的测试。首先，我们讨论了单元测试的概念，这是所有项目的基本测试类型，无论大小，其主要作用是确保代码的各个单元在独立情况下按预期工作。然后，我们处理了更复杂的模式，如集成和功能测试，这些测试验证单元以及由此扩展的整个系统能够和谐地一起工作。本章的最后部分致力于探索高级测试概念，如冒烟测试和混沌测试，并以一系列编写测试的实用技巧和窍门结束。
- en: Now, it's time for you to put on your software engineering hat and put all of
    the knowledge you have acquired so far to good use. To this end, over the course
    of the following chapters, we will be speccing out and building, from scratch,
    a complete end-to-end system using Go. This system will serve as a sandbox for
    the practical exploration of each of the concepts we will introduce throughout
    the rest of this book.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候戴上你的软件工程帽子，将你迄今为止所获得的所有知识运用到实践中了。为此，在接下来的章节中，我们将从头开始，使用Go语言构建一个完整的端到端系统。这个系统将作为我们在本书其余部分介绍的所有概念的实践探索的沙盒。
- en: Questions
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a stub and a mock?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟和存根之间有什么区别？
- en: Explain how fake objects work and describe an example scenario where you would
    opt to use a fake object instead of a mock.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释一下模拟对象是如何工作的，并描述一个场景，说明你为什么选择使用模拟对象而不是模拟。
- en: What are the main components of a table-driven test?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表驱动测试的主要组成部分是什么？
- en: What is the difference between a unit test and an integration test?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试和集成测试之间有什么区别？
- en: What is the difference between an integration test and a functional test?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成测试和功能测试之间有什么区别？
- en: Describe the *ambassador* pattern and how it can be exploited to safely run
    tests in production.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述*大使*模式以及如何利用它安全地在生产环境中运行测试。
- en: Further reading
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Bash manual**: here documents: [https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Here-Documents](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Here-Documents).'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Bash手册**: 这里文档：[https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Here-Documents](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Here-Documents).'
- en: '`clockwork`: A fake clock for `golang`: [https://github.com/jonboulle/clockwork](https://github.com/jonboulle/clockwork).'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clockwork`: `golang`的模拟时钟：[https://github.com/jonboulle/clockwork](https://github.com/jonboulle/clockwork).'
- en: '`gocheck`: Rich testing for the Go language: [http://labix.org/gocheck](http://labix.org/gocheck).'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gocheck`: Go语言的丰富测试：[http://labix.org/gocheck](http://labix.org/gocheck).'
- en: '`gomock`: A mocking framework for the Go programming language: [https://github.com/golang/mock](https://github.com/golang/mock).'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gomock`: Go编程语言的模拟框架：[https://github.com/golang/mock](https://github.com/golang/mock).'
- en: 'Meszaros, Gerard: *XUnit Test Patterns: Refactoring Test Code*. Upper Saddle
    River, NJ, USA : Prentice Hall PTR, 2006 – ISBN 0131495054 ([https://www.worldcat.org/title/xunit-test-patterns-refactoring-test-code/oclc/935197390](https://www.worldcat.org/title/xunit-test-patterns-refactoring-test-code/oclc/935197390)).'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Meszaros, Gerard: 《XUnit测试模式：重构测试代码》。Upper Saddle River, NJ, USA：Prentice Hall
    PTR，2006 – ISBN 0131495054 ([https://www.worldcat.org/title/xunit-test-patterns-refactoring-test-code/oclc/935197390](https://www.worldcat.org/title/xunit-test-patterns-refactoring-test-code/oclc/935197390)).'
- en: '**Selenium**: Browser automation: [https://www.seleniumhq.org](https://www.seleniumhq.org).'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Selenium**: 浏览器自动化：[https://www.seleniumhq.org](https://www.seleniumhq.org).'
- en: '`testify`: A toolkit with common assertions and mocks that plays nicely with
    the standard library: [https://github.com/stretchr/testify](https://github.com/stretchr/testify).'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`testify`: 一个具有常见断言和模拟的工具包，与标准库配合良好：[https://github.com/stretchr/testify](https://github.com/stretchr/testify).'
- en: '`juju/clock`: Clock definition and a testing clock: [https://github.com/juju/clock](https://github.com/juju/clock).'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`juju/clock`: 时钟定义和测试时钟：[https://github.com/juju/clock](https://github.com/juju/clock).'
