["```go\nfunc WithPinnedCertVerification(pkFingerprint []byte, tlsConfig *tls.Config) TLSDialer {\n    return func(network, addr string) (net.Conn, error) {\n       conn, err := tls.Dial(network, addr, tlsConfig)\n        if err != nil {\n            return nil, err\n        }\n        if err := verifyPinnedCert(pkFingerprint, conn.ConnectionState().PeerCertificates); err != nil { _ = conn.Close()\n            return nil, err\n        }\n        return conn, nil\n    }\n}\n```", "```go\nfunc verifyPinnedCert(pkFingerprint []byte, peerCerts []*x509.Certificate) error {\n    for _, cert := range peerCerts {\n        certDER, err := x509.MarshalPKIXPublicKey(cert.PublicKey)\n        if err != nil {\n            return xerrors.Errorf(\"unable to serialize certificate public key: %w\", err)\n        }\n        fingerprint := sha256.Sum256(certDER)\n\n        // Matched cert PK fingerprint to the one provided.\n        if bytes.Equal(fingerprint[:], pkFingerprint) {\n            return nil\n        }\n    }\n    return xerrors.Errorf(\"remote server presented a certificate which does not match the provided fingerprint\")\n}\n```", "```go\nclient := &http.Client{\n    Transport: &http.Transport{\n        DialTLS: dialer.WithPinnedCertVerification(\n            fingerprint, \n            new(tls.Config),\n        ),\n    },\n}\n```", "```go\ntype Flow struct {\n    cfg oauth2.Config\n\n    mu sync.Mutex\n    srvListener net.Listener\n    pendingRequests map[string]chan Result\n}\n```", "```go\nfunc NewOAuthFlow(cfg oauth2.Config, callbackListenAddr, redirectHost string) (*Flow, error) {\n if callbackListenAddr == \"\" {\n callbackListenAddr = \"127.0.0.1:8080\"\n }\n l, err := net.Listen(\"tcp\", callbackListenAddr)\n if err != nil {\n return nil, xerrors.Errorf(\"cannot create listener for handling OAuth redirects: %w\", err)\n }\n if redirectHost == \"\" {\n redirectHost = l.Addr().String()\n }\n\n cfg.RedirectURL = fmt.Sprintf(\"http://%s/oauth/redirect\", redirectHost)\n f := &Flow{srvListener: l, cfg: cfg, pendingRequests: make(map[string]chan Result)}\n\n mux := http.NewServeMux()\n mux.HandleFunc(redirectPath, f.handleAuthRedirect)\n go func() { _ = http.Serve(l, mux) }()\n return f, nil\n}\n```", "```go\nfunc (f *Flow) Authenticate() (string, <-chan Result, error) {\n    nonce, err := genNonce(16)\n    if err != nil {\n        return \"\", nil, err\n    }\n\n    authURL := f.cfg.AuthCodeURL(nonce, oauth2.AccessTypeOffline)\n    resCh := make(chan Result, 1)\n    f.mu.Lock()\n    f.pendingRequests[nonce] = resCh\n    f.mu.Unlock()\n\n    return authURL, resCh, nil\n}\n```", "```go\ntype Result struct {\n    authErr error\n    authCode string\n    cfg *oauth2.Config\n}\n```", "```go\nif err := r.ParseForm(); err != nil {\n    w.WriteHeader(http.StatusBadRequest)\n    return\n}\n\nnonce := r.FormValue(\"state\")\ncode := r.FormValue(\"code\")\n```", "```go\nf.mu.Lock()\nresCh, exists := f.pendingRequests[nonce]\nif !exists {\n    f.mu.Unlock()\n    _, _ = fmt.Fprint(w, unknownNonce)\n    return\n}\ndelete(f.pendingRequests, nonce)\nf.mu.Unlock()\n\nresCh <- Result{ authCode: code, cfg: &f.cfg }\nclose(resCh)\n\n_, _ = fmt.Fprint(w, successMsg)\n```", "```go\nfunc (ar *Result) Client(ctx context.Context) (*http.Client, error) {\n    if ar.authErr != nil {\n        return nil, ar.authErr\n    }\n\n    token, err := ar.cfg.Exchange(ctx, ar.authCode)\n    if err != nil {\n        return nil, xerrors.Errorf(\"unable to exchange authentication code with OAuth token: %w\", err)\n    }\n\n    return ar.cfg.Client(ctx, token), nil\n}\n```", "```go\ngo get -u google.golang.org/grpc\ngo get -u github.com/golang/protobuf/protoc-gen-go\n```", "```go\nprotoc --go_out=plugins=grpc:. -I. some-file.proto\n```", "```go\nsyntax = \"proto3\";\npackage geocoding;\n\nmessage Address {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n}\n```", "```go\nimport \"google/protobuf/timestamp.proto\";\n\nmessage Record {\n  bytes data = 1;\n  google.protobuf.Timestamp created_at = 2;\n}\n```", "```go\nmessage Address {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n  AddressType type = 4; // We can only assign an address type value to this field.\n}\n\nenum AddressType {\n  UNKNOWN = 0;\n  HOME = 1;\n  BUSINESS = 2;\n}\n```", "```go\nmessage User {\n  string id = 1;\n  string name = 2;\n}\n\nmessage Users {\n  repeated User user_list = 1;\n  map<string, User> user_by_id = 2;\n}\n```", "```go\nmessage CreateAccountResponse {\n  string correlation_id = 1;\n  oneof payload {\n    Account account = 2;\n    Error error = 3;\n  }\n}\n```", "```go\ntype CreateAccountResponse_Account struct {\n    Account *Account `protobuf:\"bytes,1,opt,name=account,proto3,oneof\"`\n}\n\ntype CreateAccountResponse_Error struct {\n    Error *Error `protobuf:\"bytes,2,opt,name=error,proto3,oneof\"`\n}\n```", "```go\ntype isCreateAccountResponse_Payload interface {\n    isCreateAccountResponse_Payload()\n}\n\nfunc (*CreateAccountResponse_Account) isCreateAccountResponse_Payload() {}\nfunc (*CreateAccountResponse_Error) isCreateAccountResponse_Payload() {}\n```", "```go\nimport \"google/protobuf/any.proto\";\n\nmessage Envelope {\n  string id = 1;\n  google.protobuf.Any payload = 2;\n}\n```", "```go\nfunc wrapInEnvelope(id string, payload proto.Message) (*Envelope, error) {\n    any, err := ptypes.MarshalAny(payload)\n    if err != nil {\n        return nil, err\n    }\n\n    return &Envelope{\n        Id: id,\n        Payload: any,\n    }, nil\n}\n```", "```go\nfunc handleEnvelope(env *Envelope) error {\n    if env.Payload == nil {\n        return nil\n    }\n\n    switch env.Payload.GetTypeUrl() {\n    case \"type.googleapis.com/Record\":\n        var rec *Record\n        if err := ptypes.UnmarshalAny(env.Payload, &rec); err != nil {\n            return err\n        }\n        return handleRecord(rec)\n    default:\n        return ErrUnknownMessageType\n    }\n}\n```", "```go\nfunc serve(addr string, serverImpl FooServer) error {\n    l, err := net.Listen(\"tcp\", addr)\n    if err != nil {\n        return err\n    }\n    grpcServer := grpc.NewServer()\n    RegisterFooServer(grpcServer, serverImpl)\n    return grpcServer.Serve(l)\n}\n```", "```go\nmessage CreateAccountRequest {\n  string user_name = 1;\n  string password = 2;\n  string email = 3;\n}\n\nmessage CreateAccountResponse {\n  string account_id = 1;\n}\n\nservice AccountService {\n  rpc CreateAccount (CreateAccountRequest) returns (CreateAccountResponse);\n}\n```", "```go\nvar _ AccountServiceServer = (*server)(nil)\n\nfunc (*server) CreateAccount(_ context.Context, req *CreateAccountRequest) (*CreateAccountResponse, error) {\n    accountID, err := createAccount(req)\n    if err != nil {\n        return nil, err\n    }\n\n    return &CreateAccountResponse{AccountId: accountID}, nil\n}\n```", "```go\nfunc (a *accountAPI) CreateAccount(account model.Account) (string, error) {\n    req := makeCreateAccountRequest(account)\n    res, err := a.accountCli.CreateAccount(context.Background(), req)\n    if err != nil {\n        return \"\", err\n    }\n    return res.AccountId, nil\n}\n```", "```go\nmessage CryptoPriceRequest {\n  string crypto_type = 1;\n}\n\nmessage CryptoPrice {\n  double price = 1;\n}\n\nservice PriceService {\n  rpc StreamCryptoPrice (CryptoPriceRequest) returns (stream CryptoPrice);\n}\n```", "```go\nvar _ PriceServiceServer = (*server)(nil)\n\nfunc (*server) StreamCryptoPrice(req *CryptoPriceRequest, resSrv PriceService_StreamCryptoPriceServer) error {\n    for price := range priceStreamFor(req.CryptoType) {\n        if err := resSrv.Send(&CryptoPrice{Price: price}); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```", "```go\nfunc (a *priceAPI) ListPrices(cryptoType string) error {\n    stream, err := a.priceCli.StreamCryptoPrice(context.Background(), &CryptoPriceRequest{CryptoType: cryptoType})\n    if err != nil {\n        return err\n    }\n\n    for {\n        res, err := stream.Recv()\n        if err != nil {\n            if err == io.EOF {\n                return nil\n            }\n            return err\n        }\n        updateListing(cryptoType, res.Price)\n    }\n}\n```", "```go\nsyntax = \"proto3\";\n\nmessage Observation {\n  double value = 1;\n}\n\nmessage StatsResponse {\n  int32 count = 1;\n  double min = 2;\n  double max = 3;\n  double avg = 4;\n}\n\nservice StatsService {\n  rpc CalculateStats (stream Observation) returns (StatsResponse);\n}\n```", "```go\nfunc (a *statsAPI) GetStats(valueCh <-chan float32) (*Stats, error) {\n    stream, err := a.statsCli.CalculateStats(context.Background())\n    if err != nil {\n        return nil, err\n    }\n    for val := range valueCh {\n        if err := stream.Send(&Observation{Value: val}); err != nil {\n            return nil, err\n        }\n    }\n    res, err := stream.CloseAndRecv()\n    if err != nil {\n        return nil, err\n    }\n    return makeStats(res), err\n}\n```", "```go\nvar _ StatsServiceServer = (*server)(nil)\n\nfunc (*server) CalculateStats(statsSrv StatsService_CalculateStatsServer) error {\n    var observations []*Observation\n    for {\n        stat, err := statsSrv.Recv()\n        if err == nil {\n            if err == io.EOF {\n                return statsSrv.SendAndClose(calcStats(observations))\n            }\n\n            return err\n        }\n        observations = append(observations, stat)\n    }\n}\n```", "```go\nmessage EchoMessage {\n  string message = 1;\n}\n\nservice EchoService {\n  rpc Echo (stream EchoMessage) returns (stream EchoMessage);\n}\n```", "```go\nfunc (*server) Echo(echoSrv EchoService_EchoServer) error {\n    for {\n        msg, err := echoSrv.Recv()\n        if err != nil {\n            if err == io.EOF {\n                return nil\n            }\n            return err\n        }\n\n        if err := echoSrv.Send(msg); err != nil {\n            return err\n        }\n    }\n}\n```", "```go\nfunc (a *echoAPI) Echo(msgCount int) error {\n    stream, err := a.echoCLI.Echo(context.Background())\n    if err != nil {\n        return err\n    }\n\n    errCh := make(chan error, 1)\n    go processEcho(stream, errCh)\n    if err := sendEcho(stream, msgCount); err != nil {\n        return err\n    }\n    for err := range errCh {\n        return err\n    }\n    return nil\n}\n```", "```go\nfunc processEcho(stream EchoService_EchoClient, errCh chan<- error) {\n    defer close(errCh)\n    for {\n        msg, err := stream.Recv()\n        if err != nil {\n            if err != io.EOF {\n                errCh <- err\n            }\n            return\n        }\n        fmt.Printf(\"Received echo for: %q\\n\", msg)\n    }\n}\n```", "```go\nfunc sendEcho(stream EchoService_EchoClient, msgCount int) error {\n    for i := 0; i < msgCount; i++ {\n        if err := stream.Send(&EchoMessage{Message: fmt.Sprint(i)}); err != nil {\n            return err\n        }\n    }\n    return stream.CloseSend()\n}\n```", "```go\nsyntax=\"proto3\";\npackage proto;\n\nimport \"google/protobuf/timestamp.proto\";\nimport \"google/protobuf/empty.proto\";\n\nservice LinkGraph {\n  rpc UpsertLink(Link) returns (Link);\n  rpc UpsertEdge(Edge) returns (Edge);\n  rpc RemoveStaleEdges(RemoveStaleEdgesQuery) returns (google.protobuf.Empty);\n  rpc Links(Range) returns (stream Link);\n  rpc Edges(Range) returns (stream Edge);\n}\n```", "```go\nmessage Link {\n  bytes uuid = 1;\n  string url = 2;\n  google.protobuf.Timestamp retrieved_at = 3;\n}\n```", "```go\nmessage Edge {\n  bytes uuid = 1;\n  bytes src_uuid = 2;\n  bytes dst_uuid = 3;\n  google.protobuf.Timestamp updated_at = 4;\n}\n```", "```go\nmessage RemoveStaleEdgesQuery {\n  bytes from_uuid = 1;\n  google.protobuf.Timestamp updated_before = 2;\n}\n```", "```go\nmessage Range {\n bytes from_uuid = 1;\n bytes to_uuid = 2;\n\n // Return results before this filter timestamp.\n google.protobuf.Timestamp filter = 3;\n}\n```", "```go\nsyntax=\"proto3\";\npackage proto;\n\nimport \"google/protobuf/timestamp.proto\";\nimport \"google/protobuf/empty.proto\";\n\nservice TextIndexer {\n  rpc Index(Document) returns (Document);\n  rpc UpdateScore(UpdateScoreRequest) returns (google.protobuf.Empty);\n  rpc Search(Query) returns (stream QueryResult);\n}\n```", "```go\nmessage Document {\n  bytes link_id = 1;\n  string url = 2;\n  string title = 3;\n  string content = 4;\n  google.protobuf.Timestamp indexed_at = 5;\n}\n```", "```go\nmessage UpdateScoreRequest {\n  bytes link_id = 1;\n  double page_rank_score = 2;\n}\n```", "```go\nmessage Query {\n  Type type = 1;\n  string expression = 2;\n  uint64 offset = 3;\n  enum Type {\n    MATCH = 0;\n    PHRASE = 1;\n  }\n}\n\nmessage QueryResult {\n  oneof result {\n    uint64 doc_count = 1;\n    Document doc = 2;\n  }\n}\n```"]