["```go\nFROM golang:1.13 AS builder\n\nWORKDIR $GOPATH/src/github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang\nCOPY . .\nRUN make deps\n\nRUN GIT_SHA=$(git rev-parse --short HEAD) && \\\n CGO_ENABLED=0 GOARCH=amd64 GOOS=linux \\\n go build -a \\\n -ldflags \"-extldflags '-static' -w -s -X main.appSha=$GIT_SHA\" \\\n -o /go/bin/linksrus-monolith \\\n github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang/Chapter10/linksrus\n```", "```go\nFROM alpine:3.10\nRUN apk update && apk add ca-certificates && rm -rf /var/cache/apk/*\nCOPY --from=builder /go/bin/linksrus-monolith /go/bin/linksrus-monolith\n\nENTRYPOINT [\"/go/bin/linksrus-monolith\"]\n```", "```go\nminikube start --kubernetes-version=v1.15.3 \\\n               --memory=4g \\\n               --network-plugin=cni\n```", "```go\n{\n \"insecure-registries\" : [\n \"$MINIKUBE_IP:5000\"\n ]\n}\n```", "```go\ntype Range struct {\n start       uuid.UUID\n rangeSplits []uuid.UUID\n}\n```", "```go\nfunc NewFullRange(numPartitions int) (Range, error) {\n return NewRange(\n uuid.Nil,\n uuid.MustParse(\"ffffffff-ffff-ffff-ffff-ffffffffffff\"),\n numPartitions,\n )\n}\n```", "```go\nif bytes.Compare(start[:], end[:]) >= 0 {\n return Range{}, xerrors.Errorf(\"range start UUID must be less than the end UUID\")\n} else if numPartitions <= 0 {\n return Range{}, xerrors.Errorf(\"number of partitions must be at least equal to 1\")\n}\n\n// Calculate the size of each partition as: ((end - start + 1) / numPartitions)\ntokenRange := big.NewInt(0)\npartSize := big.NewInt(0)\npartSize = partSize.Sub(big.NewInt(0).SetBytes(end[:]), big.NewInt(0).SetBytes(start[:]))\npartSize = partSize.Div(partSize.Add(partSize, big.NewInt(1)), big.NewInt(int64(numPartitions)))\n```", "```go\nvar to uuid.UUID\nvar err error\nvar ranges = make([]uuid.UUID, numPartitions)\nfor partition := 0; partition < numPartitions; partition++ {\n if partition == numPartitions-1 {\n to = end\n } else {\n tokenRange.Mul(partSize, big.NewInt(int64(partition+1)))\n if to, err = uuid.FromBytes(tokenRange.Bytes()); err != nil {\n return nil, xerrors.Errorf(\"partition range: %w\", err)\n }\n }\n ranges[partition] = to\n}\nreturn &Range{start: start, rangeSplits: ranges}, nil\n```", "```go\nfunc (r *Range) Extents() (uuid.UUID, uuid.UUID) {\n return r.start, r.rangeSplits[len(r.rangeSplits)-1]\n}\n\nfunc (r *Range) PartitionExtents(partition int) (uuid.UUID, uuid.UUID, error) {\n if partition < 0 || partition >= len(r.rangeSplits) {\n return uuid.Nil, uuid.Nil, xerrors.Errorf(\"invalid partition index\")\n }\n if partition == 0 {\n return r.start, r.rangeSplits[0], nil\n }\n return r.rangeSplits[partition-1], r.rangeSplits[partition], nil\n}\n```", "```go\nfunc (det FromSRVRecords) PartitionInfo() (int, int, error) {\n hostname, err := os.Hostname()\n if err != nil {\n return -1, -1, xerrors.Errorf(\"partition detector: unable to detect host name: %w\", err)\n }\n tokens := strings.Split(hostname, \"-\")\n partition, err := strconv.ParseInt(tokens[len(tokens)-1], 10, 32)\n if err != nil {\n return -1, -1, xerrors.Errorf(\"partition detector: unable to extract partition number from host name suffix\")\n }\n _, addrs, err := net.LookupSRV(\"\", \"\", det.srvName)\n if err != nil {\n return -1, -1, ErrNoPartitionDataAvailableYet\n }\n return int(partition), len(addrs), nil\n}\n```", "```go\ntype Service interface {\n Name() string\n Run(context.Context) error\n}\n```", "```go\ntype Config struct {\n GraphAPI GraphAPI\n IndexAPI IndexAPI\n PrivateNetworkDetector crawler_pipeline.PrivateNetworkDetector\n URLGetter crawler_pipeline.URLGetter\n PartitionDetector partition.Detector\n Clock clock.Clock\n\n Fand so onhWorkers int\n UpdateInterval time.Duration\n ReIndexThreshold time.Duration\n Logger *logrus.Entry\n}\n```", "```go\ntype GraphAPI interface {\n UpsertLink(link *graph.Link) error\n UpsertEdge(edge *graph.Edge) error\n RemoveStaleEdges(fromID uuid.UUID, updatedBefore time.Time) error\n Links(fromID, toID uuid.UUID, retrievedBefore time.Time) (graph.LinkIterator, error)\n}\n\ntype IndexAPI interface {\n Index(doc *index.Document) error\n}\n```", "```go\ntype Config struct {\n GraphAPI GraphAPI\n IndexAPI IndexAPI\n PartitionDetector partition.Detector\n Clock clock.Clock\n\n ComputeWorkers int\n UpdateInterval time.Duration\n Logger *logrus.Entry\n}\n```", "```go\ntype GraphAPI interface {\n Links(fromID, toID uuid.UUID, retrievedBefore time.Time) (graph.LinkIterator, error)\n Edges(fromID, toID uuid.UUID, updatedBefore time.Time) (graph.EdgeIterator, error)\n}\n\ntype IndexAPI interface {\n UpdateScore(linkID uuid.UUID, score float64) error\n}\n```", "```go\nsvc := &Service{\n router: mux.NewRouter(),\n cfg:    cfg,\n}\n\nsvc.router.HandleFunc(indexEndpoint, svc.renderIndexPage).Methods(\"GET\")\nsvc.router.HandleFunc(searchEndpoint, svc.renderSearchResults).Methods(\"GET\")\nsvc.router.HandleFunc(submitLinkEndpoint, svc.submitLink).Methods(\"GET\", \"POST\")\nsvc.router.NotFoundHandler = http.HandlerFunc(svc.render404Page)\n```", "```go\nfor resCount := 0; resultIt.Next() && resCount < svc.cfg.ResultsPerPage; resCount++ {\n doc := resultIt.Document()\n matchedDocs = append(matchedDocs, matchedDoc{\n doc: doc,\n summary: highlighter.Highlight(\n template.HTMLEscapeString(\n summarizer.MatchSummary(doc.Content),\n ),\n ),\n })\n}\n```", "```go\npagination := &paginationDetails{\n From:  int(offset + 1),\n To:    int(offset) + len(matchedDocs),\n Total: int(resultIt.TotalCount()),\n}\nif offset > 0 {\n pagination.PrevLink = fmt.Sprintf(\"%s?q=%s\", searchEndpoint, searchTerms)\n if prevOffset := int(offset) - svc.cfg.ResultsPerPage; prevOffset > 0 {\n pagination.PrevLink += fmt.Sprintf(\"&offset=%d\", prevOffset)\n }\n}\nif nextPageOffset := int(offset) + len(matchedDocs); nextPageOffset < pagination.Total {\n pagination.NextLink = fmt.Sprintf(\"%s?q=%s&offset=%d\", searchEndpoint, searchTerms, nextPageOffset)\n}\n```", "```go\nfunc newMatchHighlighter(searchTerms string) *matchHighlighter {\n var regexes []*regexp.Regexp\n for _, token := range strings.Fields(strings.Trim(searchTerms, `\"`)) {\n re, err := regexp.Compile(\n fmt.Sprintf(`(?i)%s`, regexp.QuoteMeta(token)),\n )\n if err != nil {\n continue\n }\n regexes = append(regexes, re)\n }\n\n return &matchHighlighter{regexes: regexes}\n}\n```", "```go\nfunc (h *matchHighlighter) Highlight(sentence string) string {\n for _, re := range h.regexes {\n sentence = re.ReplaceAllStringFunc(sentence, func(match string) string {\n return \"<em>\" + match + \"</em>\"\n })\n }\n return sentence\n}\n```", "```go\ntype Group []Service\n\nfunc (g Group) Run(ctx context.Context) error {...}\n```", "```go\nif ctx == nil {\n ctx = context.Background()\n}\nrunCtx, cancelFn := context.WithCancel(ctx)\ndefer cancelFn()\n```", "```go\nvar wg sync.WaitGroup\nerrCh := make(chan error, len(g))\nwg.Add(len(g))\nfor _, s := range g {\n go func(s Service) {\n defer wg.Done()\n if err := s.Run(runCtx); err != nil {\n errCh <- xerrors.Errorf(\"%s: %w\", s.Name(), err)\n cancelFn()\n }\n }(s)\n}\n```", "```go\n <-runCtx.Done()\n wg.Wait()\n```", "```go\n var err error\n close(errCh)\n for srvErr := range errCh {\n err = multierror.Append(err, srvErr)\n }\n return err\n```", "```go\nfunc runMain(logger *logrus.Entry) error {\n svcGroup, err := setupServices(logger)\n if err != nil {\n return err\n }\n\n ctx, cancelFn := context.WithCancel(context.Background())\n defer cancelFn()\n return svcGroup.Run(ctx)\n} \n```", "```go\ngo func() {\n sigCh := make(chan os.Signal, 1)\n signal.Notify(sigCh, syscall.SIGINT, syscall.SIGHUP)\n select {\n case s := <-sigCh:\n cancelFn()\n case <-ctx.Done():\n }\n}()\n```", "```go\nkubectl apply -f 01-namespaces.yaml\n```", "```go\nhelm install --namespace=linksrus-data --name cdb \\\n    --values chart-settings/cdb-settings.yaml \\\n    --set ImageTag=v19.1.5 \\\n    stable/cockroachdb\n```", "```go\nhelm repo add elastic https://helm.elastic.co \nhelm install --namespace=linksrus-data --name es \\\n    --values chart-settings/es-settings.yaml \\\n    --set imageTag=7.4.0 \\\n    elastic/elasticsearch\n```", "```go\nmake dockerize-and-push\n```", "```go\napiVersion: batch/v1\nkind: Job\nmetadata:\n name: cdb-ensure-schema\n namespace: linksrus-data\nspec:\n template:\n spec:\n containers:\n - name: cdb-schema\n imagePullPolicy: Always\n image: localhost:5000/cdb-schema:latest\n args: \n - \"linkgraph\"\n - \"cdb-cockroachdb-public.linksrus-data\"\n restartPolicy: Never\n```"]