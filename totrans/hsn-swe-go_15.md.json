["```go\nmessage QuotesRequest {\n string SKU = 1;\n}\n\nmessage QuotesResponse {\n repeated Quote quotes = 1;\n}\n\nmessage Quote {\n string vendor = 1;\n double price = 2;\n}\n\nservice QuoteService {\n rpc GetQuote(QuotesRequest) returns (QuotesResponse);\n}\n```", "```go\ntype Provider struct {\n vendorID string\n}\n\nfunc NewProvider(vendorID string) *Provider {\n return &Provider{ vendorID: vendorID }\n}\n```", "```go\nfunc (p *Provider) GetQuote(ctx context.Context, req *proto.QuotesRequest) (*proto.QuotesResponse, error) {\n return &proto.QuotesResponse{\n Quotes: []*proto.Quote{\n &proto.Quote{ Vendor: p.vendorID, Price:  100.0 * rand.Float64() },\n },\n }, nil\n}\n```", "```go\nfunc (p *Provider) Serve(ctx context.Context) (string, error) {\n return doServe(ctx, p, tracer.MustGetTracer(p.vendorID))\n}\n```", "```go\nfunc doServe(ctx context.Context, srv proto.QuoteServiceServer, tracer opentracing.Tracer) (string, error) {\n l, err := net.Listen(\"tcp\", \":0\")\n if err != nil {\n return \"\", err\n }\n tracerOpt := grpc.UnaryInterceptor(otgrpc.OpenTracingServerInterceptor(tracer))\n gsrv := grpc.NewServer(tracerOpt)\n proto.RegisterQuoteServiceServer(gsrv, srv)\n go func() {\n go func() { _ = gsrv.Serve(l) }()\n <-ctx.Done()\n gsrv.Stop()\n _ = l.Close()\n }()\n return l.Addr().String(), nil\n}\n```", "```go\ntype Aggregator struct {\n vendorID      string\n providerAddrs []string\n clients       []proto.QuoteServiceClient\n}\n\nfunc NewAggregator(vendorID string, providerAddrs []string) *Aggregator {\n return &Aggregator{\n vendorID:      vendorID,\n providerAddrs: providerAddrs,\n }\n}\n```", "```go\nfunc (a *Aggregator) Serve(ctx context.Context) (string, error) {\n tracer := tracer.MustGetTracer(a.vendorID)\n tracerClientOpt := grpc.WithUnaryInterceptor(otgrpc.OpenTracingClientInterceptor(tracer))\n\n for _, addr := range a.providerAddrs {\n conn, err := grpc.Dial(addr, grpc.WithInsecure(), tracerClientOpt)\n if err != nil {\n return \"\", xerrors.Errorf(\"dialing provider at %s: %w\", addr, err)\n }\n a.clients = append(a.clients, proto.NewQuoteServiceClient(conn))\n }\n\n return doServe(ctx, a, tracer)\n}\n```", "```go\nfunc (a *Aggregator) GetQuote(ctx context.Context, req *proto.QuotesRequest) (*proto.QuotesResponse, error) {\n // Run requests in parallel and aggregate results\n aggRes := new(proto.QuotesResponse)\n for quotes := range a.sendRequests(ctx, req) {\n aggRes.Quotes = append(aggRes.Quotes, quotes...)\n }\n return aggRes, nil\n}\n```", "```go\nfunc (a *Aggregator) sendRequests(ctx context.Context, req *proto.QuotesRequest) <-chan []*proto.Quote {\n var wg sync.WaitGroup\n wg.Add(len(a.clients))\n resCh := make(chan []*proto.Quote, len(a.clients))\n for _, client := range a.clients {\n go func(client proto.QuoteServiceClient) {\n defer wg.Done()\n if res, err := client.GetQuote(ctx, req); err == nil {\n resCh <- res.Quotes\n }\n }(client)\n }\n go func() {\n wg.Wait()\n close(resCh)\n }()\n return resCh\n}\n```", "```go\nfunc (gw *Gateway) CollectQuotes(ctx context.Context, SKU string) (map[string]float64, error) {\n span, ctx := opentracing.StartSpanFromContext(ctx, \"CollectQuotes\")\n defer span.Finish()\n\n res, err := gw.client.GetQuote(ctx, &proto.QuotesRequest{SKU: SKU})\n if err != nil {\n return nil, err\n }\n\n quoteMap := make(map[string]float64, len(res.Quotes))\n for _, quote := range res.Quotes {\n quoteMap[quote.Vendor] = quote.Price\n }\n return quoteMap, nil\n}\n```", "```go\nvar err error\nproviderAddrs := make([]string, 3)\nfor i := 0; i < len(providerAddrs); i++ {\n provider := service.NewProvider(fmt.Sprintf(\"vendor-%d\", i))\n if providerAddrs[i], err = provider.Serve(ctx); err != nil {\n return nil, err\n }\n}\n```", "```go\naggr1 := service.NewAggregator(\"aggr-1\", providerAddrs[1:])\naggr1Addr, err := aggr1.Serve(ctx)\nif err != nil {\n return nil, err\n}\n```", "```go\naggr0 := service.NewAggregator(\"aggr-0\", []string{providerAddrs[0], aggr1Addr})\naggr0Addr, err := aggr0.Serve(ctx)\nif err != nil {\n return nil, err\n}\n```", "```go\nreturn service.NewGateway(\"api-gateway\", aggr0Addr)\n```", "```go\nfunc runMain(ctx context.Context) error {\n gw, err := deployServices(ctx)\n if err != nil {\n return err\n }\n defer func() { _ = gw.Close() }()\n\n res, err := gw.CollectQuotes(ctx, \"example\")\n if err != nil {\n return err\n }\n fmt.Printf(\"Collected the following quotes:\\n\")\n for k, v := range res {\n fmt.Printf(\"  %q: %3.2f\\n\", k, v)\n }\n return nil\n}\n```", "```go\ndocker run -d --name jaeger \\\n  -p 6831:6831/udp \\\n  -p 16686:16686 \\\n  jaegertracing/all-in-one:1.14\n```", "```go\nfunc GetTracer(serviceName string) (opentracing.Tracer, error) {\n cfg, err := jaegercfg.FromEnv()\n if err != nil {\n return nil, err\n }\n cfg.ServiceName = serviceName\n cfg.Sampler = &jaegercfg.SamplerConfig{ \n Type: jaeger.SamplerTypeConst, \n Param: 1, // Sample all traces generated by our demo\n }\n tracer, closer, err := cfg.NewTracer()\n if err == nil {\n // Omitted: keep track of closer so we can close all tracers when exiting\n return tracer, nil\n }\n return err\n}\n```", "```go\nfunc fetchUserData(url *url.URL) (*user.Data, error) {\n tick := time.Now()\n res, err := http.Get(url.String())\n if err != nil {\n return nil, err\n }\n defer func() { _ = res.Body.Close() }()\n\n logrus.WithFields(logrus.Fields{\n \"url\":  url,\n \"time\": time.Since(tick).String(),\n }).Info(\"retrieved user data\")\n\n // omitted: read and unmarshal user data\n}\n```", "```go\nimport (\n \"log\"\n \"net/http\"\n _ \"net/http/pprof\" // import for side-effects\n)\n\nfunc exposeProfile() {\n go func() {\n log.Println(http.ListenAndServe(\"localhost:6060\", nil))\n }()\n}\n```", "```go\napp.Flags = []cli.Flag{\n cli.StringFlag{\n Name:   \"link-graph-api\",\n EnvVar: \"LINK_GRAPH_API\",\n Usage:  \"The gRPC endpoint for connecting to the link graph\",\n },\n cli.StringFlag{\n Name:   \"text-indexer-api\",\n EnvVar: \"TEXT_INDEXER_API\",\n Usage:  \"The gRPC endpoint for connecting to the text indexer\",\n },\n // omitted: additional flags\n}\n```", "```go\n// Obtain high-level client for link graph.\ndialCtx, cancelFn := context.WithTimeout(ctx, 5*time.Second)\ndefer cancelFn()\nlinkGraphConn, err := grpc.DialContext(dialCtx, linkGraphAPI, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n return nil, nil, xerrors.Errorf(\"could not connect to link graph API: %w\", err)\n}\ngraphCli := linkgraphapi.NewLinkGraphClient(ctx, linkgraphproto.NewLinkGraphClient(linkGraphConn))\n\n// Obtain high-level client for text-indexer.\ndialCtx, cancelFn := context.WithTimeout(ctx, 5*time.Second)\ndefer cancelFn()\nindexerConn, err := grpc.DialContext(dialCtx, textIndexerAPI, grpc.WithInsecure(), grpc.WithBlock())\nif err != nil {\n return nil, nil, xerrors.Errorf(\"could not connect to text indexer API: %w\", err)\n}\nindexerCli := textindexerapi.NewTextIndexerClient(ctx, textindexerproto.NewTextIndexerClient(indexerConn))\n```", "```go\nkind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n namespace: linksrus-data\n name: deny-from-other-namespaces\nspec:\n podSelector:\n matchLabels:\n ingress:\n - from:\n - podSelector: {}\n```", "```go\nkind: NetworkPolicy\napiVersion: networking.k8s.io/v1\nmetadata:\n namespace: linksrus-data\n name: allow-access-to-data-apis\nspec:\n podSelector:\n matchLabels:\n role: data-api\n ingress:\n - from:\n - namespaceSelector:\n matchLabels: \n role: linksrus-components\n```"]