- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章
- en: Software engineering is defined as the application of a systematic, disciplined,
    quantifiable approach to the development, operation, and maintenance of software.
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件工程被定义为将系统化、规范化和可量化的方法应用于软件开发、运行和维护。
- en: 'Some of the key questions that a software engineer must be able to answer are
    as follows:'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些软件工程师必须能够回答的关键问题如下：
- en: What are the business use cases that the software needs to support?
  id: totrans-4
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件需要支持哪些业务用例？
- en: What components comprise the system and how do they interact with each other?
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统由哪些组件组成，它们之间是如何相互作用的？
- en: What technologies will be used to implement the various system components?
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用于实现各种系统组件的技术是什么？
- en: How will the software be tested to ensure that its behavior matches the customer's
    expectations?
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试软件以确保其行为符合客户的期望？
- en: How does load affect the system's performance and what is the plan for scaling
    the system?
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载如何影响系统的性能，以及系统扩展的计划是什么？
- en: An SRE spends approximately half of their time on operations-related tasks such
    as dealing with support tickets, being on call, automating processes to eliminate
    human errors, and so on.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SRE 大约一半的时间用于与操作相关的任务，例如处理支持票证、待命、自动化流程以消除人为错误等。
- en: The waterfall model does not provide a detailed view of the processes that comprise
    each model step. In addition, it does not seem to support cross-cutting processes
    such as project management or quality control that run in parallel with the waterfall
    steps. A significant caveat of the waterfall model is that it operates under the
    assumption that all customer requirements are known in advance. The iterative
    enhancement model attempts to rectify these issues by executing small incremental
    waterfall iterations that allow the development team to adapt to changes in requirements.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水晶模型并没有提供每个模型步骤所包含过程的详细视图。此外，它似乎也不支持与水晶步骤并行运行的跨切面过程，例如项目管理或质量控制。水晶模型的一个显著缺点是它基于所有客户需求都提前已知的假设。迭代增强模型试图通过执行小的增量水晶迭代来纠正这些问题，从而使开发团队能够适应需求的变化。
- en: 'According to the lean development model, the most common sources of waste are
    as follows:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据精益开发模型，最常见的浪费来源如下：
- en: The introduction of non-essential changes when development is underway
  id: totrans-12
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中引入非必要的变化
- en: Overly complicated decision-making processes for signing off new features
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于签署新功能过于复杂的决策过程
- en: Unneeded communication between the various project stakeholders and the development
    teams
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各个项目利益相关者和开发团队之间不必要的沟通
- en: The team decides to focus on speedy delivery at the expense of code quality.
    As a result, the code base becomes more complex and defects start accumulating.
    Now, the team must dedicate a part of their development time to fixing bugs instead
    of working on the requested features. Consequently, the implementation stage becomes
    a bottleneck that reduces the efficiency of the entire development process.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队决定以牺牲代码质量为代价，专注于快速交付。结果，代码库变得更加复杂，缺陷开始累积。现在，团队必须将部分开发时间用于修复错误，而不是开发请求的功能。因此，实施阶段成为瓶颈，降低了整个开发过程的效率。
- en: The key responsibility of the Product Owner is to manage the backlog for the
    project. On the other hand, the Scrum Master is responsible for organizing and
    running the various Scrum events.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品负责人的主要职责是管理项目的待办事项。另一方面，Scrum Master 负责组织和运行各种 Scrum 活动。
- en: The retrospective serves as a feedback loop for incrementally improving the
    team's performance across sprints. The team members should be discussing both
    the things that went well during the last sprint as well as the things that didn't.
    The outcome of the retrospective should be a list of corrective actions to address
    the problems that were encountered during the sprint.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反思会议作为反馈循环，用于在冲刺期间逐步提高团队的表现。团队成员应该讨论在上一个冲刺中做得好的事情以及做得不好的事情。反思会议的结果应该是一份纠正措施清单，以解决在冲刺期间遇到的问题。
- en: Automation is important as it reduces the potential for human error. In addition,
    it reduces the time that's needed to test and deploy changes to production. Measuring
    is equally important as it allows DevOps engineers to monitor production services
    and receive alerts when their behavior diverges from the expected norm.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动化很重要，因为它减少了人为错误的可能性。此外，它减少了测试和部署更改到生产所需的时间。测量同样重要，因为它允许DevOps工程师监控生产服务，并在其行为偏离预期规范时接收警报。
- en: 'The company is expected to operate in a high-risk environment. For one, the
    new gaming console depends on a piece of technology that is not available yet
    and is being developed by a third party. What''s more, the market is already saturated:
    other, much larger competitors could also be working on their own next-gen console
    systems. The expected competitive advantage for ACME Gaming Systems may be rendered
    obsolete by the time their new system is released. This is yet another source
    of risk. Given the high risk that''s involved, the spiral model with its risk
    assessment and prototyping processes would be the most sensible choice for developing
    the software that will power the new console.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公司预计将在一个高风险环境中运营。一方面，新的游戏机依赖于一种尚未可用且由第三方开发的技术。更重要的是，市场已经饱和：其他，规模更大的竞争对手也可能正在开发他们自己的下一代游戏机系统。ACME游戏系统预期的竞争优势可能在他们的新系统发布时变得过时。这又是另一个风险来源。鉴于涉及的高风险，具有风险评估和原型制作过程的螺旋模型将是开发将驱动新控制台软件的最明智选择。
- en: Chapter 2
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章
- en: 'The following is what the SOLID acronym initials stand for:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下就是SOLID缩写代表的含义：
- en: Single responsibility
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责
- en: Open/Closed
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放/封闭
- en: Liskov substitution
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liskov替换
- en: Interface segregation
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离
- en: Dependency inversion
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖反转
- en: 'The code conflates two responsibilities: retrieving/mutating the state of a
    document and creating a signature for the document''s content. Furthermore, the
    proposed implementation is inflexible as it forces the use of a specific signing
    algorithm. To address this problem, we can remove the `Sign` method from the `Document` type
    and provide an external helper that can sign not only instances of `Document` but
    also any type that can export its content as a string:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码混淆了两个职责：检索/修改文档的状态和为文档内容创建签名。此外，所提出的实现是不灵活的，因为它强制使用特定的签名算法。为了解决这个问题，我们可以从`Document`类型中移除`Sign`方法，并提供一个外部辅助工具，它可以对`Document`的实例以及任何可以将内容导出为字符串的类型进行签名：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The idea behind the interface segregation principle is to provide clients with
    the smallest possible interface that satisfies their needs and thus avoid depending
    on interfaces that will not actually be used. In the provided example, the write
    method receives an `*os.File` instance as an argument. However, as the function
    implementation probably only needs to be able to *write* data to the file, we
    could achieve the same result by passing an `io.Writer` in the place of the `*os.File` instance.
    Apart from breaking the dependency to the `*os.File` concrete type, this change
    will also allow us to reuse the implementation for any type that implements `io.Writer` (for
    example, sockets, loggers, or others).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口隔离原则背后的思想是向客户提供尽可能小的接口，以满足他们的需求，从而避免依赖于实际上不会使用的接口。在提供的示例中，写入方法接收一个`*os.File`实例作为参数。然而，由于函数实现可能只需要能够将数据写入文件，我们可以通过传递一个`io.Writer`来代替`*os.File`实例，达到相同的结果。除了打破对`*os.File`具体类型的依赖之外，这个变化还将允许我们为任何实现了`io.Writer`的类型（例如，套接字、日志记录器或其他类型）重用实现。
- en: 'The use of `util` as a package name is not a recommended practice due to the
    following reasons:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于以下原因，将`util`用作包名不是一个推荐的做法：
- en: It provides little context as to the package's purpose and contents.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供的上下文很少，无法说明包的目的和内容。
- en: It can end up as the home for miscellaneous, possibly unrelated types and/or
    methods that would undoubtedly violate the single responsibility principle.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能成为各种杂项、可能无关的类型和方法的家，这无疑会违反单一职责原则。
- en: Import cycles cause the Go compiler to emit compile-time errors when you attempt
    to compile and/or run your code.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入周期会导致Go编译器在尝试编译和/或运行代码时发出编译时错误。
- en: 'Some of the advantages of using zero values when defining new Go types are
    as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用零值定义新的Go类型的一些优点如下：
- en: An explicit constructor is not required as Go will automatically assign the
    zero value to the fields of an object when it is allocated.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要显式构造函数，因为 Go 在对象分配时会自动将零值赋给其字段。
- en: The types can be embedded into other types and used out-of-the-box without any
    further initialization (for example, embedding a `sync.Mutex` into a struct).
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型可以嵌入到其他类型中，并且无需任何进一步初始化即可直接使用（例如，将 `sync.Mutex` 嵌入到结构体中）。
- en: Chapter 3
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章
- en: The purpose of software versioning is twofold. First, it allows software engineers
    to validate whether an external dependency can be safely upgraded without the
    risk of introducing issues to production systems. Secondly, being able to explicitly
    reference required software dependencies via their versions is a prerequisite
    for implementing the concept of repeatable builds.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件版本化的目的是双重的。首先，它允许软件工程师验证外部依赖项是否可以安全升级，而不会引入生产系统的问题。其次，能够通过它们的版本显式引用所需的软件依赖项是实现可重复构建概念的前提条件。
- en: 'A semantic version is a string that satisfies the following format: `MAJOR.MINOR.PATCH`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语义版本是一个满足以下格式的字符串：`MAJOR.MINOR.PATCH`：
- en: The major component is incremented when a breaking change is introduced to the
    software
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当软件中引入破坏性更改时，会递增主要组件。
- en: The minor component is incremented when new functionality is introduced to the
    software in a backward-compatible way
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当以向后兼容的方式向软件中引入新功能时，会递增次要组件。
- en: The patch version is incremented when a backward-compatible fix is applied to
    the code
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对代码应用向后兼容的修复时，会递增补丁版本。
- en: In the first case, we would increment the **minor** version as the new API does
    not break backward compatibility. In the second case, we would increment the **major** version
    as the new required parameter breaks compatibility with older versions of the
    API. Finally, in the third case, we would increment the **patch** version.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们会递增次要版本，因为新的 API 不会破坏向后兼容性。在第二种情况下，我们会递增主版本，因为新的必需参数与 API 的旧版本不兼容。最后，在第三种情况下，我们会递增补丁版本。
- en: One approach would be to tag each build with a unique, monotonically increasing
    number. Alternatively, we could annotate build artifacts with a timestamp that
    indicates when they were created.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种方法是为每个构建标记一个唯一的、单调递增的数字。或者，我们可以在构建工件上标注一个时间戳，以指示它们创建的时间。
- en: 'The pros of vendoring are as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: vendoring 的优点如下：
- en: The capability to run reproducible builds for current or older versions of a
    piece of software
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为当前或旧版本的软件运行可重复构建
- en: Being able to access the required dependencies locally, even if they disappear
    from the place where they were originally hosted
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够访问本地所需的依赖项，即使它们从最初托管的地方消失了。
- en: 'The cons of vendoring are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: vendoring 的缺点如下：
- en: Engineers should monitor the change logs for their dependencies and manually
    upgrade them when security fixes become available.
  id: totrans-49
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师应监控其依赖项的变更日志，并在安全修复可用时手动升级它们。
- en: If the authors of the vendored dependencies do not follow semantic versioning
    for their packages, upgrading a dependency can introduce breaking changes that
    must be addressed before it's able to compile our code.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 vendored 依赖项的作者没有为其包遵循语义版本，则升级依赖项可能会引入破坏性更改，这些更改必须在代码能够编译之前解决。
- en: 'Some differences between the dep tool and Go modules are as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: dep 工具和 Go modules 之间的一些区别如下：
- en: Go modules fully integrate with the various commands, such as `go get`, `go
    build`, and `go test`.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go modules 完全集成了各种命令，例如 `go get`、`go build` 和 `go test`。
- en: While the dep tool selects the **highest** common version for a package, Go
    modules select the **minimum** viable version.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 dep 工具选择一个包的最高公共版本，但 Go modules 选择可用的最低版本。
- en: Go modules support multi-versioned dependencies.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go modules 支持多版本依赖。
- en: Go modules do away with the *vendor* folder that's used by the dep tool.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go modules 废弃了 dep 工具使用的 *vendor* 文件夹。
- en: Chapter 4
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章
- en: 'A stub satisfies a particular interface and returns **canned** answers for
    every invocation to the methods it implements. Mocks allow us to specify the following
    in a declarative way:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板满足特定的接口，并为其实现的每个方法调用返回**预定义**的答案。模拟允许我们以声明性方式指定以下内容：
- en: The order and parameters of the expected set of method invocations
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期方法调用集的顺序和参数
- en: The set of values to be returned for each combination of inputs
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个输入组合要返回的值集
- en: A fake object provides a fully working implementation whose behavior matches
    the objects that they are meant to substitute. For example, instead of having
    our tests communicate with a real **key-value** (**KV**) store, we might inject
    a fake object that provides a compatible, in-memory implementation of the KV store's
    API.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 伪造对象提供了一个完全工作的实现，其行为与它们打算替代的对象相匹配。例如，我们可能不是让我们的测试与真实的**键值**（**KV**）存储进行通信，而是注入一个伪造对象，该对象提供了一个兼容的内存实现，用于KV存储的API。
- en: 'A table-driven test consists of three main components:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表驱动的测试由三个主要组件组成：
- en: A type that encapsulates the parameters for running the test and its expected
    outcome. In Go programs, this is typically facilitated using an anonymous struct.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种封装运行测试及其预期结果的参数的类型。在Go程序中，这通常通过匿名结构体来实现。
- en: A slice of test cases to evaluate.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组用于评估的测试用例。
- en: The test runner. Here, a for loop that iterates the list of test cases invokes
    the code under test with the correct set of parameters and verifies that the obtained
    results match the expectations for each test case.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试运行器。在这里，一个循环遍历测试用例列表，使用正确的参数集调用被测试代码，并验证获得的结果是否符合每个测试用例的预期。
- en: The purpose of unit testing is to ensure that a particular unit of code (a function,
    method, or package), when exercised in **isolation**, behaves according to a set
    of specifications. To this end, a unit test will typically use a mechanism such
    as stubs, mocks, or fake objects to replace any external dependencies of the code
    under test. On the other hand, integration tests are designed to exercise multiple
    units together so as to verify that they interoperate correctly.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试的目的是确保特定的代码单元（一个函数、方法或包）在**隔离**状态下运行时，其行为符合一组规范。为此，单元测试通常会使用诸如存根、模拟或伪造对象等机制来替换被测试代码的任何外部依赖。另一方面，集成测试旨在同时测试多个单元，以验证它们是否正确交互。
- en: Integration tests are designed to exercise multiple units together so as to
    verify that they interoperate correctly. In a similar fashion to unit tests, integration
    tests will oftentimes use a mechanism such as stubs, mocks, or fake objects as
    a substitute for external components (for example, databases, web servers, and
    so on). On the other hand, functional tests do not use any sort of mocking mechanism
    as their primary purpose is to test the behavior of the **complete** system.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成测试旨在同时测试多个单元，以验证它们是否正确交互。与单元测试类似，集成测试通常会使用诸如存根、模拟或伪造对象等机制作为外部组件的替代（例如，数据库、Web服务器等）。另一方面，功能测试不使用任何模拟机制，因为其主要目的是测试**完整**系统的行为。
- en: 'The ambassador pattern injects a proxy between an application and a service
    it depends on. The proxy is typically run as a sidecar process alongside the application
    and exposes APIs to do the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理模式在应用程序与其依赖的服务之间注入一个代理。代理通常作为与应用程序并行的边车进程运行，并公开API以执行以下操作：
- en: Divert outgoing service calls to a different version of the service
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将出站服务调用重定向到服务的不同版本
- en: Mock responses to outgoing service calls
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对出站服务调用的模拟响应
- en: Inject faults to requests or responses for testing purposes
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为测试目的向请求或响应中注入故障
- en: Chapter 5
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: Functional requirements outline the list of core functionalities that a system
    will implement, as well as the set of interactions between the system and any
    external actors. On the other hand, non-functional requirements list the mechanisms
    and metrics that we can use to ascertain whether a proposed design is a good fit
    for solving a particular problem.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能需求概述了系统将实现的核心功能列表，以及系统与任何外部参与者之间的交互集合。另一方面，非功能需求列出了我们可以用来确定所提出的设计是否适合解决特定问题的机制和指标。
- en: 'A user story is comprised of the following two key components:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户故事由以下两个关键组件组成：
- en: A requirement specification must always be expressed from the viewpoint of the
    actor interacting with the system
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求规范必须始终从与系统交互的参与者的视角来表述
- en: A set of acceptance criteria (also known as the *definition of done*) for evaluating
    whether the story goals have been successfully met
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组验收标准（也称为*完成定义*），用于评估故事目标是否已成功实现
- en: An attacker could submit a carefully crafted link with a link-local address
    that would trick the crawler into making a call to the metadata API offered by
    the cloud provider hosting our project and subsequently caching the response to
    the search index. Moreover, the attacker could submit a URL `file` as its protocol
    type and cause the crawler to read a local file from the machine and leak its
    contents to the search index.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者可以提交一个精心设计的带有本地链接地址的链接，诱使爬虫调用托管我们项目的云提供商提供的元数据API，并随后将响应缓存到搜索索引中。此外，攻击者可以将`file`作为其协议类型提交URL，导致爬虫从机器上读取本地文件并将其内容泄露到搜索索引中。
- en: 'A **service-level objective** (**SLO**) consists of the following parts:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务级别目标**（SLO）由以下部分组成：'
- en: A description of the thing being measured
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对被测量的对象的描述
- en: The expected service level, specified as a percentage
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的服务级别，以百分比指定
- en: The time period where the measurement takes place
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量发生的时间段
- en: A UML component diagram provides a high-level view of the core components that
    comprise a system and visualizes their dependencies in terms of implemented and
    required interfaces.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个UML组件图提供了对构成系统的核心组件的高级视图，并从实现和所需接口的角度可视化它们的依赖关系。
- en: Chapter 6
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Relational databases are a better fit for transactional workloads and for performing
    complex queries. They can scale horizontally using mechanisms such as data sharding
    but at the cost of requiring additional coordination for executing queries. On
    the other hand, NoSQL databases are best suited for crunching massive volumes
    of **denormalized** data. By design, NoSQL databases can efficiently scale horizontally
    (even across data centers), with many NoSQL offerings promising a linear increase
    in query performance as more nodes are added to the cluster. The main caveat of
    NoSQL databases is that they can only satisfy two facets of the **CAP** (**consistency**,
    **availability**, and **partition tolerance**) theorem.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关系型数据库更适合事务型工作负载和执行复杂查询。它们可以通过数据分片等机制进行水平扩展，但代价是需要额外的协调来执行查询。另一方面，NoSQL数据库最适合处理大量**非规范化**数据。按设计，NoSQL数据库可以高效地进行水平扩展（甚至跨数据中心），许多NoSQL产品承诺随着集群中节点数量的增加，查询性能呈线性增长。NoSQL数据库的主要缺点是它们只能满足CAP定理（**一致性**、**可用性**和**分区容错性**）的两个方面。
- en: A relational database would be a great fit for systems that perform a large
    volume of concurrent transactions, such as the ones you would expect to find in
    a bank. On the other hand, a system that needs to process a large number of events
    for analytics purposes would probably benefit more from a NoSQL solution.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于执行大量并发事务的系统，如银行中可能遇到的系统，关系型数据库将是一个很好的选择。另一方面，需要处理大量事件以进行数据分析的系统可能更多地受益于NoSQL解决方案。
- en: To scale a DBMS for a read-heavy workload, we would deploy multiple read replicas
    and update our applications to send read-only queries to the replicas and write
    queries to the master node. For a write-heavy workload, we would deploy multiple
    master nodes and enable data sharding so that writes can be efficiently distributed
    across the master nodes.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将数据库管理系统（DBMS）扩展以应对读密集型工作负载，我们会部署多个只读副本，并更新我们的应用程序以将只读查询发送到副本，将写查询发送到主节点。对于写密集型工作负载，我们会部署多个主节点并启用数据分片，以便将写操作高效地分布在主节点之间。
- en: 'According to the CAP theorem, distributed systems can only satisfy two of the
    following properties: consistency, availability, and partition tolerance. When
    deciding on which NoSQL solution to use, we must identify which two of the CAP
    terms are the most important for our particular application (CP, AP, or CA) and
    then limit our search to those NoSQL offerings that satisfy our selected CAP requirements.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据CAP定理，分布式系统只能满足以下三个属性中的两个：一致性、可用性和分区容错性。在决定使用哪种NoSQL解决方案时，我们必须确定对我们特定的应用程序来说，CAP术语中的哪两个是最重要的（CP、AP或CA），然后限制我们的搜索范围，只考虑满足我们选择的CAP要求的NoSQL产品。
- en: Having an abstraction layer allows us to decouple the business logic from the
    underlying database system. This makes it much easier to switch to a different
    DBMS in the future, without having to update our business logic. Furthermore,
    testing our business logic code also becomes easier and faster as we can use a
    mechanism such as stubs, mocks, or fake objects to avoid running our tests against
    an actual database instance.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有一个抽象层允许我们将业务逻辑与底层数据库系统解耦。这使得在未来切换到不同的DBMS变得容易得多，而无需更新我们的业务逻辑。此外，由于我们可以使用诸如存根、模拟或伪造对象等机制来避免针对实际数据库实例运行测试，因此测试我们的业务逻辑代码也变得更容易、更快。
- en: First, you would need to add the new method to the `Indexer` interface. Then,
    following a test-driven approach, you would need to add a test for the expected
    behavior of the new method to the `SuiteBase` type in the `indextest` package.
    Finally, you would need to visit all the types that adhere to the `Indexer` interface
    (in this case, the bleve and Elasticsearch indexers) and add an implementation
    for the new method.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要将新方法添加到`Indexer`接口中。然后，按照测试驱动的方法，您需要在`indextest`包中的`SuiteBase`类型中添加对新方法预期行为的测试。最后，您需要访问所有遵循`Indexer`接口的类型（在本例中为bleve和Elasticsearch索引器），并为新方法添加实现。
- en: Chapter 7
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: The Go `interface{}` type conveys no useful information about the underlying
    type. If we use it for representing an argument to a function or a method, we
    effectively bypass the compiler's ability to statically check the function/method
    arguments at compile-time and instead have to manually check whether the input
    can be safely cast into a supported known type.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go的`interface{}`类型没有关于底层类型的有用信息。如果我们用它来表示函数或方法的参数，我们实际上绕过了编译器在编译时对函数/方法参数进行静态检查的能力，而必须手动检查输入是否可以安全地转换为支持的已知类型。
- en: 'Instead of running the compute-intensive stages locally, we can migrate them
    to a remote machine with enough computing resources. The respective local stages
    can then be replaced with a proxy that transmits the local payload data to the
    remote machine via a **remote procedure call** (**RPC**), waits for the results,
    and pushes them to the next local stage. The following diagram outlines the proposed
    solution:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将计算密集型阶段迁移到具有足够计算资源的远程机器上，而不是在本地运行。然后，相应的本地阶段可以用一个代理来替换，该代理通过**远程过程调用**（**RPC**）将本地有效负载数据传输到远程机器，等待结果，并将结果推送到下一个本地阶段。以下图表概述了提出的解决方案：
- en: '![](img/87496116-364e-46b7-b79d-45119ae937cc.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87496116-364e-46b7-b79d-45119ae937cc.png)'
- en: 'Each processor function must satisfy the `Processor` interface, whose definition
    is as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个处理器函数都必须满足`Processor`接口，其定义如下：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition, we also defined the `ProcessorFunc` type, which acts as an adaptor
    for converting a function with a compatible signature into a type that implements
    the `Processor` interface.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还定义了`ProcessorFunc`类型，它充当将具有兼容签名的函数转换为实现`Processor`接口的类型的适配器。
- en: 'For this particular use case, we can define a function that receives a `Processor` and
    a logger (for example, from the `logrus` package) instance and returns a new `Processor` that
    decorates the call to the `Process` method with additional logic that emits a
    log entry if an error occurs. The `makeErrorLoggingProcessor` function shows one
    of the possible ways of implementing this pattern:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的用例，我们可以定义一个函数，该函数接收一个`Processor`和一个日志记录器（例如，来自`logrus`包）的实例，并返回一个新的`Processor`，该`Processor`在调用`Process`方法时添加额外的逻辑，如果发生错误则发出日志条目。`makeErrorLoggingProcessor`函数展示了实现此模式的一种可能方法：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A synchronous pipeline processes one payload at a time in **first-in, first-out**
    (**FIFO**) order and waits for it to exit the pipeline before processing the next
    available payload. As a result, if a single payload takes a long time to be processed,
    it effectively delays processing the payloads that are queued behind it. In an
    asynchronous pipeline, each stage operates asynchronously and can immediately
    begin processing the next payload as soon as the current payload has been sent
    to the next stage.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步管道按**先进先出**（**FIFO**）顺序一次处理一个有效负载，并在处理下一个可用有效负载之前等待它退出管道。因此，如果单个有效负载处理时间较长，它实际上会延迟处理其后排队等待的有效负载。在异步管道中，每个阶段异步操作，可以在当前有效负载被发送到下一阶段后立即开始处理下一个有效负载。
- en: A dead-letter queue is a mechanism for deferring error handling for pipeline
    payloads to a later time. When the pipeline encounters an error while processing
    a payload, it appends the payload to the dead-letter queue, along with the error
    that occurred. The application can then introspect the contents of the dead-letter
    queue and decide how it wants to handle each error according to its business logic
    (for example, retry the failed payload, log or ignore the error, and so on).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 死信队列是一种将管道有效载荷的错误处理延迟到以后的机制的机制。当管道在处理有效载荷时遇到错误，它会将有效载荷及其发生的错误附加到死信队列中。然后应用程序可以检查死信队列的内容，并根据其业务逻辑决定如何处理每个错误（例如，重试失败的有效载荷、记录或忽略错误等）。
- en: A fixed-size worker pool contains a predetermined number of workers that are
    created at the same time as the pool and remain active (even when they are idle)
    until the pool is destroyed. A dynamic pool is configured with lower and upper
    worker limits and can automatically grow or shrink on demand to accommodate changes
    in the rate of incoming payloads.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个固定大小的工作池包含在池创建时同时创建的预定数量的工作者。动态池配置了较低的工人限制和较高的工人限制，可以根据需求自动扩展或缩小，以适应传入有效载荷速率的变化。
- en: To measure the total time that each payload spent in the pipeline, we will modify
    the `pipeline.Payload` struct and add a new *private* field of the `time.Time` type called `processStartedAt`.
    This new field will be used to record the timestamp when the payload entered the
    pipeline. Next, we will modify the `linkSource` implementation to populate `processStartedAt` when
    it emits a new `Payload`. Finally, we will update the (currently empty) `Consume` method
    of `nopSink` to calculate the elapsed time via a call to `time.Since`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测量每个有效载荷在管道中花费的总时间，我们将修改`pipeline.Payload`结构体并添加一个名为`processStartedAt`的新`*private*`字段，字段类型为`time.Time`。这个新字段将用于记录有效载荷进入管道的时间戳。接下来，我们将修改`linkSource`实现，在它发出新的`Payload`时填充`processStartedAt`。最后，我们将更新`nopSink`的（目前为空的）`Consume`方法，通过调用`time.Since`来计算经过的时间。
- en: Chapter 8
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: The BSP computer is an abstract computer model made up of a collection of potentially
    heterogeneous processors that are interconnected via a computer network. Processors
    can not only access their own local memory, but they can also use the network
    link to exchange data with other processors. In other words, the BSP computer
    is effectively a **distributed memory** computer that can perform computations
    in parallel.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BSP计算机是由一组可能异构的处理器组成的抽象计算机模型，这些处理器通过计算机网络相互连接。处理器不仅可以访问自己的本地内存，还可以使用网络链路与其他处理器交换数据。换句话说，BSP计算机实际上是一个**分布式内存**计算机，可以并行执行计算。
- en: The **Single Program Multiple Data** (**SPMD**) technique models distributed
    data processing tasks as a self-contained piece of software that runs on a single-core
    machine. The program receives a set of data as input, applies a processing function
    to it, and emits some output. Parallelism is then achieved by splitting the dataset
    into batches, launching multiple instances of the **same** program to process
    each batch in parallel, and combining the results.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单程序多数据**（**SPMD**）技术将分布式数据处理任务建模为在单核机器上运行的独立软件组件。程序接收一组数据作为输入，对其应用处理函数，并输出一些结果。然后通过将数据集拆分为批次，启动多个相同程序的实例并行处理每个批次，并合并结果来实现并行性。'
- en: 'A super-step is broken down into two phases, or sub-steps:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超步骤被分解为两个阶段，或子步骤：
- en: A compute step, where each processor executes (in parallel) a single iteration
    of the user's program using the data that was assigned to the processor as input.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算步骤，其中每个处理器使用分配给处理器的数据作为输入，并行执行用户程序的单一迭代。
- en: A communication step that runs after **all** the processors complete the compute
    step. During this step, processors communicate through the network and compare,
    exchange, or aggregate the results of their individual computations.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有处理器完成计算步骤之后运行的通信步骤。在此步骤中，处理器通过网络进行通信，比较、交换或汇总各自计算的结果。
- en: 'The following block of code demonstrates how we can create an aggregator to
    keep track of the minimum `int64` value we''ve seen so far. The use of an `int64` pointer
    allows us to detect whether *any* value has been seen so far (otherwise, the pointer
    will be `nil`) and if so, the minimum value that''s been seen by the `Aggregate` method.
    Atomic access to the `int64` value is enforced via the use of `sync.Mutex`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块演示了我们可以如何创建一个聚合器来跟踪迄今为止看到的最低`int64`值。使用`int64`指针允许我们检测是否已经看到了任何值（否则，指针将是`nil`），如果是，则通过`Aggregate`方法看到的最低值。通过使用`sync.Mutex`强制执行对`int64`值的原子访问：
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Under the random surfer model, a user performs an initial search and lands
    on a page from the link graph. From that point on, users randomly select one of
    the following two options:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随机冲浪者模型下，用户执行初始搜索并从链接图中随机选择一个页面。从那时起，用户随机选择以下两种选项之一：
- en: They can click any outgoing link from the current page and navigate to a new
    page
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以点击当前页面的任何出站链接并导航到新页面
- en: Alternatively, they can decide to run a new search query
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，他们可以选择运行一个新的搜索查询
- en: The preceding steps continue in perpetuity.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤会持续进行。
- en: A PageRank score reflects the probability that a random surfer lands on a particular
    web page. In other words, the score expresses the importance (ranking) of each
    web page relative to every other web page on the internet.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PageRank分数反映了随机冲浪者随机访问特定网页的概率。换句话说，该分数表达了相对于互联网上每个其他网页的每个网页的重要性（排名）。
- en: At each step of the PageRank algorithm, each link distributes its accumulated
    PageRank score to its outgoing links. Dead-ends receive the PageRank scores from
    pages that are linked to them but never redistribute them as they have no outgoing
    links. If we don't take steps to handle these problematic cases, the graph dead-ends
    will end up with a significantly higher (and incorrect) PageRank score compared
    to regular pages in the graph.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PageRank算法的每个步骤中，每个链接都会将其累积的PageRank分数分配给其出站链接。死胡同从链接到它们的页面接收PageRank分数，但它们不会重新分配，因为它们没有出站链接。如果我们不采取措施处理这些问题情况，图中的死胡同最终会得到一个显著更高（且不正确）的PageRank分数，与图中的常规页面相比。
- en: Chapter 9
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章
- en: 'The following table summarizes the CRUD endpoints for a user entity:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下表总结了用户实体的CRUD端点：
- en: '| **HTTP Verb** | **Path** | **Expects (JSON)** | **Returns (JSON)** | **HTTP
    Status** | **Description** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **路径** | **期望（JSON）** | **返回（JSON）** | **HTTP状态** | **描述** |'
- en: '| POST | `/users` | A user entry | The new user entry and its ID | 200 (success)
    or 201 (created) | Create a new user |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| POST | `/users` | 用户条目 | 新的用户条目及其ID | 200（成功）或201（已创建） | 创建新用户 |'
- en: '| GET | `/users` | Nothing | An array with user entries | 200 (success) | Get
    a list of users |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| GET | `/users` | 无 | 包含用户条目的数组 | 200（成功） | 获取用户列表 |'
- en: '| GET | `/users/:id` | Nothing | The user with the specified ID | 200 (success)
    or 404 (not found) | Get user by ID |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| GET | `/users/:id` | 无 | 指定ID的用户 | 200（成功）或404（未找到） | 通过ID获取用户 |'
- en: '| PUT | `/users/:id` | A user entry | The updated user entry | 200 (success)
    or 404 (not found) | Update user by ID |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| PUT | `/users/:id` | 用户条目 | 更新的用户条目 | 200（成功）或404（未找到） | 通过ID更新用户 |'
- en: '| PATCH | `/users/:id` | A *partial* user entry | The updated user entry |
    200 (success) or 404 (not found) | Update individual fields for a user by ID |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| PATCH | `/users/:id` | 一个*部分*用户条目 | 更新的用户条目 | 200（成功）或404（未找到） | 通过ID更新用户的单个字段
    |'
- en: '| DELETE | `/users/:id` | Nothing | Nothing | 200 (success) or 404 (not found)
    | Delete user by ID |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | `/users/:id` | 无 | 无 | 200（成功）或404（未找到） | 通过ID删除用户 |'
- en: Basic authentication headers are transmitted as plaintext. By ensuring this
    information is transmitted over a TLS-encrypted channel, we prevent malicious
    actors from intercepting user credentials.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本认证头以明文形式传输。通过确保此信息通过TLS加密通道传输，我们防止恶意行为者拦截用户凭据。
- en: If a malicious adversary manages to install their own **certificate authority**
    (**CA**) on their targets' trusted certificate stores, they can mount a **man-in-the-middle**
    (**MitM**) attack and snoop on the TLS traffic between the target and any third
    party.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果恶意对手成功在其目标受信任的证书存储中安装自己的**证书颁发机构**（**CA**），他们可以发起**中间人攻击**（**MitM**）并窃听目标与任何第三方之间的TLS流量。
- en: 'In a three-legged OAuth2 flow, the following occurs:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在三重OAuth2流程中，以下情况发生：
- en: A user visits service A and attempts to log in via service B.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户访问服务A并尝试通过服务B登录。
- en: The backend server for A generates an authorization URL for service B and redirects
    the user's browser to it. The generated URL includes the set of permissions that
    were requested by A and a URL that B should redirect the user to once they consent
    to granting access.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: A 的后端服务器为服务 B 生成一个授权 URL，并将用户的浏览器重定向到该 URL。生成的 URL 包含 A 请求的权限集，以及 B 一旦同意授权后应将用户重定向到的
    URL。
- en: The user is redirected to service B and consents to the permissions that were
    requested by service A.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被重定向到服务 B，并同意服务 A 请求的权限。
- en: The user's browser is redirected to service A with an access code embedded in
    the URL.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户的浏览器被重定向到包含嵌入 URL 中的访问代码的服务 A。
- en: The backend server for service A contacts service B and exchanges the access
    code with an access token.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务 A 的后端服务器联系服务 B，并使用访问令牌交换访问代码。
- en: Service A uses the token to access some resource (for example, user details)
    on service B on behalf of the user.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务 A 使用令牌代表用户访问服务 B 上的某些资源（例如，用户详情）。
- en: 'Protocol buffers are superior to JSON for request/response payloads for the
    following reasons:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协议缓冲区在以下原因上优于 JSON 用于请求/响应有效负载：
- en: They utilize a much more compact binary format to serialize payloads
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使用更紧凑的二进制格式来序列化有效负载。
- en: Protocol buffer messages are strictly typed and support versioning
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议缓冲区消息是严格类型的，并支持版本控制。
- en: The protoc compiler can be used to generate the required code for working with
    protocol buffer messages in a variety of programming languages
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protoc 编译器可用于生成用于在多种编程语言中处理协议缓冲区消息所需的代码。
- en: 'gRPC supports the following RPC modes:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: gRPC 支持以下 RPC 模式：
- en: '**Unary RPC**: The client performs a request and receives a response.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例 RPC**：客户端执行请求并接收响应。'
- en: '**Server-streaming RPC**: The client initiates an RPC connection to the server
    and receives a stream of responses from the server.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器流式 RPC**：客户端初始化与服务器的 RPC 连接，并从服务器接收一系列响应。'
- en: '**Client-streaming RPC**: The client initiates an RPC connection to the server
    and sends a stream of requests via the open connection. The server processes the
    requests and sends a single response.'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端流式 RPC**：客户端初始化与服务器的 RPC 连接，并通过打开的连接发送一系列请求。服务器处理请求，并发送单个响应。'
- en: '**Bidirectional streaming RPC**: The client and the server share a bidirectional
    channel where each side can asynchronously send and receive messages.'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向流式 RPC**：客户端和服务器共享一个双向通道，每端都可以异步发送和接收消息。'
- en: Chapter 10
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章
- en: 'Some of the benefits of containerization are as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器化的某些好处如下：
- en: The same container image can run on a local development machine or a cloud instance
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个容器镜像可以在本地开发机器或云实例上运行。
- en: It is trivial to deploy a new version of a piece of software and perform a rollback
    if something goes wrong
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署软件的新版本非常简单，如果出现问题，还可以执行回滚。
- en: It introduces an extra layer of security as applications are isolated from both
    the host and other applications
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它引入了一个额外的安全层，因为应用程序既与主机又与其他应用程序隔离。
- en: Master nodes implement the *control plane* of a Kubernetes cluster. Worker nodes
    pool their resources (CPUs, memory, disks, GPUs, and so on) and execute the workloads
    that have been assigned to them by the master nodes.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主节点实现了 Kubernetes 集群的 *控制平面*。工作节点将它们的资源（CPU、内存、磁盘、GPU 等）汇总，并执行由主节点分配给它们的工作负载。
- en: A regular Kubernetes service acts as a load balancer for distributing incoming
    traffic to a collection of pods. Regular services are reachable via the cluster
    IP address that's assigned to them by Kubernetes. A headless service provides
    the means for implementing a custom service discovery mechanism. It is not assigned
    a cluster IP address and DNS queries for it are returned the full list of pods
    behind the service.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个常规的 Kubernetes 服务充当负载均衡器，将传入流量分发到一组 Pod。常规服务可以通过 Kubernetes 分配给它们的集群 IP 地址访问。无头服务提供了实现自定义服务发现机制的途径。它没有分配集群
    IP 地址，对该服务的 DNS 查询返回该服务背后的所有 Pod 的完整列表。
- en: Since both the OAuth2 client ID and secret are sensitive pieces of information,
    the recommended Kubernetes approach for sharing them with the frontend would be
    to create a secret resource.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 OAuth2 客户端 ID 和密钥都是敏感信息，因此建议的 Kubernetes 方法是将它们与前端共享，即创建一个密钥资源。
- en: A Kubernetes deployment creates a pod with non-predictable IDs, whereas a stateful
    set assigns predictable names that are constructed by concatenating the stateful
    set name and the pod ordinal (for example, web-0, web-1, and so on). Another difference
    is that while Kubernetes deployments spin up the required number of pods in parallel,
    a stateful set spins up pods sequentially.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 部署会创建具有不可预测 ID 的 pod，而有状态集则分配可预测的名称，这些名称是通过连接有状态集名称和 pod 序号（例如，web-0、web-1
    等等）来构建的。另一个区别是，虽然 Kubernetes 部署会并行启动所需数量的 pod，但有状态集则是顺序启动 pod。
- en: Chapter 11
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章
- en: A microservice-based architecture brings a lot of benefits to the table. However,
    at the same time, it adds a lot of complexity to a system and requires additional
    effort to make it resilient against network issues, to monitor its internal state,
    and to debug issues when something goes wrong. Consequently, selecting this pattern
    for an MVP or PoC is often considered to be a form of premature optimization that
    likely introduces more issues than it solves.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于微服务的架构为系统带来了许多好处。然而，同时，它也给系统增加了许多复杂性，并需要额外的努力来使其能够抵御网络问题、监控其内部状态以及在出现问题时进行调试。因此，选择这种模式用于
    MVP 或 PoC 通常被认为是一种过早优化，可能会引入比解决的问题更多的问题。
- en: When the number of errors from a particular downstream service exceeds a particular
    threshold, the circuit breaker is tripped and all future requests automatically
    fail with an error. Periodically, the circuit breaker lets some requests go through
    and after a number of successful responses, the circuit breaker switches back
    to the open position, thereby allowing all the requests to go through.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当特定下游服务的错误数量超过特定阈值时，断路器会被触发，所有未来的请求都会自动失败并显示错误。定期地，断路器会允许一些请求通过，并在收到一定数量的成功响应后，断路器会切换回开启位置，从而允许所有请求通过。
- en: 'Being able to trace requests as they travel through a system allows us to do
    the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 能够追踪请求在系统中的传输过程，使我们能够做以下事情：
- en: Figure out how much time the request spends in each service and identify potential
    bottlenecks
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定请求在每个服务中花费的时间，并识别潜在的瓶颈
- en: Understand and map the dependencies between services
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并映射服务之间的依赖关系
- en: Pinpoint the root cause of issues that affect production systems
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定影响生产系统的问题的根本原因
- en: Log entries may contain sensitive information such as credit card numbers, security
    credentials, customer names, addresses, or social security numbers. Unless we
    actively sanitize these entries, this information will end up in the logs and
    could be potentially visible to entities (employees or third parties) that are
    not authorized to access this kind of information.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志条目可能包含敏感信息，例如信用卡号码、安全凭证、客户姓名、地址或社会保障号码。除非我们主动清理这些条目，否则这些信息最终会出现在日志中，并可能被未经授权访问此类信息的实体（员工或第三方）看到。
- en: 'To collect logs from the pods running in a Kubernetes cluster, we can use one
    of the following strategies:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要收集在 Kubernetes 集群中运行的 pod 的日志，我们可以使用以下策略之一：
- en: Use a daemon set to run a log collector on each Kubernetes node. The log collector
    digests the log files from each pod running on the node and ships them to a centralized
    log storage location.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用守护集在每个 Kubernetes 节点上运行日志收集器。日志收集器会处理节点上运行的每个 pod 的日志文件，并将它们发送到集中式日志存储位置。
- en: Deploy a sidecar container in the same pod as the application whose logs we
    want to collect. The sidecar digests the application logs (which could be a single
    file or multiple files) and ships them to a centralized log storage location.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们想要收集日志的应用程序所在的同一个 pod 中部署一个边车容器。边车容器会处理应用程序日志（可能是一个文件或多个文件）并将它们发送到集中式日志存储位置。
- en: Ship logs directly from within the application.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从应用程序内部发送日志。
- en: Chapter 12
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章
- en: In a leader-follower configuration, the nodes hold an election and elect a leader
    for the cluster. All reads and writes go through the cluster leader, while the
    other nodes monitor the leader and automatically hold a new election if the leader
    becomes unavailable. As the name implies, in a multi-master configuration, the
    cluster has several master nodes and each of the master nodes can serve both read
    and write requests. The master nodes implement some form of distributed consensus
    algorithm (Raft, Paxos, and so on) to ensure that they always share the same view
    of the cluster's state.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在领导者-跟随者配置中，节点进行选举并为集群选择一个领导者。所有读取和写入操作都通过集群领导者进行，而其他节点监控领导者，如果领导者变得不可用，则自动进行新的选举。正如其名所示，在多主配置中，集群有多个主节点，每个主节点都可以处理读取和写入请求。主节点实现某种形式的分布式一致性算法（Raft、Paxos等），以确保它们始终共享集群状态的相同视图。
- en: When implementing the checkpoint strategy, workers are periodically asked by
    the master to persist their current state to durable storage. If this operation
    succeeds, a new checkpoint is created. If a worker crashes or becomes unavailable,
    the master will request for the remaining healthy workers to load their state
    from the last known checkpoint and resume executing the computation job from that
    point on.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现检查点策略时，主节点会定期要求工作节点将它们当前的状态持久化到持久存储中。如果此操作成功，则创建一个新的检查点。如果工作节点崩溃或变得不可用，主节点将要求剩余的健康工作节点从最后一个已知的检查点加载它们的状态，并从该点继续执行计算作业。
- en: The distributed barrier is a synchronization primitive that notifies the master
    node when all the workers have reached the same exact point of execution. This
    primitive is a prerequisite for executing compute jobs under the BSP model (see
    [Chapter 8](c505ec2d-0bd8-4edd-97e1-d06de2b326a5.xhtml), *Graph-Based Data Processing*),
    which requires that all the processors execute each super-step in the lockstep.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式屏障是一种同步原语，当所有工作节点都达到相同的执行点时，它会通知主节点。这个原语是执行基于BSP模型（见第8章，*基于图的数据处理*）的计算作业的先决条件，该模型要求所有处理器以同步方式执行每个超级步骤。
- en: While the algorithm itself has completed without any errors, something might
    go wrong if one or more workers attempt to persist their results to durable storage.
    Consequently, a computation job can't really be considered as completed until **all** the workers
    have persisted the results of the computation.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管算法本身没有错误地完成，但如果一个或多个工作节点尝试将它们的计算结果持久化到持久存储中，可能会出现问题。因此，只有在所有工作节点都持久化了计算结果之后，才能真正认为计算作业已经完成。
- en: Chapter 13
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: A **service-level indicator** (**SLI**) is a type of metric that allows us to
    quantify the perceived quality of the service from the perspective of the end
    user (for example, metrics such as availability, throughput, and latency). A **service-level
    objective** (**SLO**) is the range of values for some SLIs that allow us to deliver
    a particular level of service to an end user or customer.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务级别指标**（**SLI**）是一种指标类型，它允许我们从最终用户的视角量化服务的感知质量（例如，可用性、吞吐量和延迟等指标）。**服务级别目标**（**SLO**）是一组SLI的值范围，它允许我们向最终用户或客户提供特定水平的服务。'
- en: A **service-level agreement** (**SLA**) is an implicit or explicit contract
    between a service provider and one or more service consumers. The SLA outlines
    a set of SLOs that have to be met and the consequences (financial or not) for
    meeting and failing to meet them.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务级别协议**（**SLA**）是服务提供商和一位或多位服务消费者之间的一种隐式或显式合同。SLA概述了一系列必须满足的SLO以及满足和未能满足它们的后果（财务或非财务）。'
- en: In a push-based metrics collection system, the metric-producing clients connect
    to the metrics collection and aggregation service over a TCP or UDP connection
    and publish their metrics. In a pull-based system, the metrics collection system,
    at its own leisure, connects to each client and collects (scrapes) any new metrics.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于推的指标收集系统中，指标生成客户端通过TCP或UDP连接连接到指标收集和聚合服务并发布它们的指标。在基于拉的系统中，指标收集系统在其空闲时连接到每个客户端并收集（抓取）任何新的指标。
- en: Due to the network security policies in place, the metrics collection service
    would not be able to establish a connection to any of the metrics producers in
    the locked-down subnet. However, the applications running on that subnet should
    still be able to access other subnets, including the one that the metrics collection
    service runs on. Consequently, the logical choice in such a situation is to use
    a push-based system.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现有的网络安全策略，指标收集服务无法与锁定子网中的任何指标生产者建立连接。然而，在该子网上运行的应用程序仍然应该能够访问其他子网，包括指标收集服务运行的子网。因此，在这种情况下，逻辑选择是使用基于推送的系统。
- en: The value of a Prometheus counter can only increase, while the value of a Prometheus
    gauge can both increase and decrease.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus 计数器的值只能增加，而 Prometheus 仪表的值既可以增加也可以减少。
- en: A playbook is a short document that distills the best practices for resolving
    a particular type of problem. Having access to the playbook associated with a
    particular alert reduces the **mean time to resolution** (**MTTR**) as SREs can
    follow the playbook instructions to quickly diagnose the root cause of the problem
    and apply the recommended set of steps to fix it.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操场剧本是一份简短的文档，总结了解决特定类型问题的最佳实践。能够访问与特定警报关联的操场剧本可以减少**平均修复时间**（**MTTR**），因为 SRE
    可以遵循操场剧本的指示，快速诊断问题的根本原因，并应用推荐的步骤来修复它。
