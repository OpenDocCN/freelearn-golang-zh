<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Data Structures and Algorithms</h1>
                </header>
            
            <article>
                
<p>A data structure is the organization of data to reduce the storage space used and to reduce the difficulty while performing different tasks. Data structures are used to handle and work with large amounts of data in various fields, such as database management and internet indexing services.</p>
<p><span>In this chapter, we will focus on the definition of abstract datatypes, classifying data structures into linear, nonlinear, homogeneous, heterogeneous, and dynamic types. Abstract datatypes, such as </span><span>Container, List, Set, Map, Graph, Stack, and Queue, </span><span>are presented in this chapter.  We will also cover the performance analysis of data structures, choosing the right data structures, and structural design patterns.</span></p>
<p><span class="s1">T</span><span class="s1">he r</span><span class="s1">eader can start writing basic algorithms using the right data structures in Go. </span><span class="s1">Given a problem, choosing the data structure and different algorithms will be the first step. After this, doing performance analysis is the next step. Time and space analysis for different algorithms helps compare them and helps you choose the optimal one</span><span class="s1">. </span><span class="s1">It is essential to have basic knowledge of Go to get started</span><span class="s1">.</span><span class="s1"> </span></p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Classification of data structures and structural design patterns</li>
<li>Representation of algorithms</li>
<li>Complexity and performance analysis</li>
<li>Brute force algorithms</li>
<li>Divide and conquer algorithms</li>
<li>Backtracking algorithms</li>
</ul>
<p class="p3"><span class="s1"><span class="Apple-converted-space"> </span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="p1">Install Go version 1.10 from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> for your operating system. </p>
<p>The code files for this chapter can be found at the following GitHub URL: <a href="https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter01">https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter01</a><a href="https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Go/tree/master/ch1">.</a></p>
<p class="p1">Check the installation of Go by running the hello world program at <a href="https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/hello_world">https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/hello_world</a>:</p>
<pre>//main package has examples shown<br/>// in Hands-On Data Structures and algorithms with Go book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/>// main method<br/>func main() {<br/>  fmt.Println("Hello World")<br/>}</pre>
<p class="p1"><span class="s1">Run the following commands:</span></p>
<pre><strong>go build</strong><br/><strong>./hello_world</strong></pre>
<p class="p1"><span class="s1">The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8057be5f-396d-4d1f-9aa4-cd3f6eee3310.png" style="width:27.08em;height:10.58em;" width="987" height="385"/></p>
<p class="mce-root">Let's take a look at the classification of data structures and structural design patterns in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Classification of data structures and structural design patterns</h1>
                </header>
            
            <article>
                
<p><span>You can choose a data structure by using classification. </span>In this section, we discuss data structure classification in detail. The design patterns related to the data structure are covered after the classification.</p>
<p>In the next section, we'll take a look at classification of data structures.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Classification of data structures</h1>
                </header>
            
            <article>
                
<p>The term <strong>data structure</strong> refers to the organization of data in a computer's memory, in order to retrieve it quickly for processing. It is a scheme for data organization to decouple the functional definition of a data structure from its implementation. A data structure is chosen based on the problem type and the operations performed on the data.</p>
<p><span>If the situation requires various datatypes within a data structure, we can choose heterogeneous data structures. Linked, ordered, and unordered lists are grouped as heterogeneous data structures. </span><span class="s1">Linear data structures are lists, sets, tuples, queues, stacks, and heaps. Trees, tables, and containers are categorized as nonlinear data structures. Two-dimensional and multidimensional arrays are grouped as homogeneous data structures. Dynamic data structures are dictionaries, tree sets, and sequences.</span></p>
<p>The classification of <strong>Data Structures</strong> is show in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b2325558-71a8-47e6-bb1b-fef9586dd8cc.png" style="width:48.42em;height:33.33em;" width="984" height="678"/></p>
<p>Let's take a look at lists, tuples and heaps in the next sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lists</h1>
                </header>
            
            <article>
                
<p class="p1">A list is a sequence of elements. Each element can be connected to another with a link in a forward or backward direction. The element can have other payload properties. This data structure is a basic type of container. Lists have a variable length and developer can remove or add <span>elements more </span>easily than an array. Data items within a list need not be contiguous in memory or on disk. Linked lists were proposed by Allen Newell, Cliff Shaw, and Herbert A. Simon at RAND Corporation.</p>
<p class="mce-root"/>
<p class="p1">To get started, a list can be used in Go, as shown in the following example; elements are added through the <kbd>PushBack</kbd> method on the list, which is in the <kbd>container/list</kbd> package:</p>
<pre>//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/><br/>// importing fmt and container list packages<br/>import (<br/>   "fmt"<br/>   "container/list")<br/><br/>// main method<br/>func main() {<br/>    var intList list.List<br/>    intList.PushBack(11)<br/>    intList.PushBack(23)<br/>    intList.PushBack(34)<br/><br/>    for element := intList.Front(); element != nil; element=element.Next() {<br/>        fmt.Println(element.Value.(int))<br/>    }<br/>}</pre>
<p class="p1">The list is iterated through the <kbd>for</kbd> loop, and the element's value is accessed through the <kbd>Value</kbd> method.</p>
<p class="p1"><span>Run the following commands:</span></p>
<pre><strong>go run list.go</strong></pre>
<p class="p1"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d6679223-be43-4d23-a5bd-60ab04d1a8b2.png" style="width:31.75em;height:8.25em;" width="894" height="232"/></p>
<p class="mce-root">Let's take a look at Tuples in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tuples</h1>
                </header>
            
            <article>
                
<p class="p1">A tuple is a finite sorted list of elements. It<span> is a data structure that groups data. </span> Tuples are typically immutable sequential collections. The element has related fields of different datatypes. The only way to modify a tuple is to change the fields. Operators such as + and * can be applied to tuples. A database record is referred to as a tuple. In the following example, power series of integers are calculated and the square and cube of the integer is returned as a tuple:</p>
<pre>//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/><br/>)<br/>//gets the power series of integer a and returns tuple of square of a<br/>// and cube of a<br/>func powerSeries(a int) (int,int) {<br/><br/>  return a*a, a*a*a<br/><br/>}</pre>
<p class="p1"><span class="s1">The <kbd>main</kbd> method calls the <kbd>powerSeries</kbd> method with <kbd>3</kbd> as a parameter.<span class="Apple-converted-space"> The</span></span> <kbd>square</kbd> <span class="s1">and <kbd>cube</kbd> values are returned from the method:</span></p>
<pre>// main method<br/>func main() {<br/><br/>  var square int<br/>  var cube int<br/>  square, cube = powerSeries(3)<br/><br/>  fmt.Println("Square ", square, "Cube", cube)<br/><br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>Run the following commands:</span></p>
<pre><strong>go run tuples.go</strong></pre>
<p class="p1"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/378425c0-4233-4fc6-b008-e6de29c70d6c.png" style="width:31.83em;height:7.42em;" width="959" height="222"/></p>
<p>The tuples can be named in the <kbd>powerSeries</kbd> <span>function, as shown in the following code:</span></p>
<pre>func powerSeries(a int) (square int, cube int) {<br/><br/>  square = a*a<br/> <br/>  cube = square*a<br/>  <br/>  return <br/><br/>}</pre>
<p class="p1"><span class="s1">If there is an error, it can be passed with tuples, as shown in the following code:</span></p>
<pre>func powerSeries(a int) (int, int, error) {<br/><br/>  square = a*a<br/> <br/>  cube = square*a<br/>  <br/>  return square,cube,nil<br/><br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Heaps</h1>
                </header>
            
            <article>
                
<p class="p1">A heap is a data structure that is based on the <kbd>heap</kbd> property. The h<span>eap data structure is used in selection, graph, and k-way merge algorithms. Operations such as finding, merging, insertion, key changes, and deleting are performed on heaps. Heaps are part of the </span><kbd>container/heap</kbd><span> package in Go.</span> According to the heap order (maximum heap) property, the value stored at each node is greater than or equal to its children.</p>
<p class="p1">If the order is descending, it is referred to as a maximum heap; otherwise, it's a minimum heap.<span> </span><span>The h</span>eap data structure was proposed by J.W.J. Williams in 1964 for a heap sorting algorithm. It is not a sorted data structure, but partially ordered. The following example shows how to use the <kbd>container/heap</kbd> package to create a heap data structure:</p>
<pre>//main package has examples shown<br/>//<span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/><br/>// importing fmt package and container/heap<br/>import (<br/>  "container/heap"<br/>  "fmt"<br/>)<br/>// integerHeap a type<br/>type IntegerHeap []int<br/><br/>// IntegerHeap method - gets the length of integerHeap<br/>func (iheap IntegerHeap) Len() int { return len(iheap) }<br/><br/>// IntegerHeap method - checks if element of i index is less than j index<br/>func (iheap IntegerHeap) Less(i, j int) bool { return iheap[i] &lt; iheap[j] }<br/>// IntegerHeap method -swaps the element of i to j index<br/>func (iheap IntegerHeap) Swap(i, j int) { iheap[i], iheap[j] = iheap[j], iheap[i] }</pre>
<p class="p1"><span class="s1"><kbd>IntegerHeap</kbd> has a <kbd>Push</kbd> method that pushes the item with the interface:</span></p>
<pre><br/>//IntegerHeap method -pushes the item<br/>func (iheap *IntegerHeap) Push(heapintf interface{}) {<br/><br/> *iheap = append(*iheap, heapintf.(int))<br/>}<br/>//IntegerHeap method -pops the item from the heap<br/>func (iheap *IntegerHeap) Pop() interface{} {<br/> var n int<br/> var x1 int<br/> var previous IntegerHeap = *iheap<br/> n = len(previous)<br/> x1 = previous[n-1]<br/> *iheap = previous[0 : n-1]<br/> return x1<br/>}<br/><br/>// main method<br/>func main() {<br/> var intHeap *IntegerHeap = &amp;IntegerHeap{1,4,5}<br/><br/> heap.Init(intHeap)<br/> heap.Push(intHeap, 2)<br/> fmt.Printf("minimum: %d\n", (*intHeap)[0])<br/> for intHeap.Len() &gt; 0 {<br/> fmt.Printf("%d \n", heap.Pop(intHeap))<br/> }<br/>}</pre>
<p><span>Run the following commands:</span></p>
<pre><strong>go run heap.go</strong></pre>
<p><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1da0d4df-5edd-44a8-8a19-a991e77d7b5a.png" width="1144" height="268"/></p>
<p class="mce-root">Let's take a look at structural design patterns in the next section</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Structural design patterns</h1>
                </header>
            
            <article>
                
<p>Structural design patterns describe the relationships between the entities. They are used to form large structures using classes and objects. These patterns are used to create a system with different system blocks in a flexible manner. Adapter, bridge, composite, decorator, facade, flyweight, private class data, and proxy are the <strong>Gang of Four</strong> (<strong>GoF</strong>) structural design patterns.<span><span> The private class data design pattern is the other design pattern covered in this section.</span></span></p>
<p>We will take a look at adapter and bridge design patterns in the next sections.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adapter</h1>
                </header>
            
            <article>
                
<p class="mce-root">The adapter pattern provides a wrapper with an interface required by the API client to link incompatible types and act as a translator between the two types. The adapter uses the interface of a class to be a class with another compatible interface. When requirements change, there are scenarios where class functionality needs to be changed because of incompatible interfaces.</p>
<p class="mce-root">The dependency inversion principle can be adhered to by using the adapter pattern, when a class defines its own interface to the next level module interface implemented by an <kbd>adapter</kbd> class. Delegation is the other principle used by the adapter pattern. Multiple formats handling source-to-destination transformations are the scenarios where the adapter pattern is applied.</p>
<p class="mce-root">The adapter pattern comprises the target, adaptee, adapter, and client:</p>
<ul>
<li class="mce-root">Target is the interface that the client calls and invokes methods on the adapter and adaptee.</li>
<li class="mce-root">The client wants the incompatible interface implemented by the adapter.</li>
<li class="mce-root">The adapter translates the incompatible interface of the adaptee into an interface that the client wants.</li>
</ul>
<p class="mce-root">Let's say you have an <kbd>IProcessor</kbd> interface with a <kbd>process</kbd> <span>method</span>, the <kbd>Adapter</kbd> class implements the <kbd>process</kbd> <span>method</span> and has an <kbd>Adaptee</kbd> instance as an attribute. The <kbd>Adaptee</kbd> class has a <span><kbd>convert</kbd> </span>method and an <span><kbd>adapterType</kbd> </span>instance variable. The developer while using the API client calls the <kbd>process</kbd> <span>interface method</span> to invoke <kbd>convert</kbd> on <kbd>Adaptee</kbd>. The code is as follows:</p>
<pre class="mce-root">//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/>)<br/>//IProcess interface<br/>type IProcess interface {<br/> process()<br/>}<br/>//Adapter struct<br/>type Adapter struct {<br/> adaptee Adaptee<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mce-root">The <kbd>Adapter</kbd> class has a <kbd>process</kbd> method that invokes the <kbd>convert</kbd> method on <kbd>adaptee</kbd>:</p>
<pre class="mce-root">//Adapter class method process<br/>func (adapter Adapter) process() {<br/> fmt.Println("Adapter process")<br/> adapter.adaptee.convert()<br/>}<br/>//Adaptee Struct<br/>type Adaptee struct {<br/> adapterType int<br/>}<br/>// Adaptee class method convert<br/>func (adaptee Adaptee) convert() {<br/> fmt.Println("Adaptee convert method")<br/>}<br/>// main method<br/>func main() {<br/>var processor IProcess = Adapter{}<br/>processor.process()<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run adapter.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/223e23d0-ea9a-4a27-af29-aa37f8a8c311.png" width="1146" height="191"/></p>
<p class="mce-root">Let's take a look at Bridge pattern in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bridge</h1>
                </header>
            
            <article>
                
<p class="mce-root">Bridge decouples the implementation from the abstraction. The abstract base class can be subclassed to provide different implementations and allow implementation details to be modified easily. The interface, which is a bridge, helps in making the functionality of concrete classes independent from the interface implementer classes. The bridge patterns allow the implementation details to change at runtime.</p>
<p class="mce-root"/>
<p class="mce-root">The bridge pattern demonstrates the principle, preferring composition over inheritance. It helps in situations where one should subclass multiple times orthogonal to each other. Runtime binding of the application, mapping of orthogonal class hierarchies, and platform independence implementation are the scenarios where the bridge pattern can be applied.</p>
<p class="mce-root">The bridge pattern components are abstraction, refined abstraction, implementer, and concrete implementer. Abstraction is the interface implemented as an abstract class that clients invoke with the method on the concrete implementer. Abstraction maintains a <em>has-a</em> relationship with the implementation, instead of an <em>is-a</em> relationship. The <em>has-a</em> relationship is maintained by composition. Abstraction has a reference of the implementation. Refined abstraction provides more variations than abstraction.</p>
<p class="mce-root">Let's say <kbd>IDrawShape</kbd> is an interface with the <kbd>drawShape</kbd> method.  <kbd>DrawShape</kbd> implements the <kbd>IDrawShape</kbd> interface. We create an <kbd>IContour</kbd> <span>bridge interface </span>with the <kbd>drawContour</kbd> method. The contour class implements the <kbd>IContour</kbd> interface. The <kbd>ellipse</kbd> class will have <em>a</em>, <em>b</em> , <em>r</em> properties and <kbd>drawShape</kbd> (an instance of <kbd>DrawShape</kbd>). The <kbd>ellipse</kbd> class implements the <kbd>contour</kbd> bridge interface to implement the <kbd>drawContour</kbd> method. The  <kbd>drawContour</kbd> method calls the <kbd>drawShape</kbd> method on the <kbd>drawShape</kbd> instance.</p>
<p class="mce-root">The following code demonstrates the bridge implementation: </p>
<pre class="mce-root">//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/>)<br/>//IDrawShape interface<br/>type IDrawShape interface {<br/> drawShape(x[5] float32,y[5] float32)<br/>}<br/>//DrawShape struct<br/>type DrawShape struct{}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">drawShape method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>drawShape</kbd> method draws the shape given the coordinates, as shown in the following code:</p>
<pre class="mce-root">// DrawShape struct has method draw Shape with float x and y coordinates<br/>func (drawShape DrawShape) drawShape(x[5] float32, y[5] float32) {<br/> fmt.Println("Drawing Shape")<br/>}<br/>//IContour interace<br/>type IContour interface {<br/> drawContour(x[5] float32 ,y[5] float32)<br/> resizeByFactor(factor int)<br/>}<br/>//DrawContour struct<br/>type DrawContour struct {<br/> x[5] float32<br/> y[5] float32<br/> shape DrawShape<br/> factor int<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">drawContour method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd><span>drawContour</span></kbd> method of t<span>he </span><kbd>DrawContour</kbd><span> class</span> calls the <kbd>drawShape</kbd> method on the <kbd>shape</kbd> instance, this is shown in the following code:</p>
<pre class="mce-root">//DrawContour method drawContour given the coordinates<br/>func (contour DrawContour) drawContour(x[5] float32,y[5] float32) {<br/> fmt.Println("Drawing Contour")<br/> contour.shape.drawShape(contour.x,contour.y)<br/>}<br/>//DrawContour method resizeByFactor given factor<br/>func (contour DrawContour) resizeByFactor(factor int) {<br/> contour.factor = factor<br/>}<br/>// main method<br/>func main() {<br/>var x = [5]float32{1,2,3,4,5}<br/>var y = [5]float32{1,2,3,4,5}<br/>var contour IContour = DrawContour{x,y,DrawShape{},2}<br/>contour.drawContour(x,y)<br/> contour.resizeByFactor(2)<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run bridge.go</strong></pre>
<p class="mce-root"/>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c0562db0-8f61-409a-b8b9-a50c0d2ca323.png" style="width:34.83em;height:7.75em;" width="937" height="208"/></p>
<p>We will take a look at Composite, Decorator, Facade and Flyweight design patterns in the next sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Composite</h1>
                </header>
            
            <article>
                
<p class="mce-root">A composite is a group of similar objects in a single object. Objects are stored in a tree form to persist the whole hierarchy. The composite pattern is used to change a hierarchical collection of objects. The<span> composite pattern is modeled on a heterogeneous collection</span>. New types of objects can be added without changing the interface and the client code. You can use the composite pattern, for example, for UI layouts on the web, for directory trees, and for managing employees across departments. The pattern provides a mechanism to access the individual objects and groups in a similar manner.</p>
<p class="mce-root">The composite pattern comprises the <kbd>component</kbd> interface, <kbd>component</kbd> class, composite, and client:</p>
<ul>
<li class="mce-root">The <kbd>component</kbd> interface defines the default behavior of all objects and behaviors for accessing the components of the composite.</li>
<li class="mce-root">The <kbd>composite</kbd> and <kbd>component</kbd> classes implement the <kbd>component</kbd> interface.</li>
<li class="mce-root">The client interacts with the component interface to invoke methods in the composite.</li>
</ul>
<p class="mce-root">Let's say there is an <kbd>IComposite</kbd> interface with the <kbd>perform</kbd> method and <kbd>BranchClass</kbd> that implements <kbd>IComposite</kbd>  and has the <kbd>addLeaf</kbd>, <kbd>addBranch</kbd>, and <kbd>perform</kbd> methods. The <kbd>Leaflet</kbd> class implements <kbd>IComposite</kbd> with the <kbd>perform</kbd> method. <kbd>BranchClass</kbd> has a one-to-many relationship with <kbd>leafs</kbd> and <kbd>branches</kbd>. Iterating over the branch recursively, one can traverse the composite tree, as shown in the following code:</p>
<pre class="mce-root">//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/>)<br/>// IComposite interface<br/>type IComposite interface {<br/> perform()<br/>}<br/>// Leaflet struct<br/>type Leaflet struct {<br/> name string<br/>}<br/>// Leaflet class method perform<br/>func (leaf *Leaflet) perform() {<br/>fmt.Println("Leaflet " + leaf.name)<br/>}<br/>// Branch struct<br/>type Branch struct {<br/> leafs []Leaflet<br/> name string<br/> branches[]Branch<br/>}</pre>
<p class="mce-root">The <kbd><span>perform</span></kbd> method of t<span>he </span><kbd>Branch</kbd><span> class</span> calls the <kbd>perform</kbd> method on <kbd>branch</kbd> and <kbd>leafs</kbd>, as seen in the code:</p>
<pre class="mce-root">// Branch class method perform<br/>func (branch *Branch) perform() {<br/>fmt.Println("Branch: " + branch.name)<br/> for _, leaf := range branch.leafs {<br/> leaf.perform()<br/> }<br/>for _, branch := range branch.branches {<br/> branch.perform()<br/> }<br/>}<br/>// Branch class method add leaflet<br/>func (branch *Branch) add(leaf Leaflet) {<br/> branch.leafs = append(branch.leafs, leaf)<br/>}</pre>
<p class="mce-root">As shown in the following code, the <kbd><span>addBranch</span></kbd> method of <span>the </span><kbd>Branch</kbd><span> class </span>adds a new <kbd>branch</kbd>:</p>
<pre class="mce-root">//Branch class method addBranch branch<br/>func (branch *Branch) addBranch(newBranch Branch) {<br/>branch.branches = append(branch.branches,newBranch)<br/>}<br/>//Branch class method getLeaflets<br/>func (branch *Branch) getLeaflets() []Leaflet {<br/> return branch.leafs<br/>}<br/>// main method<br/>func main() {<br/>var branch = &amp;Branch{name:"branch 1"}<br/>var leaf1 = Leaflet{name:"leaf 1"}<br/>var leaf2 = Leaflet{name:"leaf 2"}<br/>var branch2 = Branch{name:"branch 2"}<br/>branch.add(leaf1)<br/>branch.add(leaf2)<br/>branch.addBranch(branch2)<br/>branch.perform()<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run composite.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7a67a4b3-ef1f-4476-af3f-1007ce8049fd.png" style="width:37.58em;height:8.25em;" width="1144" height="249"/></p>
<p class="mce-root"><span>Let's take a look at Decorator pattern in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Decorator</h1>
                </header>
            
            <article>
                
<p class="mce-root">In a scenario where class responsibilities are removed or added, the decorator pattern is applied. The decorator pattern helps with subclassing <span><span>when </span></span>modifying functionality, instead of static inheritance. An object can have multiple decorators and run-time decorators. The single responsibility principle can be achieved using a decorator. The <span>dec</span><span>orator can be applied to</span> window components and graphical object modeling. The decorator pattern helps with modifying existing instance attributes and adding new methods at run-time.</p>
<p class="mce-root"/>
<p class="mce-root">The decorator pattern participants are the component interface, the concrete component class, and the <kbd>decorator</kbd> class:</p>
<ul>
<li class="mce-root">The concrete component implements the component interface.</li>
<li class="mce-root">The <kbd>decorator</kbd> class implements the component interface and provides additional functionality in the same method or additional methods. The decorator base can be a participant representing the base class for all decorators.</li>
</ul>
<p class="mce-root">Let 's say <kbd>IProcess</kbd> is an interface with <span>the <kbd>process</kbd> method</span>. <kbd>ProcessClass</kbd> implements an interface with the <kbd>process</kbd> method. <kbd>ProcessDecorator</kbd> implements the process interface and has an instance of <kbd>ProcessClass</kbd>. <kbd>ProcessDecorator</kbd> can add more functionality than <kbd>ProcessClass</kbd>, as shown in the following code:</p>
<pre class="mce-root">//main package has examples shown<br/> // <span>in Hands-On Data Structures and algorithms with Go book</span><br/> package main<br/>// importing fmt package<br/> import (<br/> "fmt"<br/> )<br/>// IProcess Interface<br/> type IProcess interface {<br/> process()<br/> }<br/>//ProcessClass struct<br/> type ProcessClass struct{}<br/>//ProcessClass method process<br/> func (process *ProcessClass) process() {<br/> fmt.Println("ProcessClass process")<br/> }<br/>//ProcessDecorator struct<br/> type ProcessDecorator struct {<br/> processInstance *ProcessClass<br/> }</pre>
<p class="mce-root">In the following code, the <kbd>ProcessDecorator</kbd> class <kbd>process</kbd> <span>method </span>invokes the <kbd>process</kbd> method on the decorator instance of <kbd>ProcessClass</kbd>:</p>
<pre class="mce-root"><br/> //ProcessDecorator class method process<br/> func (decorator *ProcessDecorator) process() {<br/> if decorator.processInstance == nil {<br/> fmt.Println("ProcessDecorator process")<br/> } else {<br/> fmt.Printf("ProcessDecorator process and ")<br/> decorator.processInstance.process()<br/>}<br/> }<br/>//main method<br/> func main() {<br/>var process = &amp;ProcessClass{}<br/>var decorator = &amp;ProcessDecorator{}<br/>decorator.process()<br/>decorator.processInstance = process<br/>decorator.process()<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run decorator.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/35c5bee2-bd71-40f0-b536-c8ff3651b2be.png" style="width:34.00em;height:6.25em;" width="968" height="177"/></p>
<p class="mce-root"><span>Let's take a look at Facade pattern in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Facade</h1>
                </header>
            
            <article>
                
<p class="mce-root">Facade is used to abstract subsystem interfaces with a helper. The facade design pattern is used in scenarios <span>when the number of interfaces increases</span> and the system gets complicated. Facade is an entry point to different subsystems, and it simplifies the dependencies between the systems. The facade pattern provides an interface that hides the implementation details of the hidden code.</p>
<p class="mce-root">A loosely coupled principle can be realized with a facade pattern. <span>You can use a facade to improve poorly designed APIs</span>. In SOA, a service facade can be used to incorporate changes to the contract and implementation.</p>
<p class="mce-root"/>
<p class="mce-root">The facade pattern is made up of the <kbd>facade</kbd> class, module classes, and a client:</p>
<ul>
<li class="mce-root">The facade delegates the requests from the client to the module classes. The <kbd>facade</kbd> class hides the complexities of the subsystem logic and rules.</li>
<li class="mce-root">Module classes implement the behaviors and functionalities of the module subsystem.</li>
<li class="mce-root">The client invokes the <kbd>facade</kbd> method. The <kbd>facade</kbd> class functionality can be spread across multiple packages and assemblies.</li>
</ul>
<p class="mce-root">For example, account, customer, and transaction are the classes that have account, customer, and transaction creation methods. <kbd>BranchManagerFacade</kbd> can be used by the client to create an account, customer, and transaction:</p>
<pre>//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/> )<br/> //Account struct<br/> type Account struct{<br/>id string<br/>accountType string<br/>}<br/>//Account class method create - creates account given AccountType<br/>func (account *Account) create(accountType string) *Account{<br/> fmt.Println("account creation with type")<br/> account.accountType = accountType<br/>return account<br/>}<br/>//Account class method getById given id string<br/>func (account *Account) getById(id string) *Account {<br/> fmt.Println("getting account by Id")<br/> return account<br/> }</pre>
<p>The <kbd>account</kbd> class has the <kbd>deleteById</kbd> method, which is used to delete an account with a given ID, as shown in the following code:</p>
<pre class="mce-root"> //Account class method deleteById given id string<br/> func (account *Account) deleteById(id string)() {<br/> fmt.Println("delete account by id")<br/> }<br/>//Customer struct<br/> type Customer struct{<br/> name string<br/> id int<br/> }</pre>
<p class="mce-root">In the following code, the <kbd>customer</kbd> class has a method that creates a new customer with <kbd>name</kbd>:</p>
<pre class="mce-root">//Customer class method create - create Customer given name<br/> func (customer *Customer) create(name string) *Customer {<br/> fmt.Println("creating customer")<br/> customer.name = name<br/> return customer<br/> }<br/>//Transaction struct<br/> type Transaction struct{<br/> id string<br/> amount float32<br/> srcAccountId string<br/> destAccountId string<br/> }</pre>
<p class="mce-root">As shown in the following code, the <kbd>transaction</kbd> class has the <kbd>create</kbd> method for creating a transaction:</p>
<pre class="mce-root">//Transaction class method create Transaction<br/> func (transaction *Transaction) create(srcAccountId string, destAccountId string,amount float32) *Transaction {<br/> fmt.Println("creating transaction")<br/> transaction.srcAccountId = srcAccountId<br/> transaction.destAccountId = destAccountId<br/> transaction.amount = amount<br/> return transaction<br/> }<br/> //BranchManagerFacade struct<br/> type BranchManagerFacade struct {<br/> account *Account<br/> customer *Customer<br/> transaction *Transaction<br/> }<br/>//method NewBranchManagerFacade<br/> func NewBranchManagerFacade() *BranchManagerFacade {<br/> return &amp;BranchManagerFacade{ &amp;Account{}, &amp;Customer{}, &amp;Transaction{}}<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"><kbd>BranchManagerFacade</kbd> has the <kbd>createCustomerAccount</kbd> method, which calls the <kbd>create</kbd> method on the <kbd>customer</kbd> class instance, as shown in the following code:</p>
<pre class="mce-root">//BranchManagerFacade class method createCustomerAccount<br/> func (facade *BranchManagerFacade) createCustomerAccount(customerName string, accountType string) (*Customer,*Account) {<br/> var customer = facade.customer.create(customerName)<br/> var account = facade.account.create(accountType)<br/> return customer, account<br/> }<br/> //BranchManagerFacade class method createTransaction<br/> func (facade *BranchManagerFacade) createTransaction(srcAccountId string, destAccountId string, amount float32) *Transaction {<br/>var transaction = facade.transaction.create(srcAccountId,destAccountId,amount)<br/> return transaction<br/>}</pre>
<p class="mce-root">The <kbd>main</kbd> method calls the <kbd>NewBranchManagerFacade</kbd> method to create a facade. The methods on <kbd>facade</kbd> are invoked to create <kbd>customer</kbd> and <kbd>account</kbd>:</p>
<pre class="mce-root">//main method<br/>func main() {<br/>    var facade = NewBranchManagerFacade()<br/>    var customer *Customer<br/>    var account *Account<br/>    customer, account = facade.createCustomerAccount("Thomas Smith", <br/>    "Savings")<br/>    fmt.Println(customer.name)<br/>    fmt.Println(account.accountType)<br/>    var transaction = facade.createTransaction("21456","87345",1000)<br/>    fmt.Println(transaction.amount)<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run facade.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/bfc322d5-0edc-436f-bb73-cfa293d08583.png" style="width:37.33em;height:9.33em;" width="1136" height="283"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span>Let's take a look at Flyweight pattern in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flyweight</h1>
                </header>
            
            <article>
                
<p class="mce-root">Flyweight is used to manage the state of an object <span>with high variation</span>. The pattern allows us to share common parts of the object state among multiple objects, instead of each object storing it. Variable object data is referred to as extrinsic state, and the rest of the object state is intrinsic. Extrinsic data is passed to flyweight methods and will never be stored within it. Flyweight pattern helps reduce the overall memory usage and the object initializing overhead. The pattern helps create interclass relationships and lower memory to a manageable level.</p>
<p class="mce-root">Flyweight objects are immutable. Value objects are a good example of the flyweight pattern. Flyweight objects can be created in a single thread mode, ensuring one instance per value. In a concurrent thread scenario, multiple instances are created. This is based on the equality criterion of flyweight objects.</p>
<p class="mce-root">The participants of the flyweight pattern are the <kbd>FlyWeight</kbd> interface, <kbd>ConcreteFlyWeight</kbd>, <kbd>FlyWeightFactory</kbd>, and the <kbd>Client</kbd> classes:</p>
<ul>
<li class="mce-root">The <kbd>FlyWeight</kbd> interface has a method through which flyweights can get and act on the extrinsic state.</li>
<li class="mce-root"><kbd>ConcreteFlyWeight</kbd> implements the <kbd>FlyWeight</kbd> interface to represent flyweight objects.</li>
<li class="mce-root"><kbd>FlyweightFactory</kbd> is used to create and manage flyweight objects. The client invokes <kbd>FlyweightFactory</kbd> to get a flyweight object. <kbd>UnsharedFlyWeight</kbd> can have a functionality that is not shared.</li>
<li><kbd>Client</kbd> classes</li>
</ul>
<p class="mce-root">Let's say <kbd>DataTransferObject</kbd> is an interface with the <kbd>getId</kbd> method. <kbd>DataTransferObjectFactory</kbd> creates a data transfer object through <kbd>getDataTransferObject</kbd> by the <kbd>DTO</kbd> type. The <kbd>DTO</kbd> types are customer, employee, manager, and address, as shown in the following code:</p>
<pre class="mce-root">//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/> package main<br/>// importing fmt package<br/> import (<br/> "fmt"<br/> )<br/> //DataTransferObjectFactory struct<br/> type DataTransferObjectFactory struct {<br/> pool map[string] DataTransferObject<br/> }<br/>//DataTransferObjectFactory class method getDataTransferObject<br/> func (factory DataTransferObjectFactory) getDataTransferObject(dtoType string) DataTransferObject {<br/>var dto = factory.pool[dtoType]<br/>if dto == nil {<br/>fmt.Println("new DTO of dtoType: " + dtoType)<br/> switch dtoType{<br/> case "customer":<br/> factory.pool[dtoType] = Customer{id:"1"}<br/> case "employee":<br/> factory.pool[dtoType] = Employee{id:"2"}<br/> case "manager":<br/> factory.pool[dtoType] = Manager{id:"3"}<br/> case "address":<br/> factory.pool[dtoType] = Address{id:"4"}<br/> }<br/>dto = factory.pool[dtoType]<br/>}<br/><br/> return dto<br/> }</pre>
<p class="mce-root">In the following code, the <kbd>DataTransferObject</kbd> interface is implemented by the <kbd>Customer</kbd> class:</p>
<pre class="mce-root">// DataTransferObject interface<br/> type DataTransferObject interface {<br/> getId() string<br/> }<br/> //Customer struct<br/> type Customer struct {<br/> id string //sequence generator<br/> name string<br/> ssn string<br/> }<br/> // Customer class method getId<br/> func (customer Customer) getId() string {<br/> //fmt.Println("getting customer Id")<br/> return customer.id<br/>}<br/> //Employee struct<br/> type Employee struct {<br/> id string<br/> name string<br/> }<br/> //Employee class method getId<br/> func (employee Employee) getId() string {<br/> return employee.id<br/> }<br/> //Manager struct<br/> type Manager struct {<br/> id string<br/> name string<br/> dept string<br/> }</pre>
<p class="mce-root">The <kbd>DataTransferObject</kbd> interface is implemented by the <kbd>Manager</kbd> class, as shown in the following code:</p>
<pre class="mce-root">//Manager class method getId<br/> func (manager Manager) getId() string {<br/> return manager.id<br/> }<br/> //Address struct<br/> type Address struct {<br/> id string<br/> streetLine1 string<br/> streetLine2 string<br/> state string<br/> city string<br/>}<br/>//Address class method getId<br/> func (address Address) getId() string{<br/> return address.id<br/> }<br/> //main method<br/> func main() {<br/> var factory = DataTransferObjectFactory{make(map[string]DataTransferObject)}<br/> var customer DataTransferObject = factory.getDataTransferObject("customer")<br/> fmt.Println("Customer ",customer.getId())<br/> var employee DataTransferObject = factory.getDataTransferObject("employee")<br/> fmt.Println("Employee ",employee.getId())<br/> var manager DataTransferObject = factory.getDataTransferObject("manager")<br/> fmt.Println("Manager",manager.getId())<br/> var address DataTransferObject = factory.getDataTransferObject("address")<br/> fmt.Println("Address",address.getId())<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run flyweight.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/839f35da-05ca-48fc-aa64-769274250a37.png" style="width:34.83em;height:10.75em;" width="1140" height="351"/></p>
<p>We will take a look at Private class and Proxy data patterns in the next sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Private class data</h1>
                </header>
            
            <article>
                
<p class="mce-root">The private class data pattern secures the data within a class. This pattern encapsulates the initialization of the class data. The write privileges of properties within the private class are protected, and properties are set during construction. The private class pattern prints the exposure of information by securing it in a class that retains the state. The encapsulation of class data initialization is a scenario where this pattern is applicable.</p>
<p class="mce-root"><kbd>Account</kbd> is a class with account details and a customer name. <kbd>AccountDetails</kbd> is the private attribute of <kbd>Account</kbd> , and <kbd>CustomerName</kbd> is the public attribute. JSON marshaling of <kbd>Account</kbd> has <kbd>CustomerName</kbd> as a public property. <kbd>AccountDetails</kbd> is the package property in Go (modeled as private class data):</p>
<pre class="mce-root">//main package has examples shown<br/> // <span>in Hands-On Data Structures and algorithms with Go book</span><br/> package main<br/>// importing fmt and encoding/json packages<br/>import (<br/> "encoding/json"<br/> "fmt"<br/> )<br/> //AccountDetails struct<br/> type AccountDetails struct {<br/> id string<br/> accountType string<br/> }<br/> //Account struct<br/> type Account struct {<br/> details *AccountDetails<br/> CustomerName string<br/> }<br/> // Account class method setDetails<br/> func (account *Account) setDetails(id string, accountType string) {<br/>account.details = &amp;AccountDetails{id, accountType}<br/>}</pre>
<p class="mce-root">As shown in the following code, the <kbd>Account</kbd> class has the <kbd>getId</kbd> method, which returns the <kbd>id</kbd> private class attribute:</p>
<pre class="mce-root">//Account class method getId<br/> func (account *Account) getId() string{<br/>return account.details.id<br/> }<br/> //Account class method getAccountType<br/> func (account *Account) getAccountType() string{<br/>return account.details.accountType<br/> }</pre>
<p class="mce-root">The <kbd>main</kbd> method calls the <kbd>Account</kbd> initializer with <kbd>CustomerName</kbd>. The details of the account are set details with the <kbd>setDetails</kbd> method:</p>
<pre class="mce-root">// main method<br/> func main() {<br/>var account *Account = &amp;Account{CustomerName: "John Smith"}<br/> account.setDetails("4532","current")<br/>jsonAccount, _ := json.Marshal(account)<br/> fmt.Println("Private Class hidden",string(jsonAccount))<br/>fmt.Println("Account Id",account.getId())<br/>fmt.Println("Account Type",account.getAccountType())<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run privateclass.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/50c0055c-a7f4-4d86-bf64-d30690516cf0.png" style="width:33.00em;height:7.33em;" width="1016" height="224"/></p>
<p class="mce-root"><span>Let's take a look at Proxy pattern in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Proxy</h1>
                </header>
            
            <article>
                
<p class="mce-root">The proxy pattern forwards to a real object and acts as an interface to others. The proxy pattern controls access to an object and provides additional functionality. The additional functionality can be related to authentication, authorization, and providing rights of access to the resource-sensitive object. The real object need not be modified while providing additional logic. Remote, smart, virtual, and protection proxies are the scenarios where this pattern is applied. It is also used to provide an alternative to extend functionality with inheritance and object composition. A proxy object is also referred to as a surrogate, handle, or wrapper.</p>
<p class="mce-root">The proxy pattern comprises the subject interface, the <kbd>RealSubject</kbd> class, and the <kbd>Proxy</kbd> class:</p>
<ul>
<li class="mce-root">Subject is an interface for the <kbd>RealObject</kbd> and <kbd>Proxy</kbd> class.</li>
<li class="mce-root">The <kbd>RealSubject</kbd> object is created and maintained as a reference in the <kbd>Proxy</kbd> class. <kbd>RealSubject</kbd> is resource sensitive, required to be protected, and expensive to create.  <kbd>RealObject</kbd> is a class that implements the <kbd>IRealObject</kbd> interface. It has a <kbd>performAction</kbd> method. </li>
<li class="mce-root"><kbd>VirtualProxy</kbd> is used to access <kbd>RealObject</kbd> and invoke the <kbd>performAction</kbd> method.</li>
</ul>
<p>The following code shows an implementation of proxy pattern:</p>
<pre class="mce-root"><br/> //main package has examples shown<br/> // <span>in Hands-On Data Structures and algorithms with Go book</span><br/> package main<br/>// importing fmt package<br/> import (<br/> "fmt"<br/> )<br/> //IRealObject interface<br/> type IRealObject interface {<br/> performAction()<br/> }<br/> //RealObject struct<br/> type RealObject struct{}<br/>RealObject class implements IRealObject interface. The class has method performAction.<br/> //RealObject class method performAction<br/> func (realObject *RealObject) performAction() {<br/> fmt.Println("RealObject performAction()")<br/> }<br/> //VirtualProxy struct<br/> type VirtualProxy struct {<br/> realObject *RealObject<br/> }<br/> //VirtualProxy class method performAction<br/> func (virtualProxy *VirtualProxy) performAction() {<br/> if virtualProxy.realObject == nil {<br/> virtualProxy.realObject = &amp;RealObject{}<br/> }<br/> fmt.Println("Virtual Proxy performAction()")<br/> virtualProxy.realObject.performAction()<br/> }<br/> // main method<br/> func main() {<br/> var object VirtualProxy = VirtualProxy{}<br/> object.performAction()<br/> }</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run virtualproxy.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/938fb87b-a174-4cda-82a1-a5bda4e6ebed.png" style="width:37.33em;height:6.83em;" width="1032" height="187"/></p>
<p class="mce-root">Now that we know the classification of data structures and the design patterns used, let's go ahead and take a look at the representation of algorithms. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Representation of algorithms</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A flow chart and pseudo code are methods of representing algorithms.<span class="Apple-converted-space"> </span></span><span class="s1">An algorithm shows the logic of how a problem is solved. A flow chart has different representation symbols such as</span> Entry, Exit, Task, Input/Output, Decision Point, and Inter Block. A s<span class="s1">tructured program consists of a series of these symbols to perform a specific task. Pseudo code has documentation, action, and flow control keywords to visualize an algorithm. The documentation keywords are <strong>TASK</strong> and <strong>REM</strong>. <strong>SET</strong>, <strong>PUT</strong></span>, <span class="s1">and <strong>GET</strong> are the action keywords.</span></p>
<p>Let's take a look at the different representations of algorithms, that is, flow charts and Pseudo code in the next sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flow chart</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1"><span>The flow control keywords are</span></span> <strong>SET</strong><span class="s1"><span>, <strong>LOOP</strong>, (<strong>WHILE</strong>, <strong>UNTIL</strong>), <strong>REP,</strong> and <strong>POST</strong>. </span>The following flow chart shows a formula or an algorithm to calculate the dividend given a number of shares, the face value, and the dividend percentage. The s</span>tart and end <span class="s1">are th</span>e Entry and Exit symbols. The input number of shares, share face value, and dividend percentage use the Input symbol. The compute dividend and output dividend use the Task symbol and Output symbol respec<span class="s1">tively:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/54bfe074-8b26-4af2-8e65-4285564adc78.png" style="width:18.58em;height:25.92em;" width="444" height="620"/></p>
<p class="mce-root"/>
<p><span> In the next section, we'll</span> take a look at pseudo code, representation of algorithms.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pseudo code</h1>
                </header>
            
            <article>
                
<p>Pseudo code is a high-level design of a program or algorithm. Sequence and selection are two constructs used in pseudo code. Pseudo code is easier than a flow chart visualizes the algorithm while pseudo code can be easily modified and updated. Errors in design can be caught very early in pseudo code. This saves the cost of fixing defects later.</p>
<p class="p3"><span class="s1">To give an example, we want to find the <kbd>max</kbd> value in an array of length <em>n</em>. The pseudo code will be written as follows:</span></p>
<pre class="p6"><span class="s1">maximum(arr) {<br/></span><span class="s1">    n &lt;- len(arr)<br/></span><span class="s1">    max &lt;- arr[0]<br/></span><span class="s1">    for k &lt;- 0,n do<span class="Apple-converted-space">  </span>{<br/></span><span class="s1">        If<span class="Apple-converted-space">  </span>arr[k] &gt; max {<br/></span><span class="s1">            max &lt;- arr[k]<br/></span><span class="s1">        }<br/></span><span class="s1">    }<br/></span><span class="s1">    return max<br/></span><span class="s1">}</span></pre>
<p class="mce-root">Now that we know the different ways to represent the algorithm, let's take a look at how we can monitor its complexity and performance in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Complexity and performance analysis</h1>
                </header>
            
            <article>
                
<p class="mce-root">The efficiency of an algorithm is measured through various parameters, such as CPU time, memory, disk, and network. The complexity is how the algorithm scales when the number of input parameters increases. Performance is a measure of time, space, memory, and other parameters. Algorithms are compared by their processing time and resource consumption. Complexity measures the parameters and is represented by the Big O notation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Complexity analysis of algorithms</h1>
                </header>
            
            <article>
                
<p class="mce-root">The complexity of an algorithm is measured by the speed of the algorithm. Typically, the algorithm will perform differently based on processor speed, disk speed, memory, and other hardware parameters. Hence, asymptotical complexity is used to measure the complexity of an algorithm. An algorithm is a set of steps to be processed by different operations to achieve a task. The time taken for an algorithm to complete is based on the number of steps taken.</p>
<p class="mce-root">Let's say an algorithm iterates through an array, <kbd>m</kbd>, of size <kbd>10</kbd> and update the elements to the sum of index and <kbd>200</kbd>. The computational time will be 10*<em>t,</em> where <em>t</em> is the time taken to add two integers and update them to an array. The next step will be printing them after iterating over an array. The <em>t</em>  time parameter will vary with the hardware of the computer used. Asymptotically, the computational time grows as a factor of <kbd>10</kbd>, as shown in the following code:</p>
<pre class="mce-root">//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/>)<br/>// main method<br/>func main() {<br/> var m [10]int<br/> var k int<br/>for k = 0; k &lt; 10; k++ {<br/> m[k] = k + 200<br/>fmt.Printf("Element[%d] = %d\n", k, m[k] )<br/> }<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run complexity.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5d88a6f8-cc2b-40cb-8f26-1fec5139aed8.png" style="width:30.92em;height:12.25em;" width="1008" height="398"/></p>
<p>Let's take a look at the different complexity types in the next sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Big O notation</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <em>T</em>(<em>n</em>) time function represents the algorithm complexity based on Big O notation. <em>T</em>(<em>n</em>) = <em>O</em>(<em>n</em>) states that an algorithm has a linear time complexity. Using Big O notation, the constant time, linear time, logarithmic time, cubic time, and quadratic time complexity are different complexity types for an algorithm.</p>
<p class="mce-root">Linear time, <em>O</em>(<em>n</em>), is used as a measure of complexity in scenarios such as linear search, traversing, and finding the minimum and maximum number of array elements. ArrayList and queue are data structures that have these methods. An algorithm that has logarithmic time, <em>O</em>(<em>log n</em>), is a binary search in a tree data structure. Bubble sort, selection sort, and insertion sort algorithms have complexity of quadratic time, <em>O</em>(<em>n</em><sup>2</sup>). Big Omega Ω and big Theta Θ are notations for the lower and upper bounds for a particular algorithm.</p>
<p class="mce-root">The worst case, best case, average case, and amortized run-time complexity is used for analysis of algorithms. Amortized run-time complexity is referred to as 2<em><sup>n</sup></em>. Asymptotically, it will tend to <em>O</em>(1).</p>
<p class="mce-root">Big O notation is also used to determine how much space is consumed by the algorithm. This helps us find the best and worst case scenarios, relative to space and time.</p>
<p>Let's take a look at linear complexity in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linear complexity</h1>
                </header>
            
            <article>
                
<p class="mce-root">An algorithm is of linear complexity if the processing time or storage space is directly proportional to the number of input elements to be processed. In Big O notation, linear complexity is presented as <em>O</em>(<em>n</em>). String matching algorithms such as the Boyer-Moore and Ukkonen have linear complexity.</p>
<p class="mce-root">Linear complexity, <em>O</em>(<em>n</em>), is demonstrated in an algorithm as follows:</p>
<pre class="mce-root"><br/>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/>)<br/>// main method<br/>func main() {<br/> var m [10]int<br/> var k int<br/>for k = 0; k &lt; 10; k++ {<br/> m[k] = k * 200<br/>fmt.Printf("Element[%d] = %d\n", k, m[k] )<br/> }<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run linear_complexity.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/13ef15ac-cb0a-4625-ac53-826e6beff0c6.png" style="width:39.08em;height:14.08em;" width="1138" height="410"/></p>
<p class="mce-root"/>
<p class="mce-root">Let's take a look at quadratic complexity in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Quadratic complexity</h1>
                </header>
            
            <article>
                
<p>An algorithm is of quadratic complexity if the processing time is proportional to the square of the number of input elements. In the following case, the complexity of the algorithm is 10*10 = 100. The two loops have <span>a maximum</span> of <kbd>10</kbd>. The quadratic complexity for a multiplication table of <em>n</em> elements is <em>O</em>(<em>n</em><sup>2</sup>).</p>
<p><span>Quadratic complexity, <em>O</em>(<em>n</em></span><sup>2</sup><span>), is shown in the following example:</span></p>
<pre class="mce-root">//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/>// importing fmt package<br/>import (<br/>    "fmt"<br/>)<br/>// main method<br/>func main() {<br/>    var k,l int<br/>    for k = 1; k &lt;= 10; k++ {<br/>        fmt.Println(" Multiplication Table", k)<br/>        for l=1; l &lt;= 10; l++ {<br/>            var x int = l *k<br/>            fmt.Println(x)<br/>        }<br/>    }<br/>}</pre>
<p><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run quadratic_complexity.go</strong></pre>
<p><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5fd50b8f-a8ea-4d8d-b719-b8b881b69e01.png" style="width:32.58em;height:25.17em;" width="1152" height="889"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at cubic complexity in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cubic complexity</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>In the case of cubic complexity, the processing time of an algorithm is proportional to the cube of the input elements. </span>The complexity of the following algorithm is 10*10*10 = 1,000. The three loops have a maximum of 10. The cubic complexity for a matrix update is <em>O</em>(<em>n</em><sup>3</sup>).</p>
<p><span>Cubic complexity <em>O</em>(<em>n<sup>3</sup></em>) is explained in the following example:</span></p>
<pre class="mce-root">//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/>)<br/>// main method<br/>func main() {<br/>var k,l,m int<br/>var arr[10][10][10] int<br/> for k = 0; k &lt; 10; k++ {<br/>for l=0; l &lt; 10; l++ {<br/>for m=0; m &lt; 10; m++ {<br/>arr[k][l][m] = 1<br/>fmt.Println("Element value ",k,l,m," is", arr[k][l][m])<br/>}<br/>}<br/>}<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run cubic_complexity.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3a2abefc-499a-41e6-8d7d-1d352beacd64.png" style="width:23.92em;height:20.58em;" width="1031" height="882"/></p>
<p class="mce-root"><span>Let's take a look at logarithmic complexity in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Logarithmic complexity</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>An algorithm is of logarithmic complexity if the processing time is proportional to the logarithm of the input elements. The logarithm base is typically 2. The following t</span>ree is a binary tree with <kbd>LeftNode</kbd> and <kbd>RightNode</kbd>. The insert operation is of <em>O</em>(<em>log n</em>) complexity, where <em>n</em> is the number of nodes.</p>
<p><span>Logarithmic complexity is presented as follows:</span></p>
<pre class="mce-root">//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/>    "fmt"<br/>)<br/>// Tree struct<br/>type Tree struct {<br/>    LeftNode *Tree<br/>    Value int<br/>    RightNode *Tree<br/>}</pre>
<p class="mce-root">As shown in the following code, the <kbd>Tree</kbd> class has the <kbd>insert</kbd> method, which inserts the element given <kbd>m</kbd> is the integer element:</p>
<pre class="mce-root">// Tree insert method for inserting at m position<br/>func (tree *Tree) insert( m int) {<br/> if tree != nil {<br/>if tree.LeftNode == nil {<br/>tree.LeftNode = &amp;Tree{nil,m,nil}<br/> } else {<br/> if tree.RightNode == nil {<br/> tree.RightNode = &amp;Tree{nil,m,nil}<br/> } else {<br/>if tree.LeftNode != nil {<br/>tree.LeftNode.insert(m)<br/>} else {<br/>tree.RightNode.insert(m)<br/>}<br/>}<br/>}<br/>} else {<br/>tree = &amp;Tree{nil,m,nil}<br/> }<br/>}<br/>//print method for printing a Tree<br/>func print(tree *Tree) {<br/> if tree != nil {<br/>fmt.Println(" Value",tree.Value)<br/> fmt.Printf("Tree Node Left")<br/> print(tree.LeftNode)<br/> fmt.Printf("Tree Node Right")<br/> print(tree.RightNode)<br/> } else {<br/> fmt.Printf("Nil\n")<br/> }<br/>}</pre>
<p class="mce-root">The <kbd>main</kbd> method calls the <kbd>insert</kbd> method on <kbd>tree</kbd> to insert the <kbd>1</kbd>, <kbd>3</kbd>, <kbd>5</kbd>, and <kbd>7</kbd> elements, as shown in the following code:</p>
<pre class="mce-root">// main method<br/>func main() {<br/> var tree *Tree = &amp;Tree{nil,1,nil}<br/> print(tree)<br/> tree.insert(3)<br/> print(tree)<br/> tree.insert(5)<br/> print(tree)<br/> tree.LeftNode.insert(7)<br/> print(tree)<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run tree.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/81072ad5-36a2-4ef5-800f-98ad6791101f.png" style="width:38.08em;height:25.92em;" width="766" height="520"/></p>
<p class="mce-root">Now that we know about the complexities in algorithms and analyzing their performance, let's take a look at brute force algorithms in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Brute force algorithms</h1>
                </header>
            
            <article>
                
<p class="mce-root">A brute force algorithm solves a problem based on the statement and the problem definition. Brute force algorithms for search and sort are sequential search and selection sort. Exhaustive search is another brute force algorithm where the solution is in a set of candidate solutions with definitive properties. The space in which the search happens is <span>a state and combinatorial space</span>, which consists of permutations, combinations, or subsets.</p>
<p class="mce-root">Brute Force algorithms are known for wide applicability and simplicity in solving complex problems. Searching, string matching, and matrix multiplication are some scenarios where they are used. Single computational tasks can be solved using brute force algorithms. They do not provide efficient algorithms. The algorithms are slow and non-performant. Representation of a brute force algorithm is shown in the following code:</p>
<pre class="mce-root">//main package has examples shown<br/>//<span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/>    "fmt"<br/>)<br/>//findElement method given array and k element<br/>func findElement(arr[10] int, k int) bool {<br/>    var i int<br/>    for i=0; i&lt; 10; i++ {<br/>        if arr[i]==k {<br/>            return true<br/>        }<br/>    }<br/>    return false<br/>}<br/>// main method<br/>func main() {<br/>    var arr = [10]int{1,4,7,8,3,9,2,4,1,8}<br/>    var check bool = findElement(arr,10)<br/>    fmt.Println(check)<br/>    var check2 bool = findElement(arr,9)<br/>    fmt.Println(check2)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run bruteforce.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6e3fa001-4bb9-4767-b091-d69ea8165f01.png" style="width:34.42em;height:6.67em;" width="956" height="185"/></p>
<p>After brute force algorithms, let's cover divide and conquer algorithms in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Divide and conquer algorithms</h1>
                </header>
            
            <article>
                
<p class="mce-root">A divide and conquer algorithm breaks a complex problem into smaller problems and solves these smaller problems. The smaller problem will be further broken down till it is a known problem. The approach is to recursively solve the sub-problems and merge the solutions of the sub-problems.</p>
<p class="mce-root">Recursion, quick sort, binary search, fast Fourier transform, and merge sort are good examples of divide and conquer algorithms. Memory is efficiently used with these algorithms. Performance is sometimes an issue in the case of recursion. On multiprocessor machines, these algorithms can be executed on different processors after breaking them down into sub-problems. A divide and conquer algorithm is shown in the following code:</p>
<pre class="mce-root">//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/>    "fmt"<br/>)</pre>
<p class="mce-root">As shown in the following code, the Fibonacci method takes the <em>k</em> integer parameter and returns the Fibonacci number for <em>k</em>. The method uses recursion to calculate the Fibonacci numbers. The recursion algorithm is applied by dividing the problem into the <kbd>k-1</kbd> integer and the <kbd>k-2</kbd> integer:</p>
<pre class="mce-root"><br/>// fibonacci method given k integer<br/>func fibonacci(k int) int {<br/>if k&lt;=1{<br/> return 1<br/> }<br/> return fibonacci(k-1)+fibonacci(k-2)<br/>}<br/>// main method<br/>func main() {<br/>var m int = 5<br/>for m=0; m &lt; 8; m++ {<br/>var fib = fibonacci(m)<br/>fmt.Println(fib)<br/> }<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run divide.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6b32da69-198a-488d-815a-5a6552b71bcd.png" style="width:33.33em;height:12.42em;" width="924" height="343"/></p>
<p>Let's take a look at what backtracking algorithms are in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Backtracking algorithms</h1>
                </header>
            
            <article>
                
<p class="mce-root">A backtracking algorithm solves a problem by constructing the solution incrementally. Multiple options are evaluated, and the algorithm chooses to go to the next component of the solution through recursion. Backtracking can be a chronological type or can traverse the paths, depending on the problem that you are solving.</p>
<p class="mce-root">Backtracking is an algorithm that finds candidate solutions and rejects a candidate on the basis of its feasibility and validity. Backtracking is useful in scenarios such as finding a value in an unordered table. It is faster than a brute force algorithm, which rejects a large number of solutions in an iteration. Constraint satisfaction problems such as parsing, rules engine, knapsack problems, and combinatorial optimization are solved using backtracking.</p>
<p class="mce-root">The following is an example of a backtracking algorithm. The problem is to identify the combinations of elements in an array of 10 elements whose sum is equal to <kbd>18</kbd>. The <kbd>findElementsWithSum</kbd> method recursively tries to find the combination. Whenever the sum goes beyond the <kbd>k</kbd> target, it backtracks:</p>
<pre class="mce-root">//main package has examples shown<br/>// <span>in Hands-On Data Structures and algorithms with Go book</span><br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/>)<br/>//findElementsWithSum of k from arr of size<br/>func findElementsWithSum(arr[10] int,combinations[19] int,size int, k int, addValue int, l int, m int) int {<br/>var num int = 0<br/>if addValue &gt; k {<br/> return -1<br/> }<br/>if addValue == k {<br/> num = num +1<br/> var p int =0<br/> for p=0; p &lt; m; p++ {<br/>  fmt.Printf("%d,",arr[combinations[p]])<br/>  }<br/> fmt.Println(" ")<br/> }<br/>var i int<br/>for i=l; i&lt; size; i++ {<br/>//fmt.Println(" m", m)<br/>combinations[m] = l<br/>findElementsWithSum(arr,combinations,size,k,addValue+arr[i],l,m+1)<br/>l = l+1<br/> }<br/> return num<br/>}<br/>// main method<br/>func main() {<br/>var arr = [10]int{1,4,7,8,3,9,2,4,1,8}<br/>var addedSum int = 18<br/>var combinations [19]int<br/>findElementsWithSum(arr,combinations,10,addedSum,0,0,0)<br/>//fmt.Println(check)//var check2 bool = findElement(arr,9)<br/>//fmt.Println(check2)<br/>}</pre>
<p class="mce-root"><span>Run the following commands:</span></p>
<pre class="mce-root"><strong>go run backtracking.go</strong></pre>
<p class="mce-root"><span>The following screenshot displays the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fa6ea6c3-f040-4d0d-ab1c-be7046319c42.png" style="width:33.83em;height:31.33em;" width="959" height="886"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter covered the definition of abstract datatypes, classifying data structures into linear, nonlinear, homogeneous, heterogeneous, and dynamic types. Abstract datatypes such as container, list, set, map, graph, stack, and queue were presented in this chapter. The chapter covered the performance analysis of data structures and structural design patterns.</p>
<p>We looked at the classification of data structures and structural design patterns. You can use algorithms such as brute force, divide and conquer, and backtracking by calculating the complexity and performance analysis. The choice of algorithm and the use of design patterns and data structures are the key takeaways. </p>
<p>In the next chapter, we will discuss data structures in Go. The following data structures will be covered:</p>
<ul>
<li class="p1"><span class="s1">Arrays</span></li>
<li class="p1"><span class="s1">Slices</span></li>
<li class="p1"><span class="s1">Two-dimensional slices </span></li>
<li class="p1"><span class="s1">Maps</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions and exercises</h1>
                </header>
            
            <article>
                
<ol>
<li>Give an example where you can use a composite pattern.</li>
<li>For an array of 10 elements with a random set of integers, identify the maximum and minimum. Calculate the complexity of the algorithm.</li>
<li>To manage the state of an object, which structural pattern is relevant?</li>
<li>A window is sub-classed to add a scroll bar to make it a scrollable window. Which pattern is applied in this scenario?</li>
<li>Find the complexity of a binary tree search algorithm.</li>
<li>Identify the submatrices of 2x2 in a 3x3 matrix. What is the complexity of the algorithm that you have used?</li>
<li>Explain with a scenario the difference between brute force and backtracking algorithms.</li>
</ol>
<p> </p>
<ol start="8">
<li>A rules engine uses backtracking to identify the rules affected by the change. Show an example where backtracking identifies the affected rules.</li>
<li>Draw a flow chart for the algorithm of the calculation of profit-loss given the cost price, selling price, and quantity.</li>
<li>Write the pseudo code for an algorithm that compares the strings and identifies the substring within a string.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>The following books are recommended if you want to find out more about Gang of Four design patterns, algorithms, and data structures:</p>
<ul>
<li><em>Design Patterns</em>, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides</li>
<li><em>Introduction to Algorithms – Thi<span>rd Edition</span></em>, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein</li>
<li><em>Data structures and Algorithms: An Easy Introduction</em>, by Rudolph Russell</li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>