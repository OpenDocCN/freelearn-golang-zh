["```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n// main method\nfunc main() {\n  fmt.Println(\"Hello World\")\n}\n```", "```go\ngo build\n./hello_world\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n\n// importing fmt and container list packages\nimport (\n   \"fmt\"\n   \"container/list\")\n\n// main method\nfunc main() {\n    var intList list.List\n    intList.PushBack(11)\n    intList.PushBack(23)\n    intList.PushBack(34)\n\n    for element := intList.Front(); element != nil; element=element.Next() {\n        fmt.Println(element.Value.(int))\n    }\n}\n```", "```go\ngo run list.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n\n)\n//gets the power series of integer a and returns tuple of square of a\n// and cube of a\nfunc powerSeries(a int) (int,int) {\n\n  return a*a, a*a*a\n\n}\n```", "```go\n// main method\nfunc main() {\n\n  var square int\n  var cube int\n  square, cube = powerSeries(3)\n\n  fmt.Println(\"Square \", square, \"Cube\", cube)\n\n}\n```", "```go\ngo run tuples.go\n```", "```go\nfunc powerSeries(a int) (square int, cube int) {\n\n  square = a*a\n\n  cube = square*a\n\n  return \n\n}\n```", "```go\nfunc powerSeries(a int) (int, int, error) {\n\n  square = a*a\n\n  cube = square*a\n\n  return square,cube,nil\n\n}\n```", "```go\n//main package has examples shown\n//in Hands-On Data Structures and algorithms with Go book\npackage main\n\n// importing fmt package and container/heap\nimport (\n  \"container/heap\"\n  \"fmt\"\n)\n// integerHeap a type\ntype IntegerHeap []int\n\n// IntegerHeap method - gets the length of integerHeap\nfunc (iheap IntegerHeap) Len() int { return len(iheap) }\n\n// IntegerHeap method - checks if element of i index is less than j index\nfunc (iheap IntegerHeap) Less(i, j int) bool { return iheap[i] < iheap[j] }\n// IntegerHeap method -swaps the element of i to j index\nfunc (iheap IntegerHeap) Swap(i, j int) { iheap[i], iheap[j] = iheap[j], iheap[i] }\n```", "```go\n\n//IntegerHeap method -pushes the item\nfunc (iheap *IntegerHeap) Push(heapintf interface{}) {\n\n *iheap = append(*iheap, heapintf.(int))\n}\n//IntegerHeap method -pops the item from the heap\nfunc (iheap *IntegerHeap) Pop() interface{} {\n var n int\n var x1 int\n var previous IntegerHeap = *iheap\n n = len(previous)\n x1 = previous[n-1]\n *iheap = previous[0 : n-1]\n return x1\n}\n\n// main method\nfunc main() {\n var intHeap *IntegerHeap = &IntegerHeap{1,4,5}\n\n heap.Init(intHeap)\n heap.Push(intHeap, 2)\n fmt.Printf(\"minimum: %d\\n\", (*intHeap)[0])\n for intHeap.Len() > 0 {\n fmt.Printf(\"%d \\n\", heap.Pop(intHeap))\n }\n}\n```", "```go\ngo run heap.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n)\n//IProcess interface\ntype IProcess interface {\n process()\n}\n//Adapter struct\ntype Adapter struct {\n adaptee Adaptee\n}\n```", "```go\n//Adapter class method process\nfunc (adapter Adapter) process() {\n fmt.Println(\"Adapter process\")\n adapter.adaptee.convert()\n}\n//Adaptee Struct\ntype Adaptee struct {\n adapterType int\n}\n// Adaptee class method convert\nfunc (adaptee Adaptee) convert() {\n fmt.Println(\"Adaptee convert method\")\n}\n// main method\nfunc main() {\nvar processor IProcess = Adapter{}\nprocessor.process()\n}\n```", "```go\ngo run adapter.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n)\n//IDrawShape interface\ntype IDrawShape interface {\n drawShape(x[5] float32,y[5] float32)\n}\n//DrawShape struct\ntype DrawShape struct{}\n```", "```go\n// DrawShape struct has method draw Shape with float x and y coordinates\nfunc (drawShape DrawShape) drawShape(x[5] float32, y[5] float32) {\n fmt.Println(\"Drawing Shape\")\n}\n//IContour interace\ntype IContour interface {\n drawContour(x[5] float32 ,y[5] float32)\n resizeByFactor(factor int)\n}\n//DrawContour struct\ntype DrawContour struct {\n x[5] float32\n y[5] float32\n shape DrawShape\n factor int\n}\n```", "```go\n//DrawContour method drawContour given the coordinates\nfunc (contour DrawContour) drawContour(x[5] float32,y[5] float32) {\n fmt.Println(\"Drawing Contour\")\n contour.shape.drawShape(contour.x,contour.y)\n}\n//DrawContour method resizeByFactor given factor\nfunc (contour DrawContour) resizeByFactor(factor int) {\n contour.factor = factor\n}\n// main method\nfunc main() {\nvar x = [5]float32{1,2,3,4,5}\nvar y = [5]float32{1,2,3,4,5}\nvar contour IContour = DrawContour{x,y,DrawShape{},2}\ncontour.drawContour(x,y)\n contour.resizeByFactor(2)\n}\n```", "```go\ngo run bridge.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n)\n// IComposite interface\ntype IComposite interface {\n perform()\n}\n// Leaflet struct\ntype Leaflet struct {\n name string\n}\n// Leaflet class method perform\nfunc (leaf *Leaflet) perform() {\nfmt.Println(\"Leaflet \" + leaf.name)\n}\n// Branch struct\ntype Branch struct {\n leafs []Leaflet\n name string\n branches[]Branch\n}\n```", "```go\n// Branch class method perform\nfunc (branch *Branch) perform() {\nfmt.Println(\"Branch: \" + branch.name)\n for _, leaf := range branch.leafs {\n leaf.perform()\n }\nfor _, branch := range branch.branches {\n branch.perform()\n }\n}\n// Branch class method add leaflet\nfunc (branch *Branch) add(leaf Leaflet) {\n branch.leafs = append(branch.leafs, leaf)\n}\n```", "```go\n//Branch class method addBranch branch\nfunc (branch *Branch) addBranch(newBranch Branch) {\nbranch.branches = append(branch.branches,newBranch)\n}\n//Branch class method getLeaflets\nfunc (branch *Branch) getLeaflets() []Leaflet {\n return branch.leafs\n}\n// main method\nfunc main() {\nvar branch = &Branch{name:\"branch 1\"}\nvar leaf1 = Leaflet{name:\"leaf 1\"}\nvar leaf2 = Leaflet{name:\"leaf 2\"}\nvar branch2 = Branch{name:\"branch 2\"}\nbranch.add(leaf1)\nbranch.add(leaf2)\nbranch.addBranch(branch2)\nbranch.perform()\n}\n```", "```go\ngo run composite.go\n```", "```go\n//main package has examples shown\n // in Hands-On Data Structures and algorithms with Go book\n package main\n// importing fmt package\n import (\n \"fmt\"\n )\n// IProcess Interface\n type IProcess interface {\n process()\n }\n//ProcessClass struct\n type ProcessClass struct{}\n//ProcessClass method process\n func (process *ProcessClass) process() {\n fmt.Println(\"ProcessClass process\")\n }\n//ProcessDecorator struct\n type ProcessDecorator struct {\n processInstance *ProcessClass\n }\n```", "```go\n\n //ProcessDecorator class method process\n func (decorator *ProcessDecorator) process() {\n if decorator.processInstance == nil {\n fmt.Println(\"ProcessDecorator process\")\n } else {\n fmt.Printf(\"ProcessDecorator process and \")\n decorator.processInstance.process()\n}\n }\n//main method\n func main() {\nvar process = &ProcessClass{}\nvar decorator = &ProcessDecorator{}\ndecorator.process()\ndecorator.processInstance = process\ndecorator.process()\n}\n```", "```go\ngo run decorator.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n )\n //Account struct\n type Account struct{\nid string\naccountType string\n}\n//Account class method create - creates account given AccountType\nfunc (account *Account) create(accountType string) *Account{\n fmt.Println(\"account creation with type\")\n account.accountType = accountType\nreturn account\n}\n//Account class method getById given id string\nfunc (account *Account) getById(id string) *Account {\n fmt.Println(\"getting account by Id\")\n return account\n }\n```", "```go\n //Account class method deleteById given id string\n func (account *Account) deleteById(id string)() {\n fmt.Println(\"delete account by id\")\n }\n//Customer struct\n type Customer struct{\n name string\n id int\n }\n```", "```go\n//Customer class method create - create Customer given name\n func (customer *Customer) create(name string) *Customer {\n fmt.Println(\"creating customer\")\n customer.name = name\n return customer\n }\n//Transaction struct\n type Transaction struct{\n id string\n amount float32\n srcAccountId string\n destAccountId string\n }\n```", "```go\n//Transaction class method create Transaction\n func (transaction *Transaction) create(srcAccountId string, destAccountId string,amount float32) *Transaction {\n fmt.Println(\"creating transaction\")\n transaction.srcAccountId = srcAccountId\n transaction.destAccountId = destAccountId\n transaction.amount = amount\n return transaction\n }\n //BranchManagerFacade struct\n type BranchManagerFacade struct {\n account *Account\n customer *Customer\n transaction *Transaction\n }\n//method NewBranchManagerFacade\n func NewBranchManagerFacade() *BranchManagerFacade {\n return &BranchManagerFacade{ &Account{}, &Customer{}, &Transaction{}}\n }\n```", "```go\n//BranchManagerFacade class method createCustomerAccount\n func (facade *BranchManagerFacade) createCustomerAccount(customerName string, accountType string) (*Customer,*Account) {\n var customer = facade.customer.create(customerName)\n var account = facade.account.create(accountType)\n return customer, account\n }\n //BranchManagerFacade class method createTransaction\n func (facade *BranchManagerFacade) createTransaction(srcAccountId string, destAccountId string, amount float32) *Transaction {\nvar transaction = facade.transaction.create(srcAccountId,destAccountId,amount)\n return transaction\n}\n```", "```go\n//main method\nfunc main() {\n    var facade = NewBranchManagerFacade()\n    var customer *Customer\n    var account *Account\n    customer, account = facade.createCustomerAccount(\"Thomas Smith\", \n    \"Savings\")\n    fmt.Println(customer.name)\n    fmt.Println(account.accountType)\n    var transaction = facade.createTransaction(\"21456\",\"87345\",1000)\n    fmt.Println(transaction.amount)\n}\n```", "```go\ngo run facade.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\n package main\n// importing fmt package\n import (\n \"fmt\"\n )\n //DataTransferObjectFactory struct\n type DataTransferObjectFactory struct {\n pool map[string] DataTransferObject\n }\n//DataTransferObjectFactory class method getDataTransferObject\n func (factory DataTransferObjectFactory) getDataTransferObject(dtoType string) DataTransferObject {\nvar dto = factory.pool[dtoType]\nif dto == nil {\nfmt.Println(\"new DTO of dtoType: \" + dtoType)\n switch dtoType{\n case \"customer\":\n factory.pool[dtoType] = Customer{id:\"1\"}\n case \"employee\":\n factory.pool[dtoType] = Employee{id:\"2\"}\n case \"manager\":\n factory.pool[dtoType] = Manager{id:\"3\"}\n case \"address\":\n factory.pool[dtoType] = Address{id:\"4\"}\n }\ndto = factory.pool[dtoType]\n}\n\n return dto\n }\n```", "```go\n// DataTransferObject interface\n type DataTransferObject interface {\n getId() string\n }\n //Customer struct\n type Customer struct {\n id string //sequence generator\n name string\n ssn string\n }\n // Customer class method getId\n func (customer Customer) getId() string {\n //fmt.Println(\"getting customer Id\")\n return customer.id\n}\n //Employee struct\n type Employee struct {\n id string\n name string\n }\n //Employee class method getId\n func (employee Employee) getId() string {\n return employee.id\n }\n //Manager struct\n type Manager struct {\n id string\n name string\n dept string\n }\n```", "```go\n//Manager class method getId\n func (manager Manager) getId() string {\n return manager.id\n }\n //Address struct\n type Address struct {\n id string\n streetLine1 string\n streetLine2 string\n state string\n city string\n}\n//Address class method getId\n func (address Address) getId() string{\n return address.id\n }\n //main method\n func main() {\n var factory = DataTransferObjectFactory{make(map[string]DataTransferObject)}\n var customer DataTransferObject = factory.getDataTransferObject(\"customer\")\n fmt.Println(\"Customer \",customer.getId())\n var employee DataTransferObject = factory.getDataTransferObject(\"employee\")\n fmt.Println(\"Employee \",employee.getId())\n var manager DataTransferObject = factory.getDataTransferObject(\"manager\")\n fmt.Println(\"Manager\",manager.getId())\n var address DataTransferObject = factory.getDataTransferObject(\"address\")\n fmt.Println(\"Address\",address.getId())\n }\n```", "```go\ngo run flyweight.go\n```", "```go\n//main package has examples shown\n // in Hands-On Data Structures and algorithms with Go book\n package main\n// importing fmt and encoding/json packages\nimport (\n \"encoding/json\"\n \"fmt\"\n )\n //AccountDetails struct\n type AccountDetails struct {\n id string\n accountType string\n }\n //Account struct\n type Account struct {\n details *AccountDetails\n CustomerName string\n }\n // Account class method setDetails\n func (account *Account) setDetails(id string, accountType string) {\naccount.details = &AccountDetails{id, accountType}\n}\n```", "```go\n//Account class method getId\n func (account *Account) getId() string{\nreturn account.details.id\n }\n //Account class method getAccountType\n func (account *Account) getAccountType() string{\nreturn account.details.accountType\n }\n```", "```go\n// main method\n func main() {\nvar account *Account = &Account{CustomerName: \"John Smith\"}\n account.setDetails(\"4532\",\"current\")\njsonAccount, _ := json.Marshal(account)\n fmt.Println(\"Private Class hidden\",string(jsonAccount))\nfmt.Println(\"Account Id\",account.getId())\nfmt.Println(\"Account Type\",account.getAccountType())\n}\n```", "```go\ngo run privateclass.go\n```", "```go\n\n //main package has examples shown\n // in Hands-On Data Structures and algorithms with Go book\n package main\n// importing fmt package\n import (\n \"fmt\"\n )\n //IRealObject interface\n type IRealObject interface {\n performAction()\n }\n //RealObject struct\n type RealObject struct{}\nRealObject class implements IRealObject interface. The class has method performAction.\n //RealObject class method performAction\n func (realObject *RealObject) performAction() {\n fmt.Println(\"RealObject performAction()\")\n }\n //VirtualProxy struct\n type VirtualProxy struct {\n realObject *RealObject\n }\n //VirtualProxy class method performAction\n func (virtualProxy *VirtualProxy) performAction() {\n if virtualProxy.realObject == nil {\n virtualProxy.realObject = &RealObject{}\n }\n fmt.Println(\"Virtual Proxy performAction()\")\n virtualProxy.realObject.performAction()\n }\n // main method\n func main() {\n var object VirtualProxy = VirtualProxy{}\n object.performAction()\n }\n```", "```go\ngo run virtualproxy.go\n```", "```go\nmaximum(arr) {\n    n <- len(arr)\n    max <- arr[0]\n    for k <- 0,n do  {\n        If  arr[k] > max {\n            max <- arr[k]\n        }\n    }\n    return max\n}\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n)\n// main method\nfunc main() {\n var m [10]int\n var k int\nfor k = 0; k < 10; k++ {\n m[k] = k + 200\nfmt.Printf(\"Element[%d] = %d\\n\", k, m[k] )\n }\n}\n```", "```go\ngo run complexity.go\n```", "```go\n\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n)\n// main method\nfunc main() {\n var m [10]int\n var k int\nfor k = 0; k < 10; k++ {\n m[k] = k * 200\nfmt.Printf(\"Element[%d] = %d\\n\", k, m[k] )\n }\n}\n```", "```go\ngo run linear_complexity.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n// importing fmt package\nimport (\n    \"fmt\"\n)\n// main method\nfunc main() {\n    var k,l int\n    for k = 1; k <= 10; k++ {\n        fmt.Println(\" Multiplication Table\", k)\n        for l=1; l <= 10; l++ {\n            var x int = l *k\n            fmt.Println(x)\n        }\n    }\n}\n```", "```go\ngo run quadratic_complexity.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n)\n// main method\nfunc main() {\nvar k,l,m int\nvar arr[10][10][10] int\n for k = 0; k < 10; k++ {\nfor l=0; l < 10; l++ {\nfor m=0; m < 10; m++ {\narr[k][l][m] = 1\nfmt.Println(\"Element value \",k,l,m,\" is\", arr[k][l][m])\n}\n}\n}\n}\n```", "```go\ngo run cubic_complexity.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n    \"fmt\"\n)\n// Tree struct\ntype Tree struct {\n    LeftNode *Tree\n    Value int\n    RightNode *Tree\n}\n```", "```go\n// Tree insert method for inserting at m position\nfunc (tree *Tree) insert( m int) {\n if tree != nil {\nif tree.LeftNode == nil {\ntree.LeftNode = &Tree{nil,m,nil}\n } else {\n if tree.RightNode == nil {\n tree.RightNode = &Tree{nil,m,nil}\n } else {\nif tree.LeftNode != nil {\ntree.LeftNode.insert(m)\n} else {\ntree.RightNode.insert(m)\n}\n}\n}\n} else {\ntree = &Tree{nil,m,nil}\n }\n}\n//print method for printing a Tree\nfunc print(tree *Tree) {\n if tree != nil {\nfmt.Println(\" Value\",tree.Value)\n fmt.Printf(\"Tree Node Left\")\n print(tree.LeftNode)\n fmt.Printf(\"Tree Node Right\")\n print(tree.RightNode)\n } else {\n fmt.Printf(\"Nil\\n\")\n }\n}\n```", "```go\n// main method\nfunc main() {\n var tree *Tree = &Tree{nil,1,nil}\n print(tree)\n tree.insert(3)\n print(tree)\n tree.insert(5)\n print(tree)\n tree.LeftNode.insert(7)\n print(tree)\n}\n```", "```go\ngo run tree.go\n```", "```go\n//main package has examples shown\n//in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n    \"fmt\"\n)\n//findElement method given array and k element\nfunc findElement(arr[10] int, k int) bool {\n    var i int\n    for i=0; i< 10; i++ {\n        if arr[i]==k {\n            return true\n        }\n    }\n    return false\n}\n// main method\nfunc main() {\n    var arr = [10]int{1,4,7,8,3,9,2,4,1,8}\n    var check bool = findElement(arr,10)\n    fmt.Println(check)\n    var check2 bool = findElement(arr,9)\n    fmt.Println(check2)\n}\n```", "```go\ngo run bruteforce.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n    \"fmt\"\n)\n```", "```go\n\n// fibonacci method given k integer\nfunc fibonacci(k int) int {\nif k<=1{\n return 1\n }\n return fibonacci(k-1)+fibonacci(k-2)\n}\n// main method\nfunc main() {\nvar m int = 5\nfor m=0; m < 8; m++ {\nvar fib = fibonacci(m)\nfmt.Println(fib)\n }\n}\n```", "```go\ngo run divide.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n)\n//findElementsWithSum of k from arr of size\nfunc findElementsWithSum(arr[10] int,combinations[19] int,size int, k int, addValue int, l int, m int) int {\nvar num int = 0\nif addValue > k {\n return -1\n }\nif addValue == k {\n num = num +1\n var p int =0\n for p=0; p < m; p++ {\n  fmt.Printf(\"%d,\",arr[combinations[p]])\n  }\n fmt.Println(\" \")\n }\nvar i int\nfor i=l; i< size; i++ {\n//fmt.Println(\" m\", m)\ncombinations[m] = l\nfindElementsWithSum(arr,combinations,size,k,addValue+arr[i],l,m+1)\nl = l+1\n }\n return num\n}\n// main method\nfunc main() {\nvar arr = [10]int{1,4,7,8,3,9,2,4,1,8}\nvar addedSum int = 18\nvar combinations [19]int\nfindElementsWithSum(arr,combinations,10,addedSum,0,0,0)\n//fmt.Println(check)//var check2 bool = findElement(arr,9)\n//fmt.Println(check2)\n}\n```", "```go\ngo run backtracking.go\n```"]