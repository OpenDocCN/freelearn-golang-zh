- en: Data Structures and Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A data structure is the organization of data to reduce the storage space used
    and to reduce the difficulty while performing different tasks. Data structures
    are used to handle and work with large amounts of data in various fields, such
    as database management and internet indexing services.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the definition of abstract datatypes, classifying
    data structures into linear, nonlinear, homogeneous, heterogeneous, and dynamic
    types. Abstract datatypes, such as Container, List, Set, Map, Graph, Stack, and
    Queue, are presented in this chapter.  We will also cover the performance analysis
    of data structures, choosing the right data structures, and structural design
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The reader can start writing basic algorithms using the right data structures
    in Go. Given a problem, choosing the data structure and different algorithms will
    be the first step. After this, doing performance analysis is the next step. Time
    and space analysis for different algorithms helps compare them and helps you choose
    the optimal one. It is essential to have basic knowledge of Go to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Classification of data structures and structural design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representation of algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity and performance analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute force algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Divide and conquer algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backtracking algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install Go version 1.10 from [https://golang.org/doc/install](https://golang.org/doc/install) for
    your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at the following GitHub URL: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter01](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter01)[.](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Go/tree/master/ch1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the installation of Go by running the hello world program at [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/hello_world](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/hello_world):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8057be5f-396d-4d1f-9aa4-cd3f6eee3310.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the classification of data structures and structural design
    patterns in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Classification of data structures and structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can choose a data structure by using classification. In this section, we
    discuss data structure classification in detail. The design patterns related to
    the data structure are covered after the classification.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll take a look at classification of data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Classification of data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **data structure** refers to the organization of data in a computer's
    memory, in order to retrieve it quickly for processing. It is a scheme for data
    organization to decouple the functional definition of a data structure from its
    implementation. A data structure is chosen based on the problem type and the operations
    performed on the data.
  prefs: []
  type: TYPE_NORMAL
- en: If the situation requires various datatypes within a data structure, we can
    choose heterogeneous data structures. Linked, ordered, and unordered lists are
    grouped as heterogeneous data structures. Linear data structures are lists, sets,
    tuples, queues, stacks, and heaps. Trees, tables, and containers are categorized
    as nonlinear data structures. Two-dimensional and multidimensional arrays are
    grouped as homogeneous data structures. Dynamic data structures are dictionaries,
    tree sets, and sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classification of **Data Structures** is show in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2325558-71a8-47e6-bb1b-fef9586dd8cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at lists, tuples and heaps in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A list is a sequence of elements. Each element can be connected to another with
    a link in a forward or backward direction. The element can have other payload
    properties. This data structure is a basic type of container. Lists have a variable
    length and developer can remove or add elements more easily than an array. Data
    items within a list need not be contiguous in memory or on disk. Linked lists
    were proposed by Allen Newell, Cliff Shaw, and Herbert A. Simon at RAND Corporation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, a list can be used in Go, as shown in the following example;
    elements are added through the `PushBack` method on the list, which is in the `container/list`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The list is iterated through the `for` loop, and the element's value is accessed
    through the `Value` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6679223-be43-4d23-a5bd-60ab04d1a8b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at Tuples in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tuple is a finite sorted list of elements. It is a data structure that groups
    data.  Tuples are typically immutable sequential collections. The element has
    related fields of different datatypes. The only way to modify a tuple is to change
    the fields. Operators such as + and * can be applied to tuples. A database record
    is referred to as a tuple. In the following example, power series of integers
    are calculated and the square and cube of the integer is returned as a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method calls the `powerSeries` method with `3` as a parameter. The
    `square` and `cube` values are returned from the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/378425c0-4233-4fc6-b008-e6de29c70d6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The tuples can be named in the `powerSeries` function, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is an error, it can be passed with tuples, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heap is a data structure that is based on the `heap` property. The heap data
    structure is used in selection, graph, and k-way merge algorithms. Operations
    such as finding, merging, insertion, key changes, and deleting are performed on
    heaps. Heaps are part of the `container/heap` package in Go. According to the
    heap order (maximum heap) property, the value stored at each node is greater than
    or equal to its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the order is descending, it is referred to as a maximum heap; otherwise,
    it''s a minimum heap. The heap data structure was proposed by J.W.J. Williams
    in 1964 for a heap sorting algorithm. It is not a sorted data structure, but partially
    ordered. The following example shows how to use the `container/heap` package to
    create a heap data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`IntegerHeap` has a `Push` method that pushes the item with the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1da0d4df-5edd-44a8-8a19-a991e77d7b5a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at structural design patterns in the next section
  prefs: []
  type: TYPE_NORMAL
- en: Structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural design patterns describe the relationships between the entities.
    They are used to form large structures using classes and objects. These patterns
    are used to create a system with different system blocks in a flexible manner. Adapter,
    bridge, composite, decorator, facade, flyweight, private class data, and proxy
    are the **Gang of Four** (**GoF**) structural design patterns. The private class
    data design pattern is the other design pattern covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at adapter and bridge design patterns in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adapter pattern provides a wrapper with an interface required by the API
    client to link incompatible types and act as a translator between the two types.
    The adapter uses the interface of a class to be a class with another compatible
    interface. When requirements change, there are scenarios where class functionality
    needs to be changed because of incompatible interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle can be adhered to by using the adapter pattern,
    when a class defines its own interface to the next level module interface implemented
    by an `adapter` class. Delegation is the other principle used by the adapter pattern.
    Multiple formats handling source-to-destination transformations are the scenarios
    where the adapter pattern is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adapter pattern comprises the target, adaptee, adapter, and client:'
  prefs: []
  type: TYPE_NORMAL
- en: Target is the interface that the client calls and invokes methods on the adapter
    and adaptee.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client wants the incompatible interface implemented by the adapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The adapter translates the incompatible interface of the adaptee into an interface
    that the client wants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say you have an `IProcessor` interface with a `process` method, the `Adapter` class
    implements the `process` method and has an `Adaptee` instance as an attribute.
    The `Adaptee` class has a `convert` method and an `adapterType` instance variable.
    The developer while using the API client calls the `process` interface method to
    invoke `convert` on `Adaptee`. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Adapter` class has a `process` method that invokes the `convert` method
    on `adaptee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/223e23d0-ea9a-4a27-af29-aa37f8a8c311.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at Bridge pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bridge decouples the implementation from the abstraction. The abstract base
    class can be subclassed to provide different implementations and allow implementation
    details to be modified easily. The interface, which is a bridge, helps in making
    the functionality of concrete classes independent from the interface implementer
    classes. The bridge patterns allow the implementation details to change at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge pattern demonstrates the principle, preferring composition over inheritance.
    It helps in situations where one should subclass multiple times orthogonal to
    each other. Runtime binding of the application, mapping of orthogonal class hierarchies,
    and platform independence implementation are the scenarios where the bridge pattern
    can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge pattern components are abstraction, refined abstraction, implementer,
    and concrete implementer. Abstraction is the interface implemented as an abstract
    class that clients invoke with the method on the concrete implementer. Abstraction
    maintains a *has-a* relationship with the implementation, instead of an *is-a* relationship.
    The *has-a* relationship is maintained by composition. Abstraction has a reference
    of the implementation. Refined abstraction provides more variations than abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say `IDrawShape` is an interface with the `drawShape` method.  `DrawShape`
    implements the `IDrawShape` interface. We create an `IContour` bridge interface with
    the `drawContour` method. The contour class implements the `IContour` interface.
    The `ellipse` class will have *a*, *b* , *r* properties and `drawShape` (an instance
    of `DrawShape`). The `ellipse` class implements the `contour` bridge interface
    to implement the `drawContour` method. The  `drawContour` method calls the `drawShape` method
    on the `drawShape` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the bridge implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: drawShape method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `drawShape` method draws the shape given the coordinates, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: drawContour method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `drawContour` method of the `DrawContour` class calls the `drawShape` method
    on the `shape` instance, this is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0562db0-8f61-409a-b8b9-a50c0d2ca323.png)'
  prefs: []
  type: TYPE_IMG
- en: We will take a look at Composite, Decorator, Facade and Flyweight design patterns
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A composite is a group of similar objects in a single object. Objects are stored
    in a tree form to persist the whole hierarchy. The composite pattern is used to
    change a hierarchical collection of objects. The composite pattern is modeled
    on a heterogeneous collection. New types of objects can be added without changing
    the interface and the client code. You can use the composite pattern, for example,
    for UI layouts on the web, for directory trees, and for managing employees across
    departments. The pattern provides a mechanism to access the individual objects
    and groups in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The composite pattern comprises the `component` interface, `component` class,
    composite, and client:'
  prefs: []
  type: TYPE_NORMAL
- en: The `component` interface defines the default behavior of all objects and behaviors
    for accessing the components of the composite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `composite` and `component` classes implement the `component` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client interacts with the component interface to invoke methods in the composite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say there is an `IComposite` interface with the `perform` method and
    `BranchClass` that implements `IComposite`  and has the `addLeaf`, `addBranch`,
    and `perform` methods. The `Leaflet` class implements `IComposite` with the `perform`
    method. `BranchClass` has a one-to-many relationship with `leafs` and `branches`.
    Iterating over the branch recursively, one can traverse the composite tree, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `perform` method of the `Branch` class calls the `perform` method on `branch`
    and `leafs`, as seen in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following code, the `addBranch` method of the `Branch` class adds
    a new `branch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a67a4b3-ef1f-4476-af3f-1007ce8049fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at Decorator pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a scenario where class responsibilities are removed or added, the decorator
    pattern is applied. The decorator pattern helps with subclassing when modifying
    functionality, instead of static inheritance. An object can have multiple decorators
    and run-time decorators. The single responsibility principle can be achieved using
    a decorator. The decorator can be applied to window components and graphical object
    modeling. The decorator pattern helps with modifying existing instance attributes
    and adding new methods at run-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decorator pattern participants are the component interface, the concrete
    component class, and the `decorator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The concrete component implements the component interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `decorator` class implements the component interface and provides additional
    functionality in the same method or additional methods. The decorator base can
    be a participant representing the base class for all decorators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let ''s say `IProcess` is an interface with the `process` method. `ProcessClass`
    implements an interface with the `process` method. `ProcessDecorator` implements
    the process interface and has an instance of `ProcessClass`. `ProcessDecorator`
    can add more functionality than `ProcessClass`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, the `ProcessDecorator` class `process` method invokes
    the `process` method on the decorator instance of `ProcessClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35c5bee2-bd71-40f0-b536-c8ff3651b2be.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at Facade pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facade is used to abstract subsystem interfaces with a helper. The facade design
    pattern is used in scenarios when the number of interfaces increases and the system
    gets complicated. Facade is an entry point to different subsystems, and it simplifies
    the dependencies between the systems. The facade pattern provides an interface
    that hides the implementation details of the hidden code.
  prefs: []
  type: TYPE_NORMAL
- en: A loosely coupled principle can be realized with a facade pattern. You can use
    a facade to improve poorly designed APIs. In SOA, a service facade can be used
    to incorporate changes to the contract and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The facade pattern is made up of the `facade` class, module classes, and a
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: The facade delegates the requests from the client to the module classes. The
    `facade` class hides the complexities of the subsystem logic and rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module classes implement the behaviors and functionalities of the module subsystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client invokes the `facade` method. The `facade` class functionality can
    be spread across multiple packages and assemblies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, account, customer, and transaction are the classes that have account,
    customer, and transaction creation methods. `BranchManagerFacade` can be used
    by the client to create an account, customer, and transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `account` class has the `deleteById` method, which is used to delete an
    account with a given ID, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, the `customer` class has a method that creates a new
    customer with `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following code, the `transaction` class has the `create` method
    for creating a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`BranchManagerFacade` has the `createCustomerAccount` method, which calls the `create`
    method on the `customer` class instance, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method calls the `NewBranchManagerFacade` method to create a facade.
    The methods on `facade` are invoked to create `customer` and `account`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfc322d5-0edc-436f-bb73-cfa293d08583.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at Flyweight pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flyweight is used to manage the state of an object with high variation. The
    pattern allows us to share common parts of the object state among multiple objects,
    instead of each object storing it. Variable object data is referred to as extrinsic
    state, and the rest of the object state is intrinsic. Extrinsic data is passed
    to flyweight methods and will never be stored within it. Flyweight pattern helps
    reduce the overall memory usage and the object initializing overhead. The pattern
    helps create interclass relationships and lower memory to a manageable level.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight objects are immutable. Value objects are a good example of the flyweight
    pattern. Flyweight objects can be created in a single thread mode, ensuring one
    instance per value. In a concurrent thread scenario, multiple instances are created.
    This is based on the equality criterion of flyweight objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The participants of the flyweight pattern are the `FlyWeight` interface, `ConcreteFlyWeight`,
    `FlyWeightFactory`, and the `Client` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FlyWeight` interface has a method through which flyweights can get and
    act on the extrinsic state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteFlyWeight` implements the `FlyWeight` interface to represent flyweight
    objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlyweightFactory` is used to create and manage flyweight objects. The client
    invokes `FlyweightFactory` to get a flyweight object. `UnsharedFlyWeight` can
    have a functionality that is not shared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client` classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say `DataTransferObject` is an interface with the `getId` method. `DataTransferObjectFactory`
    creates a data transfer object through `getDataTransferObject` by the `DTO` type.
    The `DTO` types are customer, employee, manager, and address, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, the `DataTransferObject` interface is implemented by
    the `Customer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DataTransferObject` interface is implemented by the `Manager` class, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/839f35da-05ca-48fc-aa64-769274250a37.png)'
  prefs: []
  type: TYPE_IMG
- en: We will take a look at Private class and Proxy data patterns in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Private class data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The private class data pattern secures the data within a class. This pattern
    encapsulates the initialization of the class data. The write privileges of properties
    within the private class are protected, and properties are set during construction.
    The private class pattern prints the exposure of information by securing it in
    a class that retains the state. The encapsulation of class data initialization
    is a scenario where this pattern is applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '`Account` is a class with account details and a customer name. `AccountDetails`
    is the private attribute of `Account` , and `CustomerName` is the public attribute.
    JSON marshaling of `Account` has `CustomerName` as a public property. `AccountDetails`
    is the package property in Go (modeled as private class data):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following code, the `Account` class has the `getId` method,
    which returns the `id` private class attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method calls the `Account` initializer with `CustomerName`. The
    details of the account are set details with the `setDetails` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50c0055c-a7f4-4d86-bf64-d30690516cf0.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at Proxy pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proxy pattern forwards to a real object and acts as an interface to others.
    The proxy pattern controls access to an object and provides additional functionality.
    The additional functionality can be related to authentication, authorization,
    and providing rights of access to the resource-sensitive object. The real object
    need not be modified while providing additional logic. Remote, smart, virtual,
    and protection proxies are the scenarios where this pattern is applied. It is
    also used to provide an alternative to extend functionality with inheritance and
    object composition. A proxy object is also referred to as a surrogate, handle,
    or wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proxy pattern comprises the subject interface, the `RealSubject` class,
    and the `Proxy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Subject is an interface for the `RealObject` and `Proxy` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RealSubject` object is created and maintained as a reference in the `Proxy`
    class. `RealSubject` is resource sensitive, required to be protected, and expensive
    to create.  `RealObject` is a class that implements the `IRealObject` interface.
    It has a `performAction` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualProxy` is used to access `RealObject` and invoke the `performAction`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows an implementation of proxy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/938fb87b-a174-4cda-82a1-a5bda4e6ebed.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know the classification of data structures and the design patterns
    used, let's go ahead and take a look at the representation of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Representation of algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A flow chart and pseudo code are methods of representing algorithms. An algorithm
    shows the logic of how a problem is solved. A flow chart has different representation
    symbols such as Entry, Exit, Task, Input/Output, Decision Point, and Inter Block.
    A structured program consists of a series of these symbols to perform a specific
    task. Pseudo code has documentation, action, and flow control keywords to visualize
    an algorithm. The documentation keywords are **TASK** and **REM**. **SET**, **PUT**,
    and **GET** are the action keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the different representations of algorithms, that is, flow
    charts and Pseudo code in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Flow chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The flow control keywords are **SET**, **LOOP**, (**WHILE**, **UNTIL**), **REP,**
    and **POST**. The following flow chart shows a formula or an algorithm to calculate
    the dividend given a number of shares, the face value, and the dividend percentage.
    The start and end are the Entry and Exit symbols. The input number of shares,
    share face value, and dividend percentage use the Input symbol. The compute dividend
    and output dividend use the Task symbol and Output symbol respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54bfe074-8b26-4af2-8e65-4285564adc78.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we'll take a look at pseudo code, representation of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pseudo code is a high-level design of a program or algorithm. Sequence and selection
    are two constructs used in pseudo code. Pseudo code is easier than a flow chart
    visualizes the algorithm while pseudo code can be easily modified and updated.
    Errors in design can be caught very early in pseudo code. This saves the cost
    of fixing defects later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an example, we want to find the `max` value in an array of length *n*.
    The pseudo code will be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know the different ways to represent the algorithm, let's take a
    look at how we can monitor its complexity and performance in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity and performance analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The efficiency of an algorithm is measured through various parameters, such
    as CPU time, memory, disk, and network. The complexity is how the algorithm scales
    when the number of input parameters increases. Performance is a measure of time,
    space, memory, and other parameters. Algorithms are compared by their processing
    time and resource consumption. Complexity measures the parameters and is represented
    by the Big O notation.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity analysis of algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complexity of an algorithm is measured by the speed of the algorithm. Typically,
    the algorithm will perform differently based on processor speed, disk speed, memory,
    and other hardware parameters. Hence, asymptotical complexity is used to measure
    the complexity of an algorithm. An algorithm is a set of steps to be processed
    by different operations to achieve a task. The time taken for an algorithm to
    complete is based on the number of steps taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say an algorithm iterates through an array, `m`, of size `10` and update
    the elements to the sum of index and `200`. The computational time will be 10**t,*
    where *t* is the time taken to add two integers and update them to an array. The
    next step will be printing them after iterating over an array. The *t*  time parameter
    will vary with the hardware of the computer used. Asymptotically, the computational
    time grows as a factor of `10`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d88a6f8-cc2b-40cb-8f26-1fec5139aed8.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the different complexity types in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Big O notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *T*(*n*) time function represents the algorithm complexity based on Big
    O notation. *T*(*n*) = *O*(*n*) states that an algorithm has a linear time complexity.
    Using Big O notation, the constant time, linear time, logarithmic time, cubic
    time, and quadratic time complexity are different complexity types for an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Linear time, *O*(*n*), is used as a measure of complexity in scenarios such
    as linear search, traversing, and finding the minimum and maximum number of array
    elements. ArrayList and queue are data structures that have these methods. An
    algorithm that has logarithmic time, *O*(*log n*), is a binary search in a tree
    data structure. Bubble sort, selection sort, and insertion sort algorithms have
    complexity of quadratic time, *O*(*n*²). Big Omega Ω and big Theta Θ are notations
    for the lower and upper bounds for a particular algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The worst case, best case, average case, and amortized run-time complexity is
    used for analysis of algorithms. Amortized run-time complexity is referred to
    as 2*^n*. Asymptotically, it will tend to *O*(1).
  prefs: []
  type: TYPE_NORMAL
- en: Big O notation is also used to determine how much space is consumed by the algorithm.
    This helps us find the best and worst case scenarios, relative to space and time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at linear complexity in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Linear complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An algorithm is of linear complexity if the processing time or storage space
    is directly proportional to the number of input elements to be processed. In Big
    O notation, linear complexity is presented as *O*(*n*). String matching algorithms
    such as the Boyer-Moore and Ukkonen have linear complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linear complexity, *O*(*n*), is demonstrated in an algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13ef15ac-cb0a-4625-ac53-826e6beff0c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at quadratic complexity in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An algorithm is of quadratic complexity if the processing time is proportional
    to the square of the number of input elements. In the following case, the complexity
    of the algorithm is 10*10 = 100\. The two loops have a maximum of `10`. The quadratic
    complexity for a multiplication table of *n* elements is *O*(*n*²).
  prefs: []
  type: TYPE_NORMAL
- en: 'Quadratic complexity, *O*(*n*²), is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fd50b8f-a8ea-4d8d-b719-b8b881b69e01.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at cubic complexity in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cubic complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of cubic complexity, the processing time of an algorithm is proportional
    to the cube of the input elements. The complexity of the following algorithm is
    10*10*10 = 1,000\. The three loops have a maximum of 10\. The cubic complexity
    for a matrix update is *O*(*n*³).
  prefs: []
  type: TYPE_NORMAL
- en: 'Cubic complexity *O*(*n³*) is explained in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a2abefc-499a-41e6-8d7d-1d352beacd64.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at logarithmic complexity in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Logarithmic complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An algorithm is of logarithmic complexity if the processing time is proportional
    to the logarithm of the input elements. The logarithm base is typically 2\. The
    following tree is a binary tree with `LeftNode` and `RightNode`. The insert operation
    is of *O*(*log n*) complexity, where *n* is the number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logarithmic complexity is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following code, the `Tree` class has the `insert` method, which
    inserts the element given `m` is the integer element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method calls the `insert` method on `tree` to insert the `1`, `3`,
    `5`, and `7` elements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81072ad5-36a2-4ef5-800f-98ad6791101f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know about the complexities in algorithms and analyzing their performance,
    let's take a look at brute force algorithms in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Brute force algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A brute force algorithm solves a problem based on the statement and the problem
    definition. Brute force algorithms for search and sort are sequential search and
    selection sort. Exhaustive search is another brute force algorithm where the solution
    is in a set of candidate solutions with definitive properties. The space in which
    the search happens is a state and combinatorial space, which consists of permutations,
    combinations, or subsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Brute Force algorithms are known for wide applicability and simplicity in solving
    complex problems. Searching, string matching, and matrix multiplication are some
    scenarios where they are used. Single computational tasks can be solved using
    brute force algorithms. They do not provide efficient algorithms. The algorithms
    are slow and non-performant. Representation of a brute force algorithm is shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e3fa001-4bb9-4767-b091-d69ea8165f01.png)'
  prefs: []
  type: TYPE_IMG
- en: After brute force algorithms, let's cover divide and conquer algorithms in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Divide and conquer algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A divide and conquer algorithm breaks a complex problem into smaller problems
    and solves these smaller problems. The smaller problem will be further broken
    down till it is a known problem. The approach is to recursively solve the sub-problems
    and merge the solutions of the sub-problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursion, quick sort, binary search, fast Fourier transform, and merge sort
    are good examples of divide and conquer algorithms. Memory is efficiently used
    with these algorithms. Performance is sometimes an issue in the case of recursion.
    On multiprocessor machines, these algorithms can be executed on different processors
    after breaking them down into sub-problems. A divide and conquer algorithm is
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following code, the Fibonacci method takes the *k* integer
    parameter and returns the Fibonacci number for *k*. The method uses recursion
    to calculate the Fibonacci numbers. The recursion algorithm is applied by dividing
    the problem into the `k-1` integer and the `k-2` integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b32da69-198a-488d-815a-5a6552b71bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at what backtracking algorithms are in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A backtracking algorithm solves a problem by constructing the solution incrementally.
    Multiple options are evaluated, and the algorithm chooses to go to the next component
    of the solution through recursion. Backtracking can be a chronological type or
    can traverse the paths, depending on the problem that you are solving.
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking is an algorithm that finds candidate solutions and rejects a candidate
    on the basis of its feasibility and validity. Backtracking is useful in scenarios
    such as finding a value in an unordered table. It is faster than a brute force
    algorithm, which rejects a large number of solutions in an iteration. Constraint
    satisfaction problems such as parsing, rules engine, knapsack problems, and combinatorial
    optimization are solved using backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a backtracking algorithm. The problem is to
    identify the combinations of elements in an array of 10 elements whose sum is
    equal to `18`. The `findElementsWithSum` method recursively tries to find the
    combination. Whenever the sum goes beyond the `k` target, it backtracks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa6ea6c3-f040-4d0d-ab1c-be7046319c42.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the definition of abstract datatypes, classifying data
    structures into linear, nonlinear, homogeneous, heterogeneous, and dynamic types.
    Abstract datatypes such as container, list, set, map, graph, stack, and queue
    were presented in this chapter. The chapter covered the performance analysis of
    data structures and structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the classification of data structures and structural design patterns.
    You can use algorithms such as brute force, divide and conquer, and backtracking
    by calculating the complexity and performance analysis. The choice of algorithm
    and the use of design patterns and data structures are the key takeaways.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will discuss data structures in Go. The following data
    structures will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-dimensional slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions and exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Give an example where you can use a composite pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For an array of 10 elements with a random set of integers, identify the maximum
    and minimum. Calculate the complexity of the algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To manage the state of an object, which structural pattern is relevant?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A window is sub-classed to add a scroll bar to make it a scrollable window.
    Which pattern is applied in this scenario?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the complexity of a binary tree search algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the submatrices of 2x2 in a 3x3 matrix. What is the complexity of the
    algorithm that you have used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain with a scenario the difference between brute force and backtracking
    algorithms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A rules engine uses backtracking to identify the rules affected by the change.
    Show an example where backtracking identifies the affected rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a flow chart for the algorithm of the calculation of profit-loss given
    the cost price, selling price, and quantity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the pseudo code for an algorithm that compares the strings and identifies
    the substring within a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following books are recommended if you want to find out more about Gang
    of Four design patterns, algorithms, and data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
