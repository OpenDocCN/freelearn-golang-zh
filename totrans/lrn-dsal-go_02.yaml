- en: Data Structures and Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和算法
- en: A data structure is the organization of data to reduce the storage space used
    and to reduce the difficulty while performing different tasks. Data structures
    are used to handle and work with large amounts of data in various fields, such
    as database management and internet indexing services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是数据的组织方式，旨在减少存储空间的使用，并降低执行不同任务时的难度。数据结构用于处理和操作大量数据，在各个领域都有应用，例如数据库管理和互联网索引服务。
- en: In this chapter, we will focus on the definition of abstract datatypes, classifying
    data structures into linear, nonlinear, homogeneous, heterogeneous, and dynamic
    types. Abstract datatypes, such as Container, List, Set, Map, Graph, Stack, and
    Queue, are presented in this chapter.  We will also cover the performance analysis
    of data structures, choosing the right data structures, and structural design
    patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注抽象数据类型的定义，将数据结构分类为线性、非线性、同构、异构和动态类型。本章介绍了如容器、列表、集合、映射、图、栈和队列等抽象数据类型。我们还将涵盖数据结构的性能分析、选择合适的数据结构和结构设计模式。
- en: The reader can start writing basic algorithms using the right data structures
    in Go. Given a problem, choosing the data structure and different algorithms will
    be the first step. After this, doing performance analysis is the next step. Time
    and space analysis for different algorithms helps compare them and helps you choose
    the optimal one. It is essential to have basic knowledge of Go to get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以使用Go中的正确数据结构开始编写基本算法。给定一个问题，选择数据结构和不同的算法将是第一步。之后，进行性能分析将是下一步。不同算法的时间和空间分析有助于比较它们，并帮助您选择最优的算法。要开始，对Go的基本知识是必要的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Classification of data structures and structural design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构和结构设计模式的分类
- en: Representation of algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的表示
- en: Complexity and performance analysis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂度和性能分析
- en: Brute force algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴力算法
- en: Divide and conquer algorithms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分而治之算法
- en: Backtracking algorithms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回溯算法
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Install Go version 1.10 from [https://golang.org/doc/install](https://golang.org/doc/install) for
    your operating system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://golang.org/doc/install](https://golang.org/doc/install)为您的操作系统安装Go版本1.10。
- en: The code files for this chapter can be found at the following GitHub URL: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter01](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter01)[.](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Go/tree/master/ch1)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter01](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter01)[.](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Go/tree/master/ch1)
- en: 'Check the installation of Go by running the hello world program at [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/hello_world](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/hello_world):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行位于[https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/hello_world](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/hello_world)的hello
    world程序来检查Go的安装：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the following commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot displays the output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/8057be5f-396d-4d1f-9aa4-cd3f6eee3310.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8057be5f-396d-4d1f-9aa4-cd3f6eee3310.png)'
- en: Let's take a look at the classification of data structures and structural design
    patterns in the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中数据结构和结构设计模式的分类。
- en: Classification of data structures and structural design patterns
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和结构设计模式的分类
- en: You can choose a data structure by using classification. In this section, we
    discuss data structure classification in detail. The design patterns related to
    the data structure are covered after the classification.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过分类来选择数据结构。在本节中，我们将详细讨论数据结构的分类。在分类之后，我们将介绍与数据结构相关的模式设计。
- en: In the next section, we'll take a look at classification of data structures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨数据结构的分类。
- en: Classification of data structures
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构的分类
- en: The term **data structure** refers to the organization of data in a computer's
    memory, in order to retrieve it quickly for processing. It is a scheme for data
    organization to decouple the functional definition of a data structure from its
    implementation. A data structure is chosen based on the problem type and the operations
    performed on the data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构**这个术语指的是在计算机内存中组织数据，以便快速检索以进行处理。它是一种数据组织方案，将数据结构的函数定义与其实现解耦。数据结构的选择基于问题类型和数据上的操作。'
- en: If the situation requires various datatypes within a data structure, we can
    choose heterogeneous data structures. Linked, ordered, and unordered lists are
    grouped as heterogeneous data structures. Linear data structures are lists, sets,
    tuples, queues, stacks, and heaps. Trees, tables, and containers are categorized
    as nonlinear data structures. Two-dimensional and multidimensional arrays are
    grouped as homogeneous data structures. Dynamic data structures are dictionaries,
    tree sets, and sequences.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据结构需要各种数据类型，我们可以选择异构数据结构。链表、有序列表和无序列表被分组为异构数据结构。线性数据结构包括列表、集合、元组、队列、栈和堆。树、表和容器被归类为非线性数据结构。二维和多维数组被分组为同构数据结构。动态数据结构包括字典、树集和序列。
- en: 'The classification of **Data Structures** is show in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构**的分类如下所示：'
- en: '![](img/b2325558-71a8-47e6-bb1b-fef9586dd8cc.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2325558-71a8-47e6-bb1b-fef9586dd8cc.png)'
- en: Let's take a look at lists, tuples and heaps in the next sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看列表、元组和堆。
- en: Lists
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: A list is a sequence of elements. Each element can be connected to another with
    a link in a forward or backward direction. The element can have other payload
    properties. This data structure is a basic type of container. Lists have a variable
    length and developer can remove or add elements more easily than an array. Data
    items within a list need not be contiguous in memory or on disk. Linked lists
    were proposed by Allen Newell, Cliff Shaw, and Herbert A. Simon at RAND Corporation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是元素的序列。每个元素可以通过链接与前一个或后一个元素连接。元素可以具有其他有效载荷属性。这种数据结构是基本容器类型。列表具有可变长度，开发者可以比数组更容易地删除或添加元素。列表中的数据项在内存或磁盘上不需要连续。链表是由RAND公司的Allen
    Newell、Cliff Shaw和Herbert A. Simon提出的。
- en: 'To get started, a list can be used in Go, as shown in the following example;
    elements are added through the `PushBack` method on the list, which is in the `container/list`
    package:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，可以使用Go中的列表，如下例所示；元素通过列表上的`PushBack`方法添加，该方法是`container/list`包的一部分：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The list is iterated through the `for` loop, and the element's value is accessed
    through the `Value` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以通过`for`循环迭代，并通过`Value`方法访问元素的值。
- en: 'Run the following commands:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot displays the output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/d6679223-be43-4d23-a5bd-60ab04d1a8b2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6679223-be43-4d23-a5bd-60ab04d1a8b2.png)'
- en: Let's take a look at Tuples in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看元组。
- en: Tuples
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'A tuple is a finite sorted list of elements. It is a data structure that groups
    data.  Tuples are typically immutable sequential collections. The element has
    related fields of different datatypes. The only way to modify a tuple is to change
    the fields. Operators such as + and * can be applied to tuples. A database record
    is referred to as a tuple. In the following example, power series of integers
    are calculated and the square and cube of the integer is returned as a tuple:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是元素有限排序的列表。它是一种将数据分组的数据结构。元组通常是不可变的顺序集合。元素具有不同数据类型的关联字段。修改元组的唯一方法是更改字段。+ 和
    * 等运算符可以应用于元组。数据库记录被称为元组。在以下示例中，计算了整数的幂级数，并返回整数的平方和立方作为元组：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `main` method calls the `powerSeries` method with `3` as a parameter. The
    `square` and `cube` values are returned from the method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法使用`3`作为参数调用`powerSeries`方法。方法返回`square`和`cube`值：'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the following commands:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot displays the output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/378425c0-4233-4fc6-b008-e6de29c70d6c.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/378425c0-4233-4fc6-b008-e6de29c70d6c.png)'
- en: 'The tuples can be named in the `powerSeries` function, as shown in the following
    code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`powerSeries`函数中，可以为元组命名，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If there is an error, it can be passed with tuples, as shown in the following
    code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，它可以与元组一起传递，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Heaps
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: A heap is a data structure that is based on the `heap` property. The heap data
    structure is used in selection, graph, and k-way merge algorithms. Operations
    such as finding, merging, insertion, key changes, and deleting are performed on
    heaps. Heaps are part of the `container/heap` package in Go. According to the
    heap order (maximum heap) property, the value stored at each node is greater than
    or equal to its children.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一种基于 `heap` 属性的数据结构。堆数据结构用于选择、图和 k-路归并算法。在堆上执行查找、合并、插入、键更改和删除等操作。堆是 Go 中的
    `container/heap` 包的一部分。根据堆顺序（最大堆）属性，每个节点存储的值大于或等于其子节点。
- en: 'If the order is descending, it is referred to as a maximum heap; otherwise,
    it''s a minimum heap. The heap data structure was proposed by J.W.J. Williams
    in 1964 for a heap sorting algorithm. It is not a sorted data structure, but partially
    ordered. The following example shows how to use the `container/heap` package to
    create a heap data structure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是降序排列，则称为最大堆；否则，是最小堆。堆数据结构由 J.W.J. Williams 在 1964 年提出，用于堆排序算法。它不是一个排序数据结构，但部分有序。以下示例展示了如何使用
    `container/heap` 包创建堆数据结构：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`IntegerHeap` has a `Push` method that pushes the item with the interface:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntegerHeap` 拥有一个 `Push` 方法，该方法使用以下接口来推送项目：'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the following commands:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following screenshot displays the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/1da0d4df-5edd-44a8-8a19-a991e77d7b5a.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1da0d4df-5edd-44a8-8a19-a991e77d7b5a.png)'
- en: Let's take a look at structural design patterns in the next section
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节的结构设计模式
- en: Structural design patterns
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: Structural design patterns describe the relationships between the entities.
    They are used to form large structures using classes and objects. These patterns
    are used to create a system with different system blocks in a flexible manner. Adapter,
    bridge, composite, decorator, facade, flyweight, private class data, and proxy
    are the **Gang of Four** (**GoF**) structural design patterns. The private class
    data design pattern is the other design pattern covered in this section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 结构设计模式描述了实体之间的关系。它们用于使用类和对象形成大型结构。这些模式用于以灵活的方式创建具有不同系统块的系统。适配器、桥接、组合、装饰器、外观、享元、私有类数据和代理是
    **Gang of Four** (**GoF**) 结构设计模式。私有类数据设计模式是本节中涵盖的另一个设计模式。
- en: We will take a look at adapter and bridge design patterns in the next sections.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探讨适配器和桥接设计模式。
- en: Adapter
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: The adapter pattern provides a wrapper with an interface required by the API
    client to link incompatible types and act as a translator between the two types.
    The adapter uses the interface of a class to be a class with another compatible
    interface. When requirements change, there are scenarios where class functionality
    needs to be changed because of incompatible interfaces.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式提供了一个包装器，该包装器具有 API 客户端所需的接口，用于连接不兼容的类型，并在两种类型之间充当翻译器。适配器使用一个类的接口作为具有另一个兼容接口的类。当需求变化时，存在一些场景，由于不兼容的接口，需要更改类功能。
- en: The dependency inversion principle can be adhered to by using the adapter pattern,
    when a class defines its own interface to the next level module interface implemented
    by an `adapter` class. Delegation is the other principle used by the adapter pattern.
    Multiple formats handling source-to-destination transformations are the scenarios
    where the adapter pattern is applied.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类定义自己的接口到由 `adapter` 类实现的下一级模块接口时，可以通过使用适配器模式来遵循依赖倒置原则。委托是适配器模式使用的另一个原则。处理多种格式并执行源到目标转换的场景是应用适配器模式的场景。
- en: 'The adapter pattern comprises the target, adaptee, adapter, and client:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式包括目标、适配体、适配器和客户端：
- en: Target is the interface that the client calls and invokes methods on the adapter
    and adaptee.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标是客户端调用的接口，在适配器和适配体上调用方法。
- en: The client wants the incompatible interface implemented by the adapter.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端希望适配器实现不兼容的接口。
- en: The adapter translates the incompatible interface of the adaptee into an interface
    that the client wants.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器将适配体的不兼容接口转换为客户端想要的接口。
- en: 'Let''s say you have an `IProcessor` interface with a `process` method, the `Adapter` class
    implements the `process` method and has an `Adaptee` instance as an attribute.
    The `Adaptee` class has a `convert` method and an `adapterType` instance variable.
    The developer while using the API client calls the `process` interface method to
    invoke `convert` on `Adaptee`. The code is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个`IProcessor`接口，它有一个`process`方法，`Adapter`类实现了`process`方法，并且有一个`Adaptee`实例作为属性。`Adaptee`类有一个`convert`方法和一个`adapterType`实例变量。当开发者使用API客户端时，会调用`process`接口方法来在`Adaptee`上调用`convert`方法。代码如下：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Adapter` class has a `process` method that invokes the `convert` method
    on `adaptee`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adapter`类有一个`process`方法，它会在`adaptee`上调用`convert`方法：'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the following commands:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot displays the output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了输出：
- en: '![](img/223e23d0-ea9a-4a27-af29-aa37f8a8c311.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/223e23d0-ea9a-4a27-af29-aa37f8a8c311.png)'
- en: Let's take a look at Bridge pattern in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看桥接模式。
- en: Bridge
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接模式
- en: Bridge decouples the implementation from the abstraction. The abstract base
    class can be subclassed to provide different implementations and allow implementation
    details to be modified easily. The interface, which is a bridge, helps in making
    the functionality of concrete classes independent from the interface implementer
    classes. The bridge patterns allow the implementation details to change at runtime.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式将实现与抽象解耦。抽象基类可以被子类化以提供不同的实现，并允许轻松修改实现细节。作为桥接的接口有助于使具体类的功能独立于接口实现类。桥接模式允许在运行时更改实现细节。
- en: The bridge pattern demonstrates the principle, preferring composition over inheritance.
    It helps in situations where one should subclass multiple times orthogonal to
    each other. Runtime binding of the application, mapping of orthogonal class hierarchies,
    and platform independence implementation are the scenarios where the bridge pattern
    can be applied.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式展示了原则，更倾向于组合而非继承。它有助于那些需要多次正交子类化的情况。应用运行时绑定、正交类层次映射和平台独立性实现是桥接模式可以应用的场景。
- en: The bridge pattern components are abstraction, refined abstraction, implementer,
    and concrete implementer. Abstraction is the interface implemented as an abstract
    class that clients invoke with the method on the concrete implementer. Abstraction
    maintains a *has-a* relationship with the implementation, instead of an *is-a* relationship.
    The *has-a* relationship is maintained by composition. Abstraction has a reference
    of the implementation. Refined abstraction provides more variations than abstraction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式组件包括抽象、细化抽象、实现者和具体实现者。抽象是作为抽象类实现的接口，客户端通过在具体实现者上调用方法来调用它。抽象与实现保持*has-a*关系，而不是*is-a*关系。*has-a*关系通过组合来维护。抽象有一个实现引用。细化抽象比抽象提供更多变体。
- en: Let's say `IDrawShape` is an interface with the `drawShape` method.  `DrawShape`
    implements the `IDrawShape` interface. We create an `IContour` bridge interface with
    the `drawContour` method. The contour class implements the `IContour` interface.
    The `ellipse` class will have *a*, *b* , *r* properties and `drawShape` (an instance
    of `DrawShape`). The `ellipse` class implements the `contour` bridge interface
    to implement the `drawContour` method. The  `drawContour` method calls the `drawShape` method
    on the `drawShape` instance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`IDrawShape`是一个接口，它有一个`drawShape`方法。`DrawShape`实现了`IDrawShape`接口。我们创建了一个带有`drawContour`方法的`IContour`桥接接口。轮廓类实现了`IContour`接口。`ellipse`类将具有*a*、*b*、*r*属性和`drawShape`（`DrawShape`的一个实例）。`ellipse`类实现了`contour`桥接接口以实现`drawContour`方法。`drawContour`方法在`drawShape`实例上调用`drawShape`方法。
- en: 'The following code demonstrates the bridge implementation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码演示了桥接实现：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: drawShape method
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: drawShape方法
- en: 'The `drawShape` method draws the shape given the coordinates, as shown in the
    following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawShape`方法根据给定的坐标绘制形状，如下面的代码所示：'
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: drawContour method
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: drawContour方法
- en: 'The `drawContour` method of the `DrawContour` class calls the `drawShape` method
    on the `shape` instance, this is shown in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawContour`类的`drawContour`方法在`shape`实例上调用`drawShape`方法，如下面的代码所示：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the following commands:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following screenshot displays the output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了输出：
- en: '![](img/c0562db0-8f61-409a-b8b9-a50c0d2ca323.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/c0562db0-8f61-409a-b8b9-a50c0d2ca323.png)'
- en: We will take a look at Composite, Decorator, Facade and Flyweight design patterns
    in the next sections.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨组合、装饰者、外观和享元设计模式。
- en: Composite
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: A composite is a group of similar objects in a single object. Objects are stored
    in a tree form to persist the whole hierarchy. The composite pattern is used to
    change a hierarchical collection of objects. The composite pattern is modeled
    on a heterogeneous collection. New types of objects can be added without changing
    the interface and the client code. You can use the composite pattern, for example,
    for UI layouts on the web, for directory trees, and for managing employees across
    departments. The pattern provides a mechanism to access the individual objects
    and groups in a similar manner.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '组合是一组相似对象的单个对象。对象以树形结构存储以持久化整个层次结构。组合模式用于更改对象的分层集合。组合模式基于异构集合。可以不更改接口和客户端代码添加新类型的对象。例如，可以使用组合模式进行Web上的UI布局、目录树以及跨部门管理员工。该模式提供了一种以类似方式访问单个对象和组的方法。 '
- en: 'The composite pattern comprises the `component` interface, `component` class,
    composite, and client:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式包括`component`接口、`component`类、组合和客户端：
- en: The `component` interface defines the default behavior of all objects and behaviors
    for accessing the components of the composite.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`接口定义了所有对象默认行为以及访问组合组件的行为。'
- en: The `composite` and `component` classes implement the `component` interface.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`composite`和`component`类实现了`component`接口。'
- en: The client interacts with the component interface to invoke methods in the composite.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端通过组件接口与组件交互以调用组合中的方法。
- en: 'Let''s say there is an `IComposite` interface with the `perform` method and
    `BranchClass` that implements `IComposite`  and has the `addLeaf`, `addBranch`,
    and `perform` methods. The `Leaflet` class implements `IComposite` with the `perform`
    method. `BranchClass` has a one-to-many relationship with `leafs` and `branches`.
    Iterating over the branch recursively, one can traverse the composite tree, as
    shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个具有`perform`方法且实现`IComposite`接口的`BranchClass`，它有`addLeaf`、`addBranch`和`perform`方法。`Leaflet`类通过`perform`方法实现`IComposite`。`BranchClass`与`leafs`和`branches`具有一对一的关系。通过递归遍历分支，可以遍历组合树，如下代码所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `perform` method of the `Branch` class calls the `perform` method on `branch`
    and `leafs`, as seen in the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Branch`类的`perform`方法调用`branch`和`leafs`上的`perform`方法，如下代码所示：'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As shown in the following code, the `addBranch` method of the `Branch` class adds
    a new `branch`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，`Branch`类的`addBranch`方法添加了一个新的`branch`：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the following commands:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following screenshot displays the output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/7a67a4b3-ef1f-4476-af3f-1007ce8049fd.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a67a4b3-ef1f-4476-af3f-1007ce8049fd.png)'
- en: Let's take a look at Decorator pattern in the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看装饰者模式。
- en: Decorator
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者
- en: In a scenario where class responsibilities are removed or added, the decorator
    pattern is applied. The decorator pattern helps with subclassing when modifying
    functionality, instead of static inheritance. An object can have multiple decorators
    and run-time decorators. The single responsibility principle can be achieved using
    a decorator. The decorator can be applied to window components and graphical object
    modeling. The decorator pattern helps with modifying existing instance attributes
    and adding new methods at run-time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在类责任被移除或添加的场景中，应用装饰者模式。装饰者模式在修改功能时帮助进行子类化，而不是静态继承。一个对象可以有多个装饰器和运行时装饰器。可以使用装饰者实现单一职责原则。装饰者可以应用于窗口组件和图形对象建模。装饰者模式有助于在运行时修改现有实例属性和添加新方法。
- en: 'The decorator pattern participants are the component interface, the concrete
    component class, and the `decorator` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式参与者包括组件接口、具体组件类和`decorator`类：
- en: The concrete component implements the component interface.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体组件实现了组件接口。
- en: The `decorator` class implements the component interface and provides additional
    functionality in the same method or additional methods. The decorator base can
    be a participant representing the base class for all decorators.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decorator`类实现了组件接口，并在相同的方法或额外的方法中提供附加功能。装饰器基类可以是一个参与者，代表所有装饰器的基类。'
- en: 'Let ''s say `IProcess` is an interface with the `process` method. `ProcessClass`
    implements an interface with the `process` method. `ProcessDecorator` implements
    the process interface and has an instance of `ProcessClass`. `ProcessDecorator`
    can add more functionality than `ProcessClass`, as shown in the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `IProcess` 是一个具有 `process` 方法的接口。`ProcessClass` 实现了一个具有 `process` 方法的接口。`ProcessDecorator`
    实现了过程接口并有一个 `ProcessClass` 的实例。`ProcessDecorator` 可以比 `ProcessClass` 添加更多功能，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following code, the `ProcessDecorator` class `process` method invokes
    the `process` method on the decorator instance of `ProcessClass`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`ProcessDecorator` 类的 `process` 方法在 `ProcessClass` 的装饰器实例上调用 `process`
    方法：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the following commands:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following screenshot displays the output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/35c5bee2-bd71-40f0-b536-c8ff3651b2be.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35c5bee2-bd71-40f0-b536-c8ff3651b2be.png)'
- en: Let's take a look at Facade pattern in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的 Facade 模式。
- en: Facade
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 门面
- en: Facade is used to abstract subsystem interfaces with a helper. The facade design
    pattern is used in scenarios when the number of interfaces increases and the system
    gets complicated. Facade is an entry point to different subsystems, and it simplifies
    the dependencies between the systems. The facade pattern provides an interface
    that hides the implementation details of the hidden code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 门面用于通过辅助工具抽象子系统接口。当接口数量增加且系统变得复杂时，使用门面设计模式。门面是不同子系统的入口点，它简化了系统之间的依赖关系。门面模式提供了一个接口，隐藏了隐藏代码的实现细节。
- en: A loosely coupled principle can be realized with a facade pattern. You can use
    a facade to improve poorly designed APIs. In SOA, a service facade can be used
    to incorporate changes to the contract and implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过门面模式实现松耦合原则。你可以使用门面来改进设计不良的 API。在 SOA 中，可以使用服务门面来合并对合同和实现的更改。
- en: 'The facade pattern is made up of the `facade` class, module classes, and a
    client:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 门面模式由 `facade` 类、模块类和一个客户端组成：
- en: The facade delegates the requests from the client to the module classes. The
    `facade` class hides the complexities of the subsystem logic and rules.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面将客户端的请求委派给模块类。`facade` 类隐藏了子系统逻辑和规则的复杂性。
- en: Module classes implement the behaviors and functionalities of the module subsystem.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块类实现了模块子系统的行为和功能。
- en: The client invokes the `facade` method. The `facade` class functionality can
    be spread across multiple packages and assemblies.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端调用 `facade` 方法。`facade` 类的功能可以分散到多个包和组件中。
- en: 'For example, account, customer, and transaction are the classes that have account,
    customer, and transaction creation methods. `BranchManagerFacade` can be used
    by the client to create an account, customer, and transaction:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，账户、客户和交易是具有账户、客户和交易创建方法的类。`BranchManagerFacade` 可以被客户端用来创建账户、客户和交易：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `account` class has the `deleteById` method, which is used to delete an
    account with a given ID, as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`account` 类有一个 `deleteById` 方法，用于删除具有给定 ID 的账户，如下面的代码所示：'
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the following code, the `customer` class has a method that creates a new
    customer with `name`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`customer` 类有一个创建带有 `name` 的新客户的方法：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As shown in the following code, the `transaction` class has the `create` method
    for creating a transaction:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，`transaction` 类有一个用于创建交易的 `create` 方法：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`BranchManagerFacade` has the `createCustomerAccount` method, which calls the `create`
    method on the `customer` class instance, as shown in the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`BranchManagerFacade` 有一个 `createCustomerAccount` 方法，它调用 `customer` 类实例上的 `create`
    方法，如下面的代码所示：'
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `main` method calls the `NewBranchManagerFacade` method to create a facade.
    The methods on `facade` are invoked to create `customer` and `account`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法调用 `NewBranchManagerFacade` 方法来创建一个门面。在 `facade` 上的方法被调用以创建 `customer`
    和 `account`：'
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the following commands:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following screenshot displays the output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/bfc322d5-0edc-436f-bb73-cfa293d08583.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfc322d5-0edc-436f-bb73-cfa293d08583.png)'
- en: Let's take a look at Flyweight pattern in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的 Flyweight 模式。
- en: Flyweight
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flyweight
- en: Flyweight is used to manage the state of an object with high variation. The
    pattern allows us to share common parts of the object state among multiple objects,
    instead of each object storing it. Variable object data is referred to as extrinsic
    state, and the rest of the object state is intrinsic. Extrinsic data is passed
    to flyweight methods and will never be stored within it. Flyweight pattern helps
    reduce the overall memory usage and the object initializing overhead. The pattern
    helps create interclass relationships and lower memory to a manageable level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级模式用于管理具有高度变化的对象状态。该模式允许我们在多个对象之间共享对象状态中的公共部分，而不是每个对象都存储它。可变对象数据被称为外部状态，其余对象状态是内部状态。外部数据传递给轻量级方法，并且永远不会存储在其中。轻量级模式有助于减少整体内存使用和对象初始化开销。该模式有助于创建类间关系并降低内存到可管理的水平。
- en: Flyweight objects are immutable. Value objects are a good example of the flyweight
    pattern. Flyweight objects can be created in a single thread mode, ensuring one
    instance per value. In a concurrent thread scenario, multiple instances are created.
    This is based on the equality criterion of flyweight objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级对象是不可变的。值对象是轻量级模式的一个好例子。轻量级对象可以在单线程模式下创建，确保每个值只有一个实例。在并发线程场景中，会创建多个实例。这是基于轻量级对象的等价标准。
- en: 'The participants of the flyweight pattern are the `FlyWeight` interface, `ConcreteFlyWeight`,
    `FlyWeightFactory`, and the `Client` classes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级模式的参与者是 `FlyWeight` 接口、`ConcreteFlyWeight`、`FlyWeightFactory` 和 `Client`
    类：
- en: The `FlyWeight` interface has a method through which flyweights can get and
    act on the extrinsic state.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlyWeight` 接口有一个方法，通过该方法轻量级对象可以获取并作用于外部状态。'
- en: '`ConcreteFlyWeight` implements the `FlyWeight` interface to represent flyweight
    objects.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteFlyWeight` 实现了 `FlyWeight` 接口以表示轻量级对象。'
- en: '`FlyweightFactory` is used to create and manage flyweight objects. The client
    invokes `FlyweightFactory` to get a flyweight object. `UnsharedFlyWeight` can
    have a functionality that is not shared.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlyweightFactory` 用于创建和管理轻量级对象。客户端调用 `FlyweightFactory` 来获取轻量级对象。`UnsharedFlyWeight`
    可以具有不共享的功能。'
- en: '`Client` classes'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client` 类'
- en: 'Let''s say `DataTransferObject` is an interface with the `getId` method. `DataTransferObjectFactory`
    creates a data transfer object through `getDataTransferObject` by the `DTO` type.
    The `DTO` types are customer, employee, manager, and address, as shown in the
    following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `DataTransferObject` 是一个具有 `getId` 方法的接口。`DataTransferObjectFactory` 通过 `getDataTransferObject`
    方法根据 `DTO` 类型创建数据传输对象。`DTO` 类型包括客户、员工、经理和地址，如下代码所示：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the following code, the `DataTransferObject` interface is implemented by
    the `Customer` class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`Customer` 类实现了 `DataTransferObject` 接口：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `DataTransferObject` interface is implemented by the `Manager` class, as
    shown in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，`Manager` 类实现了 `DataTransferObject` 接口：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the following commands:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following screenshot displays the output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/839f35da-05ca-48fc-aa64-769274250a37.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/839f35da-05ca-48fc-aa64-769274250a37.png)'
- en: We will take a look at Private class and Proxy data patterns in the next sections.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中查看私有类和代理数据模式。
- en: Private class data
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有类数据
- en: The private class data pattern secures the data within a class. This pattern
    encapsulates the initialization of the class data. The write privileges of properties
    within the private class are protected, and properties are set during construction.
    The private class pattern prints the exposure of information by securing it in
    a class that retains the state. The encapsulation of class data initialization
    is a scenario where this pattern is applicable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 私有类数据模式确保了类内部数据的安全。该模式封装了类数据的初始化。私有类属性中的写权限受到保护，属性在构造过程中被设置。私有类模式通过在保持状态的情况下将信息封装在类中来打印信息的暴露。类数据初始化的封装是此模式适用的一种场景。
- en: '`Account` is a class with account details and a customer name. `AccountDetails`
    is the private attribute of `Account` , and `CustomerName` is the public attribute.
    JSON marshaling of `Account` has `CustomerName` as a public property. `AccountDetails`
    is the package property in Go (modeled as private class data):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account` 是一个包含账户详情和客户名称的类。`AccountDetails` 是 `Account` 的私有属性，而 `CustomerName`
    是公共属性。`Account` 的 JSON 序列化将 `CustomerName` 作为公共属性。`AccountDetails` 是 Go 中的包属性（模拟为私有类数据）：'
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As shown in the following code, the `Account` class has the `getId` method,
    which returns the `id` private class attribute:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，`Account`类有`getId`方法，它返回私有的类属性`id`：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `main` method calls the `Account` initializer with `CustomerName`. The
    details of the account are set details with the `setDetails` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法使用`CustomerName`调用`Account`初始化器。使用`setDetails`方法设置账户的详细信息：'
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the following commands:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following screenshot displays the output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/50c0055c-a7f4-4d86-bf64-d30690516cf0.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50c0055c-a7f4-4d86-bf64-d30690516cf0.png)'
- en: Let's take a look at Proxy pattern in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的代理模式。
- en: Proxy
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: The proxy pattern forwards to a real object and acts as an interface to others.
    The proxy pattern controls access to an object and provides additional functionality.
    The additional functionality can be related to authentication, authorization,
    and providing rights of access to the resource-sensitive object. The real object
    need not be modified while providing additional logic. Remote, smart, virtual,
    and protection proxies are the scenarios where this pattern is applied. It is
    also used to provide an alternative to extend functionality with inheritance and
    object composition. A proxy object is also referred to as a surrogate, handle,
    or wrapper.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式将请求转发到真实对象，并作为其他对象的接口。代理模式控制对对象的访问并提供附加功能。附加功能可以与身份验证、授权和提供对资源敏感对象的访问权限相关。在提供附加逻辑时，不需要修改真实对象。远程、智能、虚拟和保护代理是应用此模式的情况。它还用于通过继承和对象组合提供扩展功能的替代方案。代理对象也被称为代表、处理程序或包装器。
- en: 'The proxy pattern comprises the subject interface, the `RealSubject` class,
    and the `Proxy` class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式包括主题接口、`RealSubject`类和`Proxy`类：
- en: Subject is an interface for the `RealObject` and `Proxy` class.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题是`RealObject`和`Proxy`类的接口。
- en: The `RealSubject` object is created and maintained as a reference in the `Proxy`
    class. `RealSubject` is resource sensitive, required to be protected, and expensive
    to create.  `RealObject` is a class that implements the `IRealObject` interface.
    It has a `performAction` method.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RealSubject`对象在`Proxy`类中被创建并维护为引用。`RealSubject`是资源敏感的，需要被保护，且创建成本高昂。`RealObject`是一个实现`IRealObject`接口的类。它有一个`performAction`方法。'
- en: '`VirtualProxy` is used to access `RealObject` and invoke the `performAction`
    method.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualProxy`用于访问`RealObject`并调用`performAction`方法。'
- en: 'The following code shows an implementation of proxy pattern:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了代理模式的实现：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the following commands:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following screenshot displays the output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/938fb87b-a174-4cda-82a1-a5bda4e6ebed.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/938fb87b-a174-4cda-82a1-a5bda4e6ebed.png)'
- en: Now that we know the classification of data structures and the design patterns
    used, let's go ahead and take a look at the representation of algorithms.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了数据结构的分类和所使用的模式，让我们继续看看算法的表示。
- en: Representation of algorithms
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法的表示
- en: A flow chart and pseudo code are methods of representing algorithms. An algorithm
    shows the logic of how a problem is solved. A flow chart has different representation
    symbols such as Entry, Exit, Task, Input/Output, Decision Point, and Inter Block.
    A structured program consists of a series of these symbols to perform a specific
    task. Pseudo code has documentation, action, and flow control keywords to visualize
    an algorithm. The documentation keywords are **TASK** and **REM**. **SET**, **PUT**,
    and **GET** are the action keywords.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图和伪代码是表示算法的方法。算法显示了解决问题逻辑。流程图有不同的表示符号，如入口、退出、任务、输入/输出、决策点和交互块。结构化程序由一系列这些符号组成，以执行特定任务。伪代码有文档、动作和流程控制关键字来可视化算法。文档关键字是**任务**和**备注**。**设置**、**放置**和**获取**是动作关键字。
- en: Let's take a look at the different representations of algorithms, that is, flow
    charts and Pseudo code in the next sections.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看算法的不同表示，即在下一节中讨论的流程图和伪代码。
- en: Flow chart
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程图
- en: 'The flow control keywords are **SET**, **LOOP**, (**WHILE**, **UNTIL**), **REP,**
    and **POST**. The following flow chart shows a formula or an algorithm to calculate
    the dividend given a number of shares, the face value, and the dividend percentage.
    The start and end are the Entry and Exit symbols. The input number of shares,
    share face value, and dividend percentage use the Input symbol. The compute dividend
    and output dividend use the Task symbol and Output symbol respectively:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制关键字是 **SET**、**LOOP**、(**WHILE**、**UNTIL**)、**REP** 和 **POST**。以下流程图显示了给定股票数量、面值和分红百分比时计算股息的公式或算法。开始和结束是入口和出口符号。输入股票数量、股票面值和分红百分比使用输入符号。计算股息和输出股息分别使用任务符号和输出符号：
- en: '![](img/54bfe074-8b26-4af2-8e65-4285564adc78.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54bfe074-8b26-4af2-8e65-4285564adc78.png)'
- en: In the next section, we'll take a look at pseudo code, representation of algorithms.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨伪代码，即算法的表示。
- en: Pseudo code
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪代码
- en: Pseudo code is a high-level design of a program or algorithm. Sequence and selection
    are two constructs used in pseudo code. Pseudo code is easier than a flow chart
    visualizes the algorithm while pseudo code can be easily modified and updated.
    Errors in design can be caught very early in pseudo code. This saves the cost
    of fixing defects later.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码是程序或算法的高级设计。顺序和选择是伪代码中使用的两种结构。与流程图相比，伪代码更容易可视化算法，同时伪代码可以轻松修改和更新。设计中的错误可以在伪代码的早期阶段被发现。这可以节省以后修复缺陷的成本。
- en: 'To give an example, we want to find the `max` value in an array of length *n*.
    The pseudo code will be written as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，我们想要在一个长度为 *n* 的数组中找到 `max` 值。伪代码将如下所示：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we know the different ways to represent the algorithm, let's take a
    look at how we can monitor its complexity and performance in the next section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了表示算法的不同方法，让我们看看在下一节中我们如何监控其复杂性和性能。
- en: Complexity and performance analysis
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂度与性能分析
- en: The efficiency of an algorithm is measured through various parameters, such
    as CPU time, memory, disk, and network. The complexity is how the algorithm scales
    when the number of input parameters increases. Performance is a measure of time,
    space, memory, and other parameters. Algorithms are compared by their processing
    time and resource consumption. Complexity measures the parameters and is represented
    by the Big O notation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的效率是通过各种参数来衡量的，例如 CPU 时间、内存、磁盘和网络。复杂度是当输入参数的数量增加时算法如何扩展。性能是时间、空间、内存和其他参数的度量。算法通过其处理时间和资源消耗进行比较。复杂度衡量参数，并使用大
    O 符号表示。
- en: Complexity analysis of algorithms
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法复杂度分析
- en: The complexity of an algorithm is measured by the speed of the algorithm. Typically,
    the algorithm will perform differently based on processor speed, disk speed, memory,
    and other hardware parameters. Hence, asymptotical complexity is used to measure
    the complexity of an algorithm. An algorithm is a set of steps to be processed
    by different operations to achieve a task. The time taken for an algorithm to
    complete is based on the number of steps taken.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的复杂度是通过算法的速度来衡量的。通常，算法的性能会根据处理器速度、磁盘速度、内存和其他硬件参数的不同而有所不同。因此，使用渐近复杂度来衡量算法的复杂度。算法是一系列步骤，通过不同的操作来完成任务。算法完成所需的时间基于所采取的步骤数量。
- en: 'Let''s say an algorithm iterates through an array, `m`, of size `10` and update
    the elements to the sum of index and `200`. The computational time will be 10**t,*
    where *t* is the time taken to add two integers and update them to an array. The
    next step will be printing them after iterating over an array. The *t*  time parameter
    will vary with the hardware of the computer used. Asymptotically, the computational
    time grows as a factor of `10`, as shown in the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个算法遍历一个大小为 `10` 的数组 `m`，并将元素更新为索引和 `200` 的和。计算时间将是 10**t**，其中 *t* 是将两个整数相加并将它们更新到数组中所需的时间。下一步将是遍历数组后打印它们。*t*
    时间参数将随着所使用的计算机硬件的不同而变化。从渐近的角度来看，计算时间随着 `10` 的因子增长，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the following commands:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following screenshot displays the output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/5d88a6f8-cc2b-40cb-8f26-1fec5139aed8.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d88a6f8-cc2b-40cb-8f26-1fec5139aed8.png)'
- en: Let's take a look at the different complexity types in the next sections.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中不同的复杂度类型。
- en: Big O notation
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大 O 符号
- en: The *T*(*n*) time function represents the algorithm complexity based on Big
    O notation. *T*(*n*) = *O*(*n*) states that an algorithm has a linear time complexity.
    Using Big O notation, the constant time, linear time, logarithmic time, cubic
    time, and quadratic time complexity are different complexity types for an algorithm.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*(n)时间函数表示基于大O符号的算法复杂度。*T*(n) = *O*(n)表示算法具有线性时间复杂度。使用大O符号，常数时间、线性时间、对数时间、立方时间和二次时间复杂度是算法的不同复杂度类型。'
- en: Linear time, *O*(*n*), is used as a measure of complexity in scenarios such
    as linear search, traversing, and finding the minimum and maximum number of array
    elements. ArrayList and queue are data structures that have these methods. An
    algorithm that has logarithmic time, *O*(*log n*), is a binary search in a tree
    data structure. Bubble sort, selection sort, and insertion sort algorithms have
    complexity of quadratic time, *O*(*n*²). Big Omega Ω and big Theta Θ are notations
    for the lower and upper bounds for a particular algorithm.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 线性时间，*O*(n)，在如线性搜索、遍历和查找数组元素的最小和最大数量等场景中用作复杂度的度量。ArrayList和队列是具有这些方法的数据结构。具有对数时间，*O*(log
    n)的算法是在树数据结构中的二分搜索。冒泡排序、选择排序和插入排序算法具有二次时间复杂度，*O*(n²)。大Omega Ω和大Theta Θ是表示特定算法下限和上限的符号。
- en: The worst case, best case, average case, and amortized run-time complexity is
    used for analysis of algorithms. Amortized run-time complexity is referred to
    as 2*^n*. Asymptotically, it will tend to *O*(1).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏情况、最好情况、平均情况和摊销运行时间复杂度用于算法分析。摊销运行时间复杂度被称为2*^n*。从渐近的角度来看，它将趋向于*O*(1)。
- en: Big O notation is also used to determine how much space is consumed by the algorithm.
    This helps us find the best and worst case scenarios, relative to space and time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号也用于确定算法消耗的空间量。这有助于我们找到相对于空间和时间的最优和最坏情况。
- en: Let's take a look at linear complexity in the next section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的线性复杂度。
- en: Linear complexity
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性复杂度
- en: An algorithm is of linear complexity if the processing time or storage space
    is directly proportional to the number of input elements to be processed. In Big
    O notation, linear complexity is presented as *O*(*n*). String matching algorithms
    such as the Boyer-Moore and Ukkonen have linear complexity.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法的处理时间或存储空间与要处理的输入元素数量成正比，则该算法为线性复杂度。在大O符号中，线性复杂度表示为*O*(n)。例如，Boyer-Moore和Ukkonen字符串匹配算法具有线性复杂度。
- en: 'Linear complexity, *O*(*n*), is demonstrated in an algorithm as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 线性复杂度，*O*(n)，如下算法所示：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the following commands:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following screenshot displays the output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/13ef15ac-cb0a-4625-ac53-826e6beff0c6.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13ef15ac-cb0a-4625-ac53-826e6beff0c6.png)'
- en: Let's take a look at quadratic complexity in the next section.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的二次复杂度。
- en: Quadratic complexity
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二次复杂度
- en: An algorithm is of quadratic complexity if the processing time is proportional
    to the square of the number of input elements. In the following case, the complexity
    of the algorithm is 10*10 = 100\. The two loops have a maximum of `10`. The quadratic
    complexity for a multiplication table of *n* elements is *O*(*n*²).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法的处理时间与输入元素数量的平方成正比，则该算法为二次复杂度。在以下情况下，算法的复杂度为10*10 = 100。两个循环的最大值为`10`。n个元素的乘法表的二次复杂度为*O*(n²)。
- en: 'Quadratic complexity, *O*(*n*²), is shown in the following example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 二次复杂度，*O*(n²)，在以下示例中展示：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the following commands:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following screenshot displays the output:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/5fd50b8f-a8ea-4d8d-b719-b8b881b69e01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5fd50b8f-a8ea-4d8d-b719-b8b881b69e01.png)'
- en: Let's take a look at cubic complexity in the next section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的立方复杂度。
- en: Cubic complexity
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立方复杂度
- en: In the case of cubic complexity, the processing time of an algorithm is proportional
    to the cube of the input elements. The complexity of the following algorithm is
    10*10*10 = 1,000\. The three loops have a maximum of 10\. The cubic complexity
    for a matrix update is *O*(*n*³).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在立方复杂度的情况下，算法的处理时间与输入元素的立方成正比。以下算法的复杂度为10*10*10 = 1,000。三个循环的最大值为10。矩阵更新的立方复杂度为*O*(n³)。
- en: 'Cubic complexity *O*(*n³*) is explained in the following example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例解释了立方复杂度 *O*(n³*)：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the following commands:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following screenshot displays the output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/3a2abefc-499a-41e6-8d7d-1d352beacd64.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a2abefc-499a-41e6-8d7d-1d352beacd64.png)'
- en: Let's take a look at logarithmic complexity in the next section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节的对数复杂度。
- en: Logarithmic complexity
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数复杂度
- en: An algorithm is of logarithmic complexity if the processing time is proportional
    to the logarithm of the input elements. The logarithm base is typically 2\. The
    following tree is a binary tree with `LeftNode` and `RightNode`. The insert operation
    is of *O*(*log n*) complexity, where *n* is the number of nodes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法的处理时间与输入元素的对数成比例，则该算法具有对数复杂度。对数的底数通常是2。以下树是一个具有`LeftNode`和`RightNode`的二元树。插入操作具有*O*(*log
    n*)复杂度，其中*n*是节点数。
- en: 'Logarithmic complexity is presented as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对数复杂度如下所示：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As shown in the following code, the `Tree` class has the `insert` method, which
    inserts the element given `m` is the integer element:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，`Tree`类具有`insert`方法，该方法插入给定的整数元素`m`：
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `main` method calls the `insert` method on `tree` to insert the `1`, `3`,
    `5`, and `7` elements, as shown in the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法在`tree`上调用`insert`方法以插入`1`、`3`、`5`和`7`元素，如下代码所示：'
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the following commands:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following screenshot displays the output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/81072ad5-36a2-4ef5-800f-98ad6791101f.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81072ad5-36a2-4ef5-800f-98ad6791101f.png)'
- en: Now that we know about the complexities in algorithms and analyzing their performance,
    let's take a look at brute force algorithms in the next section.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了算法的复杂性和分析其性能，那么让我们在下一节看看暴力算法。
- en: Brute force algorithms
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴力算法
- en: A brute force algorithm solves a problem based on the statement and the problem
    definition. Brute force algorithms for search and sort are sequential search and
    selection sort. Exhaustive search is another brute force algorithm where the solution
    is in a set of candidate solutions with definitive properties. The space in which
    the search happens is a state and combinatorial space, which consists of permutations,
    combinations, or subsets.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力算法基于陈述和问题定义来解决问题。搜索和排序的暴力算法是顺序搜索和选择排序。穷举搜索是另一种暴力算法，其中解决方案是一组具有确定属性的候选解决方案。搜索发生的空间是一个状态和组合空间，它由排列、组合或子集组成。
- en: 'Brute Force algorithms are known for wide applicability and simplicity in solving
    complex problems. Searching, string matching, and matrix multiplication are some
    scenarios where they are used. Single computational tasks can be solved using
    brute force algorithms. They do not provide efficient algorithms. The algorithms
    are slow and non-performant. Representation of a brute force algorithm is shown
    in the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力算法以其广泛的应用性和解决复杂问题的简单性而闻名。搜索、字符串匹配和矩阵乘法是一些它们被使用的场景。单个计算任务可以使用暴力算法解决。它们不提供有效的算法。这些算法速度慢，性能不佳。以下代码展示了暴力算法的表示：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the following commands:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following screenshot displays the output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/6e3fa001-4bb9-4767-b091-d69ea8165f01.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e3fa001-4bb9-4767-b091-d69ea8165f01.png)'
- en: After brute force algorithms, let's cover divide and conquer algorithms in the
    next section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完暴力算法之后，我们将在下一节介绍分而治之算法。
- en: Divide and conquer algorithms
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分而治之算法
- en: A divide and conquer algorithm breaks a complex problem into smaller problems
    and solves these smaller problems. The smaller problem will be further broken
    down till it is a known problem. The approach is to recursively solve the sub-problems
    and merge the solutions of the sub-problems.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 分而治之算法将复杂问题分解为更小的问题，并解决这些较小的问题。较小的问题将进一步分解，直到成为已知问题。方法是递归解决子问题并合并子问题的解决方案。
- en: 'Recursion, quick sort, binary search, fast Fourier transform, and merge sort
    are good examples of divide and conquer algorithms. Memory is efficiently used
    with these algorithms. Performance is sometimes an issue in the case of recursion.
    On multiprocessor machines, these algorithms can be executed on different processors
    after breaking them down into sub-problems. A divide and conquer algorithm is
    shown in the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 递归、快速排序、二分搜索、快速傅里叶变换和归并排序是分而治之算法的好例子。这些算法有效地使用了内存。在递归的情况下，性能有时是一个问题。在多处理器机器上，这些算法可以在将它们分解为子问题后在不同的处理器上执行。以下代码展示了分而治之算法：
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As shown in the following code, the Fibonacci method takes the *k* integer
    parameter and returns the Fibonacci number for *k*. The method uses recursion
    to calculate the Fibonacci numbers. The recursion algorithm is applied by dividing
    the problem into the `k-1` integer and the `k-2` integer:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，斐波那契方法接受一个整数参数*k*，并返回*k*的斐波那契数。该方法使用递归来计算斐波那契数。递归算法通过将问题分解为`k-1`整数和`k-2`整数来应用：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Run the following commands:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following screenshot displays the output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了输出：
- en: '![](img/6b32da69-198a-488d-815a-5a6552b71bcd.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b32da69-198a-488d-815a-5a6552b71bcd.png)'
- en: Let's take a look at what backtracking algorithms are in the next section.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中回溯算法是什么。
- en: Backtracking algorithms
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回溯算法
- en: A backtracking algorithm solves a problem by constructing the solution incrementally.
    Multiple options are evaluated, and the algorithm chooses to go to the next component
    of the solution through recursion. Backtracking can be a chronological type or
    can traverse the paths, depending on the problem that you are solving.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯算法通过逐步构建解决方案来解决一个问题。评估多个选项，并通过递归选择算法的下一个解决方案组件。回溯可以是按时间顺序的类型，也可以根据问题遍历路径。根据你解决的问题，回溯可以是按时间顺序的类型，也可以遍历路径。
- en: Backtracking is an algorithm that finds candidate solutions and rejects a candidate
    on the basis of its feasibility and validity. Backtracking is useful in scenarios
    such as finding a value in an unordered table. It is faster than a brute force
    algorithm, which rejects a large number of solutions in an iteration. Constraint
    satisfaction problems such as parsing, rules engine, knapsack problems, and combinatorial
    optimization are solved using backtracking.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯是一种算法，它基于候选解决方案的可行性和有效性来找到候选解决方案并拒绝它。在查找无序表中的值等场景中，回溯非常有用。它比暴力搜索算法更快，后者在迭代中拒绝大量解决方案。回溯用于解决约束满足问题，如解析、规则引擎、背包问题和组合优化问题。
- en: 'The following is an example of a backtracking algorithm. The problem is to
    identify the combinations of elements in an array of 10 elements whose sum is
    equal to `18`. The `findElementsWithSum` method recursively tries to find the
    combination. Whenever the sum goes beyond the `k` target, it backtracks:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子是一个回溯算法。问题是识别一个包含10个元素的数组中，元素组合的和等于`18`。`findElementsWithSum`方法递归地尝试找到组合。每当和超过`k`目标时，它就会回溯：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the following commands:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following screenshot displays the output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了输出：
- en: '![](img/fa6ea6c3-f040-4d0d-ab1c-be7046319c42.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa6ea6c3-f040-4d0d-ab1c-be7046319c42.png)'
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the definition of abstract datatypes, classifying data
    structures into linear, nonlinear, homogeneous, heterogeneous, and dynamic types.
    Abstract datatypes such as container, list, set, map, graph, stack, and queue
    were presented in this chapter. The chapter covered the performance analysis of
    data structures and structural design patterns.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了抽象数据类型的定义，将数据结构分为线性、非线性、同构、异构和动态类型。本章介绍了容器、列表、集合、映射、图、栈和队列等抽象数据类型。本章还涵盖了数据结构的性能分析和结构设计模式。
- en: We looked at the classification of data structures and structural design patterns.
    You can use algorithms such as brute force, divide and conquer, and backtracking
    by calculating the complexity and performance analysis. The choice of algorithm
    and the use of design patterns and data structures are the key takeaways.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了数据结构的分类和结构设计模式。你可以通过计算复杂度和性能分析来使用诸如暴力搜索、分而治之、回溯等算法。算法的选择以及设计模式和数据结构的使用是关键要点。
- en: 'In the next chapter, we will discuss data structures in Go. The following data
    structures will be covered:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Go中的数据结构。以下数据结构将被涵盖：
- en: Arrays
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Slices
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片
- en: Two-dimensional slices
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二维切片
- en: Maps
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Questions and exercises
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和练习
- en: Give an example where you can use a composite pattern.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出一个可以使用组合模式的例子。
- en: For an array of 10 elements with a random set of integers, identify the maximum
    and minimum. Calculate the complexity of the algorithm.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于一个包含10个元素的随机整数数组，识别最大值和最小值。计算算法的复杂度。
- en: To manage the state of an object, which structural pattern is relevant?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了管理对象的状态，哪种结构模式是相关的？
- en: A window is sub-classed to add a scroll bar to make it a scrollable window.
    Which pattern is applied in this scenario?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个窗口被子类化以添加滚动条，使其成为可滚动的窗口。在这种情况下应用了哪种模式？
- en: Find the complexity of a binary tree search algorithm.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出二叉树搜索算法的复杂度。
- en: Identify the submatrices of 2x2 in a 3x3 matrix. What is the complexity of the
    algorithm that you have used?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个3x3矩阵中识别2x2的子矩阵。你所使用的算法的复杂度是多少？
- en: Explain with a scenario the difference between brute force and backtracking
    algorithms.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用场景解释暴力搜索算法和回溯算法之间的区别。
- en: A rules engine uses backtracking to identify the rules affected by the change.
    Show an example where backtracking identifies the affected rules.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规则引擎使用回溯来识别受变化影响的规则。请展示一个示例，说明回溯如何识别受影响的规则。
- en: Draw a flow chart for the algorithm of the calculation of profit-loss given
    the cost price, selling price, and quantity.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个流程图，用于计算成本价、售价和数量的利润亏损算法。
- en: Write the pseudo code for an algorithm that compares the strings and identifies
    the substring within a string.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个算法的伪代码，该算法比较字符串并识别字符串中的子字符串。
- en: Further reading
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following books are recommended if you want to find out more about Gang
    of Four design patterns, algorithms, and data structures:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于四人帮设计模式、算法和数据结构的内容，以下书籍推荐：
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式》，作者：艾里克·伽玛、理查德·赫尔姆、拉尔夫·约翰逊和约翰·弗利斯塞斯
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《算法导论 第3版》，作者：托马斯·H·科门、查尔斯·E·莱伊森、罗纳德·L·里维斯和克利福德·斯坦
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《数据结构与算法：简单入门》，作者：鲁道夫·拉塞尔
