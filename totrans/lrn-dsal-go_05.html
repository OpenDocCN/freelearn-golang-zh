<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linear Data Structures</h1>
                </header>
            
            <article>
                
<p>Various applications, such as Facebook, Twitter, and Google, use <span class="s1">lists and linear data structures. As we have discussed previously, data structures allow us to organize vast swathes of data in a sequential and organized manner, thereby reducing time and effort in working with such data. L<span>ists, stacks, sets, and tuples are some of the commonly used linear data structures.</span> </span></p>
<p><span class="s1">In this chapter, </span><span>we will discuss these data structures by giving examples of var</span><span>ious procedures involving them.</span> <span>We will discuss t</span>he various operations related to these data structures, such as insertion, deletion, updating, traversing (of lists), reversing, and merging with various code samples. </p>
<p><span>We will cover the following linear data structures in this chapter:</span></p>
<ul>
<li class="mce-root">Lists</li>
<li class="mce-root">Sets</li>
<li class="mce-root">Tuples</li>
<li class="mce-root">Stacks</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">Install Go version 1.10 at <a href="https://golang.org/doc/install">https://golang.org/doc/install</a>, depending on your operating system.</p>
<p>The code files for this chapter can be found at the following GitHub URL: <a href="https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter03">https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter03</a>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lists</h1>
                </header>
            
            <article>
                
<p class="mce-root">A list is a collection of ordered elements<span class="fontstyle0"> that are used to store list of items</span>. <span class="fontstyle0">Unlike array lists, these can expand and shrink dynamically.</span></p>
<p class="mce-root"><span class="fontstyle0">Lists also be used as a base for other data structures, such as stack and queue.</span><span> <span class="fontstyle0">Lists can be used to store lists of users, car parts, ingredients, to-do items, and various other such elements.</span></span> <span>Lists are the most commonly used linear data structures. </span>These were introduced in the lisp programming language. In this chapter, linked list and doubly linked list are the lists we will cover in the Go language.</p>
<p class="mce-root">Let's discuss the operations related to add, update, remove, and lookup on linked list and doubly linked list in the following section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">LinkedList</h1>
                </header>
            
            <article>
                
<p class="mce-root"><kbd>LinkedList</kbd> is a sequence of nodes that have properties and a reference to the next node in the sequence. It is a linear data structure that is used to store data. The data structure permits the addition and deletion of components from any node next to another node. They are not stored contiguously in memory, which makes them different arrays<strong>.</strong></p>
<p>The following sections will look at the structures and methods in a linked list.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Node class</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The <kbd>Node</kbd> class has an integer typed variable with the name <kbd>property</kbd>. The class has another variable with the name <kbd>nextNode</kbd>, which is a node pointer. Linked list will have a set of nodes with integer</span> properties, <span>as follows:</span></p>
<pre class="mce-root">//Node class<br/>type Node struct {<br/>    property int<br/>    nextNode *Node<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The LinkedList class</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>LinkedList</kbd> class has the <kbd>headNode</kbd> pointer as its property. By traversing to <kbd>nextNode</kbd> from <kbd>headNode</kbd>, you can iterate through the linked list, as shown in the following code:</p>
<pre class="mce-root">// LinkedList class<br/>type LinkedList struct {<br/>    headNode *Node<br/>}</pre>
<p class="mce-root">The different methods of the <kbd>LinkedList</kbd> class, such as <kbd>AddtoHead</kbd>, <kbd>IterateList</kbd>, <kbd>LastNode</kbd>, <kbd>AddtoEnd</kbd>, <kbd>NodeWithValue</kbd>, <kbd>AddAfter</kbd>, and the <kbd>main</kbd> method, are discussed in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddToHead method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>AddToHead</kbd> method adds the node to the start of the linked list. The <kbd>AddToHead</kbd> <span>method </span><span>of the <kbd>LinkedList</kbd> class has a parameter integer property</span><span>. The property is used to initialize the node. A new node is instantiated and its property is set to the <kbd>property</kbd> parameter that's passed. The <kbd>nextNode</kbd> points to the current <kbd>headNode</kbd> of <kbd>linkedList</kbd>, and <kbd>headNode</kbd> is set to the pointer of the new node that's created, as shown in the following code:</span></p>
<pre class="mce-root">//AddToHead method of LinkedList class<br/>func (linkedList *LinkedList) AddToHead(property int) {<br/>    var node = Node{}<br/>    node.property = property<br/>    if node.nextNode != nil {<br/>        node.nextNode = linkedList.headNode<br/>    }<br/>    linkedList.headNode = &amp;node<br/>}</pre>
<p>When the node with the <kbd>1</kbd> property is added to the head, adding the <kbd>1</kbd> property to the head of <kbd>linkedList</kbd> sets <kbd>headNode</kbd> to <kbd>currentNode</kbd> with a value of <kbd>1</kbd>, as you can see in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ad748616-2e91-4121-a91a-5c3b9ba06066.png" width="273" height="33"/></p>
<p class="mce-root"/>
<p class="mce-root">Let's execute this command using the <kbd>main</kbd> method. Here, we have created an instance of a <kbd>LinkedList</kbd> class and added the <kbd>1</kbd> and <kbd>3</kbd> integer properties to the head of this instance. The linked list's <kbd>headNode</kbd> property is printed after adding the elements, as follows:</p>
<pre class="mce-root">// main method<br/>func main() {<br/>    var linkedList LinkedList<br/>    linkedList = LinkedList{}<br/>    linkedList.AddToHead(1)<br/>    linkedList.AddToHead(3)<br/>    fmt.Println(linkedList.headNode.property)<br/>}</pre>
<p class="p1"><span class="s1">Run the following commands to execute the </span><kbd>linked_list.go</kbd> file:</p>
<pre class="mce-root"><strong>go run linked_list.go</strong></pre>
<p class="mce-root">After executing the preceding command, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7a3f103f-e736-4475-a7ca-56583342dcae.png" style="width:28.17em;height:5.33em;" width="1007" height="190"/></p>
<p class="CDPAlignLeft CDPAlign">Let's take a look at the <kbd>IterateList</kbd> method in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The IterateList method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>IterateList</kbd> method of the <kbd>LinkedList</kbd> class iterates from the <kbd>headNode</kbd> property and prints the property of the current head node. The iteration happens with the head node moves to <kbd>nextNode</kbd> of the <kbd>headNode</kbd> property until the current node is no longer equal to <kbd>nil</kbd>. The following code shows the <kbd>IterateList</kbd> method of the <kbd>LinkedList</kbd> class:</p>
<pre class="mce-root">//IterateList method iterates over LinkedList<br/>func (linkedList *LinkedList) IterateList() {<br/>    var node *Node<br/>    for node = linkedList.headNode; node != nil; node = node.nextNode {<br/>        fmt.Println(node.property)<br/>    }<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The LastNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>LastNode</kbd> method of <kbd>LinkedList</kbd> returns the node at the end of the list. The list is traversed to check whether <kbd>nextNode</kbd> is <kbd>nil</kbd> from <span><kbd>nextNode</kbd> of </span><kbd>headNode</kbd>, as follows:</p>
<pre class="mce-root">//LastNode method returns the last Node<br/><br/>func (linkedList *LinkedList) LastNode() *Node{<br/> var node *Node<br/> var lastNode *Node<br/> for node = linkedList.headNode; node != nil; node = node.nextNode {<br/> if node.nextNode ==nil {<br/> lastNode = node<br/> }<br/> }<br/> return lastNode<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddToEnd method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>AddToEnd</kbd> method adds the node at the end of the list. In the following code, the current <kbd>lastNode</kbd> is found and its <kbd>nextNode</kbd> property is set as the added node:</p>
<pre class="mce-root">//AddToEnd method adds the node with property to the end<br/><br/>func (linkedList *LinkedList) AddToEnd(property int) {<br/> var node = &amp;Node{}<br/> node.property = property<br/> node.nextNode = nil<br/> var lastNode *Node<br/> lastNode = linkedList.LastNode()<br/> if lastNode != nil {<br/> lastNode.nextNode = node<br/> }<br/>}</pre>
<p>In the following screenshot, the <kbd>AddToEnd</kbd> method is invoked when the node with a property value of <span class="packt_screen">5</span> is added to the end. Adding the property through this method creates a node with a value of <span class="packt_screen">5</span>. The last node of the list has a property value of <span class="packt_screen">5</span>. The <kbd>nextNode</kbd> property of <kbd>lastNode</kbd> is <kbd>nil</kbd>. The <kbd>nextNode</kbd> of <kbd>lastNode</kbd> is set to the node with a value of <span class="packt_screen">5</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d8bf773f-ae86-4ec4-8079-eab1b05c1ed2.png" style="width:32.33em;height:5.25em;" width="499" height="81"/></p>
<p class="mce-root">Let's take a look at the <kbd>NodeWithValue</kbd> method in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NodeWithValue method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code snippet, the <kbd>NodeWithValue</kbd> method of <kbd>LinkedList</kbd> returns the node with the <kbd>property</kbd> value. The list is traversed and checked to see whether the <kbd>property</kbd> value is equal to the parameter property:</p>
<pre class="mce-root">//NodeWithValue method returns Node given parameter property<br/><br/>func (linkedList *LinkedList) NodeWithValue(property int) *Node{<br/> var node *Node<br/> var nodeWith *Node<br/> for node = linkedList.headNode; node != nil; node = node.nextNode {<br/> if node.property == property {<br/> nodeWith = node<br/> break;<br/> }<br/> }<br/> return nodeWith<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddAfter method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>AddAfter</kbd> method adds the node after a specific node. The <kbd>AddAfter</kbd> method of <kbd>LinkedList</kbd> has <kbd>nodeProperty</kbd> and <kbd>property</kbd> <span>parameters</span><span>. A node with the <kbd>nodeProperty</kbd> value is retrieved using the <kbd>NodeWithValue</kbd> method. A node with <kbd>property</kbd> is created and added after the <kbd>NodeWith</kbd> node, as follows:</span></p>
<pre class="mce-root">//AddAfter method adds a node with nodeProperty after node with property<br/><br/>func (linkedList *LinkedList) AddAfter(nodeProperty int,property int) {<br/> var node = &amp;Node{}<br/> node.property = property<br/> node.nextNode = nil<br/> var nodeWith *Node<br/> nodeWith = linkedList.NodeWithValue(nodeProperty)<br/> if nodeWith != nil {<br/> node.nextNode = nodeWith.nextNode<br/> nodeWith.nextNode = node<br/> }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>You then get the following output when the <kbd>AddAfter</kbd> method is invoked when the node with a</span> property <span>value of <span class="packt_screen">7</span> is added after the node with a value of <span class="packt_screen">1</span>. The <kbd>nextNode</kbd> property of the node with a property value</span> of <span class="packt_screen">1</span> <span>is</span> <span class="packt_screen">nil</span><span>. The <kbd>nextNode</kbd> property of the node with a property value</span> of <span class="packt_screen">1</span><span> is set to the node with a value of <span class="packt_screen">5</span>: </span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4702e546-c068-42ff-9d31-9b1814410e73.png" style="width:39.25em;height:7.33em;" width="578" height="107"/></p>
<p class="mce-root">Let's take a look at the <kbd>main</kbd> method in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p>The <kbd>main</kbd> method adds the nodes with integer properties of <kbd>1</kbd>, <kbd>3</kbd>, and <kbd>5</kbd>, as shown in the following code<span>. A node with an integer property of <kbd>7</kbd> is added after the node with an integer property of <kbd>1</kbd>. The <kbd>IterateList</kbd> method is invoked on the <kbd>linkedList</kbd> instance, as follows:</span></p>
<pre class="mce-root">// main method<br/>func main() {<br/>    var linkedList LinkedList<br/>    linkedList = LinkedList{}<br/>    linkedList.AddToHead(1)<br/>    linkedList.AddToHead(3)<br/>    linkedList.AddToEnd(5)<br/>    linkedList.AddAfter(1,7)<br/>    linkedList.IterateList()<br/>}</pre>
<p>The main method adds <kbd>1</kbd> and<span> <kbd>3</kbd> to the head of the linked list. <kbd>5</kbd> is added to the end. <kbd>7</kbd> is added after <kbd>1</kbd>. The linked list will be <kbd>3</kbd>, <kbd>1</kbd>, <kbd>7</kbd>, and <kbd>5</kbd>.</span></p>
<p class="p1"><span class="s1">Run the following commands to execute the </span><kbd>linked_list.go</kbd> file:</p>
<pre class="mce-root"><strong>go run linked_list.go</strong></pre>
<p class="mce-root"/>
<p class="mce-root"><span>After executing the preceding command, we get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/81213159-77ca-4f5d-bcda-3822916087df.png" style="width:35.08em;height:8.08em;" width="1125" height="259"/></p>
<p class="CDPAlignLeft CDPAlign">Let's take a look at doubly linked list in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Doubly linked list</h1>
                </header>
            
            <article>
                
<p class="mce-root">In a doubly linked list, all nodes have a pointer to the node they are connected to, on either side of them, in the list. This means that each node is connected to two nodes, and we can traverse forward through to the next node or backward through to the previous node. Doubly linked lists allow insertion, deletion and, obviously, traversing operations. The node class definition is presented in the following code example:</p>
<pre class="mce-root">// Node class<br/>type Node struct {<br/>    property int<br/>    nextNode *Node<br/>    previousNode *Node<br/>}</pre>
<p>The following sections explain doubly linked list methods, such as the <kbd>NodeBetweenValues</kbd>, <kbd>AddToHead</kbd>, <kbd>AddAfter</kbd>, <kbd>AddToEnd</kbd>, and <kbd>main</kbd> methods.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NodeBetweenValues method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>NodeBetweenValues</kbd> method of the <kbd>LinkedList</kbd> class returns the node that has a property lying between the <kbd>firstProperty</kbd> and <kbd>secondProperty</kbd> values. The method traverses the list to find out whether the <kbd>firstProperty</kbd> and <kbd>secondProperty</kbd> <span>integer properties </span>match on consecutive nodes, as follows:</p>
<pre class="mce-root">//NodeBetweenValues method of LinkedList<br/>func (linkedList *LinkedList) NodeBetweenValues(firstProperty int,secondProperty int) *Node{<br/>    var node *Node<br/>    var nodeWith *Node<br/>    for node = linkedList.headNode; node != nil; node = node.nextNode {<br/>        if node.previousNode != nil &amp;&amp; node.nextNode != nil {<br/>            if node.previousNode.property == firstProperty &amp;&amp; node.nextNode.property ==    <br/>            secondProperty{<br/>               nodeWith = node<br/>               break;<br/>            }<br/>        }<br/>    }<br/>    return nodeWith<br/>}</pre>
<p>The example output after the node between the values method was invoked with <span class="packt_screen">1</span> and <span class="packt_screen">5</span> is shown in the following screenshot. The <kbd>nextNode</kbd> of the <kbd>lastNode</kbd> is set to the node with a value of <span class="packt_screen">5</span>. The node with a property value of <span class="packt_screen">7</span> is between the nodes with property values of <span class="packt_screen">1</span> and <span class="packt_screen">5</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c0578a2b-1158-44d6-b779-2b695aaf820c.png" style="width:33.42em;height:4.58em;" width="518" height="71"/></p>
<p class="CDPAlignLeft CDPAlign">Let's take a look at the <kbd>AddToHead</kbd> method in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddToHead method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>AddToHead</kbd> method of the doubly <kbd>LinkedList</kbd> class sets the <kbd>previousNode</kbd> property of the current <kbd>headNode</kbd> of the linked list to the node that's added with property. The node with property will be set as the <kbd>headNode</kbd> of the <kbd>LinkedList</kbd> method in the following code:</p>
<pre class="mce-root">//AddToHead method of LinkedList<br/>func (linkedList *LinkedList) AddToHead(property int) {<br/> var node = &amp;Node{}<br/> node.property = property<br/> node.nextNode = nil<br/> if linkedList.headNode != nil {<br/> node.nextNode = linkedList.headNode<br/> linkedList.headNode.previousNode = node<br/> }<br/> linkedList.headNode = node<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The example output after the  <kbd>AddToHead</kbd> method was invoked with property <span class="packt_screen">3</span> is as follows. A node with property <span class="packt_screen">3</span> is created. The <kbd>headNode</kbd> property of the list has a property value of <span class="packt_screen">1</span>. The current node with property <span class="packt_screen">3</span> has a <kbd>nextNode</kbd> property of <span class="packt_screen">nil</span>. The <kbd>nextNode</kbd> property of the current node is set to <kbd>headNode</kbd> with a property value of <span class="packt_screen">1</span>. The previous node of the <kbd>headNode</kbd> property is set to the current node:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a4ca7f7f-d7b2-4cc0-9592-f8a6efca6f9b.png" width="725" height="108"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at the <kbd>AddAfter</kbd> method in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">AddAfter method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>AddAfter</kbd> method adds a node after a specific node to a double linked list. The <kbd>AddAfter</kbd> method of the double <kbd>LinkedList</kbd> class searches the node whose value is equal to <kbd>nodeProperty</kbd>. The found node is set as the <kbd>previousNode</kbd> of the node that was added with property. The <kbd>nextNode</kbd> of the added node will be the <kbd>nodeWith</kbd> property's <kbd>nextNode</kbd>. The <kbd>previousNode</kbd> of the added node will be the node that was found with value equal to <kbd>nodeProperty</kbd>. The <kbd>nodeWith</kbd> node will be updated to the current node. <span>In the following code, the <kbd>AddAfter</kbd> method is shown:</span></p>
<pre class="mce-root">//AddAfter method of LinkedList<br/>func (linkedList *LinkedList) AddAfter(nodeProperty int,property int) {<br/> var node = &amp;Node{}<br/> node.property = property<br/> node.nextNode = nil<br/> var nodeWith *Node<br/> nodeWith = linkedList.NodeWithValue(nodeProperty)<br/> if nodeWith != nil {<br/> <br/> node.nextNode = nodeWith.nextNode<br/> node.previousNode = nodeWith<br/> nodeWith.nextNode = node<br/> }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>The example output after the <kbd>AddAfter</kbd> method is invoked with property 7 is as follows. A node with property value <span class="packt_screen">7</span> is created. The <kbd>nextNode</kbd> property of the created node is <kbd>nil</kbd>. The <kbd>nextNode</kbd> property of the created node is set to <kbd>headNode</kbd> with property value <span class="packt_screen">1</span>. The <kbd>previousNode</kbd> property of <kbd>headNode</kbd> is set to the current node:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1a2834b3-fbf4-4858-acf6-5446b5d16e41.png" width="651" height="106"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at the <kbd>AddToEnd</kbd> method in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddToEnd method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>AddToEnd</kbd> method adds the node to the end of the double linked list. The <kbd>AddToEnd</kbd> method of the <kbd>LinkedList</kbd> class creates a node whose property is set as the integer parameter property. The method sets the <kbd>previousNode</kbd> property of the node that was added with the current <kbd>lastNode</kbd> property as follows. The <kbd>nextNode</kbd> of the current <kbd>lastNode</kbd> property is set to a node added with property at the end as follows:</p>
<pre class="mce-root">//AddToEnd method of LinkedList<br/>func (linkedList *LinkedList) AddToEnd(property int) {<br/> var node = &amp;Node{}<br/> node.property = property<br/> node.nextNode = nil<br/> var lastNode *Node<br/> lastNode = linkedList.LastNode()<br/> if lastNode != nil {<br/> <br/> lastNode.nextNode = node<br/> node.previousNode = lastNode<br/> }<br/>}</pre>
<p class="mce-root"/>
<p><span>The example output after the <kbd>AddToEnd</kbd> method was invoked with property <span class="packt_screen">5</span> is as follows. A node with property value <span class="packt_screen">5</span> is created. The <kbd>lastNode</kbd> of the list has property value <span class="packt_screen">1</span>. The <kbd>nextNode</kbd> property of the <kbd>lastNode</kbd> is <kbd>nil</kbd>. The <kbd>nextNode</kbd> of the <kbd>lastNode</kbd> is set to the node with property value <span class="packt_screen">5</span>. The <kbd>previousNode</kbd> of the created node is set to the node with property value <span class="packt_screen">1</span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/597173b4-caf3-48f3-b369-c29569362ae9.png" style="width:44.33em;height:6.75em;" width="631" height="95"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at the <kbd>main</kbd> method in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code snippet, the <kbd>main</kbd> method calls the <kbd>NodeBetweenValues</kbd> property with <kbd>firstProperty</kbd> and <kbd>secondProperty</kbd>. The node property between values <kbd>1</kbd> and <kbd>5</kbd> is printed:</p>
<pre class="mce-root">// main method<br/>func main() {<br/> var linkedList LinkedList<br/> linkedList = LinkedList{}<br/> linkedList.AddToHead(1)<br/> linkedList.AddToHead(3) linkedList.AddToEnd(5)<br/> linkedList.AddAfter(1,7)<br/> fmt.Println(linkedList.headNode.property)<br/> var node *Node<br/> node = linkedList.NodeBetweenValues(1,5)<br/> fmt.Println(node.property)<br/>}</pre>
<p>The <kbd>main</kbd> method creates a linked list. The nodes are added to the head and end. The node between values <kbd>1</kbd> and <kbd>5</kbd> is searched and its property is printed.</p>
<p class="p1"><span class="s1">Run the following command <span>to execute the <kbd>doubly_linked_list.go</kbd> file</span>:</span></p>
<pre class="mce-root"><strong>go run doubly_linked_list.go</strong></pre>
<p class="mce-root"><span>After executing the preceding command, we get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/617c65dd-924b-4aa7-b9d1-9d51d4688881.png" style="width:46.00em;height:8.42em;" width="1131" height="206"/></p>
<p>The next section talks about sets, which are linear data structures.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sets</h1>
                </header>
            
            <article>
                
<p class="mce-root">A Set is a linear data structure that has a collection of values that are not repeated. A set can store unique values without any particular order. <span class="fontstyle0">In the real world, sets can be used to collect all tags for blog posts and conversation participants in a chat</span><span>. </span>The data can be of Boolean, integer, float, characters, and other types. Static sets allow only query operations, which means operations related to querying the elements. Dynamic and mutable sets allow for the insertion and deletion of elements. Algebraic operations such as union, intersection, difference, and subset can be defined on the sets. The following example shows the <kbd>Set</kbd> integer with a <kbd>map</kbd> integer key and <kbd>bool</kbd> as a value:</p>
<pre class="mce-root">//main package has examples shown<br/>// in Hands-On Data Structures and algorithms with Go book<br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/>)<br/>//Set class<br/>type Set struct {<br/> integerMap map[int]bool<br/>}<br/>//create the map of integer and bool<br/>func (set *Set) New(){<br/> set.integerMap = make(map[int]bool)<br/>}</pre>
<p>The <kbd>AddElement</kbd>, <kbd>DeleteElement</kbd>, <kbd>ContainsElement</kbd>, <kbd>Intersect</kbd>, <kbd>Union</kbd>, and <kbd>main</kbd> methods are discussed in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddElement method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>AddElement</kbd> method adds the element to a set. In the following code snippet, the <kbd>AddElement</kbd> method of the <kbd>Set</kbd> class adds the element to <kbd>integerMap</kbd> if the element is not in the <kbd>Set</kbd>. The <kbd>integerMap</kbd> element has the key integer and value as <kbd>bool</kbd>, as shown in the following code:</p>
<pre class="mce-root">// adds the element to the set<br/>func (set *Set) AddElement(element int){<br/> if !set.ContainsElement(element) {<br/>  set.integerMap[element] = true<br/> }<br/>}</pre>
<p>The example output after invoking the <kbd>AddElement</kbd> method with parameter <span class="packt_screen">2</span> is as follows. The check is done if there is an element with value <span class="packt_screen">2</span>. If there is no element, the map is set to true with the key as <span class="packt_screen">2</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5bcb8123-4485-46d5-ae6d-19d96a269670.png" width="390" height="78"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at the <kbd>DeleteElement</kbd> method in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The DeleteElement method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>DeleteElement</kbd> method deletes the element from <kbd>integerMap</kbd> using the <kbd>delete</kbd> method. This method removes the element from the <kbd>integerMap</kbd> of the set, as follows:</p>
<pre class="mce-root">//deletes the element from the set<br/>func (set *Set) DeleteElement(element int) {<br/>    delete(set.integerMap,element)<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The ContainsElement method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>ContainsElement</kbd> method of the <kbd>Set</kbd> class checks whether or not the element exists in <kbd>integerMap</kbd>. The <kbd>integerMap</kbd> element is looked up with a key integer element, as shown in the following code example:</p>
<pre class="mce-root"><br/>//checks if element is in the set<br/>func (set *Set) ContainsElement(element int) bool{<br/> var exists bool<br/> _, exists = set.integerMap[element]<br/> return exists<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method – contains element</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code snippet, the <kbd>main</kbd> method creates <kbd>Set</kbd>, invokes the <kbd>New</kbd> method, and adds elements <kbd>1</kbd> and <kbd>2</kbd>. The check is done if element <kbd>1</kbd> exists in the set:</p>
<pre class="mce-root">// main method<br/>func main() {<br/>    var set *Set<br/>    set = &amp;Set{}<br/>    set.New()<br/>    set.AddElement(1)<br/>    set.AddElement(2)<br/>    fmt.Println(set)<br/>    fmt.Println(set.ContainsElement(1))<br/>}</pre>
<p class="p1"><span class="s1">Run the following command to execute the <kbd>set.go</kbd> file:</span></p>
<pre class="mce-root"><strong>go run set.go</strong></pre>
<p class="mce-root"><span>After executing the preceding command, we get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/18bc1ab4-a4a8-4ad1-9f49-cd5ac47960af.png" style="width:31.58em;height:6.67em;" width="936" height="197"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at the <kbd>InterSect</kbd> method in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The InterSect method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code, the <kbd>InterSect</kbd> method on the <kbd>Set</kbd> class returns an <kbd>intersectionSet</kbd> that consists of the intersection of <kbd>set</kbd> and <kbd>anotherSet</kbd>. The <kbd>set</kbd> class is traversed through <kbd>integerMap</kbd> and checked against another <kbd>Set</kbd> to see if any elements exist:</p>
<pre class="mce-root">//Intersect method returns the set which intersects with anotherSet<br/><br/>func (set *Set) Intersect(anotherSet *Set) *Set{<br/> var intersectSet = &amp; Set{}<br/> intersectSet.New()<br/> var value int<br/> for(value,_ = range set.integerMap){<br/>   if anotherSet.ContainsElement(value) {<br/>    intersectSet.AddElement(value)<br/>   }<br/> }<br/> return intersectSet <br/>}</pre>
<p>The example output after invoking the intersect with the parameter of another <kbd>Set</kbd> is as follows. A new <kbd>intersectSet</kbd> is created. The current <kbd>set</kbd> is iterated and every value is checked to see if it is in another <kbd>set</kbd>. If the value is in another <kbd>set</kbd>, it is added to the <kbd>set</kbd> intersect:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/38334219-8c06-41f4-925d-4eee31e865fc.png" style="width:22.83em;height:5.42em;" width="441" height="104"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at the <kbd>Union</kbd> method in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Union method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Union</kbd> method on the <kbd>Set</kbd> class returns a <kbd>unionSet</kbd> that consists of a union of <kbd>set</kbd> and <kbd>anotherSet</kbd>. Both sets are traversed through <kbd>integerMap</kbd> keys, and union set is updated with elements from the sets, as follows:</p>
<pre class="mce-root">//Union method returns the set which is union of the set with anotherSet<br/><br/>func (set *Set) Union(anotherSet *Set) *Set{<br/> var unionSet = &amp; Set{}<br/> unionSet.New()<br/> var value int<br/> for(value,_ = range set.integerMap){<br/>   unionSet.AddElement(value)<br/> }<br/> <br/> for(value,_ = range anotherSet.integerMap){<br/>   unionSet.AddElement(value)<br/> }<br/> <br/> return unionSet <br/>}</pre>
<p>The example output after invoking the union method with the <kbd>anotherSet</kbd> parameter is as follows. A new <kbd>unionSet</kbd> is created. The current set and another set values are iterated. Every value is added to the union set:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3c1db8a4-701e-41c8-b595-8dc16d738359.png" style="width:17.25em;height:11.75em;" width="317" height="214"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at the <kbd>main</kbd> method in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method – intersection and union</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code snippet, the <kbd>main</kbd> method calls intersect and union on the set class, passing the <kbd>anotherSet</kbd><span> parameter</span><span>. The intersection and union sets are printed as follows:</span></p>
<pre class="mce-root">// main method<br/>func main() {<br/> var set *Set<br/> set = &amp;Set{}<br/> set.New()<br/> set.AddElement(1)<br/> set.AddElement(2)<br/> fmt.Println("initial set", set)<br/> fmt.Println(set.ContainsElement(1))<br/> var anotherSet *Set<br/> anotherSet = &amp;Set{}<br/> anotherSet.New()<br/> anotherSet.AddElement(2)<br/> anotherSet.AddElement(4)<br/> anotherSet.AddElement(5) fmt.Println(set.Intersect(anotherSet))<br/> fmt.Println(set.Union(anotherSet))<br/>}</pre>
<p>The main method takes two sets and finds the intersection and union of the sets.</p>
<p class="p1"><span class="s1">Run the following command to execute the <kbd>set.go</kbd> file:</span></p>
<pre class="mce-root"><strong>go run set.go</strong></pre>
<p class="mce-root"><span>After executing the preceding command, we get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/67d39427-fa0f-4e9c-9384-6085685b886e.png" style="width:29.67em;height:7.17em;" width="1122" height="269"/></p>
<p>The next section talks about tuples, which are finite ordered sequences of objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tuples</h1>
                </header>
            
            <article>
                
<p class="mce-root">Tuples are finite ordered sequences of objects. They can contain a mixture of other data types and are used to group related data into a data structure. In a relational database, a tuple is a row of a table. <span class="fontstyle0">Tuples have a fixed size compared to lists, and are also faster.</span> A finite set of tuples in the relational database is referred to as a relation instance. A tuple can be assigned in a single statement, which is useful for swapping values. <span class="fontstyle0">Lists usually contain values of the same data type, while tuples contain different data. For example, we can store a name, age, and favorite color of a user in a tuple.</span> Tuples were covered in <a href="fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml" target="_blank">Chapter 1</a>, <em>Data Structures and Algorithms</em>. The following sample shows a multi-valued expression from a function's call (<kbd>tuples.go</kbd>):</p>
<pre class="mce-root">//main package has examples shown<br/> // in Hands-On Data Structures and algorithms with Go book<br/> package main<br/> // importing fmt package<br/> import (<br/> "fmt"<br/> )<br/> //h function which returns the product of parameters x and y<br/> func h(x int, y int) int {<br/> return x*y<br/> }<br/> // g function which returns x and y parameters after modification<br/> func g(l int, m int) (x int, y int) {<br/> x=2*l<br/> y=4*m<br/> return<br/> }<br/> // main method<br/> func main() {<br/> fmt.Println(h(g()))<br/> }</pre>
<p>The <kbd>main</kbd> function calls the <kbd>h</kbd> function with the <kbd>g</kbd> function as its parameter. The <kbd>g</kbd> function returns the <span> tuple</span> <kbd>x</kbd> and <kbd>y</kbd> integers.</p>
<p class="p1"><span class="s1">Run the following command to execute the <kbd>tuples.go</kbd> file:</span></p>
<pre class="mce-root"><strong>go run tuples.go</strong></pre>
<p class="mce-root"><span>After executing the preceding command, we get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/72656d18-fa9a-403d-b244-8e1e12df1e35.png" style="width:32.50em;height:4.67em;" width="1146" height="163"/></p>
<p>The next section talks about queues, which are linear data structures.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Queues</h1>
                </header>
            
            <article>
                
<p class="mce-root">A queue consists of elements to be processed in a particular order or based on priority. A priority-based queue of orders is shown in the following code, structured as a heap. Operations such as enqueue, dequeue, and peek can be performed on queue. A queue is a linear data structure and a sequential collection. Elements are added to the end and are removed from the start of the collection. Q<span class="fontstyle0">ueues are commonly used for storing tasks that need to be done, or incoming HTTP requests that need to be processed by a server.</span> In real life, handling interruptions in real-time systems, call handling, and CPU task scheduling are good examples for using queues.</p>
<p class="mce-root"/>
<p class="mce-root">The following code shows the queue of Orders and how the <kbd>Queue</kbd> type is defined:</p>
<pre class="mce-root">// Queue—Array of Orders Type<br/>type Queue []*Order<br/><br/>// Order class<br/>type Order struct {<br/>    priority int<br/>    quantity int<br/>    product string<br/>    customerName string<br/>}</pre>
<p>The following sections in the chapter discuss the <kbd>New</kbd>, <kbd>Add</kbd>, and <kbd>main</kbd> methods of queue.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The New method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>New</kbd> method on the <kbd>Order</kbd> class assigns the properties from the <kbd>priority</kbd>, <kbd>quantity</kbd>, and <kbd>product</kbd> parameters for name and <kbd>customerName</kbd>. The method initializes the properties of the order as follows:</p>
<pre class="mce-root">// New method initializes with Order with priority, quantity, product, customerName<br/>func (order *Order) New(priority int, quantity int, product string, customerName string ){<br/> order.priority = priority<br/> order.quantity = quantity<br/> order.product = product<br/> order.customerName = customerName<br/> }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Add method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code snippet, the <kbd>Add</kbd> method on the <kbd>Queue</kbd> class takes the <kbd>order</kbd> parameter and adds it to <kbd>Queue</kbd> based on the priority. Based on this, the location of the <kbd>order</kbd> parameter is found by comparing it with the <kbd>priority</kbd> parameter:</p>
<pre class="mce-root">//Add method adds the order to the queue<br/>func (queue *Queue) Add(order *Order){<br/> if len(*queue) == 0 {<br/> *queue = append(*queue,order)<br/> } else{<br/> var appended bool<br/> appended = false<br/> var i int<br/> var addedOrder *Order<br/> for i, addedOrder = range *queue {<br/> if order.priority &gt; addedOrder.priority {<br/> *queue = append((*queue)[:i], append(Queue{order}, (*queue)[i:]...)...)<br/> appended = true<br/> break<br/> }<br/> }<br/> if !appended {<br/> *queue = append(*queue, order)<br/> }<br/> }<br/>}</pre>
<p>The example output after the <kbd>add</kbd> method is invoked with the <span>order </span>parameter is as follows. The order is checked to see whether or not it exists in the queue. The order is then appended to the queue:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/72844ffd-21b2-4ccf-a3de-bd20028220dd.png" style="width:19.92em;height:3.08em;" width="324" height="49"/></p>
<p><span>Let's take a look at the Main method in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method – queues</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>main</kbd> method creates two orders, and the priority of the orders is set to <kbd>2</kbd> and <kbd>1</kbd>. <span>In the following code, t</span>he queue will first process the order with t<span>he higher number on the priority value:</span></p>
<pre class="mce-root"><br/>// main method<br/>func main() {<br/> var queue Queue<br/> queue = make(Queue,0)<br/> var order1 *Order = &amp;Order{}<br/> var priority1 int = 2<br/> var quantity1 int = 20<br/> var product1 string = "Computer"<br/> var customerName1 string = "Greg White"<br/> order1.New(priority1,quantity1,product1, customerName1)<br/> var order2 *Order = &amp;Order{}<br/> var priority2 int = 1<br/> var quantity2 int = 10<br/> var product2 string = "Monitor"<br/> var customerName2 string = "John Smith"<br/> order2.New(priority2,quantity2,product2, customerName2)<br/> queue.Add(order1)<br/><br/> <span>queue.Add(order2)</span><br/><span>var i int</span><br/><span>for i=0; i&lt; len(queue); i++ {</span><br/><span>fmt.Println(queue[i])</span><br/><span>}</span><br/><span>}</span></pre>
<p class="p1"><span class="s1">Run the following commands <span>to execute the <kbd>queue.go</kbd> file</span>:</span></p>
<pre class="mce-root"><strong>go run queue.go</strong></pre>
<p class="mce-root"><span>After executing the preceding command, we get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/af04ddad-2f0f-4ae8-9923-47f53957c4ff.png" style="width:23.83em;height:6.50em;" width="475" height="129"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at <em>Synchronized queue</em> in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Synchronized queue</h1>
                </header>
            
            <article>
                
<p class="mce-root">A synchronized queue consists of elements that need to be processed in a particular sequence. Passenger queue and ticket processing queues are types of synchronized queues, as follows:</p>
<pre class="mce-root"><br/>//main package has examples shown<br/>// in Hands-On Data Structures and algorithms with Go book<br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/> "time"<br/> "math/rand"<br/>)<br/>// constants<br/>const (<br/> messagePassStart = iota<br/> messageTicketStart<br/> messagePassEnd<br/> messageTicketEnd<br/>)<br/>//Queue class<br/>type Queue struct {<br/> waitPass int<br/> waitTicket int<br/> playPass bool<br/> playTicket bool<br/> queuePass chan int<br/> queueTicket chan int<br/> message chan int<br/>}</pre>
<p>We will discuss the different methods of synchronized queue in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The New method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>New</kbd> method on <kbd>Queue</kbd> initializes <kbd>message</kbd>, <kbd>queuePass</kbd>, and <kbd>queueTicket</kbd> with <kbd>nil</kbd> values. The <kbd>make</kbd> method creates a <kbd>Queue</kbd> with a <kbd>chan</kbd> <span>integer parameter, </span>as follows:</p>
<pre class="mce-root">// New method initializes queue<br/>func (queue *Queue) New() {<br/> queue.message = make(chan int)<br/> queue.queuePass= make(chan int)<br/> queue.queueTicket= make(chan int)<br/> }</pre>
<p class="mce-root">In the following code example, the <kbd>Go</kbd> routine handles selecting the message based on the type of message and the respective queue to process it:</p>
<pre class="mce-root">go func() {<br/> var message int<br/> for {<br/> select {<br/> case message = &lt;-queue.message:<br/> switch message {<br/> case messagePassStart:<br/> queue.waitPass++<br/> case messagePassEnd:<br/> queue.playPass = false<br/> case messageTicketStart:<br/> queue.waitTicket++<br/> case messageTicketEnd:<br/> queue.playTicket = false<br/> }<br/> if queue.waitPass &gt; 0 &amp;&amp; queue.waitTicket &gt; 0 &amp;&amp; !queue.playPass &amp;&amp; !queue.playTicket {<br/> queue.playPass = true<br/> queue.playTicket = true<br/> queue.waitTicket--<br/> queue.waitPass--<br/> queue.queuePass &lt;- 1<br/> queue.queueTicket &lt;- 1<br/> }<br/> }<br/> }<br/> }()<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The StartTicketIssue method </h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>StartTicketIssue</kbd> method starts the issuing of a ticket for passengers standing in a queue. The <kbd>StartTicketIssue</kbd> method on <kbd>Queue</kbd> sends <kbd>messageTicketStart</kbd> to the message queue and <kbd>queueTicket</kbd> receives the message. The ticket issue is started by sending messages to the queue, as follows:</p>
<pre class="mce-root">// StartTicketIssue starts the ticket issue<br/>func (Queue *Queue) StartTicketIssue() {<br/> Queue.message &lt;- messageTicketStart<br/> &lt;-Queue.queueTicket<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The EndTicketIssue method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>EndTicketIssue</kbd> method finishes the issuing of a ticket to a passenger standing in the queue. In the following code, the <kbd>EndTicketIssue</kbd> method on <kbd>Queue</kbd> sends <kbd>messageTicketEnd</kbd> to the message queue. The ticket issue is ended by sending the message:</p>
<pre class="mce-root">// EndTicketIssue ends the ticket issue<br/>func (Queue *Queue) EndTicketIssue() {<br/> Queue.message &lt;- messageTicketEnd<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The ticketIssue method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>ticketIssue</kbd> method starts and finishes the issuing of a ticket to the passenger. The <kbd>ticketIssue</kbd> method<span> </span>invokes the <kbd>StartTicketIssue</kbd> and <kbd>EndTicketIssue</kbd> methods after <kbd>Sleep</kbd> calls for 10 seconds and two seconds. The ticket is issued after the ticket is processed, as shown in the following code:</p>
<pre class="mce-root">//ticketIssue starts and ends the ticket issue<br/>func ticketIssue(Queue *Queue) {<br/> for {<br/> // Sleep up to 10 seconds.<br/> time.Sleep(time.Duration(rand.Intn(10000)) * time.Millisecond)<br/> Queue.StartTicketIssue()<br/> fmt.Println("Ticket Issue starts")<br/> // Sleep up to 2 seconds.<br/> time.Sleep(time.Duration(rand.Intn(2000)) * time.Millisecond)<br/> fmt.Println("Ticket Issue ends")<br/> Queue.EndTicketIssue()<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The StartPass method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>StartPass</kbd> method starts the passenger queue moving toward the ticket counter. The <kbd>StartPass</kbd> method on <kbd>Queue</kbd> sends <kbd>messagePassStart</kbd> to the message queue and <kbd>queuePass</kbd> receives the message. Passengers are moved into the queue as follows:</p>
<pre class="mce-root">//StartPass ends the Pass Queue<br/>func (Queue *Queue) StartPass() {<br/>    Queue.message &lt;- messagePassStart<br/>    &lt;-Queue.queuePass<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The EndPass method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>EndPass</kbd> method stops the passenger queue moving toward the ticket counter. The <kbd>EndPass</kbd> method on <kbd>Queue</kbd> sends <kbd>messagePassEnd</kbd> to the message queue in the following code. The p<span>assenger is moved to the counter for ticket processing, and the passenger is then out of the queue:</span></p>
<pre class="mce-root">//EndPass ends the Pass Queue<br/>func (Queue *Queue) EndPass() {<br/>    Queue.message &lt;- messagePassEnd<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The passenger method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>passenger</kbd> methods starts and ends passenger movement to the queue. The <kbd>passenger</kbd> method invokes the <kbd>StartPass</kbd> method, and the <kbd>EndPass</kbd> method ends after sleep calls for 10 seconds and two seconds. The passenger moves into the queue and reaches the ticket counter, as shown in the following code:</p>
<pre class="mce-root">//passenger method starts and ends the pass Queue<br/>func passenger(Queue *Queue) {<br/> //fmt.Println("starting the passenger Queue")<br/> for {<br/> // fmt.Println("starting the processing")<br/> // Sleep up to 10 seconds.<br/> time.Sleep(time.Duration(rand.Intn(10000)) * time.Millisecond)<br/> Queue.StartPass()<br/> fmt.Println(" Passenger starts")<br/> // Sleep up to 2 seconds.<br/> time.Sleep(time.Duration(rand.Intn(2000)) * time.Millisecond)<br/> fmt.Println( " Passenger ends")<br/> Queue.EndPass()<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>main</kbd> method calls the <kbd>passenger</kbd> and <kbd>ticketIssue</kbd> methods after creating a queue. The passenger enters into the queue and a ticket is issued at the counter in the processing queue, as explained in the following code:</p>
<pre class="mce-root">// main method<br/>func main() {<br/> var Queue *Queue = &amp; Queue{}<br/> //fmt.Println(Queue)<br/> Queue.New()<br/> fmt.Println(Queue)<br/> var i int<br/> for i = 0; i &lt; 10; i++ {<br/> // fmt.Println(i, "passenger in the Queue")<br/> go passenger(Queue)<br/> }<br/> //close(Queue.queuePass)<br/> var j int<br/> for j = 0; j &lt; 5; j++ {<br/> // fmt.Println(i, "ticket issued in the Queue")<br/> go ticketIssue(Queue)<br/> }<br/> select {}<br/>}</pre>
<p class="p1"><span class="s1">Run the following command <span>to execute the <kbd>sync_queue.go</kbd> file</span>:</span></p>
<pre class="mce-root"><strong>go run sync_queue.go</strong></pre>
<p class="mce-root"><span>After executing the preceding command, we get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/31ab2f30-3205-462c-acb7-d7ec21c7b32d.png" style="width:32.50em;height:21.50em;" width="525" height="346"/></p>
<p>The next section talks about <kbd>Stacks</kbd>, which are linear data structures.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Stacks</h1>
                </header>
            
            <article>
                
<p class="mce-root">A stack is a last in, first out structure in which items are added from the top. <span class="fontstyle0">Stacks are used in parsers for solving maze algorithms</span><span>. </span><kbd>Push</kbd>, <kbd>pop</kbd>, <kbd>top</kbd>, and <kbd>get size</kbd> are the typical operations that are allowed on stack data structures. Syntax parsing, backtracking, and compiling time memory management are some real-life scenarios where stacks can be used. An example of stack implementation is as follows (<kbd>stack.go</kbd>):</p>
<pre class="mce-root">//main package has examples shown<br/>// in Hands-On Data Structures and algorithms with Go book<br/>package main<br/>// importing fmt package<br/>import (<br/> "fmt"<br/> "strconv"<br/>)<br/>//Element class<br/>type Element struct {<br/> elementValue int<br/>}<br/>// String method on Element class<br/>func (element *Element) String() string {<br/> return strconv.Itoa(element.elementValue)<br/>}</pre>
<p>The <kbd>Element</kbd> class has <kbd>elementValue</kbd> as an attribute. The <kbd>String</kbd> method returns the element's <kbd>elementValue</kbd>.</p>
<p>Stacks methods, such as <kbd>New</kbd>, <kbd>Push</kbd>, <kbd>Pop</kbd>, and <kbd>main</kbd> are presented in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The New method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>New</kbd> method on the <kbd>Stack</kbd> class creates a dynamic array of elements. The <kbd>Stack</kbd> class has the count and array pointer of elements. The code snippet with the <kbd>Stack</kbd> class definition and the <kbd>New</kbd> method is as follows:</p>
<pre class="mce-root">// NewStack returns a new stack.<br/>func (stack *Stack) New() {<br/> stack.elements = make(*Element[] elements,0)<br/>}<br/>// Stack is a basic LIFO stack that resizes as needed.<br/>type Stack struct {<br/> elements []*Element<br/> elementCount int<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Push method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Push</kbd> method adds the node to the top of the <kbd>stack</kbd> class. In the following code sample, the <kbd>Push</kbd> method on the <kbd>Stack</kbd> class adds the element to the elements array and increases the <kbd>Count</kbd> element, while the <kbd>append</kbd> method adds the element to the elements of the <kbd>stack</kbd> class:</p>
<pre class="mce-root">// Push adds a node to the stack.<br/>func (stack *Stack) Push(element *Element) {<br/> stack.elements = append(stack.elements[:stack.elementCount], element)<br/> stack.elementCount = stack.elementCount + 1<br/>}</pre>
<p class="mce-root"/>
<p>The example output after the push method is invoked with parameter elements as follows. The element with the value <span class="packt_screen">7</span> is pushed to the stack. The count of the elements before pushing to the stack is <span class="packt_screen">2</span>, and, after pushing to the stack, this figure is <span class="packt_screen">3</span><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f214116d-8e1b-485b-9ef1-8b9ab6164ea4.png" style="width:31.83em;height:3.58em;" width="448" height="50"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at the <kbd>Pop</kbd> method in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Pop method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Pop</kbd> method on the <kbd>Stack</kbd> implementation removes the last element from the element array and returns the element, as shown in the following code. The <kbd>len</kbd> method returns the length of the elements array:</p>
<pre class="mce-root">// Pop removes and returns a node from the stack in last to first order.<br/>func (stack *Stack) Pop() *Element {<br/> if stack.elementCount == 0 {<br/> return nil<br/> }<br/> var length int = len(stack.elements)<br/> var element *Element = stack.elements[length -1]<br/> //stack.elementCount = stack.elementCount - 1<br/> if length &gt; 1 {<br/> stack.elements = stack.elements[:length-1]<br/> } else {<br/> stack.elements = stack.elements[0:]<br/> }<br/> stack.elementCount = len(stack.elements)<br/> return element<br/>}</pre>
<p>The example output after the <kbd>Pop</kbd> method is invoked is as follows. The element value <span class="packt_screen">5</span> is passed and added to the <kbd>Pop</kbd> method. The count of elements before invoking the <kbd>Pop</kbd> method is <span class="packt_screen">2</span>. The count of the elements after calling the <kbd>Pop</kbd> method is <span class="packt_screen">1</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/01c29a22-a9a8-4956-9d24-50c44436658a.png" style="width:30.67em;height:3.42em;" width="449" height="50"/></p>
<p class="CDPAlignLeft CDPAlign"><span>Let's take a look at the <kbd>main</kbd> method in the next section.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code section, the <kbd>main</kbd> method creates a <kbd>stack</kbd>, calls the <kbd>New</kbd> method, and pushes the elements after initializing them. The popped-out element value and the order is printed:</p>
<pre class="mce-root">// main method<br/>func main() {<br/> var stack *Stack = &amp; Stack{}<br/> stack.New()<br/> var element1 *Element = &amp;Element{3}<br/> var element2 *Element = &amp;Element{5}<br/> var element3 *Element = &amp;Element{7}<br/> var element4 *Element = &amp;Element{9}<br/> stack.Push(element1)<br/> stack.Push(element2)<br/> stack.Push(element3)<br/> stack.Push(element4)<br/> fmt.Println(stack.Pop(), stack.Pop(), stack.Pop(), stack.Pop())<br/>}</pre>
<p class="p1"><span class="s1">Run the following commands <span>to execute the <kbd>stack.go</kbd> file</span>:</span></p>
<pre class="mce-root"><strong>go run stack.go</strong></pre>
<p class="mce-root"><span>After executing the preceding command, we get the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/cd05e596-7e16-405a-a158-95dc1fde40d5.png" style="width:32.42em;height:5.33em;" width="906" height="148"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter covered the definition of <kbd>LinkedList</kbd>, double <kbd>LinkedList</kbd>, <kbd>Tuples</kbd>, <kbd>Sets</kbd>, <kbd>Queues</kbd>, and <kbd>Stacks</kbd>. The <kbd>LinkedList</kbd> methods – <kbd>AddToHead</kbd>, <kbd>AddToEnd</kbd>, <kbd>LastNode</kbd>, and <kbd>iterateList</kbd>—were also covered in this chapter. In addition, a priority queue was modeled as a heap of orders to be processed, sync queue was presented as passenger and ticket processing queues, and tuples were explained in a context in which a function returns a multivalued expression. The <kbd>new</kbd>, <kbd>push</kbd>, <kbd>pop</kbd>, and <kbd>string</kbd> methods for <kbd>Stack</kbd> were explained with code samples.</p>
<p class="mce-root"/>
<p>In the next chapter, we will cover areas such as the <kbd>Trees</kbd>, <kbd>Tables</kbd>, <kbd>Containers</kbd>, and <kbd>Hash</kbd> functions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Where can you use double linked list? Please provide an example.</li>
<li class="mce-root">Which method on linked list can be used for printing out node values?</li>
<li class="mce-root">Which queue was shown with channels from the Go language?</li>
<li class="mce-root">Write a method that returns multiple values. What data structure can be used for returning multiple values?</li>
<li class="mce-root">Can set have duplicate elements?</li>
<li class="mce-root"><span><span>Write a code</span></span> sample showing the union and intersection of two sets.</li>
<li class="mce-root">In a linked list, which method is used to find the node between two values?</li>
<li class="mce-root">We have elements that are not repeated and unique. What is the correct data structure that represents the collection?</li>
<li class="mce-root">In Go, how do you generate a random integer between the values 3 and 5?</li>
<li class="mce-root">Which method is called to check if an element of value 5 exists in the Set?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">To read more about <kbd>LinkedLists</kbd>, <kbd>Sets</kbd>, <kbd>Tuples</kbd>, and <kbd>Stacks</kbd>, consult the following sources:</span></p>
<ul>
<li><em>Design Patterns</em>, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides</li>
<li><em>Introduction to Algorithms – Thi<span>rd Edition</span></em>, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein</li>
<li><em>Data structures and Algorithms: An Easy Introduction</em>, by Rudolph Russell</li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>