["```go\n//Node class\ntype Node struct {\n    property int\n    nextNode *Node\n}\n```", "```go\n// LinkedList class\ntype LinkedList struct {\n    headNode *Node\n}\n```", "```go\n//AddToHead method of LinkedList class\nfunc (linkedList *LinkedList) AddToHead(property int) {\n    var node = Node{}\n    node.property = property\n    if node.nextNode != nil {\n        node.nextNode = linkedList.headNode\n    }\n    linkedList.headNode = &node\n}\n```", "```go\n// main method\nfunc main() {\n    var linkedList LinkedList\n    linkedList = LinkedList{}\n    linkedList.AddToHead(1)\n    linkedList.AddToHead(3)\n    fmt.Println(linkedList.headNode.property)\n}\n```", "```go\ngo run linked_list.go\n```", "```go\n//IterateList method iterates over LinkedList\nfunc (linkedList *LinkedList) IterateList() {\n    var node *Node\n    for node = linkedList.headNode; node != nil; node = node.nextNode {\n        fmt.Println(node.property)\n    }\n}\n```", "```go\n//LastNode method returns the last Node\n\nfunc (linkedList *LinkedList) LastNode() *Node{\n var node *Node\n var lastNode *Node\n for node = linkedList.headNode; node != nil; node = node.nextNode {\n if node.nextNode ==nil {\n lastNode = node\n }\n }\n return lastNode\n}\n```", "```go\n//AddToEnd method adds the node with property to the end\n\nfunc (linkedList *LinkedList) AddToEnd(property int) {\n var node = &Node{}\n node.property = property\n node.nextNode = nil\n var lastNode *Node\n lastNode = linkedList.LastNode()\n if lastNode != nil {\n lastNode.nextNode = node\n }\n}\n```", "```go\n//NodeWithValue method returns Node given parameter property\n\nfunc (linkedList *LinkedList) NodeWithValue(property int) *Node{\n var node *Node\n var nodeWith *Node\n for node = linkedList.headNode; node != nil; node = node.nextNode {\n if node.property == property {\n nodeWith = node\n break;\n }\n }\n return nodeWith\n}\n```", "```go\n//AddAfter method adds a node with nodeProperty after node with property\n\nfunc (linkedList *LinkedList) AddAfter(nodeProperty int,property int) {\n var node = &Node{}\n node.property = property\n node.nextNode = nil\n var nodeWith *Node\n nodeWith = linkedList.NodeWithValue(nodeProperty)\n if nodeWith != nil {\n node.nextNode = nodeWith.nextNode\n nodeWith.nextNode = node\n }\n}\n```", "```go\n// main method\nfunc main() {\n    var linkedList LinkedList\n    linkedList = LinkedList{}\n    linkedList.AddToHead(1)\n    linkedList.AddToHead(3)\n    linkedList.AddToEnd(5)\n    linkedList.AddAfter(1,7)\n    linkedList.IterateList()\n}\n```", "```go\ngo run linked_list.go\n```", "```go\n// Node class\ntype Node struct {\n    property int\n    nextNode *Node\n    previousNode *Node\n}\n```", "```go\n//NodeBetweenValues method of LinkedList\nfunc (linkedList *LinkedList) NodeBetweenValues(firstProperty int,secondProperty int) *Node{\n    var node *Node\n    var nodeWith *Node\n    for node = linkedList.headNode; node != nil; node = node.nextNode {\n        if node.previousNode != nil && node.nextNode != nil {\n            if node.previousNode.property == firstProperty && node.nextNode.property ==    \n            secondProperty{\n               nodeWith = node\n               break;\n            }\n        }\n    }\n    return nodeWith\n}\n```", "```go\n//AddToHead method of LinkedList\nfunc (linkedList *LinkedList) AddToHead(property int) {\n var node = &Node{}\n node.property = property\n node.nextNode = nil\n if linkedList.headNode != nil {\n node.nextNode = linkedList.headNode\n linkedList.headNode.previousNode = node\n }\n linkedList.headNode = node\n}\n```", "```go\n//AddAfter method of LinkedList\nfunc (linkedList *LinkedList) AddAfter(nodeProperty int,property int) {\n var node = &Node{}\n node.property = property\n node.nextNode = nil\n var nodeWith *Node\n nodeWith = linkedList.NodeWithValue(nodeProperty)\n if nodeWith != nil {\n\n node.nextNode = nodeWith.nextNode\n node.previousNode = nodeWith\n nodeWith.nextNode = node\n }\n}\n```", "```go\n//AddToEnd method of LinkedList\nfunc (linkedList *LinkedList) AddToEnd(property int) {\n var node = &Node{}\n node.property = property\n node.nextNode = nil\n var lastNode *Node\n lastNode = linkedList.LastNode()\n if lastNode != nil {\n\n lastNode.nextNode = node\n node.previousNode = lastNode\n }\n}\n```", "```go\n// main method\nfunc main() {\n var linkedList LinkedList\n linkedList = LinkedList{}\n linkedList.AddToHead(1)\n linkedList.AddToHead(3) linkedList.AddToEnd(5)\n linkedList.AddAfter(1,7)\n fmt.Println(linkedList.headNode.property)\n var node *Node\n node = linkedList.NodeBetweenValues(1,5)\n fmt.Println(node.property)\n}\n```", "```go\ngo run doubly_linked_list.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n)\n//Set class\ntype Set struct {\n integerMap map[int]bool\n}\n//create the map of integer and bool\nfunc (set *Set) New(){\n set.integerMap = make(map[int]bool)\n}\n```", "```go\n// adds the element to the set\nfunc (set *Set) AddElement(element int){\n if !set.ContainsElement(element) {\n  set.integerMap[element] = true\n }\n}\n```", "```go\n//deletes the element from the set\nfunc (set *Set) DeleteElement(element int) {\n    delete(set.integerMap,element)\n}\n```", "```go\n\n//checks if element is in the set\nfunc (set *Set) ContainsElement(element int) bool{\n var exists bool\n _, exists = set.integerMap[element]\n return exists\n}\n```", "```go\n// main method\nfunc main() {\n    var set *Set\n    set = &Set{}\n    set.New()\n    set.AddElement(1)\n    set.AddElement(2)\n    fmt.Println(set)\n    fmt.Println(set.ContainsElement(1))\n}\n```", "```go\ngo run set.go\n```", "```go\n//Intersect method returns the set which intersects with anotherSet\n\nfunc (set *Set) Intersect(anotherSet *Set) *Set{\n var intersectSet = & Set{}\n intersectSet.New()\n var value int\n for(value,_ = range set.integerMap){\n   if anotherSet.ContainsElement(value) {\n    intersectSet.AddElement(value)\n   }\n }\n return intersectSet \n}\n```", "```go\n//Union method returns the set which is union of the set with anotherSet\n\nfunc (set *Set) Union(anotherSet *Set) *Set{\n var unionSet = & Set{}\n unionSet.New()\n var value int\n for(value,_ = range set.integerMap){\n   unionSet.AddElement(value)\n }\n\n for(value,_ = range anotherSet.integerMap){\n   unionSet.AddElement(value)\n }\n\n return unionSet \n}\n```", "```go\n// main method\nfunc main() {\n var set *Set\n set = &Set{}\n set.New()\n set.AddElement(1)\n set.AddElement(2)\n fmt.Println(\"initial set\", set)\n fmt.Println(set.ContainsElement(1))\n var anotherSet *Set\n anotherSet = &Set{}\n anotherSet.New()\n anotherSet.AddElement(2)\n anotherSet.AddElement(4)\n anotherSet.AddElement(5) fmt.Println(set.Intersect(anotherSet))\n fmt.Println(set.Union(anotherSet))\n}\n```", "```go\ngo run set.go\n```", "```go\n//main package has examples shown\n // in Hands-On Data Structures and algorithms with Go book\n package main\n // importing fmt package\n import (\n \"fmt\"\n )\n //h function which returns the product of parameters x and y\n func h(x int, y int) int {\n return x*y\n }\n // g function which returns x and y parameters after modification\n func g(l int, m int) (x int, y int) {\n x=2*l\n y=4*m\n return\n }\n // main method\n func main() {\n fmt.Println(h(g()))\n }\n```", "```go\ngo run tuples.go\n```", "```go\n// Queueâ€”Array of Orders Type\ntype Queue []*Order\n\n// Order class\ntype Order struct {\n    priority int\n    quantity int\n    product string\n    customerName string\n}\n```", "```go\n// New method initializes with Order with priority, quantity, product, customerName\nfunc (order *Order) New(priority int, quantity int, product string, customerName string ){\n order.priority = priority\n order.quantity = quantity\n order.product = product\n order.customerName = customerName\n }\n```", "```go\n//Add method adds the order to the queue\nfunc (queue *Queue) Add(order *Order){\n if len(*queue) == 0 {\n *queue = append(*queue,order)\n } else{\n var appended bool\n appended = false\n var i int\n var addedOrder *Order\n for i, addedOrder = range *queue {\n if order.priority > addedOrder.priority {\n *queue = append((*queue)[:i], append(Queue{order}, (*queue)[i:]...)...)\n appended = true\n break\n }\n }\n if !appended {\n *queue = append(*queue, order)\n }\n }\n}\n```", "```go\n\n// main method\nfunc main() {\n var queue Queue\n queue = make(Queue,0)\n var order1 *Order = &Order{}\n var priority1 int = 2\n var quantity1 int = 20\n var product1 string = \"Computer\"\n var customerName1 string = \"Greg White\"\n order1.New(priority1,quantity1,product1, customerName1)\n var order2 *Order = &Order{}\n var priority2 int = 1\n var quantity2 int = 10\n var product2 string = \"Monitor\"\n var customerName2 string = \"John Smith\"\n order2.New(priority2,quantity2,product2, customerName2)\n queue.Add(order1)\n\n queue.Add(order2)\nvar i int\nfor i=0; i< len(queue); i++ {\nfmt.Println(queue[i])\n}\n}\n```", "```go\ngo run queue.go\n```", "```go\n\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n \"time\"\n \"math/rand\"\n)\n// constants\nconst (\n messagePassStart = iota\n messageTicketStart\n messagePassEnd\n messageTicketEnd\n)\n//Queue class\ntype Queue struct {\n waitPass int\n waitTicket int\n playPass bool\n playTicket bool\n queuePass chan int\n queueTicket chan int\n message chan int\n}\n```", "```go\n// New method initializes queue\nfunc (queue *Queue) New() {\n queue.message = make(chan int)\n queue.queuePass= make(chan int)\n queue.queueTicket= make(chan int)\n }\n```", "```go\ngo func() {\n var message int\n for {\n select {\n case message = <-queue.message:\n switch message {\n case messagePassStart:\n queue.waitPass++\n case messagePassEnd:\n queue.playPass = false\n case messageTicketStart:\n queue.waitTicket++\n case messageTicketEnd:\n queue.playTicket = false\n }\n if queue.waitPass > 0 && queue.waitTicket > 0 && !queue.playPass && !queue.playTicket {\n queue.playPass = true\n queue.playTicket = true\n queue.waitTicket--\n queue.waitPass--\n queue.queuePass <- 1\n queue.queueTicket <- 1\n }\n }\n }\n }()\n}\n```", "```go\n// StartTicketIssue starts the ticket issue\nfunc (Queue *Queue) StartTicketIssue() {\n Queue.message <- messageTicketStart\n <-Queue.queueTicket\n}\n```", "```go\n// EndTicketIssue ends the ticket issue\nfunc (Queue *Queue) EndTicketIssue() {\n Queue.message <- messageTicketEnd\n}\n```", "```go\n//ticketIssue starts and ends the ticket issue\nfunc ticketIssue(Queue *Queue) {\n for {\n // Sleep up to 10 seconds.\n time.Sleep(time.Duration(rand.Intn(10000)) * time.Millisecond)\n Queue.StartTicketIssue()\n fmt.Println(\"Ticket Issue starts\")\n // Sleep up to 2 seconds.\n time.Sleep(time.Duration(rand.Intn(2000)) * time.Millisecond)\n fmt.Println(\"Ticket Issue ends\")\n Queue.EndTicketIssue()\n }\n}\n```", "```go\n//StartPass ends the Pass Queue\nfunc (Queue *Queue) StartPass() {\n    Queue.message <- messagePassStart\n    <-Queue.queuePass\n}\n```", "```go\n//EndPass ends the Pass Queue\nfunc (Queue *Queue) EndPass() {\n    Queue.message <- messagePassEnd\n}\n```", "```go\n//passenger method starts and ends the pass Queue\nfunc passenger(Queue *Queue) {\n //fmt.Println(\"starting the passenger Queue\")\n for {\n // fmt.Println(\"starting the processing\")\n // Sleep up to 10 seconds.\n time.Sleep(time.Duration(rand.Intn(10000)) * time.Millisecond)\n Queue.StartPass()\n fmt.Println(\" Passenger starts\")\n // Sleep up to 2 seconds.\n time.Sleep(time.Duration(rand.Intn(2000)) * time.Millisecond)\n fmt.Println( \" Passenger ends\")\n Queue.EndPass()\n }\n}\n```", "```go\n// main method\nfunc main() {\n var Queue *Queue = & Queue{}\n //fmt.Println(Queue)\n Queue.New()\n fmt.Println(Queue)\n var i int\n for i = 0; i < 10; i++ {\n // fmt.Println(i, \"passenger in the Queue\")\n go passenger(Queue)\n }\n //close(Queue.queuePass)\n var j int\n for j = 0; j < 5; j++ {\n // fmt.Println(i, \"ticket issued in the Queue\")\n go ticketIssue(Queue)\n }\n select {}\n}\n```", "```go\ngo run sync_queue.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing fmt package\nimport (\n \"fmt\"\n \"strconv\"\n)\n//Element class\ntype Element struct {\n elementValue int\n}\n// String method on Element class\nfunc (element *Element) String() string {\n return strconv.Itoa(element.elementValue)\n}\n```", "```go\n// NewStack returns a new stack.\nfunc (stack *Stack) New() {\n stack.elements = make(*Element[] elements,0)\n}\n// Stack is a basic LIFO stack that resizes as needed.\ntype Stack struct {\n elements []*Element\n elementCount int\n}\n```", "```go\n// Push adds a node to the stack.\nfunc (stack *Stack) Push(element *Element) {\n stack.elements = append(stack.elements[:stack.elementCount], element)\n stack.elementCount = stack.elementCount + 1\n}\n```", "```go\n// Pop removes and returns a node from the stack in last to first order.\nfunc (stack *Stack) Pop() *Element {\n if stack.elementCount == 0 {\n return nil\n }\n var length int = len(stack.elements)\n var element *Element = stack.elements[length -1]\n //stack.elementCount = stack.elementCount - 1\n if length > 1 {\n stack.elements = stack.elements[:length-1]\n } else {\n stack.elements = stack.elements[0:]\n }\n stack.elementCount = len(stack.elements)\n return element\n}\n```", "```go\n// main method\nfunc main() {\n var stack *Stack = & Stack{}\n stack.New()\n var element1 *Element = &Element{3}\n var element2 *Element = &Element{5}\n var element3 *Element = &Element{7}\n var element4 *Element = &Element{9}\n stack.Push(element1)\n stack.Push(element2)\n stack.Push(element3)\n stack.Push(element4)\n fmt.Println(stack.Pop(), stack.Pop(), stack.Pop(), stack.Pop())\n}\n```", "```go\ngo run stack.go\n```"]