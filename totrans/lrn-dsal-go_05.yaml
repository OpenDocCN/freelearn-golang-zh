- en: Linear Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Various applications, such as Facebook, Twitter, and Google, use lists and linear
    data structures. As we have discussed previously, data structures allow us to
    organize vast swathes of data in a sequential and organized manner, thereby reducing
    time and effort in working with such data. Lists, stacks, sets, and tuples are
    some of the commonly used linear data structures.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss these data structures by giving examples of
    various procedures involving them. We will discuss the various operations related
    to these data structures, such as insertion, deletion, updating, traversing (of
    lists), reversing, and merging with various code samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following linear data structures in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install Go version 1.10 at [https://golang.org/doc/install](https://golang.org/doc/install),
    depending on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at the following GitHub URL: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter03](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A list is a collection of ordered elements that are used to store list of items. Unlike
    array lists, these can expand and shrink dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Lists also be used as a base for other data structures, such as stack and queue. Lists
    can be used to store lists of users, car parts, ingredients, to-do items, and
    various other such elements. Lists are the most commonly used linear data structures. These
    were introduced in the lisp programming language. In this chapter, linked list
    and doubly linked list are the lists we will cover in the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the operations related to add, update, remove, and lookup on linked
    list and doubly linked list in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LinkedList` is a sequence of nodes that have properties and a reference to
    the next node in the sequence. It is a linear data structure that is used to store
    data. The data structure permits the addition and deletion of components from
    any node next to another node. They are not stored contiguously in memory, which
    makes them different arrays**.**'
  prefs: []
  type: TYPE_NORMAL
- en: The following sections will look at the structures and methods in a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: The Node class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Node` class has an integer typed variable with the name `property`. The
    class has another variable with the name `nextNode`, which is a node pointer.
    Linked list will have a set of nodes with integer properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The LinkedList class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LinkedList` class has the `headNode` pointer as its property. By traversing
    to `nextNode` from `headNode`, you can iterate through the linked list, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The different methods of the `LinkedList` class, such as `AddtoHead`, `IterateList`,
    `LastNode`, `AddtoEnd`, `NodeWithValue`, `AddAfter`, and the `main` method, are
    discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The AddToHead method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AddToHead` method adds the node to the start of the linked list. The `AddToHead` method of
    the `LinkedList` class has a parameter integer property. The property is used
    to initialize the node. A new node is instantiated and its property is set to
    the `property` parameter that''s passed. The `nextNode` points to the current
    `headNode` of `linkedList`, and `headNode` is set to the pointer of the new node
    that''s created, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the node with the `1` property is added to the head, adding the `1` property
    to the head of `linkedList` sets `headNode` to `currentNode` with a value of `1`,
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad748616-2e91-4121-a91a-5c3b9ba06066.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s execute this command using the `main` method. Here, we have created
    an instance of a `LinkedList` class and added the `1` and `3` integer properties
    to the head of this instance. The linked list''s `headNode` property is printed
    after adding the elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands to execute the `linked_list.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a3f103f-e736-4475-a7ca-56583342dcae.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `IterateList` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The IterateList method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `IterateList` method of the `LinkedList` class iterates from the `headNode` property
    and prints the property of the current head node. The iteration happens with the
    head node moves to `nextNode` of the `headNode` property until the current node
    is no longer equal to `nil`. The following code shows the `IterateList` method
    of the `LinkedList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The LastNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LastNode` method of `LinkedList` returns the node at the end of the list.
    The list is traversed to check whether `nextNode` is `nil` from `nextNode` of `headNode`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The AddToEnd method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AddToEnd` method adds the node at the end of the list. In the following
    code, the current `lastNode` is found and its `nextNode` property is set as the
    added node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, the `AddToEnd` method is invoked when the node
    with a property value of 5 is added to the end. Adding the property through this
    method creates a node with a value of 5\. The last node of the list has a property
    value of 5\. The `nextNode` property of `lastNode` is `nil`. The `nextNode` of `lastNode`
    is set to the node with a value of 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8bf773f-ae86-4ec4-8079-eab1b05c1ed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `NodeWithValue` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The NodeWithValue method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `NodeWithValue` method of `LinkedList` returns
    the node with the `property` value. The list is traversed and checked to see whether
    the `property` value is equal to the parameter property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The AddAfter method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AddAfter` method adds the node after a specific node. The `AddAfter` method
    of `LinkedList` has `nodeProperty` and `property` parameters. A node with the `nodeProperty` value
    is retrieved using the `NodeWithValue` method. A node with `property` is created
    and added after the `NodeWith` node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You then get the following output when the `AddAfter` method is invoked when
    the node with a property value of 7 is added after the node with a value of 1. The
    `nextNode` property of the node with a property value of 1 is nil. The `nextNode` property
    of the node with a property value of 1 is set to the node with a value of 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4702e546-c068-42ff-9d31-9b1814410e73.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `main` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method adds the nodes with integer properties of `1`, `3`, and `5`,
    as shown in the following code. A node with an integer property of `7` is added
    after the node with an integer property of `1`. The `IterateList` method is invoked
    on the `linkedList` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The main method adds `1` and `3` to the head of the linked list. `5` is added
    to the end. `7` is added after `1`. The linked list will be `3`, `1`, `7`, and `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to execute the `linked_list.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81213159-77ca-4f5d-bcda-3822916087df.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at doubly linked list in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a doubly linked list, all nodes have a pointer to the node they are connected
    to, on either side of them, in the list. This means that each node is connected
    to two nodes, and we can traverse forward through to the next node or backward
    through to the previous node. Doubly linked lists allow insertion, deletion and,
    obviously, traversing operations. The node class definition is presented in the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The following sections explain doubly linked list methods, such as the `NodeBetweenValues`,
    `AddToHead`, `AddAfter`, `AddToEnd`, and `main` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The NodeBetweenValues method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NodeBetweenValues` method of the `LinkedList` class returns the node that
    has a property lying between the `firstProperty` and `secondProperty` values.
    The method traverses the list to find out whether the `firstProperty` and `secondProperty`
    integer properties match on consecutive nodes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after the node between the values method was invoked with
    1 and 5 is shown in the following screenshot. The `nextNode` of the `lastNode`
    is set to the node with a value of 5\. The node with a property value of 7 is
    between the nodes with property values of 1 and 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0578a2b-1158-44d6-b779-2b695aaf820c.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `AddToHead` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The AddToHead method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AddToHead` method of the doubly `LinkedList` class sets the `previousNode` property
    of the current `headNode` of the linked list to the node that''s added with property.
    The node with property will be set as the `headNode` of the `LinkedList` method
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after the  `AddToHead` method was invoked with property
    3 is as follows. A node with property 3 is created. The `headNode` property of
    the list has a property value of 1\. The current node with property 3 has a `nextNode` property
    of nil. The `nextNode` property of the current node is set to `headNode` with
    a property value of 1\. The previous node of the `headNode` property is set to
    the current node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4ca7f7f-d7b2-4cc0-9592-f8a6efca6f9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `AddAfter` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: AddAfter method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AddAfter` method adds a node after a specific node to a double linked
    list. The `AddAfter` method of the double `LinkedList` class searches the node
    whose value is equal to `nodeProperty`. The found node is set as the `previousNode`
    of the node that was added with property. The `nextNode` of the added node will
    be the `nodeWith` property''s `nextNode`. The `previousNode` of the added node
    will be the node that was found with value equal to `nodeProperty`. The `nodeWith` node
    will be updated to the current node. In the following code, the `AddAfter` method
    is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after the `AddAfter` method is invoked with property 7 is
    as follows. A node with property value 7 is created. The `nextNode` property of
    the created node is `nil`. The `nextNode` property of the created node is set
    to `headNode` with property value 1\. The `previousNode` property of `headNode`
    is set to the current node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a2834b3-fbf4-4858-acf6-5446b5d16e41.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `AddToEnd` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The AddToEnd method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AddToEnd` method adds the node to the end of the double linked list. The
    `AddToEnd` method of the `LinkedList` class creates a node whose property is set
    as the integer parameter property. The method sets the `previousNode` property
    of the node that was added with the current `lastNode` property as follows. The
    `nextNode` of the current `lastNode` property is set to a node added with property
    at the end as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after the `AddToEnd` method was invoked with property 5
    is as follows. A node with property value 5 is created. The `lastNode` of the
    list has property value 1\. The `nextNode` property of the `lastNode` is `nil`.
    The `nextNode` of the `lastNode` is set to the node with property value 5\. The
    `previousNode` of the created node is set to the node with property value 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/597173b4-caf3-48f3-b369-c29569362ae9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `main` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `main` method calls the `NodeBetweenValues` property
    with `firstProperty` and `secondProperty`. The node property between values `1`
    and `5` is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `main` method creates a linked list. The nodes are added to the head and
    end. The node between values `1` and `5` is searched and its property is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to execute the `doubly_linked_list.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/617c65dd-924b-4aa7-b9d1-9d51d4688881.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about sets, which are linear data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Set is a linear data structure that has a collection of values that are not
    repeated. A set can store unique values without any particular order. In the real
    world, sets can be used to collect all tags for blog posts and conversation participants
    in a chat. The data can be of Boolean, integer, float, characters, and other types.
    Static sets allow only query operations, which means operations related to querying
    the elements. Dynamic and mutable sets allow for the insertion and deletion of
    elements. Algebraic operations such as union, intersection, difference, and subset
    can be defined on the sets. The following example shows the `Set` integer with
    a `map` integer key and `bool` as a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `AddElement`, `DeleteElement`, `ContainsElement`, `Intersect`, `Union`,
    and `main` methods are discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The AddElement method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AddElement` method adds the element to a set. In the following code snippet,
    the `AddElement` method of the `Set` class adds the element to `integerMap` if
    the element is not in the `Set`. The `integerMap` element has the key integer
    and value as `bool`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after invoking the `AddElement` method with parameter 2
    is as follows. The check is done if there is an element with value 2\. If there
    is no element, the map is set to true with the key as 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bcb8123-4485-46d5-ae6d-19d96a269670.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `DeleteElement` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The DeleteElement method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DeleteElement` method deletes the element from `integerMap` using the
    `delete` method. This method removes the element from the `integerMap` of the
    set, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The ContainsElement method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ContainsElement` method of the `Set` class checks whether or not the element
    exists in `integerMap`. The `integerMap` element is looked up with a key integer
    element, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The main method – contains element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `main` method creates `Set`, invokes the
    `New` method, and adds elements `1` and `2`. The check is done if element `1`
    exists in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `set.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18bc1ab4-a4a8-4ad1-9f49-cd5ac47960af.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `InterSect` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The InterSect method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, the `InterSect` method on the `Set` class returns an
    `intersectionSet` that consists of the intersection of `set` and `anotherSet`.
    The `set` class is traversed through `integerMap` and checked against another
    `Set` to see if any elements exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after invoking the intersect with the parameter of another
    `Set` is as follows. A new `intersectSet` is created. The current `set` is iterated
    and every value is checked to see if it is in another `set`. If the value is in
    another `set`, it is added to the `set` intersect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38334219-8c06-41f4-925d-4eee31e865fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `Union` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Union method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Union` method on the `Set` class returns a `unionSet` that consists of
    a union of `set` and `anotherSet`. Both sets are traversed through `integerMap`
    keys, and union set is updated with elements from the sets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after invoking the union method with the `anotherSet` parameter
    is as follows. A new `unionSet` is created. The current set and another set values
    are iterated. Every value is added to the union set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c1db8a4-701e-41c8-b595-8dc16d738359.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `main` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The main method – intersection and union
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `main` method calls intersect and union
    on the set class, passing the `anotherSet` parameter. The intersection and union
    sets are printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The main method takes two sets and finds the intersection and union of the sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to execute the `set.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67d39427-fa0f-4e9c-9384-6085685b886e.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about tuples, which are finite ordered sequences of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples are finite ordered sequences of objects. They can contain a mixture
    of other data types and are used to group related data into a data structure.
    In a relational database, a tuple is a row of a table. Tuples have a fixed size
    compared to lists, and are also faster. A finite set of tuples in the relational
    database is referred to as a relation instance. A tuple can be assigned in a single
    statement, which is useful for swapping values. Lists usually contain values of
    the same data type, while tuples contain different data. For example, we can store
    a name, age, and favorite color of a user in a tuple. Tuples were covered in [Chapter
    1](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml), *Data Structures and Algorithms*.
    The following sample shows a multi-valued expression from a function''s call (`tuples.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function calls the `h` function with the `g` function as its parameter.
    The `g` function returns the  tuple `x` and `y` integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to execute the `tuples.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72656d18-fa9a-403d-b244-8e1e12df1e35.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about queues, which are linear data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A queue consists of elements to be processed in a particular order or based
    on priority. A priority-based queue of orders is shown in the following code,
    structured as a heap. Operations such as enqueue, dequeue, and peek can be performed
    on queue. A queue is a linear data structure and a sequential collection. Elements
    are added to the end and are removed from the start of the collection. Queues
    are commonly used for storing tasks that need to be done, or incoming HTTP requests
    that need to be processed by a server. In real life, handling interruptions in
    real-time systems, call handling, and CPU task scheduling are good examples for
    using queues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the queue of Orders and how the `Queue` type is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The following sections in the chapter discuss the `New`, `Add`, and `main` methods
    of queue.
  prefs: []
  type: TYPE_NORMAL
- en: The New method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `New` method on the `Order` class assigns the properties from the `priority`,
    `quantity`, and `product` parameters for name and `customerName`. The method initializes
    the properties of the order as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The Add method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `Add` method on the `Queue` class takes
    the `order` parameter and adds it to `Queue` based on the priority. Based on this,
    the location of the `order` parameter is found by comparing it with the `priority` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after the `add` method is invoked with the order parameter
    is as follows. The order is checked to see whether or not it exists in the queue.
    The order is then appended to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72844ffd-21b2-4ccf-a3de-bd20028220dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the Main method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The main method – queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method creates two orders, and the priority of the orders is set
    to `2` and `1`. In the following code, the queue will first process the order
    with the higher number on the priority value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands to execute the `queue.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af04ddad-2f0f-4ae8-9923-47f53957c4ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at *Synchronized queue* in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronized queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A synchronized queue consists of elements that need to be processed in a particular
    sequence. Passenger queue and ticket processing queues are types of synchronized queues,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss the different methods of synchronized queue in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The New method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `New` method on `Queue` initializes `message`, `queuePass`, and `queueTicket`
    with `nil` values. The `make` method creates a `Queue` with a `chan` integer parameter, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code example, the `Go` routine handles selecting the message
    based on the type of message and the respective queue to process it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The StartTicketIssue method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StartTicketIssue` method starts the issuing of a ticket for passengers
    standing in a queue. The `StartTicketIssue` method on `Queue` sends `messageTicketStart`
    to the message queue and `queueTicket` receives the message. The ticket issue
    is started by sending messages to the queue, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The EndTicketIssue method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EndTicketIssue` method finishes the issuing of a ticket to a passenger
    standing in the queue. In the following code, the `EndTicketIssue` method on `Queue`
    sends `messageTicketEnd` to the message queue. The ticket issue is ended by sending
    the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The ticketIssue method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ticketIssue` method starts and finishes the issuing of a ticket to the
    passenger. The `ticketIssue` method invokes the `StartTicketIssue` and `EndTicketIssue` methods
    after `Sleep` calls for 10 seconds and two seconds. The ticket is issued after
    the ticket is processed, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The StartPass method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StartPass` method starts the passenger queue moving toward the ticket
    counter. The `StartPass` method on `Queue` sends `messagePassStart` to the message
    queue and `queuePass` receives the message. Passengers are moved into the queue
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The EndPass method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EndPass` method stops the passenger queue moving toward the ticket counter.
    The `EndPass` method on `Queue` sends `messagePassEnd` to the message queue in
    the following code. The passenger is moved to the counter for ticket processing,
    and the passenger is then out of the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The passenger method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `passenger` methods starts and ends passenger movement to the queue. The
    `passenger` method invokes the `StartPass` method, and the `EndPass` method ends
    after sleep calls for 10 seconds and two seconds. The passenger moves into the
    queue and reaches the ticket counter, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method calls the `passenger` and `ticketIssue` methods after creating
    a queue. The passenger enters into the queue and a ticket is issued at the counter
    in the processing queue, as explained in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `sync_queue.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31ab2f30-3205-462c-acb7-d7ec21c7b32d.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about `Stacks`, which are linear data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A stack is a last in, first out structure in which items are added from the
    top. Stacks are used in parsers for solving maze algorithms. `Push`, `pop`, `top`,
    and `get size` are the typical operations that are allowed on stack data structures.
    Syntax parsing, backtracking, and compiling time memory management are some real-life
    scenarios where stacks can be used. An example of stack implementation is as follows
    (`stack.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `Element` class has `elementValue` as an attribute. The `String` method
    returns the element's `elementValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks methods, such as `New`, `Push`, `Pop`, and `main` are presented in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The New method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `New` method on the `Stack` class creates a dynamic array of elements.
    The `Stack` class has the count and array pointer of elements. The code snippet
    with the `Stack` class definition and the `New` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The Push method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Push` method adds the node to the top of the `stack` class. In the following
    code sample, the `Push` method on the `Stack` class adds the element to the elements
    array and increases the `Count` element, while the `append` method adds the element
    to the elements of the `stack` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after the push method is invoked with parameter elements
    as follows. The element with the value 7 is pushed to the stack. The count of
    the elements before pushing to the stack is 2, and, after pushing to the stack,
    this figure is 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f214116d-8e1b-485b-9ef1-8b9ab6164ea4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `Pop` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Pop method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Pop` method on the `Stack` implementation removes the last element from
    the element array and returns the element, as shown in the following code. The
    `len` method returns the length of the elements array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output after the `Pop` method is invoked is as follows. The element
    value 5 is passed and added to the `Pop` method. The count of elements before
    invoking the `Pop` method is 2\. The count of the elements after calling the `Pop`
    method is 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01c29a22-a9a8-4956-9d24-50c44436658a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `main` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code section, the `main` method creates a `stack`, calls the
    `New` method, and pushes the elements after initializing them. The popped-out
    element value and the order is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands to execute the `stack.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding command, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd05e596-7e16-405a-a158-95dc1fde40d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the definition of `LinkedList`, double `LinkedList`, `Tuples`,
    `Sets`, `Queues`, and `Stacks`. The `LinkedList` methods – `AddToHead`, `AddToEnd`,
    `LastNode`, and `iterateList`—were also covered in this chapter. In addition,
    a priority queue was modeled as a heap of orders to be processed, sync queue was
    presented as passenger and ticket processing queues, and tuples were explained
    in a context in which a function returns a multivalued expression. The `new`,
    `push`, `pop`, and `string` methods for `Stack` were explained with code samples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover areas such as the `Trees`, `Tables`, `Containers`,
    and `Hash` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where can you use double linked list? Please provide an example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method on linked list can be used for printing out node values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which queue was shown with channels from the Go language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that returns multiple values. What data structure can be used
    for returning multiple values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can set have duplicate elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a code sample showing the union and intersection of two sets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a linked list, which method is used to find the node between two values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have elements that are not repeated and unique. What is the correct data
    structure that represents the collection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Go, how do you generate a random integer between the values 3 and 5?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method is called to check if an element of value 5 exists in the Set?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To read more about `LinkedLists`, `Sets`, `Tuples`, and `Stacks`, consult the
    following sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
