<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Non-Linear Data Structures</h1>
                </header>
            
            <article>
                
<p class="mce-root">Non-linear data structures are used in cryptography and other areas. A non-linear data structure is an arrangement in which an element is connected to many elements. These structures use memory quickly and efficiently. Free contiguous memory is not required for adding new elements.</p>
<p class="mce-root">The length of the data structures is not important before adding new elements. A non-linear data structure has multiple levels and a linear one has a single level. The values of the elements are not organized in a non-linear data structure. The data elements in a non-linear data structure cannot be iterated in one step. The implementation of these data structures is complicated.</p>
<p class="mce-root">Tree types such as binary search trees, treaps, and symbol tables are explained in this chapter. </p>
<p class="mce-root">This chapter covers the following non-linear data structures:</p>
<ul>
<li class="mce-root">Trees</li>
<li class="mce-root">Tables</li>
<li class="mce-root">Containers</li>
<li class="mce-root">Hash functions</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">Install Go version 1.10 from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> for your OS.</p>
<p>The GitHub URL for the code in this chapter is as follows: <a href="https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter04">https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter04</a>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Trees</h1>
                </header>
            
            <article>
                
<p class="mce-root">A tree is a non-linear data structure. <span>Trees are used for search and other use cases.</span><span> </span>A binary tree has nodes that have a maximum of two children. A binary search tree consists of nodes where the property values of the left node are less than the property values of the right node. The root node is at level zero of a tree. Each child node could be a leaf.</p>
<p class="mce-root">Trees and b<span>inary trees </span>were introduced in <a href="fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml">Chapter 1</a>, <em>Data Structures and Algorithms</em>, while we were discussing logarithmic complexity. Let's take a closer look at them in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Binary search tree</h1>
                </header>
            
            <article>
                
<p class="mce-root">A binary search tree is a data structure that allows for the quick lookup, addition, and removal of elements. It stores the keys in a sorted order to enable a faster lookup. This data structure was invented by <span>P. F. Windley, A. D. Booth, A. J. T. Colin, and T. N. Hibbard. On average, space usage for a binary search tree is of the order <em>O</em>(<em>n</em>), whereas the insert, search, and delete operations are of the order <em>O</em>(<em>log</em> <em>n</em>). </span>A binary search tree consists of nodes <span>with properties or attributes</span>:</p>
<ul>
<li class="mce-root">A <kbd>key</kbd> <span>integer</span></li>
<li class="mce-root">A <kbd>value</kbd> <span>integer</span></li>
<li class="mce-root">The <kbd>leftNode</kbd> and <kbd>rightNode</kbd> <span>instances </span>of <kbd>TreeNode</kbd></li>
</ul>
<p>They can be represented in the following code:</p>
<pre class="mce-root">// TreeNode class<br/>type TreeNode struct {<br/> key int<br/> value int<br/> leftNode *TreeNode <br/> rightNode *TreeNode <br/>}</pre>
<p>In the next section, the <kbd><span>BinarySearchTree</span></kbd> class implementation is discussed. For this section, please refer to the <kbd>binary_search_tree.go</kbd> <span>file</span>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The BinarySearchTree class</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code snippet, the <kbd>BinarySearchTree</kbd> class consists of a <kbd>rootNode</kbd> that's of the <kbd>TreeNode</kbd> type, and lock, which is of the <kbd>sync.RWMutex</kbd> type. The binary search tree is traversed from <kbd>rootNode</kbd> by accessing the nodes to the <span>left and right </span>of <kbd>rootNode</kbd>:</p>
<pre class="mce-root">// BinarySearchTree class<br/>type BinarySearchTree struct {<br/> rootNode *TreeNode<br/> lock sync.RWMutex<br/>}</pre>
<p class="mce-root">Now that we know what <kbd>BinarySearchTree</kbd> is, let's take a look at its different methods in the next section. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The InsertElement method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>InsertElement</kbd> method inserts the element with the given key and value in the binary search tree. The tree's <kbd>lock()</kbd> instance is locked first and the <kbd>unlock()</kbd> method is deferred before inserting the element. The <kbd>InsertTreeNode</kbd> method is invoked by passing <kbd>rootNode</kbd> and the node to be created with the key and value, as shown here:</p>
<pre class="mce-root">// InsertElement method<br/>func (tree *BinarySearchTree) InsertElement(key int, value int) {<br/> tree.lock.Lock()<br/> defer tree.lock.Unlock()<br/> var treeNode *TreeNode<br/> treeNode= &amp;TreeNode{key, value, nil, nil}<br/> if tree.rootNode == nil {<br/> tree.rootNode = treeNode<br/> } else {<br/> insertTreeNode(tree.rootNode, treeNode)<br/> }<br/>}</pre>
<p>The example output for inserting an element with key and value <kbd>3</kbd> is shown as follows. The <kbd>insert</kbd> element method calls <kbd>insertTreeNode</kbd> with <kbd>rootNode</kbd> with key <kbd>8</kbd> and the new <kbd>treeNode</kbd> with key <kbd>3</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3ec52ddb-5394-41f9-8c24-88d7fe593682.png" style="width:25.50em;height:2.67em;" width="354" height="36"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The insertTreeNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The <kbd>insertTreenode</kbd> method inserts the new <kbd>TreeNode</kbd> in the binary search tree. </span>In the following code, the <kbd>insertTreeNode</kbd> method takes <kbd>rootNode</kbd> and <kbd>newTreeNode</kbd>, both of the <kbd>TreeNode</kbd> type, as parameters. Note that <kbd>newTreeNode</kbd> is inserted at the right place in the binary search tree by comparing the key values:</p>
<pre class="mce-root">// insertTreeNode function<br/>func insertTreeNode(rootNode *TreeNode, newTreeNode *TreeNode) {<br/> if newTreeNode.key &lt; rootNode.key {<br/> if rootNode.leftNode == nil {<br/> rootNode.leftNode = newTreeNode<br/> } else {<br/> insertTreeNode(rootNode.leftNode, newTreeNode)<br/> }<br/> } else {<br/> if rootNode.rightNode == nil{ <br/> rootNode.rightNode = newTreeNode<br/> } else {<br/> insertTreeNode(rootNode.rightNode, newTreeNode)<br/> }<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The inOrderTraverse method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>inOrderTraverse</kbd> method visits all nodes in order. The <kbd>RLock()</kbd> method on the tree <kbd>lock</kbd> instance is called first. The <kbd>RUnLock()</kbd> method is deferred on the tree <kbd>lock</kbd> instance before invoking the <kbd>inOrderTraverseTree</kbd> method, as presented in the following code snippet:</p>
<pre class="mce-root">// InOrderTraverseTree method<br/>func (tree *BinarySearchTree) InOrderTraverseTree(function func(int)) {<br/> tree.lock.RLock()<br/> defer tree.lock.RUnlock()<br/> inOrderTraverseTree(tree.rootNode, function)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The inOrderTraverseTree method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>inOrderTraverseTree</kbd> method traverses the left, the root, and the right tree. The <kbd>inOrderTraverseTree</kbd> method takes <kbd>treeNode</kbd> of the <kbd>TreeNode</kbd> type and <kbd>function</kbd> as parameters. The <kbd>inOrderTraverseTree</kbd> method is called on <kbd>leftNode</kbd> and <kbd>rightNode</kbd> with <kbd>function</kbd> as a parameter. A <kbd>function</kbd> is passed with <kbd>treeNode.value</kbd>, as shown in the following code snippet:</p>
<pre class="mce-root">//  inOrderTraverseTree method<br/>func inOrderTraverseTree(treeNode *TreeNode, function func(int)) {<br/> if treeNode != nil {<br/> inOrderTraverseTree(treeNode.leftNode, function)<br/> function(treeNode.value)<br/> inOrderTraverseTree(treeNode.rightNode, function)<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The PreOrderTraverseTree method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>PreOrderTraverseTree</kbd> method visits all the <kbd>tree</kbd> nodes with preorder traversing. The tree <kbd>lock</kbd> instance is locked first and the <kbd>Unlock</kbd> method is deferred before <kbd>preOrderTraverseTree</kbd> is called. In the following code snippet, the <kbd>preOrderTraverseTree</kbd> method is passed with <kbd>rootNode</kbd> and <kbd>function</kbd> as parameters:</p>
<pre class="mce-root">// PreOrderTraverseTree method<br/>func (tree *BinarySearchTree) PreOrderTraverseTree(function func(int)) {<br/> tree.lock.Lock()<br/> defer tree.lock.Unlock()<br/> preOrderTraverseTree(tree.rootNode, function)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The preOrderTraverseTree method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>preOrderTraverseTree</kbd> method is passed with <kbd>treeNode</kbd> of the <kbd>TreeNode</kbd> type and <kbd>function</kbd> as parameters. The <kbd>preOrderTraverseTree</kbd> method is called by passing <kbd>leftNode</kbd> and <kbd>rightNode</kbd> with <kbd>function</kbd> as parameters. The <kbd>function</kbd> is invoked with <kbd>treeNode.value</kbd>, as shown here:</p>
<pre class="mce-root">//  preOrderTraverseTree method<br/>func preOrderTraverseTree(treeNode *TreeNode, function func(int)) {<br/> if treeNode != nil {<br/> function(treeNode.value)<br/> preOrderTraverseTree(treeNode.leftNode, function)<br/> preOrderTraverseTree(treeNode.rightNode, function)<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The PostOrderTraverseTree method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>PostOrderTraverseTree</kbd> method traverses the nodes in a post order (left, right, current node). In the following code snippet, the <kbd>PostOrderTraverseTree</kbd> method of the <kbd>BinarySearchTree</kbd> class visits all nodes with post-order traversing. The <kbd>function</kbd> method is passed as a parameter to the method. The <kbd>tree.lock</kbd> instance is locked first and the <kbd>Unlock</kbd> method is deferred on the tree <kbd>lock</kbd> instance before calling the <kbd>postOrderTraverseTree</kbd> method:</p>
<pre class="mce-root">// PostOrderTraverseTree method<br/>func (tree *BinarySearchTree) PostOrderTraverseTree(function func(int)) {<br/> tree.lock.Lock()<br/> defer tree.lock.Unlock()<br/> postOrderTraverseTree(tree.rootNode, function)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The postOrderTraverseTree method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>postOrderTraverseTree</kbd> method is passed with <kbd>treeNode</kbd> of the <kbd>TreeNode</kbd> type and <kbd>function</kbd> as parameters. The <kbd>postOrderTraverseTree</kbd> method is called by passing <kbd>leftNode</kbd> and <kbd>rightNode</kbd> with <kbd>function</kbd> as parameters. In the following code snippet, <kbd>function</kbd> is invoked with <kbd>treeNode.value</kbd> as a parameter:</p>
<pre class="mce-root">//  postOrderTraverseTree method<br/>func postOrderTraverseTree(treeNode *TreeNode, function func(int)) {<br/> if treeNode != nil {<br/> postOrderTraverseTree(treeNode.leftNode, function)<br/> postOrderTraverseTree(treeNode.rightNode, function)<br/> function(treeNode.value)<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The MinNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span><kbd>MinNode</kbd> finds the node with the minimum value in the binary search tree. </span>In the following code snippet, the <kbd>RLock</kbd> method of the tree <kbd>lock</kbd> instance is invoked first and the <kbd>RUnlock</kbd> method on the tree <kbd>lock</kbd> instance is deferred. The <kbd>MinNode</kbd> method returns the element with the lowest value by traversing from <kbd>rootNode</kbd> and checking whether the value of <kbd>leftNode</kbd> is <kbd>nil</kbd>:</p>
<pre class="mce-root">// MinNode method<br/>func (tree *BinarySearchTree) MinNode() *int {<br/> tree.lock.RLock()<br/> defer tree.lock.RUnlock()<br/> var treeNode *TreeNode<br/> treeNode = tree.rootNode<br/> if treeNode == nil {<br/> //nil instead of 0<br/> return (*int)(nil)<br/> }<br/> for {<br/> if treeNode.leftNode == nil {<br/> return &amp;treeNode.value<br/> }<br/> treeNode = treeNode.leftNode<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The MaxNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span><kbd>MaxNode</kbd> finds the node with maximum property in the binary search tree. </span>The <kbd>RLock</kbd> method of the tree <kbd>lock</kbd> instance is called first and the <kbd>RUnlock</kbd> method on the tree <kbd>lock</kbd> instance is deferred. The <kbd>MaxNode</kbd> method returns the element with the highest value after traversing from <kbd>rootNode</kbd> and finding a <kbd>rightNode</kbd> with a <kbd>nil</kbd> value. This is shown in the following code:</p>
<pre class="mce-root">// MaxNode method<br/>func (tree *BinarySearchTree) MaxNode() *int {<br/> tree.lock.RLock()<br/> defer tree.lock.RUnlock()<br/> var treeNode *TreeNode<br/> treeNode = tree.rootNode<br/> if treeNode == nil {<br/> //nil instead of 0<br/> return (*int)(nil)<br/> }<br/> for {<br/> if treeNode.rightNode == nil {<br/> return &amp;treeNode.value<br/> }<br/> treeNode = treeNode.rightNode<br/> }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The SearchNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>SearchNode</kbd> method searches the specified node in the binary search tree. First, the <kbd>RLock</kbd> method of the tree lock instance is called. Then, the <kbd>RUnlock</kbd> method on the tree <kbd>lock</kbd> instance is deferred. The <kbd>SearchNode</kbd> method of the <kbd>BinarySearchTree</kbd> class invokes the <kbd>searchNode</kbd> method with the <kbd>rootNode</kbd> and the <span><kbd>key</kbd> </span>integer value as <span>parameters,</span> as shown here:</p>
<pre class="mce-root">// SearchNode method<br/>func (tree *BinarySearchTree) SearchNode(key int) bool {<br/> tree.lock.RLock()<br/> defer tree.lock.RUnlock()<br/> return searchNode(tree.rootNode, key)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The searchNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code, the <kbd>searchNode</kbd> method takes <kbd>treeNode</kbd>, a pointer of the <kbd>TreeNode</kbd> type, and a <kbd>key</kbd> integer value as parameters. The method returns <kbd>true</kbd> or <kbd>false</kbd> after checking whether <kbd>treeNode</kbd> with the same value as <kbd>key</kbd> exists:</p>
<pre class="mce-root">//  searchNode method<br/>func searchNode(treeNode *TreeNode, key int) bool {<br/> if treeNode == nil {<br/> return false<br/> }<br/> if key &lt; treeNode.key {<br/> return searchNode(treeNode.leftNode, key)<br/> }<br/> if key &gt; treeNode.key {<br/> return searchNode(treeNode.rightNode, key)<br/> }<br/> return true<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The RemoveNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>RemoveNode</kbd> method of the <kbd>BinarySearchTree</kbd> class removes the element with <kbd>key</kbd> that's passed in. The method takes the <span><kbd>key</kbd> </span>integer value as the parameter. The <kbd>Lock()</kbd> method is invoked on the tree's <kbd>lock</kbd> instance first. The <kbd>Unlock()</kbd> method of the tree <kbd>lock</kbd> instance is deferred, and <kbd>removeNode</kbd> is called with <kbd>rootNode</kbd> and the <kbd>key</kbd> value as parameters, as shown here:</p>
<pre class="mce-root">// RemoveNode method<br/>func (tree *BinarySearchTree) RemoveNode(key int) {<br/> tree.lock.Lock()<br/> defer tree.lock.Unlock()<br/> removeNode(tree.rootNode, key)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The removeNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>removeNode</kbd> method takes <kbd>treeNode</kbd> of the <kbd>TreeNode</kbd> type and a <span><kbd>key</kbd> </span>integer value as parameters. In the following code snippet, the method recursively searches the <kbd>leftNode</kbd> instance of <kbd>treeNode</kbd> and the <kbd>key</kbd> value of <kbd>rightNode</kbd> if it matches the parameter value:</p>
<pre class="mce-root">// removeNode method<br/>func removeNode(treeNode *TreeNode, key int) *TreeNode {<br/> if treeNode == nil {<br/> return nil<br/> }<br/> if key &lt; treeNode.key {<br/> treeNode.leftNode = removeNode(treeNode.leftNode, key)<br/> return treeNode<br/> }<br/> if key &gt; treeNode.key {<br/> treeNode.rightNode = removeNode(treeNode.rightNode, key)<br/> return treeNode<br/> }<br/> // key == node.key<br/> if treeNode.leftNode == nil &amp;&amp; treeNode.rightNode == nil {<br/> treeNode = nil<br/> return nil<br/> }<br/> if treeNode.leftNode == nil {<br/> treeNode = treeNode.rightNode<br/> return treeNode<br/> }<br/> if treeNode.rightNode == nil {<br/> treeNode = treeNode.leftNode<br/> return treeNode<br/> }<br/> var leftmostrightNode *TreeNode<br/> leftmostrightNode = treeNode.rightNode<br/> for {<br/> //find smallest value on the right side<br/> if leftmostrightNode != nil &amp;&amp; leftmostrightNode.leftNode != nil {<br/> leftmostrightNode = leftmostrightNode.leftNode<br/> } else {<br/> break<br/> }<br/> }<br/> treeNode.key, treeNode.value = leftmostrightNode.key, leftmostrightNode.value<br/> treeNode.rightNode = removeNode(treeNode.rightNode, treeNode.key)<br/> return treeNode<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The String method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <span><kbd>String</kbd> method turns the <kbd>tree</kbd> into a string format. </span>At first, the <kbd>Lock()</kbd> method is invoked on the tree <kbd>lock</kbd> instance. Then, the <kbd>Unlock()</kbd> method of the tree <kbd>lock</kbd> instance is deferred. The <kbd>String</kbd> method prints a visual representation of <kbd>tree</kbd>:</p>
<pre class="mce-root">// String method<br/>func (tree *BinarySearchTree) String() {<br/> tree.lock.Lock()<br/> defer tree.lock.Unlock()<br/> fmt.Println("------------------------------------------------")<br/> stringify(tree.rootNode, 0)<br/> fmt.Println("------------------------------------------------")<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The stringify method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code snippet, the <kbd>stringify</kbd> method takes a <kbd>treeNode</kbd> instance of the <kbd>TreeNode</kbd> type and <span><kbd>level</kbd> (an </span>integer) as parameters. The method recursively prints the tree based on the level:</p>
<pre class="mce-root">// stringify method<br/>func stringify(treeNode *TreeNode, level int) {<br/> if treeNode != nil {<br/> format := ""<br/> for i := 0; i &lt; level; i++ {<br/> format += " "<br/> }<br/> format += "---[ "<br/> level++<br/> stringify(treeNode.leftNode, level)<br/> fmt.Printf(format+"%d\n", treeNode.key)<br/> stringify(treeNode.rightNode, level)<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code, the <kbd>main</kbd> method creates the binary search tree and inserts the elements <kbd>8</kbd>, <kbd>3</kbd>, <kbd>10</kbd>, <kbd>1</kbd>, and <kbd>6</kbd> into it. <kbd>tree</kbd> is printed by invoking the <kbd>String</kbd> method:</p>
<pre class="mce-root">// main method<br/>func main() {<br/> var tree *BinarySearchTree = &amp;BinarySearchTree{}<br/> tree.InsertElement(8,8)<br/> tree.InsertElement(3,3)<br/> tree.InsertElement(10,10)<br/> tree.InsertElement(1,1)<br/> tree.InsertElement(6,6)<br/> tree.String()<br/>}</pre>
<p class="p1"><span>Run the following command to execute the <kbd>binary_search_tree.go</kbd> file:</span></p>
<pre class="mce-root"><strong>go run binary_search_tree.go</strong></pre>
<p class="mce-root">The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d236a879-f1ae-4a80-87db-c45a03a4a811.png" width="488" height="184"/></p>
<p>The next section talks about AVL tree implementation.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adelson, Velski, and Landis (AVL) tree</h1>
                </header>
            
            <article>
                
<p class="mce-root">Adelson, Velski, and Landis pioneered the AVL tree data structure and hence it is named after them. It consists of height adjusting binary search trees. The balance factor is obtained by finding the difference between the heights of the left and right sub-trees. B<span>alancing is done using rotation techniques. I</span>f the balance factor is greater than one, rotation shifts the nodes to the opposite of the left or right sub-trees. The search, addition, and deletion operations are processed in the order of <em>O</em>(<em>log n</em>).</p>
<p class="mce-root">The following sections talks about the <kbd>KeyValue</kbd> interface definition and the <kbd>TreeNode</kbd> class. <span>For this section, please refer to the <kbd>avl_tree.go</kbd></span><span> </span><span>file</span><span>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The KeyValue interface</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>KeyValue</kbd> interface has the <kbd>LessThan</kbd> and <kbd>EqualTo</kbd> <span>methods</span>. The <kbd>LessThan</kbd> and <kbd>EqualTo</kbd> methods take <kbd>KeyValue</kbd> as a parameter and return a Boolean value after checking the less than or equal to condition. This is shown in the following code:</p>
<pre class="mce-root">// KeyValue type<br/>type KeyValue interface {<br/>  LessThan(KeyValue) bool<br/>  EqualTo(KeyValue) bool<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The TreeNode class</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>TreeNode</kbd> class has <kbd>KeyValue</kbd>, <kbd>BalanceValue</kbd>, and <kbd>LinkedNodes</kbd> as properties. The AVL tree is created as a tree of nodes of the <kbd>TreeNode</kbd> <span>type</span>, as shown here:</p>
<pre class="mce-root">// TreeNode class<br/>type TreeNode struct {<br/> KeyValue     KeyValue<br/> BalanceValue int<br/> LinkedNodes [2]*TreeNode<br/>}</pre>
<p class="mce-root">Now, let's take a look at the different methods of the <kbd>TreeNode</kbd> class.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The opposite method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>opposite</kbd> method takes a node value and returns the opposite node's value. In the following code snippet, the <kbd>opposite</kbd> method takes the <span><kbd>nodeValue</kbd> </span>integer as a parameter and returns the opposite node's value:</p>
<pre class="mce-root">//opposite method<br/>func opposite(nodeValue int) int {<br/> return 1 - nodeValue<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The singleRotation method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>singleRotation</kbd> method rotates the node opposite to the <span>specified </span>sub-tree. A<span>s shown in the following snippet, t</span>he <kbd>singleRotation</kbd> function rotates the node opposite the left or right sub-tree. The method takes the pointer to <kbd>rootNode</kbd> and a <kbd>nodeValue</kbd> <span>integer </span>as parameters and returns a <kbd>TreeNode</kbd> pointer:</p>
<pre class="mce-root">// single rotation method<br/>func singleRotation(rootNode *TreeNode, nodeValue int) *TreeNode {<br/>var saveNode *TreeNode<br/> saveNode = rootNode.LinkedNodes[opposite(nodeValue)]<br/> rootNode.LinkedNodes[opposite(nodeValue)] = saveNode.LinkedNodes[nodeValue]<br/> saveNode.LinkedNodes[nodeValue] = rootNode<br/> return saveNode<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The doubleRotation method</h1>
                </header>
            
            <article>
                
<p class="mce-root">Here, the <kbd>doubleRotation</kbd> method rotates the node twice. The method returns a <kbd>TreeNode</kbd> pointer, taking parameters such as <kbd>rootNode</kbd>, which is a <kbd>treeNode</kbd> pointer, and <kbd>nodeValue</kbd>, which is an <span>integer</span><span>. This is shown in the following code:</span></p>
<pre class="mce-root">// double rotation<br/>func doubleRotation(rootNode *TreeNode, nodeValue int) *TreeNode {<br/>var saveNode *TreeNode<br/> saveNode = rootNode.LinkedNodes[opposite(nodeValue)].LinkedNodes[nodeValue]<br/>rootNode.LinkedNodes[opposite(nodeValue)].LinkedNodes[nodeValue] = saveNode.LinkedNodes[opposite(nodeValue)]<br/> saveNode.LinkedNodes[opposite(nodeValue)] = rootNode.LinkedNodes[opposite(nodeValue)]<br/> rootNode.LinkedNodes[opposite(nodeValue)] = saveNode<br/>saveNode = rootNode.LinkedNodes[opposite(nodeValue)]<br/> rootNode.LinkedNodes[opposite(nodeValue)] = saveNode.LinkedNodes[nodeValue]<br/> saveNode.LinkedNodes[nodeValue] = rootNode<br/> return saveNode<br/>}</pre>
<p><span>The implementation of this method is shown in <em>The</em></span> <em>InsertNode m</em><span><em>ethod</em> section, as follows.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The adjustBalance method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>adjustBalance</kbd> method adjusts the balance of the tree. In the following code snippet, the <kbd>adjustBalance</kbd> method does a double rotation given the balance factor, <kbd>rootNode</kbd>, and <kbd>nodeValue</kbd>. The <kbd>adjustBalance</kbd> method takes <kbd>rootNode</kbd>, which is an instance of the <kbd>TreeNode</kbd> type, <kbd>nodeValue</kbd>, and <kbd>balanceValue</kbd> (which are both integers) <span>as parameters:</span></p>
<pre class="mce-root">// adjust balance method <br/>func adjustBalance(rootNode *TreeNode, nodeValue int, balanceValue int) {<br/> var node *TreeNode<br/> node = rootNode.LinkedNodes[nodeValue]<br/> var oppNode *TreeNode<br/> oppNode = node.LinkedNodes[opposite(balanceValue)]<br/> switch oppNode.BalanceValue {<br/> case 0:<br/> rootNode.BalanceValue = 0<br/> node.BalanceValue = 0<br/> case balanceValue:<br/> rootNode.BalanceValue = -balanceValue<br/> node.BalanceValue = 0<br/> default:<br/> rootNode.BalanceValue = 0<br/> node.BalanceValue = balanceValue<br/> }<br/> oppNode.BalanceValue= 0<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The BalanceTree method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>BalanceTree</kbd> method changes the balance factor by a single or double rotation. The method takes <kbd>rootNode</kbd> (a <kbd>TreeNode</kbd> pointer) and <span><kbd>nodeValue</kbd> (an </span>integer) as <span>parameters</span>. The <kbd>BalanceTree</kbd> method returns a <kbd>TreeNode</kbd> pointer, as shown here:</p>
<pre class="mce-root">// BalanceTree method<br/>func BalanceTree(rootNode *TreeNode, nodeValue int) *TreeNode {<br/> var node *TreeNode<br/> node = rootNode.LinkedNodes[nodeValue]<br/> var balance int<br/> balance = 2*nodeValue - 1<br/> if node.BalanceValue == balance {<br/> rootNode.BalanceValue = 0<br/> node.BalanceValue = 0<br/> return singleRotation(rootNode, opposite(nodeValue))<br/> }<br/> adjustBalance(rootNode, nodeValue, balance)<br/> return doubleRotation(rootNode, opposite(nodeValue))<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The insertRNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>insertRNode</kbd> method inserts the node and balances the tree. This method inserts <kbd>rootNode</kbd> with the <kbd>KeyValue</kbd> key, as presented in the following code snippet. The method takes <kbd>rootNode</kbd>, which is a <kbd>TreeNode</kbd> pointer, and the <kbd>key</kbd> as an integer as <span>parameters</span>. The method returns a <kbd>TreeNode</kbd> pointer and a Boolean value if the <kbd>rootNode</kbd> is inserted:</p>
<pre class="mce-root">//insertRNode method<br/>func insertRNode(rootNode *TreeNode, key KeyValue) (*TreeNode, bool) {<br/> if rootNode == nil {<br/> return &amp;TreeNode{KeyValue: key}, false<br/> }<br/> var dir int<br/> dir = 0<br/> if rootNode.KeyValue.LessThan(key) {<br/> dir = 1<br/> }<br/> var done bool<br/> rootNode.LinkedNodes[dir], done = insertRNode(rootNode.LinkedNodes[dir], key)<br/> if done {<br/> return rootNode, true<br/> }<br/> rootNode.BalanceValue = rootNode.BalanceValue+(2*dir - 1)<br/> switch rootNode.BalanceValue {<br/> case 0:<br/> return rootNode, true<br/> case 1, -1:<br/> return rootNode, false<br/> }<br/> return BalanceTree(rootNode, dir), true<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The InsertNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The <kbd>InsertNode</kbd> </span><span>method inserts a node into the AVL tree. This</span> method takes <kbd>treeNode</kbd>, which is a double <kbd>TreeNode</kbd> pointer, and the <kbd>key</kbd> value as <span>parameters</span>:</p>
<pre class="mce-root">// InsertNode method<br/>func InsertNode(treeNode **TreeNode, key KeyValue) {<br/> *treeNode, _ = insertRNode(*treeNode, key)<br/>}</pre>
<p>The example output of the <kbd>InsertNode</kbd> method is shown in the following screenshot. The <kbd>InsertNode</kbd> method calls the <kbd>insertRNode</kbd> method with the <kbd>rootNode</kbd> parameters and node to be inserted. <kbd>rootNode</kbd> has a key value of <kbd>5</kbd> and the node to be inserted has a key value of <kbd>6</kbd>. The tree needs to be balanced.</p>
<p>Hence, the next call will be <kbd>rootNode</kbd> with key <kbd>8</kbd> and node to be inserted. The next step calls <kbd>rootnode</kbd> with <kbd>key</kbd> value <kbd>7</kbd> and node to be inserted. The last call will be with <kbd>rootNode</kbd> <kbd>nil</kbd> and node to be inserted. The balance value is checked and the balance tree method returns the balanced tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/66eaf433-64fa-4788-ae2d-82a629adcb99.png" style="width:24.58em;height:8.25em;" width="370" height="124"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The RemoveNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code, the <kbd>RemoveNode</kbd> method removes the element from the AVL tree by invoking the <kbd>removeRNode</kbd> method. The method takes <kbd>treeNode</kbd>, which is a double <kbd>TreeNode</kbd> pointer, and <kbd>KeyValue</kbd> as <span>parameters:</span></p>
<pre class="mce-root">// RemoveNode method<br/>func RemoveNode(treeNode **TreeNode, key KeyValue) {<br/> *treeNode, _ = removeRNode(*treeNode, key)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The removeBalance method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>removeBalance</kbd> method removes the balance factor in a tree. This method adjusts the balance factor after removing the node and returns a <kbd>treeNode</kbd> pointer and a Boolean if the balance is removed. The method takes <kbd>rootNode</kbd> (an instance of <kbd>TreeNode</kbd>) and <kbd>nodeValue</kbd> (an integer) as <span>parameters. This is shown in the following code:</span></p>
<pre class="mce-root">// removeBalance method<br/>func removeBalance(rootNode *TreeNode, nodeValue int) (*TreeNode, bool) {<br/> var node *TreeNode<br/> node = rootNode.LinkedNodes[opposite(nodeValue)]<br/> var balance int<br/> balance = 2*nodeValue - 1<br/> switch node.BalanceValue {<br/> case -balance:<br/> rootNode.BalanceValue = 0<br/> node.BalanceValue = 0<br/> return singleRotation(rootNode, nodeValue), false<br/> case balance:<br/> adjustBalance(rootNode, opposite(nodeValue), -balance)<br/> return doubleRotation(rootNode, nodeValue), false<br/> }<br/> rootNode.BalanceValue = -balance<br/> node.BalanceValue = balance<br/> return singleRotation(rootNode, nodeValue), true<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The removeRNode method</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>removeRNode</kbd> method removes the node from the tree and balances the tree. This method takes <kbd>rootNode</kbd>, which is a <kbd>TreeNode</kbd> pointer, and the <kbd>key</kbd> value. This method returns a <kbd>TreeNode</kbd> pointer and Boolean value if <kbd>RNode</kbd> is removed, as shown in the following code snippet:</p>
<pre class="mce-root">//removeRNode method<br/>func removeRNode(rootNode *TreeNode, key KeyValue) (*TreeNode, bool) {<br/> if rootNode == nil {<br/> return nil, false<br/> }<br/> if rootNode.KeyValue.EqualTo(key) {<br/> switch {<br/> case rootNode.LinkedNodes[0] == nil:<br/> return rootNode.LinkedNodes[1], false<br/> case rootNode.LinkedNodes[1] == nil:<br/> return rootNode.LinkedNodes[0], false<br/> }<br/> var heirNode *TreeNode<br/> heirNode = rootNode.LinkedNodes[0]<br/> for heirNode.LinkedNodes[1] != nil {<br/> heirNode = heirNode.LinkedNodes[1]<br/> }<br/> rootNode.KeyValue = heirNode.KeyValue<br/> key = heirNode.KeyValue<br/> }<br/> var dir int<br/> dir = 0<br/> if rootNode.KeyValue.LessThan(key) {<br/> dir = 1<br/> }<br/> var done bool<br/> rootNode.LinkedNodes[dir], done = removeR(rootNode.LinkedNodes[dir], key)<br/> if done {<br/> return rootNode, true<br/> }<br/> rootNode.BalanceValue = rootNode.BalanceValue + (1 - 2*dir)<br/> switch rootNode.BalanceValue {<br/> case 1, -1:<br/> return rootNode, true<br/> case 0:<br/> return rootNode, false<br/> }<br/> return removeBalance(rootNode, dir)<br/>}<br/>type integerKey int<br/>func (k integerKey) LessThan(k1 KeyValue) bool { return k &lt; k1.(integerKey) }<br/>func (k integerKey) EqualTo(k1 KeyValue) bool { return k == k1.(integerKey) }</pre>
<p>The example output of the <kbd>removeRNode</kbd> method is shown as follows. The <kbd>RemoveNode</kbd> method calls the <kbd>removeRNode</kbd> method. The <kbd>removeRNode</kbd> method takes the parameters, such as <kbd>rootNode</kbd> and <kbd>KeyValue</kbd>, of the node:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d856f827-24f4-4ba1-849e-2bf65d6e1e3b.png" style="width:12.92em;height:5.42em;" width="186" height="77"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code snippet, the <kbd>main</kbd> method creates an AVL tree by inserting nodes with the <kbd>5</kbd>, <kbd>3</kbd>, <kbd>8</kbd>, <kbd>7</kbd>, <kbd>6</kbd>, and <kbd>10</kbd> keys. Nodes with the <kbd>3</kbd> and <kbd>7</kbd> keys are removed. The t<span>ree data structure is converted in to JSON in bytes</span>. The JSON bytes are printed after being changed to a string:</p>
<pre class="mce-root">//main method<br/>func main() {<br/>  var treeNode *TreeNode<br/>  fmt.Println("Tree is empty")<br/>  var avlTree []byte<br/>  avlTree, _ = json.MarshalIndent(treeNode, "", " ")<br/>  fmt.Println(string(avlTree))<br/><br/>  fmt.Println("\n Add Tree")<br/>  InsertNode(&amp;treeNode, integerKey(5))<br/>  InsertNode(&amp;treeNode, integerKey(3))<br/>  InsertNode(&amp;treeNode, integerKey(8))<br/>  InsertNode(&amp;treeNode, integerKey(7))<br/>  InsertNode(&amp;treeNode, integerKey(6))<br/>  InsertNode(&amp;treeNode, integerKey(10))<br/>  avlTree, _ = json.MarshalIndent(treeNode, "", " ")<br/>  fmt.Println(string(avlTree))<br/><br/>  fmt.Println("\n Delete Tree")<br/>  RemoveNode(&amp;treeNode, integerKey(3))<br/>  RemoveNode(&amp;treeNode, integerKey(7))<br/>  avlTree, _ = json.MarshalIndent(treeNode, "", " ")<br/>  fmt.Println(string(avlTree))<br/>}</pre>
<p class="mce-root"><span>Run the following command to execute the <kbd>avl_tree.go</kbd> file:</span></p>
<pre class="mce-root"><strong>go run avl_tree.go</strong></pre>
<p class="mce-root">The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3027cebf-bac5-4361-9dca-2b5c1e30a283.png" style="width:29.33em;height:48.92em;" width="488" height="813"/></p>
<p>In the next section, B+ tree implementation is discussed and code snippets are presented. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">B+ tree</h1>
                </header>
            
            <article>
                
<p class="mce-root">The B+ tree contains a list of keys and pointers to the next-level nodes in trees. During a search, recursion is used to search for an element by looking for the the adjacent node keys. B+ trees are used to store data in filesystems. B+ trees require fewer I/O operations to search for a node in the tree. Fan-out is defined as the number of nodes pointing to the child nodes of a node in a B+ tree. B+ trees were <span>first </span>described in a technical paper by <span>Rudolf Bayer and Edward M. McCreight.</span></p>
<p>The block-oriented storage context in B+ trees helps with the storage and efficient retrieval of data. The <span>space efficiency of a </span>B+ tree can be enhanced by using compression techniques. B+ trees belong to a family of multiway search trees. For a b-order B+ tree, space usage is of the order <em>O</em>(<em>n</em>). Inserting, finding, and removing operations are of the order <em>O</em>(<em>log<sub>b</sub>n</em>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">B-tree</h1>
                </header>
            
            <article>
                
<p class="mce-root">The B-tree is a search tree with non-leaf nodes that <span>only </span>have keys, and the data is in the leaves. B-trees are used to reduce the number of disk accesses. The B-tree is a self-adjusting data structure that keeps data sorted. B-trees store keys in a sorted order for easy traversal. They can handle multiple insertions and deletions.</p>
<p class="mce-root">Knuth initially came up with the concept of this data structure. B-trees consist of nodes that have at most <em>n</em> children. Every non-leaf node in the tree has at least <em>n</em>/2 child nodes. <span>Rudolf Bayer and Edward M. McCreight were the first to implement this data structure in their work.</span> B-trees are used in HFS and Reiser4 filesystems to allow for quick access to any block in a file. On average, space usage is in the order of <em>O</em>(<em>n</em>). Insert, search, and delete operations are in the order of <em>O</em>(<em>log n</em>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">T-tree</h1>
                </header>
            
            <article>
                
<p class="mce-root">The T-tree is a balanced data structure that has both the index and actual data in memory. They are used in in-memory databases. T refers to the shape of the node. Each node consists of pointers to the parent node and the left and right child nodes. Each node in the tree node will have an ordered array of data pointers and extra control data.</p>
<p class="mce-root">T-trees have similar performance benefits to in-memory tree structures. A T-tree is implemented on top of a self-balancing binary search tree. This data structure is good for ordered scanning of data. It supports various degrees of isolation.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tables</h1>
                </header>
            
            <article>
                
<p class="mce-root">As we already know, t<span>ables are used in data management and other areas. </span>A table has a name and a header with the column names. Let's take a look at the different classes in tables such as the <kbd>Table</kbd> class, the <kbd>Row</kbd> class, the <kbd>Column</kbd> class, and the <kbd>PrintTable</kbd> method in the following sections.</p>
<p class="mce-root"><span>For this section, please refer to the </span><kbd>table.go</kbd> <span>file</span><span>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Table class</h1>
                </header>
            
            <article>
                
<p class="mce-root">A <kbd>Table</kbd> class has an array of rows and column names. The table's <kbd>Name</kbd> is a <span>string </span>property in the <kbd>struct</kbd> class, as shown here:</p>
<pre class="mce-root">// Table Class<br/>type Table struct {<br/>    Rows []Row<br/>    Name string<br/>    ColumnNames []string<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Row class</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Row</kbd> class has an array of columns and an <kbd>Id</kbd> integer, as shown in the following code. The <kbd>Id</kbd> instance is a unique identifier for a row:</p>
<pre class="mce-root">// Row Class<br/>type Row struct {<br/> Columns []Column<br/> Id int<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Column class</h1>
                </header>
            
            <article>
                
<p class="mce-root">A <kbd>Column</kbd> class has an <kbd>Id</kbd> <span>integer </span>and a <kbd>Value string</kbd> that's identified by a unique identifier, as presented in the following code snippet:</p>
<pre class="mce-root">// Column Class<br/>type Column struct {<br/> Id int<br/> Value string<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The printTable method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the following code snippet, the <kbd>printTable</kbd> method prints the rows and columns of a table. Rows are traversed, and then for every row the columns are printed:</p>
<pre class="mce-root">//printTable<br/>func printTable(table Table){<br/> var rows []Row = table.Rows<br/> fmt.Println(table.Name)<br/> for _,row := range rows {<br/> var columns []Column = row.Columns<br/> for i,column := range columns {<br/> fmt.Println(table.ColumnNames[i],column.Id,column.Value);<br/> }<br/> }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this <kbd>main</kbd> method, we will instantiate the classes such as <kbd>Table</kbd>, <kbd>Row</kbd>, and <kbd>Column</kbd>, which we just took a look at. The <kbd>main</kbd> method creates a table and sets the name and column names. Columns are created with values. The columns are set on the rows after the rows are created. The table is printed by invoking the <kbd>printTable</kbd> method, as shown here:</p>
<pre class="mce-root">// main method<br/>func main() {<br/> var table Table = Table{}<br/> table.Name = "Customer"<br/> table.ColumnNames = []string{"Id", "Name","SSN"}<br/> var rows []Row = make([]Row,2)<br/> rows[0] = Row{}<br/> var columns1 []Column = make([]Column,3)<br/> columns1[0] = Column{1,"323"}<br/> columns1[1] = Column{1,"John Smith"}<br/> columns1[2] = Column{1,"3453223"}<br/> rows[0].Columns = columns1<br/> rows[1] = Row{}<br/> var columns2 []Column = make([]Column,3)<br/> columns2[0] = Column{2,"223"}<br/> columns2[1] = Column{2,"Curran Smith"}<br/> columns2[2] = Column{2,"3223211"}<br/> rows[1].Columns = columns2<br/> table.Rows = rows<br/> fmt.Println(table)<br/> printTable(table)<br/>}</pre>
<p class="mce-root"><span>Run the following command to execute the</span> <kbd>table.go</kbd> <span>file:</span></p>
<pre class="mce-root"><strong>go run table.go</strong></pre>
<p class="mce-root">The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6abf728c-176f-4ae0-a9ad-7e380ec43edf.png" style="width:33.58em;height:11.33em;" width="566" height="191"/></p>
<p>The next section talks about the symbol table data structure.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Symbol tables</h1>
                </header>
            
            <article>
                
<p class="mce-root">A symbol table is present in memory during the program translation process. It can be present in program binaries. A symbol table contains the symbol's name, location, and address. In Go, the <kbd>gosym</kbd> <span>package </span>implements access to the Go symbol and line number tables. Go binaries generated by the GC compilers have the symbol and line number tables. A line table is a data structure that maps program counters to line numbers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Containers</h1>
                </header>
            
            <article>
                
<p class="mce-root">The containers package provides access to the heap, list, and ring functionalities in Go. <span>Containers are used in social networks, knowledge graphs, and other areas. Containers are lists, maps, slices, channels, heaps, queues, and treaps. </span>Lists were introduced in <a href="fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml">Chapter 1</a>, <em>Data Structures and Algorithms</em>. M<span>aps and slices are b</span>uilt-in containers in Go. Channels in Go are called queues. A heap is a tree data structure. This data structure satisfies the heap property. A queue is modeled as a heap in <a href="6fc91a59-40ee-4183-8d13-2bbda917bf43.xhtml">Chapter 3</a>, <em>Linear Data Structures</em>. A treap is a mix of a tree and a heap. It is a binary tree with keys and values and a heap that maintains priorities.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root">A ring is called a circular linked list and is presented in the next section. <span>For this section, please refer to the</span> <kbd>circular_list.go</kbd> file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Circular linked list</h1>
                </header>
            
            <article>
                
<p class="mce-root">A circular linked list is a data structure in which the last node is followed by the first node. The <kbd>container/ring</kbd> structures are used to model circular linked lists. An example implementation of a circular linked list is shown as follows:</p>
<pre class="mce-root">package main<br/>import (<br/> "container/ring"<br/> "fmt"<br/>)<br/>func main() {<br/> var integers []int<br/> integers = []int{1,3,5,7}<br/> var circular_list *ring.Ring<br/> circular_list= ring.New(len(integers))<br/> var i int<br/> for i = 0; i &lt; circular_list.Len(); i++ {<br/> circular_list.Value = integers[i]<br/> circular_list = circular_list.Next()<br/> }</pre>
<p class="mce-root">The <kbd>ring.New</kbd> method with the <kbd>len</kbd> <em>n</em> as a parameter creates a circular list of length <em>n</em>. The circular linked list is initialized with an integer array by moving through <kbd>circular_list</kbd> with the <kbd>Next</kbd> method. The <kbd>Do</kbd> method of <kbd>ring.Ring</kbd> class takes the element as an interface, and the element is printed as follows:</p>
<pre class="mce-root">circular_list.Do(func(element interface{}) {<br/> fmt.Print(element,",")<br/> })<br/> fmt.Println()</pre>
<p class="mce-root">The reverse of the circular list is traversed using the <kbd>Prev</kbd> method, and the value is printed in the following code:</p>
<pre class="mce-root">// reverse of the circular list<br/> for i = 0; i &lt; circular_list.Len(); i++ {<br/> fmt.Print(circular_list.Value,",")<br/> circular_list = circular_list.Prev()<br/> }<br/> fmt.Println()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root">In the following code snippet, the circular list is moved two elements forward using the <kbd>Move</kbd> method, and the value is printed:</p>
<pre class="mce-root">// move two elements forward in the circular list<br/> circular_list = circular_list.Move(2)<br/> circular_list.Do(func(element interface{}) {<br/> fmt.Print(element,",")<br/> })<br/> fmt.Println()<br/>}</pre>
<p class="mce-root"><span>Run the following command to execute the </span><kbd>circular_list.go</kbd> <span>file:</span></p>
<pre class="mce-root"><strong>go run circular_list.go</strong></pre>
<p class="mce-root">The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b101ef1d-7757-4631-bbc3-8555b8e7e5c6.png" width="433" height="127"/></p>
<p>The next section talks about the <kbd>hash</kbd> function data structure.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The hash functions</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Hash functions are used in cryptography and other areas. These data structures are presented with code examples related to cryptography. There are two ways to implement a <kbd>hash</kbd> function in Go: with <kbd>crc32</kbd> or <kbd>sha256</kbd></span>. Marshaling (c<span>hanging the string to an encoded form</span>) saves the internal state, which is used for other purposes later. A <kbd>BinaryMarshaler</kbd> (c<span>onverting the string into binary form</span>) example is explained in this section:</p>
<pre class="mce-root">//main package has examples shown<br/>// in Hands-On Data Structures and algorithms with Go book<br/>package main<br/>// importing bytes, crpto/sha256, encoding, fmt and log package<br/>import (<br/> "bytes"<br/> "crypto/sha256"<br/> "encoding"<br/> "fmt"<br/> "log"<br/> "hash"<br/>)</pre>
<p class="mce-root">The <kbd>main</kbd> method creates a binary marshaled hash of two example strings. The hashes of the two strings are printed. The sum of the first hash is compared with the second hash using the equals <span>method </span>on bytes. This is shown in the following code:</p>
<pre class="mce-root">//main method<br/>func main() {<br/> const (<br/> example1 = "this is a example "<br/> example2 = "second example"<br/> )<br/> var firstHash hash.Hash<br/> firstHash = sha256.New()<br/> firstHash.Write([]byte(example1))<br/> var marshaler encoding.BinaryMarshaler<br/> var ok bool<br/> marshaler, ok = firstHash.(encoding.BinaryMarshaler)<br/> if !ok {<br/> log.Fatal("first Hash is not generated by encoding.BinaryMarshaler")<br/> }<br/> var data []byte<br/> var err error<br/> data, err = marshaler.MarshalBinary()<br/> if err != nil {<br/> log.Fatal("failure to create first Hash:", err)<br/> }<br/> var secondHash hash.Hash<br/> secondHash = sha256.New()<br/>var unmarshaler encoding.BinaryUnmarshaler<br/> unmarshaler, ok = secondHash.(encoding.BinaryUnmarshaler)<br/> if !ok {<br/> log.Fatal("second Hash is not generated by encoding.BinaryUnmarshaler")<br/> }<br/> if err := unmarshaler.UnmarshalBinary(data); err != nil {<br/> log.Fatal("failure to create hash:", err)<br/> }<br/> firstHash.Write([]byte(example2))<br/> secondHash.Write([]byte(example2))<br/> fmt.Printf("%x\n", firstHash.Sum(nil))<br/> fmt.Println(bytes.Equal(firstHash.Sum(nil), secondHash.Sum(nil)))<br/>}</pre>
<p class="mce-root"><span>Run the following command to execute the <kbd>hash.go</kbd> file:</span></p>
<pre class="mce-root"><strong>go run hash.go</strong></pre>
<p class="mce-root">The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a01a751a-b265-447b-a1e5-233763aab419.png" width="494" height="166"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter covered trees, binary search trees, and AVL trees. Treap, B-trees, and B+ trees were explained briefly. Operations such as insertion, deletion, and updating elements in trees were shown with various code examples. Tables, containers, and hash functions were presented in the last section. The complexity in time and space for operations such as insertion, deletion, and search were explained in each section.</p>
<p>In the next chapter, h<span class="s1">omogeneous data structures such as two-dimensional and multi- dimensional arrays will be covered.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Can you give an example where you can use a binary search tree?</li>
<li class="mce-root">Which method is used to search for an element in a binary search tree?</li>
<li class="mce-root">Which techniques are used to adjust the balance in an AVL tree?</li>
<li class="mce-root">What is a symbol table?</li>
</ol>
<p> </p>
<ol start="5">
<li class="mce-root">Which class and method are called to generate a binary marshaled hash on the hash class?</li>
<li class="mce-root">Which container in Go is used to model a circular linked list?</li>
<li class="mce-root">How do you create a JSON (indented) from a tree structure? Which class and method are used?</li>
<li>How do you compare the sum of hashes?</li>
<li>What is the balance factor in an AVL tree?</li>
<li>How do you identify a row and column in a table?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The following books are recommended if you want to know more about trees, binary search trees, and AVL trees:</span></p>
<ul>
<li><em>Design Patterns</em>, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides</li>
<li><em>Introduction to Algorithms – Thi<span>rd Edition</span></em>, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein</li>
<li><em>Data structures and Algorithms: An Easy Introduction</em>, by Rudolph Russell</li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>