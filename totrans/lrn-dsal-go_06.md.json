["```go\n// TreeNode class\ntype TreeNode struct {\n key int\n value int\n leftNode *TreeNode \n rightNode *TreeNode \n}\n```", "```go\n// BinarySearchTree class\ntype BinarySearchTree struct {\n rootNode *TreeNode\n lock sync.RWMutex\n}\n```", "```go\n// InsertElement method\nfunc (tree *BinarySearchTree) InsertElement(key int, value int) {\n tree.lock.Lock()\n defer tree.lock.Unlock()\n var treeNode *TreeNode\n treeNode= &TreeNode{key, value, nil, nil}\n if tree.rootNode == nil {\n tree.rootNode = treeNode\n } else {\n insertTreeNode(tree.rootNode, treeNode)\n }\n}\n```", "```go\n// insertTreeNode function\nfunc insertTreeNode(rootNode *TreeNode, newTreeNode *TreeNode) {\n if newTreeNode.key < rootNode.key {\n if rootNode.leftNode == nil {\n rootNode.leftNode = newTreeNode\n } else {\n insertTreeNode(rootNode.leftNode, newTreeNode)\n }\n } else {\n if rootNode.rightNode == nil{ \n rootNode.rightNode = newTreeNode\n } else {\n insertTreeNode(rootNode.rightNode, newTreeNode)\n }\n }\n}\n```", "```go\n// InOrderTraverseTree method\nfunc (tree *BinarySearchTree) InOrderTraverseTree(function func(int)) {\n tree.lock.RLock()\n defer tree.lock.RUnlock()\n inOrderTraverseTree(tree.rootNode, function)\n}\n```", "```go\n//  inOrderTraverseTree method\nfunc inOrderTraverseTree(treeNode *TreeNode, function func(int)) {\n if treeNode != nil {\n inOrderTraverseTree(treeNode.leftNode, function)\n function(treeNode.value)\n inOrderTraverseTree(treeNode.rightNode, function)\n }\n}\n```", "```go\n// PreOrderTraverseTree method\nfunc (tree *BinarySearchTree) PreOrderTraverseTree(function func(int)) {\n tree.lock.Lock()\n defer tree.lock.Unlock()\n preOrderTraverseTree(tree.rootNode, function)\n}\n```", "```go\n//  preOrderTraverseTree method\nfunc preOrderTraverseTree(treeNode *TreeNode, function func(int)) {\n if treeNode != nil {\n function(treeNode.value)\n preOrderTraverseTree(treeNode.leftNode, function)\n preOrderTraverseTree(treeNode.rightNode, function)\n }\n}\n```", "```go\n// PostOrderTraverseTree method\nfunc (tree *BinarySearchTree) PostOrderTraverseTree(function func(int)) {\n tree.lock.Lock()\n defer tree.lock.Unlock()\n postOrderTraverseTree(tree.rootNode, function)\n}\n```", "```go\n//  postOrderTraverseTree method\nfunc postOrderTraverseTree(treeNode *TreeNode, function func(int)) {\n if treeNode != nil {\n postOrderTraverseTree(treeNode.leftNode, function)\n postOrderTraverseTree(treeNode.rightNode, function)\n function(treeNode.value)\n }\n}\n```", "```go\n// MinNode method\nfunc (tree *BinarySearchTree) MinNode() *int {\n tree.lock.RLock()\n defer tree.lock.RUnlock()\n var treeNode *TreeNode\n treeNode = tree.rootNode\n if treeNode == nil {\n //nil instead of 0\n return (*int)(nil)\n }\n for {\n if treeNode.leftNode == nil {\n return &treeNode.value\n }\n treeNode = treeNode.leftNode\n }\n}\n```", "```go\n// MaxNode method\nfunc (tree *BinarySearchTree) MaxNode() *int {\n tree.lock.RLock()\n defer tree.lock.RUnlock()\n var treeNode *TreeNode\n treeNode = tree.rootNode\n if treeNode == nil {\n //nil instead of 0\n return (*int)(nil)\n }\n for {\n if treeNode.rightNode == nil {\n return &treeNode.value\n }\n treeNode = treeNode.rightNode\n }\n}\n```", "```go\n// SearchNode method\nfunc (tree *BinarySearchTree) SearchNode(key int) bool {\n tree.lock.RLock()\n defer tree.lock.RUnlock()\n return searchNode(tree.rootNode, key)\n}\n```", "```go\n//  searchNode method\nfunc searchNode(treeNode *TreeNode, key int) bool {\n if treeNode == nil {\n return false\n }\n if key < treeNode.key {\n return searchNode(treeNode.leftNode, key)\n }\n if key > treeNode.key {\n return searchNode(treeNode.rightNode, key)\n }\n return true\n}\n```", "```go\n// RemoveNode method\nfunc (tree *BinarySearchTree) RemoveNode(key int) {\n tree.lock.Lock()\n defer tree.lock.Unlock()\n removeNode(tree.rootNode, key)\n}\n```", "```go\n// removeNode method\nfunc removeNode(treeNode *TreeNode, key int) *TreeNode {\n if treeNode == nil {\n return nil\n }\n if key < treeNode.key {\n treeNode.leftNode = removeNode(treeNode.leftNode, key)\n return treeNode\n }\n if key > treeNode.key {\n treeNode.rightNode = removeNode(treeNode.rightNode, key)\n return treeNode\n }\n // key == node.key\n if treeNode.leftNode == nil && treeNode.rightNode == nil {\n treeNode = nil\n return nil\n }\n if treeNode.leftNode == nil {\n treeNode = treeNode.rightNode\n return treeNode\n }\n if treeNode.rightNode == nil {\n treeNode = treeNode.leftNode\n return treeNode\n }\n var leftmostrightNode *TreeNode\n leftmostrightNode = treeNode.rightNode\n for {\n //find smallest value on the right side\n if leftmostrightNode != nil && leftmostrightNode.leftNode != nil {\n leftmostrightNode = leftmostrightNode.leftNode\n } else {\n break\n }\n }\n treeNode.key, treeNode.value = leftmostrightNode.key, leftmostrightNode.value\n treeNode.rightNode = removeNode(treeNode.rightNode, treeNode.key)\n return treeNode\n}\n```", "```go\n// String method\nfunc (tree *BinarySearchTree) String() {\n tree.lock.Lock()\n defer tree.lock.Unlock()\n fmt.Println(\"------------------------------------------------\")\n stringify(tree.rootNode, 0)\n fmt.Println(\"------------------------------------------------\")\n}\n```", "```go\n// stringify method\nfunc stringify(treeNode *TreeNode, level int) {\n if treeNode != nil {\n format := \"\"\n for i := 0; i < level; i++ {\n format += \" \"\n }\n format += \"---[ \"\n level++\n stringify(treeNode.leftNode, level)\n fmt.Printf(format+\"%d\\n\", treeNode.key)\n stringify(treeNode.rightNode, level)\n }\n}\n```", "```go\n// main method\nfunc main() {\n var tree *BinarySearchTree = &BinarySearchTree{}\n tree.InsertElement(8,8)\n tree.InsertElement(3,3)\n tree.InsertElement(10,10)\n tree.InsertElement(1,1)\n tree.InsertElement(6,6)\n tree.String()\n}\n```", "```go\ngo run binary_search_tree.go\n```", "```go\n// KeyValue type\ntype KeyValue interface {\n  LessThan(KeyValue) bool\n  EqualTo(KeyValue) bool\n}\n```", "```go\n// TreeNode class\ntype TreeNode struct {\n KeyValue     KeyValue\n BalanceValue int\n LinkedNodes [2]*TreeNode\n}\n```", "```go\n//opposite method\nfunc opposite(nodeValue int) int {\n return 1 - nodeValue\n}\n```", "```go\n// single rotation method\nfunc singleRotation(rootNode *TreeNode, nodeValue int) *TreeNode {\nvar saveNode *TreeNode\n saveNode = rootNode.LinkedNodes[opposite(nodeValue)]\n rootNode.LinkedNodes[opposite(nodeValue)] = saveNode.LinkedNodes[nodeValue]\n saveNode.LinkedNodes[nodeValue] = rootNode\n return saveNode\n}\n```", "```go\n// double rotation\nfunc doubleRotation(rootNode *TreeNode, nodeValue int) *TreeNode {\nvar saveNode *TreeNode\n saveNode = rootNode.LinkedNodes[opposite(nodeValue)].LinkedNodes[nodeValue]\nrootNode.LinkedNodes[opposite(nodeValue)].LinkedNodes[nodeValue] = saveNode.LinkedNodes[opposite(nodeValue)]\n saveNode.LinkedNodes[opposite(nodeValue)] = rootNode.LinkedNodes[opposite(nodeValue)]\n rootNode.LinkedNodes[opposite(nodeValue)] = saveNode\nsaveNode = rootNode.LinkedNodes[opposite(nodeValue)]\n rootNode.LinkedNodes[opposite(nodeValue)] = saveNode.LinkedNodes[nodeValue]\n saveNode.LinkedNodes[nodeValue] = rootNode\n return saveNode\n}\n```", "```go\n// adjust balance method \nfunc adjustBalance(rootNode *TreeNode, nodeValue int, balanceValue int) {\n var node *TreeNode\n node = rootNode.LinkedNodes[nodeValue]\n var oppNode *TreeNode\n oppNode = node.LinkedNodes[opposite(balanceValue)]\n switch oppNode.BalanceValue {\n case 0:\n rootNode.BalanceValue = 0\n node.BalanceValue = 0\n case balanceValue:\n rootNode.BalanceValue = -balanceValue\n node.BalanceValue = 0\n default:\n rootNode.BalanceValue = 0\n node.BalanceValue = balanceValue\n }\n oppNode.BalanceValue= 0\n}\n```", "```go\n// BalanceTree method\nfunc BalanceTree(rootNode *TreeNode, nodeValue int) *TreeNode {\n var node *TreeNode\n node = rootNode.LinkedNodes[nodeValue]\n var balance int\n balance = 2*nodeValue - 1\n if node.BalanceValue == balance {\n rootNode.BalanceValue = 0\n node.BalanceValue = 0\n return singleRotation(rootNode, opposite(nodeValue))\n }\n adjustBalance(rootNode, nodeValue, balance)\n return doubleRotation(rootNode, opposite(nodeValue))\n}\n```", "```go\n//insertRNode method\nfunc insertRNode(rootNode *TreeNode, key KeyValue) (*TreeNode, bool) {\n if rootNode == nil {\n return &TreeNode{KeyValue: key}, false\n }\n var dir int\n dir = 0\n if rootNode.KeyValue.LessThan(key) {\n dir = 1\n }\n var done bool\n rootNode.LinkedNodes[dir], done = insertRNode(rootNode.LinkedNodes[dir], key)\n if done {\n return rootNode, true\n }\n rootNode.BalanceValue = rootNode.BalanceValue+(2*dir - 1)\n switch rootNode.BalanceValue {\n case 0:\n return rootNode, true\n case 1, -1:\n return rootNode, false\n }\n return BalanceTree(rootNode, dir), true\n}\n```", "```go\n// InsertNode method\nfunc InsertNode(treeNode **TreeNode, key KeyValue) {\n *treeNode, _ = insertRNode(*treeNode, key)\n}\n```", "```go\n// RemoveNode method\nfunc RemoveNode(treeNode **TreeNode, key KeyValue) {\n *treeNode, _ = removeRNode(*treeNode, key)\n}\n```", "```go\n// removeBalance method\nfunc removeBalance(rootNode *TreeNode, nodeValue int) (*TreeNode, bool) {\n var node *TreeNode\n node = rootNode.LinkedNodes[opposite(nodeValue)]\n var balance int\n balance = 2*nodeValue - 1\n switch node.BalanceValue {\n case -balance:\n rootNode.BalanceValue = 0\n node.BalanceValue = 0\n return singleRotation(rootNode, nodeValue), false\n case balance:\n adjustBalance(rootNode, opposite(nodeValue), -balance)\n return doubleRotation(rootNode, nodeValue), false\n }\n rootNode.BalanceValue = -balance\n node.BalanceValue = balance\n return singleRotation(rootNode, nodeValue), true\n}\n```", "```go\n//removeRNode method\nfunc removeRNode(rootNode *TreeNode, key KeyValue) (*TreeNode, bool) {\n if rootNode == nil {\n return nil, false\n }\n if rootNode.KeyValue.EqualTo(key) {\n switch {\n case rootNode.LinkedNodes[0] == nil:\n return rootNode.LinkedNodes[1], false\n case rootNode.LinkedNodes[1] == nil:\n return rootNode.LinkedNodes[0], false\n }\n var heirNode *TreeNode\n heirNode = rootNode.LinkedNodes[0]\n for heirNode.LinkedNodes[1] != nil {\n heirNode = heirNode.LinkedNodes[1]\n }\n rootNode.KeyValue = heirNode.KeyValue\n key = heirNode.KeyValue\n }\n var dir int\n dir = 0\n if rootNode.KeyValue.LessThan(key) {\n dir = 1\n }\n var done bool\n rootNode.LinkedNodes[dir], done = removeR(rootNode.LinkedNodes[dir], key)\n if done {\n return rootNode, true\n }\n rootNode.BalanceValue = rootNode.BalanceValue + (1 - 2*dir)\n switch rootNode.BalanceValue {\n case 1, -1:\n return rootNode, true\n case 0:\n return rootNode, false\n }\n return removeBalance(rootNode, dir)\n}\ntype integerKey int\nfunc (k integerKey) LessThan(k1 KeyValue) bool { return k < k1.(integerKey) }\nfunc (k integerKey) EqualTo(k1 KeyValue) bool { return k == k1.(integerKey) }\n```", "```go\n//main method\nfunc main() {\n  var treeNode *TreeNode\n  fmt.Println(\"Tree is empty\")\n  var avlTree []byte\n  avlTree, _ = json.MarshalIndent(treeNode, \"\", \" \")\n  fmt.Println(string(avlTree))\n\n  fmt.Println(\"\\n Add Tree\")\n  InsertNode(&treeNode, integerKey(5))\n  InsertNode(&treeNode, integerKey(3))\n  InsertNode(&treeNode, integerKey(8))\n  InsertNode(&treeNode, integerKey(7))\n  InsertNode(&treeNode, integerKey(6))\n  InsertNode(&treeNode, integerKey(10))\n  avlTree, _ = json.MarshalIndent(treeNode, \"\", \" \")\n  fmt.Println(string(avlTree))\n\n  fmt.Println(\"\\n Delete Tree\")\n  RemoveNode(&treeNode, integerKey(3))\n  RemoveNode(&treeNode, integerKey(7))\n  avlTree, _ = json.MarshalIndent(treeNode, \"\", \" \")\n  fmt.Println(string(avlTree))\n}\n```", "```go\ngo run avl_tree.go\n```", "```go\n// Table Class\ntype Table struct {\n    Rows []Row\n    Name string\n    ColumnNames []string\n}\n```", "```go\n// Row Class\ntype Row struct {\n Columns []Column\n Id int\n}\n```", "```go\n// Column Class\ntype Column struct {\n Id int\n Value string\n}\n```", "```go\n//printTable\nfunc printTable(table Table){\n var rows []Row = table.Rows\n fmt.Println(table.Name)\n for _,row := range rows {\n var columns []Column = row.Columns\n for i,column := range columns {\n fmt.Println(table.ColumnNames[i],column.Id,column.Value);\n }\n }\n}\n```", "```go\n// main method\nfunc main() {\n var table Table = Table{}\n table.Name = \"Customer\"\n table.ColumnNames = []string{\"Id\", \"Name\",\"SSN\"}\n var rows []Row = make([]Row,2)\n rows[0] = Row{}\n var columns1 []Column = make([]Column,3)\n columns1[0] = Column{1,\"323\"}\n columns1[1] = Column{1,\"John Smith\"}\n columns1[2] = Column{1,\"3453223\"}\n rows[0].Columns = columns1\n rows[1] = Row{}\n var columns2 []Column = make([]Column,3)\n columns2[0] = Column{2,\"223\"}\n columns2[1] = Column{2,\"Curran Smith\"}\n columns2[2] = Column{2,\"3223211\"}\n rows[1].Columns = columns2\n table.Rows = rows\n fmt.Println(table)\n printTable(table)\n}\n```", "```go\ngo run table.go\n```", "```go\npackage main\nimport (\n \"container/ring\"\n \"fmt\"\n)\nfunc main() {\n var integers []int\n integers = []int{1,3,5,7}\n var circular_list *ring.Ring\n circular_list= ring.New(len(integers))\n var i int\n for i = 0; i < circular_list.Len(); i++ {\n circular_list.Value = integers[i]\n circular_list = circular_list.Next()\n }\n```", "```go\ncircular_list.Do(func(element interface{}) {\n fmt.Print(element,\",\")\n })\n fmt.Println()\n```", "```go\n// reverse of the circular list\n for i = 0; i < circular_list.Len(); i++ {\n fmt.Print(circular_list.Value,\",\")\n circular_list = circular_list.Prev()\n }\n fmt.Println()\n```", "```go\n// move two elements forward in the circular list\n circular_list = circular_list.Move(2)\n circular_list.Do(func(element interface{}) {\n fmt.Print(element,\",\")\n })\n fmt.Println()\n}\n```", "```go\ngo run circular_list.go\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n// importing bytes, crpto/sha256, encoding, fmt and log package\nimport (\n \"bytes\"\n \"crypto/sha256\"\n \"encoding\"\n \"fmt\"\n \"log\"\n \"hash\"\n)\n```", "```go\n//main method\nfunc main() {\n const (\n example1 = \"this is a example \"\n example2 = \"second example\"\n )\n var firstHash hash.Hash\n firstHash = sha256.New()\n firstHash.Write([]byte(example1))\n var marshaler encoding.BinaryMarshaler\n var ok bool\n marshaler, ok = firstHash.(encoding.BinaryMarshaler)\n if !ok {\n log.Fatal(\"first Hash is not generated by encoding.BinaryMarshaler\")\n }\n var data []byte\n var err error\n data, err = marshaler.MarshalBinary()\n if err != nil {\n log.Fatal(\"failure to create first Hash:\", err)\n }\n var secondHash hash.Hash\n secondHash = sha256.New()\nvar unmarshaler encoding.BinaryUnmarshaler\n unmarshaler, ok = secondHash.(encoding.BinaryUnmarshaler)\n if !ok {\n log.Fatal(\"second Hash is not generated by encoding.BinaryUnmarshaler\")\n }\n if err := unmarshaler.UnmarshalBinary(data); err != nil {\n log.Fatal(\"failure to create hash:\", err)\n }\n firstHash.Write([]byte(example2))\n secondHash.Write([]byte(example2))\n fmt.Printf(\"%x\\n\", firstHash.Sum(nil))\n fmt.Println(bytes.Equal(firstHash.Sum(nil), secondHash.Sum(nil)))\n}\n```", "```go\ngo run hash.go\n```"]