- en: Non-Linear Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Non-linear data structures are used in cryptography and other areas. A non-linear
    data structure is an arrangement in which an element is connected to many elements.
    These structures use memory quickly and efficiently. Free contiguous memory is
    not required for adding new elements.
  prefs: []
  type: TYPE_NORMAL
- en: The length of the data structures is not important before adding new elements.
    A non-linear data structure has multiple levels and a linear one has a single
    level. The values of the elements are not organized in a non-linear data structure.
    The data elements in a non-linear data structure cannot be iterated in one step.
    The implementation of these data structures is complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Tree types such as binary search trees, treaps, and symbol tables are explained
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following non-linear data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install Go version 1.10 from [https://golang.org/doc/install](https://golang.org/doc/install) for
    your OS.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub URL for the code in this chapter is as follows: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter04](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A tree is a non-linear data structure. Trees are used for search and other use
    cases. A binary tree has nodes that have a maximum of two children. A binary search
    tree consists of nodes where the property values of the left node are less than
    the property values of the right node. The root node is at level zero of a tree.
    Each child node could be a leaf.
  prefs: []
  type: TYPE_NORMAL
- en: Trees and binary trees were introduced in [Chapter 1](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml),
    *Data Structures and Algorithms*, while we were discussing logarithmic complexity. Let's
    take a closer look at them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A binary search tree is a data structure that allows for the quick lookup,
    addition, and removal of elements. It stores the keys in a sorted order to enable
    a faster lookup. This data structure was invented by P. F. Windley, A. D. Booth,
    A. J. T. Colin, and T. N. Hibbard. On average, space usage for a binary search
    tree is of the order *O*(*n*), whereas the insert, search, and delete operations
    are of the order *O*(*log* *n*). A binary search tree consists of nodes with properties
    or attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: A `key` integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `value` integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `leftNode` and `rightNode` instances of `TreeNode`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They can be represented in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, the `BinarySearchTree` class implementation is discussed.
    For this section, please refer to the `binary_search_tree.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: The BinarySearchTree class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `BinarySearchTree` class consists of a `rootNode`
    that''s of the `TreeNode` type, and lock, which is of the `sync.RWMutex` type.
    The binary search tree is traversed from `rootNode` by accessing the nodes to
    the left and right of `rootNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know what `BinarySearchTree` is, let's take a look at its different
    methods in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The InsertElement method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `InsertElement` method inserts the element with the given key and value
    in the binary search tree. The tree''s `lock()` instance is locked first and the
    `unlock()` method is deferred before inserting the element. The `InsertTreeNode`
    method is invoked by passing `rootNode` and the node to be created with the key
    and value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output for inserting an element with key and value `3` is shown
    as follows. The `insert` element method calls `insertTreeNode` with `rootNode` with
    key `8` and the new `treeNode` with key `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ec52ddb-5394-41f9-8c24-88d7fe593682.png)'
  prefs: []
  type: TYPE_IMG
- en: The insertTreeNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `insertTreenode` method inserts the new `TreeNode` in the binary search
    tree. In the following code, the `insertTreeNode` method takes `rootNode` and
    `newTreeNode`, both of the `TreeNode` type, as parameters. Note that `newTreeNode`
    is inserted at the right place in the binary search tree by comparing the key
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The inOrderTraverse method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `inOrderTraverse` method visits all nodes in order. The `RLock()` method
    on the tree `lock` instance is called first. The `RUnLock()` method is deferred
    on the tree `lock` instance before invoking the `inOrderTraverseTree` method,
    as presented in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The inOrderTraverseTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `inOrderTraverseTree` method traverses the left, the root, and the right
    tree. The `inOrderTraverseTree` method takes `treeNode` of the `TreeNode` type
    and `function` as parameters. The `inOrderTraverseTree` method is called on `leftNode`
    and `rightNode` with `function` as a parameter. A `function` is passed with `treeNode.value`,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The PreOrderTraverseTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `PreOrderTraverseTree` method visits all the `tree` nodes with preorder
    traversing. The tree `lock` instance is locked first and the `Unlock` method is
    deferred before `preOrderTraverseTree` is called. In the following code snippet,
    the `preOrderTraverseTree` method is passed with `rootNode` and `function` as
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preOrderTraverseTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `preOrderTraverseTree` method is passed with `treeNode` of the `TreeNode`
    type and `function` as parameters. The `preOrderTraverseTree` method is called
    by passing `leftNode` and `rightNode` with `function` as parameters. The `function` is
    invoked with `treeNode.value`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The PostOrderTraverseTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `PostOrderTraverseTree` method traverses the nodes in a post order (left,
    right, current node). In the following code snippet, the `PostOrderTraverseTree`
    method of the `BinarySearchTree` class visits all nodes with post-order traversing.
    The `function` method is passed as a parameter to the method. The `tree.lock`
    instance is locked first and the `Unlock` method is deferred on the tree `lock`
    instance before calling the `postOrderTraverseTree` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The postOrderTraverseTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `postOrderTraverseTree` method is passed with `treeNode` of the `TreeNode`
    type and `function` as parameters. The `postOrderTraverseTree` method is called
    by passing `leftNode` and `rightNode` with `function` as parameters. In the following
    code snippet, `function` is invoked with `treeNode.value` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The MinNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MinNode` finds the node with the minimum value in the binary search tree. In
    the following code snippet, the `RLock` method of the tree `lock` instance is
    invoked first and the `RUnlock` method on the tree `lock` instance is deferred.
    The `MinNode` method returns the element with the lowest value by traversing from
    `rootNode` and checking whether the value of `leftNode` is `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The MaxNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MaxNode` finds the node with maximum property in the binary search tree. The
    `RLock` method of the tree `lock` instance is called first and the `RUnlock` method
    on the tree `lock` instance is deferred. The `MaxNode` method returns the element
    with the highest value after traversing from `rootNode` and finding a `rightNode`
    with a `nil` value. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The SearchNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `SearchNode` method searches the specified node in the binary search tree.
    First, the `RLock` method of the tree lock instance is called. Then, the `RUnlock`
    method on the tree `lock` instance is deferred. The `SearchNode` method of the
    `BinarySearchTree` class invokes the `searchNode` method with the `rootNode` and
    the `key` integer value as parameters, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The searchNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, the `searchNode` method takes `treeNode`, a pointer
    of the `TreeNode` type, and a `key` integer value as parameters. The method returns
    `true` or `false` after checking whether `treeNode` with the same value as `key`
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The RemoveNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RemoveNode` method of the `BinarySearchTree` class removes the element
    with `key` that''s passed in. The method takes the `key` integer value as the
    parameter. The `Lock()` method is invoked on the tree''s `lock` instance first.
    The `Unlock()` method of the tree `lock` instance is deferred, and `removeNode`
    is called with `rootNode` and the `key` value as parameters, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The removeNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `removeNode` method takes `treeNode` of the `TreeNode` type and a `key` integer
    value as parameters. In the following code snippet, the method recursively searches
    the `leftNode` instance of `treeNode` and the `key` value of `rightNode` if it
    matches the parameter value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The String method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `String` method turns the `tree` into a string format. At first, the `Lock()`
    method is invoked on the tree `lock` instance. Then, the `Unlock()` method of
    the tree `lock` instance is deferred. The `String` method prints a visual representation
    of `tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The stringify method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `stringify` method takes a `treeNode` instance
    of the `TreeNode` type and `level` (an integer) as parameters. The method recursively
    prints the tree based on the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, the `main` method creates the binary search tree and
    inserts the elements `8`, `3`, `10`, `1`, and `6` into it. `tree` is printed by
    invoking the `String` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `binary_search_tree.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d236a879-f1ae-4a80-87db-c45a03a4a811.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about AVL tree implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Adelson, Velski, and Landis (AVL) tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adelson, Velski, and Landis pioneered the AVL tree data structure and hence
    it is named after them. It consists of height adjusting binary search trees. The
    balance factor is obtained by finding the difference between the heights of the
    left and right sub-trees. Balancing is done using rotation techniques. If the
    balance factor is greater than one, rotation shifts the nodes to the opposite
    of the left or right sub-trees. The search, addition, and deletion operations
    are processed in the order of *O*(*log n*).
  prefs: []
  type: TYPE_NORMAL
- en: The following sections talks about the `KeyValue` interface definition and the `TreeNode`
    class. For this section, please refer to the `avl_tree.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: The KeyValue interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `KeyValue` interface has the `LessThan` and `EqualTo` methods. The `LessThan`
    and `EqualTo` methods take `KeyValue` as a parameter and return a Boolean value
    after checking the less than or equal to condition. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The TreeNode class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `TreeNode` class has `KeyValue`, `BalanceValue`, and `LinkedNodes` as properties.
    The AVL tree is created as a tree of nodes of the `TreeNode` type, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a look at the different methods of the `TreeNode` class.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `opposite` method takes a node value and returns the opposite node''s value.
    In the following code snippet, the `opposite` method takes the `nodeValue` integer
    as a parameter and returns the opposite node''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The singleRotation method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `singleRotation` method rotates the node opposite to the specified sub-tree.
    As shown in the following snippet, the `singleRotation` function rotates the node opposite
    the left or right sub-tree. The method takes the pointer to `rootNode` and a `nodeValue`
    integer as parameters and returns a `TreeNode` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The doubleRotation method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, the `doubleRotation` method rotates the node twice. The method returns
    a `TreeNode` pointer, taking parameters such as `rootNode`, which is a `treeNode`
    pointer, and `nodeValue`, which is an integer. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of this method is shown in *The* *InsertNode m**ethod* section,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The adjustBalance method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `adjustBalance` method adjusts the balance of the tree. In the following
    code snippet, the `adjustBalance` method does a double rotation given the balance
    factor, `rootNode`, and `nodeValue`. The `adjustBalance` method takes `rootNode`,
    which is an instance of the `TreeNode` type, `nodeValue`, and `balanceValue` (which
    are both integers) as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The BalanceTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BalanceTree` method changes the balance factor by a single or double rotation.
    The method takes `rootNode` (a `TreeNode` pointer) and `nodeValue` (an integer)
    as parameters. The `BalanceTree` method returns a `TreeNode` pointer, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The insertRNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `insertRNode` method inserts the node and balances the tree. This method inserts `rootNode`
    with the `KeyValue` key, as presented in the following code snippet. The method
    takes `rootNode`, which is a `TreeNode` pointer, and the `key` as an integer as parameters.
    The method returns a `TreeNode` pointer and a Boolean value if the `rootNode`
    is inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The InsertNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `InsertNode` method inserts a node into the AVL tree. This method takes
    `treeNode`, which is a double `TreeNode` pointer, and the `key` value as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The example output of the `InsertNode` method is shown in the following screenshot.
    The `InsertNode` method calls the `insertRNode` method with the `rootNode` parameters
    and node to be inserted. `rootNode` has a key value of `5` and the node to be
    inserted has a key value of `6`. The tree needs to be balanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the next call will be `rootNode` with key `8` and node to be inserted.
    The next step calls `rootnode` with `key` value `7` and node to be inserted. The
    last call will be with `rootNode` `nil` and node to be inserted. The balance value
    is checked and the balance tree method returns the balanced tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66eaf433-64fa-4788-ae2d-82a629adcb99.png)'
  prefs: []
  type: TYPE_IMG
- en: The RemoveNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, the `RemoveNode` method removes the element from the
    AVL tree by invoking the `removeRNode` method. The method takes `treeNode`, which
    is a double `TreeNode` pointer, and `KeyValue` as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The removeBalance method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `removeBalance` method removes the balance factor in a tree. This method
    adjusts the balance factor after removing the node and returns a `treeNode` pointer
    and a Boolean if the balance is removed. The method takes `rootNode` (an instance
    of `TreeNode`) and `nodeValue` (an integer) as parameters. This is shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The removeRNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `removeRNode` method removes the node from the tree and balances the tree.
    This method takes `rootNode`, which is a `TreeNode` pointer, and the `key` value.
    This method returns a `TreeNode` pointer and Boolean value if `RNode` is removed,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output of the `removeRNode` method is shown as follows. The `RemoveNode`
    method calls the `removeRNode` method. The `removeRNode` method takes the parameters,
    such as `rootNode` and `KeyValue`, of the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d856f827-24f4-4ba1-849e-2bf65d6e1e3b.png)'
  prefs: []
  type: TYPE_IMG
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `main` method creates an AVL tree by inserting
    nodes with the `5`, `3`, `8`, `7`, `6`, and `10` keys. Nodes with the `3` and
    `7` keys are removed. The tree data structure is converted in to JSON in bytes.
    The JSON bytes are printed after being changed to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `avl_tree.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3027cebf-bac5-4361-9dca-2b5c1e30a283.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, B+ tree implementation is discussed and code snippets are
    presented.
  prefs: []
  type: TYPE_NORMAL
- en: B+ tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The B+ tree contains a list of keys and pointers to the next-level nodes in
    trees. During a search, recursion is used to search for an element by looking
    for the the adjacent node keys. B+ trees are used to store data in filesystems.
    B+ trees require fewer I/O operations to search for a node in the tree. Fan-out
    is defined as the number of nodes pointing to the child nodes of a node in a B+
    tree. B+ trees were first described in a technical paper by Rudolf Bayer and Edward
    M. McCreight.
  prefs: []
  type: TYPE_NORMAL
- en: The block-oriented storage context in B+ trees helps with the storage and efficient
    retrieval of data. The space efficiency of a B+ tree can be enhanced by using
    compression techniques. B+ trees belong to a family of multiway search trees.
    For a b-order B+ tree, space usage is of the order *O*(*n*). Inserting, finding,
    and removing operations are of the order *O*(*log[b]n*).
  prefs: []
  type: TYPE_NORMAL
- en: B-tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The B-tree is a search tree with non-leaf nodes that only have keys, and the
    data is in the leaves. B-trees are used to reduce the number of disk accesses.
    The B-tree is a self-adjusting data structure that keeps data sorted. B-trees
    store keys in a sorted order for easy traversal. They can handle multiple insertions
    and deletions.
  prefs: []
  type: TYPE_NORMAL
- en: Knuth initially came up with the concept of this data structure. B-trees consist
    of nodes that have at most *n* children. Every non-leaf node in the tree has at
    least *n*/2 child nodes. Rudolf Bayer and Edward M. McCreight were the first to
    implement this data structure in their work. B-trees are used in HFS and Reiser4
    filesystems to allow for quick access to any block in a file. On average, space
    usage is in the order of *O*(*n*). Insert, search, and delete operations are in
    the order of *O*(*log n*).
  prefs: []
  type: TYPE_NORMAL
- en: T-tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The T-tree is a balanced data structure that has both the index and actual data
    in memory. They are used in in-memory databases. T refers to the shape of the
    node. Each node consists of pointers to the parent node and the left and right
    child nodes. Each node in the tree node will have an ordered array of data pointers
    and extra control data.
  prefs: []
  type: TYPE_NORMAL
- en: T-trees have similar performance benefits to in-memory tree structures. A T-tree
    is implemented on top of a self-balancing binary search tree. This data structure
    is good for ordered scanning of data. It supports various degrees of isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, tables are used in data management and other areas. A table
    has a name and a header with the column names. Let's take a look at the different
    classes in tables such as the `Table` class, the `Row` class, the `Column` class,
    and the `PrintTable` method in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, please refer to the `table.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: The Table class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Table` class has an array of rows and column names. The table''s `Name`
    is a string property in the `struct` class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The Row class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Row` class has an array of columns and an `Id` integer, as shown in the
    following code. The `Id` instance is a unique identifier for a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The Column class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Column` class has an `Id` integer and a `Value string` that''s identified
    by a unique identifier, as presented in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The printTable method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `printTable` method prints the rows and
    columns of a table. Rows are traversed, and then for every row the columns are
    printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this `main` method, we will instantiate the classes such as `Table`, `Row`,
    and `Column`, which we just took a look at. The `main` method creates a table
    and sets the name and column names. Columns are created with values. The columns
    are set on the rows after the rows are created. The table is printed by invoking
    the `printTable` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `table.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6abf728c-176f-4ae0-a9ad-7e380ec43edf.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about the symbol table data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Symbol tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A symbol table is present in memory during the program translation process.
    It can be present in program binaries. A symbol table contains the symbol's name,
    location, and address. In Go, the `gosym` package implements access to the Go
    symbol and line number tables. Go binaries generated by the GC compilers have
    the symbol and line number tables. A line table is a data structure that maps
    program counters to line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The containers package provides access to the heap, list, and ring functionalities
    in Go. Containers are used in social networks, knowledge graphs, and other areas.
    Containers are lists, maps, slices, channels, heaps, queues, and treaps. Lists
    were introduced in [Chapter 1](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml), *Data
    Structures and Algorithms*. Maps and slices are built-in containers in Go. Channels
    in Go are called queues. A heap is a tree data structure. This data structure
    satisfies the heap property. A queue is modeled as a heap in [Chapter 3](6fc91a59-40ee-4183-8d13-2bbda917bf43.xhtml),
    *Linear Data Structures*. A treap is a mix of a tree and a heap. It is a binary
    tree with keys and values and a heap that maintains priorities.
  prefs: []
  type: TYPE_NORMAL
- en: A ring is called a circular linked list and is presented in the next section. For
    this section, please refer to the `circular_list.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: Circular linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A circular linked list is a data structure in which the last node is followed
    by the first node. The `container/ring` structures are used to model circular
    linked lists. An example implementation of a circular linked list is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ring.New` method with the `len` *n* as a parameter creates a circular
    list of length *n*. The circular linked list is initialized with an integer array
    by moving through `circular_list` with the `Next` method. The `Do` method of `ring.Ring`
    class takes the element as an interface, and the element is printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse of the circular list is traversed using the `Prev` method, and
    the value is printed in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, the circular list is moved two elements forward
    using the `Move` method, and the value is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `circular_list.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b101ef1d-7757-4631-bbc3-8555b8e7e5c6.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about the `hash` function data structure.
  prefs: []
  type: TYPE_NORMAL
- en: The hash functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hash functions are used in cryptography and other areas. These data structures
    are presented with code examples related to cryptography. There are two ways to
    implement a `hash` function in Go: with `crc32` or `sha256`. Marshaling (changing
    the string to an encoded form) saves the internal state, which is used for other
    purposes later. A `BinaryMarshaler` (converting the string into binary form) example
    is explained in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method creates a binary marshaled hash of two example strings. The
    hashes of the two strings are printed. The sum of the first hash is compared with
    the second hash using the equals method on bytes. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `hash.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a01a751a-b265-447b-a1e5-233763aab419.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered trees, binary search trees, and AVL trees. Treap, B-trees,
    and B+ trees were explained briefly. Operations such as insertion, deletion, and
    updating elements in trees were shown with various code examples. Tables, containers,
    and hash functions were presented in the last section. The complexity in time
    and space for operations such as insertion, deletion, and search were explained
    in each section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, homogeneous data structures such as two-dimensional and
    multi- dimensional arrays will be covered.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you give an example where you can use a binary search tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method is used to search for an element in a binary search tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which techniques are used to adjust the balance in an AVL tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a symbol table?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which class and method are called to generate a binary marshaled hash on the
    hash class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which container in Go is used to model a circular linked list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a JSON (indented) from a tree structure? Which class and method
    are used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you compare the sum of hashes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the balance factor in an AVL tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you identify a row and column in a table?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following books are recommended if you want to know more about trees, binary
    search trees, and AVL trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
