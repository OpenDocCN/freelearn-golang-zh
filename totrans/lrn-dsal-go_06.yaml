- en: Non-Linear Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非线性数据结构
- en: Non-linear data structures are used in cryptography and other areas. A non-linear
    data structure is an arrangement in which an element is connected to many elements.
    These structures use memory quickly and efficiently. Free contiguous memory is
    not required for adding new elements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 非线性数据结构在密码学和其他领域中使用。非线性数据结构是一种元素连接到许多元素的排列。这些结构使用内存快速且高效。添加新元素不需要连续的空闲内存。
- en: The length of the data structures is not important before adding new elements.
    A non-linear data structure has multiple levels and a linear one has a single
    level. The values of the elements are not organized in a non-linear data structure.
    The data elements in a non-linear data structure cannot be iterated in one step.
    The implementation of these data structures is complicated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新元素之前，数据结构的长度并不重要。非线性数据结构有多个级别，而线性数据结构只有一个级别。非线性数据结构中的元素值没有组织。非线性数据结构中的数据元素不能一步迭代。这些数据结构的实现复杂。
- en: Tree types such as binary search trees, treaps, and symbol tables are explained
    in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了二叉搜索树、堆和符号表等树类型。
- en: 'This chapter covers the following non-linear data structures:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下非线性数据结构：
- en: Trees
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树
- en: Tables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格
- en: Containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Hash functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Install Go version 1.10 from [https://golang.org/doc/install](https://golang.org/doc/install) for
    your OS.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://golang.org/doc/install](https://golang.org/doc/install)为您的操作系统安装Go版本1.10。
- en: The GitHub URL for the code in this chapter is as follows: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter04](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter04).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的GitHub URL如下：[https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter04](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter04)。
- en: Trees
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: A tree is a non-linear data structure. Trees are used for search and other use
    cases. A binary tree has nodes that have a maximum of two children. A binary search
    tree consists of nodes where the property values of the left node are less than
    the property values of the right node. The root node is at level zero of a tree.
    Each child node could be a leaf.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种非线性数据结构。树用于搜索和其他用例。二叉树的节点最多有两个子节点。二叉搜索树由节点组成，其中左节点的属性值小于右节点的属性值。根节点位于树的零级。每个子节点可以是叶子节点。
- en: Trees and binary trees were introduced in [Chapter 1](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml),
    *Data Structures and Algorithms*, while we were discussing logarithmic complexity. Let's
    take a closer look at them in the next section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论对数复杂度时，介绍了[第1章](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml)“数据结构和算法”中的树和二叉树。让我们在下一节中更详细地看看它们。
- en: Binary search tree
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'A binary search tree is a data structure that allows for the quick lookup,
    addition, and removal of elements. It stores the keys in a sorted order to enable
    a faster lookup. This data structure was invented by P. F. Windley, A. D. Booth,
    A. J. T. Colin, and T. N. Hibbard. On average, space usage for a binary search
    tree is of the order *O*(*n*), whereas the insert, search, and delete operations
    are of the order *O*(*log* *n*). A binary search tree consists of nodes with properties
    or attributes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树是一种允许快速查找、添加和删除元素的数据结构。它以排序顺序存储键以实现更快的查找。这种数据结构是由P. F. Windley、A. D. Booth、A.
    J. T. Colin和T. N. Hibbard发明的。平均而言，二叉搜索树的平均空间使用量为*O*(*n*)，而插入、搜索和删除操作的平均时间为*O*(*log*
    *n*)。二叉搜索树由具有属性或属性的节点组成：
- en: A `key` integer
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`key`整数
- en: A `value` integer
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`value`整数
- en: The `leftNode` and `rightNode` instances of `TreeNode`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TreeNode`的`leftNode`和`rightNode`实例'
- en: 'They can be represented in the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以用以下代码表示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the next section, the `BinarySearchTree` class implementation is discussed.
    For this section, please refer to the `binary_search_tree.go` file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，将讨论`BinarySearchTree`类的实现。对于本节，请参阅`binary_search_tree.go`文件。
- en: The BinarySearchTree class
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树类
- en: 'In the following code snippet, the `BinarySearchTree` class consists of a `rootNode`
    that''s of the `TreeNode` type, and lock, which is of the `sync.RWMutex` type.
    The binary search tree is traversed from `rootNode` by accessing the nodes to
    the left and right of `rootNode`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`BinarySearchTree`类包含一个`rootNode`，它是`TreeNode`类型，以及一个`sync.RWMutex`类型的锁。二叉搜索树通过访问`rootNode`的左右节点从`rootNode`遍历：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we know what `BinarySearchTree` is, let's take a look at its different
    methods in the next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了什么是 `BinarySearchTree`，那么让我们在下一节中看看它的不同方法。
- en: The InsertElement method
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`InsertElement` 方法'
- en: 'The `InsertElement` method inserts the element with the given key and value
    in the binary search tree. The tree''s `lock()` instance is locked first and the
    `unlock()` method is deferred before inserting the element. The `InsertTreeNode`
    method is invoked by passing `rootNode` and the node to be created with the key
    and value, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertElement` 方法在二叉搜索树中插入具有给定键和值的元素。首先锁定树的 `lock()` 实例，并在插入元素之前延迟调用 `unlock()`
    方法。通过传递 `rootNode` 和要创建的具有键和值的节点调用 `InsertTreeNode` 方法，如下所示：'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The example output for inserting an element with key and value `3` is shown
    as follows. The `insert` element method calls `insertTreeNode` with `rootNode` with
    key `8` and the new `treeNode` with key `3`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 插入键和值为 `3` 的元素的示例输出如下。`insert` 元素方法调用 `insertTreeNode`，传递具有键 `8` 的 `rootNode`
    和具有键 `3` 的新 `treeNode`：
- en: '![](img/3ec52ddb-5394-41f9-8c24-88d7fe593682.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ec52ddb-5394-41f9-8c24-88d7fe593682.png)'
- en: The insertTreeNode method
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`insertTreeNode` 方法'
- en: 'The `insertTreenode` method inserts the new `TreeNode` in the binary search
    tree. In the following code, the `insertTreeNode` method takes `rootNode` and
    `newTreeNode`, both of the `TreeNode` type, as parameters. Note that `newTreeNode`
    is inserted at the right place in the binary search tree by comparing the key
    values:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertTreenode` 方法在二叉搜索树中插入新的 `TreeNode`。在以下代码中，`insertTreeNode` 方法接受 `rootNode`
    和 `newTreeNode` 作为参数，两者都是 `TreeNode` 类型。注意，`newTreeNode` 通过比较键值被插入到二叉搜索树的正确位置：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The inOrderTraverse method
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`inOrderTraverse` 方法'
- en: 'The `inOrderTraverse` method visits all nodes in order. The `RLock()` method
    on the tree `lock` instance is called first. The `RUnLock()` method is deferred
    on the tree `lock` instance before invoking the `inOrderTraverseTree` method,
    as presented in the following code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`inOrderTraverse` 方法按顺序访问所有节点。首先在树 `lock` 实例上调用 `RLock()` 方法。在调用 `inOrderTraverseTree`
    方法之前，在树 `lock` 实例上延迟调用 `RUnLock()` 方法，如下面的代码片段所示：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The inOrderTraverseTree method
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`inOrderTraverseTree` 方法'
- en: 'The `inOrderTraverseTree` method traverses the left, the root, and the right
    tree. The `inOrderTraverseTree` method takes `treeNode` of the `TreeNode` type
    and `function` as parameters. The `inOrderTraverseTree` method is called on `leftNode`
    and `rightNode` with `function` as a parameter. A `function` is passed with `treeNode.value`,
    as shown in the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`inOrderTraverseTree` 方法遍历左子树、根节点和右子树。`inOrderTraverseTree` 方法接受 `TreeNode`
    类型的 `treeNode` 和 `function` 作为参数。`inOrderTraverseTree` 方法在 `leftNode` 和 `rightNode`
    上调用，并传递 `function` 作为参数。`function` 以 `treeNode.value` 作为参数传递，如下面的代码片段所示：'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The PreOrderTraverseTree method
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`PreOrderTraverseTree` 方法'
- en: 'The `PreOrderTraverseTree` method visits all the `tree` nodes with preorder
    traversing. The tree `lock` instance is locked first and the `Unlock` method is
    deferred before `preOrderTraverseTree` is called. In the following code snippet,
    the `preOrderTraverseTree` method is passed with `rootNode` and `function` as
    parameters:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreOrderTraverseTree` 方法以先序遍历的方式访问所有 `tree` 节点。首先锁定 `tree` 的 `lock` 实例，并在调用
    `preOrderTraverseTree` 之前延迟调用 `Unlock` 方法。在以下代码片段中，`preOrderTraverseTree` 方法以
    `rootNode` 和 `function` 作为参数传递：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preOrderTraverseTree method
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`preOrderTraverseTree` 方法'
- en: 'The `preOrderTraverseTree` method is passed with `treeNode` of the `TreeNode`
    type and `function` as parameters. The `preOrderTraverseTree` method is called
    by passing `leftNode` and `rightNode` with `function` as parameters. The `function` is
    invoked with `treeNode.value`, as shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`preOrderTraverseTree` 方法以 `TreeNode` 类型的 `treeNode` 和 `function` 作为参数传递。通过传递
    `leftNode` 和 `rightNode` 作为参数调用 `preOrderTraverseTree` 方法。`function` 以 `treeNode.value`
    作为参数调用，如下所示：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The PostOrderTraverseTree method
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`PostOrderTraverseTree` 方法'
- en: 'The `PostOrderTraverseTree` method traverses the nodes in a post order (left,
    right, current node). In the following code snippet, the `PostOrderTraverseTree`
    method of the `BinarySearchTree` class visits all nodes with post-order traversing.
    The `function` method is passed as a parameter to the method. The `tree.lock`
    instance is locked first and the `Unlock` method is deferred on the tree `lock`
    instance before calling the `postOrderTraverseTree` method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostOrderTraverseTree` 方法以后序（左、右、当前节点）遍历节点。在以下代码片段中，`BinarySearchTree` 类的
    `PostOrderTraverseTree` 方法以后序遍历的方式访问所有节点。将 `function` 方法作为参数传递给方法。首先锁定 `tree.lock`
    实例，并在调用 `postOrderTraverseTree` 方法之前在树 `lock` 实例上延迟调用 `Unlock` 方法：'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The postOrderTraverseTree method
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后序遍历树方法
- en: 'The `postOrderTraverseTree` method is passed with `treeNode` of the `TreeNode`
    type and `function` as parameters. The `postOrderTraverseTree` method is called
    by passing `leftNode` and `rightNode` with `function` as parameters. In the following
    code snippet, `function` is invoked with `treeNode.value` as a parameter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`postOrderTraverseTree` 方法接受 `TreeNode` 类型的 `treeNode` 和 `function` 作为参数。通过传递
    `leftNode` 和 `rightNode` 以及 `function` 作为参数来调用 `postOrderTraverseTree` 方法。在以下代码片段中，`function`
    使用 `treeNode.value` 作为参数被调用：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The MinNode method
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小节点方法
- en: '`MinNode` finds the node with the minimum value in the binary search tree. In
    the following code snippet, the `RLock` method of the tree `lock` instance is
    invoked first and the `RUnlock` method on the tree `lock` instance is deferred.
    The `MinNode` method returns the element with the lowest value by traversing from
    `rootNode` and checking whether the value of `leftNode` is `nil`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`MinNode` 在二叉搜索树中找到具有最小值的节点。在下面的代码片段中，首先调用树 `lock` 实例的 `RLock` 方法，然后延迟执行树 `lock`
    实例上的 `RUnlock` 方法。`MinNode` 方法通过从 `rootNode` 开始遍历并检查 `leftNode` 的值是否为 `nil` 来返回具有最低值的元素：'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The MaxNode method
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大节点方法
- en: '`MaxNode` finds the node with maximum property in the binary search tree. The
    `RLock` method of the tree `lock` instance is called first and the `RUnlock` method
    on the tree `lock` instance is deferred. The `MaxNode` method returns the element
    with the highest value after traversing from `rootNode` and finding a `rightNode`
    with a `nil` value. This is shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaxNode` 在二叉搜索树中找到具有最大属性的节点。首先调用树 `lock` 实例的 `RLock` 方法，然后延迟执行树 `lock` 实例上的
    `RUnlock` 方法。`MaxNode` 方法在从 `rootNode` 遍历并找到一个具有 `nil` 值的 `rightNode` 后返回具有最高值的元素。这如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The SearchNode method
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索节点方法
- en: 'The `SearchNode` method searches the specified node in the binary search tree.
    First, the `RLock` method of the tree lock instance is called. Then, the `RUnlock`
    method on the tree `lock` instance is deferred. The `SearchNode` method of the
    `BinarySearchTree` class invokes the `searchNode` method with the `rootNode` and
    the `key` integer value as parameters, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchNode` 方法在二叉搜索树中搜索指定的节点。首先，调用树锁实例的 `RLock` 方法。然后，将树 `lock` 实例上的 `RUnlock`
    方法延迟执行。`BinarySearchTree` 类的 `SearchNode` 方法使用 `rootNode` 和 `key` 整数值作为参数调用 `searchNode`
    方法，如下所示：'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The searchNode method
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索节点方法
- en: 'In the following code, the `searchNode` method takes `treeNode`, a pointer
    of the `TreeNode` type, and a `key` integer value as parameters. The method returns
    `true` or `false` after checking whether `treeNode` with the same value as `key`
    exists:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`searchNode` 方法接受 `TreeNode` 类型的指针 `treeNode` 和 `key` 整数值作为参数。在检查是否存在与
    `key` 值相同的 `treeNode` 后，该方法返回 `true` 或 `false`：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The RemoveNode method
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除节点方法
- en: 'The `RemoveNode` method of the `BinarySearchTree` class removes the element
    with `key` that''s passed in. The method takes the `key` integer value as the
    parameter. The `Lock()` method is invoked on the tree''s `lock` instance first.
    The `Unlock()` method of the tree `lock` instance is deferred, and `removeNode`
    is called with `rootNode` and the `key` value as parameters, as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySearchTree` 类的 `RemoveNode` 方法移除传入的 `key` 值对应的元素。该方法将 `key` 整数值作为参数。首先在树的
    `lock` 实例上调用 `Lock()` 方法。然后延迟执行树 `lock` 实例的 `Unlock()` 方法，并使用 `rootNode` 和 `key`
    值作为参数调用 `removeNode`，如下所示：'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The removeNode method
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除节点方法
- en: 'The `removeNode` method takes `treeNode` of the `TreeNode` type and a `key` integer
    value as parameters. In the following code snippet, the method recursively searches
    the `leftNode` instance of `treeNode` and the `key` value of `rightNode` if it
    matches the parameter value:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeNode` 方法接受 `TreeNode` 类型的 `treeNode` 和 `key` 整数值作为参数。在下面的代码片段中，该方法递归地搜索
    `treeNode` 的 `leftNode` 实例和 `rightNode` 的 `key` 值，如果它与参数值匹配：'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The String method
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串方法
- en: 'The `String` method turns the `tree` into a string format. At first, the `Lock()`
    method is invoked on the tree `lock` instance. Then, the `Unlock()` method of
    the tree `lock` instance is deferred. The `String` method prints a visual representation
    of `tree`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 方法将 `tree` 转换为字符串格式。首先在树的 `lock` 实例上调用 `Lock()` 方法。然后延迟执行树 `lock`
    实例的 `Unlock()` 方法。`String` 方法打印 `tree` 的可视表示：'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The stringify method
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串化方法
- en: 'In the following code snippet, the `stringify` method takes a `treeNode` instance
    of the `TreeNode` type and `level` (an integer) as parameters. The method recursively
    prints the tree based on the level:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`stringify` 方法接受 `TreeNode` 类型的 `treeNode` 实例和 `level`（一个整数）作为参数。该方法根据级别递归打印树：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The main method
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主方法
- en: 'In the following code, the `main` method creates the binary search tree and
    inserts the elements `8`, `3`, `10`, `1`, and `6` into it. `tree` is printed by
    invoking the `String` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`main` 方法创建了一个二叉搜索树，并将元素 `8`、`3`、`10`、`1` 和 `6` 插入其中。通过调用 `String` 方法打印
    `tree`：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the following command to execute the `binary_search_tree.go` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `binary_search_tree.go` 文件：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/d236a879-f1ae-4a80-87db-c45a03a4a811.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d236a879-f1ae-4a80-87db-c45a03a4a811.png)'
- en: The next section talks about AVL tree implementation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节讨论 AVL 树的实现。
- en: Adelson, Velski, and Landis (AVL) tree
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Adelson, Velski, and Landis (AVL) 树
- en: Adelson, Velski, and Landis pioneered the AVL tree data structure and hence
    it is named after them. It consists of height adjusting binary search trees. The
    balance factor is obtained by finding the difference between the heights of the
    left and right sub-trees. Balancing is done using rotation techniques. If the
    balance factor is greater than one, rotation shifts the nodes to the opposite
    of the left or right sub-trees. The search, addition, and deletion operations
    are processed in the order of *O*(*log n*).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Adelson, Velski, and Landis 首创了 AVL 树数据结构，因此以他们的名字命名。它由调整高度的二叉搜索树组成。平衡因子是通过找到左右子树高度的差来获得的。平衡是通过旋转技术完成的。如果平衡因子大于一，则旋转将节点移至左子树或右子树的相反方向。搜索、添加和删除操作按
    *O*(*log n*) 的顺序处理。
- en: The following sections talks about the `KeyValue` interface definition and the `TreeNode`
    class. For this section, please refer to the `avl_tree.go` file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节讨论了 `KeyValue` 接口定义和 `TreeNode` 类。对于本节，请参阅 `avl_tree.go` 文件。
- en: The KeyValue interface
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`KeyValue` 接口'
- en: 'The `KeyValue` interface has the `LessThan` and `EqualTo` methods. The `LessThan`
    and `EqualTo` methods take `KeyValue` as a parameter and return a Boolean value
    after checking the less than or equal to condition. This is shown in the following
    code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyValue` 接口有 `LessThan` 和 `EqualTo` 方法。`LessThan` 和 `EqualTo` 方法接受 `KeyValue`
    作为参数，并在检查小于或等于条件后返回一个布尔值。如下代码所示：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The TreeNode class
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TreeNode 类
- en: 'The `TreeNode` class has `KeyValue`, `BalanceValue`, and `LinkedNodes` as properties.
    The AVL tree is created as a tree of nodes of the `TreeNode` type, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeNode` 类具有 `KeyValue`、`BalanceValue` 和 `LinkedNodes` 作为属性。AVL 树是一个由 `TreeNode`
    类型节点组成的树，如下所示：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, let's take a look at the different methods of the `TreeNode` class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `TreeNode` 类的不同方法。
- en: The opposite method
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相反的方法
- en: 'The `opposite` method takes a node value and returns the opposite node''s value.
    In the following code snippet, the `opposite` method takes the `nodeValue` integer
    as a parameter and returns the opposite node''s value:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`opposite` 方法接受一个节点值，并返回相反节点的值。在以下代码片段中，`opposite` 方法接受 `nodeValue` 整数作为参数，并返回相反节点的值：'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The singleRotation method
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`singleRotation` 方法'
- en: 'The `singleRotation` method rotates the node opposite to the specified sub-tree.
    As shown in the following snippet, the `singleRotation` function rotates the node opposite
    the left or right sub-tree. The method takes the pointer to `rootNode` and a `nodeValue`
    integer as parameters and returns a `TreeNode` pointer:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleRotation` 方法旋转与指定子树相反的节点。如下代码片段所示，`singleRotation` 函数旋转与左子树或右子树相反的节点。该方法接受
    `rootNode` 的指针和一个 `nodeValue` 整数作为参数，并返回一个 `TreeNode` 指针：'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The doubleRotation method
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双重旋转方法
- en: 'Here, the `doubleRotation` method rotates the node twice. The method returns
    a `TreeNode` pointer, taking parameters such as `rootNode`, which is a `treeNode`
    pointer, and `nodeValue`, which is an integer. This is shown in the following
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`doubleRotation` 方法将节点旋转两次。该方法返回一个 `TreeNode` 指针，接受参数如 `rootNode`，它是一个 `treeNode`
    指针，以及 `nodeValue`，它是一个整数。如下代码所示：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The implementation of this method is shown in *The* *InsertNode m**ethod* section,
    as follows.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的实现如 *插入节点方法* 部分所示，如下。
- en: The adjustBalance method
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整平衡方法
- en: 'The `adjustBalance` method adjusts the balance of the tree. In the following
    code snippet, the `adjustBalance` method does a double rotation given the balance
    factor, `rootNode`, and `nodeValue`. The `adjustBalance` method takes `rootNode`,
    which is an instance of the `TreeNode` type, `nodeValue`, and `balanceValue` (which
    are both integers) as parameters:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjustBalance` 方法调整树的平衡。在以下代码片段中，`adjustBalance` 方法根据平衡因子、`rootNode` 和 `nodeValue`
    执行双旋转。`adjustBalance` 方法接受 `rootNode`（`TreeNode` 类型的实例）、`nodeValue` 和 `balanceValue`（都是整数）作为参数：'
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The BalanceTree method
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`BalanceTree` 方法'
- en: 'The `BalanceTree` method changes the balance factor by a single or double rotation.
    The method takes `rootNode` (a `TreeNode` pointer) and `nodeValue` (an integer)
    as parameters. The `BalanceTree` method returns a `TreeNode` pointer, as shown
    here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`BalanceTree` 方法通过单次或双旋转来改变平衡因子。该方法接受 `rootNode`（一个 `TreeNode` 指针）和 `nodeValue`（一个整数）作为参数。`BalanceTree`
    方法返回一个 `TreeNode` 指针，如下所示：'
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The insertRNode method
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`insertRNode` 方法'
- en: 'The `insertRNode` method inserts the node and balances the tree. This method inserts `rootNode`
    with the `KeyValue` key, as presented in the following code snippet. The method
    takes `rootNode`, which is a `TreeNode` pointer, and the `key` as an integer as parameters.
    The method returns a `TreeNode` pointer and a Boolean value if the `rootNode`
    is inserted:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertRNode` 方法插入节点并平衡树。此方法使用 `KeyValue` 键插入 `rootNode`，如下代码片段所示。该方法接受 `rootNode`（一个
    `TreeNode` 指针）和 `key`（一个整数）作为参数。如果成功插入 `rootNode`，则方法返回一个 `TreeNode` 指针和一个布尔值：'
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The InsertNode method
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`InsertNode` 方法'
- en: 'The `InsertNode` method inserts a node into the AVL tree. This method takes
    `treeNode`, which is a double `TreeNode` pointer, and the `key` value as parameters:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertNode` 方法将节点插入到 AVL 树中。此方法接受 `treeNode`（一个双 `TreeNode` 指针）和 `key` 值作为参数：'
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The example output of the `InsertNode` method is shown in the following screenshot.
    The `InsertNode` method calls the `insertRNode` method with the `rootNode` parameters
    and node to be inserted. `rootNode` has a key value of `5` and the node to be
    inserted has a key value of `6`. The tree needs to be balanced.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `InsertNode` 方法的示例输出。`InsertNode` 方法使用 `rootNode` 参数和要插入的节点调用 `insertRNode`
    方法。`rootNode` 的键值为 `5`，要插入的节点的键值为 `6`。树需要平衡。
- en: 'Hence, the next call will be `rootNode` with key `8` and node to be inserted.
    The next step calls `rootnode` with `key` value `7` and node to be inserted. The
    last call will be with `rootNode` `nil` and node to be inserted. The balance value
    is checked and the balance tree method returns the balanced tree:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一个调用将是具有键值 `8` 的 `rootNode` 和要插入的节点。下一步调用 `rootnode`，键值为 `7`，并插入节点。最后的调用将是
    `rootNode` 为 `nil` 和要插入的节点。检查平衡值，平衡树方法返回平衡后的树：
- en: '![](img/66eaf433-64fa-4788-ae2d-82a629adcb99.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66eaf433-64fa-4788-ae2d-82a629adcb99.png)'
- en: The RemoveNode method
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`RemoveNode` 方法'
- en: 'In the following code, the `RemoveNode` method removes the element from the
    AVL tree by invoking the `removeRNode` method. The method takes `treeNode`, which
    is a double `TreeNode` pointer, and `KeyValue` as parameters:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`RemoveNode` 方法通过调用 `removeRNode` 方法从 AVL 树中删除元素。该方法接受 `treeNode`（一个双
    `TreeNode` 指针）和 `KeyValue` 作为参数：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The removeBalance method
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`removeBalance` 方法'
- en: 'The `removeBalance` method removes the balance factor in a tree. This method
    adjusts the balance factor after removing the node and returns a `treeNode` pointer
    and a Boolean if the balance is removed. The method takes `rootNode` (an instance
    of `TreeNode`) and `nodeValue` (an integer) as parameters. This is shown in the
    following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeBalance` 方法从树中移除平衡因子。在删除节点后，此方法调整平衡因子并返回一个 `treeNode` 指针和一个布尔值，如果平衡被移除。该方法接受
    `rootNode`（`TreeNode` 的一个实例）和 `nodeValue`（一个整数）作为参数。如下代码所示：'
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The removeRNode method
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`removeRNode` 方法'
- en: 'The `removeRNode` method removes the node from the tree and balances the tree.
    This method takes `rootNode`, which is a `TreeNode` pointer, and the `key` value.
    This method returns a `TreeNode` pointer and Boolean value if `RNode` is removed,
    as shown in the following code snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeRNode` 方法从树中删除节点并平衡树。此方法接受 `rootNode`（一个 `TreeNode` 指针）和 `key` 值。如果成功删除
    `RNode`，则此方法返回一个 `TreeNode` 指针和一个布尔值，如下代码片段所示：'
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The example output of the `removeRNode` method is shown as follows. The `RemoveNode`
    method calls the `removeRNode` method. The `removeRNode` method takes the parameters,
    such as `rootNode` and `KeyValue`, of the node:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了 `removeRNode` 方法的示例输出。`RemoveNode` 方法调用 `removeRNode` 方法。`removeRNode`
    方法接受节点的参数，例如 `rootNode` 和 `KeyValue`：
- en: '![](img/d856f827-24f4-4ba1-849e-2bf65d6e1e3b.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d856f827-24f4-4ba1-849e-2bf65d6e1e3b.png)'
- en: The main method
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main`方法'
- en: 'In the following code snippet, the `main` method creates an AVL tree by inserting
    nodes with the `5`, `3`, `8`, `7`, `6`, and `10` keys. Nodes with the `3` and
    `7` keys are removed. The tree data structure is converted in to JSON in bytes.
    The JSON bytes are printed after being changed to a string:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`main`方法通过插入具有`5`、`3`、`8`、`7`、`6`和`10`键的节点来创建AVL树。具有`3`和`7`键的节点被移除。将树数据结构转换为字节的JSON。在转换为字符串后打印JSON字节：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the following command to execute the `avl_tree.go` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`avl_tree.go`文件：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/3027cebf-bac5-4361-9dca-2b5c1e30a283.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3027cebf-bac5-4361-9dca-2b5c1e30a283.png)'
- en: In the next section, B+ tree implementation is discussed and code snippets are
    presented.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，将讨论B+树的实现并展示代码片段。
- en: B+ tree
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B+树
- en: The B+ tree contains a list of keys and pointers to the next-level nodes in
    trees. During a search, recursion is used to search for an element by looking
    for the the adjacent node keys. B+ trees are used to store data in filesystems.
    B+ trees require fewer I/O operations to search for a node in the tree. Fan-out
    is defined as the number of nodes pointing to the child nodes of a node in a B+
    tree. B+ trees were first described in a technical paper by Rudolf Bayer and Edward
    M. McCreight.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: B+树包含一个键列表和指向树中下一级节点的指针。在搜索过程中，通过查找相邻节点键来递归搜索元素。B+树用于在文件系统中存储数据。B+树在树中搜索节点时需要的I/O操作更少。扇出定义为指向B+树中节点子节点的节点数。B+树首先由鲁道夫·拜尔和爱德华·M·麦克雷特在技术论文中描述。
- en: The block-oriented storage context in B+ trees helps with the storage and efficient
    retrieval of data. The space efficiency of a B+ tree can be enhanced by using
    compression techniques. B+ trees belong to a family of multiway search trees.
    For a b-order B+ tree, space usage is of the order *O*(*n*). Inserting, finding,
    and removing operations are of the order *O*(*log[b]n*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: B+树中的面向块存储上下文有助于数据的存储和高效检索。通过使用压缩技术可以增强B+树的空间效率。B+树属于多路搜索树家族。对于b阶B+树，空间使用量是*n*的阶。插入、查找和删除操作是*b*的对数阶。
- en: B-tree
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B树
- en: The B-tree is a search tree with non-leaf nodes that only have keys, and the
    data is in the leaves. B-trees are used to reduce the number of disk accesses.
    The B-tree is a self-adjusting data structure that keeps data sorted. B-trees
    store keys in a sorted order for easy traversal. They can handle multiple insertions
    and deletions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: B树是一种搜索树，其非叶节点只包含键，而数据位于叶节点中。B树用于减少磁盘访问次数。B树是一种自我调整的数据结构，能够保持数据的排序。B树以排序顺序存储键，以便于遍历。它们可以处理多个插入和删除操作。
- en: Knuth initially came up with the concept of this data structure. B-trees consist
    of nodes that have at most *n* children. Every non-leaf node in the tree has at
    least *n*/2 child nodes. Rudolf Bayer and Edward M. McCreight were the first to
    implement this data structure in their work. B-trees are used in HFS and Reiser4
    filesystems to allow for quick access to any block in a file. On average, space
    usage is in the order of *O*(*n*). Insert, search, and delete operations are in
    the order of *O*(*log n*).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家高德纳（Knuth）最初提出了这种数据结构的概念。B树由最多有*n*个子节点的节点组成。树中的每个非叶节点至少有*n*/2个子节点。鲁道夫·拜尔（Rudolf
    Bayer）和爱德华·M·麦克雷特（Edward M. McCreight）首先在他们的工作中实现了这种数据结构。B树用于HFS和Reiser4文件系统，以便快速访问文件中的任何块。平均而言，空间使用量是*n*的阶。插入、搜索和删除操作是*n*的对数阶。
- en: T-tree
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: T树
- en: The T-tree is a balanced data structure that has both the index and actual data
    in memory. They are used in in-memory databases. T refers to the shape of the
    node. Each node consists of pointers to the parent node and the left and right
    child nodes. Each node in the tree node will have an ordered array of data pointers
    and extra control data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: T树是一种平衡的数据结构，它将索引和实际数据都存储在内存中。它们用于内存数据库。T指的是节点的形状。每个节点由指向父节点和左右子节点的指针组成。树中的每个节点都将有一个有序的数据指针数组和额外的控制数据。
- en: T-trees have similar performance benefits to in-memory tree structures. A T-tree
    is implemented on top of a self-balancing binary search tree. This data structure
    is good for ordered scanning of data. It supports various degrees of isolation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: T树与内存中的树结构具有相似的性能优势。T树是在自平衡二叉搜索树之上实现的。这种数据结构适合于有序扫描数据。它支持各种程度的隔离。
- en: Tables
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格
- en: As we already know, tables are used in data management and other areas. A table
    has a name and a header with the column names. Let's take a look at the different
    classes in tables such as the `Table` class, the `Row` class, the `Column` class,
    and the `PrintTable` method in the following sections.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，表格在数据管理和其他领域中被使用。一个表格有一个名称和包含列名的表头。让我们看看以下章节中表格的不同类，如`Table`类、`Row`类、`Column`类以及`PrintTable`方法。
- en: For this section, please refer to the `table.go` file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，请参考`table.go`文件。
- en: The Table class
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Table类
- en: 'A `Table` class has an array of rows and column names. The table''s `Name`
    is a string property in the `struct` class, as shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table`类有一个行数组和列名数组。表格的`Name`是`struct`类中的一个字符串属性，如下所示：'
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The Row class
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Row类
- en: 'The `Row` class has an array of columns and an `Id` integer, as shown in the
    following code. The `Id` instance is a unique identifier for a row:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Row`类有一个列数组和一个整型`Id`，如下面的代码所示。`Id`实例是行的唯一标识符：'
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The Column class
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Column类
- en: 'A `Column` class has an `Id` integer and a `Value string` that''s identified
    by a unique identifier, as presented in the following code snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Column`类有一个整型`Id`和一个由唯一标识符识别的`Value`字符串，如下面的代码片段所示：'
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The printTable method
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印表格方法
- en: 'In the following code snippet, the `printTable` method prints the rows and
    columns of a table. Rows are traversed, and then for every row the columns are
    printed:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`printTable`方法打印表格的行和列。遍历行，然后对于每一行打印列：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The main method
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main方法
- en: 'In this `main` method, we will instantiate the classes such as `Table`, `Row`,
    and `Column`, which we just took a look at. The `main` method creates a table
    and sets the name and column names. Columns are created with values. The columns
    are set on the rows after the rows are created. The table is printed by invoking
    the `printTable` method, as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`main`方法中，我们将实例化我们刚刚看到的类，如`Table`、`Row`和`Column`。`main`方法创建一个表格并设置名称和列名。列用值创建。在创建行之后，将列设置在行上。通过调用`printTable`方法打印表格，如下所示：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the following command to execute the `table.go` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`table.go`文件：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/6abf728c-176f-4ae0-a9ad-7e380ec43edf.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6abf728c-176f-4ae0-a9ad-7e380ec43edf.png)'
- en: The next section talks about the symbol table data structure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论符号表数据结构。
- en: Symbol tables
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号表
- en: A symbol table is present in memory during the program translation process.
    It can be present in program binaries. A symbol table contains the symbol's name,
    location, and address. In Go, the `gosym` package implements access to the Go
    symbol and line number tables. Go binaries generated by the GC compilers have
    the symbol and line number tables. A line table is a data structure that maps
    program counters to line numbers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序翻译过程中，内存中存在符号表。它也可以存在于程序二进制文件中。符号表包含符号的名称、位置和地址。在Go语言中，`gosym`包实现了对Go符号和行号表的访问。由GC编译器生成的Go二进制文件具有符号和行号表。行表是一种将程序计数器映射到行号的数据结构。
- en: Containers
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: The containers package provides access to the heap, list, and ring functionalities
    in Go. Containers are used in social networks, knowledge graphs, and other areas.
    Containers are lists, maps, slices, channels, heaps, queues, and treaps. Lists
    were introduced in [Chapter 1](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml), *Data
    Structures and Algorithms*. Maps and slices are built-in containers in Go. Channels
    in Go are called queues. A heap is a tree data structure. This data structure
    satisfies the heap property. A queue is modeled as a heap in [Chapter 3](6fc91a59-40ee-4183-8d13-2bbda917bf43.xhtml),
    *Linear Data Structures*. A treap is a mix of a tree and a heap. It is a binary
    tree with keys and values and a heap that maintains priorities.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 容器包提供了对Go中堆、列表和环形功能的访问。容器用于社交网络、知识图谱和其他领域。容器是列表、映射、切片、通道、堆、队列和treaps。列表在[第1章](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml)
    *数据结构和算法* 中介绍。映射和切片是Go中的内置容器。Go中的通道被称为队列。堆是一种树形数据结构。这种数据结构满足堆属性。队列在[第3章](6fc91a59-40ee-4183-8d13-2bbda917bf43.xhtml)
    *线性数据结构* 中被建模为堆。treap是树和堆的结合。它是一个具有键和值的二叉树，并维护一个堆来保持优先级。
- en: A ring is called a circular linked list and is presented in the next section. For
    this section, please refer to the `circular_list.go` file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 环被称为循环链表，将在下一节中介绍。对于本节，请参考`circular_list.go`文件。
- en: Circular linked list
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环链表
- en: 'A circular linked list is a data structure in which the last node is followed
    by the first node. The `container/ring` structures are used to model circular
    linked lists. An example implementation of a circular linked list is shown as
    follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表是一种数据结构，其中最后一个节点后面跟着第一个节点。使用`container/ring`结构来模拟循环链表。以下是一个循环链表的实现示例：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ring.New` method with the `len` *n* as a parameter creates a circular
    list of length *n*. The circular linked list is initialized with an integer array
    by moving through `circular_list` with the `Next` method. The `Do` method of `ring.Ring`
    class takes the element as an interface, and the element is printed as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数`len` *n* 的`ring.New`方法创建长度为*n*的循环列表。通过使用`Next`方法遍历`circular_list`，使用整数数组初始化循环链表。`ring.Ring`类的`Do`方法接受一个元素作为接口，并按以下方式打印元素：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The reverse of the circular list is traversed using the `Prev` method, and
    the value is printed in the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Prev`方法遍历循环列表的逆序，并在以下代码中打印其值：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the following code snippet, the circular list is moved two elements forward
    using the `Move` method, and the value is printed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，使用`Move`方法将循环列表向前移动两个元素，并打印其值：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the following command to execute the `circular_list.go` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`circular_list.go`文件：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/b101ef1d-7757-4631-bbc3-8555b8e7e5c6.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b101ef1d-7757-4631-bbc3-8555b8e7e5c6.png)'
- en: The next section talks about the `hash` function data structure.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论`hash`函数数据结构。
- en: The hash functions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希函数
- en: 'Hash functions are used in cryptography and other areas. These data structures
    are presented with code examples related to cryptography. There are two ways to
    implement a `hash` function in Go: with `crc32` or `sha256`. Marshaling (changing
    the string to an encoded form) saves the internal state, which is used for other
    purposes later. A `BinaryMarshaler` (converting the string into binary form) example
    is explained in this section:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数在密码学和其他领域中被使用。这些数据结构通过与密码学相关的代码示例进行展示。在Go语言中实现`hash`函数有两种方式：使用`crc32`或`sha256`。序列化（将字符串转换为编码形式）保存了内部状态，这将在以后用于其他目的。本节解释了`BinaryMarshaler`（将字符串转换为二进制形式）的示例：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `main` method creates a binary marshaled hash of two example strings. The
    hashes of the two strings are printed. The sum of the first hash is compared with
    the second hash using the equals method on bytes. This is shown in the following
    code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法创建了两个示例字符串的二进制序列化哈希。打印两个字符串的哈希值。使用字节上的equals方法比较第一个哈希的总和与第二个哈希。这在上面的代码中展示：'
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the following command to execute the `hash.go` file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`hash.go`文件：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/a01a751a-b265-447b-a1e5-233763aab419.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a01a751a-b265-447b-a1e5-233763aab419.png)'
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered trees, binary search trees, and AVL trees. Treap, B-trees,
    and B+ trees were explained briefly. Operations such as insertion, deletion, and
    updating elements in trees were shown with various code examples. Tables, containers,
    and hash functions were presented in the last section. The complexity in time
    and space for operations such as insertion, deletion, and search were explained
    in each section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了树、二叉搜索树和AVL树。简要解释了Treap、B树和B+树。通过各种代码示例展示了在树中进行插入、删除和更新元素的操作。在最后一节中介绍了表格、容器和哈希函数。在每个部分中解释了插入、删除和搜索等操作的时间和空间复杂度。
- en: In the next chapter, homogeneous data structures such as two-dimensional and
    multi- dimensional arrays will be covered.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将介绍二维和多维数组等齐次数据结构。
- en: Questions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can you give an example where you can use a binary search tree?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能给出一个可以使用二叉搜索树的例子吗？
- en: Which method is used to search for an element in a binary search tree?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在二叉搜索树中搜索元素使用的是哪个方法？
- en: Which techniques are used to adjust the balance in an AVL tree?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AVL树中调整平衡使用了哪些技术？
- en: What is a symbol table?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是符号表？
- en: Which class and method are called to generate a binary marshaled hash on the
    hash class?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哈希类中调用哪个类和方法来生成二进制序列化的哈希？
- en: Which container in Go is used to model a circular linked list?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go语言中哪个容器用于模拟循环链表？
- en: How do you create a JSON (indented) from a tree structure? Which class and method
    are used?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从树结构创建JSON（缩进）？使用了哪个类和方法？
- en: How do you compare the sum of hashes?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何比较哈希的总和？
- en: What is the balance factor in an AVL tree?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AVL树中的平衡因子是什么？
- en: How do you identify a row and column in a table?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在表格中识别行和列？
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following books are recommended if you want to know more about trees, binary
    search trees, and AVL trees:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于树、二叉搜索树和AVL树的内容，以下书籍推荐：
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式》，作者：Erich Gamma, Richard Helm, Ralph Johnson, 和 John Vlissides
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《算法导论（第三版）》，作者：Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, 和 Clifford
    Stein
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《数据结构与算法：简易入门》，作者：Rudolph Russell
