["```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n    \"fmt\"\n)\n\n// Node struct\ntype Node struct {\n    nextNode *Node\n    property rune\n}\n```", "```go\n// create List method\nfunc CreateLinkedList() *Node {\n    var headNode *Node\n    headNode = &Node{nil, 'a'}\n    var currNode *Node\n    currNode = headNode\n    var i rune\n    for i= 'b'; i <= 'z'; i++ {\n        var node *Node\n        node = &Node{nil, i}\n        currNode.nextNode = node\n        currNode = node\n    }\n    return headNode\n}\n```", "```go\n// Reverse List method\nfunc ReverseLinkedList(nodeList *Node) *Node {\n    var currNode *Node\n    currNode = nodeList\n    var topNode *Node = nil\n    for {\n        if currNode == nil {\n            break\n        }\n        var tempNode *Node\n        tempNode = currNode.nextNode\n        currNode.nextNode = topNode\n        topNode = currNode\n        currNode = tempNode\n    }\n    return topNode\n}\n```", "```go\n// main method\nfunc main() {\n    var linkedList = CreateLinkedList()\n    StringifyList(linkedList)\n    StringifyList(ReverseLinkedList(linkedList))\n}\n```", "```go\ngo run linked_list.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and list package\nimport (\n    \"container/list\"\n    \"fmt\"\n)\n\n// main method\nfunc main() {  \n    var linkedList *list.List\n    linkedList = list.New()\n    var element *list.Element\n    element = linkedList.PushBack(14)\n    var frontElement *list.Element\n    frontElement = linkedList.PushFront(1)\n    linkedList.InsertBefore(6, element)\n    linkedList.InsertAfter(5, frontElement)\n\n    var currElement *list.Element\n    for currElement = linkedList.Front(); currElement != nil; currElement = \n    currElement.Next() {\n        fmt.Println(currElement.Value)\n    }\n}\n```", "```go\ngo run double_linked_list.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n    \"fmt\"\n)\n\n//Circular Queue\ntype CircularQueue struct {\n    size int\n    nodes []interface{}\n    head int\n    last int\n}\n```", "```go\n// NewCircularQueue method\nfunc NewQueue(num int) *CircularQueue {\n    var circularQueue CircularQueue\n    circularQueue = CircularQueue{size: num + 1, head: 0, last: 0}\n    circularQueue.nodes = make([]interface{}, circularQueue.size)\n    return &circularQueue\n}\n```", "```go\n// IsUnUsed method\nfunc (circularQueue CircularQueue) IsUnUsed() bool {\n    return circularQueue.head == circularQueue.last\n}\n```", "```go\n// IsComplete method\nfunc (circularQueue CircularQueue) IsComplete() bool {\n    return circularQueue.head == (circularQueue.last+1)%circularQueue.size\n}\n```", "```go\n// Add method\nfunc (circularQueue *CircularQueue) Add(element interface{}) {\n    if circularQueue.IsComplete() {\n        panic(\"Queue is Completely Utilized\")\n    }\n    circularQueue.nodes[circularQueue.last] = element\n    circularQueue.last = (circularQueue.last + 1) % circularQueue.size\n}\n```", "```go\n//MoveOneStep method\nfunc (circularQueue *CircularQueue) MoveOneStep() (element interface{}) {\n    if circularQueue.IsUnUsed() {\n        return nil\n    }\n    element = circularQueue.nodes[circularQueue.head]\n    circularQueue.head = (circularQueue.head + 1) % circularQueue.size\n    return\n}\n```", "```go\n// main method\nfunc main() {\n   var circularQueue *CircularQueue\n   circularQueue = NewQueue(5)\n   circularQueue.Add(1)\n   circularQueue.Add(2)\n   circularQueue.Add(3)\n   circularQueue.Add(4)\n   circularQueue.Add(5)\n   fmt.Println(circularQueue.nodes)\n\n}\n```", "```go\ngo run circular_queue.go\n```", "```go\n<ol>\n    <li>Stones</li>\n    <li>Branches</li>\n    <li>Smoke</li>\n</ol>\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and sort package\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\n// class Employee\ntype Employee struct {\n    Name string\n    ID string\n    SSN int\n    Age int\n}\n```", "```go\n// ToString method\nfunc (employee Employee) ToString() string {\n    return fmt.Sprintf(\"%s: %d,%s,%d\", employee.Name, employee.Age,employee.ID, \n    employee.SSN)\n}\n```", "```go\n// SortByAge type\ntype SortByAge []Employee\n\n// SortByAge interface methods\nfunc (sortIntf SortByAge) Len() int { return len(sortIntf) }\nfunc (sortIntf SortByAge) Swap(i int, j int) { sortIntf[i], sortIntf[j] = sortIntf[j], sortIntf[i] }\nfunc (sortIntf SortByAge) Less(i int, j int) bool { return sortIntf[i].Age < sortIntf[j].Age }\n```", "```go\nfunc main() {\n    var employees = []Employee{\n        {\"Graham\",\"231\",235643,31},\n        {\"John\", \"3434\",245643,42},\n        {\"Michael\",\"8934\",32432, 17},\n        {\"Jenny\", \"24334\",32444,26},\n    }\n    fmt.Println(employees)\n    sort.Sort(SortByAge(employees))\n    fmt.Println(employees)\n    sort.Slice(employees, func(i int, j int) bool {\n        return employees[i].Age > employees[j].Age\n    })\n    fmt.Println(employees)\n}\n```", "```go\ngo run sort_slice.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and sort package\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\n// Mass and Miles Types\ntype Mass float64\ntype Miles float64\n```", "```go\n// Thing class\ntype Thing struct {\n    name string\n    mass Mass\n    distance Miles\n    meltingpoint int\n    freezingpoint int\n}\n```", "```go\n// ByFactor function type\ntype ByFactor func(Thing1 *Thing, Thing2 *Thing) bool\n```", "```go\n// Sort method \nfunc (byFactor ByFactor) Sort(Things []Thing) {\n    var sortedThings *ThingSorter\n    sortedThings = &ThingSorter{\n        Things: Things,\n        byFactor: byFactor, \n    }\n    sort.Sort(sortedThings)\n}\n```", "```go\n// ThingSorter class\ntype ThingSorter struct {\n    Things []Thing\n    byFactor func(Thing1 *Thing, Thing2 *Thing) bool \n}\n```", "```go\n// Len method\nfunc (ThingSorter *ThingSorter) Len() int {\n    return len(ThingSorter.Things)\n}\n\n// Swap method\nfunc (ThingSorter *ThingSorter) Swap(i int, j int) {\n    ThingSorter.Things[i], ThingSorter.Things[j] = ThingSorter.Things[j],    \n    ThingSorter.Things[i]\n}\n\n// Less method\nfunc (ThingSorter *ThingSorter) Less(i int, j int) bool {\n    return ThingSorter.byFactor(&ThingSorter.Things[i], &ThingSorter.Things[j])\n}\n```", "```go\n// Main method\nfunc main() {\n  var Things = []Thing{\n    {\"IronRod\", 0.055, 0.4, 3000, -180},\n    {\"SteelChair\", 0.815, 0.7, 4000, -209},\n    {\"CopperBowl\", 1.0, 1.0, 60, -30},\n    {\"BrassPot\", 0.107, 1.5, 10000, -456},\n  }\n\n  var name func(*Thing, *Thing) bool\n  name = func(Thing1 *Thing, Thing2 *Thing) bool {\n    return Thing1.name < Thing2.name\n  }\n  var mass func(*Thing, *Thing) bool\n  mass = func(Thing1 *Thing, Thing2 *Thing) bool {\n    return Thing1.mass < Thing2.mass\n  }\n  var distance func(*Thing, *Thing) bool\n  distance = func(Thing1 *Thing, Thing2 *Thing) bool {\n    return Thing1.distance < Thing2.distance\n  }\n  var decreasingDistance func(*Thing, *Thing) bool\n  decreasingDistance = func(p1, p2 *Thing) bool {\n    return distance(p2, p1)\n  }\n\n  ByFactor(name).Sort(Things)\n  fmt.Println(\"By name:\", Things)\n  ByFactor(mass).Sort(Things)\n  fmt.Println(\"By mass:\", Things)\n  ByFactor(distance).Sort(Things)\n  fmt.Println(\"By distance:\", Things)\n  ByFactor(decreasingDistance).Sort(Things)\n  fmt.Println(\"By decreasing distance:\", Things)\n}\n```", "```go\ngo run sort_keys.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and sort package\nimport (\n  \"fmt\"\n  \"sort\"\n)\n\n// A Commit is a record of code checking\ntype Commit struct {\n  username string\n  lang string\n  numlines int\n}\n```", "```go\ntype lessFunc func(p1 *Commit, p2 *Commit) bool\n// multiSorter class\ntype multiSorter struct {\n Commits []Commit\n lessFunction    []lessFunc\n}\n```", "```go\n// Sort method\nfunc (multiSorter *multiSorter) Sort(Commits []Commit) {\n    multiSorter.Commits = Commits\n    sort.Sort(multiSorter)\n}\n```", "```go\n// OrderedBy method\nfunc OrderedBy(lessFunction ...lessFunc) *multiSorter {\n  return &multiSorter{\n    lessFunction: lessFunction,\n  }\n}\n```", "```go\n// Len method\nfunc (multiSorter *multiSorter) Len() int {\n return len(multiSorter.Commits)\n}\n```", "```go\n// Swap method\nfunc (multiSorter *multiSorter) Swap(i int, j int) {\n  multiSorter.Commits[i] = multiSorter.Commits[j] \n  multiSorter.Commits[j] = multiSorter.Commits[i]\n}\n```", "```go\nfunc (multiSorter *multiSorter) Less(i int, j int) bool {\n\n  var p *Commit\n  var q *Commit\n  p = &multiSorter.Commits[i]\n  q = &multiSorter.Commits[j]\n\n  var k int\n  for k = 0; k < len(multiSorter.lessFunction)-1; k++ {\n    less := multiSorter.lessFunction[k]\n    switch {\n    case less(p, q):\n      return true\n    case less(q, p):\n      return false\n    }\n  }\n  return multiSorter.lessFunction[k](p, q)\n}\n```", "```go\n//main method\nfunc main() {\n  var Commits = []Commit{\n    {\"james\", \"Javascript\", 110},\n    {\"ritchie\", \"python\", 250},\n    {\"fletcher\", \"Go\", 300},\n    {\"ray\", \"Go\", 400},\n    {\"john\", \"Go\", 500},\n    {\"will\", \"Go\", 600},\n    {\"dan\", \"C++\", 500},\n    {\"sam\", \"Java\", 650},\n    {\"hayvard\", \"Smalltalk\", 180},\n  }\n  var user func(*Commit, *Commit) bool\n  user = func(c1 *Commit, c2 *Commit) bool {\n    return c1.username < c2.username\n  }\n  var language func(*Commit, *Commit) bool\n  language = func(c1 *Commit, c2 *Commit) bool {\n    return c1.lang < c2.lang\n  }\n  var increasingLines func(*Commit, *Commit) bool\n  increasingLines = func(c1 *Commit, c2 *Commit) bool {\n    return c1.numlines < c2.numlines\n  }\n  var decreasingLines func(*Commit, *Commit) bool\n  decreasingLines = func(c1 *Commit, c2 *Commit) bool {\n    return c1.numlines > c2.numlines // Note: > orders downwards.\n  }\n  OrderedBy(user).Sort(Commits)\n  fmt.Println(\"By username:\", Commits)\n  OrderedBy(user, increasingLines).Sort(Commits)\n  fmt.Println(\"By username,asc order\", Commits)\n  OrderedBy(user, decreasingLines).Sort(Commits)\n  fmt.Println(\"By username,desc order\", Commits)\n  OrderedBy(language, increasingLines).Sort(Commits)\n  fmt.Println(\"By lang,asc order\", Commits)\n  OrderedBy(language, decreasingLines, user).Sort(Commits)\n  fmt.Println(\"By lang,desc order\", Commits)\n}\n```", "```go\ngo run sort_multi_keys.go\n```", "```go\n<ul>\n    <li> First book </li>\n    <li> Second book </li>\n    <li> Third book </li>\n</ul>\n```", "```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n\n// importing fmt package\nimport (\n    \"fmt\"\n)\n\n//Node class\ntype Node struct {\n    property int\n    nextNode *Node\n}\n```", "```go\n// UnOrderedList class\ntype UnOrderedList struct {\n    headNode *Node\n}\n```", "```go\n//AddToHead method of UnOrderedList class\nfunc (UnOrderedList *UnOrderedList) AddToHead(property int) {\n  var node = &Node{}\n  node.property = property\n  node.nextNode = nil\n  if UnOrderedList.headNode != nil {\n    node.nextNode = UnOrderedList.headNode\n  }\n  UnOrderedList.headNode = node\n}\n```", "```go\n//IterateList method iterates over UnOrderedList\nfunc (UnOrderedList *UnOrderedList) IterateList() {\n  var node *Node\n  for node = UnOrderedList.headNode; node != nil; node = node.nextNode {\n    fmt.Println(node.property)\n  }\n}\n```", "```go\n// main method\nfunc main() {\n  var unOrderedList UnOrderedList\n  unOrderedList = UnOrderedList{}\n  unOrderedList.AddToHead(1)\n  unOrderedList.AddToHead(3)\n  unOrderedList.AddToHead(5)\n  unOrderedList.AddToHead(7)\n  unOrderedList.IterateList()\n}\n```", "```go\ngo run unordered_list.go\n```"]