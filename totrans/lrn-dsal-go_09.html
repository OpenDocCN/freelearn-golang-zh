<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dynamic Data Structures</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A <strong>dynamic data structure</strong> is a set of elements in memory that has the adaptability to expand or shrink. This ability empowers a software engineer to control precisely how much memory is used. Dynamic data structures are used for handling generic data in a key-value store. They can be used in distributed caching and storage management. Dynamic data structures are valuable in many circumstances in which dynamic addition or deletion of elements occur. They are comparable in capacity to a smaller relational database or an in-memory database. These data structures are used in marketing and customer relationship management applications. Dictionaries, TreeSets, and sequences are examples of dynamic data structures.</span></p>
<p>In this chapter, we will explain what dictionaries, TreeSets, and sequences are and show you how they are implemented with the help of code examples.  </p>
<p class="p3"><span class="s1">This chapter covers the following<span class="Apple-converted-space"> d</span>ynamic data structures:</span></p>
<ul>
<li class="li4"><span class="s3">Dictionaries</span></li>
<li class="li4"><span class="s3">TreeSets:</span>
<ul>
<li class="li4"><span class="s3">Synchronized TreeSets</span></li>
<li class="li4"><span class="s3">Mutable TreeSets</span></li>
</ul>
</li>
<li class="li4"><span class="s3">Sequences:</span>
<ul>
<li class="li4"><span class="s3">Farey</span></li>
<li class="li4"><span class="s3">Fibonacci</span></li>
<li class="li4"><span class="s3">Look-and-say</span></li>
<li class="li4"><span class="s3">Thue–Morse</span></li>
</ul>
</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">Install Go Version 1.10 from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> for your OS.</span></p>
<p class="p3"><span class="s1">The GitHub URL for the code in this chapter is as follows: <a href="https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter07">https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter07</a></span>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dictionaries</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1"><span>A <strong>dictionary</strong> is a collection of unique key and</span><span class="Apple-converted-space"> </span><span>value pairs. </span><span>A dictionary is a broadly useful data structure for storing a set of data items. It has a key, and each key has a solitary item associated with it. When given a key, the dictionary will restore the item associated with that key. These keys can be of any type: strings, integers, or objects. Where we need to sort a list, an element value can be retrieved utilizing its key.</span> Add, remove, modify, and lookup operations are allowed in this collection.</span> <span class="s1">A dictionary is similar to other data structures, such as hash, map, and HashMap. The key/value store is used in distributed caching and in memory databases.</span> <span class="s1">Arrays differ from dictionaries in how the data is accessed. A set has unique items, whereas a dictionary can have duplicate values.</span></p>
<p><span>Dictionary data structures are used in the following streams:</span></p>
<ul>
<li><span>Phone directories</span></li>
<li><span>Router tables in networking</span></li>
<li><span>Page tables in operating systems</span></li>
<li><span>Symbol tables in compilers</span></li>
<li><span>Genome maps in biology</span></li>
</ul>
<p class="p8"><span class="s1">The following code shows how to initialize and modify a dictionary. </span><span>In this snippet, the dictionary has the key <kbd>DictKey</kbd> and is a string:</span></p>
<pre class="p10">//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>"fmt"<br/>  "sync"<br/>)<br/><br/>// DictKey type<br/>type DictKey string</pre>
<p class="mce-root"><span>The following sections talk about the type and methods in dictionaries.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">DictVal type</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">The dictionary has the value <kbd>DictVal</kbd> of type <kbd>string</kbd> mapped to <kbd>DictKey</kbd>:</span></p>
<pre class="p10">// DictVal type<br/>type DictVal string</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dictionary class</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">The dictionary in the following code is a class with <span>dictionary </span>elements, with <kbd>DictKey</kbd> <span>as the key </span>and <kbd>DictVal</kbd> as the value. It has a </span><span><kbd>sync.RWMutex</kbd> </span><span>property, <kbd>lock</kbd>:</span></p>
<pre>// Dictionary class<br/>type Dictionary struct {<br/>    elements map[DictKey]DictVal<br/>    lock sync.RWMutex<br/>}</pre>
<p class="mce-root"><span>The </span><kbd>Put</kbd><span>, </span><kbd>Remove</kbd><span>, </span><kbd>Contain</kbd><span>, </span><kbd>Find</kbd><span>, </span><kbd>Rest</kbd><span>, </span><kbd>NumberofElements</kbd><span>, <kbd>GetKeys</kbd>, <kbd>GetValues</kbd></span>, <span>and <kbd>Main</kbd> methods are discussed in the following sections.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Put method</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">A has a <kbd>Put</kbd> method, as shown in the following example, that takes the <kbd>key</kbd> and <kbd>value</kbd> <span>parameters </span>of the <kbd>DictKey</kbd> and <kbd>DictVal</kbd> types respectively. The <kbd>Lock</kbd> <span>method </span>of the dictionary's <kbd>lock</kbd> instance is invoked, and the <kbd>Unlock</kbd> method is deferred.<span class="Apple-converted-space"> </span>If there are empty <kbd>map</kbd> elements in the dictionary, elements are initialized using <kbd>make</kbd>. The <kbd>map</kbd> elements are set with a <kbd>key</kbd> and a <kbd>value</kbd> if they are not empty:</span></p>
<pre>// Put method<br/>func (dict *Dictionary) Put(key DictKey, value DictVal) {<br/>    dict.lock.Lock()<br/>    defer dict.lock.Unlock()<br/>    if dict.elements == nil {<br/>        dict.elements = make(map[DictKey]DictVal)<br/>    }<br/>    dict.elements[key] = value<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The example output of the <kbd>put</kbd> method is as follows. The <kbd>put</kbd> method takes the <span class="packt_screen">key 1</span> and <span class="packt_screen">value 1</span>. The <kbd>map</kbd> is updated with <kbd>key</kbd> and <kbd>value</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1530c681-3097-46cc-862a-9762725f2f80.png" width="333" height="47"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Remove method</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">A dictionary has a <kbd>remove</kbd> method, as shown in the following code, which has a <kbd>key</kbd> <span>parameter </span>of the <kbd>DictKey</kbd> type. This method returns a <kbd>bool</kbd> value if the</span> value <span class="s1">associated with <kbd>Dictkey</kbd> is removed from the </span>map<span class="s1">:</span></p>
<pre>// Remove method<br/>func (dict *Dictionary) Remove(key DictKey) bool {<br/>    dict.lock.Lock()<br/>    defer dict.lock.Unlock()<br/>    var exists bool<br/>    _, exists = dict.elements[key]<br/>    if exists {<br/>        delete(dict.elements, key)<br/>    }<br/>    return exists<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Contains method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>In the following code,</span><span class="Apple-converted-space"> the </span><span><kbd>Contains</kbd> method has an input parameter, <kbd>key</kbd>, of the <kbd>DictKey</kbd> type, and returns <kbd>bool</kbd> if <kbd>key</kbd> exists in the dictionary:</span></p>
<pre>// Contains method<br/>func (dict *Dictionary) Contains(key DictKey) bool {<br/>    dict.lock.RLock()<br/>    defer dict.lock.RUnlock()<br/>    var exists bool<br/>    _, exists = dict.elements[key]<br/>    return exists<br/>}</pre>
<p> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Find method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The <kbd>Find</kbd> method takes the <kbd>key</kbd> parameter of the <kbd>DictKey</kbd> type and returns the <kbd>DictVal</kbd> type associated with the key.</span> <span>The following code snippet explains the <kbd>Find</kbd> method:</span></p>
<pre class="p10">// Find method<br/>func (dict *Dictionary) Find(key DictKey) DictVal {<br/>    dict.lock.RLock()<br/>    defer dict.lock.RUnlock()<br/>    return dict.elements[key]<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reset method</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">The <kbd>Reset</kbd> method<span class="Apple-converted-space"> </span>of the <kbd>Dictionary</kbd> class is presented in the following snippet. <span class="Apple-converted-space"><span>The <kbd>Lock</kbd> </span><span>method </span><span>of the dictionary's <kbd>lock</kbd> instance</span></span> is invoked and <kbd>Unlock</kbd> is deferred.<span class="Apple-converted-space"> </span>The <kbd>elements</kbd> map is initialized with a <kbd>map</kbd> of<span class="Apple-converted-space"> the <span><kbd>DictKey</kbd> </span></span>key and the <span><kbd>DictVal</kbd> </span>value:</span></p>
<pre>// Reset method<br/>func (dict *Dictionary) Reset() {<br/>    dict.lock.Lock()<br/>    defer dict.lock.Unlock()<br/>    dict.elements = make(map[DictKey]DictVal)<br/>}<br/><br/></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">NumberOfElements method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The <kbd>NumberOfElements</kbd> method of the <kbd>Dictionary</kbd> class returns the length of the <kbd>elements</kbd> map. The <kbd>RLock</kbd> method of the <kbd>lock</kbd> instance is invoked. The <kbd>RUnlock</kbd> method of the <kbd>lock</kbd> instance is deferred before returning the length; this is shown in the following code snippet:</span></p>
<pre>// NumberOfElements method<br/>func (dict *Dictionary) NumberOfElements() int {<br/>    dict.lock.RLock()<br/>    defer dict.lock.RUnlock()<br/>    return len(dict.elements)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GetKeys method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The <kbd>GetKeys</kbd> method of the <kbd>Dictionary</kbd> class is shown in the following code snippet. The method returns the array of the <kbd>DictKey</kbd> elements. The <kbd>RLock</kbd> method of the lock instance is invoked, and the <kbd>RUnlock</kbd> method is deferred. The dictionary keys are returned by traversing the element's map:</span></p>
<pre>// GetKeys method<br/>func (dict *Dictionary) GetKeys() []DictKey {<br/>    dict.lock.RLock()<br/>    defer dict.lock.RUnlock()<br/>    var dictKeys []DictKey<br/>    dictKeys = []DictKey{}<br/>    var key DictKey<br/>    for key = range dict.elements {<br/>        dictKeys = append(dictKeys, key)<br/>    }<br/>    return dictKeys<br/>}<br/><br/></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GetValues method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The <kbd>GetValues</kbd> method of the <kbd>Dictionary</kbd> class returns the array of the <kbd>DictVal</kbd> elements. In the following code snippet, the <kbd>RLock</kbd> method of the <kbd>lock</kbd> instance is invoked and the <kbd>RUnlock</kbd> method is deferred.</span><span class="Apple-converted-space"> </span><span>The array of dictionary values is returned after traversing the element's map:</span></p>
<pre>// GetValues method <br/>func (dict *Dictionary) GetValues() []DictVal {<br/>    dict.lock.RLock()<br/>    defer dict.lock.RUnlock()<br/>    var dictValues []DictVal<br/>    dictValues = []DictVal{}<br/>    var key DictKey<br/>    for key = range dict.elements {<br/>        dictValues = append(dictValues, dict.elements[key])<br/>    }<br/>    return dictValues<br/>}<br/><br/></pre>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The following code shows the main method, where the dictionary is initialized and printed:</span></p>
<pre>// main method<br/>func main() {<br/>  var dict *Dictionary = &amp;Dictionary{}<br/>  dict.Put("1","1")<br/>  dict.Put("2","2")<br/>  dict.Put("3","3")<br/>  dict.Put("4","4")<br/>  fmt.Println(dict)<br/>}</pre>
<p class="p3"><span class="s1">Run the following commands <span>to execute the <kbd>dictionary.go</kbd> file</span>:</span></p>
<pre class="p10"><strong><span class="s1">go run dictionary.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c54f4a35-f573-4d58-b8fd-16b6e1319ae1.png" style="width:30.00em;height:5.83em;" width="580" height="113"/></p>
<p><span>Let's take a look at the <kbd>TreeSet</kbd> data structure in the following section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">TreeSets</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1"><strong>TreeSets</strong> are used in marketing and customer relationship management applications. <kbd>TreeSet</kbd> is a set that has a binary tree with unique elements. The elements are sorted in a natural order. In the following code snippet, <kbd>TreeSet</kbd> creation, insertion, search, and <kbd>stringify</kbd> operations are presented. <kbd>TreeSet</kbd> allows only one null value if the set is empty. The elements are sorted and stored as elements.</span> The <kbd>add</kbd><span class="s1">, <kbd>remove</kbd>, and</span> <kbd>contains</kbd> <span class="s1">functions cost <em>log</em>(<em>n</em>) on <kbd>TreeSets</kbd>:</span></p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// TreeSet class<br/>type TreeSet struct {<br/>  bst *BinarySearchTree<br/>}</pre>
<p>We will discuss the different <kbd>TreeSet</kbd> methods in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">InsertTreeNode method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The <kbd>InsertTreeNode</kbd> method of the <kbd>TreeSet</kbd> class takes <kbd>treeNodes</kbd> variable arguments of the <kbd>TreeNode</kbd> type. In the following code, the elements with the <kbd>key</kbd> and <kbd>value</kbd> are inserted in the binary search tree of <kbd>TreeSet</kbd>:</span></p>
<pre>// InsertTreeNode method<br/>func (treeset *TreeSet) InsertTreeNode(treeNodes ...TreeNode) {<br/>  var treeNode TreeNode<br/>  for _, treeNode = range treeNodes {<br/>    treeset.bst.InsertElement(treeNode.key, treeNode.value)<br/>  }<br/>}</pre>
<p>The example output of the <kbd>InsertTreeNode</kbd> method is as follows. The <kbd>InsertTreeNode</kbd> method takes <kbd>treeNodes</kbd> as the parameter. <kbd>treeNodes</kbd> are inserted with <kbd>rootNode</kbd>, which has a value of <kbd>8</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9dedad06-c40b-4e8b-8e6a-7e8626550c6f.png" style="width:39.17em;height:13.92em;" width="583" height="206"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Delete method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>Delete</kbd> method of the <kbd>TreeSet</kbd> class is shown in the following code snippet. In this method, <kbd>treeNodes</kbd> with the provided key are removed:</span></p>
<pre>// Delete method<br/>func (treeset *TreeSet) Delete(treeNodes ...TreeNode) {<br/>  var treeNode TreeNode<br/>  for _, treeNode = range treeNodes {<br/>    treeset.bst.RemoveNode(treeNode.key)<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">InOrderTraverseTree method</h1>
                </header>
            
            <article>
                
<p>The <kbd>InOrderTraverseTree</kbd> method of the <kbd>BinarySearchTree</kbd> class takes <kbd>function</kbd> as a parameter. The <kbd>RLock</kbd> method of the <kbd>lock</kbd> instance is invoked. The <kbd>RUnlock</kbd> method of the tree's <kbd>lock</kbd> instance is deferred. <kbd>InOrderTraverseTree</kbd> is invoked with the <kbd>rootNode</kbd> of the tree and function as parameters:</p>
<pre>//InOrderTraverseTree method<br/>func (tree *BinarySearchTree) InOrderTraverseTree(function func(int)) {<br/>  tree.lock.RLock()<br/>  defer tree.lock.RUnlock()<br/>  inOrderTraverseTree(tree.rootNode, function)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The inOrderTraverseTree method</h1>
                </header>
            
            <article>
                
<p>The <kbd>inOrderTraverseTree</kbd> method traverses from the left of the tree to root of the node and then to the right of the tree. The <kbd>inOrderTraverseTree</kbd> method takes <kbd>treeNode</kbd> and <kbd>function</kbd> as <span>parameters</span>. The method recursively calls the <kbd>inOrderTraverseTree</kbd> method with <kbd>function</kbd> and then <kbd>leftNode</kbd> and <kbd>rightNode</kbd> in separate calls. The <kbd>function</kbd> method is invoked with the <kbd>value</kbd> of <kbd>treeNode</kbd>:</p>
<pre>// inOrderTraverseTree method<br/>func inOrderTraverseTree(treeNode *TreeNode, function func(int)) {<br/>  if treeNode != nil {<br/>    inOrderTraverseTree(treeNode.leftNode, function)<br/>    function(treeNode.value)<br/>    inOrderTraverseTree(treeNode.rightNode, function)<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PreOrderTraverseTree method</h1>
                </header>
            
            <article>
                
<p>The <kbd>PreOrderTraverseTree</kbd> method of the <kbd>BinarySearchTree</kbd> class takes the function as its parameter. The <kbd>Lock</kbd> method on the tree's <kbd>lock</kbd> instance is invoked first, and the <kbd>Unlock</kbd> method is deferred. The <kbd>PreOrderTraverseTree</kbd> method is called with the <kbd>rootNode</kbd> of the tree and function as parameters:</p>
<pre>// PreOrderTraverse method<br/>func (tree *BinarySearchTree) PreOrderTraverseTree(function func(int)) {<br/>  tree.lock.Lock()<br/>  defer tree.lock.Unlock()<br/>  preOrderTraverseTree(tree.rootNode, function)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The preOrderTraverseTree method</h1>
                </header>
            
            <article>
                
<p>The <kbd>preOrderTraverseTree</kbd> method traverses the tree from the root, to the left and right of the tree. The <kbd>preOrderTraverseTree</kbd> method takes <kbd>treeNode</kbd> and <kbd>function</kbd> as parameters. If <kbd>treeNode</kbd> is not <kbd>nil</kbd>, <kbd>function</kbd> is invoked with the <kbd>value</kbd> of <kbd>treeNode</kbd>, and the <kbd>preOrderTraverseTree</kbd> method is invoked with <kbd>function</kbd> and <kbd>leftNode</kbd> and <kbd>rightNode</kbd> as parameters:</p>
<pre>// preOrderTraverseTree method<br/>func preOrderTraverseTree(treeNode *TreeNode, function func(int)) {<br/>  if treeNode != nil {<br/>    function(treeNode.value)<br/>    preOrderTraverseTree(treeNode.leftNode, function)<br/>    preOrderTraverseTree(treeNode.rightNode, function)<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Search method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The <kbd>Search</kbd> method of the <kbd>TreeSet</kbd> class takes a variable argument named <kbd>treeNodes</kbd> of the <kbd>TreeNode</kbd> type and returns true if one of those <kbd>treeNodes</kbd> exists; otherwise, it returns <kbd>false</kbd>. The code following snippet outlines the <kbd>Search</kbd> method:</span></p>
<pre>// Search method<br/>func (treeset *TreeSet) Search(treeNodes ...TreeNode) bool {<br/>  var treeNode TreeNode<br/>  var exists bool<br/>  for _, treeNode = range treeNodes {<br/>    if exists = treeset.bst.SearchNode(treeNode.key); !exists {<br/>      return false<br/>    }<br/>  }<br/>  return true<br/>}<br/><br/></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The String method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>In the following code snippet, the <kbd>String</kbd> method</span><span class="Apple-converted-space"> </span><span>of the <kbd>TreeSet</kbd> class returns the string version of <kbd>bst</kbd>:</span></p>
<pre class="p10">// String method<br/>func (treeset *TreeSet) String() {<br/>  treeset.bst.String()<br/>}<br/><br/></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">The <kbd>main</kbd> method in the <kbd>TreeSet</kbd> class creates a <kbd>TreeSet</kbd> with</span> <kbd>TreeNodes</kbd><span class="s1">. The following snippet creates a <kbd>TreeSet</kbd> and invokes the <kbd>String</kbd> method:</span></p>
<pre>// main method<br/>func main() {<br/>  var treeset *TreeSet = &amp;TreeSet{}<br/>  treeset.bst = &amp;BinarySearchTree{}<br/>  var node1 TreeNode = TreeNode{8,8, nil,nil}<br/>  var node2 TreeNode = TreeNode{3,3,nil, nil}<br/>  var node3 TreeNode = TreeNode{10,10,nil,nil}<br/>  var node4 TreeNode = TreeNode{1,1,nil,nil}<br/>  var node5 TreeNode = TreeNode{6,6,nil,nil}<br/>  treeset.InsertTreeNode(node1,node2,node3, node4, node5)<br/>  treeset.String()<br/>}</pre>
<p class="p3"><span class="s1">Run the following commands <span>to execute the <kbd>treeset.go</kbd> and <kbd>binarysearchtree.go</kbd> files</span>:</span></p>
<pre class="p10"><span class="s1"><strong>$ go build treeset.go binarysearchtree.go</strong><br/><strong>$ ./treeset</strong></span></pre>
<p class="p10"><span>The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/76ae2280-d1ba-46d3-811a-71e9be2026d9.png" width="574" height="191"/></p>
<p><span>The next section talks about the synchronized <kbd>TreeSet</kbd> data structure.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Synchronized TreeSets</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">Operations that are performed on synchronized TreeSets are synchronized across multiple calls that access the elements of TreeSets.</span> <span class="s3">Synchronization in TreeSets is achieved using a <kbd>sync.RWMutex</kbd> lock. The <kbd>lock</kbd> method on the tree's <kbd>lock</kbd> instance is invoked, and the unlock method is deferred before the <kbd>tree</kbd> nodes are <span>inserted, deleted, or updated:</span></span></p>
<pre>// InsertElement method<br/>func (tree *BinarySearchTree) InsertElement(key int, value int) {<br/>  tree.lock.Lock()<br/>  defer tree.lock.Unlock()<br/>  var treeNode *TreeNode<br/>  treeNode = &amp;TreeNode{key, value, nil, nil}<br/>  if tree.rootNode == nil {<br/>    tree.rootNode = treeNode<br/>  } else {<br/>    insertTreeNode(tree.rootNode, treeNode)<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mutable TreeSets</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1"><strong>Mutable TreeSets</strong> can use <kbd>add</kbd>, <kbd>update</kbd>, and <kbd>delete</kbd> operations on the tree and its nodes. <kbd>insertTreeNode</kbd> updates the tree by taking the <kbd>rootNode</kbd> and <kbd>treeNode</kbd> <span>parameters </span>to be updated. The following code snippet shows how to insert a <kbd>TreeNode</kbd> with a given <kbd>rootNode</kbd> and <kbd>TreeNode</kbd>:</span></p>
<pre>// insertTreeNode method<br/>func insertTreeNode(rootNode *TreeNode, newTreeNode *TreeNode) {<br/>  if newTreeNode.key &lt; rootNode.key {<br/>    if rootNode.leftNode == nil {<br/>      rootNode.leftNode = newTreeNode<br/>    } else {<br/>      insertTreeNode(rootNode.leftNode, newTreeNode)<br/>    }<br/>  } else {<br/>    if rootNode.rightNode == nil {<br/>      rootNode.rightNode = newTreeNode<br/>    } else {<br/>      insertTreeNode(rootNode.rightNode, newTreeNode)<br/>    }<br/>  }<br/>}<br/><br/></pre>
<p class="mce-root">Let's discuss the different mutable TreeSets in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">RemoveNode method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The <kbd>RemoveNode</kbd> method of a <kbd>BinarySearchTree</kbd> is as follows:</span></p>
<pre>// RemoveNode method<br/>func (tree *BinarySearchTree) RemoveNode(key int) {<br/>  tree.lock.Lock()<br/>  defer tree.lock.Unlock()<br/>  removeNode(tree.rootNode, key)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Treeset.bst</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">The</span> TreeNode's <span class="s1">can be updated by accessing <kbd>treeset.bst</kbd> and traversing the binary search tree from the <kbd>rootNode</kbd> and the left and right<span class="Apple-converted-space"> n</span>odes of <kbd>rootNode</kbd>, as shown here:</span></p>
<pre>  var treeset *TreeSet = &amp;TreeSet{}<br/>  treeset.bst = &amp;BinarySearchTree{} <br/>  var node1 TreeNode = TreeNode{8, 8, nil, nil}<br/>  var node2 TreeNode = TreeNode{3, 3, nil, nil}<br/>  var node3 TreeNode = TreeNode{10, 10, nil, nil}<br/>  var node4 TreeNode = TreeNode{1, 1, nil, nil}<br/>  var node5 TreeNode = TreeNode{6, 6, nil, nil}<br/>  treeset.InsertTreeNode(node1, node2, node3, node4, node5)<br/>  treeset.String()</pre>
<p class="mce-root">In the next section, we will take a look at sequences.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sequences</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A <strong>sequence</strong> is a set of numbers that are grouped in a particular order. The number of elements in the stream can be infinite, and these sequences are called <strong>streams</strong>. A <strong>subsequence</strong> is a sequence that's created from another sequence. The relative positions of the elements in a subsequence will remain the same after deleting some of the elements in a sequence.</span></p>
<p>In the following sections, we will take a look at different sequences such as the Farey sequence, Fibonacci sequence, look-and-say, and Thue–Morse.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Farey sequence</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A <strong>Farey sequence</strong> consists of reduced fractions with values between zero and one. The denominators of the fractions are less than or equal to <em>m</em>, and organized in ascending order. This sequence is called a <strong>Farey series</strong>.<span class="Apple-converted-space"> </span>In the following code, reduced fractions are displayed:</span></p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/><br/>// fraction class<br/>type fraction struct {<br/>  numerator int<br/>  denominator int<br/>}</pre>
<p class="mce-root">Let's take a look at the different methods in a Farey sequence.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">String method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The <kbd>fraction</kbd> class has</span><span class="Apple-converted-space"> <span>the numerator and denominator </span></span><span>integer properties. The <kbd>String</kbd> method of the <kbd>fraction</kbd> class, as shown in the following snippet, returns a <kbd>string</kbd> version of <kbd>fraction</kbd>:</span></p>
<pre>// string method of fraction class<br/>func (frac fraction) String() string {<br/>  return fmt.Sprintf("%d/%d", frac.numerator, frac.denominator)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The g method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>g</kbd> method takes two fractions and prints the series of reduced fractions. The <kbd>g</kbd> <span>function </span>takes an <span><kbd>l</kbd> or an <kbd>r</kbd> fraction, and <kbd>num</kbd> int as </span>arguments to print the reduced fraction as a series. The following code snippet shows the <kbd>g</kbd> method:</span></p>
<pre>// g method<br/>func g(l fraction, r fraction, num int) {<br/>  var frac fraction<br/>  frac = fraction{l.numerator + r.numerator, l.denominator + r.denominator}<br/>  if frac.denominator &lt;= num {<br/>    g(l, frac, num)<br/>    fmt.Print(frac, " ")<br/>    g(frac, r, num)<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The following snippet shows the <kbd>main</kbd> method. In the <kbd>main</kbd> method,</span><span class="Apple-converted-space"> </span><span>reduced fraction series are printed using recursion:</span></p>
<pre>// main method<br/>func main() {<br/> var num int<br/> var l fraction<br/> var r fraction<br/> for num = 1; num &lt;= 11; num++ {<br/> l = fraction{0, 1}<br/> r = fraction{1, 1}<br/> fmt.Printf("F(%d): %s ", num, l)<br/> g(l, r, num)<br/> fmt.Println(r)<br/> }</pre>
<p class="p10"><span>Run the following command to execute the <kbd>farey_sequence.go</kbd> file:</span></p>
<pre class="p10"><strong><span class="s1">go run farey_sequence.go</span></strong></pre>
<p class="p8"><span class="s3">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c72f8003-7a5f-45f4-9e18-c45224a1cfa0.png" style="width:31.33em;height:24.00em;" width="574" height="438"/></p>
<p><span>The next section talks about the Fibonacci sequence data structure.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Fibonacci sequence</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <strong>Fibonacci sequence</strong> consists of a list of numbers in which every number is the sum of the two preceding numbers. Pingala, in 200 BC, was the first to come up with Fibonacci numbers. The Fibonacci sequence is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/244bad99-448a-4695-948d-357f09cd675c.png" style="width:17.00em;height:1.00em;" width="3060" height="180"/></p>
<p>The recurrence relation for the Fibonacci sequence is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/3f724d68-7f38-468d-b3e7-36c2381890de.png" style="width:9.00em;height:1.17em;" width="1460" height="190"/></p>
<p>The seed values are as follows:</p>
<p class="CDPAlignCenter CDPAlign"> <img class="fm-editor-equation" src="Images/e6795ba4-2732-44a7-9f12-9c97322bd705.png" style="width:8.17em;height:1.25em;" width="1170" height="180"/></p>
<p>A Fibonacci prime is a Fibonacci number that is a prime number. The Fibonacci prime series is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/78c47dff-13da-4d31-8cdb-8bd652511823.png" style="width:20.67em;height:1.17em;" width="3390" height="180"/></p>
<p>Computer algorithms such as the Fibonacci search technique, heap, and cubes are popular applications of Fibonacci numbers. Pseudorandom number generators use Fibonacci numbers.</p>
<p class="p3"><span class="s1">The following code snippet </span><span class="s1">shows the Fibonacci sequence and recursive Fibonacci number calculation. The</span> <kbd>Series</kbd> <span class="s1">function is presented as well. The <kbd>Series</kbd> function calculates the Fibonacci numbers in the sequence:</span></p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt and strconv package<br/>import (<br/>  "fmt"<br/>  "strconv"<br/>)<br/><br/>// Series method<br/>func Series(n int) int {<br/>  var f []int<br/>  f = make([]int, n+1, n+2)<br/>  if n &lt; 2 {<br/>    f = f[0:2]<br/>  }<br/>  f[0] = 0<br/>  f[1] = 1<br/>  var i int<br/>  for i = 2; i &lt;= n; i++ {<br/>    f[i] = f[i-1] + f[i-2]<br/>  }<br/>  return f[n]<br/>}</pre>
<p class="mce-root">The different methods of the Fibonacci sequence are discussed in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">FibonacciNumber method</h1>
                </header>
            
            <article>
                
<p class="p10"><span>The <kbd>FibonacciNumber</kbd> method takes the integer <em>n</em> and, by recursion, calculates the Fibonacci numbers.</span><span class="Apple-converted-space"> </span><span>The following code snippet shows this recursion:</span></p>
<pre>// FibonacciNumber method<br/>func FibonacciNumber(n int) int {<br/>  if n &lt;= 1 {<br/>    return n<br/>  }<br/>  return FibonacciNumber(n-1) + FibonacciNumber(n-2)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Main method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>main</kbd> method in the following code snippet shows how the Fibonacci sequence is calculated:</span></p>
<pre>// main method<br/>func main() {<br/> var i int<br/> for i = 0; i &lt;= 9; i++ {<br/> fmt.Print(strconv.Itoa(Series(i)) + " ")<br/> }<br/> fmt.Println("")<br/> for i = 0; i &lt;= 9; i++ {<br/> fmt.Print(strconv.Itoa(FibonacciNumber(i)) + " ")<br/> }<br/> fmt.Println("")<br/>}</pre>
<p class="p3"><span class="s1">Run the following command to execute the <kbd>fibonacci_sequence.go</kbd> file:</span></p>
<pre class="p10"><strong><span class="s1">go run fibonacci_sequence.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f49528c1-7e69-4f7b-b10f-48f275b0c28b.png" style="width:37.00em;height:9.25em;" width="595" height="148"/></p>
<p><span>The next section talks about the look-and-say data structure.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Look-and-say</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">The <strong>look-and-say</strong> sequence is a sequence of<span class="Apple-converted-space"> </span>integers:</span></p>
<p class="p8 CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/c17bb938-f6e8-40e9-91dc-13a0c6e0bc43.png" style="width:17.25em;height:1.08em;" width="2860" height="180"/></p>
<p class="p8"><span class="s1">The sequence is generated by counting the digits of the previous number in the group. John Conway initially coined the term <em>look-and-say sequence</em>.</span></p>
<p class="p8"><span class="s1">The look-and-say sequence is shown in the following code. The <kbd>look_say</kbd> method takes a string as a parameter and returns a look-and-say sequence of integers:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt and strconv package<br/>import (<br/>  "fmt"<br/>  "strconv"<br/>)<br/><br/>// look_say method<br/>func look_say(str string) (rstr string) {<br/>  var cbyte byte<br/>  cbyte = str[0]<br/>  var inc int<br/>  inc = 1<br/>  var i int<br/>  for i = 1; i &lt; len(str); i++ {<br/>    var dbyte byte<br/>    dbyte = str[i]<br/>    if dbyte == cbyte {<br/>      inc++<br/>      continue<br/>    }<br/>    rstr = rstr + strconv.Itoa(inc) + string(cbyte)<br/>    cbyte = dbyte<br/>    inc = 1<br/>  }<br/>  return rstr + strconv.Itoa(inc) + string(cbyte)<br/>}</pre>
<p class="p10"><span>The <kbd>main</kbd> method initializes the string and invokes the <kbd>look_say</kbd> method. The look-and-say sequence that is returned from the method is printed:</span></p>
<pre>// main method<br/>func main() {<br/>  var str string<br/>  str = "1"<br/>  fmt.Println(str)<br/>  var i int<br/>  for i = 0; i &lt; 8; i++ {<br/>    str = look_say(str)<br/>    fmt.Println(str)<br/>  }<br/>}</pre>
<p class="p10"><span>Run the following command to execute the <kbd>look_say.go</kbd> file:</span></p>
<pre class="p10"><strong><span class="s1">go run look_say.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d41da3c7-166d-4737-815f-65f0ccc42675.png" style="width:37.33em;height:13.42em;" width="573" height="205"/></p>
<p class="mce-root"/>
<p class="mce-root"><span>The next section talks about the Thue–Morse data structure.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Thue–Morse</h1>
                </header>
            
            <article>
                
<p class="p8"><span class="s1">The <strong>Thue–Morse</strong> sequence is a binary sequence starting at zero that appends the Boolean complement of the current sequence.</span></p>
<p class="p8"><span class="s1">The Thue–Morse sequence<span class="Apple-converted-space"> is as follows</span>:</span></p>
<p class="p13 CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="Images/7ed548d8-0e9f-4d5f-bd8e-3fd071d603a4.png" style="width:29.25em;height:1.50em;" width="3510" height="180"/></p>
<p class="p13"><span class="s1">The Thue–Morse sequence was applied by Eugene Prophet<span class="Apple-converted-space"> </span>and used by Axel Thue in the study of combinatorics on words. The Thue–Morse sequence is used in the area of fractal curves, such as Koch snowflakes.</span></p>
<p class="p13"><span class="s1">The following code snippet creates the Thue–Morse sequence. The <kbd>ThueMorseSequence</kbd> <span>function </span>takes a <kbd>bytes.Buffer</kbd> instance buffer and modifies the buffer to the Thue–Morse sequence by applying the <kbd>complement</kbd> operation on the <kbd>bytes</kbd>:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt and bytes package<br/>import (<br/> "bytes"<br/> "fmt"<br/>)<br/><br/>// ThueMorseSequence method<br/>func ThueMorseSequence(buffer *bytes.Buffer) {<br/><br/> var b int<br/> var currLength int<br/> var currBytes []byte<br/> for b, currLength, currBytes = 0, buffer.Len(), buffer.Bytes(); b &lt; currLength; b++ {<br/> if currBytes[b] == '1' {<br/> buffer.WriteByte('0')<br/> } else {<br/> buffer.WriteByte('1')<br/> }<br/> }<br/>}</pre>
<p class="p10"><span>The <kbd>main</kbd> method initializes the sequence number as <kbd>0</kbd>.</span><span class="Apple-converted-space"> </span><span>The <kbd>ThueMorseSequence</kbd> method takes the pointer to the <kbd>bytes.Buffer</kbd> and modifies it by invoking the <kbd>ThueMorseSequence</kbd> method. The resulting sequence is printed on the Terminal:</span></p>
<pre>// main method<br/>func main() {<br/> var buffer bytes.Buffer<br/> // initial sequence member is "0"<br/> buffer.WriteByte('0')<br/> fmt.Println(buffer.String())<br/> var i int<br/> for i = 2; i &lt;= 7; i++ {<br/> ThueMorseSequence(&amp;buffer)<br/> fmt.Println(buffer.String())<br/> }<br/>}</pre>
<p class="p10"><span>Run the following command to execute the <kbd>thue_morse.go</kbd> file:</span></p>
<pre class="p10"><strong><span class="s1">go run thue_morse.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8e0cc4d8-63cc-42bc-b78b-a230d2ca9400.png" width="578" height="186"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">This chapter covered the</span> <span class="s1"><kbd>contains</kbd>, <kbd>put</kbd>, <kbd>remove</kbd>, <kbd>find</kbd>, <kbd>reset</kbd>,</span> <kbd>NumberOfElements</kbd><span class="s1">,</span> <kbd>getKeys</kbd><span class="s1">, and <kbd>getValues</kbd></span> <span class="s1">methods of the dictionary data structure. The <kbd>InsertTreeNode</kbd>, <kbd>Delete</kbd>, <kbd>Search</kbd>, and <kbd>stringify</kbd><span class="Apple-converted-space"> </span></span><span>TreeSet operations</span><span> have been </span><span>explained in detail, and code examples were provided. The <kbd>BinarySearchTree</kbd> structure has been presented in code, along with the <kbd>InsertElement</kbd>, <kbd>InOrderTraversal</kbd>, <kbd>PreOrderTraverseTree</kbd>, <kbd>SearchNode</kbd>, and <kbd>RemoveNode</kbd> functions.</span></p>
<p class="p8"><span class="s1">The next chapter covers algorithms such as sorting, searching, recursion, and hashing.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol class="ol1">
<li class="li16"><span class="s3">How do you ensure a <kbd>BinarySearch<span class="Apple-converted-space">T</span>ree</kbd> is synchronized?</span></li>
<li class="li16"><span class="s3">Which method is called to postpone the invocation of a function?</span></li>
<li class="li16"><span class="s3">How do you define dictionary keys and values with custom types?</span></li>
<li class="li16"><span class="s3">How do you find the length of a map?</span></li>
<li class="li16"><span class="s3">What keyword is used to traverse a list of<span class="Apple-converted-space"> </span><kbd>treeNodes</kbd> in a tree?</span></li>
<li class="li16"><span class="s3">In a Farey sequence, what are the real numbers in the series called?</span></li>
<li class="li16"><span class="s3">What is a Fibonacci number?</span></li>
<li class="li16"><span class="s3">How do you convert an integer into a string?</span></li>
<li class="li16"><span class="s3">What method is used to convert a byte into a string?</span></li>
<li class="li16"><span class="s3">What method is called to add elements to a dictionary?</span></li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="p19"><span class="s1">The following books are recommended if you want to learn more about dynamic data structures:</span></p>
<ul>
<li><em>Design Patterns</em>, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides</li>
<li><em>Introduction to Algorithms – Thi<span>rd Edition</span></em>, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein</li>
<li><em>Data structures and Algorithms: An Easy Introduction</em>, by Rudolph Russell</li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>