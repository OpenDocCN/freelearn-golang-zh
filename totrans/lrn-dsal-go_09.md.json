["```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n\"fmt\"\n  \"sync\"\n)\n\n// DictKey type\ntype DictKey string\n```", "```go\n// DictVal type\ntype DictVal string\n```", "```go\n// Dictionary class\ntype Dictionary struct {\n    elements map[DictKey]DictVal\n    lock sync.RWMutex\n}\n```", "```go\n// Put method\nfunc (dict *Dictionary) Put(key DictKey, value DictVal) {\n    dict.lock.Lock()\n    defer dict.lock.Unlock()\n    if dict.elements == nil {\n        dict.elements = make(map[DictKey]DictVal)\n    }\n    dict.elements[key] = value\n}\n```", "```go\n// Remove method\nfunc (dict *Dictionary) Remove(key DictKey) bool {\n    dict.lock.Lock()\n    defer dict.lock.Unlock()\n    var exists bool\n    _, exists = dict.elements[key]\n    if exists {\n        delete(dict.elements, key)\n    }\n    return exists\n}\n```", "```go\n// Contains method\nfunc (dict *Dictionary) Contains(key DictKey) bool {\n    dict.lock.RLock()\n    defer dict.lock.RUnlock()\n    var exists bool\n    _, exists = dict.elements[key]\n    return exists\n}\n```", "```go\n// Find method\nfunc (dict *Dictionary) Find(key DictKey) DictVal {\n    dict.lock.RLock()\n    defer dict.lock.RUnlock()\n    return dict.elements[key]\n}\n```", "```go\n// Reset method\nfunc (dict *Dictionary) Reset() {\n    dict.lock.Lock()\n    defer dict.lock.Unlock()\n    dict.elements = make(map[DictKey]DictVal)\n}\n\n```", "```go\n// NumberOfElements method\nfunc (dict *Dictionary) NumberOfElements() int {\n    dict.lock.RLock()\n    defer dict.lock.RUnlock()\n    return len(dict.elements)\n}\n```", "```go\n// GetKeys method\nfunc (dict *Dictionary) GetKeys() []DictKey {\n    dict.lock.RLock()\n    defer dict.lock.RUnlock()\n    var dictKeys []DictKey\n    dictKeys = []DictKey{}\n    var key DictKey\n    for key = range dict.elements {\n        dictKeys = append(dictKeys, key)\n    }\n    return dictKeys\n}\n\n```", "```go\n// GetValues method \nfunc (dict *Dictionary) GetValues() []DictVal {\n    dict.lock.RLock()\n    defer dict.lock.RUnlock()\n    var dictValues []DictVal\n    dictValues = []DictVal{}\n    var key DictKey\n    for key = range dict.elements {\n        dictValues = append(dictValues, dict.elements[key])\n    }\n    return dictValues\n}\n\n```", "```go\n// main method\nfunc main() {\n  var dict *Dictionary = &Dictionary{}\n  dict.Put(\"1\",\"1\")\n  dict.Put(\"2\",\"2\")\n  dict.Put(\"3\",\"3\")\n  dict.Put(\"4\",\"4\")\n  fmt.Println(dict)\n}\n```", "```go\ngo run dictionary.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// TreeSet class\ntype TreeSet struct {\n  bst *BinarySearchTree\n}\n```", "```go\n// InsertTreeNode method\nfunc (treeset *TreeSet) InsertTreeNode(treeNodes ...TreeNode) {\n  var treeNode TreeNode\n  for _, treeNode = range treeNodes {\n    treeset.bst.InsertElement(treeNode.key, treeNode.value)\n  }\n}\n```", "```go\n// Delete method\nfunc (treeset *TreeSet) Delete(treeNodes ...TreeNode) {\n  var treeNode TreeNode\n  for _, treeNode = range treeNodes {\n    treeset.bst.RemoveNode(treeNode.key)\n  }\n}\n```", "```go\n//InOrderTraverseTree method\nfunc (tree *BinarySearchTree) InOrderTraverseTree(function func(int)) {\n  tree.lock.RLock()\n  defer tree.lock.RUnlock()\n  inOrderTraverseTree(tree.rootNode, function)\n}\n```", "```go\n// inOrderTraverseTree method\nfunc inOrderTraverseTree(treeNode *TreeNode, function func(int)) {\n  if treeNode != nil {\n    inOrderTraverseTree(treeNode.leftNode, function)\n    function(treeNode.value)\n    inOrderTraverseTree(treeNode.rightNode, function)\n  }\n}\n```", "```go\n// PreOrderTraverse method\nfunc (tree *BinarySearchTree) PreOrderTraverseTree(function func(int)) {\n  tree.lock.Lock()\n  defer tree.lock.Unlock()\n  preOrderTraverseTree(tree.rootNode, function)\n}\n```", "```go\n// preOrderTraverseTree method\nfunc preOrderTraverseTree(treeNode *TreeNode, function func(int)) {\n  if treeNode != nil {\n    function(treeNode.value)\n    preOrderTraverseTree(treeNode.leftNode, function)\n    preOrderTraverseTree(treeNode.rightNode, function)\n  }\n}\n```", "```go\n// Search method\nfunc (treeset *TreeSet) Search(treeNodes ...TreeNode) bool {\n  var treeNode TreeNode\n  var exists bool\n  for _, treeNode = range treeNodes {\n    if exists = treeset.bst.SearchNode(treeNode.key); !exists {\n      return false\n    }\n  }\n  return true\n}\n\n```", "```go\n// String method\nfunc (treeset *TreeSet) String() {\n  treeset.bst.String()\n}\n\n```", "```go\n// main method\nfunc main() {\n  var treeset *TreeSet = &TreeSet{}\n  treeset.bst = &BinarySearchTree{}\n  var node1 TreeNode = TreeNode{8,8, nil,nil}\n  var node2 TreeNode = TreeNode{3,3,nil, nil}\n  var node3 TreeNode = TreeNode{10,10,nil,nil}\n  var node4 TreeNode = TreeNode{1,1,nil,nil}\n  var node5 TreeNode = TreeNode{6,6,nil,nil}\n  treeset.InsertTreeNode(node1,node2,node3, node4, node5)\n  treeset.String()\n}\n```", "```go\n$ go build treeset.go binarysearchtree.go\n$ ./treeset\n```", "```go\n// InsertElement method\nfunc (tree *BinarySearchTree) InsertElement(key int, value int) {\n  tree.lock.Lock()\n  defer tree.lock.Unlock()\n  var treeNode *TreeNode\n  treeNode = &TreeNode{key, value, nil, nil}\n  if tree.rootNode == nil {\n    tree.rootNode = treeNode\n  } else {\n    insertTreeNode(tree.rootNode, treeNode)\n  }\n}\n```", "```go\n// insertTreeNode method\nfunc insertTreeNode(rootNode *TreeNode, newTreeNode *TreeNode) {\n  if newTreeNode.key < rootNode.key {\n    if rootNode.leftNode == nil {\n      rootNode.leftNode = newTreeNode\n    } else {\n      insertTreeNode(rootNode.leftNode, newTreeNode)\n    }\n  } else {\n    if rootNode.rightNode == nil {\n      rootNode.rightNode = newTreeNode\n    } else {\n      insertTreeNode(rootNode.rightNode, newTreeNode)\n    }\n  }\n}\n\n```", "```go\n// RemoveNode method\nfunc (tree *BinarySearchTree) RemoveNode(key int) {\n  tree.lock.Lock()\n  defer tree.lock.Unlock()\n  removeNode(tree.rootNode, key)\n}\n```", "```go\n  var treeset *TreeSet = &TreeSet{}\n  treeset.bst = &BinarySearchTree{} \n  var node1 TreeNode = TreeNode{8, 8, nil, nil}\n  var node2 TreeNode = TreeNode{3, 3, nil, nil}\n  var node3 TreeNode = TreeNode{10, 10, nil, nil}\n  var node4 TreeNode = TreeNode{1, 1, nil, nil}\n  var node5 TreeNode = TreeNode{6, 6, nil, nil}\n  treeset.InsertTreeNode(node1, node2, node3, node4, node5)\n  treeset.String()\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n// importing fmt package\nimport (\n  \"fmt\"\n)\n\n// fraction class\ntype fraction struct {\n  numerator int\n  denominator int\n}\n```", "```go\n// string method of fraction class\nfunc (frac fraction) String() string {\n  return fmt.Sprintf(\"%d/%d\", frac.numerator, frac.denominator)\n}\n```", "```go\n// g method\nfunc g(l fraction, r fraction, num int) {\n  var frac fraction\n  frac = fraction{l.numerator + r.numerator, l.denominator + r.denominator}\n  if frac.denominator <= num {\n    g(l, frac, num)\n    fmt.Print(frac, \" \")\n    g(frac, r, num)\n  }\n}\n```", "```go\n// main method\nfunc main() {\n var num int\n var l fraction\n var r fraction\n for num = 1; num <= 11; num++ {\n l = fraction{0, 1}\n r = fraction{1, 1}\n fmt.Printf(\"F(%d): %s \", num, l)\n g(l, r, num)\n fmt.Println(r)\n }\n```", "```go\ngo run farey_sequence.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and strconv package\nimport (\n  \"fmt\"\n  \"strconv\"\n)\n\n// Series method\nfunc Series(n int) int {\n  var f []int\n  f = make([]int, n+1, n+2)\n  if n < 2 {\n    f = f[0:2]\n  }\n  f[0] = 0\n  f[1] = 1\n  var i int\n  for i = 2; i <= n; i++ {\n    f[i] = f[i-1] + f[i-2]\n  }\n  return f[n]\n}\n```", "```go\n// FibonacciNumber method\nfunc FibonacciNumber(n int) int {\n  if n <= 1 {\n    return n\n  }\n  return FibonacciNumber(n-1) + FibonacciNumber(n-2)\n}\n```", "```go\n// main method\nfunc main() {\n var i int\n for i = 0; i <= 9; i++ {\n fmt.Print(strconv.Itoa(Series(i)) + \" \")\n }\n fmt.Println(\"\")\n for i = 0; i <= 9; i++ {\n fmt.Print(strconv.Itoa(FibonacciNumber(i)) + \" \")\n }\n fmt.Println(\"\")\n}\n```", "```go\ngo run fibonacci_sequence.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and strconv package\nimport (\n  \"fmt\"\n  \"strconv\"\n)\n\n// look_say method\nfunc look_say(str string) (rstr string) {\n  var cbyte byte\n  cbyte = str[0]\n  var inc int\n  inc = 1\n  var i int\n  for i = 1; i < len(str); i++ {\n    var dbyte byte\n    dbyte = str[i]\n    if dbyte == cbyte {\n      inc++\n      continue\n    }\n    rstr = rstr + strconv.Itoa(inc) + string(cbyte)\n    cbyte = dbyte\n    inc = 1\n  }\n  return rstr + strconv.Itoa(inc) + string(cbyte)\n}\n```", "```go\n// main method\nfunc main() {\n  var str string\n  str = \"1\"\n  fmt.Println(str)\n  var i int\n  for i = 0; i < 8; i++ {\n    str = look_say(str)\n    fmt.Println(str)\n  }\n}\n```", "```go\ngo run look_say.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and bytes package\nimport (\n \"bytes\"\n \"fmt\"\n)\n\n// ThueMorseSequence method\nfunc ThueMorseSequence(buffer *bytes.Buffer) {\n\n var b int\n var currLength int\n var currBytes []byte\n for b, currLength, currBytes = 0, buffer.Len(), buffer.Bytes(); b < currLength; b++ {\n if currBytes[b] == '1' {\n buffer.WriteByte('0')\n } else {\n buffer.WriteByte('1')\n }\n }\n}\n```", "```go\n// main method\nfunc main() {\n var buffer bytes.Buffer\n // initial sequence member is \"0\"\n buffer.WriteByte('0')\n fmt.Println(buffer.String())\n var i int\n for i = 2; i <= 7; i++ {\n ThueMorseSequence(&buffer)\n fmt.Println(buffer.String())\n }\n}\n```", "```go\ngo run thue_morse.go\n```"]