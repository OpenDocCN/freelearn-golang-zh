- en: Dynamic Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **dynamic data structure** is a set of elements in memory that has the adaptability
    to expand or shrink. This ability empowers a software engineer to control precisely
    how much memory is used. Dynamic data structures are used for handling generic
    data in a key-value store. They can be used in distributed caching and storage
    management. Dynamic data structures are valuable in many circumstances in which
    dynamic addition or deletion of elements occur. They are comparable in capacity
    to a smaller relational database or an in-memory database. These data structures
    are used in marketing and customer relationship management applications. Dictionaries,
    TreeSets, and sequences are examples of dynamic data structures.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explain what dictionaries, TreeSets, and sequences
    are and show you how they are implemented with the help of code examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following dynamic data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TreeSets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronized TreeSets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable TreeSets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sequences:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Farey
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fibonacci
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Look-and-say
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thue–Morse
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install Go Version 1.10 from [https://golang.org/doc/install](https://golang.org/doc/install) for
    your OS.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub URL for the code in this chapter is as follows: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **dictionary** is a collection of unique key and value pairs. A dictionary
    is a broadly useful data structure for storing a set of data items. It has a key,
    and each key has a solitary item associated with it. When given a key, the dictionary
    will restore the item associated with that key. These keys can be of any type:
    strings, integers, or objects. Where we need to sort a list, an element value
    can be retrieved utilizing its key. Add, remove, modify, and lookup operations
    are allowed in this collection. A dictionary is similar to other data structures,
    such as hash, map, and HashMap. The key/value store is used in distributed caching
    and in memory databases. Arrays differ from dictionaries in how the data is accessed.
    A set has unique items, whereas a dictionary can have duplicate values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionary data structures are used in the following streams:'
  prefs: []
  type: TYPE_NORMAL
- en: Phone directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router tables in networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page tables in operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol tables in compilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Genome maps in biology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how to initialize and modify a dictionary. In this
    snippet, the dictionary has the key `DictKey` and is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The following sections talk about the type and methods in dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: DictVal type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dictionary has the value `DictVal` of type `string` mapped to `DictKey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dictionary in the following code is a class with dictionary elements, with
    `DictKey` as the key and `DictVal` as the value. It has a `sync.RWMutex` property, `lock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Put`, `Remove`, `Contain`, `Find`, `Rest`, `NumberofElements`, `GetKeys`,
    `GetValues`, and `Main` methods are discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Put method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A has a `Put` method, as shown in the following example, that takes the `key`
    and `value` parameters of the `DictKey` and `DictVal` types respectively. The
    `Lock` method of the dictionary''s `lock` instance is invoked, and the `Unlock`
    method is deferred. If there are empty `map` elements in the dictionary, elements
    are initialized using `make`. The `map` elements are set with a `key` and a `value`
    if they are not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output of the `put` method is as follows. The `put` method takes
    the key 1 and value 1\. The `map` is updated with `key` and `value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1530c681-3097-46cc-862a-9762725f2f80.png)'
  prefs: []
  type: TYPE_IMG
- en: Remove method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A dictionary has a `remove` method, as shown in the following code, which has
    a `key` parameter of the `DictKey` type. This method returns a `bool` value if
    the value associated with `Dictkey` is removed from the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Contains method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, the `Contains` method has an input parameter, `key`,
    of the `DictKey` type, and returns `bool` if `key` exists in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Find method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Find` method takes the `key` parameter of the `DictKey` type and returns
    the `DictVal` type associated with the key. The following code snippet explains
    the `Find` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Reset method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Reset` method of the `Dictionary` class is presented in the following
    snippet. The `Lock` method of the dictionary''s `lock` instance is invoked and
    `Unlock` is deferred. The `elements` map is initialized with a `map` of the `DictKey` key
    and the `DictVal` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: NumberOfElements method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NumberOfElements` method of the `Dictionary` class returns the length
    of the `elements` map. The `RLock` method of the `lock` instance is invoked. The
    `RUnlock` method of the `lock` instance is deferred before returning the length;
    this is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: GetKeys method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GetKeys` method of the `Dictionary` class is shown in the following code
    snippet. The method returns the array of the `DictKey` elements. The `RLock` method
    of the lock instance is invoked, and the `RUnlock` method is deferred. The dictionary
    keys are returned by traversing the element''s map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: GetValues method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GetValues` method of the `Dictionary` class returns the array of the `DictVal`
    elements. In the following code snippet, the `RLock` method of the `lock` instance
    is invoked and the `RUnlock` method is deferred. The array of dictionary values
    is returned after traversing the element''s map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code shows the main method, where the dictionary is initialized
    and printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands to execute the `dictionary.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c54f4a35-f573-4d58-b8fd-16b6e1319ae1.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the `TreeSet` data structure in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: TreeSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TreeSets** are used in marketing and customer relationship management applications.
    `TreeSet` is a set that has a binary tree with unique elements. The elements are
    sorted in a natural order. In the following code snippet, `TreeSet` creation,
    insertion, search, and `stringify` operations are presented. `TreeSet` allows
    only one null value if the set is empty. The elements are sorted and stored as
    elements. The `add`, `remove`, and `contains` functions cost *log*(*n*) on `TreeSets`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss the different `TreeSet` methods in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: InsertTreeNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `InsertTreeNode` method of the `TreeSet` class takes `treeNodes` variable
    arguments of the `TreeNode` type. In the following code, the elements with the
    `key` and `value` are inserted in the binary search tree of `TreeSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output of the `InsertTreeNode` method is as follows. The `InsertTreeNode`
    method takes `treeNodes` as the parameter. `treeNodes` are inserted with `rootNode`,
    which has a value of `8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dedad06-c40b-4e8b-8e6a-7e8626550c6f.png)'
  prefs: []
  type: TYPE_IMG
- en: Delete method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Delete` method of the `TreeSet` class is shown in the following code snippet.
    In this method, `treeNodes` with the provided key are removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: InOrderTraverseTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `InOrderTraverseTree` method of the `BinarySearchTree` class takes `function`
    as a parameter. The `RLock` method of the `lock` instance is invoked. The `RUnlock`
    method of the tree''s `lock` instance is deferred. `InOrderTraverseTree` is invoked
    with the `rootNode` of the tree and function as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The inOrderTraverseTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `inOrderTraverseTree` method traverses from the left of the tree to root
    of the node and then to the right of the tree. The `inOrderTraverseTree` method
    takes `treeNode` and `function` as parameters. The method recursively calls the
    `inOrderTraverseTree` method with `function` and then `leftNode` and `rightNode`
    in separate calls. The `function` method is invoked with the `value` of `treeNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: PreOrderTraverseTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `PreOrderTraverseTree` method of the `BinarySearchTree` class takes the
    function as its parameter. The `Lock` method on the tree''s `lock` instance is
    invoked first, and the `Unlock` method is deferred. The `PreOrderTraverseTree`
    method is called with the `rootNode` of the tree and function as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preOrderTraverseTree method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `preOrderTraverseTree` method traverses the tree from the root, to the
    left and right of the tree. The `preOrderTraverseTree` method takes `treeNode`
    and `function` as parameters. If `treeNode` is not `nil`, `function` is invoked
    with the `value` of `treeNode`, and the `preOrderTraverseTree` method is invoked
    with `function` and `leftNode` and `rightNode` as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Search method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Search` method of the `TreeSet` class takes a variable argument named
    `treeNodes` of the `TreeNode` type and returns true if one of those `treeNodes`
    exists; otherwise, it returns `false`. The code following snippet outlines the
    `Search` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The String method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `String` method of the `TreeSet` class returns
    the string version of `bst`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method in the `TreeSet` class creates a `TreeSet` with `TreeNodes`.
    The following snippet creates a `TreeSet` and invokes the `String` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands to execute the `treeset.go` and `binarysearchtree.go`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76ae2280-d1ba-46d3-811a-71e9be2026d9.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about the synchronized `TreeSet` data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronized TreeSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operations that are performed on synchronized TreeSets are synchronized across
    multiple calls that access the elements of TreeSets. Synchronization in TreeSets
    is achieved using a `sync.RWMutex` lock. The `lock` method on the tree''s `lock`
    instance is invoked, and the unlock method is deferred before the `tree` nodes
    are inserted, deleted, or updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Mutable TreeSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mutable TreeSets** can use `add`, `update`, and `delete` operations on the
    tree and its nodes. `insertTreeNode` updates the tree by taking the `rootNode`
    and `treeNode` parameters to be updated. The following code snippet shows how
    to insert a `TreeNode` with a given `rootNode` and `TreeNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss the different mutable TreeSets in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: RemoveNode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RemoveNode` method of a `BinarySearchTree` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Treeset.bst
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TreeNode''s can be updated by accessing `treeset.bst` and traversing the
    binary search tree from the `rootNode` and the left and right nodes of `rootNode`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will take a look at sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **sequence** is a set of numbers that are grouped in a particular order. The
    number of elements in the stream can be infinite, and these sequences are called
    **streams**. A **subsequence** is a sequence that's created from another sequence.
    The relative positions of the elements in a subsequence will remain the same after
    deleting some of the elements in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will take a look at different sequences such as
    the Farey sequence, Fibonacci sequence, look-and-say, and Thue–Morse.
  prefs: []
  type: TYPE_NORMAL
- en: Farey sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **Farey sequence** consists of reduced fractions with values between zero
    and one. The denominators of the fractions are less than or equal to *m*, and
    organized in ascending order. This sequence is called a **Farey series**. In the
    following code, reduced fractions are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the different methods in a Farey sequence.
  prefs: []
  type: TYPE_NORMAL
- en: String method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fraction` class has the numerator and denominator integer properties.
    The `String` method of the `fraction` class, as shown in the following snippet,
    returns a `string` version of `fraction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The g method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `g` method takes two fractions and prints the series of reduced fractions.
    The `g` function takes an `l` or an `r` fraction, and `num` int as arguments to
    print the reduced fraction as a series. The following code snippet shows the `g`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following snippet shows the `main` method. In the `main` method, reduced
    fraction series are printed using recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `farey_sequence.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c72f8003-7a5f-45f4-9e18-c45224a1cfa0.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about the Fibonacci sequence data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Fibonacci sequence** consists of a list of numbers in which every number
    is the sum of the two preceding numbers. Pingala, in 200 BC, was the first to
    come up with Fibonacci numbers. The Fibonacci sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/244bad99-448a-4695-948d-357f09cd675c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The recurrence relation for the Fibonacci sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f724d68-7f38-468d-b3e7-36c2381890de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The seed values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6795ba4-2732-44a7-9f12-9c97322bd705.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A Fibonacci prime is a Fibonacci number that is a prime number. The Fibonacci
    prime series is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78c47dff-13da-4d31-8cdb-8bd652511823.png)'
  prefs: []
  type: TYPE_IMG
- en: Computer algorithms such as the Fibonacci search technique, heap, and cubes
    are popular applications of Fibonacci numbers. Pseudorandom number generators
    use Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the Fibonacci sequence and recursive Fibonacci
    number calculation. The `Series` function is presented as well. The `Series` function
    calculates the Fibonacci numbers in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The different methods of the Fibonacci sequence are discussed in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: FibonacciNumber method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FibonacciNumber` method takes the integer *n* and, by recursion, calculates
    the Fibonacci numbers. The following code snippet shows this recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method in the following code snippet shows how the Fibonacci sequence
    is calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `fibonacci_sequence.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f49528c1-7e69-4f7b-b10f-48f275b0c28b.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about the look-and-say data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Look-and-say
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **look-and-say** sequence is a sequence of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c17bb938-f6e8-40e9-91dc-13a0c6e0bc43.png)'
  prefs: []
  type: TYPE_IMG
- en: The sequence is generated by counting the digits of the previous number in the
    group. John Conway initially coined the term *look-and-say sequence*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The look-and-say sequence is shown in the following code. The `look_say` method
    takes a string as a parameter and returns a look-and-say sequence of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method initializes the string and invokes the `look_say` method.
    The look-and-say sequence that is returned from the method is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `look_say.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d41da3c7-166d-4737-815f-65f0ccc42675.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about the Thue–Morse data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Thue–Morse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Thue–Morse** sequence is a binary sequence starting at zero that appends
    the Boolean complement of the current sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Thue–Morse sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ed548d8-0e9f-4d5f-bd8e-3fd071d603a4.png)'
  prefs: []
  type: TYPE_IMG
- en: The Thue–Morse sequence was applied by Eugene Prophet and used by Axel Thue
    in the study of combinatorics on words. The Thue–Morse sequence is used in the
    area of fractal curves, such as Koch snowflakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet creates the Thue–Morse sequence. The `ThueMorseSequence`
    function takes a `bytes.Buffer` instance buffer and modifies the buffer to the
    Thue–Morse sequence by applying the `complement` operation on the `bytes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method initializes the sequence number as `0`. The `ThueMorseSequence`
    method takes the pointer to the `bytes.Buffer` and modifies it by invoking the
    `ThueMorseSequence` method. The resulting sequence is printed on the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `thue_morse.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e0cc4d8-63cc-42bc-b78b-a230d2ca9400.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the `contains`, `put`, `remove`, `find`, `reset`, `NumberOfElements`,
    `getKeys`, and `getValues` methods of the dictionary data structure. The `InsertTreeNode`,
    `Delete`, `Search`, and `stringify` TreeSet operations have been explained in
    detail, and code examples were provided. The `BinarySearchTree` structure has
    been presented in code, along with the `InsertElement`, `InOrderTraversal`, `PreOrderTraverseTree`,
    `SearchNode`, and `RemoveNode` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers algorithms such as sorting, searching, recursion, and
    hashing.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you ensure a `BinarySearchTree` is synchronized?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method is called to postpone the invocation of a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you define dictionary keys and values with custom types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you find the length of a map?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What keyword is used to traverse a list of `treeNodes` in a tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a Farey sequence, what are the real numbers in the series called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Fibonacci number?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you convert an integer into a string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method is used to convert a byte into a string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method is called to add elements to a dictionary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following books are recommended if you want to learn more about dynamic
    data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
