<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Classic Algorithms</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">Classic algorithms are used in the areas of data search and cryptography. Sorting, searching, recursing, and hashing algorithms are good examples of classic algorithms. Sorting algorithms are used to order elements into<span> </span><span>either an ascending or descending</span><span> key arrangement. These algorithms are frequently used to canonicalize data and to create readable content.</span> Search algorithms are used to find an element in a set</span><span>. A recursive algorithm is one that calls itself with input items. A hashing algorithm is a cryptographic hash technique. It is a scientific calculation that maps data with a subjective size to a hash with a settled size. It's intended to be a single direction function, that you cannot alter.</span></p>
<p>In this chapter, we will cover the different classic algorithms and explain them with suitable examples.</p>
<p class="p3"><span>This chapter covers the following algorithms:</span></p>
<ul>
<li class="li3"><span class="s1">Sorting:</span>
<ul>
<li><span>Bubble</span></li>
<li><span>Selection</span></li>
<li><span>Insertion</span></li>
<li><span>Shell</span></li>
<li><span>Merge</span></li>
<li><span>Quick</span></li>
</ul>
</li>
<li class="li3"><span class="s1">Searching:</span>
<ul>
<li><span>Linear</span></li>
<li><span>Sequential</span></li>
<li><span>Binary</span></li>
<li><span>Interpolation</span></li>
</ul>
</li>
<li class="li3"><span class="s1">Recursion</span></li>
<li class="li3"><span class="s1">Hashing</span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">Install Go version 1.10 from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> for your OS.</span></p>
<p class="p3"><span class="s4">The GitHub URL for the code in this chapter is as follows: <a href="https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter08">https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter08</a></span>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sorting</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">Sorting algorithms arrange the elements in a collection in<span class="Apple-converted-space"> </span>ascending or descending order. Lexicographical order can be applied to a collection of characters and strings. The efficiency of these algorithms is in the performance of sorting the input data into a sorted collection. The best sorting algorithm time complexity is <em>O</em>(<em>n log n</em>). Sorting algorithms are classified by the following criteria:</span></p>
<ul>
<li>Computational complexity</li>
<li>Memory usage</li>
<li>Stability</li>
<li>Type of sorting: serial/parallel</li>
<li>Adaptability</li>
<li>Method of sorting</li>
</ul>
<p class="mce-root">In the following sections, we'll look at the different sorting algorithms, that is, bubble, selection, insertion, shell, merge, and quick.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bubble</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The bubble sort algorithm is a sorting algorithm that compares a pair of neighboring elements and swaps them if they are in the wrong order. The algorithm has a complexity of <em>O</em>(<em>n</em><sup>2</sup>), where n is the number of elements to be sorted. The smallest or greatest value bubbles up to the top of the collection, or the smallest or greatest sinks to the bottom (depending on whether you're sorting into ascending or descending order).</span></p>
<p class="p5"><span class="s1">The following code snippet shows the implementation of the bubble sort algorithm. The <kbd>bubbleSorter</kbd> function takes an integer array and sorts the array's elements in ascending order. </span></p>
<p class="mce-root"/>
<p class="p5"><span>The <kbd>main</kbd> method initializes the array's integers and invokes the <kbd>bubbleSorter</kbd> function, as follows:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt and bytes package<br/>import (<br/>  "fmt"<br/>)<br/><br/>//bubble Sorter method<br/>func bubbleSorter(integers [11]int) {<br/><br/>  var num int<br/>  num = 11<br/>  var isSwapped bool<br/>  isSwapped = true<br/>  for isSwapped {<br/>    isSwapped = false<br/>    var i int<br/>    for i = 1; i &lt; num; i++ {<br/>      if integers[i-1] &gt; integers[i] {<br/><br/>        var temp = integers[i]<br/>        integers[i] = integers[i-1]<br/>        integers[i-1] = temp<br/>        isSwapped = true<br/>      }<br/>    }<br/>  }<br/>  fmt.Println(integers)<br/>}<br/><br/>// main method<br/>func main() {<br/>  var integers [11]int = [11]int{31, 13, 12, 4, 18, 16, 7, 2, 3, 0, 10}<br/>  fmt.Println("Bubble Sorter")<br/>  bubbleSorter(integers)<br/><br/>}</pre>
<p class="mce-root"/>
<p class="p5"><span class="s1">Run the following command to execute the <kbd>bubble_sort.go</kbd> file:</span></p>
<pre class="p9"><strong><span class="s1">go run bubble_sort.go</span></strong></pre>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0a5fdfe0-6a6e-4107-a495-33b3e894b798.png" style="width:40.75em;height:8.00em;" width="570" height="112"/></p>
<p class="mce-root">Let's take a look at the selection sort algorithm in the following section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Selection</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">Selection sort is an algorithm that divides the input collection into two fragments. This sublist of elements is sorted by swapping the smallest or largest element from the left of the list to the right.<span class="Apple-converted-space"> </span>The algorithm is of the order <em>O</em>(<em>n</em><sup>2</sup>). This algorithm is inefficient for large collections, and it performs worse than the insertion sort algorithm.</span></p>
<p class="p5"><span class="s1">The following code shows the <span>implementation of the </span><kbd>SelectionSorter</kbd> function, which takes the collection to be sorted:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/><br/>// Selection Sorter method<br/>func SelectionSorter(elements []int) {<br/><br/>  var i int<br/>  for i = 0; i &lt; len(elements)-1; i++ {<br/>    var min int<br/>    min = i<br/>    var j int<br/>    for j = i + 1; j &lt;= len(elements)-1; j++ {<br/>      if elements[j] &lt; elements[min] {<br/>        min = j<br/>      }<br/>    }<br/>    swap(elements, i, min)<br/>  }<br/>}</pre>
<p class="mce-root">Let's take a look at the different selection methods in the next sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The swap method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>swap</kbd> method takes the elements array and the </span><span><kbd>i</kbd> and <kbd>j</kbd> </span><span>indices as parameters. The method swaps the element at position <kbd>i</kbd> with the element at <span>position </span><kbd>j</kbd>, as shown here:</span></p>
<pre>// swap method<br/>func swap(elements []int, i int, j int) {<br/>  var temp int<br/>  temp = elements[j]<br/>  elements[j] = elements[i]<br/>  elements[i] = temp<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>main</kbd> method initializes the <kbd>elements</kbd> array. The <kbd>elements</kbd> are printed before<span class="Apple-converted-space"> </span>and after sorting in the following code snippet:</span></p>
<pre>//main method<br/>func main() {<br/>  var elements []int<br/>  elements = []int{11, 4, 18, 6, 19, 21, 71, 13, 15, 2}<br/>  fmt.Println("Before Sorting ", elements)<br/>  SelectionSorter(elements)<br/>  fmt.Println("After Sorting", elements)<br/>}</pre>
<p class="p5"><span class="s1">Run the following command <span>to execute the <kbd>selection_sort.go</kbd> file</span>:</span></p>
<pre class="p9"><strong><span class="s1">go run selection_sort.go</span></strong></pre>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fc81b87a-005f-4522-bb33-2022c21807b7.png" style="width:34.17em;height:8.17em;" width="573" height="136"/></p>
<p><span>Let's take a look at the insertion sort algorithm in the following section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Insertion</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">Insertion sort is an algorithm that creates a final sorted array one element at a time. The algorithm's performance is of the order <em>O</em>(<em>n</em><sup>2</sup>). This algorithm is less efficient on large collections than other algorithms, such as quick, heap, and merge sort. In real life, a good example of insertion sort is the way cards are manually sorted <span>by the players </span>in a game of bridge.</span></p>
<p class="p5"><span class="s1">The implementation<span class="Apple-converted-space"> </span>of the insertion sort algorithm is shown in the following code snippet. The <kbd>RandomSequence</kbd> function takes the number of elements as a parameter and returns an array of random integers:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt and bytes package<br/>import (<br/>  "fmt"<br/>  "math/rand"<br/>  "time"<br/>)<br/><br/>// randomSequence method<br/>func randomSequence(num int) []int {<br/><br/>    var sequence []int<br/>    sequence = make([]int, num,num)<br/>    rand.Seed(time.Now().UnixNano())<br/>    var i int<br/>    for i= 0; i &lt; num; i++ {<br/>        sequence[i] = rand.Intn(999) - rand.Intn(999)<br/>    }<br/>    return sequence<br/>}</pre>
<p class="mce-root"><span>Let's take a look at the different insertion methods in the next sections.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">InsertionSorter method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The implementation<span class="Apple-converted-space"> </span>of the <kbd>InsertionSorter</kbd> method is shown in the following snippet. This method takes the <span>array of </span>integers as a parameter and sorts them:</span></p>
<pre>//InsertionSorter method<br/>func InsertionSorter(elements []int) {<br/>    var n = len(elements)<br/>    var i int<br/><br/>    for i = 1; i &lt; n; i++ {<br/>        var j int<br/>        j = i<br/>        for j &gt; 0 {<br/>            if elements[j-1] &gt; elements[j] {<br/>                elements[j-1], elements[j] = elements[j], elements[j-1]<br/>            }<br/>            j = j - 1<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>main</kbd> method initializes the <kbd>sequence</kbd> by invoking the <kbd>randomSequence</kbd> function, as shown in the following code. The <kbd>InsertionSorter</kbd> function takes the <kbd>sequence</kbd> and sorts it in ascending order:</span></p>
<pre>//main method<br/>func main() {<br/><br/>    var sequence []int<br/>    sequence = randomSequence(24)<br/>    fmt.Println("\n^^^^^^ Before Sorting ^^^ \n\n", sequence)<br/>    InsertionSorter(sequence)<br/>    fmt.Println("\n--- After Sorting ---\n\n", sequence, "\n")<br/>}</pre>
<p class="mce-root"/>
<p class="p5"><span class="s1">Run the following command <span>to execute the <kbd>insertion_sort.go</kbd> file</span>:</span></p>
<pre class="p9"><strong><span class="s1">go run insertion_sort.go</span></strong></pre>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f876c7b7-5665-47c0-9d93-8ae5ed163a3c.png" style="width:36.58em;height:14.42em;" width="581" height="228"/></p>
<p class="mce-root"><span>Let's take a look at the shell sort algorithm in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shell</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The shell sort algorithm sorts a pair of elements that are </span><span>not in sequence </span>in a collection<span>. The distance between the elements to be compared is decreased sequentially. This algorithm performs more operations and has a</span> <span>greater </span><span>cache miss ratio than the quick sort algorithm.</span></p>
<p class="p3"><span class="s1">In t</span><span class="s4">he following code,<span class="Apple-converted-space"> we can see the implementation of the <span>shell sort </span></span>algorithm. The <kbd>ShellSorter</kbd> function takes an integer array as a parameter and sorts it:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt and bytes package<br/>import (<br/>  "fmt"<br/>)<br/><br/>// shell sorter method<br/>func ShellSorter(elements []int) {<br/>  var (<br/>    n = len(elements)<br/>    intervals = []int{1}<br/>    k = 1<br/><br/>  )<br/><br/>  for {<br/>    var interval int<br/>    interval = power(2, k) + 1<br/>    if interval &gt; n-1 {<br/>      break<br/>    }<br/>    intervals = append([]int{interval}, intervals...)<br/>    k++<br/>  }<br/>  var interval int<br/>  for _, interval = range intervals {<br/>    var i int<br/>    for i = interval; i &lt; n; i += interval {<br/>      var j int<br/>      j = i<br/>      for j &gt; 0 {<br/>        if elements[j-interval] &gt; elements[j] {<br/>          elements[j-interval], elements[j] = elements[j], elements[j-interval]<br/>        }<br/>        j = j - interval<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p class="mce-root"><span>Let's take a look at the different shell methods in the following sections.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The power method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>power</kbd> method takes <kbd>exponent</kbd> and <kbd>index</kbd> as parameters and returns the power of the exponent to the index, as follows:</span></p>
<pre>//power function<br/>func power(exponent int, index int) int {<br/>  var power int<br/>  power = 1<br/>  for index &gt; 0 {<br/>    if index&amp;1 != 0 {<br/>      power *= exponent<br/>    }<br/>    index &gt;&gt;= 1<br/>    exponent *= exponent<br/>  }<br/>  return power<br/>}<br/><br/></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>main</kbd> method initializes the <kbd>elements</kbd> integer array and invokes the <kbd>ShellSorter</kbd> method, as follows:</span></p>
<pre>// main method<br/>func main() {<br/>  var elements []int<br/>  elements = []int{34, 202, 13, 19, 6, 5, 1, 43, 506, 12, 20, 28, 17, 100, 25, 4, 5, 97, 1000, 27}<br/>  ShellSorter(elements)<br/>  fmt.Println(elements)<br/>}</pre>
<p class="p5"><span class="s1">Run the following command <span>to execute the <kbd>shell_sort.go</kbd> file</span>:</span></p>
<pre class="p9"><strong><span class="s1">go run shell_sort.go</span></strong></pre>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/eef52276-9794-4886-9c8d-4a3b9398ac97.png" style="width:38.75em;height:7.00em;" width="576" height="104"/></p>
<p class="mce-root"><span>Let's take a look at the merge sort algorithm in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Merge</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The merge sort algorithm is a comparison-based method that was invented by John Von Neumann. Each element in the adjacent list is compared for sorting. </span><span class="s1">The performance of the algorithm is in the order of <em>O</em>(<em>n</em> <em>log n</em>). This algorithm is the best algorithm for sorting a linked list.</span></p>
<p class="mce-root"/>
<p class="p5"><span class="s1">The following code snippet demonstrates the merge sort algorithm.<span class="Apple-converted-space"> The</span> <kbd>createArray</kbd> function takes <kbd>num int</kbd> as a parameter and returns an integer, <kbd>array</kbd>, that consists of randomized elements:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt and bytes package<br/>import (<br/>  "fmt"<br/>  "math/rand"<br/>  "time"<br/>)<br/><br/>// create array<br/>func createArray(num int) []int {<br/>  var array []int<br/>  array = make([]int, num, num)<br/>  rand.Seed(time.Now().UnixNano())<br/>  var i int<br/>  for i = 0; i &lt; num; i++ {<br/>    array[i] = rand.Intn(99999) - rand.Intn(99999)<br/>  }<br/>  return array<br/>}</pre>
<p class="mce-root"><span>Let's take a look at the different merge methods in the following sections.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">MergeSorter method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>MergeSorter</kbd> method takes an array of integer elements<span class="Apple-converted-space"> as a parameter,</span> and two sub-arrays of elements are recursively passed to the <kbd>MergeSorter</kbd> method. The resultant arrays are joined and returned as the collection, as follows:</span></p>
<pre>// MergeSorter algorithm<br/>func MergeSorter(array []int) []int {<br/><br/>  if len(array) &lt; 2 {<br/>    return array<br/>  }<br/>  var middle int<br/>  middle = (len(array)) / 2<br/>  return JoinArrays(MergeSorter(array[:middle]), MergeSorter(array[middle:]))<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">JoinArrays method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>JoinArrays</kbd> function takes the <span><kbd>leftArr</kbd> and <kbd>rightArr</kbd> </span>integer arrays as <span>parameters. T</span>he combined array is returned in the following code:</span></p>
<pre>// Join Arrays method<br/>func JoinArrays(leftArr []int, rightArr []int) []int {<br/><br/>  var num int<br/>  var i int<br/>  var j int<br/>  num, i, j = len(leftArr)+len(rightArr), 0, 0<br/>  var array []int<br/>  array = make([]int, num, num)<br/><br/>  var k int<br/>  for k = 0; k &lt; num; k++ {<br/>    if i &gt; len(leftArr)-1 &amp;&amp; j &lt;= len(rightArr)-1 {<br/>      array[k] = rightArr[j]<br/>      j++<br/>    } else if j &gt; len(rightArr)-1 &amp;&amp; i &lt;= len(leftArr)-1 {<br/>      array[k] = leftArr[i]<br/>      i++<br/>    } else if leftArr[i] &lt; rightArr[j] {<br/>      array[k] = leftArr[i]<br/>      i++<br/>    } else {<br/>      array[k] = rightArr[j]<br/>      j++<br/>    }<br/>  }<br/>  return array<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>main</kbd> method<span class="Apple-converted-space"> </span>initializes the integer array of <kbd>40</kbd> elements, and the elements are printed before and after sorting, as follows:</span></p>
<pre>// main method<br/>func main() {<br/><br/>  var elements []int<br/>  elements = createArray(40)<br/>  fmt.Println("\n Before Sorting \n\n", elements)<br/>  fmt.Println("\n-After Sorting\n\n", MergeSorter(elements), "\n")<br/>}</pre>
<p class="p5"><span class="s1">Run the following command <span>to execute the <kbd>merge_sort.go</kbd> file</span>:</span></p>
<pre class="p9"><strong><span class="s1">go run merge_sort.go</span></strong></pre>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/91adf12a-4991-4e84-9ff0-9bc9b7e4c72d.png" style="width:35.58em;height:17.92em;" width="576" height="290"/></p>
<p class="mce-root"><span>Let's take a look at the quick sort </span><span>algorithm in the following section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Quick</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">Quick sort is an algorithm for sorting the elements of a collection in an organized way.<span class="Apple-converted-space"> Parallelized</span> quick sort is two to three times faster than merge sort and heap sort. The algorithm's performance is of the order <em>O</em>(<em>n log n</em>).  This algorithm is a space-optimized version of the binary tree sort algorithm.</span></p>
<p class="p3"><span class="s1">In the following code snippet, the quick sort algorithm is implemented. The <kbd>QuickSorter</kbd> function takes an array of integer <kbd>elements</kbd>, <kbd>upper int</kbd>, and <kbd>below int</kbd> as parameters. The function divides the array into parts, which are recursively divided and sorted:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/><br/>//Quick Sorter method<br/>func QuickSorter(elements []int, below int, upper int) {<br/>  if below &lt; upper {<br/>    var part int<br/>    part = divideParts(elements, below, upper)<br/>    QuickSorter(elements, below, part-1)<br/>    QuickSorter(elements, part+1, upper)<br/>  }<br/>}</pre>
<p class="mce-root"><span>Let's take a look at the different quick methods in the following sections.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The divideParts method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>divideParts</kbd> method takes <span>an array of integer <kbd>elements</kbd>, <kbd>upper int</kbd>, and <kbd>below int</kbd> as parameters</span>. The method sorts the elements in ascending order, as shown in the following code:</span></p>
<pre>// divideParts method<br/>func divideParts(elements []int, below int, upper int) int {<br/>  var center int<br/>  center = elements[upper]<br/>  var i int<br/>  i = below<br/>  var j int<br/>  for j = below; j &lt; upper; j++ {<br/>    if elements[j] &lt;= center {<br/>      swap(&amp;elements[i], &amp;elements[j])<br/>      i += 1<br/>    }<br/>  }<br/>  swap(&amp;elements[i], &amp;elements[upper])<br/>  return i<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The swap method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">In the following code snippet, the <kbd>swap</kbd> method exchanges elements by interchanging the values:</span></p>
<pre>//swap method<br/>func swap(element1 *int, element2 *int) {<br/>  var val int<br/>  val = *element1<br/>  *element1 = *element2<br/>  *element2 = val<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The <kbd>main</kbd> method asks the user to input the number of elements and the elements to be <kbd>read</kbd>. The <kbd>array</kbd> is initialized and printed before and after sorting, as follows:</span></p>
<pre>// main method<br/>func main() {<br/>  var num int<br/><br/>  fmt.Print("Enter Number of Elements: ")<br/>  fmt.Scan(&amp;num)<br/><br/>  var array = make([]int, num)<br/><br/>  var i int<br/>  for i = 0; i &lt; num; i++ {<br/>    fmt.Print("array[", i, "]: ")<br/>    fmt.Scan(&amp;array[i])<br/>  }<br/><br/>  fmt.Print("Elements: ", array, "\n")<br/>  QuickSorter(array, 0, num-1)<br/>  fmt.Print("Sorted Elements: ", array, "\n")<br/>}</pre>
<p class="p5"><span class="s1">Run the following command to execute the <kbd>quick_sort.go</kbd> file:</span></p>
<pre class="p9"><strong><span class="s1">go run quick_sort.go</span></strong></pre>
<p class="mce-root"/>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/dfe4600a-76c9-4104-a02d-99ca37d125bd.png" style="width:32.00em;height:15.33em;" width="516" height="246"/></p>
<p class="mce-root">Now that we are done with sort algorithms, let's take a look at the search algorithms in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Searching</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">Search algorithms are used to retrieve information that's stored in a data source or a collection.<span class="Apple-converted-space"> <span>The algorithm is given the key of the element in question, and </span><span>the associated value will be found. </span></span>Search algorithms return a true<span class="Apple-converted-space"> </span>or a false Boolean value based on the availability of the <span>information</span>. They can be enhanced to display multiple values related to the search criteria. Different types of search algorithms include linear, binary, and interpolation. These algorithms are categorized by the type of search. Search algorithms include brute force and heuristic methods. The algorithms are chosen for their efficiency. Different factors for choosing these algorithms are as follows:</span></p>
<ul>
<li>Input type</li>
<li>Output type</li>
<li>Definiteness</li>
<li>Correctness</li>
<li>Finiteness</li>
<li>Effectiveness</li>
<li>Generality</li>
</ul>
<p>In this section, we will discuss the different types of search algorithms.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linear</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The linear search method finds a given value within a collection by <span>sequentially </span>checking every element in the collection. The time complexity of the linear search algorithm is</span><span class="s1"> <em>O</em>(<em>n</em>). The binary search algorithm and hash tables perform better than this search algorithm.</span></p>
<p class="p5"><span class="s1">The implementation of the linear search method is shown in the following code snippet. The </span><span class="s1"><kbd>LinearSearch</kbd> function takes an <span>array of </span>integer <kbd>elements</kbd> and <kbd>findElement int</kbd> as parameters. The function returns a Boolean <kbd>true</kbd> if the <kbd>findElement</kbd> is found; otherwise, it returns <kbd>false</kbd>:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/><br/>// Linear Search method<br/>func LinearSearch(elements []int, findElement int) bool {<br/>  var element int<br/>  for _, element = range elements {<br/>    if element == findElement {<br/>      return true<br/>    }<br/>  }<br/>  return false<br/>}</pre>
<p class="p5"><span class="s1">The <kbd>main</kbd> method initializes the <span>array of </span>integer <kbd>elements</kbd> and invokes the <kbd>LinearSearch</kbd> method by passing an integer that needs to be found, as follows:</span></p>
<pre>// main method<br/>func main() {<br/>  var elements []int<br/>  elements = []int{15, 48, 26, 18, 41, 86, 29, 51, 20}<br/>  fmt.Println(LinearSearch(elements, 48))<br/>}</pre>
<p class="p5"><span class="s1">Run the following command to execute the <kbd>linear_search.go</kbd> file:</span></p>
<pre class="p9"><strong><span class="s1">go run linear_search.go</span></strong></pre>
<p class="mce-root"/>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e4e8e576-ba34-490b-9305-61470b5a5243.png" style="width:36.75em;height:5.83em;" width="573" height="91"/></p>
<p class="mce-root"><span>Let's take a look at the binary search </span><span>algorithm in the following section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Binary</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The binary search algorithm compares the input value to the middle element of the sorted collection. If the values are not equal, the half in which the element is not found is eliminated. The search continues on the remaining half of the collection. The time complexity of this algorithm is in the order of <em>O</em>(<em>log n</em>).</span></p>
<p class="p5"><span class="s1">The following code snippet shows an implementation of the binary search algorithm<span class="Apple-converted-space"> </span>using the <kbd>sort.Search</kbd> function from the <kbd>sort</kbd> package. The <kbd>main</kbd> method initializes the <kbd>elements</kbd> array and invokes the <kbd>sort.Search</kbd> function to find an integer element:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>  "sort"<br/>)<br/><br/>// main method<br/>func main() {<br/>  var elements []int<br/>  elements = []int{1, 3, 16, 10, 45, 31, 28, 36, 45, 75}<br/>  var element int<br/>  element = 36<br/><br/>  var i int<br/><br/>  i = sort.Search(len(elements), func(i int) bool { return elements[i] &gt;= element })<br/>  if i &lt; len(elements) &amp;&amp; elements[i] == element {<br/>    fmt.Printf("found element %d at index %d in %v\n", element, i, elements)<br/>  } else {<br/>    fmt.Printf("element %d not found in %v\n", element, elements)<br/>  }<br/>}</pre>
<p class="p5"><span class="s1">Run the following command to execute the <kbd>binary_search.go</kbd> file:</span></p>
<pre class="p9"><strong><span class="s1">go run binary_search.go</span></strong></pre>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b5fe09eb-8605-4703-ac32-5a0f58a773df.png" style="width:37.08em;height:5.33em;" width="577" height="83"/></p>
<p class="mce-root"><span>Let's take a look at the interpolation search </span><span>algorithm in the following section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interpolation</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">The interpolation search algorithm searches for the element in a sorted collection. The algorithm finds the input element at an estimated position by diminishing the search space before or after the estimated position. The time complexity of the search algorithm is of the order <em>O</em>(<em>log log n</em>).</span></p>
<p class="p5"><span class="s1">The following code snippet implements the interpolation search algorithm. The <kbd>InterpolationSearch</kbd> function takes the array of integer elements and the integer element to be found as parameters. The function finds the element in the collection and returns the Boolean and the index for the found element:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/><br/>//interpolation search method<br/>func InterpolationSearch(elements []int, element int) (bool, int) {<br/>  var mid int<br/>  var low int<br/>  low = 0<br/>  var high int<br/>  high = len(elements) - 1<br/><br/>  for elements[low] &lt; element &amp;&amp; elements[high] &gt; element {<br/>    mid = low + ((element-elements[low])*(high-low))/(elements[high]-elements[low])<br/><br/>    if elements[mid] &lt; element {<br/>      low = mid + 1<br/>    } else if elements[mid] &gt; element {<br/>      high = mid - 1<br/>    } else {<br/>      return true, mid<br/>    }<br/>  }<br/><br/>  if elements[low] == element {<br/>    return true, low<br/>  } else if elements[high] == element {<br/>    return true, high<br/>  } else {<br/>    return false, -1<br/>  }<br/><br/>  return false, -1<br/>}</pre>
<p class="p5"><span class="s1">The <kbd>main</kbd> method initializes the array of integer elements and invokes the <kbd>InterpolationSearch</kbd> <span>method </span>with the <kbd>elements</kbd> array and the <kbd>element</kbd> parameters, as follows:</span></p>
<pre>// main method<br/>func main() {<br/>  var elements []int<br/>  elements = []int{2, 3, 5, 7, 9}<br/>  var element int<br/>  element = 7<br/>  var found bool<br/>  var index int<br/>  found, index = InterpolationSearch(elements, element)<br/>  fmt.Println(found, "found at", index)<br/>}</pre>
<p class="p5"><span class="s1">Run the following command to execute the <kbd>interpolation_search.go</kbd> file:</span></p>
<pre class="p9"><strong><span class="s1">go run interpolation_search.go</span></strong></pre>
<p class="mce-root"/>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/56628781-3e13-41dd-a1a5-6506150c9372.png" style="width:42.08em;height:5.58em;" width="583" height="76"/></p>
<p class="mce-root"><span>Now that we are done with search algorithms, let's take a look at the recursion algorithms in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Recursion</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s4">Recursion is an algorithm in which one of the steps invokes the currently running method or function. <span>This algorithm acquires the outcome for the input by applying basic tasks and then returns the value.</span> This method was briefly discussed in the <em>Divide and conquer algorithms</em> section of <a href="fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml">Chapter 1</a>, <em>Data Structures and Algorithms</em>. During recursion, if the base condition is not reached, then a stack overflow condition may arise.</span></p>
<p class="p5"><span class="s1">A recursion algorithm is implemented in the following code snippet. The <kbd>Factor</kbd> method takes the <kbd>num</kbd> as a parameter and returns the factorial of <span class="packt_screen">num</span>.<span class="Apple-converted-space"> </span>The method uses recursion to calculate the factorial of the number:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt and bytes package<br/>import (<br/>  "fmt"<br/>)<br/><br/>//factorial method<br/>func Factor(num int) int {<br/>  if num &lt;= 1 {<br/>    return 1<br/>  }<br/>  return num * Factor(num-1)<br/>}</pre>
<p class="mce-root"/>
<p class="p5"><span class="s1">The <kbd>main</kbd> method defines the integer with a value of <kbd><span><span>12</span></span></kbd> and invokes the <kbd>Factor</kbd> method. The factorial of the number <kbd>12</kbd> is printed, as shown in the following code:</span></p>
<pre>//main method<br/>func main() {<br/>  var num int = 12<br/>  fmt.Println("Factorial: %d is %d", num, Factor(num))<br/>}</pre>
<p class="p5"><span class="s1">Run the following command to execute the <kbd>recurse_factorial.go</kbd> file:</span></p>
<pre class="p9"><strong><span class="s1">go run recurse_factorial.go</span></strong></pre>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/bf9b2709-2b1f-40e4-9343-af72a120304c.png" style="width:40.33em;height:7.42em;" width="576" height="105"/></p>
<p class="mce-root">Now that we are done with recursive algorithms, let's take a look at the hash algorithms in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hashing</h1>
                </header>
            
            <article>
                
<p class="p14"><span class="s1">Hash functions were introduced in <a href="8fef9c62-c4b9-460b-965a-0a0da1fbd72e.xhtml"/><a href="8fef9c62-c4b9-460b-965a-0a0da1fbd72e.xhtml">Chapter 4</a>, <em>Non-Linear Data Structures</em>. Hash implementation in Go has <kbd>crc32</kbd> and <kbd>sha256</kbd> implementations. An implementation of a hashing algorithm with multiple values using an XOR transformation is shown in the following code snippet. </span><span class="s1">The <kbd>CreateHash</kbd> function takes a <kbd>byte</kbd> array, <kbd>byteStr</kbd>, as a parameter and returns the </span><span class="s1"><kbd>sha256</kbd> checksum of the byte array:</span></p>
<pre>//main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>  "crypto/sha1"<br/>  "hash"<br/>)<br/><br/>//CreateHash method<br/>func CreateHash(byteStr []byte) []byte {<br/>  var hashVal hash.Hash<br/>  hashVal = sha1.New()<br/>  hashVal.Write(byteStr)<br/><br/>  var bytes []byte<br/><br/>  bytes = hashVal.Sum(nil)<br/>  return bytes<br/>}</pre>
<p class="mce-root"><span>In the following sections, we will discuss the different methods of hash algorithms.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The CreateHashMutliple method</h1>
                </header>
            
            <article>
                
<p class="p14"><span class="s1">The <kbd>CreateHashMutliple</kbd> method takes the <span><kbd>byteStr1</kbd> and <kbd>byteStr2</kbd> </span>byte arrays as parameters and returns the XOR-transformed bytes value, as follows:</span></p>
<pre>// Create hash for Multiple Values method<br/>func CreateHashMultiple(byteStr1 []byte, byteStr2 []byte) []byte {<br/>  return xor(CreateHash(byteStr1), CreateHash(byteStr2))<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The XOR method</h1>
                </header>
            
            <article>
                
<p class="p14"><span class="s1">The <kbd>xor</kbd> method takes the <span><kbd>byteStr1</kbd> and <kbd>byteStr2</kbd> </span>byte arrays as parameters and returns the XOR-transformation result, as follows:</span></p>
<pre>// XOR method<br/>func xor(byteStr1 []byte, byteStr2 []byte) []byte {<br/>  var xorbytes []byte<br/>  xorbytes = make([]byte, len(byteStr1))<br/>  var i int<br/>  for i = 0; i &lt; len(byteStr1); i++ {<br/>    xorbytes[i] = byteStr1[i] ^ byteStr2[i]<br/>  }<br/>  return xorbytes<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p14"><span class="s1">The <kbd>main</kbd> method invokes the <kbd>createHashMutliple</kbd> method, passing <span><kbd>Check</kbd> and <kbd>Hash</kbd> as </span>string parameters, and prints the hash value of the strings, as follows:</span></p>
<pre>// main method<br/>func main() {<br/><br/>  var bytes []byte<br/>  bytes = CreateHashMultiple([]byte("Check"), []byte("Hash"))<br/><br/>  fmt.Printf("%x\n", bytes)<br/>}</pre>
<p class="p5"><span class="s1">Run the following command to execute the <kbd>hash.go</kbd> file:</span></p>
<pre class="p9"><strong><span class="s1">go run hash.go</span></strong></pre>
<p class="p5"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8c678fd3-3cd8-4766-9b8c-fc4133819e4a.png" width="514" height="106"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p5"><span class="s1">This chapter covered sorting algorithms such as bubble, selection, insertion, shell, merge, and quick sort. Search algorithms such as linear, binary, and interpolation were the discussed. Finally, the recursion and hashing algorithms were explained with code snippets. All of the algorithms were discussed <span>alongside </span>code examples and performance analysis.</span></p>
<p class="p5"><span class="s1">In the next chapter, network representation using graphs and s</span>parse matrix representation using list of lists will be <span class="s1">covered, along with appropriate examples.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="p17"><span class="s1">What is the order of complexity of bubble sort?</span></li>
<li class="p17"><span class="s1">Which sorting algorithm takes one element at a time to create a final sorted collection?</span></li>
<li>What sorting method sorts pairs of elements that are far apart from each other?</li>
<li>What is the complexity of using the merge sort algorithm?</li>
<li>Which is better: the quick, merge, or heap sort algorithm?</li>
<li>What are the different types of search algorithms?</li>
<li>Provide a code example of the recursion algorithm.</li>
<li>Who was the first person to describe the interpolation search?</li>
<li>Which sorting algorithm is based on a comparison-based method of an adjacent list of elements?</li>
<li>Who was the person to publish the shell sort algorithm?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="p17"><span class="s1">The following books are recommended if you want to know more about algorithms such as sorting, selecting, searching, and hashing:</span></p>
<ul>
<li><em>Design Patterns</em>, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides</li>
<li><em>Introduction to Algorithms – Thi<span>rd Edition</span></em>, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein</li>
<li><em>Data structures and Algorithms: An Easy Introduction</em>, by Rudolph Russell</li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>