["```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and bytes package\nimport (\n  \"fmt\"\n)\n\n//bubble Sorter method\nfunc bubbleSorter(integers [11]int) {\n\n  var num int\n  num = 11\n  var isSwapped bool\n  isSwapped = true\n  for isSwapped {\n    isSwapped = false\n    var i int\n    for i = 1; i < num; i++ {\n      if integers[i-1] > integers[i] {\n\n        var temp = integers[i]\n        integers[i] = integers[i-1]\n        integers[i-1] = temp\n        isSwapped = true\n      }\n    }\n  }\n  fmt.Println(integers)\n}\n\n// main method\nfunc main() {\n  var integers [11]int = [11]int{31, 13, 12, 4, 18, 16, 7, 2, 3, 0, 10}\n  fmt.Println(\"Bubble Sorter\")\n  bubbleSorter(integers)\n\n}\n```", "```go\ngo run bubble_sort.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n\n// Selection Sorter method\nfunc SelectionSorter(elements []int) {\n\n  var i int\n  for i = 0; i < len(elements)-1; i++ {\n    var min int\n    min = i\n    var j int\n    for j = i + 1; j <= len(elements)-1; j++ {\n      if elements[j] < elements[min] {\n        min = j\n      }\n    }\n    swap(elements, i, min)\n  }\n}\n```", "```go\n// swap method\nfunc swap(elements []int, i int, j int) {\n  var temp int\n  temp = elements[j]\n  elements[j] = elements[i]\n  elements[i] = temp\n}\n```", "```go\n//main method\nfunc main() {\n  var elements []int\n  elements = []int{11, 4, 18, 6, 19, 21, 71, 13, 15, 2}\n  fmt.Println(\"Before Sorting \", elements)\n  SelectionSorter(elements)\n  fmt.Println(\"After Sorting\", elements)\n}\n```", "```go\ngo run selection_sort.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and bytes package\nimport (\n  \"fmt\"\n  \"math/rand\"\n  \"time\"\n)\n\n// randomSequence method\nfunc randomSequence(num int) []int {\n\n    var sequence []int\n    sequence = make([]int, num,num)\n    rand.Seed(time.Now().UnixNano())\n    var i int\n    for i= 0; i < num; i++ {\n        sequence[i] = rand.Intn(999) - rand.Intn(999)\n    }\n    return sequence\n}\n```", "```go\n//InsertionSorter method\nfunc InsertionSorter(elements []int) {\n    var n = len(elements)\n    var i int\n\n    for i = 1; i < n; i++ {\n        var j int\n        j = i\n        for j > 0 {\n            if elements[j-1] > elements[j] {\n                elements[j-1], elements[j] = elements[j], elements[j-1]\n            }\n            j = j - 1\n        }\n    }\n}\n```", "```go\n//main method\nfunc main() {\n\n    var sequence []int\n    sequence = randomSequence(24)\n    fmt.Println(\"\\n^^^^^^ Before Sorting ^^^ \\n\\n\", sequence)\n    InsertionSorter(sequence)\n    fmt.Println(\"\\n--- After Sorting ---\\n\\n\", sequence, \"\\n\")\n}\n```", "```go\ngo run insertion_sort.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and bytes package\nimport (\n  \"fmt\"\n)\n\n// shell sorter method\nfunc ShellSorter(elements []int) {\n  var (\n    n = len(elements)\n    intervals = []int{1}\n    k = 1\n\n  )\n\n  for {\n    var interval int\n    interval = power(2, k) + 1\n    if interval > n-1 {\n      break\n    }\n    intervals = append([]int{interval}, intervals...)\n    k++\n  }\n  var interval int\n  for _, interval = range intervals {\n    var i int\n    for i = interval; i < n; i += interval {\n      var j int\n      j = i\n      for j > 0 {\n        if elements[j-interval] > elements[j] {\n          elements[j-interval], elements[j] = elements[j], elements[j-interval]\n        }\n        j = j - interval\n      }\n    }\n  }\n}\n```", "```go\n//power function\nfunc power(exponent int, index int) int {\n  var power int\n  power = 1\n  for index > 0 {\n    if index&1 != 0 {\n      power *= exponent\n    }\n    index >>= 1\n    exponent *= exponent\n  }\n  return power\n}\n\n```", "```go\n// main method\nfunc main() {\n  var elements []int\n  elements = []int{34, 202, 13, 19, 6, 5, 1, 43, 506, 12, 20, 28, 17, 100, 25, 4, 5, 97, 1000, 27}\n  ShellSorter(elements)\n  fmt.Println(elements)\n}\n```", "```go\ngo run shell_sort.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and bytes package\nimport (\n  \"fmt\"\n  \"math/rand\"\n  \"time\"\n)\n\n// create array\nfunc createArray(num int) []int {\n  var array []int\n  array = make([]int, num, num)\n  rand.Seed(time.Now().UnixNano())\n  var i int\n  for i = 0; i < num; i++ {\n    array[i] = rand.Intn(99999) - rand.Intn(99999)\n  }\n  return array\n}\n```", "```go\n// MergeSorter algorithm\nfunc MergeSorter(array []int) []int {\n\n  if len(array) < 2 {\n    return array\n  }\n  var middle int\n  middle = (len(array)) / 2\n  return JoinArrays(MergeSorter(array[:middle]), MergeSorter(array[middle:]))\n}\n```", "```go\n// Join Arrays method\nfunc JoinArrays(leftArr []int, rightArr []int) []int {\n\n  var num int\n  var i int\n  var j int\n  num, i, j = len(leftArr)+len(rightArr), 0, 0\n  var array []int\n  array = make([]int, num, num)\n\n  var k int\n  for k = 0; k < num; k++ {\n    if i > len(leftArr)-1 && j <= len(rightArr)-1 {\n      array[k] = rightArr[j]\n      j++\n    } else if j > len(rightArr)-1 && i <= len(leftArr)-1 {\n      array[k] = leftArr[i]\n      i++\n    } else if leftArr[i] < rightArr[j] {\n      array[k] = leftArr[i]\n      i++\n    } else {\n      array[k] = rightArr[j]\n      j++\n    }\n  }\n  return array\n}\n```", "```go\n// main method\nfunc main() {\n\n  var elements []int\n  elements = createArray(40)\n  fmt.Println(\"\\n Before Sorting \\n\\n\", elements)\n  fmt.Println(\"\\n-After Sorting\\n\\n\", MergeSorter(elements), \"\\n\")\n}\n```", "```go\ngo run merge_sort.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n\n//Quick Sorter method\nfunc QuickSorter(elements []int, below int, upper int) {\n  if below < upper {\n    var part int\n    part = divideParts(elements, below, upper)\n    QuickSorter(elements, below, part-1)\n    QuickSorter(elements, part+1, upper)\n  }\n}\n```", "```go\n// divideParts method\nfunc divideParts(elements []int, below int, upper int) int {\n  var center int\n  center = elements[upper]\n  var i int\n  i = below\n  var j int\n  for j = below; j < upper; j++ {\n    if elements[j] <= center {\n      swap(&elements[i], &elements[j])\n      i += 1\n    }\n  }\n  swap(&elements[i], &elements[upper])\n  return i\n}\n```", "```go\n//swap method\nfunc swap(element1 *int, element2 *int) {\n  var val int\n  val = *element1\n  *element1 = *element2\n  *element2 = val\n}\n```", "```go\n// main method\nfunc main() {\n  var num int\n\n  fmt.Print(\"Enter Number of Elements: \")\n  fmt.Scan(&num)\n\n  var array = make([]int, num)\n\n  var i int\n  for i = 0; i < num; i++ {\n    fmt.Print(\"array[\", i, \"]: \")\n    fmt.Scan(&array[i])\n  }\n\n  fmt.Print(\"Elements: \", array, \"\\n\")\n  QuickSorter(array, 0, num-1)\n  fmt.Print(\"Sorted Elements: \", array, \"\\n\")\n}\n```", "```go\ngo run quick_sort.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n\n// Linear Search method\nfunc LinearSearch(elements []int, findElement int) bool {\n  var element int\n  for _, element = range elements {\n    if element == findElement {\n      return true\n    }\n  }\n  return false\n}\n```", "```go\n// main method\nfunc main() {\n  var elements []int\n  elements = []int{15, 48, 26, 18, 41, 86, 29, 51, 20}\n  fmt.Println(LinearSearch(elements, 48))\n}\n```", "```go\ngo run linear_search.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n  \"sort\"\n)\n\n// main method\nfunc main() {\n  var elements []int\n  elements = []int{1, 3, 16, 10, 45, 31, 28, 36, 45, 75}\n  var element int\n  element = 36\n\n  var i int\n\n  i = sort.Search(len(elements), func(i int) bool { return elements[i] >= element })\n  if i < len(elements) && elements[i] == element {\n    fmt.Printf(\"found element %d at index %d in %v\\n\", element, i, elements)\n  } else {\n    fmt.Printf(\"element %d not found in %v\\n\", element, elements)\n  }\n}\n```", "```go\ngo run binary_search.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n\n//interpolation search method\nfunc InterpolationSearch(elements []int, element int) (bool, int) {\n  var mid int\n  var low int\n  low = 0\n  var high int\n  high = len(elements) - 1\n\n  for elements[low] < element && elements[high] > element {\n    mid = low + ((element-elements[low])*(high-low))/(elements[high]-elements[low])\n\n    if elements[mid] < element {\n      low = mid + 1\n    } else if elements[mid] > element {\n      high = mid - 1\n    } else {\n      return true, mid\n    }\n  }\n\n  if elements[low] == element {\n    return true, low\n  } else if elements[high] == element {\n    return true, high\n  } else {\n    return false, -1\n  }\n\n  return false, -1\n}\n```", "```go\n// main method\nfunc main() {\n  var elements []int\n  elements = []int{2, 3, 5, 7, 9}\n  var element int\n  element = 7\n  var found bool\n  var index int\n  found, index = InterpolationSearch(elements, element)\n  fmt.Println(found, \"found at\", index)\n}\n```", "```go\ngo run interpolation_search.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt and bytes package\nimport (\n  \"fmt\"\n)\n\n//factorial method\nfunc Factor(num int) int {\n  if num <= 1 {\n    return 1\n  }\n  return num * Factor(num-1)\n}\n```", "```go\n//main method\nfunc main() {\n  var num int = 12\n  fmt.Println(\"Factorial: %d is %d\", num, Factor(num))\n}\n```", "```go\ngo run recurse_factorial.go\n```", "```go\n//main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n  \"crypto/sha1\"\n  \"hash\"\n)\n\n//CreateHash method\nfunc CreateHash(byteStr []byte) []byte {\n  var hashVal hash.Hash\n  hashVal = sha1.New()\n  hashVal.Write(byteStr)\n\n  var bytes []byte\n\n  bytes = hashVal.Sum(nil)\n  return bytes\n}\n```", "```go\n// Create hash for Multiple Values method\nfunc CreateHashMultiple(byteStr1 []byte, byteStr2 []byte) []byte {\n  return xor(CreateHash(byteStr1), CreateHash(byteStr2))\n}\n```", "```go\n// XOR method\nfunc xor(byteStr1 []byte, byteStr2 []byte) []byte {\n  var xorbytes []byte\n  xorbytes = make([]byte, len(byteStr1))\n  var i int\n  for i = 0; i < len(byteStr1); i++ {\n    xorbytes[i] = byteStr1[i] ^ byteStr2[i]\n  }\n  return xorbytes\n}\n```", "```go\n// main method\nfunc main() {\n\n  var bytes []byte\n  bytes = CreateHashMultiple([]byte(\"Check\"), []byte(\"Hash\"))\n\n  fmt.Printf(\"%x\\n\", bytes)\n}\n```", "```go\ngo run hash.go\n```"]