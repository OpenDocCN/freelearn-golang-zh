- en: Classic Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classic algorithms are used in the areas of data search and cryptography. Sorting,
    searching, recursing, and hashing algorithms are good examples of classic algorithms. Sorting
    algorithms are used to order elements into either an ascending or descending key
    arrangement. These algorithms are frequently used to canonicalize data and to
    create readable content. Search algorithms are used to find an element in a set.
    A recursive algorithm is one that calls itself with input items. A hashing algorithm
    is a cryptographic hash technique. It is a scientific calculation that maps data
    with a subjective size to a hash with a settled size. It's intended to be a single
    direction function, that you cannot alter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the different classic algorithms and explain
    them with suitable examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Searching:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequential
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install Go version 1.10 from [https://golang.org/doc/install](https://golang.org/doc/install)
    for your OS.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub URL for the code in this chapter is as follows: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sorting algorithms arrange the elements in a collection in ascending or descending
    order. Lexicographical order can be applied to a collection of characters and
    strings. The efficiency of these algorithms is in the performance of sorting the
    input data into a sorted collection. The best sorting algorithm time complexity
    is *O*(*n log n*). Sorting algorithms are classified by the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Computational complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type of sorting: serial/parallel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adaptability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method of sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we'll look at the different sorting algorithms, that
    is, bubble, selection, insertion, shell, merge, and quick.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bubble sort algorithm is a sorting algorithm that compares a pair of neighboring
    elements and swaps them if they are in the wrong order. The algorithm has a complexity
    of *O*(*n*²), where n is the number of elements to be sorted. The smallest or
    greatest value bubbles up to the top of the collection, or the smallest or greatest
    sinks to the bottom (depending on whether you're sorting into ascending or descending
    order).
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet shows the implementation of the bubble sort algorithm.
    The `bubbleSorter` function takes an integer array and sorts the array's elements
    in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` method initializes the array''s integers and invokes the `bubbleSorter` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `bubble_sort.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a5fdfe0-6a6e-4107-a495-33b3e894b798.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the selection sort algorithm in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selection sort is an algorithm that divides the input collection into two fragments.
    This sublist of elements is sorted by swapping the smallest or largest element
    from the left of the list to the right. The algorithm is of the order *O*(*n*²).
    This algorithm is inefficient for large collections, and it performs worse than
    the insertion sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the implementation of the `SelectionSorter` function,
    which takes the collection to be sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the different selection methods in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: The swap method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `swap` method takes the elements array and the `i` and `j` indices as parameters.
    The method swaps the element at position `i` with the element at position `j`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method initializes the `elements` array. The `elements` are printed
    before and after sorting in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `selection_sort.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc81b87a-005f-4522-bb33-2022c21807b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the insertion sort algorithm in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Insertion sort is an algorithm that creates a final sorted array one element
    at a time. The algorithm's performance is of the order *O*(*n*²). This algorithm
    is less efficient on large collections than other algorithms, such as quick, heap,
    and merge sort. In real life, a good example of insertion sort is the way cards
    are manually sorted by the players in a game of bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the insertion sort algorithm is shown in the following
    code snippet. The `RandomSequence` function takes the number of elements as a
    parameter and returns an array of random integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the different insertion methods in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: InsertionSorter method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of the `InsertionSorter` method is shown in the following
    snippet. This method takes the array of integers as a parameter and sorts them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method initializes the `sequence` by invoking the `randomSequence`
    function, as shown in the following code. The `InsertionSorter` function takes
    the `sequence` and sorts it in ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `insertion_sort.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f876c7b7-5665-47c0-9d93-8ae5ed163a3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the shell sort algorithm in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shell sort algorithm sorts a pair of elements that are not in sequence in
    a collection. The distance between the elements to be compared is decreased sequentially.
    This algorithm performs more operations and has a greater cache miss ratio than
    the quick sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we can see the implementation of the shell sort algorithm.
    The `ShellSorter` function takes an integer array as a parameter and sorts it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the different shell methods in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The power method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `power` method takes `exponent` and `index` as parameters and returns the
    power of the exponent to the index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method initializes the `elements` integer array and invokes the
    `ShellSorter` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `shell_sort.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eef52276-9794-4886-9c8d-4a3b9398ac97.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the merge sort algorithm in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Merge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The merge sort algorithm is a comparison-based method that was invented by John
    Von Neumann. Each element in the adjacent list is compared for sorting. The performance
    of the algorithm is in the order of *O*(*n* *log n*). This algorithm is the best
    algorithm for sorting a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates the merge sort algorithm. The `createArray`
    function takes `num int` as a parameter and returns an integer, `array`, that
    consists of randomized elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the different merge methods in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: MergeSorter method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MergeSorter` method takes an array of integer elements as a parameter, and
    two sub-arrays of elements are recursively passed to the `MergeSorter` method.
    The resultant arrays are joined and returned as the collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: JoinArrays method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `JoinArrays` function takes the `leftArr` and `rightArr` integer arrays
    as parameters. The combined array is returned in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method initializes the integer array of `40` elements, and the elements
    are printed before and after sorting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `merge_sort.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91adf12a-4991-4e84-9ff0-9bc9b7e4c72d.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the quick sort algorithm in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quick sort is an algorithm for sorting the elements of a collection in an organized
    way. Parallelized quick sort is two to three times faster than merge sort and
    heap sort. The algorithm's performance is of the order *O*(*n log n*).  This algorithm
    is a space-optimized version of the binary tree sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, the quick sort algorithm is implemented. The
    `QuickSorter` function takes an array of integer `elements`, `upper int`, and
    `below int` as parameters. The function divides the array into parts, which are
    recursively divided and sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the different quick methods in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The divideParts method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `divideParts` method takes an array of integer `elements`, `upper int`,
    and `below int` as parameters. The method sorts the elements in ascending order,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The swap method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `swap` method exchanges elements by interchanging
    the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method asks the user to input the number of elements and the elements
    to be `read`. The `array` is initialized and printed before and after sorting,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `quick_sort.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfe4600a-76c9-4104-a02d-99ca37d125bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we are done with sort algorithms, let's take a look at the search algorithms
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Search algorithms are used to retrieve information that''s stored in a data
    source or a collection. The algorithm is given the key of the element in question,
    and the associated value will be found. Search algorithms return a true or a false
    Boolean value based on the availability of the information. They can be enhanced
    to display multiple values related to the search criteria. Different types of
    search algorithms include linear, binary, and interpolation. These algorithms
    are categorized by the type of search. Search algorithms include brute force and
    heuristic methods. The algorithms are chosen for their efficiency. Different factors
    for choosing these algorithms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Input type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Definiteness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correctness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finiteness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectiveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will discuss the different types of search algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Linear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The linear search method finds a given value within a collection by sequentially checking
    every element in the collection. The time complexity of the linear search algorithm
    is *O*(*n*). The binary search algorithm and hash tables perform better than this
    search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the linear search method is shown in the following code
    snippet. The `LinearSearch` function takes an array of integer `elements` and
    `findElement int` as parameters. The function returns a Boolean `true` if the
    `findElement` is found; otherwise, it returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method initializes the array of integer `elements` and invokes the
    `LinearSearch` method by passing an integer that needs to be found, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `linear_search.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4e8e576-ba34-490b-9305-61470b5a5243.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the binary search algorithm in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Binary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The binary search algorithm compares the input value to the middle element of
    the sorted collection. If the values are not equal, the half in which the element
    is not found is eliminated. The search continues on the remaining half of the
    collection. The time complexity of this algorithm is in the order of *O*(*log
    n*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows an implementation of the binary search algorithm using
    the `sort.Search` function from the `sort` package. The `main` method initializes
    the `elements` array and invokes the `sort.Search` function to find an integer
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `binary_search.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5fe09eb-8605-4703-ac32-5a0f58a773df.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the interpolation search algorithm in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interpolation search algorithm searches for the element in a sorted collection.
    The algorithm finds the input element at an estimated position by diminishing
    the search space before or after the estimated position. The time complexity of
    the search algorithm is of the order *O*(*log log n*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet implements the interpolation search algorithm. The
    `InterpolationSearch` function takes the array of integer elements and the integer
    element to be found as parameters. The function finds the element in the collection
    and returns the Boolean and the index for the found element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method initializes the array of integer elements and invokes the
    `InterpolationSearch` method with the `elements` array and the `element` parameters,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `interpolation_search.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56628781-3e13-41dd-a1a5-6506150c9372.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we are done with search algorithms, let's take a look at the recursion
    algorithms in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is an algorithm in which one of the steps invokes the currently running
    method or function. This algorithm acquires the outcome for the input by applying
    basic tasks and then returns the value. This method was briefly discussed in the
    *Divide and conquer algorithms* section of [Chapter 1](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml),
    *Data Structures and Algorithms*. During recursion, if the base condition is not
    reached, then a stack overflow condition may arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'A recursion algorithm is implemented in the following code snippet. The `Factor`
    method takes the `num` as a parameter and returns the factorial of num. The method
    uses recursion to calculate the factorial of the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method defines the integer with a value of `12` and invokes the
    `Factor` method. The factorial of the number `12` is printed, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `recurse_factorial.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf9b2709-2b1f-40e4-9343-af72a120304c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we are done with recursive algorithms, let's take a look at the hash
    algorithms in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hash functions were introduced in [Chapter 4](8fef9c62-c4b9-460b-965a-0a0da1fbd72e.xhtml),
    *Non-Linear Data Structures*. Hash implementation in Go has `crc32` and `sha256`
    implementations. An implementation of a hashing algorithm with multiple values
    using an XOR transformation is shown in the following code snippet. The `CreateHash`
    function takes a `byte` array, `byteStr`, as a parameter and returns the `sha256`
    checksum of the byte array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, we will discuss the different methods of hash algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The CreateHashMutliple method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CreateHashMutliple` method takes the `byteStr1` and `byteStr2` byte arrays
    as parameters and returns the XOR-transformed bytes value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The XOR method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `xor` method takes the `byteStr1` and `byteStr2` byte arrays as parameters
    and returns the XOR-transformation result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method invokes the `createHashMutliple` method, passing `Check` and
    `Hash` as string parameters, and prints the hash value of the strings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `hash.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c678fd3-3cd8-4766-9b8c-fc4133819e4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered sorting algorithms such as bubble, selection, insertion,
    shell, merge, and quick sort. Search algorithms such as linear, binary, and interpolation
    were the discussed. Finally, the recursion and hashing algorithms were explained
    with code snippets. All of the algorithms were discussed alongside code examples
    and performance analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, network representation using graphs and sparse matrix representation
    using list of lists will be covered, along with appropriate examples.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the order of complexity of bubble sort?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which sorting algorithm takes one element at a time to create a final sorted
    collection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What sorting method sorts pairs of elements that are far apart from each other?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the complexity of using the merge sort algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which is better: the quick, merge, or heap sort algorithm?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different types of search algorithms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a code example of the recursion algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who was the first person to describe the interpolation search?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which sorting algorithm is based on a comparison-based method of an adjacent
    list of elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who was the person to publish the shell sort algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following books are recommended if you want to know more about algorithms
    such as sorting, selecting, searching, and hashing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
