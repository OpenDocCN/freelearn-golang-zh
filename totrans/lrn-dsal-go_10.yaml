- en: Classic Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典算法
- en: Classic algorithms are used in the areas of data search and cryptography. Sorting,
    searching, recursing, and hashing algorithms are good examples of classic algorithms. Sorting
    algorithms are used to order elements into either an ascending or descending key
    arrangement. These algorithms are frequently used to canonicalize data and to
    create readable content. Search algorithms are used to find an element in a set.
    A recursive algorithm is one that calls itself with input items. A hashing algorithm
    is a cryptographic hash technique. It is a scientific calculation that maps data
    with a subjective size to a hash with a settled size. It's intended to be a single
    direction function, that you cannot alter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 经典算法在数据搜索和密码学领域得到应用。排序、搜索、递归和哈希算法是经典算法的好例子。排序算法用于将元素按升序或降序排列。这些算法通常用于规范化数据和创建可读内容。搜索算法用于在集合中查找元素。递归算法是一种调用自身输入项的算法。哈希算法是一种加密哈希技术。它是一种将具有主观大小的数据映射到具有固定大小的哈希的科学计算。它旨在是一个单向函数，你不能改变它。
- en: In this chapter, we will cover the different classic algorithms and explain
    them with suitable examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍不同的经典算法，并通过合适的示例进行解释。
- en: 'This chapter covers the following algorithms:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下算法：
- en: 'Sorting:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序：
- en: Bubble
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡
- en: Selection
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择
- en: Insertion
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入
- en: Shell
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希尔
- en: Merge
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并
- en: Quick
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速
- en: 'Searching:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索：
- en: Linear
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性
- en: Sequential
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序
- en: Binary
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制
- en: Interpolation
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值
- en: Recursion
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Hashing
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Install Go version 1.10 from [https://golang.org/doc/install](https://golang.org/doc/install)
    for your OS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的操作系统安装Go版本1.10，请访问[https://golang.org/doc/install](https://golang.org/doc/install)。
- en: The GitHub URL for the code in this chapter is as follows: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter08).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中代码的GitHub URL如下：[https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter08)。
- en: Sorting
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: 'Sorting algorithms arrange the elements in a collection in ascending or descending
    order. Lexicographical order can be applied to a collection of characters and
    strings. The efficiency of these algorithms is in the performance of sorting the
    input data into a sorted collection. The best sorting algorithm time complexity
    is *O*(*n log n*). Sorting algorithms are classified by the following criteria:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法将集合中的元素按升序或降序排列。字典序可以应用于字符和字符串的集合。这些算法的效率在于将输入数据排序成有序集合的性能。最佳排序算法的时间复杂度是*O*(n
    log n)。排序算法根据以下标准进行分类：
- en: Computational complexity
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算复杂度
- en: Memory usage
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用
- en: Stability
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定性
- en: 'Type of sorting: serial/parallel'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序类型：串行/并行
- en: Adaptability
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应性
- en: Method of sorting
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序方法
- en: In the following sections, we'll look at the different sorting algorithms, that
    is, bubble, selection, insertion, shell, merge, and quick.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将探讨不同的排序算法，即冒泡、选择、插入、希尔、归并和快速排序。
- en: Bubble
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 气泡
- en: The bubble sort algorithm is a sorting algorithm that compares a pair of neighboring
    elements and swaps them if they are in the wrong order. The algorithm has a complexity
    of *O*(*n*²), where n is the number of elements to be sorted. The smallest or
    greatest value bubbles up to the top of the collection, or the smallest or greatest
    sinks to the bottom (depending on whether you're sorting into ascending or descending
    order).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法是一种排序算法，它比较相邻的两个元素，如果它们顺序错误则交换它们。该算法的复杂度为*O*(n²)，其中n是要排序的元素数量。最小或最大的值会冒泡到集合的顶部，或者最小或最大的值会沉到集合的底部（取决于你是按升序还是降序排序）。
- en: The following code snippet shows the implementation of the bubble sort algorithm.
    The `bubbleSorter` function takes an integer array and sorts the array's elements
    in ascending order.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了冒泡排序算法的实现。`bubbleSorter`函数接收一个整数数组，并按升序对数组元素进行排序。
- en: 'The `main` method initializes the array''s integers and invokes the `bubbleSorter` function,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法初始化数组整数并调用`bubbleSorter`函数，如下所示：'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the following command to execute the `bubble_sort.go` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行`bubble_sort.go`文件：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/0a5fdfe0-6a6e-4107-a495-33b3e894b798.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a5fdfe0-6a6e-4107-a495-33b3e894b798.png)'
- en: Let's take a look at the selection sort algorithm in the following section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看选择排序算法。
- en: Selection
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择
- en: Selection sort is an algorithm that divides the input collection into two fragments.
    This sublist of elements is sorted by swapping the smallest or largest element
    from the left of the list to the right. The algorithm is of the order *O*(*n*²).
    This algorithm is inefficient for large collections, and it performs worse than
    the insertion sort algorithm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序是一种将输入集合分成两个片段的算法。通过从列表的左侧交换最小或最大的元素到右侧，对这个元素子列表进行排序。该算法的时间复杂度为*O*(n²)。对于大型集合，此算法效率低下，性能不如插入排序算法。
- en: 'The following code shows the implementation of the `SelectionSorter` function,
    which takes the collection to be sorted:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`SelectionSorter`函数的实现，该函数接受要排序的集合：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's take a look at the different selection methods in the next sections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看不同的选择方法。
- en: The swap method
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换方法
- en: 'The `swap` method takes the elements array and the `i` and `j` indices as parameters.
    The method swaps the element at position `i` with the element at position `j`,
    as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap`方法接受元素数组以及`i`和`j`索引作为参数。该方法将位置`i`的元素与位置`j`的元素进行交换，如下所示：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The main method
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main`方法'
- en: 'The `main` method initializes the `elements` array. The `elements` are printed
    before and after sorting in the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法初始化`elements`数组。在以下代码片段中，`elements`在排序前后被打印出来：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the following command to execute the `selection_sort.go` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`selection_sort.go`文件：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/fc81b87a-005f-4522-bb33-2022c21807b7.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc81b87a-005f-4522-bb33-2022c21807b7.png)'
- en: Let's take a look at the insertion sort algorithm in the following section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看插入排序算法。
- en: Insertion
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: Insertion sort is an algorithm that creates a final sorted array one element
    at a time. The algorithm's performance is of the order *O*(*n*²). This algorithm
    is less efficient on large collections than other algorithms, such as quick, heap,
    and merge sort. In real life, a good example of insertion sort is the way cards
    are manually sorted by the players in a game of bridge.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序是一种一次创建一个最终排序数组的算法。该算法的性能时间复杂度为*O*(n²)。与其他算法（如快速排序、堆排序和归并排序）相比，在大型集合上效率较低。在现实生活中，桥牌游戏中玩家手动排序牌的例子是插入排序的一个很好的例子。
- en: 'The implementation of the insertion sort algorithm is shown in the following
    code snippet. The `RandomSequence` function takes the number of elements as a
    parameter and returns an array of random integers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 希尔排序算法的实现如下所示。`RandomSequence`函数接受元素数量作为参数并返回一个随机整数数组：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's take a look at the different insertion methods in the next sections.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看不同的插入方法。
- en: InsertionSorter method
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InsertionSorter方法
- en: 'The implementation of the `InsertionSorter` method is shown in the following
    snippet. This method takes the array of integers as a parameter and sorts them:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertionSorter`方法的实现如下所示。此方法接受整数数组作为参数并对其进行排序：'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The main method
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main`方法'
- en: 'The `main` method initializes the `sequence` by invoking the `randomSequence`
    function, as shown in the following code. The `InsertionSorter` function takes
    the `sequence` and sorts it in ascending order:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法通过调用`randomSequence`函数初始化`sequence`，如下面的代码所示。`InsertionSorter`函数接受`sequence`并按升序对其进行排序：'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the following command to execute the `insertion_sort.go` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`insertion_sort.go`文件：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/f876c7b7-5665-47c0-9d93-8ae5ed163a3c.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f876c7b7-5665-47c0-9d93-8ae5ed163a3c.png)'
- en: Let's take a look at the shell sort algorithm in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看希尔排序算法。
- en: Shell
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 希尔
- en: The shell sort algorithm sorts a pair of elements that are not in sequence in
    a collection. The distance between the elements to be compared is decreased sequentially.
    This algorithm performs more operations and has a greater cache miss ratio than
    the quick sort algorithm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 希尔排序算法对集合中顺序不正确的元素对进行排序。要比较的元素之间的距离依次减小。此算法比快速排序算法执行更多操作，具有更高的缓存未命中率。
- en: 'In the following code, we can see the implementation of the shell sort algorithm.
    The `ShellSorter` function takes an integer array as a parameter and sorts it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们可以看到希尔排序算法的实现。`ShellSorter`函数接受一个整数数组作为参数并对其进行排序：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's take a look at the different shell methods in the following sections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看不同的希尔方法。
- en: The power method
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功率方法
- en: 'The `power` method takes `exponent` and `index` as parameters and returns the
    power of the exponent to the index, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`power`方法接受`exponent`和`index`作为参数，并返回指数的指数次幂，如下所示：'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The main method
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main`方法'
- en: 'The `main` method initializes the `elements` integer array and invokes the
    `ShellSorter` method, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法初始化`elements`整数数组并调用`ShellSorter`方法，如下所示：'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the following command to execute the `shell_sort.go` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`shell_sort.go`文件：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/eef52276-9794-4886-9c8d-4a3b9398ac97.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eef52276-9794-4886-9c8d-4a3b9398ac97.png)'
- en: Let's take a look at the merge sort algorithm in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的归并排序算法。
- en: Merge
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并
- en: The merge sort algorithm is a comparison-based method that was invented by John
    Von Neumann. Each element in the adjacent list is compared for sorting. The performance
    of the algorithm is in the order of *O*(*n* *log n*). This algorithm is the best
    algorithm for sorting a linked list.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法是一种基于比较的方法，由约翰·冯·诺伊曼发明。相邻列表中的每个元素都会进行比较以进行排序。算法的性能是*O*(*n* *log n*)。此算法是排序链表的最佳算法。
- en: 'The following code snippet demonstrates the merge sort algorithm. The `createArray`
    function takes `num int` as a parameter and returns an integer, `array`, that
    consists of randomized elements:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了归并排序算法。`createArray`函数接受`num int`作为参数，并返回一个由随机元素组成的整数`array`：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's take a look at the different merge methods in the following sections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下章节中不同的归并方法。
- en: MergeSorter method
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MergeSorter`方法'
- en: 'The `MergeSorter` method takes an array of integer elements as a parameter, and
    two sub-arrays of elements are recursively passed to the `MergeSorter` method.
    The resultant arrays are joined and returned as the collection, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`MergeSorter`方法接受一个整数元素数组作为参数，并将两个元素子数组递归地传递给`MergeSorter`方法。结果数组被连接并返回作为集合，如下所示：'
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: JoinArrays method
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`JoinArrays`方法'
- en: 'The `JoinArrays` function takes the `leftArr` and `rightArr` integer arrays
    as parameters. The combined array is returned in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`JoinArrays`函数接受`leftArr`和`rightArr`整数数组作为参数。以下代码返回合并后的数组：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The main method
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main`方法'
- en: 'The `main` method initializes the integer array of `40` elements, and the elements
    are printed before and after sorting, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法初始化一个包含`40`个元素的整数数组，并在排序前后打印元素，如下所示：'
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the following command to execute the `merge_sort.go` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`merge_sort.go`文件：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/91adf12a-4991-4e84-9ff0-9bc9b7e4c72d.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91adf12a-4991-4e84-9ff0-9bc9b7e4c72d.png)'
- en: Let's take a look at the quick sort algorithm in the following section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下章节中的快速排序算法。
- en: Quick
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速
- en: Quick sort is an algorithm for sorting the elements of a collection in an organized
    way. Parallelized quick sort is two to three times faster than merge sort and
    heap sort. The algorithm's performance is of the order *O*(*n log n*).  This algorithm
    is a space-optimized version of the binary tree sort algorithm.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是一种对集合中的元素进行有序排序的算法。并行化后的快速排序比归并排序和堆排序快两到三倍。算法的性能是*O*(*n log n*)。此算法是二叉树排序算法的空间优化版本。
- en: 'In the following code snippet, the quick sort algorithm is implemented. The
    `QuickSorter` function takes an array of integer `elements`, `upper int`, and
    `below int` as parameters. The function divides the array into parts, which are
    recursively divided and sorted:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，实现了快速排序算法。`QuickSorter`函数接受一个整数`elements`数组，以及`upper int`和`below int`作为参数。函数将数组分成部分，这些部分被递归地分割和排序：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's take a look at the different quick methods in the following sections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下章节中不同的快速方法。
- en: The divideParts method
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`divideParts`方法'
- en: 'The `divideParts` method takes an array of integer `elements`, `upper int`,
    and `below int` as parameters. The method sorts the elements in ascending order,
    as shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`divideParts`方法接受一个整数`elements`数组，`upper int`和`below int`作为参数。该方法按升序排序元素，如下所示：'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The swap method
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换方法
- en: 'In the following code snippet, the `swap` method exchanges elements by interchanging
    the values:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`swap`方法通过交换值来交换元素：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The main method
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main`方法'
- en: 'The `main` method asks the user to input the number of elements and the elements
    to be `read`. The `array` is initialized and printed before and after sorting,
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法要求用户输入元素的个数和要`read`的元素。在排序前后，`array`被初始化并打印，如下所示：'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the following command to execute the `quick_sort.go` file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行`quick_sort.go`文件：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/dfe4600a-76c9-4104-a02d-99ca37d125bd.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfe4600a-76c9-4104-a02d-99ca37d125bd.png)'
- en: Now that we are done with sort algorithms, let's take a look at the search algorithms
    in the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了排序算法，让我们在下一节中看看搜索算法。
- en: Searching
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: 'Search algorithms are used to retrieve information that''s stored in a data
    source or a collection. The algorithm is given the key of the element in question,
    and the associated value will be found. Search algorithms return a true or a false
    Boolean value based on the availability of the information. They can be enhanced
    to display multiple values related to the search criteria. Different types of
    search algorithms include linear, binary, and interpolation. These algorithms
    are categorized by the type of search. Search algorithms include brute force and
    heuristic methods. The algorithms are chosen for their efficiency. Different factors
    for choosing these algorithms are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索算法用于检索存储在数据源或集合中的信息。算法被赋予待查元素的键，并将找到相关值。搜索算法根据信息的可用性返回布尔值true或false。它们可以被增强以显示与搜索标准相关的多个值。不同的搜索算法类型包括线性、二分和插值。这些算法根据搜索类型进行分类。搜索算法包括暴力法和启发式方法。算法的选择基于其效率。选择这些算法的不同因素如下：
- en: Input type
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入类型
- en: Output type
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出类型
- en: Definiteness
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确性
- en: Correctness
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确性
- en: Finiteness
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性
- en: Effectiveness
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效性
- en: Generality
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用性
- en: In this section, we will discuss the different types of search algorithms.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论不同类型的搜索算法。
- en: Linear
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性
- en: The linear search method finds a given value within a collection by sequentially checking
    every element in the collection. The time complexity of the linear search algorithm
    is *O*(*n*). The binary search algorithm and hash tables perform better than this
    search algorithm.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索方法通过依次检查集合中的每个元素来在集合中查找给定的值。线性搜索算法的时间复杂度是*O*(*n*)。二分搜索算法和哈希表的性能优于此搜索算法。
- en: 'The implementation of the linear search method is shown in the following code
    snippet. The `LinearSearch` function takes an array of integer `elements` and
    `findElement int` as parameters. The function returns a Boolean `true` if the
    `findElement` is found; otherwise, it returns `false`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了线性搜索方法的实现。`LinearSearch`函数接受一个整数数组`elements`和`findElement int`作为参数。如果找到`findElement`，函数返回布尔值`true`；否则，返回`false`：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `main` method initializes the array of integer `elements` and invokes the
    `LinearSearch` method by passing an integer that needs to be found, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法初始化整数数组`elements`，并通过传递需要找到的整数调用`LinearSearch`方法，如下所示：'
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the following command to execute the `linear_search.go` file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行`linear_search.go`文件：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/e4e8e576-ba34-490b-9305-61470b5a5243.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4e8e576-ba34-490b-9305-61470b5a5243.png)'
- en: Let's take a look at the binary search algorithm in the following section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下章节中的二分搜索算法。
- en: Binary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分
- en: The binary search algorithm compares the input value to the middle element of
    the sorted collection. If the values are not equal, the half in which the element
    is not found is eliminated. The search continues on the remaining half of the
    collection. The time complexity of this algorithm is in the order of *O*(*log
    n*).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索算法将输入值与排序集合的中间元素进行比较。如果不相等，则消除未找到元素的半部分。搜索继续在集合的剩余半部分进行。此算法的时间复杂度为*O*(*log
    n*)。
- en: 'The following code snippet shows an implementation of the binary search algorithm using
    the `sort.Search` function from the `sort` package. The `main` method initializes
    the `elements` array and invokes the `sort.Search` function to find an integer
    element:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用`sort`包中的`sort.Search`函数实现的二分搜索算法。`main`方法初始化`elements`数组，并调用`sort.Search`函数以查找整数元素：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the following command to execute the `binary_search.go` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行`binary_search.go`文件：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/b5fe09eb-8605-4703-ac32-5a0f58a773df.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5fe09eb-8605-4703-ac32-5a0f58a773df.png)'
- en: Let's take a look at the interpolation search algorithm in the following section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下章节中的插值搜索算法。
- en: Interpolation
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值
- en: The interpolation search algorithm searches for the element in a sorted collection.
    The algorithm finds the input element at an estimated position by diminishing
    the search space before or after the estimated position. The time complexity of
    the search algorithm is of the order *O*(*log log n*).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 插值搜索算法在有序集合中搜索元素。该算法通过在估计位置之前或之后减小搜索空间来找到输入元素。搜索算法的时间复杂度为 *O*(*log log n*)。
- en: 'The following code snippet implements the interpolation search algorithm. The
    `InterpolationSearch` function takes the array of integer elements and the integer
    element to be found as parameters. The function finds the element in the collection
    and returns the Boolean and the index for the found element:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了插值搜索算法。`InterpolationSearch` 函数接受整数元素数组和要查找的整数元素作为参数。该函数在集合中找到元素，并返回找到的元素的布尔值和索引：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `main` method initializes the array of integer elements and invokes the
    `InterpolationSearch` method with the `elements` array and the `element` parameters,
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法初始化整数元素数组，并使用 `elements` 数组和 `element` 参数调用 `InterpolationSearch`
    方法，如下所示：'
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the following command to execute the `interpolation_search.go` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `interpolation_search.go` 文件：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/56628781-3e13-41dd-a1a5-6506150c9372.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56628781-3e13-41dd-a1a5-6506150c9372.png)'
- en: Now that we are done with search algorithms, let's take a look at the recursion
    algorithms in the next section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了搜索算法，接下来让我们看看下一节中的递归算法。
- en: Recursion
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: Recursion is an algorithm in which one of the steps invokes the currently running
    method or function. This algorithm acquires the outcome for the input by applying
    basic tasks and then returns the value. This method was briefly discussed in the
    *Divide and conquer algorithms* section of [Chapter 1](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml),
    *Data Structures and Algorithms*. During recursion, if the base condition is not
    reached, then a stack overflow condition may arise.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种算法，其中一个步骤会调用当前正在运行的方法或函数。该算法通过应用基本任务并返回值来获取输入的结果。这种方法在[第1章](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml)，*数据结构与算法*的*分而治之算法*部分中简要讨论过。在递归过程中，如果未达到基本条件，则可能会出现栈溢出条件。
- en: 'A recursion algorithm is implemented in the following code snippet. The `Factor`
    method takes the `num` as a parameter and returns the factorial of num. The method
    uses recursion to calculate the factorial of the number:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了递归算法。`Factor` 方法将 `num` 作为参数，并返回 `num` 的阶乘。该方法使用递归来计算数字的阶乘：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `main` method defines the integer with a value of `12` and invokes the
    `Factor` method. The factorial of the number `12` is printed, as shown in the
    following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法定义了一个值为 `12` 的整数并调用 `Factor` 方法。打印出数字 `12` 的阶乘，如下所示：'
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the following command to execute the `recurse_factorial.go` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `recurse_factorial.go` 文件：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/bf9b2709-2b1f-40e4-9343-af72a120304c.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf9b2709-2b1f-40e4-9343-af72a120304c.png)'
- en: Now that we are done with recursive algorithms, let's take a look at the hash
    algorithms in the next section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了递归算法，接下来让我们看看下一节中的哈希算法。
- en: Hashing
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希
- en: 'Hash functions were introduced in [Chapter 4](8fef9c62-c4b9-460b-965a-0a0da1fbd72e.xhtml),
    *Non-Linear Data Structures*. Hash implementation in Go has `crc32` and `sha256`
    implementations. An implementation of a hashing algorithm with multiple values
    using an XOR transformation is shown in the following code snippet. The `CreateHash`
    function takes a `byte` array, `byteStr`, as a parameter and returns the `sha256`
    checksum of the byte array:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](8fef9c62-c4b9-460b-965a-0a0da1fbd72e.xhtml)，*非线性数据结构*中介绍了哈希函数。Go中的哈希实现有
    `crc32` 和 `sha256` 实现。以下代码片段展示了使用XOR变换实现的具有多个值的哈希算法。`CreateHash` 函数接受一个 `byte`
    数组，`byteStr`，作为参数，并返回该字节数组的 `sha256` 校验和：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the following sections, we will discuss the different methods of hash algorithms.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将讨论哈希算法的不同方法。
- en: The CreateHashMutliple method
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The CreateHashMutliple method
- en: 'The `CreateHashMutliple` method takes the `byteStr1` and `byteStr2` byte arrays
    as parameters and returns the XOR-transformed bytes value, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateHashMutliple` 方法接受 `byteStr1` 和 `byteStr2` 字节数组作为参数，并返回XOR变换后的字节数值，如下所示：'
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The XOR method
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XOR方法
- en: 'The `xor` method takes the `byteStr1` and `byteStr2` byte arrays as parameters
    and returns the XOR-transformation result, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor`方法接受`byteStr1`和`byteStr2`字节数组作为参数，并返回XOR变换结果，如下所示：'
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The main method
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要方法
- en: 'The `main` method invokes the `createHashMutliple` method, passing `Check` and
    `Hash` as string parameters, and prints the hash value of the strings, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法调用`createHashMutliple`方法，传递`Check`和`Hash`作为字符串参数，并打印字符串的哈希值，如下所示：'
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the following command to execute the `hash.go` file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来执行`hash.go`文件：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/8c678fd3-3cd8-4766-9b8c-fc4133819e4a.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c678fd3-3cd8-4766-9b8c-fc4133819e4a.png)'
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered sorting algorithms such as bubble, selection, insertion,
    shell, merge, and quick sort. Search algorithms such as linear, binary, and interpolation
    were the discussed. Finally, the recursion and hashing algorithms were explained
    with code snippets. All of the algorithms were discussed alongside code examples
    and performance analysis.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了冒泡排序、选择排序、插入排序、希尔排序、归并排序和快速排序等排序算法。讨论了线性搜索、二分搜索和插值搜索等搜索算法。最后，通过代码片段解释了递归和哈希算法。所有算法都伴随着代码示例和性能分析。
- en: In the next chapter, network representation using graphs and sparse matrix representation
    using list of lists will be covered, along with appropriate examples.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将介绍使用图表示网络和使用列表表示稀疏矩阵，以及相应的示例。
- en: Questions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the order of complexity of bubble sort?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡排序的复杂度顺序是什么？
- en: Which sorting algorithm takes one element at a time to create a final sorted
    collection?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种排序算法一次取一个元素来创建一个最终排序的集合？
- en: What sorting method sorts pairs of elements that are far apart from each other?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种排序方法可以排序彼此距离较远的元素对？
- en: What is the complexity of using the merge sort algorithm?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用归并排序算法的复杂度是多少？
- en: 'Which is better: the quick, merge, or heap sort algorithm?'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个算法更好：快速排序、归并排序还是堆排序算法？
- en: What are the different types of search algorithms?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些不同类型的搜索算法？
- en: Provide a code example of the recursion algorithm.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个递归算法的代码示例。
- en: Who was the first person to describe the interpolation search?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁是第一个描述插值搜索的人？
- en: Which sorting algorithm is based on a comparison-based method of an adjacent
    list of elements?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种排序算法是基于相邻元素列表的比较方法？
- en: Who was the person to publish the shell sort algorithm?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁发表了希尔排序算法？
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following books are recommended if you want to know more about algorithms
    such as sorting, selecting, searching, and hashing:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于排序、选择、搜索和哈希等算法的信息，以下书籍推荐：
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式》，作者：艾里克·伽玛、理查德·赫尔姆、拉尔夫·约翰逊和约翰·弗利斯
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《算法导论 第3版》，作者：托马斯·H·科门、查尔斯·E·莱伊森、罗纳德·L·里维斯和克利福德·斯坦
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《数据结构和算法：简单入门》，作者：鲁道夫·拉塞尔
