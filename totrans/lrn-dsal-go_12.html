<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Network and Sparse Matrix Representation</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A <strong>sparse matrix</strong> is a matrix in which most of the values are zero. The ratio of zero values to non-zero values is known as the <strong>sparsity</strong>. An estimation of a matrix's sparsity can be helpful when creating hypotheses about the availability of networks. Extensive big sparse matrices are commonly used in machine learning and natural language parsing. It is computationally costly to work with them. Recommendation engines use them for representing products inside a catalog. Computer vision uses </span><span>sparse matrices and network data structures </span><span>when working with pictures that contain sections with dark pixels. Network and sparse matrix data structures are also used in social graphs and map layouts. In this chapter, we will cover the following topics:</span></p>
<ul>
<li class="li4"><span class="s3">Network representations using graphs:</span>
<ul>
<li class="li4"><span class="s3">Social network representation</span></li>
<li class="li4"><span class="s3">Map layouts</span></li>
<li class="li4"><span class="s3">Knowledge graphs</span></li>
</ul>
</li>
<li class="li4"><span class="s3">Sparse matrix representation using a list of lists</span></li>
</ul>
<p>A social graph that connects people <span>is implemented in this chapter, </span>and a code example shows how the graph can be traversed. Map layouts are explained with geographic locations with latitude and longitude. Knowledge graphs are explained via the use of a car and its parts.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">Install Go version 1.10 from <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> <a href="https://golang.org/doc/install">for your OS.</a></span></p>
<p class="p4"><span class="s3">The GitHub URL for the code in this chapter is as follows: <a href="https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter09">https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter09</a><span class="s5">.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Network representation using graphs</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A graph is a representation of a set of objects that's connected by links. The links connect vertices, which are points.<span class="Apple-converted-space"> </span>The basic operations on a graph are the addition and removal of links and vertices. These are some different types of graphs:</span></p>
<ul>
<li>Directed graph</li>
<li>Non-directed graph</li>
<li>Connected graph</li>
<li>Non-connected graph</li>
<li>Simple graph</li>
<li>Multi-graph</li>
</ul>
<p class="p3"><span class="s1">An <strong>adjacency list</strong> consists of adjacent vertices of a graph that have objects or records. An adjacency matrix consists of source and destination vertices. An incidence matrix<span class="Apple-converted-space"> </span>is a two-dimensional Boolean matrix. The matrix has rows of vertices and columns that represent the links (edges).</span></p>
<p class="p3"><span class="s1">Network representation <span>using a graph </span>is shown in the following code. A social graph consists of an array of links:</span></p>
<pre class="p7">///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/>// Social Graph<br/>type SocialGraph struct {<br/>  Size int<br/>  Links [][]Link<br/>}</pre>
<p>The <kbd>Link</kbd> struct is defined and implemented in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Link class</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>Link</kbd> class consists of the <kbd>vertex1</kbd> and <kbd>vertex2</kbd> <span>vertices </span>and the <kbd>LinkWeight</kbd> integer property:</span></p>
<pre>// Link class<br/>type Link struct {<br/>  Vertex1 int<br/>  Vertex2 int<br/>  LinkWeight int<br/>}</pre>
<p>The next section talks about the <span>implementation of the</span> different <kbd>Link</kbd> class methods.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NewSocialGraph method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>NewSocialGraph</kbd> function creates a social graph given <kbd>num</kbd>, which is the size of the graph. <kbd>Size</kbd> is the number of links in the graph:</span></p>
<pre>// NewSocialGraph method<br/>func NewSocialGraph(num int) *SocialGraph {<br/>  return &amp;SocialGraph{<br/>    Size: num,<br/>    Links: make([][]Link, num),<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddLink method</h1>
                </header>
            
            <article>
                
<p class="p7"><span>The <kbd>AddLink</kbd> method adds the link between two vertices. The <kbd>AddLink</kbd> method of a social graph takes <kbd>vertex1</kbd>, <kbd>vertex2</kbd>, and <kbd>weight</kbd> as parameters. The method adds the link from <kbd>vertex1</kbd> to <kbd>vertex2</kbd>, as shown in the following code:</span></p>
<pre>// AddLink method<br/>func (socialGraph *SocialGraph) AddLink(vertex1 int, vertex2 int, weight int) {<br/>  socialGraph.Links[vertex1] = append(socialGraph.Links[vertex1], Link{Vertex1: vertex1, Vertex2: vertex2, LinkWeight: weight})<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The PrintLinks method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>PrintLinks</kbd> method of the <kbd>SocialGraph</kbd> class prints the links from <kbd>vertex = 0</kbd> and all the links in the graph:</span></p>
<pre>// Print Links Example<br/>func (socialGraph *SocialGraph) PrintLinks() {<br/><br/>  var vertex int<br/>  vertex = 0<br/><br/>  fmt.Printf("Printing all links from %d\n", vertex)<br/>  var link Link<br/>  for _, link = range socialGraph.Links[vertex] {<br/>    fmt.Printf("Link: %d -&gt; %d (%d)\n", link.Vertex1, link.Vertex2, link.LinkWeight)<br/>  }<br/><br/>  fmt.Println("Printing all links in graph.")<br/>  var adjacent []Link<br/>  for _, adjacent = range socialGraph.Links {<br/>    for _, link = range adjacent {<br/>      fmt.Printf("Link: %d -&gt; %d (%d)\n", link.Vertex1, link.Vertex2, link.LinkWeight)<br/>    }<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p4"><span class="s1">The <kbd>main</kbd> method creates a social graph by invoking the <kbd>NewSocialGraph</kbd> method. The links from <kbd>0</kbd> to <kbd>1</kbd>, <kbd>0</kbd> to <kbd>2</kbd>, <kbd>1</kbd> to <kbd>3</kbd>, and <kbd>2</kbd> to <kbd>4</kbd> are added to the social graph.<span class="Apple-converted-space"> </span>The links are printed using the <kbd>printLinks</kbd> method:</span></p>
<pre>// main method<br/>func main() {<br/><br/>  var socialGraph *SocialGraph<br/><br/>  socialGraph = NewSocialGraph(4)<br/><br/>  socialGraph.AddLink(0, 1, 1)<br/>  socialGraph.AddLink(0, 2, 1)<br/>  socialGraph.AddLink(1, 3, 1)<br/>  socialGraph.AddLink(2, 4, 1)<br/><br/>  socialGraph.PrintLinks()<br/><br/>}</pre>
<p class="p3"><span class="s1">Run the following command to execute the <kbd>social_graph.go</kbd> file:</span></p>
<pre class="p7"><strong><span class="s1">go run social_graph.go</span></strong></pre>
<p class="p4"><span class="s3">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/effb0aaf-b05a-4467-8e5b-fbcf04d942ce.png" style="width:41.33em;height:13.58em;" width="572" height="187"/></p>
<p class="mce-root"><span>In the next section, we will take a look at the unit test for the social graph method.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test</h1>
                </header>
            
            <article>
                
<p>Here, we have written a unit test for the social graph method. The code is as follows:</p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing testing package<br/>import (<br/>  "fmt"<br/>  "testing"<br/>)<br/>// NewSocialGraph test method<br/>func TestNewSocialGraph(test *testing.T) {<br/><br/>  var socialGraph *SocialGraph<br/><br/>  socialGraph = NewSocialGraph(1)<br/><br/>  if socialGraph == nil {<br/><br/>    test.Errorf("error in creating a social Graph")<br/>  }<br/><br/>}</pre>
<p class="p3"><span class="s1">Run the following command to execute the preceding code snippet:</span></p>
<pre class="p7"><strong>go test -run NewSocialGraph -v</strong></pre>
<p class="p4"><span class="s3">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4e4bba5d-e61f-4e72-8e1f-1458188f7f3d.png" style="width:40.00em;height:9.75em;" width="587" height="143"/></p>
<p class="p3"><span class="s1">In the next section,<span class="Apple-converted-space"> a s</span>ocial network representation will be implemented with code examples. The preceding graph will be enhanced with nodes. Each node will represent a social entity.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Representing a social network</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A <strong>social network</strong> consists of social links that contain social entities such as people, friends, discussions, shares, beliefs, trust, and likes. This graph is used to represent the social network.</span></p>
<p class="p3"><span class="s1">Metrics </span><span>related to the proximity of entities </span><span>can be calculated based on the graph.</span><span class="Apple-converted-space"> S</span><span>ocial graphs consist of graph nodes and links, which are maps with a key name and multiple keys names, respectively:</span></p>
<pre>///Main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/><br/><br/>type Name string<br/><br/>type SocialGraph struct {<br/>  GraphNodes map[Name]struct{}<br/>  Links map[Name]map[Name]struct{}<br/>}</pre>
<p>The different social network methods are explained and implemented in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NewSocialGraph method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>NewSocialGraph</kbd> method returns a social graph consisting of </span>nil<span class="s1">-valued <kbd>GraphNodes</kbd> and <kbd>Links</kbd>:</span></p>
<pre>// NewSocialGraph method<br/>func NewSocialGraph() *SocialGraph {<br/>  return &amp;SocialGraph{<br/>    GraphNodes: make(map[Name]struct{}),<br/>    Links: make(map[Name]map[Name]struct{}),<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddEntity method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>AddEntity</kbd> method adds the entity to the social graph. The <kbd>AddEntity</kbd> method of the <kbd>SocialGraph</kbd> class takes <kbd>name</kbd> as a parameter and returns <kbd>true</kbd> if it is added to the social graph:</span></p>
<pre>// AddEntity method<br/>func (socialGraph *SocialGraph) AddEntity(name Name) bool {<br/><br/>  var exists bool<br/>  if _, exists = socialGraph.GraphNodes[name]; exists {<br/>    return true<br/>  }<br/>  socialGraph.GraphNodes[name] = struct{}{}<br/>  return true<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddLink method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>AddLink</kbd> method of the <kbd>SocialGraph</kbd> class takes <span><kbd>name1</kbd> and <kbd>name2</kbd> as </span>parameters. This method creates the entities if the named entities do not exist and creates a link between the entities:</span></p>
<pre>// Add Link<br/>func (socialGraph *SocialGraph) AddLink(name1 Name, name2 Name) {<br/>  var exists bool<br/>  if _, exists = socialGraph.GraphNodes[name1]; !exists {<br/>    socialGraph.AddEntity(name1)<br/>  }<br/>  if _, exists = socialGraph.GraphNodes[name2]; !exists {<br/>    socialGraph.AddEntity(name2)<br/>  }<br/>  if _, exists = socialGraph.Links[name1]; !exists {<br/>    socialGraph.Links[name1] = make(map[Name]struct{})<br/>  }<br/>  socialGraph.Links[name1][name2] = struct{}{}<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The PrintLinks method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>PrintLinks</kbd> method of the <kbd>SocialGraph</kbd> class prints the links adjacent to the <kbd>root</kbd> and all the links, as shown in the following code snippet:</span></p>
<pre>func (socialGraph *SocialGraph) PrintLinks() {<br/>  var root Name<br/>  root = Name("Root") <br/><br/>  fmt.Printf("Printing all links adjacent to %d\n", root)<br/><br/>  var node Name<br/>  for node = range socialGraph.Links[root] {<br/>    // Edge exists from u to v.<br/>    fmt.Printf("Link: %d -&gt; %d\n", root, node)<br/>  }<br/><br/>  var m map[Name]struct{}<br/>  fmt.Println("Printing all links.")<br/>  for root, m = range socialGraph.Links {<br/>    var vertex Name<br/>    for vertex = range m {<br/>      // Edge exists from u to v.<br/>      fmt.Printf("Link: %d -&gt; %d\n", root, vertex)<br/>    }<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>main</kbd> method creates a social graph. The entities, such as <kbd>john</kbd>, <kbd>per</kbd>, and <kbd>cynthia</kbd>, are created and linked with the root node. The friends, such as <kbd>mayo</kbd>, <kbd>lorrie</kbd>, and <kbd>ellie</kbd>, are created and linked with <kbd>john</kbd> and <kbd>per</kbd>:</span></p>
<pre>// main method<br/>func main() {<br/><br/>  var socialGraph *SocialGraph<br/><br/>   socialGraph = NewSocialGraph()<br/><br/>   var root Name = Name("Root")<br/>   var john Name = Name("John Smith")<br/>   var per Name = Name("Per Jambeck")<br/>   var cynthia Name = Name("Cynthia Gibas")<br/><br/><br/>   socialGraph.AddEntity(root)<br/>   socialGraph.AddEntity(john)<br/>   socialGraph.AddEntity(per)<br/>   socialGraph.AddEntity(cynthia)<br/><br/>   socialGraph.AddLink(root, john)<br/>   socialGraph.AddLink(root, per)<br/>   socialGraph.AddLink(root, cynthia)<br/><br/>   var mayo Name = Name("Mayo Smith")<br/>   var lorrie Name = Name("Lorrie Jambeck")<br/>   var ellie Name = Name("Ellie Vlocksen")<br/><br/>   socialGraph.AddLink(john, mayo)<br/>   socialGraph.AddLink(john, lorrie)<br/>   socialGraph.AddLink(per, ellie)<br/><br/>   socialGraph.PrintLinks()<br/>}</pre>
<p class="mce-root"/>
<p class="p3"><span class="s1">Run the following command to execute the <kbd>social_graph_example.go</kbd> file:</span></p>
<pre class="p7"><strong><span class="s1">go run social_graph_example.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4956347c-552c-48f2-a367-11f5dc04b25b.png" style="width:36.25em;height:14.08em;" width="590" height="228"/></p>
<p><span>The next section talks about the <strong>map layout</strong> implementation.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Map layouts</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A</span> map <span class="s1">layout is a geographical visualization of locations that are linked together. The nodes in the graph of a map consist of geo-based information. The node will have information such as the name of the location, latitude, and longitude. Maps are laid out in different scales. Cartographic design is referred to as map creation using geographic information.</span></p>
<p class="p3"><span class="s1">A map layout is shown in the following code snippet. The <kbd>Place</kbd> class consists of <kbd>Name</kbd>, <kbd>Latitude</kbd>, and <kbd>Longitude</kbd> properties:</span></p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/><br/>// Place class<br/>type Place struct {<br/><br/>    Name string<br/>    Latitude float64<br/>    Longitude float64<br/><br/>}</pre>
<p class="mce-root"><span>The next section talks about the <kbd>MapLayout</kbd></span><span> class.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The MapLayout class</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>MapLayout</kbd> class consists of <kbd>GraphNodes</kbd><span class="Apple-converted-space"> </span>and <kbd>Links</kbd>:</span></p>
<pre>// MapLayout class<br/>type MapLayout struct {<br/>  GraphNodes map[Place]struct{}<br/>  Links map[Place]map[Place]struct{}<br/>}</pre>
<p class="mce-root"><span>The different <kbd>MapLayout</kbd> methods are explained and implemented in the next section.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NewMapLayout method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>NewMapLayout</kbd> method creates a <kbd>MapLayout</kbd>. The <kbd>MapLayout</kbd> has <kbd>GraphNodes</kbd> and links maps:</span></p>
<pre>// NewMapLayout method<br/>func NewMapLayout() *MapLayout {<br/>  return &amp;MapLayout{<br/>    GraphNodes: make(map[Place]struct{}),<br/>    Links: make(map[Place]map[Place]struct{}),<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddPlace method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>AddPlace</kbd> method of the <kbd>MapLayout</kbd> class<span class="Apple-converted-space"> </span>takes <span>place as a </span>parameter and returns <kbd>true</kbd> if the place exists. If the place does not exist, then a graph node with a new place key is created:</span></p>
<pre>// AddPlace method<br/>func (mapLayout *MapLayout) AddPlace(place Place) bool {<br/><br/>  var exists bool<br/>  if _, exists = mapLayout.GraphNodes[place]; exists {<br/>    return true<br/>  }<br/>  mapLayout.GraphNodes[place] = struct{}{}<br/>  return true<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddLink method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>AddLink</kbd> method of the <kbd>MapLayout</kbd> class takes the places as parameters and links them together:</span></p>
<pre>// Add Link<br/>func (mapLayout *MapLayout) AddLink(place1 Place, place2 Place) {<br/>  var exists bool<br/>  if _, exists = mapLayout.GraphNodes[place1]; !exists {<br/>    mapLayout.AddPlace(place1)<br/>  }<br/>  if _, exists = mapLayout.GraphNodes[place2]; !exists {<br/>    mapLayout.AddPlace(place2)<br/>  }<br/><br/>  if _, exists = mapLayout.Links[place1]; !exists {<br/>    mapLayout.Links[place1] = make(map[Place]struct{})<br/>  }<br/>  mapLayout.Links[place1][place2] = struct{}{}<br/><br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title"> The PrintLinks method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>PrintLinks</kbd> method of <kbd>MapLayout</kbd> prints the places and the links:</span></p>
<pre>// PrintLinks method<br/>func (mapLayout *MapLayout) PrintLinks() {<br/>  var root Place<br/>  root = Place{"Algeria", 3, 28}<br/><br/>  fmt.Printf("Printing all links adjacent to %s\n", root.Name)<br/><br/>  var node Place<br/>  for node = range mapLayout.Links[root] {<br/>    fmt.Printf("Link: %s -&gt; %s\n", root.Name, node.Name)<br/>  }<br/><br/>  var m map[Place]struct{}<br/>  fmt.Println("Printing all links.")<br/>  for root, m = range mapLayout.Links {<br/>    var vertex Place<br/>    for vertex = range m {<br/>      fmt.Printf("Link: %s -&gt; %s\n", root.Name, vertex.Name)<br/>    }<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">In the <kbd>main</kbd> method, the map layout is created by invoking the <kbd>NewMapLayout</kbd> method. Places are instantiated and added to the map layout. Then, the links are added between places:</span></p>
<pre>// main method<br/>func main() {<br/><br/>  var mapLayout *MapLayout<br/><br/>   mapLayout = NewMapLayout()<br/><br/>   var root Place = Place{"Algeria", 3, 28}<br/>   var netherlands Place = Place{"Netherlands", 5.75, 52.5}<br/><br/>   var korea Place = Place{"Korea", 124.1, -8.36}<br/>   var tunisia Place = Place{"Tunisia", 9, 34}<br/><br/><br/>   mapLayout.AddPlace(root)<br/>   mapLayout.AddPlace(netherlands)<br/>   mapLayout.AddPlace(korea)<br/>   mapLayout.AddPlace(tunisia)<br/><br/>   mapLayout.AddLink(root, netherlands)<br/>   mapLayout.AddLink(root,korea)<br/>   mapLayout.AddLink(root,tunisia)<br/><br/><br/>   var singapore Place = Place{"Singapore",103.8,1.36}<br/>   var uae Place = Place{"UAE",54,24}<br/>   var japan Place = Place{"Japan",139.75, 35.68}<br/><br/>   mapLayout.AddLink(korea, singapore)<br/>   mapLayout.AddLink(korea,japan)<br/>   mapLayout.AddLink(netherlands,uae)<br/><br/>   mapLayout.PrintLinks()<br/>}</pre>
<p class="mce-root"/>
<p class="p3"><span class="s1">Run the following command to execute the <kbd>map_layout.go</kbd> file:</span></p>
<pre class="p7"><strong><span class="s1">go run map_layout.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/14daeead-8574-4dcb-8d7b-91c09f4f8b98.png" style="width:35.00em;height:13.00em;" width="590" height="218"/></p>
<p class="mce-root">In the next section, we will take a look at the unit test for the <kbd>NewMapLayout</kbd> method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test</h1>
                </header>
            
            <article>
                
<p>A unit test for the <kbd>MapLayout</kbd> class's <kbd>NewMapLayout</kbd> <span>method </span>is shown in the following code snippet:</p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing testing package<br/>import (<br/>  "testing"<br/>)<br/><br/>// NewMapLayout test method<br/>func TestNewMapLayout(test *testing.T) {<br/><br/>  var mapLayout *MapLayout<br/><br/>  mapLayout = NewMapLayout()<br/><br/>  test.Log(mapLayout)<br/><br/>  if mapLayout == nil {<br/><br/>    test.Errorf("error in creating a mapLayout")<br/>  }<br/><br/>}</pre>
<p class="p3"><span class="s1">Run the following command to execute the preceding code snippet:</span></p>
<pre class="p7"><strong>go test -run NewMapLayout -v</strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/122e9e5b-efa0-450d-8333-4386b4a3bf0a.png" style="width:39.17em;height:9.75em;" width="590" height="146"/></p>
<p><span>The next section talks about implementing a <strong>knowledge graph</strong>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Knowledge graphs</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A knowledge graph is a network representation of entities, items, and users as nodes. The nodes interact with one another via links or edges. Knowledge graphs are widely used because they are schema less. These data structures are used to represent knowledge in the form of graphs, and the nodes have textual information. Knowledge graphs are created by using item, entity, and user nodes and linking them with edges.</span></p>
<p class="p3"><span class="s1">An <strong>ontology</strong> consists of a knowledge graph of information nodes. The reasoner derives knowledge from knowledge graphs. A knowledge graph consists of classes, slots, and facets, which are ontological terms. </span><span class="s1">In the following code, a knowledge graph consisting of a car's bill of materials is explained. The <kbd>Class</kbd> type consists of a name, which is a string:</span></p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/><br/>// Class Type<br/>type Class struct {<br/>  Name string<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span>The next section talks about the <kbd>knowledge graph</kbd></span><span> class.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The KnowledgeGraph class</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>KnowledgeGraph</kbd> class<span class="Apple-converted-space"> </span>consists of <kbd>GraphNodes</kbd> and links:</span></p>
<pre>// Knowledge Graph type<br/>type KnowledgeGraph struct {<br/>  GraphNodes map[Class]struct{}<br/>  Links map[Class]map[Class]struct{}<br/>}</pre>
<p class="mce-root"><span>The different knowledge graph methods are explained and implemented in the following sections.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NewKnowledgeGraph method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>NewKnowledgeGraph</kbd> method creates a knowledge graph, which consists of <kbd>GraphNodes</kbd> and <kbd>Links</kbd> maps:</span></p>
<pre>// NewKnowledgeGraph method<br/>func NewKnowledgeGraph() *KnowledgeGraph {<br/>  return &amp;KnowledgeGraph{<br/>    GraphNodes: make(map[Class]struct{}),<br/>    Links: make(map[Class]map[Class]struct{}),<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddClass method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>AddClass</kbd> method of the <kbd>KnowledgeGraph</kbd> class<span class="Apple-converted-space"> </span>takes <kbd>class</kbd> as a <span>parameter </span>and returns <kbd>true</kbd> if the class exists. If the class does not exist, a <kbd>GraphNode</kbd> is created with <kbd>class</kbd> as a</span> key<span class="s1">:</span></p>
<pre>// AddClass method<br/>func (knowledgeGraph *KnowledgeGraph) AddClass(class Class) bool {<br/><br/>  var exists bool<br/>  if _, exists = knowledgeGraph.GraphNodes[class]; exists {<br/>    return true<br/>  }<br/>  knowledgeGraph.GraphNodes[class] = struct{}{}<br/>  return true<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The AddLink method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>AddLink</kbd> method of the <kbd>KnowledgeGraph</kbd> class takes <span><kbd>class1</kbd> and <kbd>class2</kbd> as </span>parameters, and a link is created between these classes:</span></p>
<pre>// Add Link<br/>func (knowledgeGraph *KnowledgeGraph) AddLink(class1 Class, class2 Class) {<br/>  var exists bool<br/>  if _, exists = knowledgeGraph.GraphNodes[class1]; !exists {<br/>    knowledgeGraph.AddClass(class1)<br/>  }<br/>  if _, exists = knowledgeGraph.GraphNodes[class2]; !exists {<br/>    knowledgeGraph.AddClass(class2)<br/>  }<br/><br/>  if _, exists = knowledgeGraph.Links[class1]; !exists {<br/>    knowledgeGraph.Links[class1] = make(map[Class]struct{})<br/>  }<br/>  knowledgeGraph.Links[class1][class2] = struct{}{}<br/><br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The PrintLinks method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>PrintLinks</kbd> method of the <kbd>KnowledgeGraph</kbd> class prints the links and nodes:</span></p>
<pre>// Print Links method<br/>func (knowledgeGraph *KnowledgeGraph) PrintLinks() {<br/>  var car Class<br/>  car = Class{"Car"}<br/><br/>  fmt.Printf("Printing all links adjacent to %s\n", car.Name)<br/><br/>  var node Class<br/>  for node = range knowledgeGraph.Links[car] {<br/>    fmt.Printf("Link: %s -&gt; %s\n", car.Name, node.Name)<br/>  }<br/><br/>  var m map[Class]struct{}<br/>  fmt.Println("Printing all links.")<br/>  for car, m = range knowledgeGraph.Links {<br/>    var vertex Class<br/>    for vertex = range m {<br/>      fmt.Printf("Link: %s -&gt; %s\n", car.Name, vertex.Name)<br/>    }<br/>  }<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>main</kbd> method<span class="Apple-converted-space"> </span>creates the knowledge graph, and the classes are instantiated. The links between the classes<span class="Apple-converted-space"> </span>are created and printed:</span></p>
<pre>// main method<br/>func main() {<br/><br/>  var knowledgeGraph *KnowledgeGraph<br/><br/>  knowledgeGraph = NewKnowledgeGraph()<br/><br/>  var car = Class{"Car"}<br/>  var tyre = Class{"Tyre"}<br/>  var door = Class{"Door"}<br/>  var hood = Class{"Hood"}<br/><br/>  knowledgeGraph.AddClass(car)<br/>  knowledgeGraph.AddClass(tyre)<br/>  knowledgeGraph.AddClass(door)<br/>  knowledgeGraph.AddClass(hood)<br/><br/>  knowledgeGraph.AddLink(car, tyre)<br/>  knowledgeGraph.AddLink(car, door)<br/>  knowledgeGraph.AddLink(car, hood)<br/><br/>  var tube = Class{"Tube"}<br/>  var axle = Class{"Axle"}<br/>  var handle = Class{"Handle"}<br/>  var windowGlass = Class{"Window Glass"}<br/><br/>  knowledgeGraph.AddClass(tube)<br/>  knowledgeGraph.AddClass(axle)<br/>  knowledgeGraph.AddClass(handle)<br/>  knowledgeGraph.AddClass(windowGlass)<br/><br/>  knowledgeGraph.AddLink(tyre, tube)<br/>  knowledgeGraph.AddLink(tyre, axle)<br/>  knowledgeGraph.AddLink(door, handle)<br/>  knowledgeGraph.AddLink(door, windowGlass)<br/><br/>  knowledgeGraph.PrintLinks()<br/>}</pre>
<p class="mce-root"/>
<p class="p3"><span class="s1">Run the following command to execute the <kbd>knowledge_catalog.go</kbd> file:</span></p>
<pre class="p7"><strong><span class="s1">go run knowledge_catalog.go</span></strong></pre>
<p class="mce-root"/>
<p class="p4"><span class="s3">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/de4512d6-2274-45fe-a0aa-43fbadda3cb9.png" style="width:32.08em;height:12.83em;" width="590" height="235"/></p>
<p class="mce-root"><span>In the next section, we will take a look at the unit test for the <kbd>NewKnowledgeGraph</kbd> method.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test</h1>
                </header>
            
            <article>
                
<p>The <kbd>NewKnowledgeGraph</kbd> method is unit tested in the following code snippet:</p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing testing package<br/>import (<br/>  "testing"<br/>)<br/><br/>// NewKnowledgeGraph test method<br/>func TestNewKnowledgeGraph(test *testing.T) {<br/><br/>  var knowledgeGraph *KnowledgeGraph<br/><br/>  knowledgeGraph = NewKnowledgeGraph()<br/><br/>  test.Log(knowledgeGraph)<br/><br/>  if knowledgeGraph == nil {<br/><br/>    test.Errorf("error in creating a knowledgeGraph")<br/>  }<br/><br/>}</pre>
<p class="mce-root"/>
<p class="p3"><span class="s1">Run the following command to execute the preceding code snippet:</span></p>
<pre class="p7"><strong>go test -run NewKnowledgeGraph -v</strong></pre>
<p class="p4"><span class="s3">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fa19e9a4-6010-4051-ad30-f51104b0c638.png" style="width:29.83em;height:7.83em;" width="590" height="153"/></p>
<p><span>The next section talks about the representation of the <strong>sparse matrix</strong>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sparse matrix representation using a list of lists</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">A sparse matrix is a two-dimensional list of <em>m</em> rows and <em>n</em> columns. The shape of a matrix is <em>m</em> x <em>n</em> if it consists of <em>m</em> rows and <em>n</em> columns. Sparse matrices are used for solving large-scale problems that do not require dense matrices. For example, partial differential equations are solved by using the </span><span><strong>finite element method</strong> </span><span>(<strong><span>FEM</span></strong>). Tuples of a sparse matrix are non-zero elements of the matrix.</span></p>
<p class="p3"><span class="s1">In the following code, a sparse matrix is modeled as a list of lists. A sparse matrix consists of cells that are a list of lists. Each cell has properties such as</span> <kbd>Row</kbd>, <kbd>Column</kbd>, and <kbd>Value</kbd>:</p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>  "fmt"<br/>)<br/><br/>//List of List<br/>type LOL struct {<br/>  Row int<br/>  Column int<br/>  Value float64<br/>}</pre>
<p class="mce-root"/>
<p>The next section talks about the <kbd>SparseMatrix</kbd> class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SparseMatrix class</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1"><kbd>SparseMatrix</kbd> has a <kbd>cells</kbd> array and <kbd>shape</kbd>, which is an integer array:</span></p>
<pre>//Sparse Matrix<br/>type SparseMatrix struct {<br/>  cells []LOL<br/>  shape [2]int<br/>}</pre>
<p>In the next section, the different <kbd>Sparse</kbd> methods of the <kbd>SparseMatrix</kbd> struct are implemented.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Shape method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>Shape</kbd> method of the <kbd>SparseMatrix</kbd> class returns the <kbd>shape</kbd> array elements:</span></p>
<pre>// Shape method<br/>func (sparseMatrix *SparseMatrix) Shape() (int, int) {<br/>  return sparseMatrix.shape[0], sparseMatrix.shape[1]<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NumNonZero method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>NumNonZero</kbd> method finds the cells with non-zero elements. The <kbd>NumNonZero</kbd> method of the <kbd>SparseMatrix</kbd> class returns the size of the cells array in <kbd>sparseMatrix</kbd>:</span></p>
<pre>// NumNonZero method<br/>func (sparseMatrix *SparseMatrix) NumNonZero() int {<br/>  return len(sparseMatrix.cells)<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The LessThan method</h1>
                </header>
            
            <article>
                
<p class="p4"><span class="s3">The <kbd>LessThan</kbd> method<span class="Apple-converted-space"> </span>compares the list of lists rows and columns and checks whether the row is less than <kbd>i</kbd> and that the column is less than <kbd>j</kbd>:</span></p>
<pre>// Less Than method<br/>func LessThan(lol LOL, i int, j int) bool {<br/><br/>  if lol.Row &lt; i &amp;&amp; lol.Column &lt; j {<br/><br/>    return true<br/>  }<br/><br/>  return false<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Equal method</h1>
                </header>
            
            <article>
                
<p class="p4"><span class="s3">The <kbd>Equal</kbd> method checks whether the list of lists rows and columns are equal to <kbd>i</kbd> and <kbd>j</kbd>, respectively:</span></p>
<pre>// Equal method<br/>func Equal(lol LOL, i int, j int) bool {<br/>  if lol.Row == i &amp;&amp; lol.Column == j {<br/>    return true<br/>  }<br/>  return false<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The GetValue method</h1>
                </header>
            
            <article>
                
<p class="p4"><span class="s3">The <kbd>GetValue</kbd> method of the <kbd>SparseMatrix</kbd> class returns the value of the cell whose row and column equal <kbd>i</kbd> and <kbd>j</kbd>, respectively:</span></p>
<pre>// GetValue method<br/>func (sparseMatrix *SparseMatrix) GetValue(i int, j int) float64 {<br/>  var lol LOL<br/>  for _, lol = range sparseMatrix.cells {<br/>    if LessThan(lol, i, j) {<br/>      continue<br/>    }<br/>    if Equal(lol, i, j) {<br/>      return lol.Value<br/>    }<br/>    return 0.0<br/>  }<br/>  return 0.0<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The SetValue method</h1>
                </header>
            
            <article>
                
<p class="p4"><span class="s3">The <kbd>SetValue</kbd> method of the <kbd>SparseMatrix</kbd> class sets the value of the cell with the row and column equal to <kbd>i</kbd> and <kbd>j</kbd>, respectively, as the parameter value:</span></p>
<pre>//SetValue method<br/>func (sparseMatrix *SparseMatrix) SetValue(i int, j int, value float64) {<br/><br/>  var lol LOL<br/>  var index int<br/>  for index, lol = range sparseMatrix.cells {<br/>    if LessThan(lol, i, j) {<br/>      continue<br/>    }<br/>    if Equal(lol, i, j) {<br/>      sparseMatrix.cells[index].Value = value<br/>      return<br/>    }<br/><br/>    sparseMatrix.cells = append(sparseMatrix.cells, LOL{})<br/>    var k int<br/>    for k = len(sparseMatrix.cells) - 2; k &gt;= index; k-- {<br/>      sparseMatrix.cells[k+1] = sparseMatrix.cells[k]<br/>    }<br/>    sparseMatrix.cells[index] = LOL{<br/>      Row: i,<br/>      Column: j,<br/>      Value: value,<br/>    }<br/>    return<br/>  }<br/>  sparseMatrix.cells = append(sparseMatrix.cells, LOL{<br/>    Row: i,<br/>    Column: j,<br/>    Value: value,<br/>  })<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NewSparseMatrix method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>NewSparseMatrix</kbd> method takes the <kbd>m</kbd> and <kbd>n</kbd> as <span>parameters </span>and returns the initialized matrix:<br/></span></p>
<pre>// New SparseMatrix method<br/>func NewSparseMatrix(m int, n int) *SparseMatrix {<br/>  return &amp;SparseMatrix{<br/>    cells: []LOL{},<br/>    shape: [2]int{m, n},<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>main</kbd> method creates the sparse matrix by invoking the <kbd>NewSparseMatrix</kbd> <span>method</span>. The values are set in cells (<kbd>1</kbd>, <kbd>1</kbd>) and (<kbd>1</kbd>, <kbd>3</kbd>). The sparse matrix and the number of non-zero cells<span class="Apple-converted-space"> </span>are printed:</span></p>
<pre>// main method<br/>func main() {<br/><br/>  var sparseMatrix *SparseMatrix<br/><br/>  sparseMatrix = NewSparseMatrix(3, 3)<br/><br/>  sparseMatrix.SetValue(1, 1, 2.0)<br/>  sparseMatrix.SetValue(1, 3, 3.0)<br/><br/>  fmt.Println(sparseMatrix)<br/>  fmt.Println(sparseMatrix.NumNonZero())<br/>}</pre>
<p class="p3"><span class="s1">Run the following command to execute the <kbd>sparse_matrix.go</kbd> file:</span></p>
<pre class="p7"><strong><span class="s1">go run sparse_matrix.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ee13443f-9fff-483b-847c-9087caeaf52c.png" style="width:38.75em;height:6.75em;" width="580" height="101"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">This chapter covered how to present networks and sparse matrices using graphs and a list of lists, respectively. </span>Social network representation, map layouts, and knowledge graphs were discussed in detail with code examples. The different sparse matrix methods were also implemented with the appropriate code.</p>
<p class="p3"><span class="s1">In the next chapter, algorithms such as</span> garbage collection, cache management, and space allocation <span class="s1">will be presented with code examples and an efficiency analysis.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ul>
<li><span class="s1">What data structure is used to represent a set of linked objects?</span></li>
<li>What is a two-dimensional matrix with Boolean values called?</li>
<li>Give a code example for a network representation using a graph.</li>
<li>Which metrics can be calculated from a social graph?</li>
<li>What is a cartographic design?</li>
<li>Give an example of a knowledge graph and define the class, slots, and facets.</li>
<li>What are the applications of sparse matrices?</li>
<li>Define a list of lists and write a code sample.</li>
<li>What is a map layout?</li>
<li>What different operations can be performed using graphs?</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="p15"><span class="s1">The following books are recommended if you want to know more about graphs and list of lists:</span></p>
<ul>
<li><em>Design Patterns</em>, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides</li>
<li><em>Introduction to Algorithms – Thi<span>rd Edition</span></em>, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein</li>
<li><em>Data structures and Algorithms: An Easy Introduction</em>, by Rudolph Russell</li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>