["```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n// Social Graph\ntype SocialGraph struct {\n  Size int\n  Links [][]Link\n}\n```", "```go\n// Link class\ntype Link struct {\n  Vertex1 int\n  Vertex2 int\n  LinkWeight int\n}\n```", "```go\n// NewSocialGraph method\nfunc NewSocialGraph(num int) *SocialGraph {\n  return &SocialGraph{\n    Size: num,\n    Links: make([][]Link, num),\n  }\n}\n```", "```go\n// AddLink method\nfunc (socialGraph *SocialGraph) AddLink(vertex1 int, vertex2 int, weight int) {\n  socialGraph.Links[vertex1] = append(socialGraph.Links[vertex1], Link{Vertex1: vertex1, Vertex2: vertex2, LinkWeight: weight})\n}\n```", "```go\n// Print Links Example\nfunc (socialGraph *SocialGraph) PrintLinks() {\n\n  var vertex int\n  vertex = 0\n\n  fmt.Printf(\"Printing all links from %d\\n\", vertex)\n  var link Link\n  for _, link = range socialGraph.Links[vertex] {\n    fmt.Printf(\"Link: %d -> %d (%d)\\n\", link.Vertex1, link.Vertex2, link.LinkWeight)\n  }\n\n  fmt.Println(\"Printing all links in graph.\")\n  var adjacent []Link\n  for _, adjacent = range socialGraph.Links {\n    for _, link = range adjacent {\n      fmt.Printf(\"Link: %d -> %d (%d)\\n\", link.Vertex1, link.Vertex2, link.LinkWeight)\n    }\n  }\n}\n```", "```go\n// main method\nfunc main() {\n\n  var socialGraph *SocialGraph\n\n  socialGraph = NewSocialGraph(4)\n\n  socialGraph.AddLink(0, 1, 1)\n  socialGraph.AddLink(0, 2, 1)\n  socialGraph.AddLink(1, 3, 1)\n  socialGraph.AddLink(2, 4, 1)\n\n  socialGraph.PrintLinks()\n\n}\n```", "```go\ngo run social_graph.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing testing package\nimport (\n  \"fmt\"\n  \"testing\"\n)\n// NewSocialGraph test method\nfunc TestNewSocialGraph(test *testing.T) {\n\n  var socialGraph *SocialGraph\n\n  socialGraph = NewSocialGraph(1)\n\n  if socialGraph == nil {\n\n    test.Errorf(\"error in creating a social Graph\")\n  }\n\n}\n```", "```go\ngo test -run NewSocialGraph -v\n```", "```go\n///Main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n\ntype Name string\n\ntype SocialGraph struct {\n  GraphNodes map[Name]struct{}\n  Links map[Name]map[Name]struct{}\n}\n```", "```go\n// NewSocialGraph method\nfunc NewSocialGraph() *SocialGraph {\n  return &SocialGraph{\n    GraphNodes: make(map[Name]struct{}),\n    Links: make(map[Name]map[Name]struct{}),\n  }\n}\n```", "```go\n// AddEntity method\nfunc (socialGraph *SocialGraph) AddEntity(name Name) bool {\n\n  var exists bool\n  if _, exists = socialGraph.GraphNodes[name]; exists {\n    return true\n  }\n  socialGraph.GraphNodes[name] = struct{}{}\n  return true\n}\n```", "```go\n// Add Link\nfunc (socialGraph *SocialGraph) AddLink(name1 Name, name2 Name) {\n  var exists bool\n  if _, exists = socialGraph.GraphNodes[name1]; !exists {\n    socialGraph.AddEntity(name1)\n  }\n  if _, exists = socialGraph.GraphNodes[name2]; !exists {\n    socialGraph.AddEntity(name2)\n  }\n  if _, exists = socialGraph.Links[name1]; !exists {\n    socialGraph.Links[name1] = make(map[Name]struct{})\n  }\n  socialGraph.Links[name1][name2] = struct{}{}\n}\n```", "```go\nfunc (socialGraph *SocialGraph) PrintLinks() {\n  var root Name\n  root = Name(\"Root\") \n\n  fmt.Printf(\"Printing all links adjacent to %d\\n\", root)\n\n  var node Name\n  for node = range socialGraph.Links[root] {\n    // Edge exists from u to v.\n    fmt.Printf(\"Link: %d -> %d\\n\", root, node)\n  }\n\n  var m map[Name]struct{}\n  fmt.Println(\"Printing all links.\")\n  for root, m = range socialGraph.Links {\n    var vertex Name\n    for vertex = range m {\n      // Edge exists from u to v.\n      fmt.Printf(\"Link: %d -> %d\\n\", root, vertex)\n    }\n  }\n}\n```", "```go\n// main method\nfunc main() {\n\n  var socialGraph *SocialGraph\n\n   socialGraph = NewSocialGraph()\n\n   var root Name = Name(\"Root\")\n   var john Name = Name(\"John Smith\")\n   var per Name = Name(\"Per Jambeck\")\n   var cynthia Name = Name(\"Cynthia Gibas\")\n\n   socialGraph.AddEntity(root)\n   socialGraph.AddEntity(john)\n   socialGraph.AddEntity(per)\n   socialGraph.AddEntity(cynthia)\n\n   socialGraph.AddLink(root, john)\n   socialGraph.AddLink(root, per)\n   socialGraph.AddLink(root, cynthia)\n\n   var mayo Name = Name(\"Mayo Smith\")\n   var lorrie Name = Name(\"Lorrie Jambeck\")\n   var ellie Name = Name(\"Ellie Vlocksen\")\n\n   socialGraph.AddLink(john, mayo)\n   socialGraph.AddLink(john, lorrie)\n   socialGraph.AddLink(per, ellie)\n\n   socialGraph.PrintLinks()\n}\n```", "```go\ngo run social_graph_example.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n\n// Place class\ntype Place struct {\n\n    Name string\n    Latitude float64\n    Longitude float64\n\n}\n```", "```go\n// MapLayout class\ntype MapLayout struct {\n  GraphNodes map[Place]struct{}\n  Links map[Place]map[Place]struct{}\n}\n```", "```go\n// NewMapLayout method\nfunc NewMapLayout() *MapLayout {\n  return &MapLayout{\n    GraphNodes: make(map[Place]struct{}),\n    Links: make(map[Place]map[Place]struct{}),\n  }\n}\n```", "```go\n// AddPlace method\nfunc (mapLayout *MapLayout) AddPlace(place Place) bool {\n\n  var exists bool\n  if _, exists = mapLayout.GraphNodes[place]; exists {\n    return true\n  }\n  mapLayout.GraphNodes[place] = struct{}{}\n  return true\n}\n```", "```go\n// Add Link\nfunc (mapLayout *MapLayout) AddLink(place1 Place, place2 Place) {\n  var exists bool\n  if _, exists = mapLayout.GraphNodes[place1]; !exists {\n    mapLayout.AddPlace(place1)\n  }\n  if _, exists = mapLayout.GraphNodes[place2]; !exists {\n    mapLayout.AddPlace(place2)\n  }\n\n  if _, exists = mapLayout.Links[place1]; !exists {\n    mapLayout.Links[place1] = make(map[Place]struct{})\n  }\n  mapLayout.Links[place1][place2] = struct{}{}\n\n}\n```", "```go\n// PrintLinks method\nfunc (mapLayout *MapLayout) PrintLinks() {\n  var root Place\n  root = Place{\"Algeria\", 3, 28}\n\n  fmt.Printf(\"Printing all links adjacent to %s\\n\", root.Name)\n\n  var node Place\n  for node = range mapLayout.Links[root] {\n    fmt.Printf(\"Link: %s -> %s\\n\", root.Name, node.Name)\n  }\n\n  var m map[Place]struct{}\n  fmt.Println(\"Printing all links.\")\n  for root, m = range mapLayout.Links {\n    var vertex Place\n    for vertex = range m {\n      fmt.Printf(\"Link: %s -> %s\\n\", root.Name, vertex.Name)\n    }\n  }\n}\n```", "```go\n// main method\nfunc main() {\n\n  var mapLayout *MapLayout\n\n   mapLayout = NewMapLayout()\n\n   var root Place = Place{\"Algeria\", 3, 28}\n   var netherlands Place = Place{\"Netherlands\", 5.75, 52.5}\n\n   var korea Place = Place{\"Korea\", 124.1, -8.36}\n   var tunisia Place = Place{\"Tunisia\", 9, 34}\n\n   mapLayout.AddPlace(root)\n   mapLayout.AddPlace(netherlands)\n   mapLayout.AddPlace(korea)\n   mapLayout.AddPlace(tunisia)\n\n   mapLayout.AddLink(root, netherlands)\n   mapLayout.AddLink(root,korea)\n   mapLayout.AddLink(root,tunisia)\n\n   var singapore Place = Place{\"Singapore\",103.8,1.36}\n   var uae Place = Place{\"UAE\",54,24}\n   var japan Place = Place{\"Japan\",139.75, 35.68}\n\n   mapLayout.AddLink(korea, singapore)\n   mapLayout.AddLink(korea,japan)\n   mapLayout.AddLink(netherlands,uae)\n\n   mapLayout.PrintLinks()\n}\n```", "```go\ngo run map_layout.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing testing package\nimport (\n  \"testing\"\n)\n\n// NewMapLayout test method\nfunc TestNewMapLayout(test *testing.T) {\n\n  var mapLayout *MapLayout\n\n  mapLayout = NewMapLayout()\n\n  test.Log(mapLayout)\n\n  if mapLayout == nil {\n\n    test.Errorf(\"error in creating a mapLayout\")\n  }\n\n}\n```", "```go\ngo test -run NewMapLayout -v\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n\n// Class Type\ntype Class struct {\n  Name string\n}\n```", "```go\n// Knowledge Graph type\ntype KnowledgeGraph struct {\n  GraphNodes map[Class]struct{}\n  Links map[Class]map[Class]struct{}\n}\n```", "```go\n// NewKnowledgeGraph method\nfunc NewKnowledgeGraph() *KnowledgeGraph {\n  return &KnowledgeGraph{\n    GraphNodes: make(map[Class]struct{}),\n    Links: make(map[Class]map[Class]struct{}),\n  }\n}\n```", "```go\n// AddClass method\nfunc (knowledgeGraph *KnowledgeGraph) AddClass(class Class) bool {\n\n  var exists bool\n  if _, exists = knowledgeGraph.GraphNodes[class]; exists {\n    return true\n  }\n  knowledgeGraph.GraphNodes[class] = struct{}{}\n  return true\n}\n```", "```go\n// Add Link\nfunc (knowledgeGraph *KnowledgeGraph) AddLink(class1 Class, class2 Class) {\n  var exists bool\n  if _, exists = knowledgeGraph.GraphNodes[class1]; !exists {\n    knowledgeGraph.AddClass(class1)\n  }\n  if _, exists = knowledgeGraph.GraphNodes[class2]; !exists {\n    knowledgeGraph.AddClass(class2)\n  }\n\n  if _, exists = knowledgeGraph.Links[class1]; !exists {\n    knowledgeGraph.Links[class1] = make(map[Class]struct{})\n  }\n  knowledgeGraph.Links[class1][class2] = struct{}{}\n\n}\n```", "```go\n// Print Links method\nfunc (knowledgeGraph *KnowledgeGraph) PrintLinks() {\n  var car Class\n  car = Class{\"Car\"}\n\n  fmt.Printf(\"Printing all links adjacent to %s\\n\", car.Name)\n\n  var node Class\n  for node = range knowledgeGraph.Links[car] {\n    fmt.Printf(\"Link: %s -> %s\\n\", car.Name, node.Name)\n  }\n\n  var m map[Class]struct{}\n  fmt.Println(\"Printing all links.\")\n  for car, m = range knowledgeGraph.Links {\n    var vertex Class\n    for vertex = range m {\n      fmt.Printf(\"Link: %s -> %s\\n\", car.Name, vertex.Name)\n    }\n  }\n}\n```", "```go\n// main method\nfunc main() {\n\n  var knowledgeGraph *KnowledgeGraph\n\n  knowledgeGraph = NewKnowledgeGraph()\n\n  var car = Class{\"Car\"}\n  var tyre = Class{\"Tyre\"}\n  var door = Class{\"Door\"}\n  var hood = Class{\"Hood\"}\n\n  knowledgeGraph.AddClass(car)\n  knowledgeGraph.AddClass(tyre)\n  knowledgeGraph.AddClass(door)\n  knowledgeGraph.AddClass(hood)\n\n  knowledgeGraph.AddLink(car, tyre)\n  knowledgeGraph.AddLink(car, door)\n  knowledgeGraph.AddLink(car, hood)\n\n  var tube = Class{\"Tube\"}\n  var axle = Class{\"Axle\"}\n  var handle = Class{\"Handle\"}\n  var windowGlass = Class{\"Window Glass\"}\n\n  knowledgeGraph.AddClass(tube)\n  knowledgeGraph.AddClass(axle)\n  knowledgeGraph.AddClass(handle)\n  knowledgeGraph.AddClass(windowGlass)\n\n  knowledgeGraph.AddLink(tyre, tube)\n  knowledgeGraph.AddLink(tyre, axle)\n  knowledgeGraph.AddLink(door, handle)\n  knowledgeGraph.AddLink(door, windowGlass)\n\n  knowledgeGraph.PrintLinks()\n}\n```", "```go\ngo run knowledge_catalog.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing testing package\nimport (\n  \"testing\"\n)\n\n// NewKnowledgeGraph test method\nfunc TestNewKnowledgeGraph(test *testing.T) {\n\n  var knowledgeGraph *KnowledgeGraph\n\n  knowledgeGraph = NewKnowledgeGraph()\n\n  test.Log(knowledgeGraph)\n\n  if knowledgeGraph == nil {\n\n    test.Errorf(\"error in creating a knowledgeGraph\")\n  }\n\n}\n```", "```go\ngo test -run NewKnowledgeGraph -v\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n  \"fmt\"\n)\n\n//List of List\ntype LOL struct {\n  Row int\n  Column int\n  Value float64\n}\n```", "```go\n//Sparse Matrix\ntype SparseMatrix struct {\n  cells []LOL\n  shape [2]int\n}\n```", "```go\n// Shape method\nfunc (sparseMatrix *SparseMatrix) Shape() (int, int) {\n  return sparseMatrix.shape[0], sparseMatrix.shape[1]\n}\n```", "```go\n// NumNonZero method\nfunc (sparseMatrix *SparseMatrix) NumNonZero() int {\n  return len(sparseMatrix.cells)\n}\n```", "```go\n// Less Than method\nfunc LessThan(lol LOL, i int, j int) bool {\n\n  if lol.Row < i && lol.Column < j {\n\n    return true\n  }\n\n  return false\n}\n```", "```go\n// Equal method\nfunc Equal(lol LOL, i int, j int) bool {\n  if lol.Row == i && lol.Column == j {\n    return true\n  }\n  return false\n}\n```", "```go\n// GetValue method\nfunc (sparseMatrix *SparseMatrix) GetValue(i int, j int) float64 {\n  var lol LOL\n  for _, lol = range sparseMatrix.cells {\n    if LessThan(lol, i, j) {\n      continue\n    }\n    if Equal(lol, i, j) {\n      return lol.Value\n    }\n    return 0.0\n  }\n  return 0.0\n}\n```", "```go\n//SetValue method\nfunc (sparseMatrix *SparseMatrix) SetValue(i int, j int, value float64) {\n\n  var lol LOL\n  var index int\n  for index, lol = range sparseMatrix.cells {\n    if LessThan(lol, i, j) {\n      continue\n    }\n    if Equal(lol, i, j) {\n      sparseMatrix.cells[index].Value = value\n      return\n    }\n\n    sparseMatrix.cells = append(sparseMatrix.cells, LOL{})\n    var k int\n    for k = len(sparseMatrix.cells) - 2; k >= index; k-- {\n      sparseMatrix.cells[k+1] = sparseMatrix.cells[k]\n    }\n    sparseMatrix.cells[index] = LOL{\n      Row: i,\n      Column: j,\n      Value: value,\n    }\n    return\n  }\n  sparseMatrix.cells = append(sparseMatrix.cells, LOL{\n    Row: i,\n    Column: j,\n    Value: value,\n  })\n}\n```", "```go\n// New SparseMatrix method\nfunc NewSparseMatrix(m int, n int) *SparseMatrix {\n  return &SparseMatrix{\n    cells: []LOL{},\n    shape: [2]int{m, n},\n  }\n}\n```", "```go\n// main method\nfunc main() {\n\n  var sparseMatrix *SparseMatrix\n\n  sparseMatrix = NewSparseMatrix(3, 3)\n\n  sparseMatrix.SetValue(1, 1, 2.0)\n  sparseMatrix.SetValue(1, 3, 3.0)\n\n  fmt.Println(sparseMatrix)\n  fmt.Println(sparseMatrix.NumNonZero())\n}\n```", "```go\ngo run sparse_matrix.go\n```"]