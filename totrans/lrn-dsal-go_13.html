<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Memory Management</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1"><strong>Memory management</strong> is a way to control and organize memory. Memory divisions are called <strong>blocks</strong>, and they are used for <span>running </span>different processes. The basic goal of memory management algorithms is to dynamically designate segments of memory to programs on demand. The algorithms free up memory for reuse when the objects in the memory are never required again. Garbage collection, cache management, and space allocation algorithms are good examples of memory management techniques. In software engineering, g</span>arbage collection is used to free up memory that's been allocated to those objects that won't be used again, thus helping in memory management. <span class="s1">The cache provides in-memory storage for data. You can sort the data in the cache into locale-specific groups. The data can be stored using key and value sets.</span></p>
<p class="p3"><span class="s1">This chapter covers the garbage collection, cache management, and space allocation algorithms. The memory management algorithms are presented with code samples and efficiency analyses. The following topics will be covered in this chapter:</span></p>
<ul>
<li class="li4"><span class="s3">Garbage collection</span></li>
<li class="li4"><span class="s3">Cache management</span></li>
<li class="li4"><span class="s3">Space allocation</span></li>
<li>Concepts—Go memory management</li>
</ul>
<p>We'll look at garbage collection first, then look at the different algorithms related to garbage collection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">Install Go Version 1.10 from G<span class="s4">olang (<a href="https://golang.org/">https://golang.org/</a>)</span>, choosing the right version for your OS.</span></p>
<p class="p4"><span class="s3">The G</span><span class="s3">itHub repository for the code in this chapter can be found here: <a href="https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter10">https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter10</a>.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Garbage collection</h1>
                </header>
            
            <article>
                
<p><strong>Garbage collection</strong> is a type of programmed memory management in which memory, currently occupied by objects <span>that will never be used again, is gathered</span>. John McCarthy was the first person to come up with garbage collection for managing Lisp memory management. This technique specifies which objects need to be de-allocated, and then discharges the memory. The strategies that are utilized for garbage collection are <strong>stack allocation</strong> and <strong>region interference</strong>. Sockets, relational database handles, user window objects, and file resources are not overseen by garbage collectors.</p>
<p>Garbage collection algorithms help reduce dangling pointer defects, double-free defects, and memory leaks. These algorithms are computing-intensive and cause decreased or uneven performance. According to Apple, one of the reasons for iOS not having garbage collection is that garbage collection needs five times the memory to match explicit memory management. In high-transactional systems, concurrent, incremental, and real-time garbage collectors help manage memory collection and release.</p>
<p class="p3"><span class="s1">Garbage collection algorithms depend on various factors:</span></p>
<ul>
<li class="li7"><span class="s3">GC throughput</span></li>
<li class="li7"><span class="s3">Heap overhead</span></li>
<li class="li7"><span class="s3">Pause times</span></li>
<li class="li7"><span class="s3">Pause frequency</span></li>
<li class="li7"><span class="s3">Pause distribution</span></li>
<li class="li7"><span class="s3">Allocation performance</span></li>
<li class="li7"><span class="s3">Compaction</span></li>
<li class="li7"><span class="s3">Concurrency</span></li>
<li class="li7"><span class="s3">Scaling</span></li>
<li class="li7"><span class="s3">Tuning</span></li>
<li class="li7"><span class="s3">Warm-up time</span></li>
<li class="li7"><span class="s3">Page release</span></li>
<li class="li7"><span class="s3">Portability</span></li>
<li class="li7"><span class="s3">Compatibility</span></li>
</ul>
<p>That's simple, deferred, one-bit, weighted reference counting, mark-and-sweep, and generational collection algorithms discussed in the following sections.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The ReferenceCounter class</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The following code snippet shows how references to <span>created </span>objects are maintained in the stack. The <kbd>ReferenceCounter</kbd> class has the number of references, including the pool of references and removed references, as properties:</span></p>
<pre>//main package has examples shown<br/>// in Hands-On Data Structures and algorithms with Go book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>    "fmt"<br/>    "sync"<br/>)<br/><br/>//Reference Counter<br/>type ReferenceCounter struct {<br/>    num *uint32<br/>    pool *sync.Pool<br/>    removed *uint32<br/>}</pre>
<p class="mce-root">Let's take a look at the method of the <kbd>ReferenceCounter</kbd> class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The newReferenceCounter method</h1>
                </header>
            
            <article>
                
<p>The <kbd>newReferenceCounter</kbd> method initializes a <kbd>ReferenceCounter</kbd> instance and returns a pointer to <kbd>ReferenceCounter</kbd>. This is shown in the following code:</p>
<pre>//new Reference Counter method<br/>func newReferenceCounter() *ReferenceCounter {<br/>    return &amp;ReferenceCounter{<br/>    num: new(uint32),<br/>    pool: &amp;sync.Pool{},<br/>    removed: new(uint32),<br/>    }<br/>}</pre>
<p class="mce-root">The <kbd>Stack</kbd> class is described in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Stack class</h1>
                </header>
            
            <article>
                
<p class="p8">The <kbd>Stack</kbd> class consists of a <kbd>references</kbd> array and <kbd>Count</kbd> as properties. This is shown in the following code:</p>
<pre class="p8">// Stack class<br/>type Stack struct {<br/>    references []*ReferenceCounter<br/>    Count int<br/>}</pre>
<p class="mce-root"><span>Let's take a look at the methods of the <kbd>Stack</kbd> class.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Stack class – a new method</h1>
                </header>
            
            <article>
                
<p class="p8">Now, let's look at the heap interface methods that are implemented by the <kbd>Stack</kbd> class. The new method initializes the <kbd>references</kbd> array, and the <span><kbd>Push</kbd> and <kbd>Pop</kbd> h</span>eap interface methods take the <kbd>reference</kbd> <span>parameter </span>to push and pop <kbd>reference</kbd> out of the stack. This is shown in the following code:</p>
<pre>// New method of Stack Class<br/>func (stack *Stack) New() {<br/>    stack.references = make([]*ReferenceCounter,0)<br/>}<br/><br/>// Push method<br/>func (stack *Stack) Push(reference *ReferenceCounter) {<br/>    stack.references = append(stack.references[:stack.Count], <br/>    reference)<br/>    stack.Count = stack.Count + 1<br/>}<br/><br/>// Pop method<br/>func (stack *Stack) Pop() *ReferenceCounter {<br/>    if stack.Count == 0 {<br/>        return nil<br/>    }<br/>var length int = len(stack.references)<br/>var reference *ReferenceCounter = stack.references[length -1]<br/>if length &gt; 1 {<br/>  stack.references = stack.references[:length-1]<br/>  } else {<br/>  stack.references = stack.references[0:]<br/>}<br/>    stack.Count = len(stack.references)<br/>    return reference<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p8">In the following code snippet, let's see how <kbd>Stack</kbd> is used. A <kbd>Stack</kbd> instance is initialized, and references are added to the stack by invoking the <kbd>Push</kbd> method. The <kbd>Pop</kbd> method is invoked and the output is printed:</p>
<pre class="p8">// main method<br/>func main() {<br/>    var stack *Stack = &amp;Stack{}<br/>    stack.New()<br/>    var reference1 *ReferenceCounter = newReferenceCounter()<br/>    var reference2 *ReferenceCounter = newReferenceCounter()<br/>    var reference3 *ReferenceCounter = newReferenceCounter()<br/>    var reference4 *ReferenceCounter = newReferenceCounter()<br/>    stack.Push(reference1)<br/>    stack.Push(reference2)<br/>    stack.Push(reference3)<br/>    stack.Push(reference4)<br/>    fmt.Println(stack.Pop(), stack.Pop(), stack.Pop(), stack.Pop())<br/>}</pre>
<p class="p3"><span class="s1">Run the following commands to execute the <kbd>stack_garbage_collection.go</kbd> file:</span></p>
<pre class="p8"><strong><span class="s1">go run stack_garbage_collection.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/39684366-3b9e-45fe-884f-c99f332a1ab4.png" width="849" height="115"/></p>
<p class="p3"><span class="s1">The reference counting, mark-and-sweep, and generational collection algorithms will be discussed in the following sections.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reference counting</h1>
                </header>
            
            <article>
                
<p><strong>Reference counting</strong> is a technique that's used for keeping the count of references, pointers, and handles to resources. Memory blocks, disk space, and objects are good examples of resources. This technique tracks each object as a resource. The metrics that are tracked are the number of references held by different objects. The objects are <span>recovered when they can never be referenced again</span>.</p>
<p>The number of references is used for runtime optimizations. Deutsch-Bobrow came up with the strategy of reference counting. This strategy was related to the number of updated references that were produced by references that were put in local variables. Henry Baker came up with a method that includes references in local variables that are deferred until needed.</p>
<p>In the following subsections, the simple, deferred, one-bit, and weighted techniques of reference counting will be discussed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Simple reference counting</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">Reference counting is related to keeping the number of references, pointers, and handles to a resource such as an object, block of memory, or disk space.<span class="Apple-converted-space"> </span>This technique is related to the number of references to de-allocated objects that are never referenced <span>again</span>.</span></p>
<p><span>The collection technique tracks, for each object, a tally of the number of references to the object.</span><span> The references are held by other objects. The object gets removed when the number of references to the object is zero. The removed object becomes inaccessible.</span> The removal of <span>a reference can prompt countless connected references to be purged. </span></p>
<p><span class="s1">The algorithm is time-consuming because of the size of the object graph and slow<span class="Apple-converted-space"> </span>access speed. </span></p>
<p class="p3">In the following code snippets, we can see a simple reference-counting algorithm being implemented. The <span><kbd>ReferenceCounter</kbd> class has number (<kbd>num</kbd>), <kbd>pool</kbd>, and <kbd>removed</kbd> references as properties:</span></p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing sync, atomic and fmt packages<br/>import (<br/>    "sync/atomic"<br/>    "sync"<br/>    "fmt"<br/>)<br/><br/>//Reference Counter<br/>type ReferenceCounter struct {<br/>    num *uint32<br/>    pool *sync.Pool<br/>    removed *uint32<br/>}</pre>
<p class="p8">The <kbd>newReferenceCounter</kbd>, <kbd>Add</kbd>, and <kbd>Subtract</kbd> methods of the <kbd>ReferenceCounter</kbd> class are shown in the following snippet:</p>
<pre>//new Reference Counter method<br/>func newReferenceCounter() ReferenceCounter {<br/>    return ReferenceCounter{<br/>        num: new(uint32),<br/>        pool: &amp;sync.Pool{},<br/>        removed: new(uint32),<br/>    }<br/>}<br/><br/>// Add method<br/>func (referenceCounter ReferenceCounter) Add() {<br/>    atomic.AddUint32(referenceCounter.num, 1)<br/>}<br/><br/>// Subtract method<br/>func (referenceCounter ReferenceCounter) Subtract() {<br/>    if atomic.AddUint32(referenceCounter.num, ^uint32(0)) == 0 {<br/>        atomic.AddUint32(referenceCounter.removed, 1)<br/>    }<br/>}</pre>
<p class="mce-root"><span>Let's look at the <kbd>main</kbd> method and see an example of simple reference counting. The <kbd>newReferenceCounter</kbd> method is invoked, and a reference is added by invoking the <kbd>Add</kbd> method. The <kbd>count</kbd> reference is printed at the end. This is shown in the following code snippet</span></p>
<pre>// main method<br/>func main() {<br/>    var referenceCounter ReferenceCounter<br/>    referenceCounter = newReferenceCounter()<br/>    referenceCounter.Add()<br/>    fmt.Println(*referenceCounter.count)<br/>}</pre>
<p class="mce-root"/>
<p class="p3"><span class="s1">Run the following commands to execute the <kbd>reference_counting.go</kbd> file:</span></p>
<pre class="p8"><strong><span class="s1">go run reference_counting.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7eb59ec1-667a-455b-8b4a-8d8bf42142cf.png" style="width:38.58em;height:6.00em;" width="591" height="92"/></p>
<p class="mce-root">The different types of reference counting techniques are described in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deferred reference counting</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1"><strong>Deferred reference counting</strong> is a procedure <span>in which references from different objects to a given object are checked and program-variable references are overlooked.</span> If the tally of the references is zero, that object will not be considered. This algorithm helps reduce the overhead of keeping <span>counts </span>up to date. Deferred reference counting is supported by many compilers.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">One-bit reference counting</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <strong>one-bit reference counting</strong> technique <span>utilizes a solitary bit flag to show whether an object has one or more references.</span> The flag is stored as part of the object pointer. <span>There is no requirement to spare any object for extra space in this technique. This technique is viable since the majority of objects have a reference count of 1.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Weighted reference counting</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The weighted reference counting technique <span>tallies the number of references to an object, and each reference is delegated a weight. This technique tracks the total weight of the references to an object. </span>Weighted reference counting was invented by Bevan, Watson, and Watson in 1987. The following code snippet shows an implementation of the weighted reference counting technique:</span></p>
<pre>//Reference Counter<br/>type ReferenceCounter struct {<br/>    num *uint32<br/>    pool *sync.Pool<br/>    removed *uint32<br/>    weight int<br/>}<br/><br/>//WeightedReference method<br/>func WeightedReference() int {<br/>    var references []ReferenceCounter<br/>    references = GetReferences(root)<br/>    var reference ReferenceCounter<br/>    var sum int<br/>    for _, reference = range references {<br/>        sum = sum + reference.weight<br/>    }<br/>    return sum<br/>}<br/><br/></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The mark-and-sweep algorithm</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <strong>mark-and-sweep algorithm</strong> is based on an idea that was proposed by Dijkstra in 1978.<span class="Apple-converted-space"> </span>In the garbage collection style, the heap consists of a graph of connected objects, which are white. This technique visits the objects and checks whether <span>they are specifically available by the application.</span> Globals and objects on the stack are shaded gray in this technique. Every gray object is darkened to black and filtered for pointers to other objects. Any white object found in the output is turned gray. This calculation is rehashed until there are no gray objects. White objects that are left out are inaccessible.</span></p>
<p class="p3"><span class="s1">A mutator in this algorithm handles concurrency by changing the pointers while the collector is running. It also takes care of the condition so that no black object points to a white object. The mark algorithm has the following steps:</span></p>
<ol>
<li>Mark the <kbd>root</kbd> object</li>
<li>Mark the <kbd>root</kbd> bit as <kbd>true</kbd> if the value of the bit is <kbd>false</kbd></li>
<li>For every reference of <kbd>root</kbd>, mark the reference, as in the first step</li>
</ol>
<p class="p3"><span class="s1">The following code snippet shows the marking algorithm. Let's look at the implementation of the <kbd>Mark</kbd> method:</span></p>
<pre>func Mark( root *object){<br/>   var markedAlready bool<br/>   markedAlready = IfMarked(root)<br/>   if !markedAlready {<br/>        map[root] = true<br/>   }<br/>   var references *object[]<br/>   references = GetReferences(root)<br/>   var reference *object<br/>   for _, reference = range references {<br/>       Mark(reference)<br/>   }<br/>}</pre>
<p class="p8">The sweep algorithm's pseudocode is presented here:</p>
<ul>
<li>For each object in the heap, mark the bit as <kbd>false</kbd> if the value of the bit is <kbd>true</kbd></li>
<li>If the value of the bit is <kbd>true</kbd>, release the object from the heap</li>
</ul>
<p>The sweep algorithm releases the objects that are marked for garbage collection.</p>
<p class="p4"><span class="s1">Now, let's look at the implementation of the</span> sweep<span class="s3"> </span><span class="s3">algorithm: </span></p>
<pre>func Sweep(){<br/>   var objects *[]object<br/>   objects = GetObjects()<br/>   var object *object<br/>   for _, object = range objects {<br/>   var markedAlready bool<br/>   markedAlready = IfMarked(object)<br/>   if markedAlready {<br/>        map[object] = true<br/>   }<br/>       Release(object)<br/>   }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The generational collection algorithm</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <strong>generational collection algorithm</strong> divides the heap of objects into generations. A generation of objects will be expired and collected by the algorithm based on their age. The algorithm promotes objects to older generations based on the age of the object in the garbage collection cycle.</span></p>
<p class="p3"><span class="s1">The entire heap needs to be scavenged, even if a generation is collected. Let's say generation <kbd>3</kbd> is collected; in this case, generations</span> <kbd>0</kbd>-<kbd>2</kbd> <span class="s1">are also scavenged. The generational collection algorithm is presented in the following code snippet:</span></p>
<pre>func GenerationCollect(){<br/>   var currentGeneration int<br/>   currentGeneration = 3<br/>   var objects *[]object<br/>   objects = GetObjectsFromOldGeneration(3)<br/>   var object *object<br/>   for _, object = range objects {<br/>       var markedAlready bool<br/>       markedAlready = IfMarked(object)<br/>       if markedAlready {<br/>           map[object] = true<br/>       }<br/>    }<br/>}</pre>
<p class="mce-root">We'll take a look at cache management in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cache management</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1"><strong>Cache management</strong> consists of managing static, dynamic, and variable information:</span></p>
<ul>
<li class="p3"><span class="s1">Static information never changes</span></li>
<li class="p3"><span class="s1">Dynamic information changes frequently</span></li>
<li class="p3"><span class="s1">Variable information changes less frequently than dynamic information</span></li>
</ul>
<p><span class="s1">The object cache is stored in various data structures, such as maps and trees. Maps have a key as an identifier and a value, which is an object.</span></p>
<p class="p3"><span class="s1">Cache objects can be related to memory, disks, pools, and streams. Caches have attributes related to time to live, group, and region. A region consists of a collection of mapped key-values. Regions can be independent of other regions. Cache configuration consists of defaults, regions, and auxiliaries.</span></p>
<p class="p3"><span class="s1">A typical cache manager has the following features:</span></p>
<ul>
<li class="li4"><span class="s3">Memory management</span></li>
<li class="li4"><span class="s3">Thread pool controls</span></li>
<li class="li4"><span class="s3">Grouping of elements</span></li>
<li class="li4"><span class="s3">Configurable runtime parameters</span></li>
<li class="li4"><span class="s3">Region data separation and configuration</span></li>
<li class="li4"><span class="s3">Remote synchronization</span></li>
<li class="li4"><span class="s3">Remote store recovery</span></li>
<li class="li4"><span class="s3">Event handling</span></li>
<li class="li4"><span class="s3">Remote server chaining and failover</span></li>
<li class="li4"><span class="s3"><span class="s3">Custom event logging</span></span></li>
<li class="li4"><span class="s3">Custom event queue injection</span></li>
<li class="li4"><span class="s3">Key pattern-matching retrieval</span></li>
<li class="li4"><span class="s3">Network-efficient multi-key retrieval</span></li>
</ul>
<p class="p3">The <kbd>CacheObject</kbd> class and the <kbd>Cache</kbd> class are described in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The CacheObject class</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1"><span class="Apple-converted-space">The</span> <kbd>CacheObject</kbd> class has <kbd>Value</kbd> and <kbd>TimeToLive</kbd> properties. This is shown in the following code:</span></p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt, sync and time packages<br/>import (<br/>    "fmt"<br/>    "sync"<br/>    "time"<br/>)<br/><br/>// CacheObject class<br/>type CacheObject struct {<br/>    Value string<br/>    TimeToLive int64<br/>}</pre>
<p class="mce-root">The <kbd>IfExpired</kbd> method of the <kbd>CacheObject</kbd> class is shown in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The IfExpired method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1"><kbd>IfExpired</kbd> checks whether the <kbd>cache</kbd> object has expired. The <kbd>IfExpired</kbd> method of <kbd>CacheObject</kbd><span class="Apple-converted-space"> </span>returns <kbd>true</kbd> if <kbd>TimeToLive</kbd> has not expired; otherwise, it returns <kbd>false</kbd>. This is shown in the following code:</span></p>
<pre>// IfExpired method<br/>func (cacheObject CacheObject) IfExpired() bool {<br/>    if cacheObject.TimeToLive == 0 {<br/>        return false<br/>    }<br/>    return time.Now().UnixNano() &gt; cacheObject.TimeToLive<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Cache class</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>Cache</kbd> class consists of <kbd>objects map</kbd> with a <kbd><span>string</span></kbd> key, a <kbd>CacheObject</kbd> <span>value, </span>and a <span><kbd>sync.RWMutex</kbd> </span>mutex. This is shown in the following code:</span></p>
<pre>//Cache class<br/>type Cache struct {<br/>    objects map[string]CacheObject<br/>    mutex *sync.RWMutex<br/>}</pre>
<p class="mce-root"><span>The <kbd>NewCache</kbd>, <kbd>GetObject</kbd>, and <kbd>SetValue</kbd> methods of the <kbd>Cache</kbd> class are shown in the following sections.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NewCache method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>NewCache</kbd> method returns a pointer to a cache, which is initialized with the <kbd>nil</kbd> map (that is, a map without values) and <kbd>RWMutex</kbd>. This is shown in the following code:</span></p>
<pre>//NewCache method<br/>func NewCache() *Cache {<br/>    return &amp;Cache{<br/>        objects: make(map[string]CacheObject),<br/>        mutex: &amp;sync.RWMutex{},<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The GetObject method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>GetObject</kbd> method retrieves the object given the cache key. The <kbd>GetObject</kbd> method of the <kbd>Cache</kbd> class returns the value of <kbd>cacheKey</kbd>. The <kbd>RLock</kbd> method on the <kbd>mutex</kbd> object of the cache is invoked, and the <kbd>RUnlock</kbd> method is deferred before returning the value of <kbd>cacheKey</kbd>. If the object has expired, the key value will be an empty string. This is shown in the following code:</span></p>
<pre>//GetObject method<br/>func (cache Cache) GetObject(cacheKey string) string {<br/>    cache.mutex.RLock()<br/>    defer cache.mutex.RUnlock()<br/>    var object CacheObject<br/>    object = cache.objects[cacheKey]<br/>    if object.IfExpired() {<br/>        delete(cache.objects, cacheKey)<br/>    return ""<br/>    }<br/>    return object.Value<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The SetValue method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>SetValue</kbd> method of the <kbd>Cache</kbd> class takes <kbd>cacheKey</kbd>, <kbd>cacheValue</kbd>, and <kbd>timeToLive</kbd> parameters. The <kbd>Lock</kbd> <span>method </span>on the <kbd>mutex</kbd> object of the cache is invoked, and the <kbd>Unlock</kbd> method is deferred.<span class="Apple-converted-space"> </span>A new <kbd>CacheObject</kbd> is created with <kbd>cacheValue</kbd> and <kbd>TimeToLive</kbd> as properties.<span class="Apple-converted-space"> </span>The created <kbd>cacheObject</kbd> is set as a value to map objects with the <kbd>cacheKey</kbd> key. This is shown in the following code:</span></p>
<pre class="p8">//SetValue method<br/>func (cache Cache) SetValue(cacheKey string, cacheValue string, timeToLive time.Duration) {<br/>    cache.mutex.Lock()<br/>    defer cache.mutex.Unlock()<br/>    cache.objects[cacheKey] = CacheObject{<br/>        Value: cacheValue,<br/>        TimeToLive: time.Now().Add(timeToLive).UnixNano(),<br/>    }<br/>}</pre>
<p class="mce-root">We'll implement the methods we just took a look at in the <kbd>main</kbd> method in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">The <kbd>main</kbd> method creates the cache by invoking the <kbd>NewCache</kbd> method. The key and value are set on the cache by invoking <kbd>setValue</kbd>. The value is accessed by calling the <kbd>GetObject</kbd> method of the <kbd>Cache</kbd> class. This is shown in the following code:</span></p>
<pre class="p8">// main method<br/>func main() {<br/>    var cache *Cache<br/>    cache = NewCache()<br/>    cache.SetValue("name", "john smith", 200000000)<br/>    var name string<br/>    name = cache.GetObject("name")<br/>    fmt.Println(name)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="p3"><span class="s1">Run the following command to execute the <kbd>cache_management.go</kbd> file:</span></p>
<pre class="p8"><strong><span class="s1">go run cache_management.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f9a21e93-be8d-4492-b87d-99deda377d18.png" style="width:41.58em;height:6.92em;" width="589" height="97"/></p>
<p><span>The next section talks about the space allocation algorithm.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Space allocation</h1>
                </header>
            
            <article>
                
<p class="p14"><span class="s1">Each function has stack frames associated with individual memory space. Functions have access to the memory inside the<span class="Apple-converted-space"> </span>frame, and a frame pointer points to the memory's location.<span class="Apple-converted-space"> </span>Transition between frames occurs when the function is invoked. Data is transferred by value from one frame to another during the transition.</span></p>
<p class="p14"><span class="s1">Stack frame creation and memory allocation is demonstrated in the following code. The <kbd>addOne</kbd> function takes <kbd>num</kbd> and increments it by one. The function prints the value and address of <kbd>num</kbd></span>:</p>
<pre>///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>    "fmt"<br/>)<br/><br/>// increment method<br/>func addOne(num int) {<br/>    num++<br/>    fmt.Println("added to num", num, "Address of num", &amp;num)<br/>}</pre>
<p class="mce-root"/>
<p class="p14"><span class="s1">The <kbd>main</kbd> method initializes the variable number as <kbd>17</kbd>. The number value and address are printed before and after invoking the <kbd>addOne</kbd> function. This is shown in the following code:</span></p>
<pre>// main method<br/>func main() {<br/>    var number int<br/>    number = 17<br/>    fmt.Println("value of number", number, "Address of number", <br/>    &amp;number)<br/>    addOne(number)<br/>    fmt.Println("value of number after adding One", number, "Address <br/>    of", &amp;number)<br/>}</pre>
<p class="p3"><span class="s1">Run the following command to execute the <kbd>stack_memory_allocation.go</kbd> file:</span></p>
<pre class="p8"><strong><span class="s1">go run stack_memory_allocation.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9eff9232-a8fa-4384-94e4-efd4969f5d40.png" style="width:39.42em;height:7.25em;" width="593" height="109"/></p>
<p class="mce-root">Frame pointers are explained in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pointers</h1>
                </header>
            
            <article>
                
<p class="p14"><span class="s1">Pointers have an address that is 4 or 8 bytes long, depending on whether you have a 32-bit or 64-bit architecture. The stack's main frame<span class="Apple-converted-space"> </span>consists of the number 17 with the address</span> <kbd>0xc420016058</kbd><span class="s1">. After adding one, a new frame with <kbd>num</kbd> equal to <kbd>18</kbd> and an address of</span> <kbd>0xc420016068</kbd> <span class="s1">is created.<span class="Apple-converted-space"> </span>The <kbd>main</kbd> method prints the stack's main frame after invoking the <kbd>addOne</kbd> function. </span><span class="s1">The code in the following sections demonstrates memory space allocation with pointers instead of actual values passed into a function.</span></p>
<p>The <kbd>AddOne</kbd> and main methods of pointers are shown in the following sections.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The addOne method</h1>
                </header>
            
            <article>
                
<p class="p14"><span class="s1">The <kbd>addOne</kbd> function takes a pointer to <kbd>num</kbd> and increments it by 1. The function prints the value, address, and pointer of <kbd>num</kbd>. This is shown in the following code:</span></p>
<pre class="p8">///main package has examples shown<br/>// in Go Data Structures and algorithms book<br/>package main<br/><br/>// importing fmt package<br/>import (<br/>    "fmt"<br/>)<br/><br/>// increment method<br/>func addOne(num *int) {<br/>    *num++<br/>    fmt.Println("added to num", num, "Address of num", &amp;num, "Value <br/>    Points To", *num )<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The main method</h1>
                </header>
            
            <article>
                
<p class="p14"><span class="s1">The <kbd>main</kbd> method initializes the variable number to <kbd>17</kbd>. The pointer to the number is passed to the <kbd>addOne</kbd> function. The number value and address is printed before and after invoking the <kbd>addOne</kbd> function.</span></p>
<p class="p14"><span class="s1"><span>In this example, the address of the number is the same as the </span><span>value of </span><span><kbd>num</kbd> in the <kbd>addOne</kbd> function. Pointers share the address</span><span class="Apple-converted-space"> </span><span>of the variable for the function to access for reads and writes within the stack frame. Pointer types are specific to every type that is declared. Pointers provide indirect memory access outside the function's stack frame. This is shown in the following code</span>:</span></p>
<pre class="p8">// main method<br/>func main() {<br/>    var number int<br/>    number = 17<br/>    fmt.Println("value of number", number, "Address of number", <br/>    &amp;number)<br/>    addOne(&amp;number)<br/>    fmt.Println("value of number after adding One", number, "Address <br/>    of", &amp;number)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="p3"><span class="s1">Run the following command to execute the <kbd>stack_memory_pointer.go</kbd> file:</span></p>
<pre class="p8"><strong><span class="s1">go run stack_memory_pointer.go</span></strong></pre>
<p class="p3"><span class="s1">The output is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a1b768d7-ed65-4637-8c12-840e94f6cac0.png" width="849" height="107"/></p>
<p class="p3">The next section talks about memory management in Go.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Concepts – Go memory management</h1>
                </header>
            
            <article>
                
<p>In Go, programmers don't need to worry about coding a variable's value placement in memory and space allocation. Garbage collection in Go is overseen by the memory manager. The <kbd>GOGC</kbd> variable is used to set a value for the initial garbage collection target percentage. Garbage collection is activated when the proportion of freshly allotted data to the live data that <span>remains after the previous garbage collection</span> reaches the target percentage. The default value of the <span><kbd>GOGC</kbd> variable </span>is <kbd>100</kbd>. This setting can be turned off, which stops garbage collection. The current implementation of garbage collection in Go uses the <strong>mark-and-sweep</strong> algorithm.</p>
<p>Some of the best practices that you can follow to improve memory management are as follows:</p>
<ul>
<li>Small objects can be combined into larger objects</li>
<li>Local variables that have escaped from their declaration scope can be promoted into heap allocations</li>
<li>Slice array pre-allocation can be performed to improve memory</li>
<li>Use <kbd>int8</kbd>, instead of <kbd>int</kbd>, because <kbd>int8</kbd> is a smaller data type</li>
<li>Objects that do not have any pointers will not be scanned by the garbage collector</li>
<li>FreeLists can be used to reuse transient objects and reduce the number of allocations</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Profiling</h1>
                </header>
            
            <article>
                
<p><strong>Profiling</strong> in Go can be enabled by using the <kbd>cpuprofile</kbd> and <kbd>memprofile</kbd> flags. The Go testing package has support for benchmarking and profiling. The <kbd>cpuprofile</kbd> flag can be invoked by the following command:</p>
<pre><strong>go test -run=none -bench=ClientServerParallel4 -cpuprofile=cprofile net/http</strong></pre>
<p>The benchmark can be written to a <kbd>cprofile</kbd> output file using the following command:</p>
<pre><strong>go tool pprof --text http.test cprof</strong></pre>
<p>Let's look at an example of how to profile the programs that you have written. The <kbd>flag.Parse</kbd> method reads the command-line flags. The CPU profiling output is written to a file. The <kbd>StopCPUProfile</kbd> method on the profiler is called to flush any pending file output that needs to be written before the program stops:</p>
<pre>var profile = flag.String("cpuprofile", "", "cpu profile to output file")<br/>func main() {<br/>    flag.Parse()<br/>    if *profile != "" {<br/>        var file *os.File<br/>        var err error<br/>        file, err = os.Create(*profile)<br/>        if err != nil {<br/>            log.Fatal(err)<br/>        }<br/>        pprof.StartCPUProfile(file)<br/>        defer pprof.StopCPUProfile()<br/>    }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p3"><span class="s1">This chapter covered the garbage collection, cache management, and memory space allocation algorithms. We looked at reference counting algorithms, including simple, deferred, one-bit, and weighted. The mark-and-sweep and generational collection algorithms were also presented with code examples. </span></p>
<p class="p3"><span class="s1">The next chapter will cover<span class="Apple-converted-space"> </span>the next steps we can take after going through this book.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="p16"><span class="s1">Which factors are considered when choosing a garbage collection algorithm?</span></li>
<li class="p16"><span class="s1">In which reference counting algorithm are program-variable references ignored?</span></li>
<li class="p16"><span class="s1">What is the type of reference counting algorithm in which a single-bit flag is used for counting?</span></li>
<li class="p16"><span class="s1">In which reference counting algorithm is a weight assigned to each reference?</span></li>
<li class="p16"><span class="s1">Who invented weighted reference counting?</span></li>
<li class="p16"><span class="s1">Which garbage collection algorithm was proposed by Dijkstra?</span></li>
<li class="p16"><span class="s1">What class handles concurrency when the mark-and-sweep collector is running?</span></li>
<li class="p16"><span class="s1">What are the criteria for promoting objects to older generations?</span></li>
<li class="p16"><span class="s1">Draw a flow chart for the cache management algorithm.</span></li>
<li class="p16"><span class="s1">How do you get indirect memory access outside a method's stack frame?</span></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="p16"><span class="s1">The following books are recommended if you want to know more about garbage collection:</span></p>
<ul>
<li><em>Design Patterns</em>, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides</li>
<li><em>Introduction to Algorithms – Thi<span>rd Edition</span></em>, by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein</li>
<li><em>Data structures and Algorithms: An Easy Introduction</em>, by Rudolph Russell</li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>