["```go\n//main package has examples shown\n// in Hands-On Data Structures and algorithms with Go book\npackage main\n\n// importing fmt package\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\n//Reference Counter\ntype ReferenceCounter struct {\n    num *uint32\n    pool *sync.Pool\n    removed *uint32\n}\n```", "```go\n//new Reference Counter method\nfunc newReferenceCounter() *ReferenceCounter {\n    return &ReferenceCounter{\n    num: new(uint32),\n    pool: &sync.Pool{},\n    removed: new(uint32),\n    }\n}\n```", "```go\n// Stack class\ntype Stack struct {\n    references []*ReferenceCounter\n    Count int\n}\n```", "```go\n// New method of Stack Class\nfunc (stack *Stack) New() {\n    stack.references = make([]*ReferenceCounter,0)\n}\n\n// Push method\nfunc (stack *Stack) Push(reference *ReferenceCounter) {\n    stack.references = append(stack.references[:stack.Count], \n    reference)\n    stack.Count = stack.Count + 1\n}\n\n// Pop method\nfunc (stack *Stack) Pop() *ReferenceCounter {\n    if stack.Count == 0 {\n        return nil\n    }\nvar length int = len(stack.references)\nvar reference *ReferenceCounter = stack.references[length -1]\nif length > 1 {\n  stack.references = stack.references[:length-1]\n  } else {\n  stack.references = stack.references[0:]\n}\n    stack.Count = len(stack.references)\n    return reference\n}\n```", "```go\n// main method\nfunc main() {\n    var stack *Stack = &Stack{}\n    stack.New()\n    var reference1 *ReferenceCounter = newReferenceCounter()\n    var reference2 *ReferenceCounter = newReferenceCounter()\n    var reference3 *ReferenceCounter = newReferenceCounter()\n    var reference4 *ReferenceCounter = newReferenceCounter()\n    stack.Push(reference1)\n    stack.Push(reference2)\n    stack.Push(reference3)\n    stack.Push(reference4)\n    fmt.Println(stack.Pop(), stack.Pop(), stack.Pop(), stack.Pop())\n}\n```", "```go\ngo run stack_garbage_collection.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing sync, atomic and fmt packages\nimport (\n    \"sync/atomic\"\n    \"sync\"\n    \"fmt\"\n)\n\n//Reference Counter\ntype ReferenceCounter struct {\n    num *uint32\n    pool *sync.Pool\n    removed *uint32\n}\n```", "```go\n//new Reference Counter method\nfunc newReferenceCounter() ReferenceCounter {\n    return ReferenceCounter{\n        num: new(uint32),\n        pool: &sync.Pool{},\n        removed: new(uint32),\n    }\n}\n\n// Add method\nfunc (referenceCounter ReferenceCounter) Add() {\n    atomic.AddUint32(referenceCounter.num, 1)\n}\n\n// Subtract method\nfunc (referenceCounter ReferenceCounter) Subtract() {\n    if atomic.AddUint32(referenceCounter.num, ^uint32(0)) == 0 {\n        atomic.AddUint32(referenceCounter.removed, 1)\n    }\n}\n```", "```go\n// main method\nfunc main() {\n    var referenceCounter ReferenceCounter\n    referenceCounter = newReferenceCounter()\n    referenceCounter.Add()\n    fmt.Println(*referenceCounter.count)\n}\n```", "```go\ngo run reference_counting.go\n```", "```go\n//Reference Counter\ntype ReferenceCounter struct {\n    num *uint32\n    pool *sync.Pool\n    removed *uint32\n    weight int\n}\n\n//WeightedReference method\nfunc WeightedReference() int {\n    var references []ReferenceCounter\n    references = GetReferences(root)\n    var reference ReferenceCounter\n    var sum int\n    for _, reference = range references {\n        sum = sum + reference.weight\n    }\n    return sum\n}\n\n```", "```go\nfunc Mark( root *object){\n   var markedAlready bool\n   markedAlready = IfMarked(root)\n   if !markedAlready {\n        map[root] = true\n   }\n   var references *object[]\n   references = GetReferences(root)\n   var reference *object\n   for _, reference = range references {\n       Mark(reference)\n   }\n}\n```", "```go\nfunc Sweep(){\n   var objects *[]object\n   objects = GetObjects()\n   var object *object\n   for _, object = range objects {\n   var markedAlready bool\n   markedAlready = IfMarked(object)\n   if markedAlready {\n        map[object] = true\n   }\n       Release(object)\n   }\n}\n```", "```go\nfunc GenerationCollect(){\n   var currentGeneration int\n   currentGeneration = 3\n   var objects *[]object\n   objects = GetObjectsFromOldGeneration(3)\n   var object *object\n   for _, object = range objects {\n       var markedAlready bool\n       markedAlready = IfMarked(object)\n       if markedAlready {\n           map[object] = true\n       }\n    }\n}\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt, sync and time packages\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// CacheObject class\ntype CacheObject struct {\n    Value string\n    TimeToLive int64\n}\n```", "```go\n// IfExpired method\nfunc (cacheObject CacheObject) IfExpired() bool {\n    if cacheObject.TimeToLive == 0 {\n        return false\n    }\n    return time.Now().UnixNano() > cacheObject.TimeToLive\n}\n```", "```go\n//Cache class\ntype Cache struct {\n    objects map[string]CacheObject\n    mutex *sync.RWMutex\n}\n```", "```go\n//NewCache method\nfunc NewCache() *Cache {\n    return &Cache{\n        objects: make(map[string]CacheObject),\n        mutex: &sync.RWMutex{},\n    }\n}\n```", "```go\n//GetObject method\nfunc (cache Cache) GetObject(cacheKey string) string {\n    cache.mutex.RLock()\n    defer cache.mutex.RUnlock()\n    var object CacheObject\n    object = cache.objects[cacheKey]\n    if object.IfExpired() {\n        delete(cache.objects, cacheKey)\n    return \"\"\n    }\n    return object.Value\n}\n```", "```go\n//SetValue method\nfunc (cache Cache) SetValue(cacheKey string, cacheValue string, timeToLive time.Duration) {\n    cache.mutex.Lock()\n    defer cache.mutex.Unlock()\n    cache.objects[cacheKey] = CacheObject{\n        Value: cacheValue,\n        TimeToLive: time.Now().Add(timeToLive).UnixNano(),\n    }\n}\n```", "```go\n// main method\nfunc main() {\n    var cache *Cache\n    cache = NewCache()\n    cache.SetValue(\"name\", \"john smith\", 200000000)\n    var name string\n    name = cache.GetObject(\"name\")\n    fmt.Println(name)\n}\n```", "```go\ngo run cache_management.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n    \"fmt\"\n)\n\n// increment method\nfunc addOne(num int) {\n    num++\n    fmt.Println(\"added to num\", num, \"Address of num\", &num)\n}\n```", "```go\n// main method\nfunc main() {\n    var number int\n    number = 17\n    fmt.Println(\"value of number\", number, \"Address of number\", \n    &number)\n    addOne(number)\n    fmt.Println(\"value of number after adding One\", number, \"Address \n    of\", &number)\n}\n```", "```go\ngo run stack_memory_allocation.go\n```", "```go\n///main package has examples shown\n// in Go Data Structures and algorithms book\npackage main\n\n// importing fmt package\nimport (\n    \"fmt\"\n)\n\n// increment method\nfunc addOne(num *int) {\n    *num++\n    fmt.Println(\"added to num\", num, \"Address of num\", &num, \"Value \n    Points To\", *num )\n}\n```", "```go\n// main method\nfunc main() {\n    var number int\n    number = 17\n    fmt.Println(\"value of number\", number, \"Address of number\", \n    &number)\n    addOne(&number)\n    fmt.Println(\"value of number after adding One\", number, \"Address \n    of\", &number)\n}\n```", "```go\ngo run stack_memory_pointer.go\n```", "```go\ngo test -run=none -bench=ClientServerParallel4 -cpuprofile=cprofile net/http\n```", "```go\ngo tool pprof --text http.test cprof\n```", "```go\nvar profile = flag.String(\"cpuprofile\", \"\", \"cpu profile to output file\")\nfunc main() {\n    flag.Parse()\n    if *profile != \"\" {\n        var file *os.File\n        var err error\n        file, err = os.Create(*profile)\n        if err != nil {\n            log.Fatal(err)\n        }\n        pprof.StartCPUProfile(file)\n        defer pprof.StopCPUProfile()\n    }\n```"]