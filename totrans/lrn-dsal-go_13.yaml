- en: Memory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Memory management** is a way to control and organize memory. Memory divisions
    are called **blocks**, and they are used for running different processes. The
    basic goal of memory management algorithms is to dynamically designate segments
    of memory to programs on demand. The algorithms free up memory for reuse when
    the objects in the memory are never required again. Garbage collection, cache
    management, and space allocation algorithms are good examples of memory management
    techniques. In software engineering, garbage collection is used to free up memory
    that''s been allocated to those objects that won''t be used again, thus helping
    in memory management. The cache provides in-memory storage for data. You can sort
    the data in the cache into locale-specific groups. The data can be stored using
    key and value sets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the garbage collection, cache management, and space allocation
    algorithms. The memory management algorithms are presented with code samples and
    efficiency analyses. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Space allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts—Go memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at garbage collection first, then look at the different algorithms
    related to garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install Go Version 1.10 from Golang ([https://golang.org/](https://golang.org/)),
    choosing the right version for your OS.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for the code in this chapter can be found here: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Garbage collection** is a type of programmed memory management in which memory,
    currently occupied by objects that will never be used again, is gathered. John
    McCarthy was the first person to come up with garbage collection for managing
    Lisp memory management. This technique specifies which objects need to be de-allocated,
    and then discharges the memory. The strategies that are utilized for garbage collection
    are **stack allocation** and **region interference**. Sockets, relational database
    handles, user window objects, and file resources are not overseen by garbage collectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection algorithms help reduce dangling pointer defects, double-free
    defects, and memory leaks. These algorithms are computing-intensive and cause
    decreased or uneven performance. According to Apple, one of the reasons for iOS
    not having garbage collection is that garbage collection needs five times the
    memory to match explicit memory management. In high-transactional systems, concurrent,
    incremental, and real-time garbage collectors help manage memory collection and
    release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Garbage collection algorithms depend on various factors:'
  prefs: []
  type: TYPE_NORMAL
- en: GC throughput
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause frequency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocation performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warm-up time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's simple, deferred, one-bit, weighted reference counting, mark-and-sweep,
    and generational collection algorithms discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The ReferenceCounter class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code snippet shows how references to created objects are maintained
    in the stack. The `ReferenceCounter` class has the number of references, including
    the pool of references and removed references, as properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the method of the `ReferenceCounter` class.
  prefs: []
  type: TYPE_NORMAL
- en: The newReferenceCounter method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `newReferenceCounter` method initializes a `ReferenceCounter` instance
    and returns a pointer to `ReferenceCounter`. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Stack` class is described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Stack class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Stack` class consists of a `references` array and `Count` as properties.
    This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the methods of the `Stack` class.
  prefs: []
  type: TYPE_NORMAL
- en: The Stack class – a new method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s look at the heap interface methods that are implemented by the
    `Stack` class. The new method initializes the `references` array, and the `Push`
    and `Pop` heap interface methods take the `reference` parameter to push and pop
    `reference` out of the stack. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code snippet, let''s see how `Stack` is used. A `Stack` instance
    is initialized, and references are added to the stack by invoking the `Push` method.
    The `Pop` method is invoked and the output is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands to execute the `stack_garbage_collection.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39684366-3b9e-45fe-884f-c99f332a1ab4.png)'
  prefs: []
  type: TYPE_IMG
- en: The reference counting, mark-and-sweep, and generational collection algorithms
    will be discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Reference counting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reference counting** is a technique that''s used for keeping the count of
    references, pointers, and handles to resources. Memory blocks, disk space, and
    objects are good examples of resources. This technique tracks each object as a
    resource. The metrics that are tracked are the number of references held by different
    objects. The objects are recovered when they can never be referenced again.'
  prefs: []
  type: TYPE_NORMAL
- en: The number of references is used for runtime optimizations. Deutsch-Bobrow came
    up with the strategy of reference counting. This strategy was related to the number
    of updated references that were produced by references that were put in local
    variables. Henry Baker came up with a method that includes references in local
    variables that are deferred until needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, the simple, deferred, one-bit, and weighted techniques
    of reference counting will be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Simple reference counting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reference counting is related to keeping the number of references, pointers,
    and handles to a resource such as an object, block of memory, or disk space. This
    technique is related to the number of references to de-allocated objects that
    are never referenced again.
  prefs: []
  type: TYPE_NORMAL
- en: The collection technique tracks, for each object, a tally of the number of references
    to the object. The references are held by other objects. The object gets removed
    when the number of references to the object is zero. The removed object becomes
    inaccessible. The removal of a reference can prompt countless connected references
    to be purged.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is time-consuming because of the size of the object graph and
    slow access speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippets, we can see a simple reference-counting algorithm
    being implemented. The `ReferenceCounter` class has number (`num`), `pool`, and
    `removed` references as properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newReferenceCounter`, `Add`, and `Subtract` methods of the `ReferenceCounter`
    class are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the `main` method and see an example of simple reference counting.
    The `newReferenceCounter` method is invoked, and a reference is added by invoking
    the `Add` method. The `count` reference is printed at the end. This is shown in
    the following code snippet
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands to execute the `reference_counting.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7eb59ec1-667a-455b-8b4a-8d8bf42142cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The different types of reference counting techniques are described in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred reference counting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deferred reference counting** is a procedure in which references from different
    objects to a given object are checked and program-variable references are overlooked. If
    the tally of the references is zero, that object will not be considered. This
    algorithm helps reduce the overhead of keeping counts up to date. Deferred reference
    counting is supported by many compilers.'
  prefs: []
  type: TYPE_NORMAL
- en: One-bit reference counting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **one-bit reference counting** technique utilizes a solitary bit flag to
    show whether an object has one or more references. The flag is stored as part
    of the object pointer. There is no requirement to spare any object for extra space
    in this technique. This technique is viable since the majority of objects have
    a reference count of 1.
  prefs: []
  type: TYPE_NORMAL
- en: Weighted reference counting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The weighted reference counting technique tallies the number of references
    to an object, and each reference is delegated a weight. This technique tracks
    the total weight of the references to an object. Weighted reference counting was
    invented by Bevan, Watson, and Watson in 1987\. The following code snippet shows
    an implementation of the weighted reference counting technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The mark-and-sweep algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **mark-and-sweep algorithm** is based on an idea that was proposed by Dijkstra
    in 1978. In the garbage collection style, the heap consists of a graph of connected
    objects, which are white. This technique visits the objects and checks whether they
    are specifically available by the application. Globals and objects on the stack
    are shaded gray in this technique. Every gray object is darkened to black and
    filtered for pointers to other objects. Any white object found in the output is
    turned gray. This calculation is rehashed until there are no gray objects. White
    objects that are left out are inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mutator in this algorithm handles concurrency by changing the pointers while
    the collector is running. It also takes care of the condition so that no black
    object points to a white object. The mark algorithm has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Mark the `root` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the `root` bit as `true` if the value of the bit is `false`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For every reference of `root`, mark the reference, as in the first step
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet shows the marking algorithm. Let''s look at the
    implementation of the `Mark` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The sweep algorithm''s pseudocode is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: For each object in the heap, mark the bit as `false` if the value of the bit
    is `true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value of the bit is `true`, release the object from the heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sweep algorithm releases the objects that are marked for garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the implementation of the sweep algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The generational collection algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **generational collection algorithm** divides the heap of objects into generations.
    A generation of objects will be expired and collected by the algorithm based on
    their age. The algorithm promotes objects to older generations based on the age
    of the object in the garbage collection cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire heap needs to be scavenged, even if a generation is collected. Let''s
    say generation `3` is collected; in this case, generations `0`-`2` are also scavenged.
    The generational collection algorithm is presented in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll take a look at cache management in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cache management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cache management** consists of managing static, dynamic, and variable information:'
  prefs: []
  type: TYPE_NORMAL
- en: Static information never changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic information changes frequently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable information changes less frequently than dynamic information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object cache is stored in various data structures, such as maps and trees.
    Maps have a key as an identifier and a value, which is an object.
  prefs: []
  type: TYPE_NORMAL
- en: Cache objects can be related to memory, disks, pools, and streams. Caches have
    attributes related to time to live, group, and region. A region consists of a
    collection of mapped key-values. Regions can be independent of other regions.
    Cache configuration consists of defaults, regions, and auxiliaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical cache manager has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread pool controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable runtime parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Region data separation and configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote store recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote server chaining and failover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom event logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom event queue injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key pattern-matching retrieval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network-efficient multi-key retrieval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CacheObject` class and the `Cache` class are described in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The CacheObject class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CacheObject` class has `Value` and `TimeToLive` properties. This is shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `IfExpired` method of the `CacheObject` class is shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The IfExpired method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IfExpired` checks whether the `cache` object has expired. The `IfExpired`
    method of `CacheObject` returns `true` if `TimeToLive` has not expired; otherwise,
    it returns `false`. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Cache class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Cache` class consists of `objects map` with a `string` key, a `CacheObject`
    value, and a `sync.RWMutex` mutex. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `NewCache`, `GetObject`, and `SetValue` methods of the `Cache` class are
    shown in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The NewCache method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NewCache` method returns a pointer to a cache, which is initialized with
    the `nil` map (that is, a map without values) and `RWMutex`. This is shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The GetObject method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GetObject` method retrieves the object given the cache key. The `GetObject`
    method of the `Cache` class returns the value of `cacheKey`. The `RLock` method
    on the `mutex` object of the cache is invoked, and the `RUnlock` method is deferred
    before returning the value of `cacheKey`. If the object has expired, the key value
    will be an empty string. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The SetValue method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `SetValue` method of the `Cache` class takes `cacheKey`, `cacheValue`,
    and `timeToLive` parameters. The `Lock` method on the `mutex` object of the cache
    is invoked, and the `Unlock` method is deferred. A new `CacheObject` is created
    with `cacheValue` and `TimeToLive` as properties. The created `cacheObject` is
    set as a value to map objects with the `cacheKey` key. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We'll implement the methods we just took a look at in the `main` method in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` method creates the cache by invoking the `NewCache` method. The
    key and value are set on the cache by invoking `setValue`. The value is accessed
    by calling the `GetObject` method of the `Cache` class. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `cache_management.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9a21e93-be8d-4492-b87d-99deda377d18.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about the space allocation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Space allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each function has stack frames associated with individual memory space. Functions
    have access to the memory inside the frame, and a frame pointer points to the
    memory's location. Transition between frames occurs when the function is invoked.
    Data is transferred by value from one frame to another during the transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stack frame creation and memory allocation is demonstrated in the following
    code. The `addOne` function takes `num` and increments it by one. The function
    prints the value and address of `num`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method initializes the variable number as `17`. The number value
    and address are printed before and after invoking the `addOne` function. This
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `stack_memory_allocation.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9eff9232-a8fa-4384-94e4-efd4969f5d40.png)'
  prefs: []
  type: TYPE_IMG
- en: Frame pointers are explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pointers have an address that is 4 or 8 bytes long, depending on whether you
    have a 32-bit or 64-bit architecture. The stack's main frame consists of the number
    17 with the address `0xc420016058`. After adding one, a new frame with `num` equal
    to `18` and an address of `0xc420016068` is created. The `main` method prints
    the stack's main frame after invoking the `addOne` function. The code in the following
    sections demonstrates memory space allocation with pointers instead of actual
    values passed into a function.
  prefs: []
  type: TYPE_NORMAL
- en: The `AddOne` and main methods of pointers are shown in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The addOne method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `addOne` function takes a pointer to `num` and increments it by 1\. The
    function prints the value, address, and pointer of `num`. This is shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` method initializes the variable number to `17`. The pointer to the
    number is passed to the `addOne` function. The number value and address is printed
    before and after invoking the `addOne` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the address of the number is the same as the value of `num`
    in the `addOne` function. Pointers share the address of the variable for the function
    to access for reads and writes within the stack frame. Pointer types are specific
    to every type that is declared. Pointers provide indirect memory access outside
    the function''s stack frame. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to execute the `stack_memory_pointer.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1b768d7-ed65-4637-8c12-840e94f6cac0.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section talks about memory management in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts – Go memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, programmers don't need to worry about coding a variable's value placement
    in memory and space allocation. Garbage collection in Go is overseen by the memory
    manager. The `GOGC` variable is used to set a value for the initial garbage collection
    target percentage. Garbage collection is activated when the proportion of freshly
    allotted data to the live data that remains after the previous garbage collection reaches
    the target percentage. The default value of the `GOGC` variable is `100`. This
    setting can be turned off, which stops garbage collection. The current implementation
    of garbage collection in Go uses the **mark-and-sweep** algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the best practices that you can follow to improve memory management
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Small objects can be combined into larger objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local variables that have escaped from their declaration scope can be promoted
    into heap allocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slice array pre-allocation can be performed to improve memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `int8`, instead of `int`, because `int8` is a smaller data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects that do not have any pointers will not be scanned by the garbage collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeLists can be used to reuse transient objects and reduce the number of allocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Profiling** in Go can be enabled by using the `cpuprofile` and `memprofile`
    flags. The Go testing package has support for benchmarking and profiling. The
    `cpuprofile` flag can be invoked by the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The benchmark can be written to a `cprofile` output file using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at an example of how to profile the programs that you have written.
    The `flag.Parse` method reads the command-line flags. The CPU profiling output
    is written to a file. The `StopCPUProfile` method on the profiler is called to
    flush any pending file output that needs to be written before the program stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the garbage collection, cache management, and memory space
    allocation algorithms. We looked at reference counting algorithms, including simple,
    deferred, one-bit, and weighted. The mark-and-sweep and generational collection
    algorithms were also presented with code examples.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover the next steps we can take after going through this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which factors are considered when choosing a garbage collection algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which reference counting algorithm are program-variable references ignored?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the type of reference counting algorithm in which a single-bit flag
    is used for counting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which reference counting algorithm is a weight assigned to each reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who invented weighted reference counting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which garbage collection algorithm was proposed by Dijkstra?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What class handles concurrency when the mark-and-sweep collector is running?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the criteria for promoting objects to older generations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a flow chart for the cache management algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you get indirect memory access outside a method's stack frame?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following books are recommended if you want to know more about garbage
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
