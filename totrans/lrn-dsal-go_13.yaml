- en: Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: '**Memory management** is a way to control and organize memory. Memory divisions
    are called **blocks**, and they are used for running different processes. The
    basic goal of memory management algorithms is to dynamically designate segments
    of memory to programs on demand. The algorithms free up memory for reuse when
    the objects in the memory are never required again. Garbage collection, cache
    management, and space allocation algorithms are good examples of memory management
    techniques. In software engineering, garbage collection is used to free up memory
    that''s been allocated to those objects that won''t be used again, thus helping
    in memory management. The cache provides in-memory storage for data. You can sort
    the data in the cache into locale-specific groups. The data can be stored using
    key and value sets.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存管理**是一种控制和组织内存的方式。内存分区称为**块**，它们用于运行不同的进程。内存管理算法的基本目标是根据需求动态地为程序分配内存段。当内存中的对象不再需要时，算法会释放内存。垃圾收集、缓存管理和空间分配算法是内存管理技术的良好示例。在软件工程中，垃圾收集用于释放分配给那些不再使用的对象的内存，从而帮助进行内存管理。缓存为数据提供内存存储。您可以将缓存中的数据按地域分组排序。数据可以使用键值集进行存储。'
- en: 'This chapter covers the garbage collection, cache management, and space allocation
    algorithms. The memory management algorithms are presented with code samples and
    efficiency analyses. The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了垃圾收集、缓存管理和空间分配算法。内存管理算法通过代码示例和效率分析进行展示。本章将涵盖以下主题：
- en: Garbage collection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: Cache management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存管理
- en: Space allocation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间分配
- en: Concepts—Go memory management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念——Go内存管理
- en: We'll look at garbage collection first, then look at the different algorithms
    related to garbage collection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看垃圾收集，然后查看与垃圾收集相关的不同算法。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Install Go Version 1.10 from Golang ([https://golang.org/](https://golang.org/)),
    choosing the right version for your OS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从Golang([https://golang.org/](https://golang.org/))安装Go版本1.10，选择适合您操作系统的正确版本。
- en: The GitHub repository for the code in this chapter can be found here: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter10).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的GitHub仓库可以在这里找到：[https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter10)。
- en: Garbage collection
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: '**Garbage collection** is a type of programmed memory management in which memory,
    currently occupied by objects that will never be used again, is gathered. John
    McCarthy was the first person to come up with garbage collection for managing
    Lisp memory management. This technique specifies which objects need to be de-allocated,
    and then discharges the memory. The strategies that are utilized for garbage collection
    are **stack allocation** and **region interference**. Sockets, relational database
    handles, user window objects, and file resources are not overseen by garbage collectors.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**垃圾收集**是一种程序化内存管理，其中收集当前由永远不会再次使用的对象占用的内存。约翰·麦卡锡是第一个提出垃圾收集来管理Lisp内存管理的人。该技术指定了哪些对象需要被释放，然后释放内存。用于垃圾收集的策略包括**栈分配**和**区域干扰**。套接字、关系数据库句柄、用户窗口对象和文件资源不受垃圾收集器的监管。'
- en: Garbage collection algorithms help reduce dangling pointer defects, double-free
    defects, and memory leaks. These algorithms are computing-intensive and cause
    decreased or uneven performance. According to Apple, one of the reasons for iOS
    not having garbage collection is that garbage collection needs five times the
    memory to match explicit memory management. In high-transactional systems, concurrent,
    incremental, and real-time garbage collectors help manage memory collection and
    release.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集算法有助于减少悬挂指针缺陷、双重释放缺陷和内存泄漏。这些算法计算密集，会导致性能下降或不均匀。据苹果公司称，iOS没有垃圾收集的原因之一是垃圾收集需要五倍的内存来匹配显式内存管理。在高交易系统中，并发、增量实时垃圾收集器有助于管理内存收集和释放。
- en: 'Garbage collection algorithms depend on various factors:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集算法依赖于各种因素：
- en: GC throughput
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC吞吐量
- en: Heap overhead
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆开销
- en: Pause times
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停时间
- en: Pause frequency
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停频率
- en: Pause distribution
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停分布
- en: Allocation performance
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配性能
- en: Compaction
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: Concurrency
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Scaling
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模化
- en: Tuning
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调优
- en: Warm-up time
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预热时间
- en: Page release
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面释放
- en: Portability
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植性
- en: Compatibility
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容性
- en: That's simple, deferred, one-bit, weighted reference counting, mark-and-sweep,
    and generational collection algorithms discussed in the following sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是简单、延迟、单比特、加权引用计数、标记-清除和代际收集算法，这些将在以下几节中讨论。
- en: The ReferenceCounter class
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ReferenceCounter`类'
- en: 'The following code snippet shows how references to created objects are maintained
    in the stack. The `ReferenceCounter` class has the number of references, including
    the pool of references and removed references, as properties:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了创建的对象引用如何在栈中维护。`ReferenceCounter`类具有引用数量属性，包括引用池和已删除引用：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's take a look at the method of the `ReferenceCounter` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ReferenceCounter`类的方法。
- en: The newReferenceCounter method
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`newReferenceCounter`方法'
- en: 'The `newReferenceCounter` method initializes a `ReferenceCounter` instance
    and returns a pointer to `ReferenceCounter`. This is shown in the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`newReferenceCounter`方法初始化一个`ReferenceCounter`实例，并返回对`ReferenceCounter`的指针。这在上面的代码中显示：'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Stack` class is described in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中描述了`Stack`类。
- en: The Stack class
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Stack`类'
- en: 'The `Stack` class consists of a `references` array and `Count` as properties.
    This is shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack`类由`references`数组和`Count`属性组成。这在上面的代码中显示：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's take a look at the methods of the `Stack` class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Stack`类的实现方法。
- en: The Stack class – a new method
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Stack`类 – 新方法'
- en: 'Now, let''s look at the heap interface methods that are implemented by the
    `Stack` class. The new method initializes the `references` array, and the `Push`
    and `Pop` heap interface methods take the `reference` parameter to push and pop
    `reference` out of the stack. This is shown in the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Stack`类实现的堆接口方法。新方法初始化`references`数组，`Push`和`Pop`堆接口方法使用`reference`参数将`reference`从栈中推入和弹出。这在上面的代码中显示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The main method
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要方法
- en: 'In the following code snippet, let''s see how `Stack` is used. A `Stack` instance
    is initialized, and references are added to the stack by invoking the `Push` method.
    The `Pop` method is invoked and the output is printed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，让我们看看如何使用`Stack`。初始化一个`Stack`实例，通过调用`Push`方法将引用添加到栈中。调用`Pop`方法并打印输出：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the following commands to execute the `stack_garbage_collection.go` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行`stack_garbage_collection.go`文件：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/39684366-3b9e-45fe-884f-c99f332a1ab4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39684366-3b9e-45fe-884f-c99f332a1ab4.png)'
- en: The reference counting, mark-and-sweep, and generational collection algorithms
    will be discussed in the following sections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几节中，将讨论引用计数、标记-清除和代际收集算法。
- en: Reference counting
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用计数
- en: '**Reference counting** is a technique that''s used for keeping the count of
    references, pointers, and handles to resources. Memory blocks, disk space, and
    objects are good examples of resources. This technique tracks each object as a
    resource. The metrics that are tracked are the number of references held by different
    objects. The objects are recovered when they can never be referenced again.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用计数**是一种用于跟踪引用、指针和资源句柄数量的技术。内存块、磁盘空间和对象是资源的良好例子。该技术将每个对象视为资源。跟踪的指标是不同对象持有的引用数量。当对象无法再次被引用时，对象将被恢复。'
- en: The number of references is used for runtime optimizations. Deutsch-Bobrow came
    up with the strategy of reference counting. This strategy was related to the number
    of updated references that were produced by references that were put in local
    variables. Henry Baker came up with a method that includes references in local
    variables that are deferred until needed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 引用数量用于运行时优化。Deutsch-Bobrow提出了引用计数的策略。这个策略与放入局部变量的引用产生的更新引用数量有关。Henry Baker提出了一种方法，该方法包括延迟到需要时才包含在局部变量中的引用。
- en: In the following subsections, the simple, deferred, one-bit, and weighted techniques
    of reference counting will be discussed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，将讨论引用计数的简单、延迟、单比特和加权技术。
- en: Simple reference counting
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单引用计数
- en: Reference counting is related to keeping the number of references, pointers,
    and handles to a resource such as an object, block of memory, or disk space. This
    technique is related to the number of references to de-allocated objects that
    are never referenced again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数与跟踪资源（如对象、内存块或磁盘空间）的引用数量有关。这项技术与不再被引用的已分配对象的引用数量有关。
- en: The collection technique tracks, for each object, a tally of the number of references
    to the object. The references are held by other objects. The object gets removed
    when the number of references to the object is zero. The removed object becomes
    inaccessible. The removal of a reference can prompt countless connected references
    to be purged.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 收集技术跟踪每个对象对对象的引用数量。引用由其他对象持有。当对象的引用数量为零时，对象被移除。被移除的对象变得不可访问。引用的移除可以触发无数相关引用的清除。
- en: The algorithm is time-consuming because of the size of the object graph and
    slow access speed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象图的大小和缓慢的访问速度，该算法耗时。
- en: 'In the following code snippets, we can see a simple reference-counting algorithm
    being implemented. The `ReferenceCounter` class has number (`num`), `pool`, and
    `removed` references as properties:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们可以看到一个简单的引用计数算法的实现。`ReferenceCounter` 类具有数字（`num`）、`pool` 和 `removed`
    引用作为属性：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `newReferenceCounter`, `Add`, and `Subtract` methods of the `ReferenceCounter`
    class are shown in the following snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了 `ReferenceCounter` 类的 `newReferenceCounter`、`Add` 和 `Subtract` 方法：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's look at the `main` method and see an example of simple reference counting.
    The `newReferenceCounter` method is invoked, and a reference is added by invoking
    the `Add` method. The `count` reference is printed at the end. This is shown in
    the following code snippet
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `main` 方法，并查看一个简单的引用计数的示例。调用 `newReferenceCounter` 方法，并通过调用 `Add` 方法添加引用。最后打印
    `count` 引用。这在上面的代码片段中显示。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the following commands to execute the `reference_counting.go` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行 `reference_counting.go` 文件：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/7eb59ec1-667a-455b-8b4a-8d8bf42142cf.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7eb59ec1-667a-455b-8b4a-8d8bf42142cf.png)'
- en: The different types of reference counting techniques are described in the following
    sections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节描述了不同类型的引用计数技术。
- en: Deferred reference counting
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟引用计数
- en: '**Deferred reference counting** is a procedure in which references from different
    objects to a given object are checked and program-variable references are overlooked. If
    the tally of the references is zero, that object will not be considered. This
    algorithm helps reduce the overhead of keeping counts up to date. Deferred reference
    counting is supported by many compilers.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟引用计数**是一种检查来自不同对象到指定对象的引用并忽略程序变量引用的程序。如果引用计数为零，则不会考虑该对象。此算法有助于减少保持计数更新的开销。延迟引用计数被许多编译器支持。'
- en: One-bit reference counting
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一位引用计数
- en: The **one-bit reference counting** technique utilizes a solitary bit flag to
    show whether an object has one or more references. The flag is stored as part
    of the object pointer. There is no requirement to spare any object for extra space
    in this technique. This technique is viable since the majority of objects have
    a reference count of 1.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**一位引用计数**技术使用一个单独的位标志来表示对象是否有一个或多个引用。该标志作为对象指针的一部分存储。在此技术中，无需为额外空间预留任何对象。由于大多数对象的引用计数为
    1，因此该技术是可行的。'
- en: Weighted reference counting
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加权引用计数
- en: 'The weighted reference counting technique tallies the number of references
    to an object, and each reference is delegated a weight. This technique tracks
    the total weight of the references to an object. Weighted reference counting was
    invented by Bevan, Watson, and Watson in 1987\. The following code snippet shows
    an implementation of the weighted reference counting technique:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 加权引用计数技术统计对象引用的数量，并为每个引用分配一个权重。该技术跟踪对象引用的总权重。加权引用计数技术由 Bevan、Watson 和 Watson
    在 1987 年发明。以下代码片段展示了加权引用计数技术的实现：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The mark-and-sweep algorithm
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记-清除算法
- en: The **mark-and-sweep algorithm** is based on an idea that was proposed by Dijkstra
    in 1978. In the garbage collection style, the heap consists of a graph of connected
    objects, which are white. This technique visits the objects and checks whether they
    are specifically available by the application. Globals and objects on the stack
    are shaded gray in this technique. Every gray object is darkened to black and
    filtered for pointers to other objects. Any white object found in the output is
    turned gray. This calculation is rehashed until there are no gray objects. White
    objects that are left out are inaccessible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**标记-清除算法**基于1978年由迪杰斯特拉提出的想法。在垃圾回收风格中，堆由一个由白色对象组成的连接图组成。这种技术遍历对象并检查它们是否被应用程序特别使用。在这个技术中，全局变量和栈上的对象被着色为灰色。每个灰色对象都会被加深为黑色并过滤出指向其他对象的指针。在输出中找到的任何白色对象都会变为灰色。这个计算会重新进行，直到没有灰色对象为止。未被包含的白色对象是不可访问的。'
- en: 'A mutator in this algorithm handles concurrency by changing the pointers while
    the collector is running. It also takes care of the condition so that no black
    object points to a white object. The mark algorithm has the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此算法中，一个突变者通过在收集器运行时更改指针来处理并发。它还负责确保没有黑色对象指向白色对象。标记算法有以下步骤：
- en: Mark the `root` object
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记`root`对象
- en: Mark the `root` bit as `true` if the value of the bit is `false`
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果位的值为`false`，则将`root`位标记为`true`
- en: For every reference of `root`, mark the reference, as in the first step
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个`root`引用，标记引用，就像第一步一样
- en: 'The following code snippet shows the marking algorithm. Let''s look at the
    implementation of the `Mark` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了标记算法。让我们看看`Mark`方法的实现：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The sweep algorithm''s pseudocode is presented here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描算法的伪代码如下所示：
- en: For each object in the heap, mark the bit as `false` if the value of the bit
    is `true`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于堆中的每个对象，如果位的值为`true`，则将该位标记为`false`
- en: If the value of the bit is `true`, release the object from the heap
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果位的值为`true`，则从堆中释放对象
- en: The sweep algorithm releases the objects that are marked for garbage collection.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描算法释放了标记为垃圾回收的对象。
- en: 'Now, let''s look at the implementation of the sweep algorithm:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看扫描算法的实现：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The generational collection algorithm
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世代收集算法
- en: The **generational collection algorithm** divides the heap of objects into generations.
    A generation of objects will be expired and collected by the algorithm based on
    their age. The algorithm promotes objects to older generations based on the age
    of the object in the garbage collection cycle.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**世代收集算法**将对象堆分为世代。根据对象的年龄，算法将使一代对象过期并被收集。根据垃圾收集周期中对象的年龄，算法将对象提升到较老的世代。'
- en: 'The entire heap needs to be scavenged, even if a generation is collected. Let''s
    say generation `3` is collected; in this case, generations `0`-`2` are also scavenged.
    The generational collection algorithm is presented in the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 即使收集了一代，也需要扫描整个堆。假设收集了`3`代；在这种情况下，`0`-`2`代也会被扫描。世代收集算法在以下代码片段中展示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll take a look at cache management in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中查看缓存管理。
- en: Cache management
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存管理
- en: '**Cache management** consists of managing static, dynamic, and variable information:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存管理**包括管理静态、动态和变量信息：'
- en: Static information never changes
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态信息永远不会改变
- en: Dynamic information changes frequently
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态信息变化频繁
- en: Variable information changes less frequently than dynamic information
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量信息比动态信息变化频率低
- en: The object cache is stored in various data structures, such as maps and trees.
    Maps have a key as an identifier and a value, which is an object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对象缓存存储在各种数据结构中，如映射和树。映射有一个作为标识符的键和一个作为对象的值。
- en: Cache objects can be related to memory, disks, pools, and streams. Caches have
    attributes related to time to live, group, and region. A region consists of a
    collection of mapped key-values. Regions can be independent of other regions.
    Cache configuration consists of defaults, regions, and auxiliaries.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存对象可以与内存、磁盘、池和流相关联。缓存具有与生存时间、组和区域相关的属性。区域由一组映射的键值对组成。区域可以独立于其他区域。缓存配置包括默认值、区域和辅助工具。
- en: 'A typical cache manager has the following features:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的缓存管理器具有以下功能：
- en: Memory management
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理
- en: Thread pool controls
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程池控制
- en: Grouping of elements
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素分组
- en: Configurable runtime parameters
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置的运行时参数
- en: Region data separation and configuration
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域数据分离和配置
- en: Remote synchronization
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程同步
- en: Remote store recovery
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程存储恢复
- en: Event handling
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理
- en: Remote server chaining and failover
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程服务器链路和故障转移
- en: Custom event logging
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义事件记录
- en: Custom event queue injection
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义事件队列注入
- en: Key pattern-matching retrieval
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键模式匹配检索
- en: Network-efficient multi-key retrieval
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络高效的多键检索
- en: The `CacheObject` class and the `Cache` class are described in the following
    sections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分将描述 `CacheObject` 类和 `Cache` 类。
- en: The CacheObject class
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CacheObject 类
- en: 'The `CacheObject` class has `Value` and `TimeToLive` properties. This is shown
    in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`CacheObject` 类具有 `Value` 和 `TimeToLive` 属性。这将在以下代码中展示：'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `IfExpired` method of the `CacheObject` class is shown in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`CacheObject` 类的 `IfExpired` 方法将在下一节展示。'
- en: The IfExpired method
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IfExpired 方法
- en: '`IfExpired` checks whether the `cache` object has expired. The `IfExpired`
    method of `CacheObject` returns `true` if `TimeToLive` has not expired; otherwise,
    it returns `false`. This is shown in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`IfExpired` 检查 `cache` 对象是否已过期。如果 `TimeToLive` 未过期，`CacheObject` 的 `IfExpired`
    方法返回 `true`；否则，返回 `false`。这将在以下代码中展示：'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Cache class
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存类
- en: 'The `Cache` class consists of `objects map` with a `string` key, a `CacheObject`
    value, and a `sync.RWMutex` mutex. This is shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cache` 类由具有 `string` 键、`CacheObject` 值和 `sync.RWMutex` 锁的 `objects map` 组成。这将在以下代码中展示：'
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `NewCache`, `GetObject`, and `SetValue` methods of the `Cache` class are
    shown in the following sections.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cache` 类的 `NewCache`、`GetObject` 和 `SetValue` 方法将在以下部分展示。'
- en: The NewCache method
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NewCache 方法
- en: 'The `NewCache` method returns a pointer to a cache, which is initialized with
    the `nil` map (that is, a map without values) and `RWMutex`. This is shown in
    the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewCache` 方法返回一个指向缓存的指针，该缓存使用 `nil` 映射（即没有值的映射）和 `RWMutex` 初始化。这将在以下代码中展示：'
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The GetObject method
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GetObject 方法
- en: 'The `GetObject` method retrieves the object given the cache key. The `GetObject`
    method of the `Cache` class returns the value of `cacheKey`. The `RLock` method
    on the `mutex` object of the cache is invoked, and the `RUnlock` method is deferred
    before returning the value of `cacheKey`. If the object has expired, the key value
    will be an empty string. This is shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetObject` 方法根据缓存键检索对象。`Cache` 类的 `GetObject` 方法返回 `cacheKey` 的值。在返回 `cacheKey`
    的值之前，在缓存的 `mutex` 对象上调用 `RLock` 方法，并延迟调用 `RUnlock` 方法。如果对象已过期，键值将是一个空字符串。这将在以下代码中展示：'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The SetValue method
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SetValue 方法
- en: 'The `SetValue` method of the `Cache` class takes `cacheKey`, `cacheValue`,
    and `timeToLive` parameters. The `Lock` method on the `mutex` object of the cache
    is invoked, and the `Unlock` method is deferred. A new `CacheObject` is created
    with `cacheValue` and `TimeToLive` as properties. The created `cacheObject` is
    set as a value to map objects with the `cacheKey` key. This is shown in the following
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cache` 类的 `SetValue` 方法接受 `cacheKey`、`cacheValue` 和 `timeToLive` 参数。在缓存的 `mutex`
    对象上调用 `Lock` 方法，并延迟调用 `Unlock` 方法。使用 `cacheValue` 和 `TimeToLive` 作为属性创建一个新的 `CacheObject`。创建的
    `cacheObject` 被设置为具有 `cacheKey` 键的映射对象的值。这将在以下代码中展示：'
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We'll implement the methods we just took a look at in the `main` method in the
    next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中在 `main` 方法中实现我们刚刚查看的方法。
- en: The main method
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main` 方法'
- en: 'The `main` method creates the cache by invoking the `NewCache` method. The
    key and value are set on the cache by invoking `setValue`. The value is accessed
    by calling the `GetObject` method of the `Cache` class. This is shown in the following
    code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法通过调用 `NewCache` 方法创建缓存。通过调用 `setValue` 在缓存上设置键和值。通过调用 `Cache` 类的 `GetObject`
    方法访问值。这将在以下代码中展示：'
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the following command to execute the `cache_management.go` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `cache_management.go` 文件：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/f9a21e93-be8d-4492-b87d-99deda377d18.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9a21e93-be8d-4492-b87d-99deda377d18.png)'
- en: The next section talks about the space allocation algorithm.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论空间分配算法。
- en: Space allocation
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间分配
- en: Each function has stack frames associated with individual memory space. Functions
    have access to the memory inside the frame, and a frame pointer points to the
    memory's location. Transition between frames occurs when the function is invoked.
    Data is transferred by value from one frame to another during the transition.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都与单个内存空间关联的堆栈帧。函数可以访问帧内的内存，并且一个帧指针指向内存的位置。当函数被调用时发生帧之间的转换。在转换期间，数据通过值从一帧传递到另一帧。
- en: 'Stack frame creation and memory allocation is demonstrated in the following
    code. The `addOne` function takes `num` and increments it by one. The function
    prints the value and address of `num`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了栈帧创建和内存分配。`addOne` 函数接收 `num` 并将其增加 1。函数打印 `num` 的值和地址：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `main` method initializes the variable number as `17`. The number value
    and address are printed before and after invoking the `addOne` function. This
    is shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法将变量数量初始化为 `17`。在调用 `addOne` 函数前后，打印了数值和地址。这在上面的代码中显示：'
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the following command to execute the `stack_memory_allocation.go` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行 `stack_memory_allocation.go` 文件：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/9eff9232-a8fa-4384-94e4-efd4969f5d40.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9eff9232-a8fa-4384-94e4-efd4969f5d40.png)'
- en: Frame pointers are explained in the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释帧指针。
- en: Pointers
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: Pointers have an address that is 4 or 8 bytes long, depending on whether you
    have a 32-bit or 64-bit architecture. The stack's main frame consists of the number
    17 with the address `0xc420016058`. After adding one, a new frame with `num` equal
    to `18` and an address of `0xc420016068` is created. The `main` method prints
    the stack's main frame after invoking the `addOne` function. The code in the following
    sections demonstrates memory space allocation with pointers instead of actual
    values passed into a function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的地址长度为 4 或 8 字节，具体取决于你是否有一个 32 位或 64 位架构。栈的主要帧由数字 17 和地址 `0xc420016058` 组成。在加一之后，创建了一个新的帧，其中
    `num` 等于 `18`，地址为 `0xc420016068`。`main` 方法在调用 `addOne` 函数后打印栈的主要帧。以下代码部分展示了使用指针而不是实际传递给函数的值进行内存空间分配。
- en: The `AddOne` and main methods of pointers are shown in the following sections.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分展示了指针的 `AddOne` 和 `main` 方法。
- en: The addOne method
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`addOne` 方法'
- en: 'The `addOne` function takes a pointer to `num` and increments it by 1\. The
    function prints the value, address, and pointer of `num`. This is shown in the
    following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`addOne` 函数接收 `num` 的指针并增加 1。函数打印 `num` 的值、地址和指针。这在上面的代码中显示：'
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The main method
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main` 方法'
- en: The `main` method initializes the variable number to `17`. The pointer to the
    number is passed to the `addOne` function. The number value and address is printed
    before and after invoking the `addOne` function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法将变量 `number` 初始化为 `17`。将数字的指针传递给 `addOne` 函数。在调用 `addOne` 函数前后，打印了数值和地址。'
- en: 'In this example, the address of the number is the same as the value of `num`
    in the `addOne` function. Pointers share the address of the variable for the function
    to access for reads and writes within the stack frame. Pointer types are specific
    to every type that is declared. Pointers provide indirect memory access outside
    the function''s stack frame. This is shown in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，数字的地址与 `addOne` 函数中 `num` 的值相同。指针共享变量的地址，以便函数在栈帧内进行读写操作。指针类型对每个声明的类型都是特定的。指针提供了在函数栈帧之外进行间接内存访问的能力。这在上面的代码中显示：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the following command to execute the `stack_memory_pointer.go` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行 `stack_memory_pointer.go` 文件：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/a1b768d7-ed65-4637-8c12-840e94f6cac0.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1b768d7-ed65-4637-8c12-840e94f6cac0.png)'
- en: The next section talks about memory management in Go.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论 Go 中的内存管理。
- en: Concepts – Go memory management
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念 – Go 内存管理
- en: In Go, programmers don't need to worry about coding a variable's value placement
    in memory and space allocation. Garbage collection in Go is overseen by the memory
    manager. The `GOGC` variable is used to set a value for the initial garbage collection
    target percentage. Garbage collection is activated when the proportion of freshly
    allotted data to the live data that remains after the previous garbage collection reaches
    the target percentage. The default value of the `GOGC` variable is `100`. This
    setting can be turned off, which stops garbage collection. The current implementation
    of garbage collection in Go uses the **mark-and-sweep** algorithm.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，程序员不需要担心在内存和空间分配中编码变量的值放置。Go 中的垃圾回收由内存管理器负责。`GOGC` 变量用于设置初始垃圾回收目标百分比的值。当新鲜分配的数据与之前垃圾回收后剩余的存活数据的比例达到目标百分比时，垃圾回收被激活。`GOGC`
    变量的默认值为 `100`。此设置可以关闭，这将停止垃圾回收。Go 中垃圾回收的当前实现使用 **标记-清除** 算法。
- en: 'Some of the best practices that you can follow to improve memory management
    are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遵循的一些最佳实践来提高内存管理如下：
- en: Small objects can be combined into larger objects
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小对象可以组合成更大的对象
- en: Local variables that have escaped from their declaration scope can be promoted
    into heap allocations
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出其声明作用域的局部变量可以被提升为堆分配
- en: Slice array pre-allocation can be performed to improve memory
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以执行切片数组预分配来提高内存
- en: Use `int8`, instead of `int`, because `int8` is a smaller data type
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`int8`而不是`int`，因为`int8`是一种更小的数据类型
- en: Objects that do not have any pointers will not be scanned by the garbage collector
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何指针的对象不会被垃圾回收器扫描
- en: FreeLists can be used to reuse transient objects and reduce the number of allocations
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用FreeLists来重用瞬态对象并减少分配的数量
- en: Profiling
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: '**Profiling** in Go can be enabled by using the `cpuprofile` and `memprofile`
    flags. The Go testing package has support for benchmarking and profiling. The
    `cpuprofile` flag can be invoked by the following command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，可以通过使用`cpuprofile`和`memprofile`标志来启用**性能分析**。Go测试包支持基准测试和性能分析。可以通过以下命令调用`cpuprofile`标志：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The benchmark can be written to a `cprofile` output file using the following
    command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令将基准测试写入`cprofile`输出文件：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s look at an example of how to profile the programs that you have written.
    The `flag.Parse` method reads the command-line flags. The CPU profiling output
    is written to a file. The `StopCPUProfile` method on the profiler is called to
    flush any pending file output that needs to be written before the program stops:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何对所编写的程序进行性能分析。`flag.Parse`方法读取命令行标志。CPU性能分析输出被写入文件。在程序停止之前，需要写入任何挂起的文件输出，此时将调用分析器的`StopCPUProfile`方法：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the garbage collection, cache management, and memory space
    allocation algorithms. We looked at reference counting algorithms, including simple,
    deferred, one-bit, and weighted. The mark-and-sweep and generational collection
    algorithms were also presented with code examples.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了垃圾回收、缓存管理和内存空间分配算法。我们探讨了包括简单、延迟、单比特和加权在内的引用计数算法。还展示了标记-清除和代际收集算法的代码示例。
- en: The next chapter will cover the next steps we can take after going through this
    book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍在阅读完本书之后我们可以采取的下一步行动。
- en: Questions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which factors are considered when choosing a garbage collection algorithm?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择垃圾回收算法时考虑哪些因素？
- en: In which reference counting algorithm are program-variable references ignored?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪种引用计数算法中，程序变量引用被忽略？
- en: What is the type of reference counting algorithm in which a single-bit flag
    is used for counting?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪种引用计数算法中使用单比特标志进行计数？
- en: In which reference counting algorithm is a weight assigned to each reference?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪种引用计数算法中，每个引用都被分配了一个权重？
- en: Who invented weighted reference counting?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁发明了加权引用计数？
- en: Which garbage collection algorithm was proposed by Dijkstra?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迪杰斯特拉提出了哪种垃圾回收算法？
- en: What class handles concurrency when the mark-and-sweep collector is running?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当标记-清除收集器运行时，哪个类处理并发？
- en: What are the criteria for promoting objects to older generations?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提升对象到较老代的标准是什么？
- en: Draw a flow chart for the cache management algorithm.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制缓存管理算法的流程图。
- en: How do you get indirect memory access outside a method's stack frame?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在方法栈帧外获取间接内存访问？
- en: Further reading
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following books are recommended if you want to know more about garbage
    collection:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于垃圾回收的信息，以下书籍推荐：
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《设计模式》*，作者：艾里克·伽玛、理查德·赫尔姆、拉尔夫·约翰逊和约翰·弗利斯'
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《算法导论 第3版》*，作者：托马斯·H·科门、查尔斯·E·莱伊森、罗纳德·L·里维斯和克利福德·斯坦'
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《数据结构和算法：简单入门》*，作者：鲁道夫·拉斯尔'
