<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer026">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 class="chapterTitle" id="_idParaDest-14"><span class="koboSpan" id="kobo.2.1">A Quick Introduction to Go</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Despite its name, this chapter is more than just a quick introduction to Go, as it is also going to be the foundation for the rest of the book. </span><span class="koboSpan" id="kobo.3.2">The basics of Go, some design decisions, and the philosophy of Go are explained in this chapter so that you can get the big picture before learning the details of Go. </span><span class="koboSpan" id="kobo.3.3">Among other things, we present the advantages and disadvantages of Go so that you know when to use Go and when to consider other alternatives.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">In the sections that follow, we cover a number of concepts and utilities in order to build a solid foundation of Go, before building a simplified version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5.1">which(1)</span></code><span class="koboSpan" id="kobo.6.1"> utility, which is a UNIX utility that locates program files by searching the directories of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.7.1">PATH</span></code><span class="koboSpan" id="kobo.8.1"> environment variable. </span><span class="koboSpan" id="kobo.8.2">Additionally, we explain how to write information in log files, as this can help you store error messages and warnings while you are developing software in Go.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">At the end of the chapter, we develop a basic command line utility that computes basic statistical properties. </span><span class="koboSpan" id="kobo.9.2">It is that command line utility that we are going to improve and expand in the remaining book chapters as we learn more advanced Go features.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.10.1">The contents of this chapter are:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Introducing Go</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">When to use Go</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Hello World!</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Running Go code</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">What you should know about Go</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Developing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">which(1)</span></code><span class="koboSpan" id="kobo.18.1"> utility in Go</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Logging information</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Developing a statistics application</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-15"><span class="koboSpan" id="kobo.21.1">Introducing Go</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.22.1">Go is an open-source </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.23.1">systems programming language, initially developed as an internal Google project that went public back in 2009. </span><span class="koboSpan" id="kobo.23.2">The spiritual fathers of Go are Robert Griesemer, Ken Thomson, and Rob Pike.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.24.1">Although the official name of the language is Go, it is sometimes (wrongly) referred to as </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Golang</span></em><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">The official reason for this is that </span><a href="https://go.org/"><span class="url"><span class="koboSpan" id="kobo.27.1">https://go.org/</span></span></a><span class="koboSpan" id="kobo.28.1"> was not available for registration and </span><a href="https://golang.org"><span class="url"><span class="koboSpan" id="kobo.29.1">golang.org</span></span></a><span class="koboSpan" id="kobo.30.1"> was chosen insteadâ€”however, nowadays, the official Go </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.31.1">website is </span><a href="https://go.dev/"><span class="url"><span class="koboSpan" id="kobo.32.1">https://go.dev/</span></span></a><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">Keep in mind that when you are querying a search engine for Go-related information, the word </span><em class="italic"><span class="koboSpan" id="kobo.34.1">Go</span></em><span class="koboSpan" id="kobo.35.1"> is usually interpreted as a verb; therefore, you should search for </span><em class="italic"><span class="koboSpan" id="kobo.36.1">golang</span></em><span class="koboSpan" id="kobo.37.1"> instead. </span><span class="koboSpan" id="kobo.37.2">Additionally, the official Twitter hashtag for Go is </span><em class="italic"><span class="koboSpan" id="kobo.38.1">#golang</span></em><span class="koboSpan" id="kobo.39.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.40.1">Let us now discuss the history of Go and what that means for someone who wants to learn Go.</span></p>
<h2 class="heading-2" id="_idParaDest-16"><span class="koboSpan" id="kobo.41.1">The history of Go</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.42.1">As mentioned earlier, Go</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.43.1"> started as an internal Google project that went public back in 2009. </span><span class="koboSpan" id="kobo.43.2">Griesemer, Thomson, and Pike designed Go as a language for professional programmers who want to build reliable, robust, and efficient software that is easy to manage. </span><span class="koboSpan" id="kobo.43.3">They designed Go with simplicity in mind, even if simplicity meant that Go was not going to be a programming language for everyone or everything.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.44.1">The figure that follows shows the programming languages that directly or indirectly influenced Go. </span><span class="koboSpan" id="kobo.44.2">As an example, Go syntax looks like C, whereas the package concept was inspired by Modula-2.</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.45.1"><img alt="A group of white squares with black text  Description automatically generated with low confidence" src="../Images/B21003_01_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.46.1">Figure 1.1: The programming languages that influenced Go</span></p>
<p class="normal"><span class="koboSpan" id="kobo.47.1">The deliverable was a programming language with tools and a standard library. </span><span class="koboSpan" id="kobo.47.2">What you get with Go, apart from its syntax and tools, is a rich standard library and a type system that tries to save you from easy mistakes, such as implicit type conversions, unused variables, and unused packages. </span><span class="koboSpan" id="kobo.47.3">The Go compiler catches most of these easy mistakes and refuses to compile until you do something about them. </span><span class="koboSpan" id="kobo.47.4">Additionally, the Go compiler can find difficult-to-catch mistakes such as race conditions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.48.1">If you are going to install Go for the first time, you can start by visiting </span><a href="https://go.dev/dl/"><span class="url"><span class="koboSpan" id="kobo.49.1">https://go.dev/dl/</span></span></a><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">However, there is a big chance that your UNIX variant has a ready-to-install package for the Go programming language, so you might want to get Go by using your favorite package manager.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.51.1">As Go is a portable programming language, almost all presented code is going to work fine on any modern </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.52.1">Microsoft Windows, Linux, or macOS machine without any changes. </span><span class="koboSpan" id="kobo.52.2">The only Go code that might need some small or big adjustments is the code that deals with the operating system. </span><span class="koboSpan" id="kobo.52.3">Most of that code is covered in </span><em class="chapterRef"><span class="koboSpan" id="kobo.53.1">Chapter 7</span></em><span class="koboSpan" id="kobo.54.1">, </span><em class="italic"><span class="koboSpan" id="kobo.55.1">Telling a UNIX System What to Do</span></em><span class="koboSpan" id="kobo.56.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-17"><span class="koboSpan" id="kobo.57.1">The advantages of Go</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.58.1">Go comes with</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.59.1"> some important advantages for developers, starting with the fact that it was designed and is currently maintained by real programmers. </span><span class="koboSpan" id="kobo.59.2">Go is also easy to learn, especially if you are already familiar with programming languages such as C, Python, or Java. </span><span class="koboSpan" id="kobo.59.3">On top of that, due to its simplified and elegant syntax, Go code is pleasant to the eye, which is great, especially when you are programming applications for a living and you have to look at code on a daily basis. </span><span class="koboSpan" id="kobo.59.4">Go code is also easy to read, which means that you can make changes to existing Go code easily, and offers support for Unicode out of the box. </span><span class="koboSpan" id="kobo.59.5">Lastly, Go has reserved only 25 keywords, which makes it much easier to remember the language. </span><span class="koboSpan" id="kobo.59.6">Can you do that with C++?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.60.1">Go also comes with concurrency capabilities, using a simple concurrency model that is implemented using </span><em class="italic"><span class="koboSpan" id="kobo.61.1">goroutines</span></em><span class="koboSpan" id="kobo.62.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.63.1">channels</span></em><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">Go manages OS threads for you and has a powerful runtime that allows you to spawn lightweight units of work (goroutines) that communicate with each other using channels.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.65.1">Although Go comes with a rich standard library, there are really handy Go packages, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.66.1">cobra</span></code><span class="koboSpan" id="kobo.67.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.68.1">viper</span></code><span class="koboSpan" id="kobo.69.1">, that allow Go to develop complex command line utilities such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">docker</span></code><span class="koboSpan" id="kobo.71.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">hugo</span></code><span class="koboSpan" id="kobo.73.1">. </span><span class="koboSpan" id="kobo.73.2">This is greatly supported by the fact that executable binaries are statically linked, which means that once they are generated, they do not depend on any shared libraries and include all required information. </span><span class="koboSpan" id="kobo.73.3">In practice, this means that you can transfer an existing executable file to a different machine with the same architecture and be sure that it is going to run without any issues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.74.1">Due to its simplicity, Go code is predictable and does not have strange side effects, and although Go supports pointers, it does not support pointer arithmetic like C, unless you use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.75.1">unsafe</span></code><span class="koboSpan" id="kobo.76.1"> package, which can be the root of many bugs and security holes. </span><span class="koboSpan" id="kobo.76.2">Although Go is not an object-oriented programming language, Go interfaces are very versatile and allow you to mimic some of the capabilities of object-oriented languages, such as polymorphism, encapsulation, and composition. </span><span class="koboSpan" id="kobo.76.3">However, Go offers no support for classes and inheritance. </span><em class="chapterRef"><span class="koboSpan" id="kobo.77.1">Chapter 5</span></em><span class="koboSpan" id="kobo.78.1">, </span><em class="italic"><span class="koboSpan" id="kobo.79.1">Reflection and Interfaces</span></em><span class="koboSpan" id="kobo.80.1">, provides more information on the subject.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.81.1">Additionally, the latest Go versions offer support for </span><em class="italic"><span class="koboSpan" id="kobo.82.1">generics</span></em><span class="koboSpan" id="kobo.83.1">, which simplifies your code when working</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.84.1"> with multiple data types. </span><span class="koboSpan" id="kobo.84.2">You can learn more about Go generics in </span><em class="chapterRef"><span class="koboSpan" id="kobo.85.1">Chapter 4</span></em><span class="koboSpan" id="kobo.86.1">, </span><em class="italic"><span class="koboSpan" id="kobo.87.1">Go Generics</span></em><span class="koboSpan" id="kobo.88.1">. </span><span class="koboSpan" id="kobo.88.2">Finally, Go is a garbage-collected language, which means that no manual memory management is needed.</span></p>
<h1 class="heading-1" id="_idParaDest-18"><span class="koboSpan" id="kobo.89.1">When to use Go</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.90.1">Although Go is a</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.91.1"> general-purpose programming language, it is primarily used for writing system tools, command line utilities, web services, and software that works over networks and the internet. </span><span class="koboSpan" id="kobo.91.2">You can use Go for teaching programming, and it is a good candidate as your first programming language because of its lack of verbosity and clear ideas and principles.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.92.1">Go can help you develop the following kinds of applications:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.93.1">Professional web services</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.94.1">Networking tools and servers such as Kubernetes and Istio</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.95.1">Backend systems</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.96.1">Robust UNIX and Windows system tools</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.97.1">Servers that work with APIs and clients that interact by exchanging data in myriad formats, including JSON, XML, and CSV</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.98.1">WebSocket servers and clients</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.99.1">gRPC (Remote Procedure Call) servers and clients</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.100.1">Complex command line utilities with multiple commands, sub-commands, and command line parameters, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.101.1">docker</span></code><span class="koboSpan" id="kobo.102.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">hugo</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.104.1">Applications that exchange data in the JSON format</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.105.1">Applications that process data from relational databases, NoSQL databases, or other popular data storage systems</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.106.1">Compilers and interpreters for your own programming languages</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.107.1">Database systems such as CockroachDB and key/value stores such as etcd</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.108.1">Although Go is a very </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.109.1">practical and competent programming language, it is not perfect:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.110.1">This is a personal preference rather than an actual technical shortcoming: Go has no direct and full support for object-oriented programming, which is a popular programming paradigm.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.111.1">Although goroutines are lightweight, they are not as powerful as OS threads. </span><span class="koboSpan" id="kobo.111.2">Depending on the application you are trying to implement, there might exist some rare cases where goroutines will not be appropriate for the job. </span><span class="koboSpan" id="kobo.111.3">The Apache web server creates UNIX processes with </span><code class="inlineCode"><span class="koboSpan" id="kobo.112.1">fork(2)</span></code><span class="koboSpan" id="kobo.113.1"> to serve its clientsâ€”Go does not support the functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.114.1">fork(2)</span></code><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">However, in most cases, designing your application with goroutines and channels in mind will solve your problems.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.116.1">Although garbage collection is fast enough most of the time, and for almost all kinds of applications, there are times when you need to handle memory allocation manually, such as when developing an operating system or working with large chunks of memory and want to avoid fragmentationâ€”Go cannot do that. </span><span class="koboSpan" id="kobo.116.2">In practice, this means that Go will not allow you to perform any memory management manually.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.117.1">Go does not offer the full functionality of a functional programming language.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.118.1">Go is not good at developing systems with high availability guarantees. </span><span class="koboSpan" id="kobo.118.2">In such cases, use Erlang or Elixir instead.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.119.1">There are many things that Go does better than other programming languages, including the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.120.1">The Go compiler catches a large set of silly errors that might end up being bugs. </span><span class="koboSpan" id="kobo.120.2">This includes imported Go packages and variables that are not being used in the code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.121.1">Go uses fewer parentheses than C, C++, or Java, and no semicolons, which makes Go source code more human-readable and less error-prone.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.122.1">Go comes with a rich and reliable standard library that keeps improving.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.123.1">Go has support for concurrency out of the box through goroutines and channels.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.124.1">Goroutines are lightweight. </span><span class="koboSpan" id="kobo.124.2">You can easily run thousands of goroutines on any modern machine without any performance issues.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.125.1">Unlike C, Go considers functions as first-class citizens.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.126.1">Go code is backward compatible, which means that newer versions of the Go compiler accept programs that were created using a previous version of the language without any modifications. </span><span class="koboSpan" id="kobo.126.2">This compatibility guarantee is limited to major versions of Go. </span><span class="koboSpan" id="kobo.126.3">For example, there is no guarantee that a Go 1.x program will compile with Go 2.x.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.127.1">The next </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.128.1">subsection describes my personal Go journey.</span></p>
<h2 class="heading-2" id="_idParaDest-19"><span class="koboSpan" id="kobo.129.1">My personal Go journey</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.130.1">In this subsection, I am going to tell you my personal story of how I ended up learning and using Go. </span><span class="koboSpan" id="kobo.130.2">I am a UNIX person, which means that I like UNIX and prefer to use it whenever possible. </span><span class="koboSpan" id="kobo.130.3">I also love C, and I used to like C++; I wrote a command line FTP client in C++ for my M.Sc. </span><span class="koboSpan" id="kobo.130.4">project. </span><span class="koboSpan" id="kobo.130.5">Nowadays, C++ is just a huge programming language that is difficult to learn. </span><span class="koboSpan" id="kobo.130.6">Although C continues to be a decent programming language, it requires lots of code to perform simple tasks and suffers from difficult-to-find and correct bugs, due to manual memory management and extremely flexible conversion between different data types without any warnings or error messages. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.131.1">As a result, I used to use Perl to write simple command line utilities. </span><span class="koboSpan" id="kobo.131.2">However, Perl is far from perfect for writing serious command line tools and services, as it is a scripting programming language and is not intended for web development.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.132.1">When I first heard about Go, that it was developed by Google, and that both Rob Pike and Ken Thomson were involved in its development, I instantly became interested in Go.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.133.1">Since then, I have used Go to create web services, servers, and clients that communicate with RabbitMQ, MySQL, and PostgreSQL, create simple command line utilities, implement algorithms for time series data mining, create utilities that generate synthetic data, etc.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.134.1">Soon, we are going to move on to actually learn some Go, using </span><em class="italic"><span class="koboSpan" id="kobo.135.1">Hello World!</span></em><span class="koboSpan" id="kobo.136.1"> as the first example, but before that, we will present the </span><code class="inlineCode"><span class="koboSpan" id="kobo.137.1">go doc</span></code><span class="koboSpan" id="kobo.138.1"> command, which allows you to find information about the Go standard library, its packages, and their functions, as well as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.139.1">godoc</span></code><span class="koboSpan" id="kobo.140.1"> utility.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.141.1">If you have not already installed Go, this is the right time to do so. </span><span class="koboSpan" id="kobo.141.2">To do that, visit </span><a href="https://go.dev/dl/"><span class="url"><span class="koboSpan" id="kobo.142.1">https://go.dev/dl/</span></span></a><span class="koboSpan" id="kobo.143.1"> or use your favorite package manager.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-20"><span class="koboSpan" id="kobo.144.1">The go doc and godoc utilities</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.145.1">The Go distribution </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.146.1">comes with a plethora of tools that can make your life as a programmer easier. </span><span class="koboSpan" id="kobo.146.2">Two of these tools are the </span><code class="inlineCode"><span class="koboSpan" id="kobo.147.1">go doc</span></code><span class="koboSpan" id="kobo.148.1"> subcommand and </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">godoc</span></code><span class="koboSpan" id="kobo.150.1"> utility, which allow you to see the documentation of existing Go functions and packages without needing an internet connection. </span><span class="koboSpan" id="kobo.150.2">However, if you prefer viewing the Go documentation online, you can visit </span><a href="https://pkg.go.dev/"><span class="url"><span class="koboSpan" id="kobo.151.1">https://pkg.go.dev/</span></span></a><span class="koboSpan" id="kobo.152.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.153.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">go doc</span></code><span class="koboSpan" id="kobo.155.1"> command can </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.156.1">be executed as a normal command line application that displays its output on a terminal, and it is similar to the UNIX </span><code class="inlineCode"><span class="koboSpan" id="kobo.157.1">man(1)</span></code><span class="koboSpan" id="kobo.158.1"> command, but for Go functions and packages only. </span><span class="koboSpan" id="kobo.158.2">So, in order to find out information about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.159.1">Printf()</span></code><span class="koboSpan" id="kobo.160.1"> function of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">fmt</span></code><span class="koboSpan" id="kobo.162.1"> package, you should execute the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.163.1">$ </span></span><span class="koboSpan" id="kobo.164.1">go doc fmt.Printf
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.165.1">Similarly, you can find out information about the entire </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">fmt</span></code><span class="koboSpan" id="kobo.167.1"> package by running the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.168.1">$ </span></span><span class="koboSpan" id="kobo.169.1">go doc </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.170.1">fmt</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.171.1">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">godoc</span></code><span class="koboSpan" id="kobo.173.1"> is not installed by default, you might need to install it by running </span><code class="inlineCode"><span class="koboSpan" id="kobo.174.1">go install golang.org/x/tools/cmd/godoc@latest</span></code><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.176.1">godoc</span></code><span class="koboSpan" id="kobo.177.1"> binary is going to be installed in </span><code class="inlineCode"><span class="koboSpan" id="kobo.178.1">~/go/bin</span></code><span class="koboSpan" id="kobo.179.1">, and you can execute it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.180.1">~/go/bin/godoc</span></code><span class="koboSpan" id="kobo.181.1"> unless </span><code class="inlineCode"><span class="koboSpan" id="kobo.182.1">~/go/bin</span></code><span class="koboSpan" id="kobo.183.1"> is in your </span><code class="inlineCode"><span class="koboSpan" id="kobo.184.1">PATH</span></code><span class="koboSpan" id="kobo.185.1"> environment variable. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.186.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">godoc</span></code><span class="koboSpan" id="kobo.188.1"> command line application starts a local web server. </span><span class="koboSpan" id="kobo.188.2">So you need a web browser to look at the Go documentation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.189.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">godoc</span></code><span class="koboSpan" id="kobo.191.1"> requires executing </span><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">godoc</span></code><span class="koboSpan" id="kobo.193.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">-http</span></code><span class="koboSpan" id="kobo.195.1"> parameter:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.196.1">$ </span></span><span class="koboSpan" id="kobo.197.1">~/go/bin/godoc -http=:8001
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.198.1">The numeric value in the preceding command, which in this case is </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">8001</span></code><span class="koboSpan" id="kobo.200.1">, is the port number that the HTTP server will listen to. </span><span class="koboSpan" id="kobo.200.2">As we have omitted the IP address, </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">godoc</span></code><span class="koboSpan" id="kobo.202.1"> is going to listen to all network interfaces.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.203.1">You can choose any port number that is available if you have the right privileges. </span><span class="koboSpan" id="kobo.203.2">However, note that port numbers </span><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">0</span></code><span class="koboSpan" id="kobo.205.1">â€“</span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">1023</span></code><span class="koboSpan" id="kobo.207.1"> are restricted and can only be used by the root user, so it is better to avoid choosing one of those and pick something else, if it is not already in use by a different process. </span><span class="koboSpan" id="kobo.207.2">Port number </span><code class="inlineCode"><span class="koboSpan" id="kobo.208.1">8001</span></code><span class="koboSpan" id="kobo.209.1"> is usually free and is frequently used for local HTTP servers.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.210.1">You can omit the equals sign in the presented command and put a space character in its place. </span><span class="koboSpan" id="kobo.210.2">So the following command is completely equivalent to the previous one: </span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.211.1">$ </span></span><span class="koboSpan" id="kobo.212.1">~/go/bin/godoc -http :8001
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.213.1">After that, you</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.214.1"> should point your web browser to </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">http://localhost:8001/</span></code><span class="koboSpan" id="kobo.216.1"> in order to get the list of available Go packages and browse their documentation. </span><span class="koboSpan" id="kobo.216.2">If no </span><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">-http</span></code><span class="koboSpan" id="kobo.218.1"> parameter is provided, </span><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">godoc</span></code><span class="koboSpan" id="kobo.220.1"> listens to port </span><code class="inlineCode"><span class="koboSpan" id="kobo.221.1">6060</span></code><span class="koboSpan" id="kobo.222.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.223.1">If you are using Go for the first time, you will find the Go documentation very handy for learning the parameters and the return values of the functions you want to use â€” as you progress in your Go journey, you will use the Go documentation to learn the gory details of the functions and variables that you want to use.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.224.1">The next section presents the first Go program of the book and explains the basic concepts of Go.</span></p>
<h1 class="heading-1" id="_idParaDest-21"><span class="koboSpan" id="kobo.225.1">Hello World!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.226.1">The following is</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.227.1"> the Go version of the </span><em class="italic"><span class="koboSpan" id="kobo.228.1">Hello World!</span></em><span class="koboSpan" id="kobo.229.1"> program. </span><span class="koboSpan" id="kobo.229.2">Please type it and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.230.1">hw.go</span></code><span class="koboSpan" id="kobo.231.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.232.1">package</span></span><span class="koboSpan" id="kobo.233.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.234.1">import</span></span><span class="koboSpan" id="kobo.235.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.236.1">"fmt"</span></span><span class="koboSpan" id="kobo.237.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.238.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.239.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.240.1">()</span></span><span class="koboSpan" id="kobo.241.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.242.1">"Hello World!"</span></span><span class="koboSpan" id="kobo.243.1">)
}
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.244.1">If you are eager to execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">hw.go</span></code><span class="koboSpan" id="kobo.246.1">, type </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">go run hw.go</span></code><span class="koboSpan" id="kobo.248.1"> in the same directory where you save it. </span><span class="koboSpan" id="kobo.248.2">The file can also be found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">ch01</span></code><span class="koboSpan" id="kobo.250.1"> directory of the GitHub repository of the book.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.251.1">Each Go source code begins with a package declaration. </span><span class="koboSpan" id="kobo.251.2">In this case, the name of the package is </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">main</span></code><span class="koboSpan" id="kobo.253.1">, which has a special meaning in Goâ€”autonomous Go programs should use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.254.1">main</span></code><span class="koboSpan" id="kobo.255.1"> package. </span><span class="koboSpan" id="kobo.255.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.256.1">import</span></code><span class="koboSpan" id="kobo.257.1"> keyword allows you to include functionality from existing packages. </span><span class="koboSpan" id="kobo.257.2">In our case, we only need some of the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">fmt</span></code><span class="koboSpan" id="kobo.259.1"> package that belongs to the standard Go library, implementing formatted input and output with functions that are analogous to Câ€™s </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">printf()</span></code><span class="koboSpan" id="kobo.261.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">scanf()</span></code><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">The next important thing if you are creating an executable application is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">main()</span></code><span class="koboSpan" id="kobo.265.1"> function. </span><span class="koboSpan" id="kobo.265.2">Go considers this the entry point to the application, and it begins the execution of an application with the code found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.266.1">main()</span></code><span class="koboSpan" id="kobo.267.1"> function of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.268.1">main</span></code><span class="koboSpan" id="kobo.269.1"> package.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">hw.go</span></code><span class="koboSpan" id="kobo.271.1"> is a Go program that runs on its own. </span><span class="koboSpan" id="kobo.271.2">Two characteristics make </span><code class="inlineCode"><span class="koboSpan" id="kobo.272.1">hw.go</span></code><span class="koboSpan" id="kobo.273.1"> a source file that can generate an executable binary: the name of the package, which should be </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">main</span></code><span class="koboSpan" id="kobo.275.1">, and the presence of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.276.1">main()</span></code><span class="koboSpan" id="kobo.277.1"> functionâ€”we discuss Go functions in more detail in the next subsection, but we will learn even more about functions and methods, which are functions attached to specific data types, in </span><em class="chapterRef"><span class="koboSpan" id="kobo.278.1">Chapter 6</span></em><span class="koboSpan" id="kobo.279.1">, </span><em class="italic"><span class="koboSpan" id="kobo.280.1">Go Packages and Functions</span></em><span class="koboSpan" id="kobo.281.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-22"><span class="koboSpan" id="kobo.282.1">Introducing functions</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.283.1">Each Go function </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.284.1">definition begins with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">func</span></code><span class="koboSpan" id="kobo.286.1"> keyword, followed by its name, signature, and implementation. </span><span class="koboSpan" id="kobo.286.2">Apart from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">main()</span></code><span class="koboSpan" id="kobo.288.1"> function, which has a special purpose, you can name the rest of your functions anything you wantâ€”there is a global Go rule that also applies to function and variable names and is valid for all packages except main: </span><em class="italic"><span class="koboSpan" id="kobo.289.1">everything that begins with a lowercase letter is considered private and is accessible in the current package only</span></em><span class="koboSpan" id="kobo.290.1">. </span><span class="koboSpan" id="kobo.290.2">We will learn more about that rule in </span><em class="chapterRef"><span class="koboSpan" id="kobo.291.1">Chapter 6</span></em><span class="koboSpan" id="kobo.292.1">, </span><em class="italic"><span class="koboSpan" id="kobo.293.1">Go Packages and Functions</span></em><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">The only exception to this rule is package names, which can begin with either lowercase or uppercase letters. </span><span class="koboSpan" id="kobo.294.3">Having said that, I am not aware of a Go package that begins with an uppercase letter!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">You might now ask</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.296.1"> how functions are organized and delivered. </span><span class="koboSpan" id="kobo.296.2">Well, the answer is in packagesâ€”the next subsection sheds some light on that.</span></p>
<h2 class="heading-2" id="_idParaDest-23"><span class="koboSpan" id="kobo.297.1">Introducing packages</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.298.1">Go programs are </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.299.1">organized in packagesâ€”even the smallest Go program should be delivered as a package. </span><span class="koboSpan" id="kobo.299.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">package</span></code><span class="koboSpan" id="kobo.301.1"> keyword helps you define the name of a new package, which can be anything you want, with just one exception: if you are creating an executable application and not just a package that will be shared by other applications or packages, you should name your package </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">main</span></code><span class="koboSpan" id="kobo.303.1">. </span><span class="koboSpan" id="kobo.303.2">You will learn more about developing Go packages in </span><em class="chapterRef"><span class="koboSpan" id="kobo.304.1">Chapter 6</span></em><span class="koboSpan" id="kobo.305.1">, </span><em class="italic"><span class="koboSpan" id="kobo.306.1">Go Packages and Functions</span></em><span class="koboSpan" id="kobo.307.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.308.1">Packages can be used by other packages. </span><span class="koboSpan" id="kobo.308.2">In fact, reusing existing packages is a good practice that saves you from having to write lots of code or implement existing functionality from scratch.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.309.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">import</span></code><span class="koboSpan" id="kobo.311.1"> keyword is used for importing other Go packages into your Go programs to use some or all of their functionality. </span><span class="koboSpan" id="kobo.311.2">A Go package can either be a part of the rich Standard Go library or come from an external source. </span><span class="koboSpan" id="kobo.311.3">Packages of the standard Go library are imported by name, for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">import</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.313.1">"os"</span></code><span class="koboSpan" id="kobo.314.1"> to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">os</span></code><span class="koboSpan" id="kobo.316.1"> package, whereas external packages like </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">github.com/spf13/cobra</span></code><span class="koboSpan" id="kobo.318.1"> are imported using their full URLs: </span><code class="inlineCode"><span class="koboSpan" id="kobo.319.1">import "github.com/spf13/cobra"</span></code><span class="koboSpan" id="kobo.320.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-24"><span class="koboSpan" id="kobo.321.1">Running Go code</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.322.1">You now need to </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.323.1">know how to execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">hw.go</span></code><span class="koboSpan" id="kobo.325.1"> or any other Go application. </span><span class="koboSpan" id="kobo.325.2">As will be explained in the two subsections that follow, there are two ways to execute Go code: as a compiled language, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">go build</span></code><span class="koboSpan" id="kobo.327.1">, or by mimicking a scripting language, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.328.1">go run</span></code><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">So let us find out more about these two ways of running Go code.</span></p>
<h2 class="heading-2" id="_idParaDest-25"><span class="koboSpan" id="kobo.330.1">Compiling Go code</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.331.1">To compile Go </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.332.1">code and create a binary executable file, we need to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">go build</span></code><span class="koboSpan" id="kobo.334.1"> command. </span><span class="koboSpan" id="kobo.334.2">What </span><code class="inlineCode"><span class="koboSpan" id="kobo.335.1">go build</span></code><span class="koboSpan" id="kobo.336.1"> does is create an executable file for us to distribute and execute manually. </span><span class="koboSpan" id="kobo.336.2">This means that when using </span><code class="inlineCode"><span class="koboSpan" id="kobo.337.1">go build</span></code><span class="koboSpan" id="kobo.338.1">, an extra step is required to run the executable file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.339.1">The generated executable is automatically named after the source code filename without the </span><code class="inlineCode"><span class="koboSpan" id="kobo.340.1">.go</span></code><span class="koboSpan" id="kobo.341.1"> file extension. </span><span class="koboSpan" id="kobo.341.2">Therefore, because of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">hw.go</span></code><span class="koboSpan" id="kobo.343.1"> source filename, the executable will be called </span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">hw</span></code><span class="koboSpan" id="kobo.345.1">. </span><span class="koboSpan" id="kobo.345.2">If this is not what you want, </span><code class="inlineCode"><span class="koboSpan" id="kobo.346.1">go build</span></code><span class="koboSpan" id="kobo.347.1"> supports the </span><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">-o</span></code><span class="koboSpan" id="kobo.349.1"> option, which allows you to change the filename and the path of the generated executable file. </span><span class="koboSpan" id="kobo.349.2">As an example, if you want to name the executable file a </span><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">helloWorld</span></code><span class="koboSpan" id="kobo.351.1">, you should execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">go build -o helloWorld hw.go</span></code><span class="koboSpan" id="kobo.353.1"> instead. </span><span class="koboSpan" id="kobo.353.2">If no source files are provided, </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">go build</span></code><span class="koboSpan" id="kobo.355.1"> looks for a </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">main</span></code><span class="koboSpan" id="kobo.357.1"> package in the current directory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.358.1">After that, you need to execute the generated executable binary file on your own. </span><span class="koboSpan" id="kobo.358.2">In our case, this means executing either </span><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">hw</span></code><span class="koboSpan" id="kobo.360.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">helloWorld</span></code><span class="koboSpan" id="kobo.362.1">. </span><span class="koboSpan" id="kobo.362.2">This is shown in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.363.1">$ </span></span><span class="koboSpan" id="kobo.364.1">go build hw.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.365.1">$ </span></span><span class="koboSpan" id="kobo.366.1">./hw
Hello World!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.367.1">Now that we know how to compile Go code, let us continue using Go as if it were a scripting language.</span></p>
<h2 class="heading-2" id="_idParaDest-26"><span class="koboSpan" id="kobo.368.1">Using Go like a scripting language</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.369.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">go run</span></code><span class="koboSpan" id="kobo.371.1"> command</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.372.1"> builds the named Go package, which in</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.373.1"> this case is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.374.1">main</span></code><span class="koboSpan" id="kobo.375.1"> package implemented in a single file, creates a temporary executable file, executes that file, and deletes it once it is doneâ€”to our eyes, this looks like using a scripting language while the Go compiler still creates a binary executable. </span><span class="koboSpan" id="kobo.375.2">In our case, we can do the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.376.1">$ </span></span><span class="koboSpan" id="kobo.377.1">go run hw.go
Hello World!
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.378.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.379.1">go run</span></code><span class="koboSpan" id="kobo.380.1"> is a better choice when testing code. </span><span class="koboSpan" id="kobo.380.2">However, if you want to create and distribute an executable binary, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.381.1">go build</span></code><span class="koboSpan" id="kobo.382.1"> is the way to go.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-27"><span class="koboSpan" id="kobo.383.1">Important formatting and coding rules</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.384.1">You should know </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.385.1">that Go comes with some strict formatting and coding rules that help a developer avoid rookie mistakes and bugsâ€”once you learn these few rules and Go idiosyncrasies as well as the implications they have on your code, you will be free to concentrate on the actual functionality of your code. </span><span class="koboSpan" id="kobo.385.2">Additionally, the Go compiler is here to help you follow these rules with its expressive error messages and warnings. </span><span class="koboSpan" id="kobo.385.3">Last, Go offers standard tooling (</span><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">gofmt</span></code><span class="koboSpan" id="kobo.387.1">) that can format your code for you, so you never have to think about it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.388.1">The following is a list of important Go rules that will help you while reading this chapter:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.389.1">Go code is delivered in packages, and you are free to use the functionality found in existing packages. </span><span class="koboSpan" id="kobo.389.2">There is a Go rule that says that if you import a package, you should use it in some way (call a function or use a datatype), or the compiler is going to complain. </span><span class="koboSpan" id="kobo.389.3">There exist exceptions to this rule that mainly have to do with packages that initialize connections with database and TCP/IP servers, but they are not important for now. </span><span class="koboSpan" id="kobo.389.4">Packages are covered in </span><em class="chapterRef"><span class="koboSpan" id="kobo.390.1">Chapter 6</span></em><span class="koboSpan" id="kobo.391.1">, </span><em class="italic"><span class="koboSpan" id="kobo.392.1">Go Packages and Functions</span></em><span class="koboSpan" id="kobo.393.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.394.1">You either use a variable or you do not declare it at all. </span><span class="koboSpan" id="kobo.394.2">This rule helps you avoid errors such as misspelling an existing variable or function name.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.395.1">There is only one way to format curly braces in Go.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.396.1">Coding blocks in Go are embedded in curly braces, even if they contain just a single statement or no statements at all.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.397.1">Go functions can return multiple values.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.398.1">You cannot automatically convert between different data types, even if they are of the same kind. </span><span class="koboSpan" id="kobo.398.2">As an example, you cannot implicitly convert an integer to a floating point.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.399.1">Go has more rules, but the preceding ones are the most important and will keep you going for most of the book. </span><span class="koboSpan" id="kobo.399.2">You are going to see all these rules in action in this chapter as well as in other chapters. </span><span class="koboSpan" id="kobo.399.3">For now, letâ€™s consider the only way to format curly braces in Go because this rule applies everywhere.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.400.1">Look at the following Go program named </span><code class="inlineCode"><span class="koboSpan" id="kobo.401.1">curly.go</span></code><span class="koboSpan" id="kobo.402.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.403.1">package</span></span><span class="koboSpan" id="kobo.404.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.405.1">import</span></span><span class="koboSpan" id="kobo.406.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.407.1">"fmt"</span></span><span class="koboSpan" id="kobo.408.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.409.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.410.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.411.1">()</span></span><span class="koboSpan" id="kobo.412.1"> 
{
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.413.1">"Go has strict rules for curly braces!"</span></span><span class="koboSpan" id="kobo.414.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.415.1">Although it looks just fine, if you try to execute it, you will be disappointed because the code will not compile and, therefore, you will get the following syntax error message:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.416.1">$ </span></span><span class="koboSpan" id="kobo.417.1">go run curly.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.418.1"># </span></span><span class="koboSpan" id="kobo.419.1">command-line-arguments
./curly.go:7:6: missing function body
./curly.go:8:1: syntax error: unexpected semicolon or newline before {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.420.1">The official explanation for this error message is that Go requires the use of semicolons as statement terminators in many contexts, and the compiler implicitly inserts the required semicolons when it thinks that they are necessary. </span><span class="koboSpan" id="kobo.420.2">Therefore, putting the opening curly brace (</span><code class="inlineCode"><span class="koboSpan" id="kobo.421.1">{</span></code><span class="koboSpan" id="kobo.422.1">) in its own line will make the Go compiler insert a semicolon at the end of the previous line (</span><code class="inlineCode"><span class="koboSpan" id="kobo.423.1">func main()</span></code><span class="koboSpan" id="kobo.424.1">), which is the main cause of the error message. </span><span class="koboSpan" id="kobo.424.2">The correct way to write the previous code is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.425.1">package</span></span><span class="koboSpan" id="kobo.426.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.427.1">import</span></span><span class="koboSpan" id="kobo.428.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.429.1">"fmt"</span></span><span class="koboSpan" id="kobo.430.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.431.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.432.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.433.1">()</span></span><span class="koboSpan" id="kobo.434.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.435.1">"Go has strict rules for curly braces!"</span></span><span class="koboSpan" id="kobo.436.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.437.1">After learning</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.438.1"> about this global rule, let us continue by presenting some important characteristics of Go.</span></p>
<h1 class="heading-1" id="_idParaDest-28"><span class="koboSpan" id="kobo.439.1">What you should know about Go</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.440.1">This big section</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.441.1"> discusses important and essential Go features including variables, controlling program flow, iterations, getting user input, and Go concurrency. </span><span class="koboSpan" id="kobo.441.2">We begin by discussing variables, variable declaration, and variable usage.</span></p>
<h2 class="heading-2" id="_idParaDest-29"><span class="koboSpan" id="kobo.442.1">Defining and using variables</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.443.1">Imagine that you </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.444.1">want to perform basic mathematical calculations. </span><span class="koboSpan" id="kobo.444.2">In that case, you need to define variables to keep the input, intermediate computations, and results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.445.1">Go provides multiple ways to declare new variables to make the variable declaration process more natural and convenient. </span><span class="koboSpan" id="kobo.445.2">You can declare a new variable using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.446.1">var</span></code><span class="koboSpan" id="kobo.447.1"> keyword, followed by the variable name, followed by the desired data type (we are going to cover data types in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.448.1">Chapter 2</span></em><span class="koboSpan" id="kobo.449.1">, </span><em class="italic"><span class="koboSpan" id="kobo.450.1">Basic Go Data Types</span></em><span class="koboSpan" id="kobo.451.1">). </span><span class="koboSpan" id="kobo.451.2">If you want, you can follow that declaration with </span><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">=</span></code><span class="koboSpan" id="kobo.453.1"> and an initial value for your variable. </span><span class="koboSpan" id="kobo.453.2">If there is an initial value given, you can omit the data type and the compiler will infer it for you.</span></p>
<p class="normal"><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.454.1">This brings us to a very important Go rule: if no initial value is given to a variable, the Go compiler will automatically initialize that variable to the zero value of its data type.</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.455.1">There is also the </span><code class="inlineCode"><span class="koboSpan" id="kobo.456.1">:=</span></code><span class="koboSpan" id="kobo.457.1"> notation, which can be used instead of a var declaration. </span><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">:=</span></code><span class="koboSpan" id="kobo.459.1"> defines a new variable by inferring the data of the value that follows it. </span><span class="koboSpan" id="kobo.459.2">The official name for </span><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">:=</span></code><span class="koboSpan" id="kobo.461.1"> is </span><em class="italic"><span class="koboSpan" id="kobo.462.1">short assignment statement</span></em><span class="koboSpan" id="kobo.463.1">, and it is very frequently used in Go, especially for getting the return values from functions and </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">for</span></code><span class="koboSpan" id="kobo.465.1"> loops with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">range</span></code><span class="koboSpan" id="kobo.467.1"> keyword.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.468.1">The short assignment statement can be used in place of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">var</span></code><span class="koboSpan" id="kobo.470.1"> declaration with an implicit type. </span><span class="koboSpan" id="kobo.470.2">You rarely see the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">var</span></code><span class="koboSpan" id="kobo.472.1"> in Go; the </span><code class="inlineCode"><span class="koboSpan" id="kobo.473.1">var</span></code><span class="koboSpan" id="kobo.474.1"> keyword is mostly used for declaring global or local variables without an initial value. </span><span class="koboSpan" id="kobo.474.2">The reason for the former is that every statement that exists outside of the code of a function must begin with a keyword, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.475.1">func</span></code><span class="koboSpan" id="kobo.476.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">var</span></code><span class="koboSpan" id="kobo.478.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.479.1">This means that the short assignment statement cannot be used outside of a function environment because it is not permitted there. </span><span class="koboSpan" id="kobo.479.2">Last, you might need to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.480.1">var</span></code><span class="koboSpan" id="kobo.481.1"> when you want to be explicit about the data type. </span><span class="koboSpan" id="kobo.481.2">For example, when you want the type of a variable to be </span><code class="inlineCode"><span class="koboSpan" id="kobo.482.1">int8</span></code><span class="koboSpan" id="kobo.483.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.484.1">int32</span></code><span class="koboSpan" id="kobo.485.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.486.1">int</span></code><span class="koboSpan" id="kobo.487.1">, which is the default.</span></p>
<h2 class="heading-2" id="_idParaDest-30"><span class="koboSpan" id="kobo.488.1">Constants</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.489.1">There are values, such as the </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.490.1">mathematical constant Pi, that cannot change. </span><span class="koboSpan" id="kobo.490.2">In that case, we can declare such values as constants using </span><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">const</span></code><span class="koboSpan" id="kobo.492.1">. </span><span class="koboSpan" id="kobo.492.2">Constants are declared just like variables but cannot change once they have been declared.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.493.1">The supported data types for constants are character, string, Boolean, and all numeric data types. </span><span class="koboSpan" id="kobo.493.2">Thereâ€™s more about Go data types in </span><em class="chapterRef"><span class="koboSpan" id="kobo.494.1">Chapter 2</span></em><span class="koboSpan" id="kobo.495.1">, </span><em class="italic"><span class="koboSpan" id="kobo.496.1">Basic Go Data Types</span></em><span class="koboSpan" id="kobo.497.1">.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-31"><span class="koboSpan" id="kobo.498.1">Global variables</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.499.1">Global variables are</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.500.1"> variables that are defined outside of a function implementation. </span><em class="italic"><span class="koboSpan" id="kobo.501.1">Global variables</span></em><span class="koboSpan" id="kobo.502.1"> can be accessed from anywhere in a package without the need to explicitly pass them to a function, and they can be changed unless they were defined as constants, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.503.1">const</span></code><span class="koboSpan" id="kobo.504.1"> keyword.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.505.1">Although you can declare local variables using either </span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">var</span></code><span class="koboSpan" id="kobo.507.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">:=</span></code><span class="koboSpan" id="kobo.509.1">, only </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">const</span></code><span class="koboSpan" id="kobo.511.1"> (when the value of a variable is not going to change) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.512.1">var</span></code><span class="koboSpan" id="kobo.513.1"> work for global variables.</span></p>
<h2 class="heading-2" id="_idParaDest-32"><span class="koboSpan" id="kobo.514.1">Printing variables</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.515.1">Programs tend to </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.516.1">display information, which means that they need to print data or send it somewhere for other software to store or process it. </span><span class="koboSpan" id="kobo.516.2">To print data on the screen, Go uses the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">fmt</span></code><span class="koboSpan" id="kobo.518.1"> package. </span><span class="koboSpan" id="kobo.518.2">If you want Go to take care of the printing, then you might want to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.520.1"> function. </span><span class="koboSpan" id="kobo.520.2">However, there are times when you want to have full control over how data is going to be printed. </span><span class="koboSpan" id="kobo.520.3">In such cases, you might want to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.522.1">.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.524.1"> is similar to the C </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">printf()</span></code><span class="koboSpan" id="kobo.526.1"> function and requires the use of control sequences that specify the data type of the variable that is going to be printed. </span><span class="koboSpan" id="kobo.526.2">Additionally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.528.1"> function allows you to format the generated output, which is particularly convenient for floating point values because it allows you to specify the digits that will be displayed in the output (</span><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">%.2f</span></code><span class="koboSpan" id="kobo.530.1"> displays two digits after the decimal point of a floating point value). </span><span class="koboSpan" id="kobo.530.2">Lastly, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">\n</span></code><span class="koboSpan" id="kobo.532.1"> character is used for printing a newline character and, therefore, creating a new line, as </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.534.1"> does not automatically insert a newlineâ€”this is not the case with </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.536.1">, which automatically inserts a newline, hence the </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">ln</span></code><span class="koboSpan" id="kobo.538.1"> at the end of its name.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.539.1">The following program illustrates how you can declare new variables, how to use them, and how to print themâ€”type the following code into a plain text file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.540.1">variables.go</span></code><span class="koboSpan" id="kobo.541.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.542.1">package</span></span><span class="koboSpan" id="kobo.543.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.544.1">import</span></span><span class="koboSpan" id="kobo.545.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.546.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.547.1">"math"</span></span><span class="koboSpan" id="kobo.548.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.549.1">var</span></span><span class="koboSpan" id="kobo.550.1"> Global </span><span class="hljs-type"><span class="koboSpan" id="kobo.551.1">int</span></span><span class="koboSpan" id="kobo.552.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.553.1">1234</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.554.1">var</span></span><span class="koboSpan" id="kobo.555.1"> AnotherGlobal = </span><span class="hljs-number"><span class="koboSpan" id="kobo.556.1">-5678</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.557.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.558.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.559.1">()</span></span><span class="koboSpan" id="kobo.560.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.561.1">var</span></span><span class="koboSpan" id="kobo.562.1"> j </span><span class="hljs-type"><span class="koboSpan" id="kobo.563.1">int</span></span><span class="koboSpan" id="kobo.564.1">
    i := Global + AnotherGlobal
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.565.1">"Initial j value:"</span></span><span class="koboSpan" id="kobo.566.1">, j)
    j = Global
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.567.1">// math.Abs() requires a float64 parameter</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.568.1">// so we type cast it appropriately</span></span><span class="koboSpan" id="kobo.569.1">
    k := math.Abs(</span><span class="hljs-type"><span class="koboSpan" id="kobo.570.1">float64</span></span><span class="koboSpan" id="kobo.571.1">(AnotherGlobal))
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.572.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.573.1">Global=%d, i=%d, j=%d k=%.2f.\n"</span></span><span class="koboSpan" id="kobo.574.1">, Global, i, j, k)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.575.1">Personally, I prefer to make global variables stand out by either beginning them with an uppercase letter or using all capital letters. </span><span class="koboSpan" id="kobo.575.2">As you are going to learn in </span><em class="chapterRef"><span class="koboSpan" id="kobo.576.1">Chapter 6</span></em><span class="koboSpan" id="kobo.577.1">, </span><em class="italic"><span class="koboSpan" id="kobo.578.1">Go Packages and Functions</span></em><span class="koboSpan" id="kobo.579.1">, the case of the first character of a variable name has a special meaning in Go and changes its visibility. </span><span class="koboSpan" id="kobo.579.2">So this works for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">main</span></code><span class="koboSpan" id="kobo.581.1"> package only.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.582.1">This above</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.583.1"> program contains the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.584.1">A global </span><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">int</span></code><span class="koboSpan" id="kobo.586.1"> variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">Global</span></code><span class="koboSpan" id="kobo.588.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.589.1">A second global variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.590.1">AnotherGlobal</span></code><span class="koboSpan" id="kobo.591.1">â€”Go automatically infers its data type from its value, which in this case is an integer.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.592.1">A local variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.593.1">j</span></code><span class="koboSpan" id="kobo.594.1"> of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">int</span></code><span class="koboSpan" id="kobo.596.1">, which, as you will learn in the next chapter, is a special data type. </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">j</span></code><span class="koboSpan" id="kobo.598.1"> does not have an initial value, which means that Go automatically assigns the zero value of its data type, which in this case is </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">0</span></code><span class="koboSpan" id="kobo.600.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.601.1">Another local variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.602.1">i</span></code><span class="koboSpan" id="kobo.603.1">â€”Go infers its data type from its value. </span><span class="koboSpan" id="kobo.603.2">As it is the sum of two </span><code class="inlineCode"><span class="koboSpan" id="kobo.604.1">int</span></code><span class="koboSpan" id="kobo.605.1"> values, it is also an </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">int</span></code><span class="koboSpan" id="kobo.607.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.608.1">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.609.1">math.Abs()</span></code><span class="koboSpan" id="kobo.610.1"> requires a </span><code class="inlineCode"><span class="koboSpan" id="kobo.611.1">float64</span></code><span class="koboSpan" id="kobo.612.1"> parameter, you cannot pass </span><code class="inlineCode"><span class="koboSpan" id="kobo.613.1">AnotherGlobal</span></code><span class="koboSpan" id="kobo.614.1"> to it because </span><code class="inlineCode"><span class="koboSpan" id="kobo.615.1">AnotherGlobal</span></code><span class="koboSpan" id="kobo.616.1"> is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.617.1">int</span></code><span class="koboSpan" id="kobo.618.1"> variable. </span><span class="koboSpan" id="kobo.618.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.619.1">float64()</span></code> <strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.620.1">type cast</span></strong><span class="koboSpan" id="kobo.621.1"> converts the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.622.1">AnotherGlobal</span></code><span class="koboSpan" id="kobo.623.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.624.1">float64</span></code><span class="koboSpan" id="kobo.625.1">. </span><span class="koboSpan" id="kobo.625.2">Note that </span><code class="inlineCode"><span class="koboSpan" id="kobo.626.1">AnotherGlobal</span></code><span class="koboSpan" id="kobo.627.1"> continues to have the </span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">int</span></code><span class="koboSpan" id="kobo.629.1"> data type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.630.1">Lastly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.631.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.632.1"> formats and prints the output.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.633.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.634.1">variables.go</span></code><span class="koboSpan" id="kobo.635.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.636.1">Initial j value: 0
Global=1234, i=-4444, j=1234 k=5678.00.
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.637.1">This example demonstrated another important Go rule that was also mentioned previously: </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.638.1">Go does not allow implicit data conversions like C</span></strong><span class="koboSpan" id="kobo.639.1">. </span><span class="koboSpan" id="kobo.639.2">As presented in </span><code class="inlineCode"><span class="koboSpan" id="kobo.640.1">variables.go</span></code><span class="koboSpan" id="kobo.641.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">math.Abs()</span></code><span class="koboSpan" id="kobo.643.1"> function that expects (requires) a </span><code class="inlineCode"><span class="koboSpan" id="kobo.644.1">float64</span></code><span class="koboSpan" id="kobo.645.1"> value cannot work with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">int</span></code><span class="koboSpan" id="kobo.647.1"> value, even if this particular conversion is straightforward and error-free. </span><span class="koboSpan" id="kobo.647.2">The Go compiler refuses to compile such statements. </span><span class="koboSpan" id="kobo.647.3">You should convert the </span><code class="inlineCode"><span class="koboSpan" id="kobo.648.1">int</span></code><span class="koboSpan" id="kobo.649.1"> value to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.650.1">float64</span></code><span class="koboSpan" id="kobo.651.1"> explicitly using </span><code class="inlineCode"><span class="koboSpan" id="kobo.652.1">float64()</span></code><span class="koboSpan" id="kobo.653.1"> for things to work properly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.654.1">For conversions that </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.655.1">are not straightforward (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.656.1">string</span></code><span class="koboSpan" id="kobo.657.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.658.1">int</span></code><span class="koboSpan" id="kobo.659.1">), there exist specialized functions that allow you to catch issues with the conversion, in the form of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.660.1">error</span></code><span class="koboSpan" id="kobo.661.1"> variable that is returned by the function.</span></p>
<h2 class="heading-2" id="_idParaDest-33"><span class="koboSpan" id="kobo.662.1">Controlling program flow</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.663.1">So far, we have</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.664.1"> seen Go variables, but how do we change the flow of a Go program based on the value of a variable or some other condition? </span><span class="koboSpan" id="kobo.664.2">Go supports the </span><code class="inlineCode"><span class="koboSpan" id="kobo.665.1">if/else</span></code><span class="koboSpan" id="kobo.666.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.667.1">switch</span></code><span class="koboSpan" id="kobo.668.1"> control structures. </span><span class="koboSpan" id="kobo.668.2">Both control structures can be found in most modern programming languages, so if you have already programmed in another programming language, you should already be familiar with both </span><code class="inlineCode"><span class="koboSpan" id="kobo.669.1">if</span></code><span class="koboSpan" id="kobo.670.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.671.1">switch</span></code><span class="koboSpan" id="kobo.672.1"> statements. </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">if</span></code><span class="koboSpan" id="kobo.674.1"> statements use no parenthesis to embed the conditions that need to be examined because Go does not use parentheses in general. </span><span class="koboSpan" id="kobo.674.2">As expected, </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">if</span></code><span class="koboSpan" id="kobo.676.1"> has support for </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">else</span></code><span class="koboSpan" id="kobo.678.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.679.1">else if</span></code><span class="koboSpan" id="kobo.680.1"> statements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.681.1">To demonstrate the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.682.1">if</span></code><span class="koboSpan" id="kobo.683.1">, let us use a very common pattern in Go that is used almost everywhere. </span><span class="koboSpan" id="kobo.683.2">This pattern says that if the value of an error variable as returned from a function is </span><code class="inlineCode"><span class="koboSpan" id="kobo.684.1">nil</span></code><span class="koboSpan" id="kobo.685.1">, then everything is OK with the function execution. </span><span class="koboSpan" id="kobo.685.2">Otherwise, there is an error condition somewhere that needs special care. </span><span class="koboSpan" id="kobo.685.3">This pattern is usually implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.686.1">err := anyFunctionCall()
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.687.1">if</span></span><span class="koboSpan" id="kobo.688.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.689.1">nil</span></span><span class="koboSpan" id="kobo.690.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.691.1">// Do something if there is an error</span></span><span class="koboSpan" id="kobo.692.1">
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.693.1">err</span></code><span class="koboSpan" id="kobo.694.1"> is the variable that holds the error value as returned from a function and </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">!=</span></code><span class="koboSpan" id="kobo.696.1"> means that the value of the err variable is not equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.697.1">nil</span></code><span class="koboSpan" id="kobo.698.1">. </span><span class="koboSpan" id="kobo.698.2">You will see similar code multiple times in Go programs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.699.1">Lines beginning with </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">//</span></code><span class="koboSpan" id="kobo.701.1"> are single-line comments. </span><span class="koboSpan" id="kobo.701.2">If you put </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">//</span></code><span class="koboSpan" id="kobo.703.1"> in the middle of a line, then everything after </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">//</span></code><span class="koboSpan" id="kobo.705.1"> until the end of the line is considered a comment. </span><span class="koboSpan" id="kobo.705.2">This rule does not apply if </span><code class="inlineCode"><span class="koboSpan" id="kobo.706.1">//</span></code><span class="koboSpan" id="kobo.707.1"> is inside a string value.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.708.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.709.1">switch</span></code><span class="koboSpan" id="kobo.710.1"> statement has two different forms. </span><span class="koboSpan" id="kobo.710.2">In the first form, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.711.1">switch</span></code><span class="koboSpan" id="kobo.712.1"> statement has an expression that is evaluated, whereas in the second form, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">switch</span></code><span class="koboSpan" id="kobo.714.1"> statement has no expression to evaluate. </span><span class="koboSpan" id="kobo.714.2">In that case, expressions are evaluated in each </span><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">case</span></code><span class="koboSpan" id="kobo.716.1"> statement, which increases the flexibility of </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">switch</span></code><span class="koboSpan" id="kobo.718.1">. </span><span class="koboSpan" id="kobo.718.2">The main benefit you get from </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">switch</span></code><span class="koboSpan" id="kobo.720.1"> is that when used properly, it simplifies complex and hard-to-read </span><code class="inlineCode"><span class="koboSpan" id="kobo.721.1">if-else</span></code><span class="koboSpan" id="kobo.722.1"> blocks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.723.1">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.724.1">if</span></code><span class="koboSpan" id="kobo.725.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.726.1">switch</span></code><span class="koboSpan" id="kobo.727.1"> are illustrated in the following code, which is designed to process user input given as command line argumentsâ€”please type it and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">control.go</span></code><span class="koboSpan" id="kobo.729.1">. </span><span class="koboSpan" id="kobo.729.2">For learning </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.730.1">purposes, we present the code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.731.1">control.go</span></code><span class="koboSpan" id="kobo.732.1"> in pieces in order to explain it better:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.733.1">package</span></span><span class="koboSpan" id="kobo.734.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.735.1">import</span></span><span class="koboSpan" id="kobo.736.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.737.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.738.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.739.1">"strconv"</span></span><span class="koboSpan" id="kobo.740.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.741.1">This first part contains the expected preamble with the imported packages. </span><span class="koboSpan" id="kobo.741.2">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">main()</span></code><span class="koboSpan" id="kobo.743.1"> function starts next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.744.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.745.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.746.1">()</span></span><span class="koboSpan" id="kobo.747.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.748.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.749.1">len</span></span><span class="koboSpan" id="kobo.750.1">(os.Args) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.751.1">2</span></span><span class="koboSpan" id="kobo.752.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.753.1">"Please provide a command line argument"</span></span><span class="koboSpan" id="kobo.754.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.755.1">return</span></span><span class="koboSpan" id="kobo.756.1">
    }
    argument := os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.757.1">1</span></span><span class="koboSpan" id="kobo.758.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.759.1">This part of the program makes sure that you have a single command line argument to process, which is accessed as </span><code class="inlineCode"><span class="koboSpan" id="kobo.760.1">os.Args[1]</span></code><span class="koboSpan" id="kobo.761.1">, before continuing. </span><span class="koboSpan" id="kobo.761.2">We will cover this in more detail later, but you can refer to </span><em class="italic"><span class="koboSpan" id="kobo.762.1">Figure 1.2</span></em><span class="koboSpan" id="kobo.763.1"> for more information about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">os.Args</span></code><span class="koboSpan" id="kobo.765.1"> slice:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.766.1">// With expression after switch</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.767.1">switch</span></span><span class="koboSpan" id="kobo.768.1"> argument {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.769.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.770.1">"0"</span></span><span class="koboSpan" id="kobo.771.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.772.1">"Zero!"</span></span><span class="koboSpan" id="kobo.773.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.774.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.775.1">"1"</span></span><span class="koboSpan" id="kobo.776.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.777.1">"One!"</span></span><span class="koboSpan" id="kobo.778.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.779.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.780.1">"2"</span></span><span class="koboSpan" id="kobo.781.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.782.1">"3"</span></span><span class="koboSpan" id="kobo.783.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.784.1">"4"</span></span><span class="koboSpan" id="kobo.785.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.786.1">"2 or 3 or 4"</span></span><span class="koboSpan" id="kobo.787.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.788.1">fallthrough</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.789.1">default</span></span><span class="koboSpan" id="kobo.790.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.791.1">"Value:"</span></span><span class="koboSpan" id="kobo.792.1">, argument)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.793.1">Here, you see a switch block with four branches. </span><span class="koboSpan" id="kobo.793.2">The first three require exact string matches and the last one matches everything else. </span><span class="koboSpan" id="kobo.793.3">The order of the case statements is important because only the first match is executed. </span><span class="koboSpan" id="kobo.793.4">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.794.1">fallthrough</span></code><span class="koboSpan" id="kobo.795.1"> keyword tells Go that after this branch is executed, it will continue with the next branch, which in this case is the default branch:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.796.1">    value, err := strconv.Atoi(argument)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.797.1">if</span></span><span class="koboSpan" id="kobo.798.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.799.1">nil</span></span><span class="koboSpan" id="kobo.800.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.801.1">"Cannot convert to int:"</span></span><span class="koboSpan" id="kobo.802.1">, argument)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.803.1">return</span></span><span class="koboSpan" id="kobo.804.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.805.1">As command line arguments are initialized as string values, we need to convert user input into an integer </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.806.1">value using a separate call, which in this case is a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.807.1">strconv.Atoi()</span></code><span class="koboSpan" id="kobo.808.1">. </span><span class="koboSpan" id="kobo.808.2">If the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.809.1">err</span></code><span class="koboSpan" id="kobo.810.1"> variable is </span><code class="inlineCode"><span class="koboSpan" id="kobo.811.1">nil</span></code><span class="koboSpan" id="kobo.812.1">, then the conversion was successful, and we can continue. </span><span class="koboSpan" id="kobo.812.2">Otherwise, an error message is printed onscreen and the program exits.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.813.1">The following code shows the second form of </span><code class="inlineCode"><span class="koboSpan" id="kobo.814.1">switch</span></code><span class="koboSpan" id="kobo.815.1">, where the condition is evaluated at each case branch:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.816.1">// No expression after switch</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.817.1">switch</span></span><span class="koboSpan" id="kobo.818.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.819.1">case</span></span><span class="koboSpan" id="kobo.820.1"> value == </span><span class="hljs-number"><span class="koboSpan" id="kobo.821.1">0</span></span><span class="koboSpan" id="kobo.822.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.823.1">"Zero!"</span></span><span class="koboSpan" id="kobo.824.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.825.1">case</span></span><span class="koboSpan" id="kobo.826.1"> value &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.827.1">0</span></span><span class="koboSpan" id="kobo.828.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.829.1">"Positive integer"</span></span><span class="koboSpan" id="kobo.830.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.831.1">case</span></span><span class="koboSpan" id="kobo.832.1"> value &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.833.1">0</span></span><span class="koboSpan" id="kobo.834.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.835.1">"Negative integer"</span></span><span class="koboSpan" id="kobo.836.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.837.1">default</span></span><span class="koboSpan" id="kobo.838.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.839.1">"This should not happen:"</span></span><span class="koboSpan" id="kobo.840.1">, value)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.841.1">This gives you more flexibility but requires more thinking when reading the code. </span><span class="koboSpan" id="kobo.841.2">In this case, the default branch should not be executed, mainly because any valid integer value would be caught by the other three branches. </span><span class="koboSpan" id="kobo.841.3">Nevertheless, the default branch is there, which is good practice because it can catch unexpected values.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.842.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.843.1">control.go</span></code><span class="koboSpan" id="kobo.844.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.845.1">$ </span></span><span class="koboSpan" id="kobo.846.1">go run control.go 10
Value: 10
Positive integer
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.847.1">$ </span></span><span class="koboSpan" id="kobo.848.1">go run control.go 0
Zero!
</span><span class="koboSpan" id="kobo.848.2">Zero!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.849.1">Each one of</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.850.1"> the two switch blocks in </span><code class="inlineCode"><span class="koboSpan" id="kobo.851.1">control.go</span></code><span class="koboSpan" id="kobo.852.1"> creates one line of output.</span></p>
<h2 class="heading-2" id="_idParaDest-34"><span class="koboSpan" id="kobo.853.1">Iterating with for loops and range</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.854.1">This section is all</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.855.1"> about iterating in Go. </span><span class="koboSpan" id="kobo.855.2">Go </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.856.1">supports </span><code class="inlineCode"><span class="koboSpan" id="kobo.857.1">for</span></code><span class="koboSpan" id="kobo.858.1"> loops as well as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.859.1">range</span></code><span class="koboSpan" id="kobo.860.1"> keyword to iterate over all the elements of arrays, slices, and (as you will see in </span><em class="chapterRef"><span class="koboSpan" id="kobo.861.1">Chapter 3</span></em><span class="koboSpan" id="kobo.862.1">, </span><em class="italic"><span class="koboSpan" id="kobo.863.1">Composite Data Types</span></em><span class="koboSpan" id="kobo.864.1">) maps, without knowing the size of the data structure. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.865.1">An example of Go simplicity is the fact that Go provides support for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.866.1">for</span></code><span class="koboSpan" id="kobo.867.1"> keyword only, instead of including direct support for </span><code class="inlineCode"><span class="koboSpan" id="kobo.868.1">while</span></code><span class="koboSpan" id="kobo.869.1"> loops. </span><span class="koboSpan" id="kobo.869.2">However, depending on how you write a </span><code class="inlineCode"><span class="koboSpan" id="kobo.870.1">for</span></code><span class="koboSpan" id="kobo.871.1"> loop, it can function as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.872.1">while</span></code><span class="koboSpan" id="kobo.873.1"> loop or an infinite loop. </span><span class="koboSpan" id="kobo.873.2">Moreover, </span><code class="inlineCode"><span class="koboSpan" id="kobo.874.1">for</span></code><span class="koboSpan" id="kobo.875.1"> loops can implement the functionality of JavaScriptâ€™s </span><code class="inlineCode"><span class="koboSpan" id="kobo.876.1">forEach</span></code><span class="koboSpan" id="kobo.877.1"> function when combined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.878.1">range</span></code><span class="koboSpan" id="kobo.879.1"> keyword.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.880.1">You need to put curly braces around a </span><code class="inlineCode"><span class="koboSpan" id="kobo.881.1">for</span></code><span class="koboSpan" id="kobo.882.1"> loop even if it contains just a single statement or no statements at all.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.883.1">You can also create </span><code class="inlineCode"><span class="koboSpan" id="kobo.884.1">for</span></code><span class="koboSpan" id="kobo.885.1"> loops with variables and conditions. </span><span class="koboSpan" id="kobo.885.2">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.886.1">for</span></code><span class="koboSpan" id="kobo.887.1"> loop can be exited with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.888.1">break</span></code><span class="koboSpan" id="kobo.889.1"> keyword, and you can skip the current iteration with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.890.1">continue</span></code><span class="koboSpan" id="kobo.891.1"> keyword.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.892.1">The following program illustrates the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.893.1">for</span></code><span class="koboSpan" id="kobo.894.1"> on its own and with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">range</span></code><span class="koboSpan" id="kobo.896.1"> keywordâ€”type it and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.897.1">forLoops.go</span></code><span class="koboSpan" id="kobo.898.1"> to execute it afterward:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.899.1">package</span></span><span class="koboSpan" id="kobo.900.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.901.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.902.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.903.1">fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.904.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.905.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.906.1">()</span></span><span class="koboSpan" id="kobo.907.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.908.1">// Traditional for loop</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.909.1">for</span></span><span class="koboSpan" id="kobo.910.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.911.1">0</span></span><span class="koboSpan" id="kobo.912.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.913.1">10</span></span><span class="koboSpan" id="kobo.914.1">; i++ {
        fmt.Print(i*i, </span><span class="hljs-string"><span class="koboSpan" id="kobo.915.1">" "</span></span><span class="koboSpan" id="kobo.916.1">)
    }
    fmt.Println()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.917.1">The previous code illustrates a traditional </span><code class="inlineCode"><span class="koboSpan" id="kobo.918.1">for</span></code><span class="koboSpan" id="kobo.919.1"> loop that uses a local variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">i</span></code><span class="koboSpan" id="kobo.921.1">. </span><span class="koboSpan" id="kobo.921.2">This prints the squares of </span><code class="inlineCode"><span class="koboSpan" id="kobo.922.1">0</span></code><span class="koboSpan" id="kobo.923.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.924.1">1</span></code><span class="koboSpan" id="kobo.925.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">2</span></code><span class="koboSpan" id="kobo.927.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">3</span></code><span class="koboSpan" id="kobo.929.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">4</span></code><span class="koboSpan" id="kobo.931.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">5</span></code><span class="koboSpan" id="kobo.933.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.934.1">6</span></code><span class="koboSpan" id="kobo.935.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.936.1">7</span></code><span class="koboSpan" id="kobo.937.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">8</span></code><span class="koboSpan" id="kobo.939.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.940.1">9</span></code><span class="koboSpan" id="kobo.941.1"> onscreen. </span><span class="koboSpan" id="kobo.941.2">The square of </span><code class="inlineCode"><span class="koboSpan" id="kobo.942.1">10</span></code><span class="koboSpan" id="kobo.943.1"> is not computed and printed because it does not satisfy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.944.1">10 &lt; 10</span></code><span class="koboSpan" id="kobo.945.1"> condition.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.946.1">The following code</span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.947.1"> is idiomatic Go </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.948.1">and produces the same output as the previous </span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">for</span></code><span class="koboSpan" id="kobo.950.1"> loop:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.951.1">    i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.952.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.953.1">for</span></span><span class="koboSpan" id="kobo.954.1"> ok := </span><span class="hljs-literal"><span class="koboSpan" id="kobo.955.1">true</span></span><span class="koboSpan" id="kobo.956.1">; ok; ok = (i != </span><span class="hljs-number"><span class="koboSpan" id="kobo.957.1">10</span></span><span class="koboSpan" id="kobo.958.1">) {
        fmt.Print(i*i, </span><span class="hljs-string"><span class="koboSpan" id="kobo.959.1">" "</span></span><span class="koboSpan" id="kobo.960.1">)
        i++
    }
    fmt.Println()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.961.1">You might use it, but it is sometimes hard to read, especially for people who are new to Go. </span><span class="koboSpan" id="kobo.961.2">The following code shows how a </span><code class="inlineCode"><span class="koboSpan" id="kobo.962.1">for</span></code><span class="koboSpan" id="kobo.963.1"> loop can simulate a </span><code class="inlineCode"><span class="koboSpan" id="kobo.964.1">while</span></code><span class="koboSpan" id="kobo.965.1"> loop, which is not supported directly:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.966.1">// For loop used as while loop</span></span><span class="koboSpan" id="kobo.967.1">
    i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.968.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.969.1">for</span></span><span class="koboSpan" id="kobo.970.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.971.1">if</span></span><span class="koboSpan" id="kobo.972.1"> i == </span><span class="hljs-number"><span class="koboSpan" id="kobo.973.1">10</span></span><span class="koboSpan" id="kobo.974.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.975.1">break</span></span><span class="koboSpan" id="kobo.976.1">
        }
        fmt.Print(i*i, </span><span class="hljs-string"><span class="koboSpan" id="kobo.977.1">" "</span></span><span class="koboSpan" id="kobo.978.1">)
        i++
    }
    fmt.Println()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.979.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">break</span></code><span class="koboSpan" id="kobo.981.1"> keyword in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">if</span></code><span class="koboSpan" id="kobo.983.1"> condition exits the loop early and acts as the loop exit condition. </span><span class="koboSpan" id="kobo.983.2">Without an exit condition that is going to be met at some point and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.984.1">break</span></code><span class="koboSpan" id="kobo.985.1"> keyword, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.986.1">for</span></code><span class="koboSpan" id="kobo.987.1"> loop is never going to finish.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.988.1">Lastly, given a slice, which you can consider as a resizable array, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">aSlice</span></code><span class="koboSpan" id="kobo.990.1">, you iterate over all its elements with the help of </span><code class="inlineCode"><span class="koboSpan" id="kobo.991.1">range</span></code><span class="koboSpan" id="kobo.992.1">, which returns two ordered values: </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.993.1">the index of the current element in the slice and its value</span></strong><span class="koboSpan" id="kobo.994.1">. </span><span class="koboSpan" id="kobo.994.2">If you want to ignore either of these return values, which is not the case here, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.995.1">_</span></code><span class="koboSpan" id="kobo.996.1"> in the place of the value that you want to ignore. </span><span class="koboSpan" id="kobo.996.2">If you just need the index, you can leave out the second value from </span><code class="inlineCode"><span class="koboSpan" id="kobo.997.1">range</span></code><span class="koboSpan" id="kobo.998.1"> entirely without using </span><code class="inlineCode"><span class="koboSpan" id="kobo.999.1">_</span></code><span class="koboSpan" id="kobo.1000.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1001.1">// This is a slice but range also works with arrays</span></span><span class="koboSpan" id="kobo.1002.1">
    aSlice := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1003.1">int</span></span><span class="koboSpan" id="kobo.1004.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1005.1">-1</span></span><span class="koboSpan" id="kobo.1006.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1007.1">2</span></span><span class="koboSpan" id="kobo.1008.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1009.1">1</span></span><span class="koboSpan" id="kobo.1010.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1011.1">-1</span></span><span class="koboSpan" id="kobo.1012.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1013.1">2</span></span><span class="koboSpan" id="kobo.1014.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1015.1">-2</span></span><span class="koboSpan" id="kobo.1016.1">}
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1017.1">for</span></span><span class="koboSpan" id="kobo.1018.1"> i, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1019.1">range</span></span><span class="koboSpan" id="kobo.1020.1"> aSlice {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1021.1">"index:"</span></span><span class="koboSpan" id="kobo.1022.1">, i, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1023.1">"value: "</span></span><span class="koboSpan" id="kobo.1024.1">, v)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1025.1">If you run </span><code class="inlineCode"><span class="koboSpan" id="kobo.1026.1">forLoops.go</span></code><span class="koboSpan" id="kobo.1027.1">, you get the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1028.1">$ </span></span><span class="koboSpan" id="kobo.1029.1">go run forLoops.go
0 1 4 9 16 25 36 49 64 81
0 1 4 9 16 25 36 49 64 81
0 1 4 9 16 25 36 49 64 81
index: 0 value:  -1
index: 1 value:  2
index: 2 value:  1
index: 3 value:  -1
index: 4 value:  2
index: 5 value:  -2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1030.1">The previous output illustrates that the first three </span><code class="inlineCode"><span class="koboSpan" id="kobo.1031.1">for</span></code><span class="koboSpan" id="kobo.1032.1"> loops are equivalent and, therefore, produce</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.1033.1"> the same output. </span><span class="koboSpan" id="kobo.1033.2">The</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.1034.1"> last six lines show the index and the value of each element found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1035.1">aSlice</span></code><span class="koboSpan" id="kobo.1036.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1037.1">Now that we know about </span><code class="inlineCode"><span class="koboSpan" id="kobo.1038.1">for</span></code><span class="koboSpan" id="kobo.1039.1"> loops, let us see how to get user input.</span></p>
<h2 class="heading-2" id="_idParaDest-35"><span class="koboSpan" id="kobo.1040.1">Getting user input</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1041.1">Getting user</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.1042.1"> input is an important part of the majority of programs. </span><span class="koboSpan" id="kobo.1042.2">This section presents two ways of getting user input, which read from standard input and use the command line arguments of the program.</span></p>
<h2 class="heading-2" id="_idParaDest-36"><span class="koboSpan" id="kobo.1043.1">Reading from standard input</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1044.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1045.1">fmt.Scanln()</span></code><span class="koboSpan" id="kobo.1046.1"> function</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.1047.1"> can help you read user input while the program is already running and store it to a string variable, which is passed as a pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1048.1">fmt.Scanln()</span></code><span class="koboSpan" id="kobo.1049.1">. </span><span class="koboSpan" id="kobo.1049.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1050.1">fmt</span></code><span class="koboSpan" id="kobo.1051.1"> package contains additional functions for reading user input from the console (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1052.1">os.Stdin</span></code><span class="koboSpan" id="kobo.1053.1">), files, or argument lists.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1054.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1055.1">fmt.Scanln()</span></code><span class="koboSpan" id="kobo.1056.1"> function is rarely used to get user input. </span><span class="koboSpan" id="kobo.1056.2">Usually, user input is read from command line arguments or external files. </span><span class="koboSpan" id="kobo.1056.3">However, interactive command line applications need </span><code class="inlineCode"><span class="koboSpan" id="kobo.1057.1">fmt.Scanln()</span></code><span class="koboSpan" id="kobo.1058.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1059.1">The following code illustrates reading from standard inputâ€”type it and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">input.go</span></code><span class="koboSpan" id="kobo.1061.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1062.1">package</span></span><span class="koboSpan" id="kobo.1063.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1064.1">import</span></span><span class="koboSpan" id="kobo.1065.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1066.1">"fmt"</span></span><span class="koboSpan" id="kobo.1067.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1068.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1069.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1070.1">()</span></span><span class="koboSpan" id="kobo.1071.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1072.1">// Get User Input</span></span><span class="koboSpan" id="kobo.1073.1">
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1074.1">"Please give me your name: "</span></span><span class="koboSpan" id="kobo.1075.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1076.1">var</span></span><span class="koboSpan" id="kobo.1077.1"> name </span><span class="hljs-type"><span class="koboSpan" id="kobo.1078.1">string</span></span><span class="koboSpan" id="kobo.1079.1">
    fmt.Scanln(&amp;name)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1080.1">"Your name is"</span></span><span class="koboSpan" id="kobo.1081.1">, name)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1082.1">While waiting for user input, it is good to let the user know what kind of information they have to give, which is the purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1083.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.1084.1"> call. </span><span class="koboSpan" id="kobo.1084.2">The reason for not using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1085.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.1086.1"> instead is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1087.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.1088.1"> automatically appends a newline character at the end of the output, which is not what we want here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1089.1">Executing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1090.1">input.go</span></code><span class="koboSpan" id="kobo.1091.1"> generates the following kind of output and user interaction:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1092.1">$ </span></span><span class="koboSpan" id="kobo.1093.1">go run input.go
Please give me your name: Mihalis
Your name is Mihalis
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-37"><span class="koboSpan" id="kobo.1094.1">Working with command line arguments</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1095.1">Although typing </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.1096.1">user input when</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.1097.1"> needed might look like a nice idea, this is not usually how real software works. </span><span class="koboSpan" id="kobo.1097.2">Usually, user input is given in the form of command line arguments to the executable file. </span><span class="koboSpan" id="kobo.1097.3">By default, command line arguments in Go are stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1098.1">os.Args</span></code><span class="koboSpan" id="kobo.1099.1"> slice. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1100.1">The standard Go library also offers the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1101.1">flag</span></code><span class="koboSpan" id="kobo.1102.1"> package for parsing command line arguments, but there are better and more powerful alternatives.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1103.1">The figure that follows shows the way command line arguments work in Go, which is the same as in the C programming language. </span><span class="koboSpan" id="kobo.1103.2">It is important to know that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1104.1">os.Args</span></code><span class="koboSpan" id="kobo.1105.1"> slice is </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1106.1">properly initialized by Go and is available to the program when referenced</span></strong><span class="koboSpan" id="kobo.1107.1">. </span><span class="koboSpan" id="kobo.1107.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1108.1">os.Args</span></code><span class="koboSpan" id="kobo.1109.1"> slice contains </span><code class="inlineCode"><span class="koboSpan" id="kobo.1110.1">string</span></code><span class="koboSpan" id="kobo.1111.1"> values:</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.1112.1"><img alt="A picture containing text, screenshot, font, black  Description automatically generated" src="../Images/B21003_01_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1113.1">Figure 1.2: How the os.Args slice works</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1114.1">The first command line argument stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1115.1">os.Args</span></code><span class="koboSpan" id="kobo.1116.1"> slice is always the file path of the executable. </span><span class="koboSpan" id="kobo.1116.2">If you use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1117.1">go run</span></code><span class="koboSpan" id="kobo.1118.1">, you will get a temporary name and path; otherwise, it will be the path of the executable as given by the user. </span><span class="koboSpan" id="kobo.1118.2">The remaining command line arguments are what come after the name of the executableâ€”the various command line arguments are automatically separated by space characters unless they are included in double or single quotes; this depends on the OS.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1119.1">The use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1120.1">os.Args</span></code><span class="koboSpan" id="kobo.1121.1"> is illustrated in the code that follows, which is to find the minimum and the maximum numeric values of its input while ignoring invalid input, such as characters and</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.1122.1"> strings. </span><span class="koboSpan" id="kobo.1122.2">Type the </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.1123.1">code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1124.1">cla.go</span></code><span class="koboSpan" id="kobo.1125.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1126.1">package</span></span><span class="koboSpan" id="kobo.1127.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1128.1">import</span></span><span class="koboSpan" id="kobo.1129.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1130.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1131.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1132.1">"strconv"</span></span><span class="koboSpan" id="kobo.1133.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1134.1">As expected, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1135.1">cla.go</span></code><span class="koboSpan" id="kobo.1136.1"> begins with its preamble. </span><span class="koboSpan" id="kobo.1136.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1137.1">fmt</span></code><span class="koboSpan" id="kobo.1138.1"> package is used for printing output, whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1139.1">os</span></code><span class="koboSpan" id="kobo.1140.1"> package is required because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1141.1">os.Args</span></code><span class="koboSpan" id="kobo.1142.1"> is a part of it. </span><span class="koboSpan" id="kobo.1142.2">Lastly, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1143.1">strconv</span></code><span class="koboSpan" id="kobo.1144.1"> package contains functions for converting strings to numeric values. </span><span class="koboSpan" id="kobo.1144.2">Next, we make sure that we have at least one command line argument:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1145.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1146.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1147.1">()</span></span><span class="koboSpan" id="kobo.1148.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1149.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1150.1">len</span></span><span class="koboSpan" id="kobo.1151.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1152.1">1</span></span><span class="koboSpan" id="kobo.1153.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1154.1">"Need one or more arguments!"</span></span><span class="koboSpan" id="kobo.1155.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1156.1">return</span></span><span class="koboSpan" id="kobo.1157.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1158.1">Remember that the first element in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1159.1">os.Args</span></code><span class="koboSpan" id="kobo.1160.1"> is always the path of the executable file, so </span><code class="inlineCode"><span class="koboSpan" id="kobo.1161.1">os.Args</span></code><span class="koboSpan" id="kobo.1162.1"> is never totally empty. </span><span class="koboSpan" id="kobo.1162.2">Next, the program checks for errors in the same way we looked for them in previous examples. </span><span class="koboSpan" id="kobo.1162.3">You will learn more about errors and error handling in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1163.1">Chapter 2</span></em><span class="koboSpan" id="kobo.1164.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1165.1">Basic Go Data Types</span></em><span class="koboSpan" id="kobo.1166.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1167.1">var</span></span><span class="koboSpan" id="kobo.1168.1"> min, max </span><span class="hljs-type"><span class="koboSpan" id="kobo.1169.1">float64</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1170.1">var</span></span><span class="koboSpan" id="kobo.1171.1"> initialized = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1172.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1173.1">for</span></span><span class="koboSpan" id="kobo.1174.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1175.1">1</span></span><span class="koboSpan" id="kobo.1176.1">; i &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1177.1">len</span></span><span class="koboSpan" id="kobo.1178.1">(arguments); i++ {
        n, err := strconv.ParseFloat(arguments[i], </span><span class="hljs-number"><span class="koboSpan" id="kobo.1179.1">64</span></span><span class="koboSpan" id="kobo.1180.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1181.1">if</span></span><span class="koboSpan" id="kobo.1182.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1183.1">nil</span></span><span class="koboSpan" id="kobo.1184.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1185.1">continue</span></span><span class="koboSpan" id="kobo.1186.1">
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1187.1">In this case, we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1188.1">error</span></code><span class="koboSpan" id="kobo.1189.1"> variable returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1190.1">strconv.ParseFloat()</span></code><span class="koboSpan" id="kobo.1191.1"> to make sure that the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1192.1">strconv.ParseFloat()</span></code><span class="koboSpan" id="kobo.1193.1"> was successful and there is a valid numeric value to process. </span><span class="koboSpan" id="kobo.1193.2">Otherwise, we should continue to the next command line argument. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1194.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1195.1">for</span></code><span class="koboSpan" id="kobo.1196.1"> loop is used to iterate over all available command line arguments except the first one, which uses an index value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1197.1">0</span></code><span class="koboSpan" id="kobo.1198.1">. </span><span class="koboSpan" id="kobo.1198.2">This is another popular technique for working with all command line arguments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1199.1">The following code is used to properly initialize the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1200.1">min</span></code><span class="koboSpan" id="kobo.1201.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1202.1">max</span></code><span class="koboSpan" id="kobo.1203.1"> variables after the first valid command line argument is processed:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1204.1">if</span></span><span class="koboSpan" id="kobo.1205.1"> initialized == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1206.1">0</span></span><span class="koboSpan" id="kobo.1207.1"> {
            min = n
            max = n
            initialized = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1208.1">1</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1209.1">continue</span></span><span class="koboSpan" id="kobo.1210.1">
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1211.1">We are using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1212.1">initialized == 0</span></code><span class="koboSpan" id="kobo.1213.1"> to test whether this is the first valid command line argument. </span><span class="koboSpan" id="kobo.1213.2">If this is the case, we process the first command line argument and initialize the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1214.1">min</span></code><span class="koboSpan" id="kobo.1215.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1216.1">max</span></code><span class="koboSpan" id="kobo.1217.1"> variables to its value.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1218.1">The next code</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.1219.1"> checks whether the </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.1220.1">current value is our new minimum or maximumâ€”this is where the logic of the program is implemented:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1221.1">if</span></span><span class="koboSpan" id="kobo.1222.1"> n &lt; min {
            min = n
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1223.1">if</span></span><span class="koboSpan" id="kobo.1224.1"> n &gt; max {
            max = n
        }
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1225.1">"Min:"</span></span><span class="koboSpan" id="kobo.1226.1">, min)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1227.1">"Max:"</span></span><span class="koboSpan" id="kobo.1228.1">, max)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1229.1">The last part of the program is about printing your findings, which are the minimum and maximum numeric values of all valid command line arguments. </span><span class="koboSpan" id="kobo.1229.2">The output you get from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1230.1">cla.go</span></code><span class="koboSpan" id="kobo.1231.1"> depends on its input:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1232.1">$ </span></span><span class="koboSpan" id="kobo.1233.1">go run cla.go a b 2 -1
Min: -1
Max: 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1234.1">In this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1235.1">a</span></code><span class="koboSpan" id="kobo.1236.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1237.1">b</span></code><span class="koboSpan" id="kobo.1238.1"> are invalid, and the only valid inputs are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1239.1">-1</span></code><span class="koboSpan" id="kobo.1240.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1241.1">2</span></code><span class="koboSpan" id="kobo.1242.1">, which are the minimum value and maximum value, respectively:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1243.1">$ </span></span><span class="koboSpan" id="kobo.1244.1">go run cla.go a 0 b -1.2 10.32
Min: -1.2
Max: 10.32
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1245.1">In this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1246.1">a</span></code><span class="koboSpan" id="kobo.1247.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1248.1">b</span></code><span class="koboSpan" id="kobo.1249.1"> are invalid input and, therefore, ignored:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1250.1">$ </span></span><span class="koboSpan" id="kobo.1251.1">go run cla.go
Need one or more arguments!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1252.1">In the final case, as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1253.1">cla.go</span></code><span class="koboSpan" id="kobo.1254.1"> has no input to process, it prints a help message. </span><span class="koboSpan" id="kobo.1254.2">If you execute the program with no valid input values, for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1255.1">go run cla.go a b c</span></code><span class="koboSpan" id="kobo.1256.1">, then the </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.1257.1">values </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.1258.1">of both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1259.1">Min</span></code><span class="koboSpan" id="kobo.1260.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1261.1">Max</span></code><span class="koboSpan" id="kobo.1262.1"> are going to be zero.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1263.1">The next subsection shows a technique for differentiating between different data types, using error variables.</span></p>
<h2 class="heading-2" id="_idParaDest-38"><span class="koboSpan" id="kobo.1264.1">Using error variables to differentiate between input types</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1265.1">Now, let me</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.1266.1"> show you a technique that uses error variables to differentiate between various kinds of user input. </span><span class="koboSpan" id="kobo.1266.2">For this technique to work, you should go from more specific cases to more generic ones. </span><span class="koboSpan" id="kobo.1266.3">If we are talking about numeric values, you should first examine whether a string is a valid integer before examining whether the same string is a floating-point value, because every valid integer is also a valid floating-point value.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1267.1">The first part of the program, which is saved as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1268.1">process.go</span></code><span class="koboSpan" id="kobo.1269.1">, is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1270.1">package</span></span><span class="koboSpan" id="kobo.1271.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1272.1">import</span></span><span class="koboSpan" id="kobo.1273.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1274.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1275.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1276.1">"strconv"</span></span><span class="koboSpan" id="kobo.1277.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1278.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1279.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1280.1">()</span></span><span class="koboSpan" id="kobo.1281.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1282.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1283.1">len</span></span><span class="koboSpan" id="kobo.1284.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1285.1">1</span></span><span class="koboSpan" id="kobo.1286.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1287.1">"Not enough arguments"</span></span><span class="koboSpan" id="kobo.1288.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1289.1">return</span></span><span class="koboSpan" id="kobo.1290.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1291.1">The previous code contains the preamble and the storing of the command line arguments in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1292.1">arguments</span></code><span class="koboSpan" id="kobo.1293.1"> variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1294.1">The next part is where we start examining the validity of the input:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1295.1">var</span></span><span class="koboSpan" id="kobo.1296.1"> total, nInts, nFloats </span><span class="hljs-type"><span class="koboSpan" id="kobo.1297.1">int</span></span><span class="koboSpan" id="kobo.1298.1">
    invalid := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1299.1">make</span></span><span class="koboSpan" id="kobo.1300.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1301.1">string</span></span><span class="koboSpan" id="kobo.1302.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1303.1">0</span></span><span class="koboSpan" id="kobo.1304.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1305.1">for</span></span><span class="koboSpan" id="kobo.1306.1"> _, k := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1307.1">range</span></span><span class="koboSpan" id="kobo.1308.1"> arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1309.1">1</span></span><span class="koboSpan" id="kobo.1310.1">:] {
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1311.1">// Is it an integer?</span></span><span class="koboSpan" id="kobo.1312.1">
        _, err := strconv.Atoi(k)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1313.1">if</span></span><span class="koboSpan" id="kobo.1314.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1315.1">nil</span></span><span class="koboSpan" id="kobo.1316.1"> {
            total++
            nInts++
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1317.1">continue</span></span><span class="koboSpan" id="kobo.1318.1">
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1319.1">First, we create three variables for keeping a count of the total number of valid values examined, the total number of integer values found, and the total number of floating-point values</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.1320.1"> found, respectively. </span><span class="koboSpan" id="kobo.1320.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1321.1">invalid</span></code><span class="koboSpan" id="kobo.1322.1"> variable, which is a slice of strings, is used for keeping all non-numeric values.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1323.1">Once again, we need to iterate over all the command line arguments except the first one, which has an index value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1324.1">0</span></code><span class="koboSpan" id="kobo.1325.1">, because this is the path of the executable file. </span><span class="koboSpan" id="kobo.1325.2">We ignore the path of the executable, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1326.1">arguments[1:]</span></code><span class="koboSpan" id="kobo.1327.1"> instead of just </span><code class="inlineCode"><span class="koboSpan" id="kobo.1328.1">arguments</span></code><span class="koboSpan" id="kobo.1329.1">â€”selecting a continuous part of a slice is discussed in the next chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1330.1">The call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1331.1">strconv.Atoi()</span></code><span class="koboSpan" id="kobo.1332.1"> determines whether we are processing a valid </span><code class="inlineCode"><span class="koboSpan" id="kobo.1333.1">int</span></code><span class="koboSpan" id="kobo.1334.1"> value or not. </span><span class="koboSpan" id="kobo.1334.2">If so, we increase the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1335.1">total</span></code><span class="koboSpan" id="kobo.1336.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1337.1">nInts</span></code><span class="koboSpan" id="kobo.1338.1"> counters:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1339.1">// Is it a float</span></span><span class="koboSpan" id="kobo.1340.1">
        _, err = strconv.ParseFloat(k, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1341.1">64</span></span><span class="koboSpan" id="kobo.1342.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1343.1">if</span></span><span class="koboSpan" id="kobo.1344.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1345.1">nil</span></span><span class="koboSpan" id="kobo.1346.1"> {
            total++
            nFloats++
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1347.1">continue</span></span><span class="koboSpan" id="kobo.1348.1">
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1349.1">Similarly, if the examined string represents a valid floating-point value, the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1350.1">strconv.ParseFloat()</span></code><span class="koboSpan" id="kobo.1351.1"> is going to be successful, and the program will update the relevant counters. </span><span class="koboSpan" id="kobo.1351.2">Lastly, if a value is not numeric, it is appended to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1352.1">invalid</span></code><span class="koboSpan" id="kobo.1353.1"> slice with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1354.1">append()</span></code><span class="koboSpan" id="kobo.1355.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1356.1">// Then it is invalid</span></span><span class="koboSpan" id="kobo.1357.1">
        invalid = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1358.1">append</span></span><span class="koboSpan" id="kobo.1359.1">(invalid, k)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1360.1">The last part of the program is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1361.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1362.1">"#read:"</span></span><span class="koboSpan" id="kobo.1363.1">, total, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1364.1">"#ints:"</span></span><span class="koboSpan" id="kobo.1365.1">, nInts, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1366.1">"#floats:"</span></span><span class="koboSpan" id="kobo.1367.1">, nFloats)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1368.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1369.1">len</span></span><span class="koboSpan" id="kobo.1370.1">(invalid) &gt; total {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1371.1">"Too much invalid input:"</span></span><span class="koboSpan" id="kobo.1372.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1373.1">len</span></span><span class="koboSpan" id="kobo.1374.1">(invalid))
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1375.1">for</span></span><span class="koboSpan" id="kobo.1376.1"> _, s := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1377.1">range</span></span><span class="koboSpan" id="kobo.1378.1"> invalid {
            fmt.Println(s)
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1379.1">Presented here is</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.1380.1"> extra code that warns you when your invalid input is more than the valid one (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1381.1">len(invalid) &gt; total</span></code><span class="koboSpan" id="kobo.1382.1">). </span><span class="koboSpan" id="kobo.1382.2">This is a common practice for keeping unexpected input in applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1383.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1384.1">process.go</span></code><span class="koboSpan" id="kobo.1385.1"> produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1386.1">$ </span></span><span class="koboSpan" id="kobo.1387.1">go run process.go 1 2 3
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1388.1">#</span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1389.1">read</span></span><span class="koboSpan" id="kobo.1390.1">: 3 </span><span class="hljs-con-comment"><span class="koboSpan" id="kobo.1391.1">#ints: 3 #floats: 0</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1392.1">In this case, we process 1, 2, and 3, which are all valid integer values:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1393.1">$ </span></span><span class="koboSpan" id="kobo.1394.1">go run process.go 1 2.1 a    
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1395.1">#</span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1396.1">read</span></span><span class="koboSpan" id="kobo.1397.1">: 2 </span><span class="hljs-con-comment"><span class="koboSpan" id="kobo.1398.1">#ints: 1 #floats: 1</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1399.1">In this case, we have a valid integer, 1, a floating-point value, 2.1, and an invalid value, a:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1400.1">$ </span></span><span class="koboSpan" id="kobo.1401.1">go run process.go a 1 b
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1402.1">#</span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1403.1">read</span></span><span class="koboSpan" id="kobo.1404.1">: 1 </span><span class="hljs-con-comment"><span class="koboSpan" id="kobo.1405.1">#ints: 1 #floats: 0</span></span><span class="koboSpan" id="kobo.1406.1">
Too much invalid input: 2
a
b
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1407.1">If the invalid input is more than the valid one, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.1408.1">process.go</span></code><span class="koboSpan" id="kobo.1409.1"> prints an extra error message.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1410.1">The next</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.1411.1"> subsection discusses the concurrency model of Go.</span></p>
<h2 class="heading-2" id="_idParaDest-39"><span class="koboSpan" id="kobo.1412.1">Understanding the Go concurrency model</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1413.1">This section is a </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.1414.1">quick introduction to the Go concurrency</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.1415.1"> model. </span><span class="koboSpan" id="kobo.1415.2">The Go concurrency model is implemented using </span><em class="italic"><span class="koboSpan" id="kobo.1416.1">goroutines</span></em><span class="koboSpan" id="kobo.1417.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1418.1">channels</span></em><span class="koboSpan" id="kobo.1419.1">. </span><span class="koboSpan" id="kobo.1419.2">A goroutine is the smallest executable Go entity. </span><span class="koboSpan" id="kobo.1419.3">To create a new goroutine, you have to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1420.1">go</span></code><span class="koboSpan" id="kobo.1421.1"> keyword followed by a predefined function or an anonymous functionâ€”both these methods are equivalent as far as Go is concerned.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1422.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1423.1">go</span></code><span class="koboSpan" id="kobo.1424.1"> keyword works with functions or anonymous functions only.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1425.1">A channel in Go is a mechanism that, among other things, allows goroutines to communicate and exchange data. </span><span class="koboSpan" id="kobo.1425.2">If you are an amateur programmer or are hearing about goroutines and channels for the first time, do not panic. </span><span class="koboSpan" id="kobo.1425.3">Goroutines and channels, as well as pipelines and sharing data among goroutines, will be explained in much more detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1426.1">Chapter 8</span></em><span class="koboSpan" id="kobo.1427.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1428.1">Go Concurrency</span></em><span class="koboSpan" id="kobo.1429.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1430.1">Although it is easy to create goroutines, there are other difficulties when dealing with concurrent programming, including goroutine synchronization and sharing data between goroutinesâ€”this is a Go mechanism for avoiding side effects by using global state when running goroutines. </span><span class="koboSpan" id="kobo.1430.2">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.1431.1">main()</span></code><span class="koboSpan" id="kobo.1432.1"> runs as a goroutine as well, you do not want </span><code class="inlineCode"><span class="koboSpan" id="kobo.1433.1">main()</span></code><span class="koboSpan" id="kobo.1434.1"> to finish before the other goroutines of the program because once </span><code class="inlineCode"><span class="koboSpan" id="kobo.1435.1">main()</span></code><span class="koboSpan" id="kobo.1436.1"> exits, the entire program along with any goroutines that have not finished yet will terminate. </span><span class="koboSpan" id="kobo.1436.2">Although goroutines cannot communicate directly with each other, they can share memory. </span><span class="koboSpan" id="kobo.1436.3">The good thing is that there are various techniques for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1437.1">main()</span></code><span class="koboSpan" id="kobo.1438.1"> function to wait for goroutines to exchange data through channels or, less frequently in Go, use shared memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1439.1">Type the following Go program, which synchronizes goroutines using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1440.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.1441.1"> calls (this is not the right way to synchronize goroutinesâ€”we will discuss the proper way to synchronize goroutines in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1442.1">Chapter 8</span></em><span class="koboSpan" id="kobo.1443.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1444.1">Go Concurrency</span></em><span class="koboSpan" id="kobo.1445.1">), into your favorite editor, and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1446.1">goRoutines.go</span></code><span class="koboSpan" id="kobo.1447.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1448.1">package</span></span><span class="koboSpan" id="kobo.1449.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1450.1">import</span></span><span class="koboSpan" id="kobo.1451.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1452.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1453.1">"time"</span></span><span class="koboSpan" id="kobo.1454.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1455.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1456.1">myPrint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1457.1">(start, finish </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1458.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1459.1">)</span></span><span class="koboSpan" id="kobo.1460.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1461.1">for</span></span><span class="koboSpan" id="kobo.1462.1"> i := start; i &lt;= finish; i++ {
        fmt.Print(i, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1463.1">" "</span></span><span class="koboSpan" id="kobo.1464.1">)
    }
    fmt.Println()
    time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1465.1">100</span></span><span class="koboSpan" id="kobo.1466.1"> * time.Microsecond)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1467.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1468.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1469.1">()</span></span><span class="koboSpan" id="kobo.1470.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1471.1">for</span></span><span class="koboSpan" id="kobo.1472.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1473.1">0</span></span><span class="koboSpan" id="kobo.1474.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1475.1">4</span></span><span class="koboSpan" id="kobo.1476.1">; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1477.1">go</span></span><span class="koboSpan" id="kobo.1478.1"> myPrint(i, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1479.1">5</span></span><span class="koboSpan" id="kobo.1480.1">)
    }
    time.Sleep(time.Second)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1481.1">The preceding naively implemented example creates four goroutines and prints some values on the screen using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1482.1">myPrint()</span></code><span class="koboSpan" id="kobo.1483.1"> functionâ€”the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1484.1">go</span></code><span class="koboSpan" id="kobo.1485.1"> keyword is used for creating the </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.1486.1">goroutines. </span><span class="koboSpan" id="kobo.1486.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1487.1">goRoutines.go</span></code><span class="koboSpan" id="kobo.1488.1"> generates </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.1489.1">the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1490.1">$ </span></span><span class="koboSpan" id="kobo.1491.1">go run goRoutines.go
2 3 4 5
0 4 1 2 3 1 2 3 4 4 5
5
3 4 5
5
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1492.1">However, if you run it multiple times, you will most likely get a different output each time:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1493.1">1 2 3 4 5 
4 2 5 3 4 5 
3 0 1 2 3 4 5 
4 5
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1494.1">This happens because </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1495.1">goroutines are initialized in a random order and start running in a random order</span></strong><span class="koboSpan" id="kobo.1496.1">. </span><span class="koboSpan" id="kobo.1496.2">The Go scheduler is responsible for the execution of goroutines, just like the OS scheduler is responsible for the execution of the OS threads. </span><em class="chapterRef"><span class="koboSpan" id="kobo.1497.1">Chapter 8</span></em><span class="koboSpan" id="kobo.1498.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1499.1">Go Concurrency</span></em><span class="koboSpan" id="kobo.1500.1">, discusses Go concurrency in more detail and presents the solution to that randomness issue with the use of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1501.1">sync.WaitGroup</span></code><span class="koboSpan" id="kobo.1502.1"> variableâ€”however, keep in mind that Go concurrency is everywhere, which is the main reason for including this section here. </span><span class="koboSpan" id="kobo.1502.2">Therefore, as some error messages generated by the compiler discuss goroutines, you should not think that these goroutines were created by you.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1503.1">The next section shows a practical example that involves developing a Go version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1504.1">which(1)</span></code><span class="koboSpan" id="kobo.1505.1"> utility, which </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.1506.1">searches for an executable file in</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.1507.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1508.1">PATH</span></code><span class="koboSpan" id="kobo.1509.1"> environment value of the current user.</span></p>
<h1 class="heading-1" id="_idParaDest-40"><span class="koboSpan" id="kobo.1510.1">Developing the which(1) utility in Go</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1511.1">Go can work with </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.1512.1">your operating system through a set of packages. </span><span class="koboSpan" id="kobo.1512.2">A good way of learning a new programming language is by trying to implement simple versions of traditional UNIX utilitiesâ€”in general, the only efficient way to learn a programming language is by writing lots of code in that language. </span><span class="koboSpan" id="kobo.1512.3">In this section, you will see a Go version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1513.1">which(1)</span></code><span class="koboSpan" id="kobo.1514.1"> utility, which will help you understand the way Go interacts with the underlying OS and reads environment variables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1515.1">The presented code, which will implement the functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1516.1">which(1)</span></code><span class="koboSpan" id="kobo.1517.1">, can be divided into three logical parts. </span><span class="koboSpan" id="kobo.1517.2">The first part is about reading the input argument, which is the name of the executable file that the utility will be searching for. </span><span class="koboSpan" id="kobo.1517.3">The second part is about reading the value stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1518.1">PATH</span></code><span class="koboSpan" id="kobo.1519.1"> environment variable, splitting it, and iterating over the directories of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1520.1">PATH</span></code><span class="koboSpan" id="kobo.1521.1"> variable. </span><span class="koboSpan" id="kobo.1521.2">The third part is about looking for the desired binary file in these directories and determining whether it can be found or not, whether it is a regular file, and whether it is an executable file. </span><span class="koboSpan" id="kobo.1521.3">If the desired executable file is found, the program terminates with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1522.1">return</span></code><span class="koboSpan" id="kobo.1523.1"> statement. </span><span class="koboSpan" id="kobo.1523.2">Otherwise, it will terminate after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1524.1">for</span></code><span class="koboSpan" id="kobo.1525.1"> loop ends and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1526.1">main()</span></code><span class="koboSpan" id="kobo.1527.1"> function exits.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1528.1">The presented source file is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1529.1">which.go</span></code><span class="koboSpan" id="kobo.1530.1"> and is located under the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1531.1">ch01</span></code><span class="koboSpan" id="kobo.1532.1"> directory of the GitHub repository of the book. </span><span class="koboSpan" id="kobo.1532.2">Now, let us see the code, beginning with the logical preamble that usually includes the package name, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1533.1">import</span></code><span class="koboSpan" id="kobo.1534.1"> statements, and other definitions with a global scope:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1535.1">package</span></span><span class="koboSpan" id="kobo.1536.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1537.1">import</span></span><span class="koboSpan" id="kobo.1538.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1539.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1540.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1541.1">"path/filepath"</span></span><span class="koboSpan" id="kobo.1542.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1543.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1544.1">fmt</span></code><span class="koboSpan" id="kobo.1545.1"> package is used for printing onscreen, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1546.1">os</span></code><span class="koboSpan" id="kobo.1547.1"> package is for interacting with the underlying operating system, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1548.1">path/filepath</span></code><span class="koboSpan" id="kobo.1549.1"> package is used for working with the contents of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1550.1">PATH</span></code><span class="koboSpan" id="kobo.1551.1"> variable that is read as a long string, depending on the number of directories it contains.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1552.1">The second logical part of the utility is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1553.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1554.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1555.1">()</span></span><span class="koboSpan" id="kobo.1556.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1557.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1558.1">len</span></span><span class="koboSpan" id="kobo.1559.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1560.1">1</span></span><span class="koboSpan" id="kobo.1561.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1562.1">"Please provide an argument!"</span></span><span class="koboSpan" id="kobo.1563.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1564.1">return</span></span><span class="koboSpan" id="kobo.1565.1">
    }
    file := arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1566.1">1</span></span><span class="koboSpan" id="kobo.1567.1">]
    path := os.Getenv(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1568.1">"PATH"</span></span><span class="koboSpan" id="kobo.1569.1">)
    pathSplit := filepath.SplitList(path)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1570.1">for</span></span><span class="koboSpan" id="kobo.1571.1"> _, directory := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1572.1">range</span></span><span class="koboSpan" id="kobo.1573.1"> pathSplit {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1574.1">First, we read the command line arguments of the program (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1575.1">os.Args</span></code><span class="koboSpan" id="kobo.1576.1">) and save the first command line </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.1577.1">argument into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1578.1">file</span></code><span class="koboSpan" id="kobo.1579.1"> variable. </span><span class="koboSpan" id="kobo.1579.2">Then, we get the contents of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1580.1">PATH</span></code><span class="koboSpan" id="kobo.1581.1"> environment variable and split it using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1582.1">filepath.SplitList()</span></code><span class="koboSpan" id="kobo.1583.1">, which offers a portable way of separating a list of paths. </span><span class="koboSpan" id="kobo.1583.2">Lastly, we iterate over all the directories of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1584.1">PATH</span></code><span class="koboSpan" id="kobo.1585.1"> variable using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1586.1">for</span></code><span class="koboSpan" id="kobo.1587.1"> loop with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1588.1">range</span></code><span class="koboSpan" id="kobo.1589.1">, as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1590.1">filepath.SplitList()</span></code><span class="koboSpan" id="kobo.1591.1"> returns a slice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1592.1">The rest of the utility contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1593.1">        fullPath := filepath.Join(directory, file)
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1594.1">// Does it exist?</span></span><span class="koboSpan" id="kobo.1595.1">
        fileInfo, err := os.Stat(fullPath)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1596.1">if</span></span><span class="koboSpan" id="kobo.1597.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1598.1">nil</span></span><span class="koboSpan" id="kobo.1599.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1600.1">continue</span></span><span class="koboSpan" id="kobo.1601.1">
        }
        mode := fileInfo.Mode()
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1602.1">// Is it a regular file?</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1603.1">if</span></span><span class="koboSpan" id="kobo.1604.1"> !mode.IsRegular() {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1605.1">continue</span></span><span class="koboSpan" id="kobo.1606.1">
        }
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1607.1">// Is it executable?</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1608.1">if</span></span><span class="koboSpan" id="kobo.1609.1"> mode&amp;</span><span class="hljs-number"><span class="koboSpan" id="kobo.1610.1">0111</span></span><span class="koboSpan" id="kobo.1611.1"> != </span><span class="hljs-number"><span class="koboSpan" id="kobo.1612.1">0</span></span><span class="koboSpan" id="kobo.1613.1"> {
            fmt.Println(fullPath)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1614.1">return</span></span><span class="koboSpan" id="kobo.1615.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1616.1">We construct the full path that we examine using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1617.1">filepath.Join()</span></code><span class="koboSpan" id="kobo.1618.1">, which is used for concatenating the different parts of a path using an OS-specific separatorâ€”this makes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1619.1">filepath.Join()</span></code><span class="koboSpan" id="kobo.1620.1"> work on all supported operating systems. </span><span class="koboSpan" id="kobo.1620.2">In this part, we also get some lower-level information about the fileâ€”keep in mind that UNIX considers everything as a file, which means that we want to make sure that we are dealing with a regular file that is also executable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1621.1">Executing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1622.1">which.go</span></code><span class="koboSpan" id="kobo.1623.1"> generates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1624.1">$ </span></span><span class="koboSpan" id="kobo.1625.1">go run which.go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1626.1">which</span></span><span class="koboSpan" id="kobo.1627.1">
/usr/bin/which
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1628.1">$ </span></span><span class="koboSpan" id="kobo.1629.1">go run which.go doesNotExist
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1630.1">The last command could not find the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1631.1">doesNotExist</span></code><span class="koboSpan" id="kobo.1632.1"> executableâ€”according to the UNIX philosophy and the way UNIX pipes work, utilities generate no output onscreen if they have nothing to say.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1633.1">Although it is useful to print error messages onscreen, there are times that you need to keep all error </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.1634.1">messages together and be able to search for them later when it is convenient for you. </span><span class="koboSpan" id="kobo.1634.2">In this case, you need to use one or more log files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1635.1">The next section discusses logging in Go.</span></p>
<h1 class="heading-1" id="_idParaDest-41"><span class="koboSpan" id="kobo.1636.1">Logging information</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1637.1">All UNIX systems have</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.1638.1"> their own log files for writing logging information that comes from running servers and programs. </span><span class="koboSpan" id="kobo.1638.2">Usually, most system log files of a UNIX system can be found under the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1639.1">/var/log</span></code><span class="koboSpan" id="kobo.1640.1"> directory. </span><span class="koboSpan" id="kobo.1640.2">However, the log files of many popular services, such as Apache and Nginx, can be found elsewhere, depending on their configuration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1641.1">Logging and storing logging information in log files is a practical way of examining data and information from your software asynchronously, either locally, at a central log server, or using server software such as Elasticsearch, Beats, and Grafana Loki.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1642.1">Generally speaking, using a log file to write some information used to be considered a better practice than writing the same output on screen for two reasons. </span><span class="koboSpan" id="kobo.1642.2">Firstly, because the output does not get lost, as it is stored on a file, and secondly, because you can search and process log files using UNIX tools, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1643.1">grep(1)</span></code><span class="koboSpan" id="kobo.1644.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1645.1">awk(1)</span></code><span class="koboSpan" id="kobo.1646.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1647.1">sed(1)</span></code><span class="koboSpan" id="kobo.1648.1">, which cannot be done when messages are printed in a terminal window. </span><span class="koboSpan" id="kobo.1648.2">However, writing to log files is not always the best approach, mainly because many services run as Docker images, which have their own log files that get lost when the Docker image stops.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1649.1">As we usually run our services via </span><code class="inlineCode"><span class="koboSpan" id="kobo.1650.1">systemd</span></code><span class="koboSpan" id="kobo.1651.1">, programs should log to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1652.1">stdout</span></code><span class="koboSpan" id="kobo.1653.1"> so that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1654.1">systemd</span></code><span class="koboSpan" id="kobo.1655.1"> can put logging data in the journal. </span><a href="https://12factor.net/logs"><span class="url"><span class="koboSpan" id="kobo.1656.1">https://12factor.net/logs</span></span></a><span class="koboSpan" id="kobo.1657.1"> offers more information about app logs. </span><span class="koboSpan" id="kobo.1657.2">Additionally, in cloud-native applications, we are encouraged to simply log to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1658.1">stderr</span></code><span class="koboSpan" id="kobo.1659.1"> and let the container system redirect the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1660.1">stderr</span></code><span class="koboSpan" id="kobo.1661.1"> stream to the desired destination.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1662.1">The UNIX logging service has support for two properties named </span><em class="italic"><span class="koboSpan" id="kobo.1663.1">logging level</span></em><span class="koboSpan" id="kobo.1664.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1665.1">logging facility</span></em><span class="koboSpan" id="kobo.1666.1">. </span><span class="koboSpan" id="kobo.1666.2">The logging level is a value that specifies the severity of the log entry. </span><span class="koboSpan" id="kobo.1666.3">There are various logging levels, including </span><code class="inlineCode"><span class="koboSpan" id="kobo.1667.1">debug</span></code><span class="koboSpan" id="kobo.1668.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1669.1">info</span></code><span class="koboSpan" id="kobo.1670.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1671.1">notice</span></code><span class="koboSpan" id="kobo.1672.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1673.1">warning</span></code><span class="koboSpan" id="kobo.1674.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1675.1">err</span></code><span class="koboSpan" id="kobo.1676.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1677.1">crit</span></code><span class="koboSpan" id="kobo.1678.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1679.1">alert</span></code><span class="koboSpan" id="kobo.1680.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1681.1">emerg</span></code><span class="koboSpan" id="kobo.1682.1">, in reverse order of severity. </span><span class="koboSpan" id="kobo.1682.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1683.1">log</span></code><span class="koboSpan" id="kobo.1684.1"> package of the standard Go library does not support working with logging levels. </span><span class="koboSpan" id="kobo.1684.2">The logging facility is like a category used for logging</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.1685.1"> information. </span><span class="koboSpan" id="kobo.1685.2">The value of the logging facility part can be one of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1686.1">auth</span></code><span class="koboSpan" id="kobo.1687.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1688.1">authpriv</span></code><span class="koboSpan" id="kobo.1689.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1690.1">cron</span></code><span class="koboSpan" id="kobo.1691.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1692.1">daemon</span></code><span class="koboSpan" id="kobo.1693.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1694.1">kern</span></code><span class="koboSpan" id="kobo.1695.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1696.1">lpr</span></code><span class="koboSpan" id="kobo.1697.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1698.1">mail</span></code><span class="koboSpan" id="kobo.1699.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1700.1">mark</span></code><span class="koboSpan" id="kobo.1701.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1702.1">news</span></code><span class="koboSpan" id="kobo.1703.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1704.1">syslog</span></code><span class="koboSpan" id="kobo.1705.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1706.1">user</span></code><span class="koboSpan" id="kobo.1707.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1708.1">UUCP</span></code><span class="koboSpan" id="kobo.1709.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1710.1">local0</span></code><span class="koboSpan" id="kobo.1711.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1712.1">local1</span></code><span class="koboSpan" id="kobo.1713.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1714.1">local2</span></code><span class="koboSpan" id="kobo.1715.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1716.1">local3</span></code><span class="koboSpan" id="kobo.1717.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1718.1">local4</span></code><span class="koboSpan" id="kobo.1719.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1720.1">local5</span></code><span class="koboSpan" id="kobo.1721.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1722.1">local6</span></code><span class="koboSpan" id="kobo.1723.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1724.1">local7</span></code><span class="koboSpan" id="kobo.1725.1"> and is defined inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.1726.1">/etc/syslog.conf</span></code><span class="koboSpan" id="kobo.1727.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1728.1">/etc/rsyslog.conf</span></code><span class="koboSpan" id="kobo.1729.1">, or another appropriate file depending on the server process used for system logging on your UNIX machine. </span><span class="koboSpan" id="kobo.1729.2">This means that if a logging facility is not defined correctly, it will not be handled; therefore, the log messages you send to it might get ignored and, therefore, lost.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1730.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1731.1">log</span></code><span class="koboSpan" id="kobo.1732.1"> package sends log messages to standard error. </span><span class="koboSpan" id="kobo.1732.2">Part of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1733.1">log</span></code><span class="koboSpan" id="kobo.1734.1"> package is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1735.1">log/syslog</span></code><span class="koboSpan" id="kobo.1736.1"> package, which allows you to send log messages to the syslog server of your machine. </span><span class="koboSpan" id="kobo.1736.2">Although by default log writes to standard error, the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1737.1">log.SetOutput()</span></code><span class="koboSpan" id="kobo.1738.1"> modifies that behavior. </span><span class="koboSpan" id="kobo.1738.2">The list of functions for sending logging data includes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1739.1">log.Printf()</span></code><span class="koboSpan" id="kobo.1740.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1741.1">log.Print()</span></code><span class="koboSpan" id="kobo.1742.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1743.1">log.Println()</span></code><span class="koboSpan" id="kobo.1744.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1745.1">log.Fatalf()</span></code><span class="koboSpan" id="kobo.1746.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1747.1">log.Fatalln()</span></code><span class="koboSpan" id="kobo.1748.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1749.1">log.Panic()</span></code><span class="koboSpan" id="kobo.1750.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1751.1">log.Panicln()</span></code><span class="koboSpan" id="kobo.1752.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1753.1">log.Panicf()</span></code><span class="koboSpan" id="kobo.1754.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1755.1">Logging is for application code, not library code. </span><span class="koboSpan" id="kobo.1755.2">If you are developing libraries, do not put logging in them.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1756.1">In order to write to system logs, you need to call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1757.1">syslog.New()</span></code><span class="koboSpan" id="kobo.1758.1"> function with the appropriate parameters. </span><span class="koboSpan" id="kobo.1758.2">Writing to the main system log file is as easy as calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.1759.1">syslog.New()</span></code><span class="koboSpan" id="kobo.1760.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1761.1">syslog.LOG_SYSLOG</span></code><span class="koboSpan" id="kobo.1762.1"> option. </span><span class="koboSpan" id="kobo.1762.2">After that, you need to tell your Go program that all logging information goes to the new loggerâ€”this is implemented with a call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1763.1">log.SetOutput()</span></code><span class="koboSpan" id="kobo.1764.1"> function. </span><span class="koboSpan" id="kobo.1764.2">The process is illustrated in the following codeâ€”type it into your favorite plain text editor and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1765.1">systemLog.go</span></code><span class="koboSpan" id="kobo.1766.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1767.1">package</span></span><span class="koboSpan" id="kobo.1768.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1769.1">import</span></span><span class="koboSpan" id="kobo.1770.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1771.1">"log"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1772.1">"log/syslog"</span></span><span class="koboSpan" id="kobo.1773.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1774.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1775.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1776.1">()</span></span><span class="koboSpan" id="kobo.1777.1"> {
    sysLog, err := syslog.New(syslog.LOG_SYSLOG, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1778.1">"systemLog.go"</span></span><span class="koboSpan" id="kobo.1779.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1780.1">if</span></span><span class="koboSpan" id="kobo.1781.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1782.1">nil</span></span><span class="koboSpan" id="kobo.1783.1"> {
        log.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1784.1">return</span></span><span class="koboSpan" id="kobo.1785.1">
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1786.1">else</span></span><span class="koboSpan" id="kobo.1787.1"> {
        log.SetOutput(sysLog)
        log.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1788.1">"Everything is fine!"</span></span><span class="koboSpan" id="kobo.1789.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1790.1">After the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1791.1">log.SetOutput()</span></code><span class="koboSpan" id="kobo.1792.1">, all logging information goes to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1793.1">syslog</span></code><span class="koboSpan" id="kobo.1794.1"> logger variable which </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.1795.1">sends it to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1796.1">syslog.LOG_SYSLOG</span></code><span class="koboSpan" id="kobo.1797.1">. </span><span class="koboSpan" id="kobo.1797.2">Custom text for the log entries coming from that program is specified as the second parameter to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1798.1">syslog.New()</span></code><span class="koboSpan" id="kobo.1799.1"> call.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1800.1">Usually, we want to store logging data in user-defined files because they group relevant information, which makes them easier to process and inspect.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1801.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1802.1">systemLog.go</span></code><span class="koboSpan" id="kobo.1803.1"> generates no output. </span><span class="koboSpan" id="kobo.1803.2">However, if you execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.1804.1">journalctl -xe</span></code><span class="koboSpan" id="kobo.1805.1"> on a Linux machine, you can see entries like the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1806.1">Jun 08 20:46:05 thinkpad systemLog.go[4412]: 2023/06/08 20:46:05 Everything is fine!
</span><span class="koboSpan" id="kobo.1806.2">Jun 08 20:46:51 thinkpad systemLog.go[4822]: 2023/06/08 20:46:51 Everything is fine!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1807.1">The output on your own operating system might be slightly different, but the general idea is the same.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1808.1">Bad things happen all </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.1809.1">the time, even to good people and good software. </span><span class="koboSpan" id="kobo.1809.2">So the next subsection covers the Go way of dealing with bad situations.</span></p>
<h2 class="heading-2" id="_idParaDest-42"><span class="koboSpan" id="kobo.1810.1">log.Fatal() and log.Panic()</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1811.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1812.1">log.Fatal()</span></code><span class="koboSpan" id="kobo.1813.1"> function is </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.1814.1">used when something </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.1815.1">erroneous</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.1816.1"> has</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.1817.1"> happened and you just want to exit your program as soon as possible after reporting that bad situation. </span><span class="koboSpan" id="kobo.1817.2">The call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1818.1">log.Fatal()</span></code><span class="koboSpan" id="kobo.1819.1"> terminates a Go program at the point where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1820.1">log.Fatal()</span></code><span class="koboSpan" id="kobo.1821.1"> was called after printing an error message. </span><span class="koboSpan" id="kobo.1821.2">In most cases, this custom error message can be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1822.1">Not enough arguments</span></code><span class="koboSpan" id="kobo.1823.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1824.1">Cannot access file</span></code><span class="koboSpan" id="kobo.1825.1">, or similar. </span><span class="koboSpan" id="kobo.1825.2">Additionally, it returns a non-zero exit code, which in UNIX indicates an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1826.1">There are situations where a program is about to fail for good and you want to have as much information about the failure as possibleâ€”</span><code class="inlineCode"><span class="koboSpan" id="kobo.1827.1">log.Panic()</span></code><span class="koboSpan" id="kobo.1828.1"> implies that something really unexpected and unknown, such as not being able to find a file that was previously accessed or not having enough disk space, has happened. </span><span class="koboSpan" id="kobo.1828.2">Analogous to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1829.1">log.Fatal()</span></code><span class="koboSpan" id="kobo.1830.1"> function, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1831.1">log.Panic()</span></code><span class="koboSpan" id="kobo.1832.1"> prints a custom message and immediately terminates the Go program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1833.1">Keep in mind that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1834.1">log.Panic()</span></code><span class="koboSpan" id="kobo.1835.1"> is equivalent to a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1836.1">log.Print()</span></code><span class="koboSpan" id="kobo.1837.1">, followed by a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1838.1">panic()</span></code><span class="koboSpan" id="kobo.1839.1">. </span><span class="koboSpan" id="kobo.1839.2">This is a built-in function that stops the execution of the current function and begins panicking. </span><span class="koboSpan" id="kobo.1839.3">After that, it returns to the caller function. </span><span class="koboSpan" id="kobo.1839.4">Conversely, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1840.1">log.Fatal()</span></code><span class="koboSpan" id="kobo.1841.1"> calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.1842.1">log.Print()</span></code><span class="koboSpan" id="kobo.1843.1"> and then </span><code class="inlineCode"><span class="koboSpan" id="kobo.1844.1">os.Exit(1)</span></code><span class="koboSpan" id="kobo.1845.1">, which is an immediate way of terminating the current program. </span><span class="koboSpan" id="kobo.1845.2">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1846.1">log.Fatal()</span></code><span class="koboSpan" id="kobo.1847.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1848.1">log.Panic()</span></code><span class="koboSpan" id="kobo.1849.1"> are illustrated in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1850.1">logs.go</span></code><span class="koboSpan" id="kobo.1851.1"> file, which contains the following Go code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1852.1">package</span></span><span class="koboSpan" id="kobo.1853.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1854.1">import</span></span><span class="koboSpan" id="kobo.1855.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1856.1">"log"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1857.1">"os"</span></span><span class="koboSpan" id="kobo.1858.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1859.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1860.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1861.1">()</span></span><span class="koboSpan" id="kobo.1862.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1863.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1864.1">len</span></span><span class="koboSpan" id="kobo.1865.1">(os.Args) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.1866.1">1</span></span><span class="koboSpan" id="kobo.1867.1"> {
        log.Fatal(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1868.1">"Fatal: Hello World!"</span></span><span class="koboSpan" id="kobo.1869.1">)
    }
    log.Panic(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1870.1">"Panic: Hello World!"</span></span><span class="koboSpan" id="kobo.1871.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1872.1">If you call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1873.1">logs.go</span></code><span class="koboSpan" id="kobo.1874.1"> without any command line arguments, it calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.1875.1">log.Panic()</span></code><span class="koboSpan" id="kobo.1876.1">. </span><span class="koboSpan" id="kobo.1876.2">Otherwise, it calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.1877.1">log.Fatal()</span></code><span class="koboSpan" id="kobo.1878.1">. </span><span class="koboSpan" id="kobo.1878.2">This is illustrated in the following output from an Arch Linux system:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1879.1">$ </span></span><span class="koboSpan" id="kobo.1880.1">go run logs.go
2023/06/08 20:48:42 Panic: Hello World!
</span><span class="koboSpan" id="kobo.1880.2">panic: Panic: Hello World!
</span><span class="koboSpan" id="kobo.1880.3">goroutine 1 [running]:
log.Panic({0xc000104f60?, 0x0?, 0x0?})
    /usr/lib/go/src/log/log.go:384 +0x65
main.main()
    /home/mtsouk/code/mGo4th/ch01/logs.go:12 +0x85
exit status 2
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1881.1">$ </span></span><span class="koboSpan" id="kobo.1882.1">go run logs.go 1
2023/06/08 20:48:59 Fatal: Hello World!
</span><span class="koboSpan" id="kobo.1882.2">exit status 1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1883.1">So the output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1884.1">log.Panic()</span></code><span class="koboSpan" id="kobo.1885.1"> includes additional low-level information that, hopefully, will help you resolve difficult situations that arise in your Go code.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1886.1">Please keep in mind that both of these functions terminate the program abruptly, which </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.1887.1">may not be what the user wants. </span><span class="koboSpan" id="kobo.1887.2">As</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.1888.1"> a result, they are not the best</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.1889.1"> way</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.1890.1"> to end a program. </span><span class="koboSpan" id="kobo.1890.2">However, they can be handy for reporting really bad error conditions or unexpected situations. </span><span class="koboSpan" id="kobo.1890.3">Two such examples are when a program is unable to save its data or when a configuration file is not found.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1891.1">The next subsection is about writing to custom log files.</span></p>
<h2 class="heading-2" id="_idParaDest-43"><span class="koboSpan" id="kobo.1892.1">Writing to a custom log file</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1893.1">Most of the time, and </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.1894.1">especially</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.1895.1"> on applications and services that are deployed to production, you need to write your logging data in a log file of your choice. </span><span class="koboSpan" id="kobo.1895.2">This can be for many reasons, including writing debugging data without messing with the system log files, or keeping your own logging data separate from system logs to transfer it or store it in a database or software, like Elasticsearch. </span><span class="koboSpan" id="kobo.1895.3">This subsection teaches you how to write to a custom log file that is usually application-specific.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1896.1">Writing to files and file input and output are both covered in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1897.1">Chapter 7</span></em><span class="koboSpan" id="kobo.1898.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1899.1">Telling a UNIX System What to Do</span></em><span class="koboSpan" id="kobo.1900.1">â€”however, saving information to files is very handy when troubleshooting and debugging Go code, which is why this is covered in the first chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1901.1">The path of the log file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1902.1">mGo.log</span></code><span class="koboSpan" id="kobo.1903.1">) that is used is stored on a variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1904.1">LOGFILE</span></code><span class="koboSpan" id="kobo.1905.1">â€”this is created using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1906.1">os.TempDir()</span></code><span class="koboSpan" id="kobo.1907.1"> function, which returns the default directory used on the current OS for temporary files, in order to prevent your file system from getting full in case something goes wrong.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1908.1">Additionally, at this point, this will save you from having to execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.1909.1">customLog.go</span></code><span class="koboSpan" id="kobo.1910.1"> with root privileges and putting unnecessary files into precious system directories.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1911.1">Type the </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.1912.1">following</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.1913.1"> code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1914.1">customLog.go</span></code><span class="koboSpan" id="kobo.1915.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1916.1">package</span></span><span class="koboSpan" id="kobo.1917.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1918.1">import</span></span><span class="koboSpan" id="kobo.1919.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1920.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1921.1">"log"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1922.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1923.1">"path"</span></span><span class="koboSpan" id="kobo.1924.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1925.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1926.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1927.1">()</span></span><span class="koboSpan" id="kobo.1928.1"> {
    LOGFILE := path.Join(os.TempDir(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1929.1">"mGo.log"</span></span><span class="koboSpan" id="kobo.1930.1">)
    fmt.Println(LOGFILE)
    f, err := os.OpenFile(LOGFILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1931.1">0644</span></span><span class="koboSpan" id="kobo.1932.1">)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1933.1">// The call to os.OpenFile() creates the log file for writing, </span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1934.1">// if it does not already exist, or opens it for writing </span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1935.1">// by appending new data at the end of it (os.O_APPEND)</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1936.1">if</span></span><span class="koboSpan" id="kobo.1937.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1938.1">nil</span></span><span class="koboSpan" id="kobo.1939.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1940.1">return</span></span><span class="koboSpan" id="kobo.1941.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1942.1">defer</span></span><span class="koboSpan" id="kobo.1943.1"> f.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1944.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1945.1">defer</span></code><span class="koboSpan" id="kobo.1946.1"> keyword tells Go to execute the statement just before the current function returns. </span><span class="koboSpan" id="kobo.1946.2">This means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1947.1">f.Close()</span></code><span class="koboSpan" id="kobo.1948.1"> is going to be executed just before </span><code class="inlineCode"><span class="koboSpan" id="kobo.1949.1">main()</span></code><span class="koboSpan" id="kobo.1950.1"> returns. </span><span class="koboSpan" id="kobo.1950.2">We will go into more detail on </span><code class="inlineCode"><span class="koboSpan" id="kobo.1951.1">defer</span></code><span class="koboSpan" id="kobo.1952.1"> in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1953.1">Chapter 6</span></em><span class="koboSpan" id="kobo.1954.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1955.1">Go Packages and Functions</span></em><span class="koboSpan" id="kobo.1956.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1957.1">    iLog := log.New(f, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1958.1">"iLog "</span></span><span class="koboSpan" id="kobo.1959.1">, log.LstdFlags)
    iLog.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1960.1">"Hello there!"</span></span><span class="koboSpan" id="kobo.1961.1">)
    iLog.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1962.1">"Mastering Go 4th edition!"</span></span><span class="koboSpan" id="kobo.1963.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1964.1">The last three statements create a new log file based on an opened file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1965.1">f</span></code><span class="koboSpan" id="kobo.1966.1">) and write two messages to it, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1967.1">Println()</span></code><span class="koboSpan" id="kobo.1968.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1969.1">If you ever decide to use the code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1970.1">customLog.go</span></code><span class="koboSpan" id="kobo.1971.1"> in a real application, you should change the path stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">LOGFILE</span></code><span class="koboSpan" id="kobo.1973.1"> to something that makes more sense.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1974.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1975.1">customLog.go</span></code><span class="koboSpan" id="kobo.1976.1"> on an Arch Linux machine prints the file path of the log file:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1977.1">$ </span></span><span class="koboSpan" id="kobo.1978.1">go run customLog.go
/tmp/mGo.log
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1979.1">Depending on your operating system, your output might vary. </span><span class="koboSpan" id="kobo.1979.2">However, what is important is what </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.1980.1">has been written in the</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.1981.1"> custom log file:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1982.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1983.1">cat</span></span><span class="koboSpan" id="kobo.1984.1"> /tmp/mGo.</span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1985.1">log</span></span><span class="koboSpan" id="kobo.1986.1">
iLog 2023/11/27 22:15:10 Hello there!
</span><span class="koboSpan" id="kobo.1986.2">iLog 2023/11/27 22:15:10 Mastering Go 4th edition!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1987.1">The next subsection shows how to print line numbers in log entries.</span></p>
<h2 class="heading-2" id="_idParaDest-44"><span class="koboSpan" id="kobo.1988.1">Printing line numbers in log entries</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1989.1">In this subsection, you </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.1990.1">will learn </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.1991.1">how to print the filename as well as the line number in the source file where the statement that wrote a log entry is located.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1992.1">The desired functionality is implemented with the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1993.1">log.Lshortfile</span></code><span class="koboSpan" id="kobo.1994.1"> in the parameters of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1995.1">log.New()</span></code><span class="koboSpan" id="kobo.1996.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1997.1">SetFlags()</span></code><span class="koboSpan" id="kobo.1998.1">. </span><span class="koboSpan" id="kobo.1998.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1999.1">log.Lshortfile</span></code><span class="koboSpan" id="kobo.2000.1"> flag adds the filename as well as the line number of the Go statement that printed the log entry in the log entry itself. </span><span class="koboSpan" id="kobo.2000.2">If you use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2001.1">log.Llongfile</span></code><span class="koboSpan" id="kobo.2002.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2003.1">log.Lshortfile</span></code><span class="koboSpan" id="kobo.2004.1">, then you get the full path of the Go source fileâ€”usually, this is not necessary, especially when you have a really long path.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2005.1">Type the following code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2006.1">customLogLineNumber.go</span></code><span class="koboSpan" id="kobo.2007.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2008.1">package</span></span><span class="koboSpan" id="kobo.2009.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2010.1">import</span></span><span class="koboSpan" id="kobo.2011.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2012.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2013.1">"log"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2014.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2015.1">"path"</span></span><span class="koboSpan" id="kobo.2016.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2017.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2018.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2019.1">()</span></span><span class="koboSpan" id="kobo.2020.1"> {
    LOGFILE := path.Join(os.TempDir(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.2021.1">"mGo.log"</span></span><span class="koboSpan" id="kobo.2022.1">)
    fmt.Println(LOGFILE)
    f, err := os.OpenFile(LOGFILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2023.1">0644</span></span><span class="koboSpan" id="kobo.2024.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2025.1">if</span></span><span class="koboSpan" id="kobo.2026.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2027.1">nil</span></span><span class="koboSpan" id="kobo.2028.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2029.1">return</span></span><span class="koboSpan" id="kobo.2030.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2031.1">defer</span></span><span class="koboSpan" id="kobo.2032.1"> f.Close()
    LstdFlags := log.Ldate | log.Lshortfile
    iLog := log.New(f, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2033.1">"LNum "</span></span><span class="koboSpan" id="kobo.2034.1">, LstdFlags)
    iLog.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2035.1">"Mastering Go, 4th edition!"</span></span><span class="koboSpan" id="kobo.2036.1">)
    iLog.SetFlags(log.Lshortfile | log.LstdFlags)
    iLog.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2037.1">"Another log entry!"</span></span><span class="koboSpan" id="kobo.2038.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2039.1">In case you are wondering, you are allowed to change the format of the log entries during program </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.2040.1">executionâ€”this</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.2041.1"> means that when there is a reason, you can print more analytical information in the log entries. </span><span class="koboSpan" id="kobo.2041.2">This is implemented with multiple calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2042.1">iLog.SetFlags()</span></code><span class="koboSpan" id="kobo.2043.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2044.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2045.1">customLogLineNumber.go</span></code><span class="koboSpan" id="kobo.2046.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2047.1">$ </span></span><span class="koboSpan" id="kobo.2048.1">go run customLogLineNumber.go
/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/mGo.log
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2049.1">It also writes the following entries in the file path that is specified by the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2050.1">LOGFILE</span></code><span class="koboSpan" id="kobo.2051.1"> global variable:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2052.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2053.1">cat</span></span><span class="koboSpan" id="kobo.2054.1"> /var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/mGo.</span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2055.1">log</span></span><span class="koboSpan" id="kobo.2056.1">
LNum 2023/06/08 customLogLineNumber.go:25: Mastering Go, 4th edition!
</span><span class="koboSpan" id="kobo.2056.2">LNum 2023/06/08 20:58:09 customLogLineNumber.go:28: Another log entry!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2057.1">The first error message is from source code line 25, whereas the second one is from source code line 28.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2058.1">You will most</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.2059.1"> likely get a different</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.2060.1"> output on your own machine, which is the expected behavior.</span></p>
<h2 class="heading-2" id="_idParaDest-45"><span class="koboSpan" id="kobo.2061.1">Writing to multiple log files</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2062.1">This subsection</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.2063.1"> shows a technique for </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.2064.1">writing to multiple log filesâ€”this is illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2065.1">multipleLogs.go</span></code><span class="koboSpan" id="kobo.2066.1">, which can be found in the GitHub repository of the book under directory </span><code class="inlineCode"><span class="koboSpan" id="kobo.2067.1">ch01</span></code><span class="koboSpan" id="kobo.2068.1"> and comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2069.1">package</span></span><span class="koboSpan" id="kobo.2070.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2071.1">import</span></span><span class="koboSpan" id="kobo.2072.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2073.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2074.1">"io"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2075.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2076.1">log"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2077.1">"os"</span></span><span class="koboSpan" id="kobo.2078.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2079.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2080.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2081.1">()</span></span><span class="koboSpan" id="kobo.2082.1"> {
    flag := os.O_APPEND | os.O_CREATE | os.O_WRONLY
    file, err := os.OpenFile(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2083.1">"myLog.log"</span></span><span class="koboSpan" id="kobo.2084.1">, flag, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2085.1">0644</span></span><span class="koboSpan" id="kobo.2086.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2087.1">if</span></span><span class="koboSpan" id="kobo.2088.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2089.1">nil</span></span><span class="koboSpan" id="kobo.2090.1"> {
        fmt.Println(err)
        os.Exit(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2091.1">0</span></span><span class="koboSpan" id="kobo.2092.1">)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2093.1">defer</span></span><span class="koboSpan" id="kobo.2094.1"> file.Close()
    w := io.MultiWriter(file, os.Stderr)
    logger := log.New(w, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2095.1">"myApp: "</span></span><span class="koboSpan" id="kobo.2096.1">, log.LstdFlags)
    logger.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2097.1">"BOOK %d"</span></span><span class="koboSpan" id="kobo.2098.1">, os.Getpid())
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2099.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2100.1">io.MultiWriter()</span></code><span class="koboSpan" id="kobo.2101.1"> function is what allows us to write to multiple destinations, which in this case are a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2102.1">myLog.log</span></code><span class="koboSpan" id="kobo.2103.1"> and standard error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2104.1">The results of running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2105.1">multipleLogs.go</span></code><span class="koboSpan" id="kobo.2106.1"> can be seen in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2107.1">myLog.log</span></code><span class="koboSpan" id="kobo.2108.1"> file, which is going to be created in the current working directory, and to standard error, which is usually presented on screen:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2109.1">$ </span></span><span class="koboSpan" id="kobo.2110.1">go run multipleLogs.go
myApp: 2023/06/24 21:02:55 BOOK 71457
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2111.1">The contents </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.2112.1">of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2113.1">myLog.log</span></code><span class="koboSpan" id="kobo.2114.1"> are the same as </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.2115.1">before:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2116.1">$ </span></span><span class="koboSpan" id="kobo.2117.1">at myLog.</span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2118.1">log</span></span><span class="koboSpan" id="kobo.2119.1">
myApp: 2023/06/24 21:02:55 BOOK 71457
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2120.1">In the next section, we are going to write the first version of the statistics application.</span></p>
<h1 class="heading-1" id="_idParaDest-46"><span class="koboSpan" id="kobo.2121.1">Developing a statistics application</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2122.1">In this section, we </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.2123.1">are going to develop a basic statistics application stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2124.1">stats.go</span></code><span class="koboSpan" id="kobo.2125.1">. </span><span class="koboSpan" id="kobo.2125.2">The statistical application is going to be improved and enriched with new features throughout this book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2126.1">The first part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2127.1">stats.go</span></code><span class="koboSpan" id="kobo.2128.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2129.1">package</span></span><span class="koboSpan" id="kobo.2130.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2131.1">import</span></span><span class="koboSpan" id="kobo.2132.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2133.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2134.1">"math"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2135.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2136.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2137.1">strconv"</span></span><span class="koboSpan" id="kobo.2138.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2139.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2140.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2141.1">()</span></span><span class="koboSpan" id="kobo.2142.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2143.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2144.1">len</span></span><span class="koboSpan" id="kobo.2145.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2146.1">1</span></span><span class="koboSpan" id="kobo.2147.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2148.1">"Need one or more arguments!"</span></span><span class="koboSpan" id="kobo.2149.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2150.1">return</span></span><span class="koboSpan" id="kobo.2151.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2152.1">In this first part of the application, the necessary Go packages are imported before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2153.1">main()</span></code><span class="koboSpan" id="kobo.2154.1"> function makes sure that we have at least a single command line parameter to work with, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2155.1">len(arguments) == 1</span></code><span class="koboSpan" id="kobo.2156.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2157.1">The second part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2158.1">stats.go</span></code><span class="koboSpan" id="kobo.2159.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2160.1">var</span></span><span class="koboSpan" id="kobo.2161.1"> min, max </span><span class="hljs-type"><span class="koboSpan" id="kobo.2162.1">float64</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2163.1">var</span></span><span class="koboSpan" id="kobo.2164.1"> initialized = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2165.1">0</span></span><span class="koboSpan" id="kobo.2166.1">
    nValues := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2167.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2168.1">var</span></span><span class="koboSpan" id="kobo.2169.1"> sum </span><span class="hljs-type"><span class="koboSpan" id="kobo.2170.1">float64</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2171.1">for</span></span><span class="koboSpan" id="kobo.2172.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2173.1">1</span></span><span class="koboSpan" id="kobo.2174.1">; i &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2175.1">len</span></span><span class="koboSpan" id="kobo.2176.1">(arguments); i++ {
        n, err := strconv.ParseFloat(arguments[i], </span><span class="hljs-number"><span class="koboSpan" id="kobo.2177.1">64</span></span><span class="koboSpan" id="kobo.2178.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2179.1">if</span></span><span class="koboSpan" id="kobo.2180.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2181.1">nil</span></span><span class="koboSpan" id="kobo.2182.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2183.1">continue</span></span><span class="koboSpan" id="kobo.2184.1">
        }
        nValues = nValues + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2185.1">1</span></span><span class="koboSpan" id="kobo.2186.1">
        sum = sum + n
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2187.1">if</span></span><span class="koboSpan" id="kobo.2188.1"> initialized == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2189.1">0</span></span><span class="koboSpan" id="kobo.2190.1"> {
            min = n
            max = n
            initialized = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2191.1">1</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2192.1">continue</span></span><span class="koboSpan" id="kobo.2193.1">
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2194.1">if</span></span><span class="koboSpan" id="kobo.2195.1"> n &lt; min {
            min = n
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2196.1">if</span></span><span class="koboSpan" id="kobo.2197.1"> n &gt; max {
            max = n
        }
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2198.1">"Number of values:"</span></span><span class="koboSpan" id="kobo.2199.1">, nValues)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2200.1">"Min:"</span></span><span class="koboSpan" id="kobo.2201.1">, min)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2202.1">"Max:"</span></span><span class="koboSpan" id="kobo.2203.1">, max)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2204.1">In the previous code excerpt, we process all valid inputs to count the number of valid values and find the</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.2205.1"> minimum and the maximum values among them. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2206.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2207.1">stats.go</span></code><span class="koboSpan" id="kobo.2208.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2209.1">// Mean value</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2210.1">if</span></span><span class="koboSpan" id="kobo.2211.1"> nValues == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2212.1">0</span></span><span class="koboSpan" id="kobo.2213.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2214.1">return</span></span><span class="koboSpan" id="kobo.2215.1">
    }
meanValue := sum / </span><span class="hljs-type"><span class="koboSpan" id="kobo.2216.1">float64</span></span><span class="koboSpan" id="kobo.2217.1">(nValues)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2218.1">"Mean value: %.5f\n"</span></span><span class="koboSpan" id="kobo.2219.1">, meanValue)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2220.1">// Standard deviation</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2221.1">var</span></span><span class="koboSpan" id="kobo.2222.1"> squared </span><span class="hljs-type"><span class="koboSpan" id="kobo.2223.1">float64</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2224.1">for</span></span><span class="koboSpan" id="kobo.2225.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2226.1">1</span></span><span class="koboSpan" id="kobo.2227.1">; i &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2228.1">len</span></span><span class="koboSpan" id="kobo.2229.1">(arguments); i++ {
        n, err := strconv.ParseFloat(arguments[i], </span><span class="hljs-number"><span class="koboSpan" id="kobo.2230.1">64</span></span><span class="koboSpan" id="kobo.2231.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2232.1">if</span></span><span class="koboSpan" id="kobo.2233.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2234.1">nil</span></span><span class="koboSpan" id="kobo.2235.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2236.1">continue</span></span><span class="koboSpan" id="kobo.2237.1">
        }
        squared = squared + math.Pow((n-meanValue), </span><span class="hljs-number"><span class="koboSpan" id="kobo.2238.1">2</span></span><span class="koboSpan" id="kobo.2239.1">)
    }
    standardDeviation := math.Sqrt(squared / </span><span class="hljs-type"><span class="koboSpan" id="kobo.2240.1">float64</span></span><span class="koboSpan" id="kobo.2241.1">(nValues))
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2242.1">"Standard deviation: %.5f\n"</span></span><span class="koboSpan" id="kobo.2243.1">, standardDeviation)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2244.1">In the previous code excerpt, we find the </span><em class="italic"><span class="koboSpan" id="kobo.2245.1">mean value</span></em><span class="koboSpan" id="kobo.2246.1"> because this cannot be computed without processing all values first. </span><span class="koboSpan" id="kobo.2246.2">After that, we process each valid value to compute the </span><em class="italic"><span class="koboSpan" id="kobo.2247.1">standard deviation</span></em><span class="koboSpan" id="kobo.2248.1"> because the mean value is required in order to compute the standard deviation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2249.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2250.1">stats.go</span></code><span class="koboSpan" id="kobo.2251.1"> generates</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.2252.1"> the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2253.1">$ </span></span><span class="koboSpan" id="kobo.2254.1">go run stats.go 1 2 3
Number of values: 3
Min: 1
Max: 3
Mean value: 2.00000
Standard deviation: 0.81650
</span></code></pre>
<h1 class="heading-1" id="_idParaDest-47"><span class="koboSpan" id="kobo.2255.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2256.1">At the beginning of this chapter, we discussed the advantages, disadvantages, philosophy, and history of Go. </span><span class="koboSpan" id="kobo.2256.2">Then, the basics of Go were presented, which include variables, iterations, and flow control as well as how to log data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2257.1">After that, we learned about logging, implemented </span><code class="inlineCode"><span class="koboSpan" id="kobo.2258.1">which(1)</span></code><span class="koboSpan" id="kobo.2259.1">, and created a basic statistics application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2260.1">The next chapter is all about the basic Go data types.</span></p>
<h1 class="heading-1" id="_idParaDest-48"><span class="koboSpan" id="kobo.2261.1">Exercises</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2262.1">Test out what you have learned by trying to complete the following exercises:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2263.1">Read the documentation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2264.1">fmt</span></code><span class="koboSpan" id="kobo.2265.1"> package using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2266.1">go doc</span></code><span class="koboSpan" id="kobo.2267.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2268.1">In UNIX, an exit code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2269.1">0</span></code><span class="koboSpan" id="kobo.2270.1"> means success, whereas a non-zero exit code usually means failure. </span><span class="koboSpan" id="kobo.2270.2">Try to modify </span><code class="inlineCode"><span class="koboSpan" id="kobo.2271.1">which.go</span></code><span class="koboSpan" id="kobo.2272.1"> to do so with the help of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2273.1">os.Exit()</span></code><span class="koboSpan" id="kobo.2274.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2275.1">The current version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2276.1">which(1)</span></code><span class="koboSpan" id="kobo.2277.1"> stops after finding the first occurrence of the desired executable. </span><span class="koboSpan" id="kobo.2277.2">Make the necessary code changes to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2278.1">which.go</span></code><span class="koboSpan" id="kobo.2279.1"> in order to find all possible occurrences of the desired executable.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-49"><span class="koboSpan" id="kobo.2280.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2281.1">The official Go website: </span><a href="https://go.dev/"><span class="url"><span class="koboSpan" id="kobo.2282.1">https://go.dev/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2283.1">The Go Playground: </span><a href="https://go.dev/play/"><span class="url"><span class="koboSpan" id="kobo.2284.1">https://go.dev/play/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2285.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2286.1">log</span></code><span class="koboSpan" id="kobo.2287.1"> package: </span><a href="https://pkg.go.dev/log"><span class="url"><span class="koboSpan" id="kobo.2288.1">https://pkg.go.dev/log</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2289.1">Elasticsearch Beats: </span><a href="https://www.elastic.co/beats/"><span class="url"><span class="koboSpan" id="kobo.2290.1">https://www.elastic.co/beats/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2291.1">Grafana Loki: </span><a href="https://grafana.com/oss/loki/"><span class="url"><span class="koboSpan" id="kobo.2292.1">https://grafana.com/oss/loki/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2293.1">Standard deviation: </span><a href="https://en.wikipedia.org/wiki/Standard_deviation"><span class="url"><span class="koboSpan" id="kobo.2294.1">https://en.wikipedia.org/wiki/Standard_deviation</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2295.1">Microsoft Visual Studio: </span><a href="https://visualstudio.microsoft.com/"><span class="url"><span class="koboSpan" id="kobo.2296.1">https://visualstudio.microsoft.com/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2297.1">The Standard Go library: </span><a href="https://pkg.go.dev/std"><span class="url"><span class="koboSpan" id="kobo.2298.1">https://pkg.go.dev/std</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2299.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2300.1">godoc</span></code><span class="koboSpan" id="kobo.2301.1"> utility: </span><a href="https://pkg.go.dev/golang.org/x/tools/cmd/godoc"><span class="url"><span class="koboSpan" id="kobo.2302.1">https://pkg.go.dev/golang.org/x/tools/cmd/godoc</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.2303.1">Leave a review!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2304.1">Enjoying this book? </span><span class="koboSpan" id="kobo.2304.2">Help readers like you by leaving an Amazon review. </span><span class="koboSpan" id="kobo.2304.3">Scan the QR code below to get a free eBook of your choice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2305.1"><img alt="" role="presentation" src="../Images/Review_QR_Code.png"/></span></p>
</div>
</body></html>