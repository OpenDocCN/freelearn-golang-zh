["```go\n$ go doc fmt.Printf \n```", "```go\n$ go doc fmt \n```", "```go\n$ ~/go/bin/godoc -http=:8001 \n```", "```go\n$ ~/go/bin/godoc -http :8001 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() {\n    fmt.Println(\"Hello World!\")\n} \n```", "```go\n$ go build hw.go\n$ ./hw\nHello World! \n```", "```go\n$ go run hw.go\nHello World! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() \n{\n    fmt.Println(\"Go has strict rules for curly braces!\")\n} \n```", "```go\n$ go run curly.go\n# command-line-arguments\n./curly.go:7:6: missing function body\n./curly.go:8:1: syntax error: unexpected semicolon or newline before { \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() {\n    fmt.Println(\"Go has strict rules for curly braces!\")\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"math\"\n)\nvar Global int = 1234\nvar AnotherGlobal = -5678\nfunc main() {\n    var j int\n    i := Global + AnotherGlobal\n    fmt.Println(\"Initial j value:\", j)\n    j = Global\n    // math.Abs() requires a float64 parameter\n// so we type cast it appropriately\n    k := math.Abs(float64(AnotherGlobal))\n    fmt.Printf(\"Global=%d, i=%d, j=%d k=%.2f.\\n\", Global, i, j, k)\n} \n```", "```go\nInitial j value: 0\nGlobal=1234, i=-4444, j=1234 k=5678.00. \n```", "```go\nerr := anyFunctionCall()\nif err != nil {\n    // Do something if there is an error\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"strconv\"\n) \n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Println(\"Please provide a command line argument\")\n        return\n    }\n    argument := os.Args[1] \n```", "```go\n // With expression after switch\nswitch argument {\n    case \"0\":\n        fmt.Println(\"Zero!\")\n    case \"1\":\n        fmt.Println(\"One!\")\n    case \"2\", \"3\", \"4\":\n        fmt.Println(\"2 or 3 or 4\")\n        fallthrough\ndefault:\n        fmt.Println(\"Value:\", argument)\n    } \n```", "```go\n value, err := strconv.Atoi(argument)\n    if err != nil {\n        fmt.Println(\"Cannot convert to int:\", argument)\n        return\n    } \n```", "```go\n // No expression after switch\nswitch {\n    case value == 0:\n        fmt.Println(\"Zero!\")\n    case value > 0:\n        fmt.Println(\"Positive integer\")\n    case value < 0:\n        fmt.Println(\"Negative integer\")\n    default:\n        fmt.Println(\"This should not happen:\", value)\n    }\n} \n```", "```go\n$ go run control.go 10\nValue: 10\nPositive integer\n$ go run control.go 0\nZero!\nZero! \n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n    // Traditional for loop\nfor i := 0; i < 10; i++ {\n        fmt.Print(i*i, \" \")\n    }\n    fmt.Println()\n} \n```", "```go\n i := 0\nfor ok := true; ok; ok = (i != 10) {\n        fmt.Print(i*i, \" \")\n        i++\n    }\n    fmt.Println() \n```", "```go\n // For loop used as while loop\n    i = 0\nfor {\n        if i == 10 {\n            break\n        }\n        fmt.Print(i*i, \" \")\n        i++\n    }\n    fmt.Println() \n```", "```go\n // This is a slice but range also works with arrays\n    aSlice := []int{-1, 2, 1, -1, 2, -2}\n    for i, v := range aSlice {\n        fmt.Println(\"index:\", i, \"value: \", v)\n    } \n```", "```go\n$ go run forLoops.go\n0 1 4 9 16 25 36 49 64 81\n0 1 4 9 16 25 36 49 64 81\n0 1 4 9 16 25 36 49 64 81\nindex: 0 value:  -1\nindex: 1 value:  2\nindex: 2 value:  1\nindex: 3 value:  -1\nindex: 4 value:  2\nindex: 5 value:  -2 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() {\n    // Get User Input\n    fmt.Printf(\"Please give me your name: \")\n    var name string\n    fmt.Scanln(&name)\n    fmt.Println(\"Your name is\", name)\n} \n```", "```go\n$ go run input.go\nPlease give me your name: Mihalis\nYour name is Mihalis \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"strconv\"\n) \n```", "```go\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Need one or more arguments!\")\n        return\n    } \n```", "```go\n var min, max float64\nvar initialized = 0\nfor i := 1; i < len(arguments); i++ {\n        n, err := strconv.ParseFloat(arguments[i], 64)\n        if err != nil {\n            continue\n        } \n```", "```go\n if initialized == 0 {\n            min = n\n            max = n\n            initialized = 1\ncontinue\n        } \n```", "```go\n if n < min {\n            min = n\n        }\n        if n > max {\n            max = n\n        }\n    }\n    fmt.Println(\"Min:\", min)\n    fmt.Println(\"Max:\", max)\n} \n```", "```go\n$ go run cla.go a b 2 -1\nMin: -1\nMax: 2 \n```", "```go\n$ go run cla.go a 0 b -1.2 10.32\nMin: -1.2\nMax: 10.32 \n```", "```go\n$ go run cla.go\nNeed one or more arguments! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"strconv\"\n)\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Not enough arguments\")\n        return\n    } \n```", "```go\n var total, nInts, nFloats int\n    invalid := make([]string, 0)\n    for _, k := range arguments[1:] {\n        // Is it an integer?\n        _, err := strconv.Atoi(k)\n        if err == nil {\n            total++\n            nInts++\n            continue\n        } \n```", "```go\n // Is it a float\n        _, err = strconv.ParseFloat(k, 64)\n        if err == nil {\n            total++\n            nFloats++\n            continue\n        } \n```", "```go\n // Then it is invalid\n        invalid = append(invalid, k)\n    } \n```", "```go\n fmt.Println(\"#read:\", total, \"#ints:\", nInts, \"#floats:\", nFloats)\n    if len(invalid) > total {\n        fmt.Println(\"Too much invalid input:\", len(invalid))\n        for _, s := range invalid {\n            fmt.Println(s)\n        }\n    }\n} \n```", "```go\n$ go run process.go 1 2 3\n#read: 3 #ints: 3 #floats: 0 \n```", "```go\n$ go run process.go 1 2.1 a    \n#read: 2 #ints: 1 #floats: 1 \n```", "```go\n$ go run process.go a 1 b\n#read: 1 #ints: 1 #floats: 0\nToo much invalid input: 2\na\nb \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"time\"\n)\nfunc myPrint(start, finish int) {\n    for i := start; i <= finish; i++ {\n        fmt.Print(i, \" \")\n    }\n    fmt.Println()\n    time.Sleep(100 * time.Microsecond)\n}\nfunc main() {\n    for i := 0; i < 4; i++ {\n        go myPrint(i, 5)\n    }\n    time.Sleep(time.Second)\n} \n```", "```go\n$ go run goRoutines.go\n2 3 4 5\n0 4 1 2 3 1 2 3 4 4 5\n5\n3 4 5\n5 \n```", "```go\n1 2 3 4 5 \n4 2 5 3 4 5 \n3 0 1 2 3 4 5 \n4 5 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"path/filepath\"\n) \n```", "```go\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Please provide an argument!\")\n        return\n    }\n    file := arguments[1]\n    path := os.Getenv(\"PATH\")\n    pathSplit := filepath.SplitList(path)\n    for _, directory := range pathSplit { \n```", "```go\n fullPath := filepath.Join(directory, file)\n        // Does it exist?\n        fileInfo, err := os.Stat(fullPath)\n        if err != nil {\n            continue\n        }\n        mode := fileInfo.Mode()\n        // Is it a regular file?\nif !mode.IsRegular() {\n            continue\n        }\n        // Is it executable?\nif mode&0111 != 0 {\n            fmt.Println(fullPath)\n            return\n        }\n    }\n} \n```", "```go\n$ go run which.go which\n/usr/bin/which\n$ go run which.go doesNotExist \n```", "```go\npackage main\nimport (\n    \"log\"\n\"log/syslog\"\n)\nfunc main() {\n    sysLog, err := syslog.New(syslog.LOG_SYSLOG, \"systemLog.go\")\n    if err != nil {\n        log.Println(err)\n        return\n    } else {\n        log.SetOutput(sysLog)\n        log.Print(\"Everything is fine!\")\n    }\n} \n```", "```go\nJun 08 20:46:05 thinkpad systemLog.go[4412]: 2023/06/08 20:46:05 Everything is fine!\nJun 08 20:46:51 thinkpad systemLog.go[4822]: 2023/06/08 20:46:51 Everything is fine! \n```", "```go\npackage main\nimport (\n    \"log\"\n\"os\"\n)\nfunc main() {\n    if len(os.Args) != 1 {\n        log.Fatal(\"Fatal: Hello World!\")\n    }\n    log.Panic(\"Panic: Hello World!\")\n} \n```", "```go\n$ go run logs.go\n2023/06/08 20:48:42 Panic: Hello World!\npanic: Panic: Hello World!\ngoroutine 1 [running]:\nlog.Panic({0xc000104f60?, 0x0?, 0x0?})\n    /usr/lib/go/src/log/log.go:384 +0x65\nmain.main()\n    /home/mtsouk/code/mGo4th/ch01/logs.go:12 +0x85\nexit status 2\n$ go run logs.go 1\n2023/06/08 20:48:59 Fatal: Hello World!\nexit status 1 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"log\"\n\"os\"\n\"path\"\n)\nfunc main() {\n    LOGFILE := path.Join(os.TempDir(), \"mGo.log\")\n    fmt.Println(LOGFILE)\n    f, err := os.OpenFile(LOGFILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n// The call to os.OpenFile() creates the log file for writing, \n// if it does not already exist, or opens it for writing \n// by appending new data at the end of it (os.O_APPEND)\nif err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer f.Close() \n```", "```go\n iLog := log.New(f, \"iLog \", log.LstdFlags)\n    iLog.Println(\"Hello there!\")\n    iLog.Println(\"Mastering Go 4th edition!\")\n} \n```", "```go\n$ go run customLog.go\n/tmp/mGo.log \n```", "```go\n$ cat /tmp/mGo.log\niLog 2023/11/27 22:15:10 Hello there!\niLog 2023/11/27 22:15:10 Mastering Go 4th edition! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"log\"\n\"os\"\n\"path\"\n)\nfunc main() {\n    LOGFILE := path.Join(os.TempDir(), \"mGo.log\")\n    fmt.Println(LOGFILE)\n    f, err := os.OpenFile(LOGFILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer f.Close()\n    LstdFlags := log.Ldate | log.Lshortfile\n    iLog := log.New(f, \"LNum \", LstdFlags)\n    iLog.Println(\"Mastering Go, 4th edition!\")\n    iLog.SetFlags(log.Lshortfile | log.LstdFlags)\n    iLog.Println(\"Another log entry!\")\n} \n```", "```go\n$ go run customLogLineNumber.go\n/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/mGo.log \n```", "```go\n$ cat /var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/mGo.log\nLNum 2023/06/08 customLogLineNumber.go:25: Mastering Go, 4th edition!\nLNum 2023/06/08 20:58:09 customLogLineNumber.go:28: Another log entry! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"io\"\n\"log\"\n\"os\"\n)\nfunc main() {\n    flag := os.O_APPEND | os.O_CREATE | os.O_WRONLY\n    file, err := os.OpenFile(\"myLog.log\", flag, 0644)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(0)\n    }\n    defer file.Close()\n    w := io.MultiWriter(file, os.Stderr)\n    logger := log.New(w, \"myApp: \", log.LstdFlags)\n    logger.Printf(\"BOOK %d\", os.Getpid())\n} \n```", "```go\n$ go run multipleLogs.go\nmyApp: 2023/06/24 21:02:55 BOOK 71457 \n```", "```go\n$ at myLog.log\nmyApp: 2023/06/24 21:02:55 BOOK 71457 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"math\"\n\"os\"\n\"strconv\"\n)\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Need one or more arguments!\")\n        return\n    } \n```", "```go\n var min, max float64\nvar initialized = 0\n    nValues := 0\nvar sum float64\nfor i := 1; i < len(arguments); i++ {\n        n, err := strconv.ParseFloat(arguments[i], 64)\n        if err != nil {\n            continue\n        }\n        nValues = nValues + 1\n        sum = sum + n\n        if initialized == 0 {\n            min = n\n            max = n\n            initialized = 1\ncontinue\n        }\n        if n < min {\n            min = n\n        }\n        if n > max {\n            max = n\n        }\n    }\n    fmt.Println(\"Number of values:\", nValues)\n    fmt.Println(\"Min:\", min)\n    fmt.Println(\"Max:\", max) \n```", "```go\n // Mean value\nif nValues == 0 {\n        return\n    }\nmeanValue := sum / float64(nValues)\n    fmt.Printf(\"Mean value: %.5f\\n\", meanValue)\n    // Standard deviation\nvar squared float64\nfor i := 1; i < len(arguments); i++ {\n        n, err := strconv.ParseFloat(arguments[i], 64)\n        if err != nil {\n            continue\n        }\n        squared = squared + math.Pow((n-meanValue), 2)\n    }\n    standardDeviation := math.Sqrt(squared / float64(nValues))\n    fmt.Printf(\"Standard deviation: %.5f\\n\", standardDeviation)\n} \n```", "```go\n$ go run stats.go 1 2 3\nNumber of values: 3\nMin: 1\nMax: 3\nMean value: 2.00000\nStandard deviation: 0.81650 \n```"]