- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Quick Introduction to Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite its name, this chapter is more than just a quick introduction to Go,
    as it is also going to be the foundation for the rest of the book. The basics
    of Go, some design decisions, and the philosophy of Go are explained in this chapter
    so that you can get the big picture before learning the details of Go. Among other
    things, we present the advantages and disadvantages of Go so that you know when
    to use Go and when to consider other alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, we cover a number of concepts and utilities in
    order to build a solid foundation of Go, before building a simplified version
    of the `which(1)` utility, which is a UNIX utility that locates program files
    by searching the directories of the `PATH` environment variable. Additionally,
    we explain how to write information in log files, as this can help you store error
    messages and warnings while you are developing software in Go.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we develop a basic command line utility that computes
    basic statistical properties. It is that command line utility that we are going
    to improve and expand in the remaining book chapters as we learn more advanced
    Go features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello World!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Go code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you should know about Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the `which(1)` utility in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a statistics application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is an open-source systems programming language, initially developed as an
    internal Google project that went public back in 2009\. The spiritual fathers
    of Go are Robert Griesemer, Ken Thomson, and Rob Pike.
  prefs: []
  type: TYPE_NORMAL
- en: Although the official name of the language is Go, it is sometimes (wrongly)
    referred to as *Golang*. The official reason for this is that [https://go.org/](https://go.org/)
    was not available for registration and [golang.org](https://golang.org) was chosen
    insteadâ€”however, nowadays, the official Go website is [https://go.dev/](https://go.dev/).
    Keep in mind that when you are querying a search engine for Go-related information,
    the word *Go* is usually interpreted as a verb; therefore, you should search for
    *golang* instead. Additionally, the official Twitter hashtag for Go is *#golang*.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now discuss the history of Go and what that means for someone who wants
    to learn Go.
  prefs: []
  type: TYPE_NORMAL
- en: The history of Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, Go started as an internal Google project that went public
    back in 2009\. Griesemer, Thomson, and Pike designed Go as a language for professional
    programmers who want to build reliable, robust, and efficient software that is
    easy to manage. They designed Go with simplicity in mind, even if simplicity meant
    that Go was not going to be a programming language for everyone or everything.
  prefs: []
  type: TYPE_NORMAL
- en: The figure that follows shows the programming languages that directly or indirectly
    influenced Go. As an example, Go syntax looks like C, whereas the package concept
    was inspired by Modula-2.
  prefs: []
  type: TYPE_NORMAL
- en: '![A group of white squares with black text  Description automatically generated
    with low confidence](img/B21003_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The programming languages that influenced Go'
  prefs: []
  type: TYPE_NORMAL
- en: The deliverable was a programming language with tools and a standard library.
    What you get with Go, apart from its syntax and tools, is a rich standard library
    and a type system that tries to save you from easy mistakes, such as implicit
    type conversions, unused variables, and unused packages. The Go compiler catches
    most of these easy mistakes and refuses to compile until you do something about
    them. Additionally, the Go compiler can find difficult-to-catch mistakes such
    as race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to install Go for the first time, you can start by visiting
    [https://go.dev/dl/](https://go.dev/dl/). However, there is a big chance that
    your UNIX variant has a ready-to-install package for the Go programming language,
    so you might want to get Go by using your favorite package manager.
  prefs: []
  type: TYPE_NORMAL
- en: As Go is a portable programming language, almost all presented code is going
    to work fine on any modern Microsoft Windows, Linux, or macOS machine without
    any changes. The only Go code that might need some small or big adjustments is
    the code that deals with the operating system. Most of that code is covered in
    *Chapter 7*, *Telling a UNIX System What to Do*.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go comes with some important advantages for developers, starting with the fact
    that it was designed and is currently maintained by real programmers. Go is also
    easy to learn, especially if you are already familiar with programming languages
    such as C, Python, or Java. On top of that, due to its simplified and elegant
    syntax, Go code is pleasant to the eye, which is great, especially when you are
    programming applications for a living and you have to look at code on a daily
    basis. Go code is also easy to read, which means that you can make changes to
    existing Go code easily, and offers support for Unicode out of the box. Lastly,
    Go has reserved only 25 keywords, which makes it much easier to remember the language.
    Can you do that with C++?
  prefs: []
  type: TYPE_NORMAL
- en: Go also comes with concurrency capabilities, using a simple concurrency model
    that is implemented using *goroutines* and *channels*. Go manages OS threads for
    you and has a powerful runtime that allows you to spawn lightweight units of work
    (goroutines) that communicate with each other using channels.
  prefs: []
  type: TYPE_NORMAL
- en: Although Go comes with a rich standard library, there are really handy Go packages,
    such as `cobra` and `viper`, that allow Go to develop complex command line utilities
    such as `docker` and `hugo`. This is greatly supported by the fact that executable
    binaries are statically linked, which means that once they are generated, they
    do not depend on any shared libraries and include all required information. In
    practice, this means that you can transfer an existing executable file to a different
    machine with the same architecture and be sure that it is going to run without
    any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Due to its simplicity, Go code is predictable and does not have strange side
    effects, and although Go supports pointers, it does not support pointer arithmetic
    like C, unless you use the `unsafe` package, which can be the root of many bugs
    and security holes. Although Go is not an object-oriented programming language,
    Go interfaces are very versatile and allow you to mimic some of the capabilities
    of object-oriented languages, such as polymorphism, encapsulation, and composition.
    However, Go offers no support for classes and inheritance. *Chapter 5*, *Reflection
    and Interfaces*, provides more information on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the latest Go versions offer support for *generics*, which simplifies
    your code when working with multiple data types. You can learn more about Go generics
    in *Chapter 4*, *Go Generics*. Finally, Go is a garbage-collected language, which
    means that no manual memory management is needed.
  prefs: []
  type: TYPE_NORMAL
- en: When to use Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Go is a general-purpose programming language, it is primarily used
    for writing system tools, command line utilities, web services, and software that
    works over networks and the internet. You can use Go for teaching programming,
    and it is a good candidate as your first programming language because of its lack
    of verbosity and clear ideas and principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go can help you develop the following kinds of applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Professional web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking tools and servers such as Kubernetes and Istio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robust UNIX and Windows system tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servers that work with APIs and clients that interact by exchanging data in
    myriad formats, including JSON, XML, and CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket servers and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gRPC (Remote Procedure Call) servers and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex command line utilities with multiple commands, sub-commands, and command
    line parameters, such as `docker` and `hugo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications that exchange data in the JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications that process data from relational databases, NoSQL databases, or
    other popular data storage systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilers and interpreters for your own programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database systems such as CockroachDB and key/value stores such as etcd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although Go is a very practical and competent programming language, it is not
    perfect:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a personal preference rather than an actual technical shortcoming:
    Go has no direct and full support for object-oriented programming, which is a
    popular programming paradigm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although goroutines are lightweight, they are not as powerful as OS threads.
    Depending on the application you are trying to implement, there might exist some
    rare cases where goroutines will not be appropriate for the job. The Apache web
    server creates UNIX processes with `fork(2)` to serve its clientsâ€”Go does not
    support the functionality of `fork(2)`. However, in most cases, designing your
    application with goroutines and channels in mind will solve your problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although garbage collection is fast enough most of the time, and for almost
    all kinds of applications, there are times when you need to handle memory allocation
    manually, such as when developing an operating system or working with large chunks
    of memory and want to avoid fragmentationâ€”Go cannot do that. In practice, this
    means that Go will not allow you to perform any memory management manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go does not offer the full functionality of a functional programming language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go is not good at developing systems with high availability guarantees. In such
    cases, use Erlang or Elixir instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many things that Go does better than other programming languages,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go compiler catches a large set of silly errors that might end up being
    bugs. This includes imported Go packages and variables that are not being used
    in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go uses fewer parentheses than C, C++, or Java, and no semicolons, which makes
    Go source code more human-readable and less error-prone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go comes with a rich and reliable standard library that keeps improving.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go has support for concurrency out of the box through goroutines and channels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goroutines are lightweight. You can easily run thousands of goroutines on any
    modern machine without any performance issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike C, Go considers functions as first-class citizens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go code is backward compatible, which means that newer versions of the Go compiler
    accept programs that were created using a previous version of the language without
    any modifications. This compatibility guarantee is limited to major versions of
    Go. For example, there is no guarantee that a Go 1.x program will compile with
    Go 2.x.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next subsection describes my personal Go journey.
  prefs: []
  type: TYPE_NORMAL
- en: My personal Go journey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, I am going to tell you my personal story of how I ended
    up learning and using Go. I am a UNIX person, which means that I like UNIX and
    prefer to use it whenever possible. I also love C, and I used to like C++; I wrote
    a command line FTP client in C++ for my M.Sc. project. Nowadays, C++ is just a
    huge programming language that is difficult to learn. Although C continues to
    be a decent programming language, it requires lots of code to perform simple tasks
    and suffers from difficult-to-find and correct bugs, due to manual memory management
    and extremely flexible conversion between different data types without any warnings
    or error messages.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, I used to use Perl to write simple command line utilities. However,
    Perl is far from perfect for writing serious command line tools and services,
    as it is a scripting programming language and is not intended for web development.
  prefs: []
  type: TYPE_NORMAL
- en: When I first heard about Go, that it was developed by Google, and that both
    Rob Pike and Ken Thomson were involved in its development, I instantly became
    interested in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, I have used Go to create web services, servers, and clients that
    communicate with RabbitMQ, MySQL, and PostgreSQL, create simple command line utilities,
    implement algorithms for time series data mining, create utilities that generate
    synthetic data, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we are going to move on to actually learn some Go, using *Hello World!*
    as the first example, but before that, we will present the `go doc` command, which
    allows you to find information about the Go standard library, its packages, and
    their functions, as well as the `godoc` utility.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already installed Go, this is the right time to do so. To do
    that, visit [https://go.dev/dl/](https://go.dev/dl/) or use your favorite package
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: The go doc and godoc utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Go distribution comes with a plethora of tools that can make your life as
    a programmer easier. Two of these tools are the `go doc` subcommand and `godoc`
    utility, which allow you to see the documentation of existing Go functions and
    packages without needing an internet connection. However, if you prefer viewing
    the Go documentation online, you can visit [https://pkg.go.dev/](https://pkg.go.dev/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `go doc` command can be executed as a normal command line application that
    displays its output on a terminal, and it is similar to the UNIX `man(1)` command,
    but for Go functions and packages only. So, in order to find out information about
    the `Printf()` function of the `fmt` package, you should execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can find out information about the entire `fmt` package by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As `godoc` is not installed by default, you might need to install it by running
    `go install golang.org/x/tools/cmd/godoc@latest`. The `godoc` binary is going
    to be installed in `~/go/bin`, and you can execute it as `~/go/bin/godoc` unless
    `~/go/bin` is in your `PATH` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `godoc` command line application starts a local web server. So you need
    a web browser to look at the Go documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `godoc` requires executing `godoc` with the `-http` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The numeric value in the preceding command, which in this case is `8001`, is
    the port number that the HTTP server will listen to. As we have omitted the IP
    address, `godoc` is going to listen to all network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose any port number that is available if you have the right privileges.
    However, note that port numbers `0`â€“`1023` are restricted and can only be used
    by the root user, so it is better to avoid choosing one of those and pick something
    else, if it is not already in use by a different process. Port number `8001` is
    usually free and is frequently used for local HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can omit the equals sign in the presented command and put a space character
    in its place. So the following command is completely equivalent to the previous
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After that, you should point your web browser to `http://localhost:8001/` in
    order to get the list of available Go packages and browse their documentation.
    If no `-http` parameter is provided, `godoc` listens to port `6060`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Go for the first time, you will find the Go documentation very
    handy for learning the parameters and the return values of the functions you want
    to use â€” as you progress in your Go journey, you will use the Go documentation
    to learn the gory details of the functions and variables that you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: The next section presents the first Go program of the book and explains the
    basic concepts of Go.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the Go version of the *Hello World!* program. Please type
    it and save it as `hw.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you are eager to execute `hw.go`, type `go run hw.go` in the same directory
    where you save it. The file can also be found in the `ch01` directory of the GitHub
    repository of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Each Go source code begins with a package declaration. In this case, the name
    of the package is `main`, which has a special meaning in Goâ€”autonomous Go programs
    should use the `main` package. The `import` keyword allows you to include functionality
    from existing packages. In our case, we only need some of the functionality of
    the `fmt` package that belongs to the standard Go library, implementing formatted
    input and output with functions that are analogous to Câ€™s `printf()` and `scanf()`.
    The next important thing if you are creating an executable application is a `main()`
    function. Go considers this the entry point to the application, and it begins
    the execution of an application with the code found in the `main()` function of
    the `main` package.
  prefs: []
  type: TYPE_NORMAL
- en: '`hw.go` is a Go program that runs on its own. Two characteristics make `hw.go`
    a source file that can generate an executable binary: the name of the package,
    which should be `main`, and the presence of the `main()` functionâ€”we discuss Go
    functions in more detail in the next subsection, but we will learn even more about
    functions and methods, which are functions attached to specific data types, in
    *Chapter 6*, *Go Packages and Functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each Go function definition begins with the `func` keyword, followed by its
    name, signature, and implementation. Apart from the `main()` function, which has
    a special purpose, you can name the rest of your functions anything you wantâ€”there
    is a global Go rule that also applies to function and variable names and is valid
    for all packages except main: *everything that begins with a lowercase letter
    is considered private and is accessible in the current package only*. We will
    learn more about that rule in *Chapter 6*, *Go Packages and Functions*. The only
    exception to this rule is package names, which can begin with either lowercase
    or uppercase letters. Having said that, I am not aware of a Go package that begins
    with an uppercase letter!'
  prefs: []
  type: TYPE_NORMAL
- en: You might now ask how functions are organized and delivered. Well, the answer
    is in packagesâ€”the next subsection sheds some light on that.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go programs are organized in packagesâ€”even the smallest Go program should be
    delivered as a package. The `package` keyword helps you define the name of a new
    package, which can be anything you want, with just one exception: if you are creating
    an executable application and not just a package that will be shared by other
    applications or packages, you should name your package `main`. You will learn
    more about developing Go packages in *Chapter 6*, *Go Packages and Functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Packages can be used by other packages. In fact, reusing existing packages is
    a good practice that saves you from having to write lots of code or implement
    existing functionality from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `import` keyword is used for importing other Go packages into your Go programs
    to use some or all of their functionality. A Go package can either be a part of
    the rich Standard Go library or come from an external source. Packages of the
    standard Go library are imported by name, for example, `import` `"os"` to use
    the `os` package, whereas external packages like `github.com/spf13/cobra` are
    imported using their full URLs: `import "github.com/spf13/cobra"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Running Go code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You now need to know how to execute `hw.go` or any other Go application. As
    will be explained in the two subsections that follow, there are two ways to execute
    Go code: as a compiled language, using `go build`, or by mimicking a scripting
    language, using `go run`. So let us find out more about these two ways of running
    Go code.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Go code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To compile Go code and create a binary executable file, we need to use the `go
    build` command. What `go build` does is create an executable file for us to distribute
    and execute manually. This means that when using `go build`, an extra step is
    required to run the executable file.
  prefs: []
  type: TYPE_NORMAL
- en: The generated executable is automatically named after the source code filename
    without the `.go` file extension. Therefore, because of the `hw.go` source filename,
    the executable will be called `hw`. If this is not what you want, `go build` supports
    the `-o` option, which allows you to change the filename and the path of the generated
    executable file. As an example, if you want to name the executable file a `helloWorld`,
    you should execute `go build -o helloWorld hw.go` instead. If no source files
    are provided, `go build` looks for a `main` package in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you need to execute the generated executable binary file on your
    own. In our case, this means executing either `hw` or `helloWorld`. This is shown
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to compile Go code, let us continue using Go as if it were
    a scripting language.
  prefs: []
  type: TYPE_NORMAL
- en: Using Go like a scripting language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `go run` command builds the named Go package, which in this case is the
    `main` package implemented in a single file, creates a temporary executable file,
    executes that file, and deletes it once it is doneâ€”to our eyes, this looks like
    using a scripting language while the Go compiler still creates a binary executable.
    In our case, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using `go run` is a better choice when testing code. However, if you want to
    create and distribute an executable binary, then `go build` is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Important formatting and coding rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should know that Go comes with some strict formatting and coding rules that
    help a developer avoid rookie mistakes and bugsâ€”once you learn these few rules
    and Go idiosyncrasies as well as the implications they have on your code, you
    will be free to concentrate on the actual functionality of your code. Additionally,
    the Go compiler is here to help you follow these rules with its expressive error
    messages and warnings. Last, Go offers standard tooling (`gofmt`) that can format
    your code for you, so you never have to think about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of important Go rules that will help you while reading
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Go code is delivered in packages, and you are free to use the functionality
    found in existing packages. There is a Go rule that says that if you import a
    package, you should use it in some way (call a function or use a datatype), or
    the compiler is going to complain. There exist exceptions to this rule that mainly
    have to do with packages that initialize connections with database and TCP/IP
    servers, but they are not important for now. Packages are covered in *Chapter
    6*, *Go Packages and Functions*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You either use a variable or you do not declare it at all. This rule helps you
    avoid errors such as misspelling an existing variable or function name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is only one way to format curly braces in Go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding blocks in Go are embedded in curly braces, even if they contain just
    a single statement or no statements at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go functions can return multiple values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot automatically convert between different data types, even if they
    are of the same kind. As an example, you cannot implicitly convert an integer
    to a floating point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go has more rules, but the preceding ones are the most important and will keep
    you going for most of the book. You are going to see all these rules in action
    in this chapter as well as in other chapters. For now, letâ€™s consider the only
    way to format curly braces in Go because this rule applies everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following Go program named `curly.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it looks just fine, if you try to execute it, you will be disappointed
    because the code will not compile and, therefore, you will get the following syntax
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The official explanation for this error message is that Go requires the use
    of semicolons as statement terminators in many contexts, and the compiler implicitly
    inserts the required semicolons when it thinks that they are necessary. Therefore,
    putting the opening curly brace (`{`) in its own line will make the Go compiler
    insert a semicolon at the end of the previous line (`func main()`), which is the
    main cause of the error message. The correct way to write the previous code is
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After learning about this global rule, let us continue by presenting some important
    characteristics of Go.
  prefs: []
  type: TYPE_NORMAL
- en: What you should know about Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This big section discusses important and essential Go features including variables,
    controlling program flow, iterations, getting user input, and Go concurrency.
    We begin by discussing variables, variable declaration, and variable usage.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and using variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you want to perform basic mathematical calculations. In that case,
    you need to define variables to keep the input, intermediate computations, and
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides multiple ways to declare new variables to make the variable declaration
    process more natural and convenient. You can declare a new variable using the
    `var` keyword, followed by the variable name, followed by the desired data type
    (we are going to cover data types in detail in *Chapter 2*, *Basic Go Data Types*).
    If you want, you can follow that declaration with `=` and an initial value for
    your variable. If there is an initial value given, you can omit the data type
    and the compiler will infer it for you.
  prefs: []
  type: TYPE_NORMAL
- en: '**This brings us to a very important Go rule: if no initial value is given
    to a variable, the Go compiler will automatically initialize that variable to
    the zero value of its data type.**'
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `:=` notation, which can be used instead of a var declaration.
    `:=` defines a new variable by inferring the data of the value that follows it.
    The official name for `:=` is *short assignment statement*, and it is very frequently
    used in Go, especially for getting the return values from functions and `for`
    loops with the `range` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The short assignment statement can be used in place of a `var` declaration with
    an implicit type. You rarely see the use of `var` in Go; the `var` keyword is
    mostly used for declaring global or local variables without an initial value.
    The reason for the former is that every statement that exists outside of the code
    of a function must begin with a keyword, such as `func` or `var`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the short assignment statement cannot be used outside of a function
    environment because it is not permitted there. Last, you might need to use `var`
    when you want to be explicit about the data type. For example, when you want the
    type of a variable to be `int8` or `int32` instead of `int`, which is the default.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are values, such as the mathematical constant Pi, that cannot change.
    In that case, we can declare such values as constants using `const`. Constants
    are declared just like variables but cannot change once they have been declared.
  prefs: []
  type: TYPE_NORMAL
- en: The supported data types for constants are character, string, Boolean, and all
    numeric data types. Thereâ€™s more about Go data types in *Chapter 2*, *Basic Go
    Data Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Global variables are variables that are defined outside of a function implementation.
    *Global variables* can be accessed from anywhere in a package without the need
    to explicitly pass them to a function, and they can be changed unless they were
    defined as constants, using the `const` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can declare local variables using either `var` or `:=`, only `const`
    (when the value of a variable is not going to change) and `var` work for global
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Printing variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs tend to display information, which means that they need to print data
    or send it somewhere for other software to store or process it. To print data
    on the screen, Go uses the functionality of the `fmt` package. If you want Go
    to take care of the printing, then you might want to use the `fmt.Println()` function.
    However, there are times when you want to have full control over how data is going
    to be printed. In such cases, you might want to use `fmt.Printf()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`fmt.Printf()` is similar to the C `printf()` function and requires the use
    of control sequences that specify the data type of the variable that is going
    to be printed. Additionally, the `fmt.Printf()` function allows you to format
    the generated output, which is particularly convenient for floating point values
    because it allows you to specify the digits that will be displayed in the output
    (`%.2f` displays two digits after the decimal point of a floating point value).
    Lastly, the `\n` character is used for printing a newline character and, therefore,
    creating a new line, as `fmt.Printf()` does not automatically insert a newlineâ€”this
    is not the case with `fmt.Println()`, which automatically inserts a newline, hence
    the `ln` at the end of its name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program illustrates how you can declare new variables, how to
    use them, and how to print themâ€”type the following code into a plain text file
    named `variables.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I prefer to make global variables stand out by either beginning
    them with an uppercase letter or using all capital letters. As you are going to
    learn in *Chapter 6*, *Go Packages and Functions*, the case of the first character
    of a variable name has a special meaning in Go and changes its visibility. So
    this works for the `main` package only.
  prefs: []
  type: TYPE_NORMAL
- en: 'This above program contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A global `int` variable named `Global`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second global variable named `AnotherGlobal`â€”Go automatically infers its data
    type from its value, which in this case is an integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local variable named `j` of type `int`, which, as you will learn in the next
    chapter, is a special data type. `j` does not have an initial value, which means
    that Go automatically assigns the zero value of its data type, which in this case
    is `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another local variable named `i`â€”Go infers its data type from its value. As
    it is the sum of two `int` values, it is also an `int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As `math.Abs()` requires a `float64` parameter, you cannot pass `AnotherGlobal`
    to it because `AnotherGlobal` is an `int` variable. The `float64()` **type cast**
    converts the value of `AnotherGlobal` to `float64`. Note that `AnotherGlobal`
    continues to have the `int` data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, `fmt.Printf()` formats and prints the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running `variables.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrated another important Go rule that was also mentioned
    previously: **Go does not allow implicit data conversions like C**. As presented
    in `variables.go`, the `math.Abs()` function that expects (requires) a `float64`
    value cannot work with an `int` value, even if this particular conversion is straightforward
    and error-free. The Go compiler refuses to compile such statements. You should
    convert the `int` value to a `float64` explicitly using `float64()` for things
    to work properly.'
  prefs: []
  type: TYPE_NORMAL
- en: For conversions that are not straightforward (for example, `string` to `int`),
    there exist specialized functions that allow you to catch issues with the conversion,
    in the form of an `error` variable that is returned by the function.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling program flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen Go variables, but how do we change the flow of a Go program
    based on the value of a variable or some other condition? Go supports the `if/else`
    and `switch` control structures. Both control structures can be found in most
    modern programming languages, so if you have already programmed in another programming
    language, you should already be familiar with both `if` and `switch` statements.
    `if` statements use no parenthesis to embed the conditions that need to be examined
    because Go does not use parentheses in general. As expected, `if` has support
    for `else` and `else if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the use of `if`, let us use a very common pattern in Go that
    is used almost everywhere. This pattern says that if the value of an error variable
    as returned from a function is `nil`, then everything is OK with the function
    execution. Otherwise, there is an error condition somewhere that needs special
    care. This pattern is usually implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`err` is the variable that holds the error value as returned from a function
    and `!=` means that the value of the err variable is not equal to `nil`. You will
    see similar code multiple times in Go programs.'
  prefs: []
  type: TYPE_NORMAL
- en: Lines beginning with `//` are single-line comments. If you put `//` in the middle
    of a line, then everything after `//` until the end of the line is considered
    a comment. This rule does not apply if `//` is inside a string value.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` statement has two different forms. In the first form, the `switch`
    statement has an expression that is evaluated, whereas in the second form, the
    `switch` statement has no expression to evaluate. In that case, expressions are
    evaluated in each `case` statement, which increases the flexibility of `switch`.
    The main benefit you get from `switch` is that when used properly, it simplifies
    complex and hard-to-read `if-else` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `if` and `switch` are illustrated in the following code, which is designed
    to process user input given as command line argumentsâ€”please type it and save
    it as `control.go`. For learning purposes, we present the code of `control.go`
    in pieces in order to explain it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This first part contains the expected preamble with the imported packages.
    The implementation of the `main()` function starts next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This part of the program makes sure that you have a single command line argument
    to process, which is accessed as `os.Args[1]`, before continuing. We will cover
    this in more detail later, but you can refer to *Figure 1.2* for more information
    about the `os.Args` slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you see a switch block with four branches. The first three require exact
    string matches and the last one matches everything else. The order of the case
    statements is important because only the first match is executed. The `fallthrough`
    keyword tells Go that after this branch is executed, it will continue with the
    next branch, which in this case is the default branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As command line arguments are initialized as string values, we need to convert
    user input into an integer value using a separate call, which in this case is
    a call to `strconv.Atoi()`. If the value of the `err` variable is `nil`, then
    the conversion was successful, and we can continue. Otherwise, an error message
    is printed onscreen and the program exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the second form of `switch`, where the condition is
    evaluated at each case branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This gives you more flexibility but requires more thinking when reading the
    code. In this case, the default branch should not be executed, mainly because
    any valid integer value would be caught by the other three branches. Nevertheless,
    the default branch is there, which is good practice because it can catch unexpected
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `control.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Each one of the two switch blocks in `control.go` creates one line of output.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating with for loops and range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is all about iterating in Go. Go supports `for` loops as well as
    the `range` keyword to iterate over all the elements of arrays, slices, and (as
    you will see in *Chapter 3*, *Composite Data Types*) maps, without knowing the
    size of the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: An example of Go simplicity is the fact that Go provides support for the `for`
    keyword only, instead of including direct support for `while` loops. However,
    depending on how you write a `for` loop, it can function as a `while` loop or
    an infinite loop. Moreover, `for` loops can implement the functionality of JavaScriptâ€™s
    `forEach` function when combined with the `range` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: You need to put curly braces around a `for` loop even if it contains just a
    single statement or no statements at all.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create `for` loops with variables and conditions. A `for` loop
    can be exited with a `break` keyword, and you can skip the current iteration with
    the `continue` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program illustrates the use of `for` on its own and with the
    `range` keywordâ€”type it and save it as `forLoops.go` to execute it afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous code illustrates a traditional `for` loop that uses a local variable
    named `i`. This prints the squares of `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`,
    `8`, and `9` onscreen. The square of `10` is not computed and printed because
    it does not satisfy the `10 < 10` condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is idiomatic Go and produces the same output as the previous
    `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You might use it, but it is sometimes hard to read, especially for people who
    are new to Go. The following code shows how a `for` loop can simulate a `while`
    loop, which is not supported directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `break` keyword in the `if` condition exits the loop early and acts as the
    loop exit condition. Without an exit condition that is going to be met at some
    point and the `break` keyword, the `for` loop is never going to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, given a slice, which you can consider as a resizable array, named `aSlice`,
    you iterate over all its elements with the help of `range`, which returns two
    ordered values: **the index of the current element in the slice and its value**.
    If you want to ignore either of these return values, which is not the case here,
    you can use `_` in the place of the value that you want to ignore. If you just
    need the index, you can leave out the second value from `range` entirely without
    using `_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run `forLoops.go`, you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The previous output illustrates that the first three `for` loops are equivalent
    and, therefore, produce the same output. The last six lines show the index and
    the value of each element found in `aSlice`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about `for` loops, let us see how to get user input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting user input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting user input is an important part of the majority of programs. This section
    presents two ways of getting user input, which read from standard input and use
    the command line arguments of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from standard input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fmt.Scanln()` function can help you read user input while the program is
    already running and store it to a string variable, which is passed as a pointer
    to `fmt.Scanln()`. The `fmt` package contains additional functions for reading
    user input from the console (`os.Stdin`), files, or argument lists.
  prefs: []
  type: TYPE_NORMAL
- en: The `fmt.Scanln()` function is rarely used to get user input. Usually, user
    input is read from command line arguments or external files. However, interactive
    command line applications need `fmt.Scanln()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code illustrates reading from standard inputâ€”type it and save
    it as `input.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While waiting for user input, it is good to let the user know what kind of information
    they have to give, which is the purpose of the `fmt.Printf()` call. The reason
    for not using `fmt.Println()` instead is that `fmt.Println()` automatically appends
    a newline character at the end of the output, which is not what we want here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `input.go` generates the following kind of output and user interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Working with command line arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although typing user input when needed might look like a nice idea, this is
    not usually how real software works. Usually, user input is given in the form
    of command line arguments to the executable file. By default, command line arguments
    in Go are stored in the `os.Args` slice.
  prefs: []
  type: TYPE_NORMAL
- en: The standard Go library also offers the `flag` package for parsing command line
    arguments, but there are better and more powerful alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The figure that follows shows the way command line arguments work in Go, which
    is the same as in the C programming language. It is important to know that the
    `os.Args` slice is **properly initialized by Go and is available to the program
    when referenced**. The `os.Args` slice contains `string` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, black  Description automatically
    generated](img/B21003_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: How the os.Args slice works'
  prefs: []
  type: TYPE_NORMAL
- en: The first command line argument stored in the `os.Args` slice is always the
    file path of the executable. If you use `go run`, you will get a temporary name
    and path; otherwise, it will be the path of the executable as given by the user.
    The remaining command line arguments are what come after the name of the executableâ€”the
    various command line arguments are automatically separated by space characters
    unless they are included in double or single quotes; this depends on the OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `os.Args` is illustrated in the code that follows, which is to find
    the minimum and the maximum numeric values of its input while ignoring invalid
    input, such as characters and strings. Type the code and save it as `cla.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, `cla.go` begins with its preamble. The `fmt` package is used for
    printing output, whereas the `os` package is required because `os.Args` is a part
    of it. Lastly, the `strconv` package contains functions for converting strings
    to numeric values. Next, we make sure that we have at least one command line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the first element in `os.Args` is always the path of the executable
    file, so `os.Args` is never totally empty. Next, the program checks for errors
    in the same way we looked for them in previous examples. You will learn more about
    errors and error handling in *Chapter 2*, *Basic Go Data Types*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we use the `error` variable returned by `strconv.ParseFloat()`
    to make sure that the call to `strconv.ParseFloat()` was successful and there
    is a valid numeric value to process. Otherwise, we should continue to the next
    command line argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop is used to iterate over all available command line arguments
    except the first one, which uses an index value of `0`. This is another popular
    technique for working with all command line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to properly initialize the value of the `min` and
    `max` variables after the first valid command line argument is processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are using `initialized == 0` to test whether this is the first valid command
    line argument. If this is the case, we process the first command line argument
    and initialize the `min` and `max` variables to its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code checks whether the current value is our new minimum or maximumâ€”this
    is where the logic of the program is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the program is about printing your findings, which are the
    minimum and maximum numeric values of all valid command line arguments. The output
    you get from `cla.go` depends on its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `a` and `b` are invalid, and the only valid inputs are `-1` and
    `2`, which are the minimum value and maximum value, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `a` and `b` are invalid input and, therefore, ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the final case, as `cla.go` has no input to process, it prints a help message.
    If you execute the program with no valid input values, for example, `go run cla.go
    a b c`, then the values of both `Min` and `Max` are going to be zero.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection shows a technique for differentiating between different
    data types, using error variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using error variables to differentiate between input types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let me show you a technique that uses error variables to differentiate
    between various kinds of user input. For this technique to work, you should go
    from more specific cases to more generic ones. If we are talking about numeric
    values, you should first examine whether a string is a valid integer before examining
    whether the same string is a floating-point value, because every valid integer
    is also a valid floating-point value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program, which is saved as `process.go`, is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The previous code contains the preamble and the storing of the command line
    arguments in the `arguments` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part is where we start examining the validity of the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, we create three variables for keeping a count of the total number of
    valid values examined, the total number of integer values found, and the total
    number of floating-point values found, respectively. The `invalid` variable, which
    is a slice of strings, is used for keeping all non-numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we need to iterate over all the command line arguments except the
    first one, which has an index value of `0`, because this is the path of the executable
    file. We ignore the path of the executable, using `arguments[1:]` instead of just
    `arguments`â€”selecting a continuous part of a slice is discussed in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `strconv.Atoi()` determines whether we are processing a valid `int`
    value or not. If so, we increase the `total` and `nInts` counters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if the examined string represents a valid floating-point value,
    the call to `strconv.ParseFloat()` is going to be successful, and the program
    will update the relevant counters. Lastly, if a value is not numeric, it is appended
    to the `invalid` slice with a call to `append()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Presented here is extra code that warns you when your invalid input is more
    than the valid one (`len(invalid) > total`). This is a common practice for keeping
    unexpected input in applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `process.go` produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we process 1, 2, and 3, which are all valid integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have a valid integer, 1, a floating-point value, 2.1, and
    an invalid value, a:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If the invalid input is more than the valid one, then `process.go` prints an
    extra error message.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection discusses the concurrency model of Go.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Go concurrency model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is a quick introduction to the Go concurrency model. The Go concurrency
    model is implemented using *goroutines* and *channels*. A goroutine is the smallest
    executable Go entity. To create a new goroutine, you have to use the `go` keyword
    followed by a predefined function or an anonymous functionâ€”both these methods
    are equivalent as far as Go is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: The `go` keyword works with functions or anonymous functions only.
  prefs: []
  type: TYPE_NORMAL
- en: A channel in Go is a mechanism that, among other things, allows goroutines to
    communicate and exchange data. If you are an amateur programmer or are hearing
    about goroutines and channels for the first time, do not panic. Goroutines and
    channels, as well as pipelines and sharing data among goroutines, will be explained
    in much more detail in *Chapter 8*, *Go Concurrency*.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is easy to create goroutines, there are other difficulties when
    dealing with concurrent programming, including goroutine synchronization and sharing
    data between goroutinesâ€”this is a Go mechanism for avoiding side effects by using
    global state when running goroutines. As `main()` runs as a goroutine as well,
    you do not want `main()` to finish before the other goroutines of the program
    because once `main()` exits, the entire program along with any goroutines that
    have not finished yet will terminate. Although goroutines cannot communicate directly
    with each other, they can share memory. The good thing is that there are various
    techniques for the `main()` function to wait for goroutines to exchange data through
    channels or, less frequently in Go, use shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following Go program, which synchronizes goroutines using `time.Sleep()`
    calls (this is not the right way to synchronize goroutinesâ€”we will discuss the
    proper way to synchronize goroutines in *Chapter 8*, *Go Concurrency*), into your
    favorite editor, and save it as `goRoutines.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding naively implemented example creates four goroutines and prints
    some values on the screen using the `myPrint()` functionâ€”the `go` keyword is used
    for creating the goroutines. Running `goRoutines.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you run it multiple times, you will most likely get a different
    output each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This happens because **goroutines are initialized in a random order and start
    running in a random order**. The Go scheduler is responsible for the execution
    of goroutines, just like the OS scheduler is responsible for the execution of
    the OS threads. *Chapter 8*, *Go Concurrency*, discusses Go concurrency in more
    detail and presents the solution to that randomness issue with the use of a `sync.WaitGroup`
    variableâ€”however, keep in mind that Go concurrency is everywhere, which is the
    main reason for including this section here. Therefore, as some error messages
    generated by the compiler discuss goroutines, you should not think that these
    goroutines were created by you.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows a practical example that involves developing a Go version
    of the `which(1)` utility, which searches for an executable file in the `PATH`
    environment value of the current user.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the which(1) utility in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go can work with your operating system through a set of packages. A good way
    of learning a new programming language is by trying to implement simple versions
    of traditional UNIX utilitiesâ€”in general, the only efficient way to learn a programming
    language is by writing lots of code in that language. In this section, you will
    see a Go version of the `which(1)` utility, which will help you understand the
    way Go interacts with the underlying OS and reads environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: The presented code, which will implement the functionality of `which(1)`, can
    be divided into three logical parts. The first part is about reading the input
    argument, which is the name of the executable file that the utility will be searching
    for. The second part is about reading the value stored in the `PATH` environment
    variable, splitting it, and iterating over the directories of the `PATH` variable.
    The third part is about looking for the desired binary file in these directories
    and determining whether it can be found or not, whether it is a regular file,
    and whether it is an executable file. If the desired executable file is found,
    the program terminates with the help of the `return` statement. Otherwise, it
    will terminate after the `for` loop ends and the `main()` function exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presented source file is called `which.go` and is located under the `ch01`
    directory of the GitHub repository of the book. Now, let us see the code, beginning
    with the logical preamble that usually includes the package name, the `import`
    statements, and other definitions with a global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `fmt` package is used for printing onscreen, the `os` package is for interacting
    with the underlying operating system, and the `path/filepath` package is used
    for working with the contents of the `PATH` variable that is read as a long string,
    depending on the number of directories it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second logical part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, we read the command line arguments of the program (`os.Args`) and save
    the first command line argument into the `file` variable. Then, we get the contents
    of the `PATH` environment variable and split it using `filepath.SplitList()`,
    which offers a portable way of separating a list of paths. Lastly, we iterate
    over all the directories of the `PATH` variable using a `for` loop with `range`,
    as `filepath.SplitList()` returns a slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the utility contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We construct the full path that we examine using `filepath.Join()`, which is
    used for concatenating the different parts of a path using an OS-specific separatorâ€”this
    makes `filepath.Join()` work on all supported operating systems. In this part,
    we also get some lower-level information about the fileâ€”keep in mind that UNIX
    considers everything as a file, which means that we want to make sure that we
    are dealing with a regular file that is also executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `which.go` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The last command could not find the `doesNotExist` executableâ€”according to the
    UNIX philosophy and the way UNIX pipes work, utilities generate no output onscreen
    if they have nothing to say.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is useful to print error messages onscreen, there are times that
    you need to keep all error messages together and be able to search for them later
    when it is convenient for you. In this case, you need to use one or more log files.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses logging in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Logging information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All UNIX systems have their own log files for writing logging information that
    comes from running servers and programs. Usually, most system log files of a UNIX
    system can be found under the `/var/log` directory. However, the log files of
    many popular services, such as Apache and Nginx, can be found elsewhere, depending
    on their configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Logging and storing logging information in log files is a practical way of examining
    data and information from your software asynchronously, either locally, at a central
    log server, or using server software such as Elasticsearch, Beats, and Grafana
    Loki.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, using a log file to write some information used to be considered
    a better practice than writing the same output on screen for two reasons. Firstly,
    because the output does not get lost, as it is stored on a file, and secondly,
    because you can search and process log files using UNIX tools, such as `grep(1)`,
    `awk(1)`, and `sed(1)`, which cannot be done when messages are printed in a terminal
    window. However, writing to log files is not always the best approach, mainly
    because many services run as Docker images, which have their own log files that
    get lost when the Docker image stops.
  prefs: []
  type: TYPE_NORMAL
- en: As we usually run our services via `systemd`, programs should log to `stdout`
    so that `systemd` can put logging data in the journal. [https://12factor.net/logs](https://12factor.net/logs)
    offers more information about app logs. Additionally, in cloud-native applications,
    we are encouraged to simply log to `stderr` and let the container system redirect
    the `stderr` stream to the desired destination.
  prefs: []
  type: TYPE_NORMAL
- en: The UNIX logging service has support for two properties named *logging level*
    and *logging facility*. The logging level is a value that specifies the severity
    of the log entry. There are various logging levels, including `debug`, `info`,
    `notice`, `warning`, `err`, `crit`, `alert`, and `emerg`, in reverse order of
    severity. The `log` package of the standard Go library does not support working
    with logging levels. The logging facility is like a category used for logging
    information. The value of the logging facility part can be one of `auth`, `authpriv`,
    `cron`, `daemon`, `kern`, `lpr`, `mail`, `mark`, `news`, `syslog`, `user`, `UUCP`,
    `local0`, `local1`, `local2`, `local3`, `local4`, `local5`, `local6`, or `local7`
    and is defined inside `/etc/syslog.conf`, `/etc/rsyslog.conf`, or another appropriate
    file depending on the server process used for system logging on your UNIX machine.
    This means that if a logging facility is not defined correctly, it will not be
    handled; therefore, the log messages you send to it might get ignored and, therefore,
    lost.
  prefs: []
  type: TYPE_NORMAL
- en: The `log` package sends log messages to standard error. Part of the `log` package
    is the `log/syslog` package, which allows you to send log messages to the syslog
    server of your machine. Although by default log writes to standard error, the
    use of `log.SetOutput()` modifies that behavior. The list of functions for sending
    logging data includes `log.Printf()`, `log.Print()`, `log.Println()`, `log.Fatalf()`,
    `log.Fatalln()`, `log.Panic()`, `log.Panicln()`, and `log.Panicf()`.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is for application code, not library code. If you are developing libraries,
    do not put logging in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write to system logs, you need to call the `syslog.New()` function
    with the appropriate parameters. Writing to the main system log file is as easy
    as calling `syslog.New()` with the `syslog.LOG_SYSLOG` option. After that, you
    need to tell your Go program that all logging information goes to the new loggerâ€”this
    is implemented with a call to the `log.SetOutput()` function. The process is illustrated
    in the following codeâ€”type it into your favorite plain text editor and save it
    as `systemLog.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After the call to `log.SetOutput()`, all logging information goes to the `syslog`
    logger variable which sends it to `syslog.LOG_SYSLOG`. Custom text for the log
    entries coming from that program is specified as the second parameter to the `syslog.New()`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we want to store logging data in user-defined files because they group
    relevant information, which makes them easier to process and inspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `systemLog.go` generates no output. However, if you execute `journalctl
    -xe` on a Linux machine, you can see entries like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The output on your own operating system might be slightly different, but the
    general idea is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Bad things happen all the time, even to good people and good software. So the
    next subsection covers the Go way of dealing with bad situations.
  prefs: []
  type: TYPE_NORMAL
- en: log.Fatal() and log.Panic()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `log.Fatal()` function is used when something erroneous has happened and
    you just want to exit your program as soon as possible after reporting that bad
    situation. The call to `log.Fatal()` terminates a Go program at the point where
    `log.Fatal()` was called after printing an error message. In most cases, this
    custom error message can be `Not enough arguments`, `Cannot access file`, or similar.
    Additionally, it returns a non-zero exit code, which in UNIX indicates an error.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations where a program is about to fail for good and you want
    to have as much information about the failure as possibleâ€”`log.Panic()` implies
    that something really unexpected and unknown, such as not being able to find a
    file that was previously accessed or not having enough disk space, has happened.
    Analogous to the `log.Fatal()` function, `log.Panic()` prints a custom message
    and immediately terminates the Go program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that `log.Panic()` is equivalent to a call to `log.Print()`, followed
    by a call to `panic()`. This is a built-in function that stops the execution of
    the current function and begins panicking. After that, it returns to the caller
    function. Conversely, `log.Fatal()` calls `log.Print()` and then `os.Exit(1)`,
    which is an immediate way of terminating the current program. Both `log.Fatal()`
    and `log.Panic()` are illustrated in the `logs.go` file, which contains the following
    Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call `logs.go` without any command line arguments, it calls `log.Panic()`.
    Otherwise, it calls `log.Fatal()`. This is illustrated in the following output
    from an Arch Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: So the output of `log.Panic()` includes additional low-level information that,
    hopefully, will help you resolve difficult situations that arise in your Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Please keep in mind that both of these functions terminate the program abruptly,
    which may not be what the user wants. As a result, they are not the best way to
    end a program. However, they can be handy for reporting really bad error conditions
    or unexpected situations. Two such examples are when a program is unable to save
    its data or when a configuration file is not found.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection is about writing to custom log files.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a custom log file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time, and especially on applications and services that are deployed
    to production, you need to write your logging data in a log file of your choice.
    This can be for many reasons, including writing debugging data without messing
    with the system log files, or keeping your own logging data separate from system
    logs to transfer it or store it in a database or software, like Elasticsearch.
    This subsection teaches you how to write to a custom log file that is usually
    application-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to files and file input and output are both covered in *Chapter 7*,
    *Telling a UNIX System What to Do*â€”however, saving information to files is very
    handy when troubleshooting and debugging Go code, which is why this is covered
    in the first chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The path of the log file (`mGo.log`) that is used is stored on a variable named
    `LOGFILE`â€”this is created using the `os.TempDir()` function, which returns the
    default directory used on the current OS for temporary files, in order to prevent
    your file system from getting full in case something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, at this point, this will save you from having to execute `customLog.go`
    with root privileges and putting unnecessary files into precious system directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code and save it as `customLog.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `defer` keyword tells Go to execute the statement just before the current
    function returns. This means that `f.Close()` is going to be executed just before
    `main()` returns. We will go into more detail on `defer` in *Chapter 6*, *Go Packages
    and Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The last three statements create a new log file based on an opened file (`f`)
    and write two messages to it, using `Println()`.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever decide to use the code of `customLog.go` in a real application,
    you should change the path stored in `LOGFILE` to something that makes more sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `customLog.go` on an Arch Linux machine prints the file path of the
    log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your operating system, your output might vary. However, what is
    important is what has been written in the custom log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection shows how to print line numbers in log entries.
  prefs: []
  type: TYPE_NORMAL
- en: Printing line numbers in log entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you will learn how to print the filename as well as the
    line number in the source file where the statement that wrote a log entry is located.
  prefs: []
  type: TYPE_NORMAL
- en: The desired functionality is implemented with the use of `log.Lshortfile` in
    the parameters of `log.New()` or `SetFlags()`. The `log.Lshortfile` flag adds
    the filename as well as the line number of the Go statement that printed the log
    entry in the log entry itself. If you use `log.Llongfile` instead of `log.Lshortfile`,
    then you get the full path of the Go source fileâ€”usually, this is not necessary,
    especially when you have a really long path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code and save it as `customLogLineNumber.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In case you are wondering, you are allowed to change the format of the log entries
    during program executionâ€”this means that when there is a reason, you can print
    more analytical information in the log entries. This is implemented with multiple
    calls to `iLog.SetFlags()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `customLogLineNumber.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'It also writes the following entries in the file path that is specified by
    the value of the `LOGFILE` global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The first error message is from source code line 25, whereas the second one
    is from source code line 28.
  prefs: []
  type: TYPE_NORMAL
- en: You will most likely get a different output on your own machine, which is the
    expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to multiple log files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection shows a technique for writing to multiple log filesâ€”this is
    illustrated in `multipleLogs.go`, which can be found in the GitHub repository
    of the book under directory `ch01` and comes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `io.MultiWriter()` function is what allows us to write to multiple destinations,
    which in this case are a file named `myLog.log` and standard error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of running `multipleLogs.go` can be seen in the `myLog.log` file,
    which is going to be created in the current working directory, and to standard
    error, which is usually presented on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of `myLog.log` are the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we are going to write the first version of the statistics
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a statistics application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to develop a basic statistics application stored
    in `stats.go`. The statistical application is going to be improved and enriched
    with new features throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `stats.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this first part of the application, the necessary Go packages are imported
    before the `main()` function makes sure that we have at least a single command
    line parameter to work with, using `len(arguments) == 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `stats.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code excerpt, we process all valid inputs to count the number
    of valid values and find the minimum and the maximum values among them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `stats.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code excerpt, we find the *mean value* because this cannot be
    computed without processing all values first. After that, we process each valid
    value to compute the *standard deviation* because the mean value is required in
    order to compute the standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `stats.go` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we discussed the advantages, disadvantages,
    philosophy, and history of Go. Then, the basics of Go were presented, which include
    variables, iterations, and flow control as well as how to log data.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned about logging, implemented `which(1)`, and created a
    basic statistics application.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is all about the basic Go data types.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test out what you have learned by trying to complete the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the documentation of the `fmt` package using `go doc`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In UNIX, an exit code of `0` means success, whereas a non-zero exit code usually
    means failure. Try to modify `which.go` to do so with the help of `os.Exit()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current version of `which(1)` stops after finding the first occurrence of
    the desired executable. Make the necessary code changes to `which.go` in order
    to find all possible occurrences of the desired executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Go website: [https://go.dev/](https://go.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Go Playground: [https://go.dev/play/](https://go.dev/play/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `log` package: [https://pkg.go.dev/log](https://pkg.go.dev/log)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Elasticsearch Beats: [https://www.elastic.co/beats/](https://www.elastic.co/beats/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grafana Loki: [https://grafana.com/oss/loki/](https://grafana.com/oss/loki/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Standard deviation: [https://en.wikipedia.org/wiki/Standard_deviation](https://en.wikipedia.org/wiki/Standard_deviation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Visual Studio: [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Standard Go library: [https://pkg.go.dev/std](https://pkg.go.dev/std)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `godoc` utility: [https://pkg.go.dev/golang.org/x/tools/cmd/godoc](https://pkg.go.dev/golang.org/x/tools/cmd/godoc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Review_QR_Code.png)'
  prefs: []
  type: TYPE_IMG
