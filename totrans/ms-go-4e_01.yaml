- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: A Quick Introduction to Go
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go快速入门
- en: Despite its name, this chapter is more than just a quick introduction to Go,
    as it is also going to be the foundation for the rest of the book. The basics
    of Go, some design decisions, and the philosophy of Go are explained in this chapter
    so that you can get the big picture before learning the details of Go. Among other
    things, we present the advantages and disadvantages of Go so that you know when
    to use Go and when to consider other alternatives.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章的名称是“快速入门”，但它不仅仅是Go的快速介绍，它还将成为本书其余部分的基础。本章解释了Go的基本知识、一些设计决策和Go的哲学，以便你在学习Go的细节之前能够了解全局。在众多内容中，我们介绍了Go的优点和缺点，以便你知道何时使用Go以及何时考虑其他替代方案。
- en: In the sections that follow, we cover a number of concepts and utilities in
    order to build a solid foundation of Go, before building a simplified version
    of the `which(1)` utility, which is a UNIX utility that locates program files
    by searching the directories of the `PATH` environment variable. Additionally,
    we explain how to write information in log files, as this can help you store error
    messages and warnings while you are developing software in Go.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍一些概念和实用工具，以便在构建`which(1)`实用工具的简化版本之前，为Go建立一个坚实的基础。`which(1)`是一个UNIX实用工具，通过搜索`PATH`环境变量的目录来定位程序文件。此外，我们还将解释如何将信息写入日志文件，因为这可以帮助你在使用Go开发软件时存储错误消息和警告。
- en: At the end of the chapter, we develop a basic command line utility that computes
    basic statistical properties. It is that command line utility that we are going
    to improve and expand in the remaining book chapters as we learn more advanced
    Go features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们开发了一个基本的命令行实用工具，用于计算基本的统计属性。正是这个命令行实用工具，随着我们学习更多高级的Go特性，我们将在接下来的本书章节中对其进行改进和扩展。
- en: 'The contents of this chapter are:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容如下：
- en: Introducing Go
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Go
- en: When to use Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用Go
- en: Hello World!
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hello World!
- en: Running Go code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Go代码
- en: What you should know about Go
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该了解的Go
- en: Developing the `which(1)` utility in Go
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中开发`which(1)`实用工具
- en: Logging information
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录信息
- en: Developing a statistics application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发统计应用程序
- en: Introducing Go
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Go
- en: Go is an open-source systems programming language, initially developed as an
    internal Google project that went public back in 2009\. The spiritual fathers
    of Go are Robert Griesemer, Ken Thomson, and Rob Pike.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种开源的系统编程语言，最初作为2009年公开的内部Google项目而开发。Go的精神之父是Robert Griesemer、Ken Thomson和Rob
    Pike。
- en: Although the official name of the language is Go, it is sometimes (wrongly)
    referred to as *Golang*. The official reason for this is that [https://go.org/](https://go.org/)
    was not available for registration and [golang.org](https://golang.org) was chosen
    instead—however, nowadays, the official Go website is [https://go.dev/](https://go.dev/).
    Keep in mind that when you are querying a search engine for Go-related information,
    the word *Go* is usually interpreted as a verb; therefore, you should search for
    *golang* instead. Additionally, the official Twitter hashtag for Go is *#golang*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该语言的官方名称是Go，但它有时（错误地）被称为*Golang*。官方的原因是[https://go.org/](https://go.org/)不可用于注册，因此选择了[golang.org](https://golang.org)——然而，如今，官方的Go网站是[https://go.dev/](https://go.dev/)。请记住，当你通过搜索引擎查询与Go相关的信息时，单词*Go*通常被解释为动词；因此，你应该搜索*golang*。此外，Go的官方Twitter标签是*#golang*。
- en: Let us now discuss the history of Go and what that means for someone who wants
    to learn Go.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在讨论Go的历史以及这对想学习Go的人意味着什么。
- en: The history of Go
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go的历史
- en: As mentioned earlier, Go started as an internal Google project that went public
    back in 2009\. Griesemer, Thomson, and Pike designed Go as a language for professional
    programmers who want to build reliable, robust, and efficient software that is
    easy to manage. They designed Go with simplicity in mind, even if simplicity meant
    that Go was not going to be a programming language for everyone or everything.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Go最初是一个内部的Google项目，于2009年公开。Griesemer、Thomson和Pike设计Go作为一种语言，供希望构建可靠、健壮和高效软件的专业程序员使用，这种软件易于管理。他们设计Go时考虑到了简洁性，即使这意味着Go可能不会成为适合所有人或所有事物的编程语言。
- en: The figure that follows shows the programming languages that directly or indirectly
    influenced Go. As an example, Go syntax looks like C, whereas the package concept
    was inspired by Modula-2.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了直接或间接影响Go的编程语言。例如，Go的语法看起来像C，而包的概念则受到了Modula-2的启发。
- en: '![A group of white squares with black text  Description automatically generated
    with low confidence](img/B21003_01_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![一组带有黑色文字的白色方块，描述由低置信度自动生成](img/B21003_01_01.png)'
- en: 'Figure 1.1: The programming languages that influenced Go'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：影响 Go 的编程语言
- en: The deliverable was a programming language with tools and a standard library.
    What you get with Go, apart from its syntax and tools, is a rich standard library
    and a type system that tries to save you from easy mistakes, such as implicit
    type conversions, unused variables, and unused packages. The Go compiler catches
    most of these easy mistakes and refuses to compile until you do something about
    them. Additionally, the Go compiler can find difficult-to-catch mistakes such
    as race conditions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可交付成果是一个包含工具和标准库的编程语言。除了其语法和工具之外，Go 还提供了丰富的标准库和一个试图让您避免简单错误的类型系统，例如隐式类型转换、未使用的变量和未使用的包。Go
    编译器会捕捉到这些简单错误，并在您处理它们之前拒绝编译。此外，Go 编译器还可以找到难以捕捉的错误，例如竞态条件。
- en: If you are going to install Go for the first time, you can start by visiting
    [https://go.dev/dl/](https://go.dev/dl/). However, there is a big chance that
    your UNIX variant has a ready-to-install package for the Go programming language,
    so you might want to get Go by using your favorite package manager.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是第一次安装 Go，可以从访问 [https://go.dev/dl/](https://go.dev/dl/) 开始。然而，您的 UNIX 变体很可能已经有一个为
    Go 编程语言准备好的安装包，因此您可能希望使用您喜欢的包管理器来获取 Go。
- en: As Go is a portable programming language, almost all presented code is going
    to work fine on any modern Microsoft Windows, Linux, or macOS machine without
    any changes. The only Go code that might need some small or big adjustments is
    the code that deals with the operating system. Most of that code is covered in
    *Chapter 7*, *Telling a UNIX System What to Do*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 是一种可移植的编程语言，几乎所有展示的代码都可以在未经任何修改的情况下在任何现代的 Microsoft Windows、Linux 或 macOS
    机器上正常工作。可能需要一些小或大的调整的 Go 代码是处理操作系统的代码。其中大部分代码在 *第 7 章*，*告诉 UNIX 系统做什么* 中进行了介绍。
- en: The advantages of Go
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 的优势
- en: Go comes with some important advantages for developers, starting with the fact
    that it was designed and is currently maintained by real programmers. Go is also
    easy to learn, especially if you are already familiar with programming languages
    such as C, Python, or Java. On top of that, due to its simplified and elegant
    syntax, Go code is pleasant to the eye, which is great, especially when you are
    programming applications for a living and you have to look at code on a daily
    basis. Go code is also easy to read, which means that you can make changes to
    existing Go code easily, and offers support for Unicode out of the box. Lastly,
    Go has reserved only 25 keywords, which makes it much easier to remember the language.
    Can you do that with C++?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Go 为开发者带来了一些重要的优势，首先是因为它是由真正的程序员设计和维护的。Go 也很容易学习，尤其是如果您已经熟悉 C、Python 或 Java
    等编程语言。除此之外，由于其简化和优雅的语法，Go 代码看起来很舒服，这在您以编程为生并需要每天查看代码时尤其如此。Go 代码也易于阅读，这意味着您可以轻松地对现有的
    Go 代码进行修改，并且它提供了对 Unicode 的原生支持。最后，Go 只保留了 25 个关键字，这使得记住该语言变得容易得多。您能用 C++ 做到这一点吗？
- en: Go also comes with concurrency capabilities, using a simple concurrency model
    that is implemented using *goroutines* and *channels*. Go manages OS threads for
    you and has a powerful runtime that allows you to spawn lightweight units of work
    (goroutines) that communicate with each other using channels.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还提供了并发能力，使用一个简单的并发模型，该模型通过 *goroutines* 和 *channels* 实现。Go 会为您管理操作系统线程，并拥有一个强大的运行时，允许您生成轻量级的工作单元（goroutines），它们通过通道相互通信。
- en: Although Go comes with a rich standard library, there are really handy Go packages,
    such as `cobra` and `viper`, that allow Go to develop complex command line utilities
    such as `docker` and `hugo`. This is greatly supported by the fact that executable
    binaries are statically linked, which means that once they are generated, they
    do not depend on any shared libraries and include all required information. In
    practice, this means that you can transfer an existing executable file to a different
    machine with the same architecture and be sure that it is going to run without
    any issues.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 拥有丰富的标准库，但还有一些非常实用的 Go 包，例如 `cobra` 和 `viper`，这些包使得 Go 能够开发出复杂的命令行工具，如
    `docker` 和 `hugo`。这一点得到了强有力的支持，因为可执行二进制文件是静态链接的，这意味着一旦生成，它们就不依赖于任何共享库，并包含了所有必需的信息。在实践中，这意味着你可以将现有的可执行文件转移到具有相同架构的不同机器上，并确信它将无任何问题地运行。
- en: Due to its simplicity, Go code is predictable and does not have strange side
    effects, and although Go supports pointers, it does not support pointer arithmetic
    like C, unless you use the `unsafe` package, which can be the root of many bugs
    and security holes. Although Go is not an object-oriented programming language,
    Go interfaces are very versatile and allow you to mimic some of the capabilities
    of object-oriented languages, such as polymorphism, encapsulation, and composition.
    However, Go offers no support for classes and inheritance. *Chapter 5*, *Reflection
    and Interfaces*, provides more information on the subject.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性，Go 代码是可预测的，并且没有奇怪的副作用，尽管 Go 支持指针，但它不支持像 C 语言那样的指针算术，除非你使用 `unsafe` 包，这可能是许多错误和安全漏洞的根源。虽然
    Go 不是一个面向对象编程语言，但 Go 接口非常灵活，允许你模仿一些面向对象语言的能力，如多态性、封装和组合。然而，Go 并不支持类和继承。*第 5 章*，*反射和接口*提供了更多关于这个主题的信息。
- en: Additionally, the latest Go versions offer support for *generics*, which simplifies
    your code when working with multiple data types. You can learn more about Go generics
    in *Chapter 4*, *Go Generics*. Finally, Go is a garbage-collected language, which
    means that no manual memory management is needed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，最新的 Go 版本提供了对 *泛型* 的支持，这简化了处理多个数据类型时的代码。你可以在 *第 4 章*，*Go 泛型* 中了解更多关于 Go 泛型的信息。最后，Go
    是一种垃圾回收语言，这意味着不需要手动内存管理。
- en: When to use Go
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用 Go
- en: Although Go is a general-purpose programming language, it is primarily used
    for writing system tools, command line utilities, web services, and software that
    works over networks and the internet. You can use Go for teaching programming,
    and it is a good candidate as your first programming language because of its lack
    of verbosity and clear ideas and principles.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 是一种通用编程语言，但它主要用于编写系统工具、命令行工具、网络服务和在网络上工作的软件。你可以用 Go 来教授编程，由于其简洁性、清晰的思想和原则，它是一个很好的编程语言入门选择。
- en: 'Go can help you develop the following kinds of applications:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Go 可以帮助你开发以下类型的应用程序：
- en: Professional web services
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专业网络服务
- en: Networking tools and servers such as Kubernetes and Istio
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 Kubernetes 和 Istio 这样的网络工具和服务器
- en: Backend systems
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端系统
- en: Robust UNIX and Windows system tools
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坚固的 UNIX 和 Windows 系统工具
- en: Servers that work with APIs and clients that interact by exchanging data in
    myriad formats, including JSON, XML, and CSV
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 API 一起工作的服务器和通过交换多种格式的数据（包括 JSON、XML 和 CSV）进行交互的客户端
- en: WebSocket servers and clients
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket 服务器和客户端
- en: gRPC (Remote Procedure Call) servers and clients
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC（远程过程调用）服务器和客户端
- en: Complex command line utilities with multiple commands, sub-commands, and command
    line parameters, such as `docker` and `hugo`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有多个命令、子命令和命令行参数的复杂命令行工具，如 `docker` 和 `hugo`
- en: Applications that exchange data in the JSON format
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 JSON 格式交换数据的应用程序
- en: Applications that process data from relational databases, NoSQL databases, or
    other popular data storage systems
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从关系型数据库、NoSQL 数据库或其他流行的数据存储系统中处理数据的应用程序
- en: Compilers and interpreters for your own programming languages
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你自己的编程语言编写的编译器和解释器
- en: Database systems such as CockroachDB and key/value stores such as etcd
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 CockroachDB 这样的数据库系统以及 etcd 这样的键值存储
- en: 'Although Go is a very practical and competent programming language, it is not
    perfect:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 是一种非常实用和高效的编程语言，但它并不完美：
- en: 'This is a personal preference rather than an actual technical shortcoming:
    Go has no direct and full support for object-oriented programming, which is a
    popular programming paradigm.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种个人偏好，而不是实际的技术缺陷：Go 没有直接和全面的支持面向对象编程，这是一种流行的编程范式。
- en: Although goroutines are lightweight, they are not as powerful as OS threads.
    Depending on the application you are trying to implement, there might exist some
    rare cases where goroutines will not be appropriate for the job. The Apache web
    server creates UNIX processes with `fork(2)` to serve its clients—Go does not
    support the functionality of `fork(2)`. However, in most cases, designing your
    application with goroutines and channels in mind will solve your problems.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然goroutines轻量级，但它们不如操作系统线程强大。根据你试图实现的应用程序，可能存在一些罕见的情况，其中goroutines可能不适合这项工作。Apache
    网络服务器使用 `fork(2)` 创建 UNIX 进程来为其客户端提供服务——Go 不支持 `fork(2)` 的功能。然而，在大多数情况下，考虑使用 goroutines
    和 channels 设计你的应用程序将解决你的问题。
- en: Although garbage collection is fast enough most of the time, and for almost
    all kinds of applications, there are times when you need to handle memory allocation
    manually, such as when developing an operating system or working with large chunks
    of memory and want to avoid fragmentation—Go cannot do that. In practice, this
    means that Go will not allow you to perform any memory management manually.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管垃圾回收在大多数情况下足够快，并且对于几乎所有类型的应用程序来说，有时你需要手动处理内存分配，例如在开发操作系统或处理大量内存时想要避免碎片化——Go
    无法做到这一点。在实践中，这意味着 Go 不会允许你手动进行任何内存管理。
- en: Go does not offer the full functionality of a functional programming language.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 不提供函数式编程语言的全部功能。
- en: Go is not good at developing systems with high availability guarantees. In such
    cases, use Erlang or Elixir instead.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 不擅长开发具有高可用性保证的系统。在这种情况下，请使用 Erlang 或 Elixir。
- en: 'There are many things that Go does better than other programming languages,
    including the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Go 在许多方面比其他编程语言做得更好，包括以下方面：
- en: The Go compiler catches a large set of silly errors that might end up being
    bugs. This includes imported Go packages and variables that are not being used
    in the code.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 编译器可以捕获大量愚蠢的错误，这些错误最终可能成为漏洞。这包括导入的 Go 包和代码中未使用的变量。
- en: Go uses fewer parentheses than C, C++, or Java, and no semicolons, which makes
    Go source code more human-readable and less error-prone.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 使用的括号比 C、C++ 或 Java 少，并且没有分号，这使得 Go 源代码更易于阅读且错误更少。
- en: Go comes with a rich and reliable standard library that keeps improving.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 搭载了一个丰富且可靠的标准库，并且一直在不断改进。
- en: Go has support for concurrency out of the box through goroutines and channels.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 通过 goroutines 和 channels 提供了开箱即用的并发支持。
- en: Goroutines are lightweight. You can easily run thousands of goroutines on any
    modern machine without any performance issues.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goroutines 轻量级。你可以在任何现代机器上轻松运行数千个 goroutines，而不会出现任何性能问题。
- en: Unlike C, Go considers functions as first-class citizens.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 C 语言不同，Go 将函数视为一等公民。
- en: Go code is backward compatible, which means that newer versions of the Go compiler
    accept programs that were created using a previous version of the language without
    any modifications. This compatibility guarantee is limited to major versions of
    Go. For example, there is no guarantee that a Go 1.x program will compile with
    Go 2.x.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 代码具有向后兼容性，这意味着较新版本的 Go 编译器可以接受使用语言先前版本创建的程序，而无需任何修改。这种兼容性保证仅限于 Go 的大版本。例如，不能保证
    Go 1.x 程序可以用 Go 2.x 编译。
- en: The next subsection describes my personal Go journey.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将描述我的个人 Go 之旅。
- en: My personal Go journey
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我的个人 Go 之旅
- en: In this subsection, I am going to tell you my personal story of how I ended
    up learning and using Go. I am a UNIX person, which means that I like UNIX and
    prefer to use it whenever possible. I also love C, and I used to like C++; I wrote
    a command line FTP client in C++ for my M.Sc. project. Nowadays, C++ is just a
    huge programming language that is difficult to learn. Although C continues to
    be a decent programming language, it requires lots of code to perform simple tasks
    and suffers from difficult-to-find and correct bugs, due to manual memory management
    and extremely flexible conversion between different data types without any warnings
    or error messages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将告诉你我如何最终学习并使用 Go 的个人故事。我是一个 UNIX 人士，这意味着我喜欢 UNIX，并尽可能使用它。我也热爱 C 语言，曾经喜欢
    C++；我为我硕士项目用 C++ 编写了一个命令行 FTP 客户端。如今，C++ 已经成为一个庞大且难以学习的编程语言。尽管 C 仍然是一个不错的编程语言，但它需要大量的代码来完成简单的任务，并且由于手动内存管理和不同数据类型之间极其灵活的转换（没有任何警告或错误消息），因此存在难以找到和纠正的错误。
- en: As a result, I used to use Perl to write simple command line utilities. However,
    Perl is far from perfect for writing serious command line tools and services,
    as it is a scripting programming language and is not intended for web development.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我过去常常使用Perl编写简单的命令行实用程序。然而，Perl并不适合编写严肃的命令行工具和服务，因为它是一种脚本编程语言，并不适用于Web开发。
- en: When I first heard about Go, that it was developed by Google, and that both
    Rob Pike and Ken Thomson were involved in its development, I instantly became
    interested in Go.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次听说Go语言是由Google开发的，并且Rob Pike和Ken Thompson都参与了其开发时，我立刻对Go语言产生了兴趣。
- en: Since then, I have used Go to create web services, servers, and clients that
    communicate with RabbitMQ, MySQL, and PostgreSQL, create simple command line utilities,
    implement algorithms for time series data mining, create utilities that generate
    synthetic data, etc.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我使用Go创建了与RabbitMQ、MySQL和PostgreSQL通信的Web服务、服务器和客户端，创建了简单的命令行实用程序，实现了时间序列数据挖掘的算法，创建了生成合成数据的实用程序等。
- en: Soon, we are going to move on to actually learn some Go, using *Hello World!*
    as the first example, but before that, we will present the `go doc` command, which
    allows you to find information about the Go standard library, its packages, and
    their functions, as well as the `godoc` utility.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将开始学习Go语言，以*Hello World!*作为第一个示例，但在那之前，我们将介绍`go doc`命令，该命令允许您查找有关Go标准库、其包及其函数的信息，以及`godoc`实用程序。
- en: If you have not already installed Go, this is the right time to do so. To do
    that, visit [https://go.dev/dl/](https://go.dev/dl/) or use your favorite package
    manager.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装Go，现在是安装的时候了。要安装，请访问[https://go.dev/dl/](https://go.dev/dl/)或使用您喜欢的包管理器。
- en: The go doc and godoc utilities
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go doc和godoc实用程序
- en: The Go distribution comes with a plethora of tools that can make your life as
    a programmer easier. Two of these tools are the `go doc` subcommand and `godoc`
    utility, which allow you to see the documentation of existing Go functions and
    packages without needing an internet connection. However, if you prefer viewing
    the Go documentation online, you can visit [https://pkg.go.dev/](https://pkg.go.dev/).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言发行版附带了许多工具，可以使程序员的编程生活更加轻松。其中两个工具是`go doc`子命令和`godoc`实用程序，它们允许您在不使用互联网连接的情况下查看现有Go函数和包的文档。然而，如果您更喜欢在线查看Go文档，可以访问[https://pkg.go.dev/](https://pkg.go.dev/)。
- en: 'The `go doc` command can be executed as a normal command line application that
    displays its output on a terminal, and it is similar to the UNIX `man(1)` command,
    but for Go functions and packages only. So, in order to find out information about
    the `Printf()` function of the `fmt` package, you should execute the following
    command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`go doc`命令可以作为正常的命令行应用程序执行，并在终端上显示其输出，它与UNIX的`man(1)`命令类似，但仅针对Go函数和包。因此，为了查找有关`fmt`包的`Printf()`函数的信息，您应该执行以下命令：'
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similarly, you can find out information about the entire `fmt` package by running
    the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以通过运行以下命令来查找有关整个`fmt`包的信息：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As `godoc` is not installed by default, you might need to install it by running
    `go install golang.org/x/tools/cmd/godoc@latest`. The `godoc` binary is going
    to be installed in `~/go/bin`, and you can execute it as `~/go/bin/godoc` unless
    `~/go/bin` is in your `PATH` environment variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`godoc`默认未安装，您可能需要通过运行`go install golang.org/x/tools/cmd/godoc@latest`来安装它。`godoc`二进制文件将被安装到`~/go/bin`，除非`~/go/bin`已包含在您的`PATH`环境变量中，否则您可以通过`~/go/bin/godoc`来执行它。
- en: The `godoc` command line application starts a local web server. So you need
    a web browser to look at the Go documentation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`godoc`命令行应用程序启动一个本地Web服务器。因此，您需要一个Web浏览器来查看Go文档。'
- en: 'Running `godoc` requires executing `godoc` with the `-http` parameter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`godoc`需要使用`-http`参数执行`godoc`：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The numeric value in the preceding command, which in this case is `8001`, is
    the port number that the HTTP server will listen to. As we have omitted the IP
    address, `godoc` is going to listen to all network interfaces.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，该数值为`8001`，是HTTP服务器将监听的端口号。由于我们省略了IP地址，`godoc`将监听所有网络接口。
- en: You can choose any port number that is available if you have the right privileges.
    However, note that port numbers `0`–`1023` are restricted and can only be used
    by the root user, so it is better to avoid choosing one of those and pick something
    else, if it is not already in use by a different process. Port number `8001` is
    usually free and is frequently used for local HTTP servers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有适当的权限，可以选择任何可用的端口号。但是，请注意端口号 `0`–`1023` 是受限的，只能由 root 用户使用，因此最好避免选择这些中的一个，如果它还没有被其他进程使用，可以选择其他端口号。端口号
    `8001` 通常空闲，并且经常用于本地 HTTP 服务器。
- en: 'You can omit the equals sign in the presented command and put a space character
    in its place. So the following command is completely equivalent to the previous
    one:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在展示的命令中省略等号，并用空格字符代替。因此，以下命令与上一个命令完全等价：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After that, you should point your web browser to `http://localhost:8001/` in
    order to get the list of available Go packages and browse their documentation.
    If no `-http` parameter is provided, `godoc` listens to port `6060`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您应该将您的网络浏览器指向 `http://localhost:8001/` 以获取可用的 Go 包列表并浏览它们的文档。如果没有提供 `-http`
    参数，`godoc` 将监听端口号 `6060`。
- en: If you are using Go for the first time, you will find the Go documentation very
    handy for learning the parameters and the return values of the functions you want
    to use — as you progress in your Go journey, you will use the Go documentation
    to learn the gory details of the functions and variables that you want to use.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是第一次使用 Go，您会发现 Go 文档对于学习您想要使用的函数的参数和返回值非常有用——随着您在 Go 之旅中的进步，您将使用 Go 文档来学习您想要使用的函数和变量的详细信息。
- en: The next section presents the first Go program of the book and explains the
    basic concepts of Go.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节介绍了本书的第一个 Go 程序，并解释了 Go 的基本概念。
- en: Hello World!
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World！
- en: 'The following is the Go version of the *Hello World!* program. Please type
    it and save it as `hw.go`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将 *Hello World!* 程序转换为 Go 版本。请将其键入并保存为 `hw.go`：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you are eager to execute `hw.go`, type `go run hw.go` in the same directory
    where you save it. The file can also be found in the `ch01` directory of the GitHub
    repository of the book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您急于执行 `hw.go`，请在保存它的同一目录中键入 `go run hw.go`。该文件也可以在本书 GitHub 仓库的 `ch01` 目录中找到。
- en: Each Go source code begins with a package declaration. In this case, the name
    of the package is `main`, which has a special meaning in Go—autonomous Go programs
    should use the `main` package. The `import` keyword allows you to include functionality
    from existing packages. In our case, we only need some of the functionality of
    the `fmt` package that belongs to the standard Go library, implementing formatted
    input and output with functions that are analogous to C’s `printf()` and `scanf()`.
    The next important thing if you are creating an executable application is a `main()`
    function. Go considers this the entry point to the application, and it begins
    the execution of an application with the code found in the `main()` function of
    the `main` package.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Go 源代码都以包声明开始。在这种情况下，包名是 `main`，这在 Go 中有特殊含义——自主 Go 程序应使用 `main` 包。`import`
    关键字允许您包含现有包的功能。在我们的例子中，我们只需要属于标准 Go 库的 `fmt` 包的一些功能，这些功能通过类似于 C 的 `printf()` 和
    `scanf()` 的函数实现格式化输入和输出。如果您正在创建可执行应用程序，下一个重要的事情是一个 `main()` 函数。Go 将其视为应用程序的入口点，并以
    `main` 包的 `main()` 函数中的代码开始执行应用程序。
- en: '`hw.go` is a Go program that runs on its own. Two characteristics make `hw.go`
    a source file that can generate an executable binary: the name of the package,
    which should be `main`, and the presence of the `main()` function—we discuss Go
    functions in more detail in the next subsection, but we will learn even more about
    functions and methods, which are functions attached to specific data types, in
    *Chapter 6*, *Go Packages and Functions*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`hw.go` 是一个独立运行的 Go 程序。两个特性使 `hw.go` 成为一个可以生成可执行二进制文件的源文件：包名应该是 `main`，以及存在
    `main()` 函数——我们将在下一小节中更详细地讨论 Go 函数，但我们将更深入地了解函数和方法，这些是附加到特定数据类型上的函数，在 *第 6 章*，*Go
    包和函数* 中。'
- en: Introducing functions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数介绍
- en: 'Each Go function definition begins with the `func` keyword, followed by its
    name, signature, and implementation. Apart from the `main()` function, which has
    a special purpose, you can name the rest of your functions anything you want—there
    is a global Go rule that also applies to function and variable names and is valid
    for all packages except main: *everything that begins with a lowercase letter
    is considered private and is accessible in the current package only*. We will
    learn more about that rule in *Chapter 6*, *Go Packages and Functions*. The only
    exception to this rule is package names, which can begin with either lowercase
    or uppercase letters. Having said that, I am not aware of a Go package that begins
    with an uppercase letter!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Go函数定义都以`func`关键字开始，后面跟着其名称、签名和实现。除了具有特殊用途的`main()`函数外，你可以将其他函数命名为任何你想要的名称——有一个全局的Go规则也适用于函数和变量名称，并且对所有包（除了main包）都有效：*以小写字母开头的所有内容都被认为是私有的，并且只能在当前包中访问*。我们将在*第6章，Go包和函数*中了解更多关于这个规则的内容。这个规则的唯一例外是包名，它可以以小写或大写字母开头。话虽如此，我并不了解以大写字母开头的Go包！
- en: You might now ask how functions are organized and delivered. Well, the answer
    is in packages—the next subsection sheds some light on that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能会问函数是如何组织和交付的。好吧，答案是包——下一个小节将对此进行一些解释。
- en: Introducing packages
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍包
- en: 'Go programs are organized in packages—even the smallest Go program should be
    delivered as a package. The `package` keyword helps you define the name of a new
    package, which can be anything you want, with just one exception: if you are creating
    an executable application and not just a package that will be shared by other
    applications or packages, you should name your package `main`. You will learn
    more about developing Go packages in *Chapter 6*, *Go Packages and Functions*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序是有组织的包——即使是最小的Go程序也应该作为一个包来交付。`package`关键字帮助你定义新包的名称，你可以取任何你想要的名称，只有一个例外：如果你正在创建一个可执行的应用程序，而不仅仅是其他应用程序或包将共享的包，你应该将你的包命名为`main`。你将在*第6章，Go包和函数*中了解更多关于开发Go包的内容。
- en: Packages can be used by other packages. In fact, reusing existing packages is
    a good practice that saves you from having to write lots of code or implement
    existing functionality from scratch.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 包可以被其他包使用。实际上，重用现有包是一个好的实践，可以节省你编写大量代码或从头实现现有功能的时间。
- en: 'The `import` keyword is used for importing other Go packages into your Go programs
    to use some or all of their functionality. A Go package can either be a part of
    the rich Standard Go library or come from an external source. Packages of the
    standard Go library are imported by name, for example, `import` `"os"` to use
    the `os` package, whereas external packages like `github.com/spf13/cobra` are
    imported using their full URLs: `import "github.com/spf13/cobra"`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`关键字用于将其他Go包导入到你的Go程序中，以使用它们的一些或全部功能。一个Go包可以是丰富的标准Go库的一部分，也可以来自外部来源。标准Go库的包通过名称导入，例如，使用`import
    "os"`来使用`os`包，而像`github.com/spf13/cobra`这样的外部包则使用它们的完整URL导入：`import "github.com/spf13/cobra"`。'
- en: Running Go code
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Go代码
- en: 'You now need to know how to execute `hw.go` or any other Go application. As
    will be explained in the two subsections that follow, there are two ways to execute
    Go code: as a compiled language, using `go build`, or by mimicking a scripting
    language, using `go run`. So let us find out more about these two ways of running
    Go code.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在需要知道如何执行`hw.go`或任何其他Go应用程序。正如将在接下来的两个小节中解释的那样，有两种方式可以执行Go代码：作为编译语言，使用`go
    build`，或者模仿脚本语言，使用`go run`。那么，让我们更深入地了解这两种运行Go代码的方式。
- en: Compiling Go code
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译Go代码
- en: To compile Go code and create a binary executable file, we need to use the `go
    build` command. What `go build` does is create an executable file for us to distribute
    and execute manually. This means that when using `go build`, an extra step is
    required to run the executable file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译Go代码并创建一个二进制可执行文件，我们需要使用`go build`命令。`go build`为我们创建一个可分发的可执行文件。这意味着当使用`go
    build`时，需要额外一步来运行可执行文件。
- en: The generated executable is automatically named after the source code filename
    without the `.go` file extension. Therefore, because of the `hw.go` source filename,
    the executable will be called `hw`. If this is not what you want, `go build` supports
    the `-o` option, which allows you to change the filename and the path of the generated
    executable file. As an example, if you want to name the executable file a `helloWorld`,
    you should execute `go build -o helloWorld hw.go` instead. If no source files
    are provided, `go build` looks for a `main` package in the current directory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的可执行文件会自动以源代码文件名（不带 `.go` 扩展名）命名。因此，由于 `hw.go` 源文件名，可执行文件将被命名为 `hw`。如果你不希望这样，`go
    build` 支持使用 `-o` 选项来更改生成的可执行文件的文件名和路径。例如，如果你想将可执行文件命名为 `helloWorld`，你应该执行 `go
    build -o helloWorld hw.go`。如果没有提供源文件，`go build` 会查找当前目录中的 `main` 包。
- en: 'After that, you need to execute the generated executable binary file on your
    own. In our case, this means executing either `hw` or `helloWorld`. This is shown
    in the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你需要在自己的计算机上执行生成的可执行二进制文件。在我们的例子中，这意味着执行 `hw` 或 `helloWorld`。以下输出显示了这一点：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we know how to compile Go code, let us continue using Go as if it were
    a scripting language.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何编译 Go 代码，让我们继续像使用脚本语言一样使用 Go。
- en: Using Go like a scripting language
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Go 当作脚本语言使用
- en: 'The `go run` command builds the named Go package, which in this case is the
    `main` package implemented in a single file, creates a temporary executable file,
    executes that file, and deletes it once it is done—to our eyes, this looks like
    using a scripting language while the Go compiler still creates a binary executable.
    In our case, we can do the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run` 命令构建名为 Go 的包，在这个例子中是单个文件中实现的 `main` 包，创建一个临时可执行文件，执行该文件，并在完成后删除它——对我们来说，这看起来像是使用脚本语言，而
    Go 编译器仍然创建二进制可执行文件。在我们的情况下，我们可以做以下操作：'
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using `go run` is a better choice when testing code. However, if you want to
    create and distribute an executable binary, then `go build` is the way to go.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go run` 在测试代码时是一个更好的选择。然而，如果你想创建和分发可执行二进制文件，那么 `go build` 是正确的选择。
- en: Important formatting and coding rules
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要的格式化和编码规则
- en: You should know that Go comes with some strict formatting and coding rules that
    help a developer avoid rookie mistakes and bugs—once you learn these few rules
    and Go idiosyncrasies as well as the implications they have on your code, you
    will be free to concentrate on the actual functionality of your code. Additionally,
    the Go compiler is here to help you follow these rules with its expressive error
    messages and warnings. Last, Go offers standard tooling (`gofmt`) that can format
    your code for you, so you never have to think about it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，Go 有一套严格的格式化和编码规则，可以帮助开发者避免新手错误和漏洞——一旦你学会了这些规则以及 Go 的特性以及它们对代码的影响，你就可以自由地专注于代码的实际功能。此外，Go
    编译器通过其表达性的错误信息和警告来帮助你遵循这些规则。最后，Go 提供了标准工具（`gofmt`），可以为你格式化代码，所以你永远不必担心它。
- en: 'The following is a list of important Go rules that will help you while reading
    this chapter:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在阅读本章时帮助你的一些重要的 Go 规则列表：
- en: Go code is delivered in packages, and you are free to use the functionality
    found in existing packages. There is a Go rule that says that if you import a
    package, you should use it in some way (call a function or use a datatype), or
    the compiler is going to complain. There exist exceptions to this rule that mainly
    have to do with packages that initialize connections with database and TCP/IP
    servers, but they are not important for now. Packages are covered in *Chapter
    6*, *Go Packages and Functions*.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 代码以包的形式提供，你可以自由使用现有包中的功能。有一个 Go 规则说，如果你导入了一个包，你应该以某种方式使用它（调用一个函数或使用数据类型），否则编译器会报错。这个规则有一些例外，主要与初始化数据库和
    TCP/IP 服务器连接的包有关，但这对现在来说并不重要。包将在 *第 6 章*，*Go 包和函数* 中介绍。
- en: You either use a variable or you do not declare it at all. This rule helps you
    avoid errors such as misspelling an existing variable or function name.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你要么使用变量，要么根本不声明它。这个规则帮助你避免诸如拼写现有变量或函数名错误这样的错误。
- en: There is only one way to format curly braces in Go.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中格式化花括号只有一种方式。
- en: Coding blocks in Go are embedded in curly braces, even if they contain just
    a single statement or no statements at all.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 中的代码块使用花括号嵌套，即使它们只包含一个语句或者没有任何语句。
- en: Go functions can return multiple values.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 函数可以返回多个值。
- en: You cannot automatically convert between different data types, even if they
    are of the same kind. As an example, you cannot implicitly convert an integer
    to a floating point.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能在不同的数据类型之间自动转换，即使它们属于同一类型。例如，您不能隐式地将整数转换为浮点数。
- en: Go has more rules, but the preceding ones are the most important and will keep
    you going for most of the book. You are going to see all these rules in action
    in this chapter as well as in other chapters. For now, let’s consider the only
    way to format curly braces in Go because this rule applies everywhere.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有更多规则，但前面的规则是最重要的，它们将贯穿本书的大部分内容。您将在本章以及其他章节中看到所有这些规则的实际应用。现在，让我们考虑在 Go 中格式化花括号的唯一方法，因为这个规则适用于所有地方。
- en: 'Look at the following Go program named `curly.go`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下名为 `curly.go` 的 Go 程序：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although it looks just fine, if you try to execute it, you will be disappointed
    because the code will not compile and, therefore, you will get the following syntax
    error message:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来没问题，但如果您尝试执行它，您会感到失望，因为代码将无法编译，因此您将得到以下语法错误信息：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The official explanation for this error message is that Go requires the use
    of semicolons as statement terminators in many contexts, and the compiler implicitly
    inserts the required semicolons when it thinks that they are necessary. Therefore,
    putting the opening curly brace (`{`) in its own line will make the Go compiler
    insert a semicolon at the end of the previous line (`func main()`), which is the
    main cause of the error message. The correct way to write the previous code is
    the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个错误信息的官方解释是，Go 语言在许多情况下要求使用分号作为语句终止符，当编译器认为有必要时，会隐式地插入所需的分号。因此，将开括号 (`{`)
    放在其自己的行上会使 Go 编译器在上一行（`func main()`）的末尾插入一个分号，这是错误信息的主要原因。正确编写上一段代码的方法如下：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After learning about this global rule, let us continue by presenting some important
    characteristics of Go.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解这个全局规则之后，让我们继续介绍 Go 语言的一些重要特性。
- en: What you should know about Go
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您应该了解的 Go 语言知识
- en: This big section discusses important and essential Go features including variables,
    controlling program flow, iterations, getting user input, and Go concurrency.
    We begin by discussing variables, variable declaration, and variable usage.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大节讨论了 Go 语言的重要和基本特性，包括变量、控制程序流程、迭代、获取用户输入和 Go 并发。我们首先讨论变量、变量声明和变量使用。
- en: Defining and using variables
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和使用变量
- en: Imagine that you want to perform basic mathematical calculations. In that case,
    you need to define variables to keep the input, intermediate computations, and
    results.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您想执行基本的数学计算。在这种情况下，您需要定义变量来保存输入、中间计算和结果。
- en: Go provides multiple ways to declare new variables to make the variable declaration
    process more natural and convenient. You can declare a new variable using the
    `var` keyword, followed by the variable name, followed by the desired data type
    (we are going to cover data types in detail in *Chapter 2*, *Basic Go Data Types*).
    If you want, you can follow that declaration with `=` and an initial value for
    your variable. If there is an initial value given, you can omit the data type
    and the compiler will infer it for you.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了多种声明新变量的方式，使变量声明过程更加自然和方便。您可以使用 `var` 关键字来声明一个新变量，后跟变量名，然后是所需的数据类型（我们将在
    *第 2 章*，*基本 Go 数据类型* 中详细介绍数据类型）。如果您愿意，可以在声明后跟 `=` 和变量的初始值。如果提供了初始值，您可以省略数据类型，编译器会为您推断它。
- en: '**This brings us to a very important Go rule: if no initial value is given
    to a variable, the Go compiler will automatically initialize that variable to
    the zero value of its data type.**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**这带我们来到了一个非常重要的 Go 规则：如果未给变量提供初始值，Go 编译器将自动将该变量初始化为其数据类型的零值。**'
- en: There is also the `:=` notation, which can be used instead of a var declaration.
    `:=` defines a new variable by inferring the data of the value that follows it.
    The official name for `:=` is *short assignment statement*, and it is very frequently
    used in Go, especially for getting the return values from functions and `for`
    loops with the `range` keyword.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 `:=` 符号，它可以用来代替变量声明。`:=` 通过推断其后值的类型来定义一个新变量。`:=` 的官方名称是 *短赋值语句*，在 Go 语言中非常常用，尤其是在从函数和带有
    `range` 关键字的 `for` 循环中获取返回值时。
- en: The short assignment statement can be used in place of a `var` declaration with
    an implicit type. You rarely see the use of `var` in Go; the `var` keyword is
    mostly used for declaring global or local variables without an initial value.
    The reason for the former is that every statement that exists outside of the code
    of a function must begin with a keyword, such as `func` or `var`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的赋值语句可以用作具有隐式类型的`var`声明的替代。在Go语言中，很少看到`var`的使用；`var`关键字主要用于声明没有初始值的全局或局部变量。前者之所以如此，是因为存在于函数代码之外的所有语句都必须以关键字开头，例如`func`或`var`。
- en: This means that the short assignment statement cannot be used outside of a function
    environment because it is not permitted there. Last, you might need to use `var`
    when you want to be explicit about the data type. For example, when you want the
    type of a variable to be `int8` or `int32` instead of `int`, which is the default.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着简短的赋值语句不能在函数环境之外使用，因为那里不允许这样做。最后，当你想明确指定数据类型时，你可能需要使用`var`。例如，当你想让变量的类型为`int8`或`int32`而不是默认的`int`时。
- en: Constants
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: There are values, such as the mathematical constant Pi, that cannot change.
    In that case, we can declare such values as constants using `const`. Constants
    are declared just like variables but cannot change once they have been declared.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些值，例如数学常数π，是不可变的。在这种情况下，我们可以使用`const`来声明这样的值。常量的声明方式与变量相同，但一旦声明后就不能更改。
- en: The supported data types for constants are character, string, Boolean, and all
    numeric data types. There’s more about Go data types in *Chapter 2*, *Basic Go
    Data Types*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 常量支持的数据类型包括字符、字符串、布尔值以及所有数值数据类型。关于Go语言数据类型的更多信息，请参阅*第2章*，*基本Go数据类型*。
- en: Global variables
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: Global variables are variables that are defined outside of a function implementation.
    *Global variables* can be accessed from anywhere in a package without the need
    to explicitly pass them to a function, and they can be changed unless they were
    defined as constants, using the `const` keyword.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量是在函数实现之外定义的变量。*全局变量*可以在包的任何地方访问，而无需显式地将它们传递给函数，并且除非它们被定义为常量，否则可以使用`const`关键字来更改它们。
- en: Although you can declare local variables using either `var` or `:=`, only `const`
    (when the value of a variable is not going to change) and `var` work for global
    variables.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用`var`或`:=`来声明局部变量，但只有`const`（当变量的值不会改变时）和`var`适用于全局变量。
- en: Printing variables
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印变量
- en: Programs tend to display information, which means that they need to print data
    or send it somewhere for other software to store or process it. To print data
    on the screen, Go uses the functionality of the `fmt` package. If you want Go
    to take care of the printing, then you might want to use the `fmt.Println()` function.
    However, there are times when you want to have full control over how data is going
    to be printed. In such cases, you might want to use `fmt.Printf()`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 程序倾向于显示信息，这意味着它们需要打印数据或将数据发送到其他软件进行存储或处理。要在屏幕上打印数据，Go语言使用`fmt`包的功能。如果你想让Go语言处理打印，那么你可能想使用`fmt.Println()`函数。然而，有时你可能希望完全控制数据的打印方式。在这种情况下，你可能想使用`fmt.Printf()`。
- en: '`fmt.Printf()` is similar to the C `printf()` function and requires the use
    of control sequences that specify the data type of the variable that is going
    to be printed. Additionally, the `fmt.Printf()` function allows you to format
    the generated output, which is particularly convenient for floating point values
    because it allows you to specify the digits that will be displayed in the output
    (`%.2f` displays two digits after the decimal point of a floating point value).
    Lastly, the `\n` character is used for printing a newline character and, therefore,
    creating a new line, as `fmt.Printf()` does not automatically insert a newline—this
    is not the case with `fmt.Println()`, which automatically inserts a newline, hence
    the `ln` at the end of its name.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Printf()`类似于C语言的`printf()`函数，需要使用控制序列来指定将要打印的变量的数据类型。此外，`fmt.Printf()`函数允许你格式化生成的输出，这对于浮点值尤其方便，因为它允许你指定输出中要显示的数字（`%.2f`显示浮点值小数点后的两位数字）。最后，`\n`字符用于打印换行符，因此创建新行，因为`fmt.Printf()`不会自动插入换行符——这与自动插入换行符的`fmt.Println()`不同，因此其名称末尾有`ln`。'
- en: 'The following program illustrates how you can declare new variables, how to
    use them, and how to print them—type the following code into a plain text file
    named `variables.go`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序说明了你可以如何声明新变量，如何使用它们，以及如何打印它们——将以下代码输入一个名为`variables.go`的纯文本文件中：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Personally, I prefer to make global variables stand out by either beginning
    them with an uppercase letter or using all capital letters. As you are going to
    learn in *Chapter 6*, *Go Packages and Functions*, the case of the first character
    of a variable name has a special meaning in Go and changes its visibility. So
    this works for the `main` package only.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我更喜欢通过以下方式使全局变量突出：要么以大写字母开头，要么使用全部大写字母。正如你将在*第6章*，*Go包和函数*中学习的，变量名首字符的大小写有特殊含义，在Go中会改变其可见性。因此，这仅适用于`main`包。
- en: 'This above program contains the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序包含以下内容：
- en: A global `int` variable named `Global`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`Global`的全局`int`变量。
- en: A second global variable named `AnotherGlobal`—Go automatically infers its data
    type from its value, which in this case is an integer.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个名为`AnotherGlobal`的全局变量——Go自动从其值推断其数据类型，在这种情况下是一个整数。
- en: A local variable named `j` of type `int`, which, as you will learn in the next
    chapter, is a special data type. `j` does not have an initial value, which means
    that Go automatically assigns the zero value of its data type, which in this case
    is `0`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`j`的局部变量，其类型为`int`，正如你将在下一章学习的，这是一个特殊的数据类型。`j`没有初始值，这意味着Go自动将其数据类型的零值分配给它，在这种情况下是`0`。
- en: Another local variable named `i`—Go infers its data type from its value. As
    it is the sum of two `int` values, it is also an `int`.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个名为`i`的局部变量——Go从其值推断其数据类型。由于它是两个`int`值的和，它也是一个`int`。
- en: As `math.Abs()` requires a `float64` parameter, you cannot pass `AnotherGlobal`
    to it because `AnotherGlobal` is an `int` variable. The `float64()` **type cast**
    converts the value of `AnotherGlobal` to `float64`. Note that `AnotherGlobal`
    continues to have the `int` data type.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`math.Abs()`需要一个`float64`参数，你不能将`AnotherGlobal`传递给它，因为`AnotherGlobal`是一个`int`变量。`float64()`类型转换将`AnotherGlobal`的值转换为`float64`。请注意，`AnotherGlobal`仍然具有`int`数据类型。
- en: Lastly, `fmt.Printf()` formats and prints the output.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`fmt.Printf()`格式化和打印输出。
- en: 'Running `variables.go` produces the following output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`variables.go`产生以下输出：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example demonstrated another important Go rule that was also mentioned
    previously: **Go does not allow implicit data conversions like C**. As presented
    in `variables.go`, the `math.Abs()` function that expects (requires) a `float64`
    value cannot work with an `int` value, even if this particular conversion is straightforward
    and error-free. The Go compiler refuses to compile such statements. You should
    convert the `int` value to a `float64` explicitly using `float64()` for things
    to work properly.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了另一个重要的Go规则，这个规则之前也提到过：**Go不允许像C那样的隐式数据转换**。正如在`variables.go`中展示的，期望（需要）`float64`值的`math.Abs()`函数不能与`int`值一起工作，即使这个特定的转换是直接且无错误的。Go编译器拒绝编译这样的语句。你应该使用`float64()`显式地将`int`值转换为`float64`，以便事情能够正常工作。
- en: For conversions that are not straightforward (for example, `string` to `int`),
    there exist specialized functions that allow you to catch issues with the conversion,
    in the form of an `error` variable that is returned by the function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不直接（例如，`string`到`int`）的转换，存在专门的函数，允许你捕获转换中的问题，以函数返回的错误变量形式。
- en: Controlling program flow
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制程序流程
- en: So far, we have seen Go variables, but how do we change the flow of a Go program
    based on the value of a variable or some other condition? Go supports the `if/else`
    and `switch` control structures. Both control structures can be found in most
    modern programming languages, so if you have already programmed in another programming
    language, you should already be familiar with both `if` and `switch` statements.
    `if` statements use no parenthesis to embed the conditions that need to be examined
    because Go does not use parentheses in general. As expected, `if` has support
    for `else` and `else if` statements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Go变量，但我们是如何根据变量的值或其他条件来改变Go程序的流程的呢？Go支持`if/else`和`switch`控制结构。这两种控制结构在大多数现代编程语言中都可以找到，所以如果你已经使用过其他编程语言进行编程，你应该已经熟悉了`if`和`switch`语句。`if`语句不需要括号来嵌入需要检查的条件，因为Go通常不使用括号。正如预期的那样，`if`支持`else`和`else
    if`语句。
- en: 'To demonstrate the use of `if`, let us use a very common pattern in Go that
    is used almost everywhere. This pattern says that if the value of an error variable
    as returned from a function is `nil`, then everything is OK with the function
    execution. Otherwise, there is an error condition somewhere that needs special
    care. This pattern is usually implemented as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `if` 的用法，让我们使用 Go 中几乎无处不在的一个非常常见的模式。这个模式表明，如果一个函数返回的错误变量的值为 `nil`，那么函数执行就没有问题。否则，某个地方存在错误条件，需要特别处理。这个模式通常如下实现：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`err` is the variable that holds the error value as returned from a function
    and `!=` means that the value of the err variable is not equal to `nil`. You will
    see similar code multiple times in Go programs.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`err` 是一个变量，用于存储函数返回的错误值，`!=` 表示 `err` 变量的值不等于 `nil`。你将在 Go 程序中多次看到类似的代码。'
- en: Lines beginning with `//` are single-line comments. If you put `//` in the middle
    of a line, then everything after `//` until the end of the line is considered
    a comment. This rule does not apply if `//` is inside a string value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `//` 开头的行是单行注释。如果你在一行的中间放置 `//`，那么从 `//` 到行尾的所有内容都被视为注释。如果 `//` 在字符串值内部，则不适用此规则。
- en: The `switch` statement has two different forms. In the first form, the `switch`
    statement has an expression that is evaluated, whereas in the second form, the
    `switch` statement has no expression to evaluate. In that case, expressions are
    evaluated in each `case` statement, which increases the flexibility of `switch`.
    The main benefit you get from `switch` is that when used properly, it simplifies
    complex and hard-to-read `if-else` blocks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句有两种不同的形式。在第一种形式中，`switch` 语句有一个要评估的表达式，而在第二种形式中，`switch` 语句没有要评估的表达式。在这种情况下，每个
    `case` 语句都会评估表达式，这增加了 `switch` 的灵活性。你从 `switch` 获得的主要好处是，当正确使用时，它可以简化复杂且难以阅读的
    `if-else` 块。'
- en: 'Both `if` and `switch` are illustrated in the following code, which is designed
    to process user input given as command line arguments—please type it and save
    it as `control.go`. For learning purposes, we present the code of `control.go`
    in pieces in order to explain it better:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `if` 和 `switch` 的用法，该代码旨在处理作为命令行参数给出的用户输入——请将其输入并保存为 `control.go`。为了学习目的，我们将
    `control.go` 的代码分块呈现，以便更好地解释它：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This first part contains the expected preamble with the imported packages.
    The implementation of the `main()` function starts next:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含预期的前言，其中包含了导入的包。`main()` 函数的实现紧接着开始：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This part of the program makes sure that you have a single command line argument
    to process, which is accessed as `os.Args[1]`, before continuing. We will cover
    this in more detail later, but you can refer to *Figure 1.2* for more information
    about the `os.Args` slice:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分程序确保在继续之前，你有一个要处理的单个命令行参数，它可以通过 `os.Args[1]` 访问。我们将在稍后更详细地介绍这一点，但你也可以参考 *图
    1.2* 了解更多关于 `os.Args` 切片的信息：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, you see a switch block with four branches. The first three require exact
    string matches and the last one matches everything else. The order of the case
    statements is important because only the first match is executed. The `fallthrough`
    keyword tells Go that after this branch is executed, it will continue with the
    next branch, which in this case is the default branch:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你看到的是一个包含四个分支的 `switch` 块。前三个需要精确的字符串匹配，最后一个匹配所有其他内容。`case` 语句的顺序很重要，因为只有第一个匹配会被执行。`fallthrough`
    关键字告诉 Go，在执行完这个分支后，它将继续执行下一个分支，在这个例子中是默认分支：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As command line arguments are initialized as string values, we need to convert
    user input into an integer value using a separate call, which in this case is
    a call to `strconv.Atoi()`. If the value of the `err` variable is `nil`, then
    the conversion was successful, and we can continue. Otherwise, an error message
    is printed onscreen and the program exits.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令行参数被初始化为字符串值，我们需要使用单独的调用将用户输入转换为整数值，在这个例子中是调用 `strconv.Atoi()`。如果 `err`
    变量的值为 `nil`，则转换成功，我们可以继续。否则，将在屏幕上打印错误消息，程序退出。
- en: 'The following code shows the second form of `switch`, where the condition is
    evaluated at each case branch:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `switch` 的第二种形式，其中条件在每一个分支处被评估：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This gives you more flexibility but requires more thinking when reading the
    code. In this case, the default branch should not be executed, mainly because
    any valid integer value would be caught by the other three branches. Nevertheless,
    the default branch is there, which is good practice because it can catch unexpected
    values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了更多的灵活性，但在阅读代码时需要更多的思考。在这种情况下，默认分支不应该被执行，主要是因为任何有效的整数值都会被其他三个分支捕获。尽管如此，默认分支仍然存在，这是一个好的实践，因为它可以捕获意外的值。
- en: 'Running `control.go` generates the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `control.go` 生成以下输出：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each one of the two switch blocks in `control.go` creates one line of output.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`control.go` 中的两个 switch 块各自创建一行输出。'
- en: Iterating with for loops and range
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 for 循环和 range 迭代
- en: This section is all about iterating in Go. Go supports `for` loops as well as
    the `range` keyword to iterate over all the elements of arrays, slices, and (as
    you will see in *Chapter 3*, *Composite Data Types*) maps, without knowing the
    size of the data structure.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分完全是关于 Go 中的迭代。Go 支持使用 `for` 循环以及 `range` 关键字来迭代数组、切片和（如你将在 *第 3 章*，*复合数据类型*）中看到的映射的所有元素，而不需要知道数据结构的大小。
- en: An example of Go simplicity is the fact that Go provides support for the `for`
    keyword only, instead of including direct support for `while` loops. However,
    depending on how you write a `for` loop, it can function as a `while` loop or
    an infinite loop. Moreover, `for` loops can implement the functionality of JavaScript’s
    `forEach` function when combined with the `range` keyword.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Go 简单性的一个例子是，Go 只提供了对 `for` 关键字的支持，而不是包括对 `while` 循环的直接支持。然而，根据你如何编写 `for` 循环，它可以作为
    `while` 循环或无限循环运行。此外，当与 `range` 关键字结合使用时，`for` 循环可以实现 JavaScript 的 `forEach` 函数的功能。
- en: You need to put curly braces around a `for` loop even if it contains just a
    single statement or no statements at all.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `for` 循环中只有一个语句或没有语句，你也必须将其括在大括号内。
- en: You can also create `for` loops with variables and conditions. A `for` loop
    can be exited with a `break` keyword, and you can skip the current iteration with
    the `continue` keyword.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用变量和条件创建 `for` 循环。`for` 循环可以使用 `break` 关键字退出，你可以使用 `continue` 关键字跳过当前迭代。
- en: 'The following program illustrates the use of `for` on its own and with the
    `range` keyword—type it and save it as `forLoops.go` to execute it afterward:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序说明了 `for` 循环及其与 `range` 关键字结合使用时的用法——将其键入并保存为 `forLoops.go` 以在之后执行：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code illustrates a traditional `for` loop that uses a local variable
    named `i`. This prints the squares of `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`,
    `8`, and `9` onscreen. The square of `10` is not computed and printed because
    it does not satisfy the `10 < 10` condition.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码演示了一个传统的 `for` 循环，它使用了一个名为 `i` 的局部变量。这将在屏幕上打印 `0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`
    和 `9` 的平方。因为 `10` 的平方不满足 `10 < 10` 的条件，所以它没有被计算和打印。
- en: 'The following code is idiomatic Go and produces the same output as the previous
    `for` loop:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是典型的 Go 代码，它产生的输出与之前的 `for` 循环相同：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You might use it, but it is sometimes hard to read, especially for people who
    are new to Go. The following code shows how a `for` loop can simulate a `while`
    loop, which is not supported directly:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会用到它，但它有时很难阅读，尤其是对于刚接触 Go 的人来说。以下代码展示了如何使用 `for` 循环来模拟不支持直接使用的 `while` 循环：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `break` keyword in the `if` condition exits the loop early and acts as the
    loop exit condition. Without an exit condition that is going to be met at some
    point and the `break` keyword, the `for` loop is never going to finish.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 条件中的 `break` 关键字提前退出循环并充当循环退出条件。如果没有将在某个时刻满足的退出条件以及 `break` 关键字，`for`
    循环将永远不会结束。'
- en: 'Lastly, given a slice, which you can consider as a resizable array, named `aSlice`,
    you iterate over all its elements with the help of `range`, which returns two
    ordered values: **the index of the current element in the slice and its value**.
    If you want to ignore either of these return values, which is not the case here,
    you can use `_` in the place of the value that you want to ignore. If you just
    need the index, you can leave out the second value from `range` entirely without
    using `_`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，给定一个切片，你可以将其视为一个可调整大小的数组，命名为 `aSlice`，你可以通过 `range` 来迭代其所有元素，`range` 返回两个有序值：**切片中当前元素的索引及其值**。如果你想忽略这两个返回值中的任何一个，这里不是这种情况，你可以在想要忽略的值的位置使用
    `_`。如果你只需要索引，你可以完全省略 `range` 的第二个值而不使用 `_`：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you run `forLoops.go`, you get the following output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `forLoops.go`，你会得到以下输出：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The previous output illustrates that the first three `for` loops are equivalent
    and, therefore, produce the same output. The last six lines show the index and
    the value of each element found in `aSlice`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出说明前三个 `for` 循环是等效的，因此产生相同的输出。最后六行显示了在 `aSlice` 中找到的每个元素的索引和值。
- en: Now that we know about `for` loops, let us see how to get user input.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `for` 循环，让我们看看如何获取用户输入。
- en: Getting user input
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户输入
- en: Getting user input is an important part of the majority of programs. This section
    presents two ways of getting user input, which read from standard input and use
    the command line arguments of the program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户输入是大多数程序的重要部分。本节介绍了两种获取用户输入的方法，即从标准输入读取和使用程序的命令行参数。
- en: Reading from standard input
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从标准输入读取
- en: The `fmt.Scanln()` function can help you read user input while the program is
    already running and store it to a string variable, which is passed as a pointer
    to `fmt.Scanln()`. The `fmt` package contains additional functions for reading
    user input from the console (`os.Stdin`), files, or argument lists.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Scanln()` 函数可以在程序运行时帮助您读取用户输入并将其存储到字符串变量中，该变量作为指针传递给 `fmt.Scanln()`。`fmt`
    包包含从控制台（`os.Stdin`）、文件或参数列表中读取用户输入的附加函数。'
- en: The `fmt.Scanln()` function is rarely used to get user input. Usually, user
    input is read from command line arguments or external files. However, interactive
    command line applications need `fmt.Scanln()`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Scanln()` 函数很少用于获取用户输入。通常，用户输入是从命令行参数或外部文件中读取的。然而，交互式命令行应用程序需要使用 `fmt.Scanln()`。'
- en: 'The following code illustrates reading from standard input—type it and save
    it as `input.go`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了从标准输入读取——将其键入并保存为 `input.go`：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While waiting for user input, it is good to let the user know what kind of information
    they have to give, which is the purpose of the `fmt.Printf()` call. The reason
    for not using `fmt.Println()` instead is that `fmt.Println()` automatically appends
    a newline character at the end of the output, which is not what we want here.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待用户输入时，让用户知道他们需要提供的信息类型是很好的，这就是 `fmt.Printf()` 调用的目的。不使用 `fmt.Println()` 的原因是因为
    `fmt.Println()` 会自动在输出末尾添加换行符，而这不是我们想要的。
- en: 'Executing `input.go` generates the following kind of output and user interaction:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `input.go` 生成以下类型的输出和用户交互：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Working with command line arguments
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理命令行参数
- en: Although typing user input when needed might look like a nice idea, this is
    not usually how real software works. Usually, user input is given in the form
    of command line arguments to the executable file. By default, command line arguments
    in Go are stored in the `os.Args` slice.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在需要时输入用户输入可能看起来是个好主意，但这通常不是真实软件的工作方式。通常，用户输入是以命令行参数的形式提供给可执行文件的。默认情况下，Go 中的命令行参数存储在
    `os.Args` 切片中。
- en: The standard Go library also offers the `flag` package for parsing command line
    arguments, but there are better and more powerful alternatives.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Go 库还提供了 `flag` 包来解析命令行参数，但有一些更好、更强大的替代方案。
- en: 'The figure that follows shows the way command line arguments work in Go, which
    is the same as in the C programming language. It is important to know that the
    `os.Args` slice is **properly initialized by Go and is available to the program
    when referenced**. The `os.Args` slice contains `string` values:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了 Go 中命令行参数的工作方式，这与 C 编程语言相同。重要的是要知道 `os.Args` 切片是由 Go 正确初始化的，并且在引用时对程序可用。`os.Args`
    切片包含 `string` 类型的值：
- en: '![A picture containing text, screenshot, font, black  Description automatically
    generated](img/B21003_01_02.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、黑色描述自动生成](img/B21003_01_02.png)'
- en: 'Figure 1.2: How the os.Args slice works'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：os.Args 切片的工作方式
- en: The first command line argument stored in the `os.Args` slice is always the
    file path of the executable. If you use `go run`, you will get a temporary name
    and path; otherwise, it will be the path of the executable as given by the user.
    The remaining command line arguments are what come after the name of the executable—the
    various command line arguments are automatically separated by space characters
    unless they are included in double or single quotes; this depends on the OS.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 `os.Args` 切片中的第一个命令行参数始终是可执行文件的文件路径。如果您使用 `go run`，您将获得一个临时名称和路径；否则，它将是用户提供的可执行文件路径。其余的命令行参数是可执行文件名称之后的参数——各种命令行参数自动由空格字符分隔，除非它们包含在双引号或单引号内；这取决于操作系统。
- en: 'The use of `os.Args` is illustrated in the code that follows, which is to find
    the minimum and the maximum numeric values of its input while ignoring invalid
    input, such as characters and strings. Type the code and save it as `cla.go`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了`os.Args`的使用，目的是在忽略无效输入（如字符和字符串）的情况下找到输入的最小和最大数值。将代码输入并保存为`cla.go`：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As expected, `cla.go` begins with its preamble. The `fmt` package is used for
    printing output, whereas the `os` package is required because `os.Args` is a part
    of it. Lastly, the `strconv` package contains functions for converting strings
    to numeric values. Next, we make sure that we have at least one command line argument:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`cla.go`以它的前言开始。`fmt`包用于打印输出，而`os`包是必需的，因为`os.Args`是其一部分。最后，`strconv`包包含将字符串转换为数值的函数。接下来，我们确保我们至少有一个命令行参数：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Remember that the first element in `os.Args` is always the path of the executable
    file, so `os.Args` is never totally empty. Next, the program checks for errors
    in the same way we looked for them in previous examples. You will learn more about
    errors and error handling in *Chapter 2*, *Basic Go Data Types*:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`os.Args`中的第一个元素总是可执行文件的路径，所以`os.Args`永远不会完全为空。接下来，程序以与之前示例中相同的方式检查错误。你将在*第二章*，*基本Go数据类型*中了解更多关于错误和错误处理的内容。
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, we use the `error` variable returned by `strconv.ParseFloat()`
    to make sure that the call to `strconv.ParseFloat()` was successful and there
    is a valid numeric value to process. Otherwise, we should continue to the next
    command line argument.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们使用`strconv.ParseFloat()`返回的`error`变量来确保对`strconv.ParseFloat()`的调用是成功的，并且有一个有效的数值可以处理。否则，我们应该继续到下一个命令行参数。
- en: The `for` loop is used to iterate over all available command line arguments
    except the first one, which uses an index value of `0`. This is another popular
    technique for working with all command line arguments.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环遍历所有可用的命令行参数（除了第一个，它使用索引值`0`）。这是处理所有命令行参数的另一种流行技术。
- en: 'The following code is used to properly initialize the value of the `min` and
    `max` variables after the first valid command line argument is processed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于在处理第一个有效命令行参数后正确初始化`min`和`max`变量的值：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using `initialized == 0` to test whether this is the first valid command
    line argument. If this is the case, we process the first command line argument
    and initialize the `min` and `max` variables to its value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`initialized == 0`来测试这是否是第一个有效的命令行参数。如果是这种情况，我们处理第一个命令行参数并将`min`和`max`变量初始化为其值。
- en: 'The next code checks whether the current value is our new minimum or maximum—this
    is where the logic of the program is implemented:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码检查当前值是否是新的最小值或最大值——这是程序逻辑实现的地方：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last part of the program is about printing your findings, which are the
    minimum and maximum numeric values of all valid command line arguments. The output
    you get from `cla.go` depends on its input:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分是关于打印你的发现，即所有有效命令行参数的最小和最大数值。从`cla.go`得到的输出取决于其输入：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this case, `a` and `b` are invalid, and the only valid inputs are `-1` and
    `2`, which are the minimum value and maximum value, respectively:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`a`和`b`是无效的，唯一有效的输入是`-1`和`2`，分别是最小值和最大值：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this case, `a` and `b` are invalid input and, therefore, ignored:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`a`和`b`是无效输入，因此被忽略：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the final case, as `cla.go` has no input to process, it prints a help message.
    If you execute the program with no valid input values, for example, `go run cla.go
    a b c`, then the values of both `Min` and `Max` are going to be zero.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，由于`cla.go`没有要处理的输入，它将打印一条帮助信息。如果你不带有效输入值执行程序，例如，`go run cla.go a b
    c`，那么`Min`和`Max`的值都将为零。
- en: The next subsection shows a technique for differentiating between different
    data types, using error variables.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节展示了使用错误变量区分不同数据类型的技术。
- en: Using error variables to differentiate between input types
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用错误变量来区分输入类型
- en: Now, let me show you a technique that uses error variables to differentiate
    between various kinds of user input. For this technique to work, you should go
    from more specific cases to more generic ones. If we are talking about numeric
    values, you should first examine whether a string is a valid integer before examining
    whether the same string is a floating-point value, because every valid integer
    is also a valid floating-point value.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我向您展示一种使用误差变量来区分各种用户输入的技术。为了使这项技术生效，您应该从更具体的案例逐步过渡到更通用的案例。如果我们谈论数值，您应该首先检查一个字符串是否是有效的整数，然后再检查相同的字符串是否是浮点数值，因为每个有效的整数也是有效的浮点数值。
- en: 'The first part of the program, which is saved as `process.go`, is the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分，保存为 `process.go`，如下所示：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The previous code contains the preamble and the storing of the command line
    arguments in the `arguments` variable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码包含了序言部分以及将命令行参数存储在 `arguments` 变量中的部分。
- en: 'The next part is where we start examining the validity of the input:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分是我们开始检查输入有效性的地方：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we create three variables for keeping a count of the total number of
    valid values examined, the total number of integer values found, and the total
    number of floating-point values found, respectively. The `invalid` variable, which
    is a slice of strings, is used for keeping all non-numeric values.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建三个变量来记录检查的总有效值数、找到的总整数值数和找到的总浮点数值数，分别。`invalid` 变量，它是一个字符串切片，用于存储所有非数值。
- en: Once again, we need to iterate over all the command line arguments except the
    first one, which has an index value of `0`, because this is the path of the executable
    file. We ignore the path of the executable, using `arguments[1:]` instead of just
    `arguments`—selecting a continuous part of a slice is discussed in the next chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们需要遍历除了第一个参数之外的所有命令行参数，因为第一个参数的索引值为 `0`，这是可执行文件的路径。我们忽略可执行文件的路径，使用 `arguments[1:]`
    而不是 `arguments`，选择切片的连续部分将在下一章讨论。
- en: 'The call to `strconv.Atoi()` determines whether we are processing a valid `int`
    value or not. If so, we increase the `total` and `nInts` counters:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`strconv.Atoi()` 的调用确定我们是否正在处理一个有效的 `int` 值。如果是这样，我们将增加 `total` 和 `nInts` 计数器：'
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Similarly, if the examined string represents a valid floating-point value,
    the call to `strconv.ParseFloat()` is going to be successful, and the program
    will update the relevant counters. Lastly, if a value is not numeric, it is appended
    to the `invalid` slice with a call to `append()`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果检查的字符串代表一个有效的浮点数值，`strconv.ParseFloat()` 的调用将会成功，程序将更新相关的计数器。最后，如果一个值不是数值，它将通过调用
    `append()` 追加到 `invalid` 切片中：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last part of the program is the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分如下：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Presented here is extra code that warns you when your invalid input is more
    than the valid one (`len(invalid) > total`). This is a common practice for keeping
    unexpected input in applications.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的额外代码会在您的无效输入多于有效输入时发出警告（`len(invalid) > total`）。这是在应用程序中保持意外输入的常见做法。
- en: 'Running `process.go` produces the following kind of output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `process.go` 会产生以下类型的输出：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this case, we process 1, 2, and 3, which are all valid integer values:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们处理了 1、2 和 3，这些都是有效的整数值：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this case, we have a valid integer, 1, a floating-point value, 2.1, and
    an invalid value, a:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个有效的整数，1，一个浮点数值，2.1，以及一个无效的值，a：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the invalid input is more than the valid one, then `process.go` prints an
    extra error message.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无效输入多于有效输入，那么 `process.go` 将打印额外的错误信息。
- en: The next subsection discusses the concurrency model of Go.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论了 Go 的并发模型。
- en: Understanding the Go concurrency model
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Go 并发模型
- en: This section is a quick introduction to the Go concurrency model. The Go concurrency
    model is implemented using *goroutines* and *channels*. A goroutine is the smallest
    executable Go entity. To create a new goroutine, you have to use the `go` keyword
    followed by a predefined function or an anonymous function—both these methods
    are equivalent as far as Go is concerned.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是 Go 并发模型的快速介绍。Go 并发模型是通过 *goroutines* 和 *channels* 实现的。goroutine 是最小的可执行
    Go 实体。要创建一个新的 goroutine，您必须使用 `go` 关键字后跟一个预定义的函数或匿名函数——这两种方法在 Go 中是等效的。
- en: The `go` keyword works with functions or anonymous functions only.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`go` 关键字仅与函数或匿名函数一起使用。'
- en: A channel in Go is a mechanism that, among other things, allows goroutines to
    communicate and exchange data. If you are an amateur programmer or are hearing
    about goroutines and channels for the first time, do not panic. Goroutines and
    channels, as well as pipelines and sharing data among goroutines, will be explained
    in much more detail in *Chapter 8*, *Go Concurrency*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 channel 是一种机制，它允许 goroutines 通信和交换数据。如果您是业余程序员或第一次听说 goroutines 和 channels，请不要慌张。goroutines
    和 channels，以及管道和 goroutines 之间的数据共享，将在 *第 8 章*，*Go 并发* 中更详细地解释。
- en: Although it is easy to create goroutines, there are other difficulties when
    dealing with concurrent programming, including goroutine synchronization and sharing
    data between goroutines—this is a Go mechanism for avoiding side effects by using
    global state when running goroutines. As `main()` runs as a goroutine as well,
    you do not want `main()` to finish before the other goroutines of the program
    because once `main()` exits, the entire program along with any goroutines that
    have not finished yet will terminate. Although goroutines cannot communicate directly
    with each other, they can share memory. The good thing is that there are various
    techniques for the `main()` function to wait for goroutines to exchange data through
    channels or, less frequently in Go, use shared memory.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建 goroutines 很容易，但在处理并发编程时还有其他困难，包括 goroutine 同步和 goroutines 之间的数据共享——这是
    Go 在运行 goroutines 时使用全局状态来避免副作用的一种机制。由于 `main()` 也是一个 goroutine，您不希望 `main()`
    在其他程序 goroutine 完成之前结束，因为一旦 `main()` 退出，整个程序以及任何尚未完成的 goroutine 都将终止。尽管 goroutines
    不能直接相互通信，但它们可以共享内存。好事是，有各种技术可以让 `main()` 函数等待 goroutines 通过 channels 交换数据，或者在
    Go 中较少使用共享内存。
- en: 'Type the following Go program, which synchronizes goroutines using `time.Sleep()`
    calls (this is not the right way to synchronize goroutines—we will discuss the
    proper way to synchronize goroutines in *Chapter 8*, *Go Concurrency*), into your
    favorite editor, and save it as `goRoutines.go`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 Go 程序，该程序使用 `time.Sleep()` 调用来同步 goroutines（这不是同步 goroutines 的正确方法——我们将在
    *第 8 章*，*Go 并发* 中讨论同步 goroutines 的正确方法），输入您喜欢的编辑器中，并将其保存为 `goRoutines.go`：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding naively implemented example creates four goroutines and prints
    some values on the screen using the `myPrint()` function—the `go` keyword is used
    for creating the goroutines. Running `goRoutines.go` generates the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 之前天真实现的示例创建了四个 goroutines，并使用 `myPrint()` 函数在屏幕上打印一些值——使用 `go` 关键字创建 goroutines。运行
    `goRoutines.go` 生成以下输出：
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, if you run it multiple times, you will most likely get a different
    output each time:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您多次运行它，您很可能会每次得到不同的输出：
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This happens because **goroutines are initialized in a random order and start
    running in a random order**. The Go scheduler is responsible for the execution
    of goroutines, just like the OS scheduler is responsible for the execution of
    the OS threads. *Chapter 8*, *Go Concurrency*, discusses Go concurrency in more
    detail and presents the solution to that randomness issue with the use of a `sync.WaitGroup`
    variable—however, keep in mind that Go concurrency is everywhere, which is the
    main reason for including this section here. Therefore, as some error messages
    generated by the compiler discuss goroutines, you should not think that these
    goroutines were created by you.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 **goroutines 以随机顺序初始化并随机顺序启动**。Go 调度器负责 goroutines 的执行，就像操作系统调度器负责操作系统线程的执行一样。*第
    8 章*，*Go 并发* 详细讨论了 Go 并发，并使用 `sync.WaitGroup` 变量解决了随机性问题——然而，请记住，Go 并发无处不在，这也是在此处包含此部分的主要原因。因此，由于一些编译器生成的错误消息讨论了
    goroutines，您不应认为这些 goroutines 是您创建的。
- en: The next section shows a practical example that involves developing a Go version
    of the `which(1)` utility, which searches for an executable file in the `PATH`
    environment value of the current user.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示一个实际示例，该示例涉及开发 Go 版本的 `which(1)` 工具，该工具在当前用户的 `PATH` 环境值中搜索可执行文件。
- en: Developing the which(1) utility in Go
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中开发 which(1) 工具
- en: Go can work with your operating system through a set of packages. A good way
    of learning a new programming language is by trying to implement simple versions
    of traditional UNIX utilities—in general, the only efficient way to learn a programming
    language is by writing lots of code in that language. In this section, you will
    see a Go version of the `which(1)` utility, which will help you understand the
    way Go interacts with the underlying OS and reads environment variables.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Go可以通过一系列包与您的操作系统交互。通过尝试实现传统UNIX实用程序简单版本来学习一门新编程语言是一个好方法——一般来说，学习一门编程语言的唯一有效方法是大量使用该语言编写代码。在本节中，您将看到`which(1)`实用程序的Go版本，这将帮助您了解Go如何与底层操作系统交互以及如何读取环境变量。
- en: The presented code, which will implement the functionality of `which(1)`, can
    be divided into three logical parts. The first part is about reading the input
    argument, which is the name of the executable file that the utility will be searching
    for. The second part is about reading the value stored in the `PATH` environment
    variable, splitting it, and iterating over the directories of the `PATH` variable.
    The third part is about looking for the desired binary file in these directories
    and determining whether it can be found or not, whether it is a regular file,
    and whether it is an executable file. If the desired executable file is found,
    the program terminates with the help of the `return` statement. Otherwise, it
    will terminate after the `for` loop ends and the `main()` function exits.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的代码，将实现`which(1)`的功能，可以分为三个逻辑部分。第一部分是关于读取输入参数，即实用程序将要搜索的可执行文件名称。第二部分是关于读取存储在`PATH`环境变量中的值，将其分割，并遍历`PATH`变量的目录。第三部分是在这些目录中寻找所需的二进制文件，并确定是否可以找到它，它是否是一个常规文件，以及它是否是一个可执行文件。如果找到了所需的可执行文件，程序将借助`return`语句终止。否则，它将在`for`循环结束后，`main()`函数退出后终止。
- en: 'The presented source file is called `which.go` and is located under the `ch01`
    directory of the GitHub repository of the book. Now, let us see the code, beginning
    with the logical preamble that usually includes the package name, the `import`
    statements, and other definitions with a global scope:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的源文件名为`which.go`，位于书籍GitHub仓库的`ch01`目录下。现在，让我们看看代码，从通常包括包名、`import`语句和其他全局定义的逻辑前言开始：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `fmt` package is used for printing onscreen, the `os` package is for interacting
    with the underlying operating system, and the `path/filepath` package is used
    for working with the contents of the `PATH` variable that is read as a long string,
    depending on the number of directories it contains.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt`包用于在屏幕上打印，`os`包用于与底层操作系统交互，而`path/filepath`包用于处理读取为长字符串的`PATH`变量内容。'
- en: 'The second logical part of the utility is the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第二个逻辑部分如下：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we read the command line arguments of the program (`os.Args`) and save
    the first command line argument into the `file` variable. Then, we get the contents
    of the `PATH` environment variable and split it using `filepath.SplitList()`,
    which offers a portable way of separating a list of paths. Lastly, we iterate
    over all the directories of the `PATH` variable using a `for` loop with `range`,
    as `filepath.SplitList()` returns a slice.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取程序的命令行参数（`os.Args`），并将第一个命令行参数保存到`file`变量中。然后，我们获取`PATH`环境变量的内容，并使用`filepath.SplitList()`进行分割，它提供了一种分离路径列表的便携方式。最后，我们使用`range`和`for`循环遍历`PATH`变量的所有目录，因为`filepath.SplitList()`返回一个切片。
- en: 'The rest of the utility contains the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的其他部分包含以下代码：
- en: '[PRE47]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We construct the full path that we examine using `filepath.Join()`, which is
    used for concatenating the different parts of a path using an OS-specific separator—this
    makes `filepath.Join()` work on all supported operating systems. In this part,
    we also get some lower-level information about the file—keep in mind that UNIX
    considers everything as a file, which means that we want to make sure that we
    are dealing with a regular file that is also executable.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`filepath.Join()`构建要检查的完整路径，它用于使用特定于操作系统的分隔符连接路径的不同部分——这使得`filepath.Join()`能够在所有支持的操作系统上工作。在这一部分，我们还获取有关文件的一些更底层的信息——请记住，UNIX将一切视为文件，这意味着我们想要确保我们正在处理的是一个既是常规文件又是可执行文件的文件。
- en: 'Executing `which.go` generates the following kind of output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`which.go`会生成以下类型的输出：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The last command could not find the `doesNotExist` executable—according to the
    UNIX philosophy and the way UNIX pipes work, utilities generate no output onscreen
    if they have nothing to say.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条命令找不到 `doesNotExist` 可执行文件——根据 UNIX 哲学和 UNIX 管道的工作方式，如果实用工具没有要说的，它们就不会在屏幕上生成输出。
- en: Although it is useful to print error messages onscreen, there are times that
    you need to keep all error messages together and be able to search for them later
    when it is convenient for you. In this case, you need to use one or more log files.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在屏幕上打印错误信息很有用，但有时你需要将所有错误信息集中在一起，以便在方便的时候能够搜索它们。在这种情况下，你需要使用一个或多个日志文件。
- en: The next section discusses logging in Go.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论 Go 语言的登录操作。
- en: Logging information
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志信息
- en: All UNIX systems have their own log files for writing logging information that
    comes from running servers and programs. Usually, most system log files of a UNIX
    system can be found under the `/var/log` directory. However, the log files of
    many popular services, such as Apache and Nginx, can be found elsewhere, depending
    on their configuration.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 UNIX 系统都有自己的日志文件，用于记录运行的服务和程序产生的日志信息。通常，UNIX 系统的大多数系统日志文件都可以在 `/var/log`
    目录下找到。然而，许多流行服务的日志文件，如 Apache 和 Nginx，可能位于其他位置，这取决于它们的配置。
- en: Logging and storing logging information in log files is a practical way of examining
    data and information from your software asynchronously, either locally, at a central
    log server, or using server software such as Elasticsearch, Beats, and Grafana
    Loki.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志文件中记录和存储日志信息是检查软件中的数据和信息的异步方法，无论是在本地、中央日志服务器，还是使用 Elasticsearch、Beats 和 Grafana
    Loki 等服务器软件。
- en: Generally speaking, using a log file to write some information used to be considered
    a better practice than writing the same output on screen for two reasons. Firstly,
    because the output does not get lost, as it is stored on a file, and secondly,
    because you can search and process log files using UNIX tools, such as `grep(1)`,
    `awk(1)`, and `sed(1)`, which cannot be done when messages are printed in a terminal
    window. However, writing to log files is not always the best approach, mainly
    because many services run as Docker images, which have their own log files that
    get lost when the Docker image stops.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，使用日志文件来记录一些信息被认为比在屏幕上输出相同内容是一种更好的实践，原因有两个。首先，因为输出不会丢失，因为它被存储在文件中；其次，因为你可以使用
    UNIX 工具，如 `grep(1)`、`awk(1)` 和 `sed(1)` 来搜索和处理日志文件，而这些操作在终端窗口打印消息时是无法完成的。然而，写入日志文件并不总是最佳方法，主要是因为许多服务作为
    Docker 镜像运行，当 Docker 镜像停止时，它们自己的日志文件也会丢失。
- en: As we usually run our services via `systemd`, programs should log to `stdout`
    so that `systemd` can put logging data in the journal. [https://12factor.net/logs](https://12factor.net/logs)
    offers more information about app logs. Additionally, in cloud-native applications,
    we are encouraged to simply log to `stderr` and let the container system redirect
    the `stderr` stream to the desired destination.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通常通过 `systemd` 运行我们的服务，程序应该将日志记录到 `stdout`，这样 `systemd` 就可以将日志数据放入日志中。[https://12factor.net/logs](https://12factor.net/logs)
    提供了有关应用程序日志的更多信息。此外，在云原生应用程序中，我们被鼓励简单地记录到 `stderr`，并让容器系统将 `stderr` 流重定向到所需的目的地。
- en: The UNIX logging service has support for two properties named *logging level*
    and *logging facility*. The logging level is a value that specifies the severity
    of the log entry. There are various logging levels, including `debug`, `info`,
    `notice`, `warning`, `err`, `crit`, `alert`, and `emerg`, in reverse order of
    severity. The `log` package of the standard Go library does not support working
    with logging levels. The logging facility is like a category used for logging
    information. The value of the logging facility part can be one of `auth`, `authpriv`,
    `cron`, `daemon`, `kern`, `lpr`, `mail`, `mark`, `news`, `syslog`, `user`, `UUCP`,
    `local0`, `local1`, `local2`, `local3`, `local4`, `local5`, `local6`, or `local7`
    and is defined inside `/etc/syslog.conf`, `/etc/rsyslog.conf`, or another appropriate
    file depending on the server process used for system logging on your UNIX machine.
    This means that if a logging facility is not defined correctly, it will not be
    handled; therefore, the log messages you send to it might get ignored and, therefore,
    lost.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 日志服务支持两个名为 *日志级别* 和 *日志设施* 的属性。日志级别是一个指定日志条目严重性的值。有各种日志级别，包括 `debug`、`info`、`notice`、`warning`、`err`、`crit`、`alert`
    和 `emerg`，按照严重性递减的顺序。标准 Go 库的 `log` 包不支持与日志级别一起工作。日志设施类似于用于记录信息的类别。日志设施部分的值可以是
    `auth`、`authpriv`、`cron`、`daemon`、`kern`、`lpr`、`mail`、`mark`、`news`、`syslog`、`user`、`UUCP`、`local0`、`local1`、`local2`、`local3`、`local4`、`local5`、`local6`
    或 `local7` 之一，并且定义在 `/etc/syslog.conf`、`/etc/rsyslog.conf` 或根据在 UNIX 机器上用于系统日志的服务器进程的其他适当文件中。这意味着如果日志设施没有正确定义，它将不会被处理；因此，您发送给它的日志消息可能会被忽略，从而丢失。
- en: The `log` package sends log messages to standard error. Part of the `log` package
    is the `log/syslog` package, which allows you to send log messages to the syslog
    server of your machine. Although by default log writes to standard error, the
    use of `log.SetOutput()` modifies that behavior. The list of functions for sending
    logging data includes `log.Printf()`, `log.Print()`, `log.Println()`, `log.Fatalf()`,
    `log.Fatalln()`, `log.Panic()`, `log.Panicln()`, and `log.Panicf()`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 包将日志消息发送到标准错误。`log` 包的一部分是 `log/syslog` 包，它允许您将日志消息发送到您的机器上的 syslog 服务器。尽管默认情况下日志写入标准错误，但使用
    `log.SetOutput()` 会修改这种行为。用于发送日志数据的函数列表包括 `log.Printf()`、`log.Print()`、`log.Println()`、`log.Fatalf()`、`log.Fatalln()`、`log.Panic()`、`log.Panicln()`
    和 `log.Panicf()`。'
- en: Logging is for application code, not library code. If you are developing libraries,
    do not put logging in them.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是针对应用程序代码，而不是库代码。如果您正在开发库，请不要在其中添加日志记录。
- en: 'In order to write to system logs, you need to call the `syslog.New()` function
    with the appropriate parameters. Writing to the main system log file is as easy
    as calling `syslog.New()` with the `syslog.LOG_SYSLOG` option. After that, you
    need to tell your Go program that all logging information goes to the new logger—this
    is implemented with a call to the `log.SetOutput()` function. The process is illustrated
    in the following code—type it into your favorite plain text editor and save it
    as `systemLog.go`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将日志写入系统日志，您需要使用适当的参数调用 `syslog.New()` 函数。将日志写入主系统日志文件与使用 `syslog.LOG_SYSLOG`
    选项调用 `syslog.New()` 一样简单。之后，您需要告诉您的 Go 程序所有日志信息都发送到新的日志记录器——这是通过调用 `log.SetOutput()`
    函数实现的。这个过程在以下代码中得到了说明——将其输入您最喜欢的纯文本编辑器并保存为 `systemLog.go`：
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After the call to `log.SetOutput()`, all logging information goes to the `syslog`
    logger variable which sends it to `syslog.LOG_SYSLOG`. Custom text for the log
    entries coming from that program is specified as the second parameter to the `syslog.New()`
    call.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `log.SetOutput()` 之后，所有日志信息都发送到 `syslog` 日志变量，该变量将其发送到 `syslog.LOG_SYSLOG`。来自该程序的日志条目的自定义文本作为
    `syslog.New()` 调用的第二个参数指定。
- en: Usually, we want to store logging data in user-defined files because they group
    relevant information, which makes them easier to process and inspect.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望将日志数据存储在用户定义的文件中，因为它们将相关信息分组，这使得它们更容易处理和检查。
- en: 'Running `systemLog.go` generates no output. However, if you execute `journalctl
    -xe` on a Linux machine, you can see entries like the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `systemLog.go` 不会生成任何输出。然而，如果您在 Linux 机器上执行 `journalctl -xe`，您可以看到如下条目：
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The output on your own operating system might be slightly different, but the
    general idea is the same.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您自己的操作系统的输出可能略有不同，但基本思想是相同的。
- en: Bad things happen all the time, even to good people and good software. So the
    next subsection covers the Go way of dealing with bad situations.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 坏事情总是会发生，即使是好人好软件也会遇到。所以下一个小节将介绍 Go 处理不良情况的方式。
- en: log.Fatal() and log.Panic()
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: log.Fatal() 和 log.Panic()
- en: The `log.Fatal()` function is used when something erroneous has happened and
    you just want to exit your program as soon as possible after reporting that bad
    situation. The call to `log.Fatal()` terminates a Go program at the point where
    `log.Fatal()` was called after printing an error message. In most cases, this
    custom error message can be `Not enough arguments`, `Cannot access file`, or similar.
    Additionally, it returns a non-zero exit code, which in UNIX indicates an error.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误并且你只想在报告了这种糟糕的情况后尽快退出程序时，使用`log.Fatal()`函数。`log.Fatal()`调用在打印错误消息后终止Go程序在`log.Fatal()`被调用的位置。在大多数情况下，这个自定义错误消息可以是“参数不足”、“无法访问文件”或类似的内容。此外，它返回一个非零退出代码，在UNIX中表示错误。
- en: There are situations where a program is about to fail for good and you want
    to have as much information about the failure as possible—`log.Panic()` implies
    that something really unexpected and unknown, such as not being able to find a
    file that was previously accessed or not having enough disk space, has happened.
    Analogous to the `log.Fatal()` function, `log.Panic()` prints a custom message
    and immediately terminates the Go program.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个程序即将永久失败，而你希望尽可能多地了解失败的信息——`log.Panic()`暗示了一些真正意外且未知的情况已经发生，例如无法找到之前访问过的文件或磁盘空间不足。类似于`log.Fatal()`函数，`log.Panic()`打印一条自定义消息并立即终止Go程序。
- en: 'Keep in mind that `log.Panic()` is equivalent to a call to `log.Print()`, followed
    by a call to `panic()`. This is a built-in function that stops the execution of
    the current function and begins panicking. After that, it returns to the caller
    function. Conversely, `log.Fatal()` calls `log.Print()` and then `os.Exit(1)`,
    which is an immediate way of terminating the current program. Both `log.Fatal()`
    and `log.Panic()` are illustrated in the `logs.go` file, which contains the following
    Go code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`log.Panic()`等同于调用`log.Print()`，然后调用`panic()`。这是一个内置函数，它会停止当前函数的执行并开始恐慌。之后，它返回到调用函数。相反，`log.Fatal()`调用`log.Print()`然后`os.Exit(1)`，这是一种立即终止当前程序的方式。`log.Fatal()`和`log.Panic()`都在`logs.go`文件中进行了说明，该文件包含以下Go代码：
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you call `logs.go` without any command line arguments, it calls `log.Panic()`.
    Otherwise, it calls `log.Fatal()`. This is illustrated in the following output
    from an Arch Linux system:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有提供任何命令行参数就调用`logs.go`，它将调用`log.Panic()`。否则，它将调用`log.Fatal()`。这在一个Arch Linux系统的以下输出中得到了说明：
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So the output of `log.Panic()` includes additional low-level information that,
    hopefully, will help you resolve difficult situations that arise in your Go code.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`log.Panic()`的输出包括额外的低级信息，希望这些信息能帮助你解决在Go代码中出现的困难情况。
- en: Please keep in mind that both of these functions terminate the program abruptly,
    which may not be what the user wants. As a result, they are not the best way to
    end a program. However, they can be handy for reporting really bad error conditions
    or unexpected situations. Two such examples are when a program is unable to save
    its data or when a configuration file is not found.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这两个函数都会突然终止程序，这可能不是用户想要的。因此，它们不是结束程序的最佳方式。然而，它们在报告真正糟糕的错误条件或意外情况时可能很有用。两个这样的例子是当程序无法保存其数据或配置文件找不到时。
- en: The next subsection is about writing to custom log files.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节是关于将日志写入自定义日志文件。
- en: Writing to a custom log file
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日志写入自定义日志文件
- en: Most of the time, and especially on applications and services that are deployed
    to production, you need to write your logging data in a log file of your choice.
    This can be for many reasons, including writing debugging data without messing
    with the system log files, or keeping your own logging data separate from system
    logs to transfer it or store it in a database or software, like Elasticsearch.
    This subsection teaches you how to write to a custom log file that is usually
    application-specific.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，尤其是在将应用程序和服务部署到生产环境时，你需要将你的日志数据写入你选择的日志文件。这可能出于许多原因，包括在不干扰系统日志文件的情况下写入调试数据，或者将你的日志数据与系统日志分开，以便将其传输或存储在数据库或软件中，如Elasticsearch。本小节将教你如何写入通常针对特定应用程序的自定义日志文件。
- en: Writing to files and file input and output are both covered in *Chapter 7*,
    *Telling a UNIX System What to Do*—however, saving information to files is very
    handy when troubleshooting and debugging Go code, which is why this is covered
    in the first chapter.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件以及文件输入输出都在*第7章*，*告诉UNIX系统做什么*中进行了介绍——然而，在调试Go代码时将信息保存到文件中非常有用，这就是为什么它被包含在第一章中的原因。
- en: The path of the log file (`mGo.log`) that is used is stored on a variable named
    `LOGFILE`—this is created using the `os.TempDir()` function, which returns the
    default directory used on the current OS for temporary files, in order to prevent
    your file system from getting full in case something goes wrong.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的日志文件路径（`mGo.log`）存储在一个名为 `LOGFILE` 的变量中——这是通过使用 `os.TempDir()` 函数创建的，该函数返回当前操作系统用于临时文件的默认目录，以防止在出现错误时文件系统变满。
- en: Additionally, at this point, this will save you from having to execute `customLog.go`
    with root privileges and putting unnecessary files into precious system directories.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在此阶段，这将让您免于需要以 root 权限执行 `customLog.go` 并将不必要的文件放入宝贵的系统目录中。
- en: 'Type the following code and save it as `customLog.go`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码并将其保存为 `customLog.go`：
- en: '[PRE53]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `defer` keyword tells Go to execute the statement just before the current
    function returns. This means that `f.Close()` is going to be executed just before
    `main()` returns. We will go into more detail on `defer` in *Chapter 6*, *Go Packages
    and Functions*:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 关键字告诉 Go 在当前函数返回之前执行语句。这意味着 `f.Close()` 将在 `main()` 返回之前执行。我们将在 *第
    6 章*，*Go 包和函数* 中更详细地介绍 `defer`。'
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The last three statements create a new log file based on an opened file (`f`)
    and write two messages to it, using `Println()`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个语句基于一个打开的文件（`f`）创建一个新的日志文件，并使用 `Println()` 向其写入两条消息。
- en: If you ever decide to use the code of `customLog.go` in a real application,
    you should change the path stored in `LOGFILE` to something that makes more sense.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定在真实应用中使用 `customLog.go` 的代码，您应该将存储在 `LOGFILE` 中的路径更改为更有意义的内容。
- en: 'Running `customLog.go` on an Arch Linux machine prints the file path of the
    log file:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 Arch Linux 机器上运行 `customLog.go` 会打印日志文件的路径：
- en: '[PRE55]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Depending on your operating system, your output might vary. However, what is
    important is what has been written in the custom log file:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统，您的输出可能会有所不同。然而，重要的是在自定义日志文件中写入的内容：
- en: '[PRE56]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The next subsection shows how to print line numbers in log entries.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将展示如何在日志条目中打印行号。
- en: Printing line numbers in log entries
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在日志条目中打印行号
- en: In this subsection, you will learn how to print the filename as well as the
    line number in the source file where the statement that wrote a log entry is located.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将学习如何打印写入日志条目的语句所在的源文件中的文件名以及行号。
- en: The desired functionality is implemented with the use of `log.Lshortfile` in
    the parameters of `log.New()` or `SetFlags()`. The `log.Lshortfile` flag adds
    the filename as well as the line number of the Go statement that printed the log
    entry in the log entry itself. If you use `log.Llongfile` instead of `log.Lshortfile`,
    then you get the full path of the Go source file—usually, this is not necessary,
    especially when you have a really long path.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的功能是通过在 `log.New()` 或 `SetFlags()` 的参数中使用 `log.Lshortfile` 来实现的。`log.Lshortfile`
    标志将文件名以及打印日志条目的 Go 语句的行号添加到日志条目本身中。如果您使用 `log.Llongfile` 而不是 `log.Lshortfile`，则获取
    Go 源文件的完整路径——通常，这并不是必需的，尤其是当路径非常长时。
- en: 'Type the following code and save it as `customLogLineNumber.go`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码并将其保存为 `customLogLineNumber.go`：
- en: '[PRE57]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In case you are wondering, you are allowed to change the format of the log entries
    during program execution—this means that when there is a reason, you can print
    more analytical information in the log entries. This is implemented with multiple
    calls to `iLog.SetFlags()`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道，您可以在程序执行期间更改日志条目的格式——这意味着当有理由时，您可以在日志条目中打印更多分析信息。这是通过多次调用 `iLog.SetFlags()`
    来实现的。
- en: 'Running `customLogLineNumber.go` generates the following output:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `customLogLineNumber.go` 生成以下输出：
- en: '[PRE58]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It also writes the following entries in the file path that is specified by
    the value of the `LOGFILE` global variable:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会在由 `LOGFILE` 全局变量值指定的文件路径中写入以下条目：
- en: '[PRE59]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The first error message is from source code line 25, whereas the second one
    is from source code line 28.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误信息来自源代码的第 25 行，而第二个来自第 28 行。
- en: You will most likely get a different output on your own machine, which is the
    expected behavior.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您在自己的机器上可能会得到不同的输出，这是预期的行为。
- en: Writing to multiple log files
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向多个日志文件写入
- en: 'This subsection shows a technique for writing to multiple log files—this is
    illustrated in `multipleLogs.go`, which can be found in the GitHub repository
    of the book under directory `ch01` and comes with the following code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节展示了向多个日志文件写入的技术——这通过 `multipleLogs.go` 来说明，该文件可以在书的 GitHub 仓库的 `ch01` 目录下找到，并包含以下代码：
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `io.MultiWriter()` function is what allows us to write to multiple destinations,
    which in this case are a file named `myLog.log` and standard error.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.MultiWriter()` 函数使我们能够写入多个目的地，在这种情况下是一个名为 `myLog.log` 的文件和标准错误。'
- en: 'The results of running `multipleLogs.go` can be seen in the `myLog.log` file,
    which is going to be created in the current working directory, and to standard
    error, which is usually presented on screen:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `multipleLogs.go` 的结果可以在 `myLog.log` 文件中看到，该文件将在当前工作目录中创建，并输出到标准错误，通常在屏幕上显示：
- en: '[PRE61]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The contents of `myLog.log` are the same as before:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`myLog.log` 文件的内容与之前相同：'
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the next section, we are going to write the first version of the statistics
    application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将编写统计应用的第一个版本。
- en: Developing a statistics application
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发统计应用
- en: In this section, we are going to develop a basic statistics application stored
    in `stats.go`. The statistical application is going to be improved and enriched
    with new features throughout this book.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个存储在 `stats.go` 中的基本统计应用。在整个书中，统计应用将得到改进和增强，增加新功能。
- en: 'The first part of `stats.go` is the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats.go` 的第一部分如下：'
- en: '[PRE63]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this first part of the application, the necessary Go packages are imported
    before the `main()` function makes sure that we have at least a single command
    line parameter to work with, using `len(arguments) == 1`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的第一部分，在 `main()` 函数之前导入必要的 Go 包，确保我们至少有一个命令行参数可以工作，使用 `len(arguments) ==
    1`。
- en: 'The second part of `stats.go` is the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats.go` 的第二部分如下：'
- en: '[PRE64]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the previous code excerpt, we process all valid inputs to count the number
    of valid values and find the minimum and the maximum values among them.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们处理所有有效的输入来计算有效值的数量，并找出其中的最小值和最大值。
- en: 'The last part of `stats.go` is the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats.go` 文件的最后部分如下：'
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the previous code excerpt, we find the *mean value* because this cannot be
    computed without processing all values first. After that, we process each valid
    value to compute the *standard deviation* because the mean value is required in
    order to compute the standard deviation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们找到平均值，因为在不处理所有值之前无法计算。之后，我们处理每个有效值来计算标准差，因为需要平均值来计算标准差。
- en: 'Running `stats.go` generates the following kind of output:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `stats.go` 会生成以下类型的输出：
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: At the beginning of this chapter, we discussed the advantages, disadvantages,
    philosophy, and history of Go. Then, the basics of Go were presented, which include
    variables, iterations, and flow control as well as how to log data.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了 Go 的优点、缺点、哲学和历史。然后，介绍了 Go 的基础知识，包括变量、迭代和流程控制，以及如何记录数据。
- en: After that, we learned about logging, implemented `which(1)`, and created a
    basic statistics application.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们学习了日志记录，实现了 `which(1)`，并创建了一个基本的统计应用。
- en: The next chapter is all about the basic Go data types.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍基本的 Go 数据类型。
- en: Exercises
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Test out what you have learned by trying to complete the following exercises:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尝试完成以下练习来测试你所学的知识：
- en: Read the documentation of the `fmt` package using `go doc`.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `go doc` 读取 `fmt` 包的文档。
- en: In UNIX, an exit code of `0` means success, whereas a non-zero exit code usually
    means failure. Try to modify `which.go` to do so with the help of `os.Exit()`.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 UNIX 中，退出码 `0` 表示成功，而非零退出码通常表示失败。尝试修改 `which.go` 以使用 `os.Exit()` 来实现这一点。
- en: The current version of `which(1)` stops after finding the first occurrence of
    the desired executable. Make the necessary code changes to `which.go` in order
    to find all possible occurrences of the desired executable.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前版本的 `which(1)` 在找到第一个所需的可执行文件后停止。为了找到所有可能的可执行文件，需要对 `which.go` 进行必要的代码更改。
- en: Additional resources
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The official Go website: [https://go.dev/](https://go.dev/)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Go 网站：[https://go.dev/](https://go.dev/)
- en: 'The Go Playground: [https://go.dev/play/](https://go.dev/play/)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 编程语言沙盒：[https://go.dev/play/](https://go.dev/play/)
- en: 'The `log` package: [https://pkg.go.dev/log](https://pkg.go.dev/log)'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log` 包：[https://pkg.go.dev/log](https://pkg.go.dev/log)'
- en: 'Elasticsearch Beats: [https://www.elastic.co/beats/](https://www.elastic.co/beats/)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elasticsearch Beats：[https://www.elastic.co/beats/](https://www.elastic.co/beats/)
- en: 'Grafana Loki: [https://grafana.com/oss/loki/](https://grafana.com/oss/loki/)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana Loki：[https://grafana.com/oss/loki/](https://grafana.com/oss/loki/)
- en: 'Standard deviation: [https://en.wikipedia.org/wiki/Standard_deviation](https://en.wikipedia.org/wiki/Standard_deviation)'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准差：[https://en.wikipedia.org/wiki/Standard_deviation](https://en.wikipedia.org/wiki/Standard_deviation)
- en: 'Microsoft Visual Studio: [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '微软Visual Studio: [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)'
- en: 'The Standard Go library: [https://pkg.go.dev/std](https://pkg.go.dev/std)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '标准Go库: [https://pkg.go.dev/std](https://pkg.go.dev/std)'
- en: 'The `godoc` utility: [https://pkg.go.dev/golang.org/x/tools/cmd/godoc](https://pkg.go.dev/golang.org/x/tools/cmd/godoc)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`godoc`工具: [https://pkg.go.dev/golang.org/x/tools/cmd/godoc](https://pkg.go.dev/golang.org/x/tools/cmd/godoc)'
- en: Leave a review!
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论来帮助像你一样的读者。扫描下面的二维码，获取你选择的免费电子书。
- en: '![](img/Review_QR_Code.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![评论二维码](img/Review_QR_Code.png)'
