<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer054">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 class="chapterTitle" id="_idParaDest-50"><span class="koboSpan" id="kobo.2.1">Basic Go Data Types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Data is stored and manipulated in variables—all Go variables should have a data type that is either determined implicitly or declared explicitly. </span><span class="koboSpan" id="kobo.3.2">Knowing the built-in data types of Go allows you to understand how to manipulate simple data values and construct more complex data structures when simple data types are not enough or not efficient for a job. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.4.1">Go being a statically typed and compiled programming language</span></strong><span class="koboSpan" id="kobo.5.1"> allows the compiler to perform various optimizations and checks prior to program execution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">The first part of this chapter is all about the basic data types of Go, and the second part logically follows, covering the data structures that allow you to group data of the same data type, which are arrays and the much more powerful slices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.7.1">But let us begin with something more practical: imagine that you want to read data as command line arguments. </span><span class="koboSpan" id="kobo.7.2">How can you be sure that what you have read was what you expected? </span><span class="koboSpan" id="kobo.7.3">How can you handle error situations? </span><span class="koboSpan" id="kobo.7.4">What about reading not just numbers and strings but dates and times from the command line? </span><span class="koboSpan" id="kobo.7.5">Do you have to write your own parser for working with dates and times?</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.8.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.9.1">Chapter 1</span></em><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">A Quick Introduction to Go</span></em><span class="koboSpan" id="kobo.12.1">, we included the entire code of the presented source files. </span><span class="koboSpan" id="kobo.12.2">However, starting from this chapter, this will not always be the case. </span><span class="koboSpan" id="kobo.12.3">This serves two purposes: the first one is that you get to see the code that really matters, and the second one is that we save book space.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.13.1">This chapter will answer all these questions and many more, such as working with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.14.1">unsafe</span></code><span class="koboSpan" id="kobo.15.1"> package, the internals of slices and how slices are connected to arrays, and how to work with pointers in Go. </span><span class="koboSpan" id="kobo.15.2">Additionally, it implements utilities that generate random numbers and random strings and updates the statistics application. </span><span class="koboSpan" id="kobo.15.3">So, this chapter covers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">error</span></code><span class="koboSpan" id="kobo.18.1"> data type</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Numeric data types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Non-numeric data types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Constants</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Grouping similar data</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">Pointers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">Data types and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.25.1">unsafe</span></code><span class="koboSpan" id="kobo.26.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">Generating random numbers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.28.1">Updating the statistics application</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.29.1">We begin this chapter with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.30.1">error</span></code><span class="koboSpan" id="kobo.31.1"> data type because errors and error handling play a key role in Go.</span></p>
<h1 class="heading-1" id="_idParaDest-51"><span class="koboSpan" id="kobo.32.1">The error data type</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.33.1">Go provides a special data type, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.34.1">error</span></code><span class="koboSpan" id="kobo.35.1">, for representing error conditions and error messages—in practice, this means that Go treats errors as values. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.36.1">To program successfully in Go, you should be aware of the error conditions that might occur with the functions and methods you are using and handle them accordingly</span></strong><span class="koboSpan" id="kobo.37.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.38.1">As you already know from the</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.39.1"> previous chapter, Go follows a particular convention concerning error values: if the value of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.40.1">error</span></code><span class="koboSpan" id="kobo.41.1"> variable is </span><code class="inlineCode"><span class="koboSpan" id="kobo.42.1">nil</span></code><span class="koboSpan" id="kobo.43.1">, then there is no error. </span><span class="koboSpan" id="kobo.43.2">As an example, let us consider </span><code class="inlineCode"><span class="koboSpan" id="kobo.44.1">strconv.Atoi()</span></code><span class="koboSpan" id="kobo.45.1">, which is used for converting a </span><code class="inlineCode"><span class="koboSpan" id="kobo.46.1">string</span></code><span class="koboSpan" id="kobo.47.1"> value into an </span><code class="inlineCode"><span class="koboSpan" id="kobo.48.1">int</span></code><span class="koboSpan" id="kobo.49.1"> value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">Atoi</span></code><span class="koboSpan" id="kobo.51.1"> stands for </span><em class="italic"><span class="koboSpan" id="kobo.52.1">ASCII to Int</span></em><span class="koboSpan" id="kobo.53.1">). </span><span class="koboSpan" id="kobo.53.2">As specified by its signature, </span><code class="inlineCode"><span class="koboSpan" id="kobo.54.1">strconv.Atoi()</span></code><span class="koboSpan" id="kobo.55.1"> returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.56.1">(int, error)</span></code><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">Having an error value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.58.1">nil</span></code><span class="koboSpan" id="kobo.59.1"> means that the conversion was successful and that you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.60.1">int</span></code><span class="koboSpan" id="kobo.61.1"> value if you want. </span><span class="koboSpan" id="kobo.61.2">Having an error value that is not </span><code class="inlineCode"><span class="koboSpan" id="kobo.62.1">nil</span></code><span class="koboSpan" id="kobo.63.1"> means that the conversion was unsuccessful and that the string input is not a valid </span><code class="inlineCode"><span class="koboSpan" id="kobo.64.1">int</span></code><span class="koboSpan" id="kobo.65.1"> value.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.66.1">If you want to learn more about </span><code class="inlineCode"><span class="koboSpan" id="kobo.67.1">strconv.Atoi()</span></code><span class="koboSpan" id="kobo.68.1">, you should execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.69.1">go doc strconv.Atoi</span></code><span class="koboSpan" id="kobo.70.1"> in your terminal window.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.71.1">You might wonder what happens if you want to create your own error messages. </span><span class="koboSpan" id="kobo.71.2">Is this possible? </span><span class="koboSpan" id="kobo.71.3">Should you wish to return a custom error, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">errors.New()</span></code><span class="koboSpan" id="kobo.73.1"> from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">errors</span></code><span class="koboSpan" id="kobo.75.1"> package. </span><span class="koboSpan" id="kobo.75.2">This usually happens inside a function other than </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">main()</span></code><span class="koboSpan" id="kobo.77.1"> because </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">main()</span></code><span class="koboSpan" id="kobo.79.1"> does not return anything to any other function. </span><span class="koboSpan" id="kobo.79.2">Additionally, a good place to define your custom errors is inside the Go packages you create.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.80.1">You will most likely work with errors in your programs without needing the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.81.1">errors</span></code><span class="koboSpan" id="kobo.82.1"> package. </span><span class="koboSpan" id="kobo.82.2">Additionally, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.83.1">you are not going to need to define custom error messages unless you are creating big applications or packages</span></strong><span class="koboSpan" id="kobo.84.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">If you want to format your error messages in the way </span><code class="inlineCode"><span class="koboSpan" id="kobo.86.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.87.1"> works, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">fmt.Errorf()</span></code><span class="koboSpan" id="kobo.89.1"> function, which simplifies the creation of custom error messages—the </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">fmt.Errorf()</span></code><span class="koboSpan" id="kobo.91.1"> function returns</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.92.1"> an </span><code class="inlineCode"><span class="koboSpan" id="kobo.93.1">error</span></code><span class="koboSpan" id="kobo.94.1"> value just like </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">errors.New()</span></code><span class="koboSpan" id="kobo.96.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.97.1">Now, we should talk about something important: you should have a global error-handling tactic in each application that should not change. </span><span class="koboSpan" id="kobo.97.2">In practice, this means the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.98.1">All error messages should be handled at the same level, which means that all errors should either be returned to the calling function or be handled at the place they occurred.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.99.1">The handling of critical errors should be clearly documented. </span><span class="koboSpan" id="kobo.99.2">This means that there will be situations where a critical error should terminate the program and other times where a critical error might just create a warning message onscreen and continue.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.100.1">It is considered a good practice to send all error messages to the log service of your machine because this way the error messages can be examined later. </span><span class="koboSpan" id="kobo.100.2">However, this is not always true, so exercise caution when setting this up—for example, cloud-native apps do not work that way. </span><span class="koboSpan" id="kobo.100.3">For cloud-native apps it is better to send the error output to standard error so that the error messages do not get lost.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.101.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">error</span></code><span class="koboSpan" id="kobo.103.1"> data type is defined as an interface—interfaces are covered in </span><em class="chapterRef"><span class="koboSpan" id="kobo.104.1">Chapter 5</span></em><span class="koboSpan" id="kobo.105.1">, </span><em class="italic"><span class="koboSpan" id="kobo.106.1">Reflection and Interfaces</span></em><span class="koboSpan" id="kobo.107.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.108.1">Type the following code in your favorite text editor and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">error.go</span></code><span class="koboSpan" id="kobo.110.1"> in the directory where you put the code for this chapter. </span><span class="koboSpan" id="kobo.110.2">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">ch02</span></code><span class="koboSpan" id="kobo.112.1"> as the directory name is a good idea.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.113.1">package</span></span><span class="koboSpan" id="kobo.114.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.115.1">import</span></span><span class="koboSpan" id="kobo.116.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.117.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.118.1">errors"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.119.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.120.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.121.1">"strconv"</span></span><span class="koboSpan" id="kobo.122.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.123.1">The first part is the preamble of the program—</span><code class="inlineCode"><span class="koboSpan" id="kobo.124.1">error.go</span></code><span class="koboSpan" id="kobo.125.1"> uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">fmt</span></code><span class="koboSpan" id="kobo.127.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.128.1">os</span></code><span class="koboSpan" id="kobo.129.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.130.1">strconv</span></code><span class="koboSpan" id="kobo.131.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">errors</span></code><span class="koboSpan" id="kobo.133.1"> packages.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.134.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.135.1">check</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.136.1">(a, b </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.137.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.138.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.139.1">error</span></span><span class="koboSpan" id="kobo.140.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.141.1">if</span></span><span class="koboSpan" id="kobo.142.1"> a == </span><span class="hljs-number"><span class="koboSpan" id="kobo.143.1">0</span></span><span class="koboSpan" id="kobo.144.1"> &amp;&amp; b == </span><span class="hljs-number"><span class="koboSpan" id="kobo.145.1">0</span></span><span class="koboSpan" id="kobo.146.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.147.1">return</span></span><span class="koboSpan" id="kobo.148.1"> errors.New(</span><span class="hljs-string"><span class="koboSpan" id="kobo.149.1">"this is a custom error message"</span></span><span class="koboSpan" id="kobo.150.1">)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.151.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.152.1">nil</span></span><span class="koboSpan" id="kobo.153.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.154.1">The preceding code</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.155.1"> implements a function named </span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">check()</span></code><span class="koboSpan" id="kobo.157.1"> that returns an </span><code class="inlineCode"><span class="koboSpan" id="kobo.158.1">error</span></code><span class="koboSpan" id="kobo.159.1"> value. </span><span class="koboSpan" id="kobo.159.2">If both input parameters of </span><code class="inlineCode"><span class="koboSpan" id="kobo.160.1">check()</span></code><span class="koboSpan" id="kobo.161.1"> are equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.162.1">0</span></code><span class="koboSpan" id="kobo.163.1">, the function returns a custom error message using </span><code class="inlineCode"><span class="koboSpan" id="kobo.164.1">errors.New()</span></code><span class="koboSpan" id="kobo.165.1">—otherwise it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">nil</span></code><span class="koboSpan" id="kobo.167.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.168.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.169.1">formattedError</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.170.1">(a, b </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.171.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.172.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.173.1">error</span></span><span class="koboSpan" id="kobo.174.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.175.1">if</span></span><span class="koboSpan" id="kobo.176.1"> a == </span><span class="hljs-number"><span class="koboSpan" id="kobo.177.1">0</span></span><span class="koboSpan" id="kobo.178.1"> &amp;&amp; b == </span><span class="hljs-number"><span class="koboSpan" id="kobo.179.1">0</span></span><span class="koboSpan" id="kobo.180.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.181.1">return</span></span><span class="koboSpan" id="kobo.182.1"> fmt.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.183.1">"a %d and b %d. </span><span class="koboSpan" id="kobo.183.2">UserID: %d"</span></span><span class="koboSpan" id="kobo.184.1">, a, b, os.Getuid())
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.185.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.186.1">nil</span></span><span class="koboSpan" id="kobo.187.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.188.1">The preceding code implements </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">formattedError()</span></code><span class="koboSpan" id="kobo.190.1">, which is a function that returns a formatted error message using </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">fmt.Errorf()</span></code><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">Among other things, the error message prints the user ID of the user who executed the program with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">os.Getuid()</span></code><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">When you want to create a custom error message, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">fmt.Errorf()</span></code><span class="koboSpan" id="kobo.196.1"> gives you more control over the output.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.197.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.198.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.199.1">()</span></span><span class="koboSpan" id="kobo.200.1"> {
    err := check(</span><span class="hljs-number"><span class="koboSpan" id="kobo.201.1">0</span></span><span class="koboSpan" id="kobo.202.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.203.1">10</span></span><span class="koboSpan" id="kobo.204.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.205.1">if</span></span><span class="koboSpan" id="kobo.206.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.207.1">nil</span></span><span class="koboSpan" id="kobo.208.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.209.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.210.1">check() executed normally!"</span></span><span class="koboSpan" id="kobo.211.1">)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.212.1">else</span></span><span class="koboSpan" id="kobo.213.1"> {
        fmt.Println(err)
    }
    err = check(</span><span class="hljs-number"><span class="koboSpan" id="kobo.214.1">0</span></span><span class="koboSpan" id="kobo.215.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.216.1">0</span></span><span class="koboSpan" id="kobo.217.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.218.1">if</span></span><span class="koboSpan" id="kobo.219.1"> err.Error() == </span><span class="hljs-string"><span class="koboSpan" id="kobo.220.1">"this is a custom error message"</span></span><span class="koboSpan" id="kobo.221.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.222.1">"Custom error detected!"</span></span><span class="koboSpan" id="kobo.223.1">)
    }
    err = formattedError(</span><span class="hljs-number"><span class="koboSpan" id="kobo.224.1">0</span></span><span class="koboSpan" id="kobo.225.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.226.1">0</span></span><span class="koboSpan" id="kobo.227.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.228.1">if</span></span><span class="koboSpan" id="kobo.229.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.230.1">nil</span></span><span class="koboSpan" id="kobo.231.1"> {
        fmt.Println(err)
    }
    i, err := strconv.Atoi(</span><span class="hljs-string"><span class="koboSpan" id="kobo.232.1">"-123"</span></span><span class="koboSpan" id="kobo.233.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.234.1">if</span></span><span class="koboSpan" id="kobo.235.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.236.1">nil</span></span><span class="koboSpan" id="kobo.237.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.238.1">"Int value is"</span></span><span class="koboSpan" id="kobo.239.1">, i)
    }
    i, err = strconv.Atoi(</span><span class="hljs-string"><span class="koboSpan" id="kobo.240.1">"Y123"</span></span><span class="koboSpan" id="kobo.241.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.242.1">if</span></span><span class="koboSpan" id="kobo.243.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.244.1">nil</span></span><span class="koboSpan" id="kobo.245.1"> {
        fmt.Println(err)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.246.1">The preceding code is the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">main()</span></code><span class="koboSpan" id="kobo.248.1"> function where you can see the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">if err != nil</span></code><span class="koboSpan" id="kobo.250.1"> statement multiple times as well as the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">if err == nil</span></code><span class="koboSpan" id="kobo.252.1">, which is used to make sure</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.253.1"> that everything was OK before executing the desired code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.254.1">Bear in mind that although the preceding code compares an error message, this is considered a bad practice. </span><span class="koboSpan" id="kobo.254.2">It is better to print an error message when it is not </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">nil</span></code><span class="koboSpan" id="kobo.256.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.257.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">error.go</span></code><span class="koboSpan" id="kobo.259.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.260.1">$ </span></span><span class="koboSpan" id="kobo.261.1">go run error.go
check() ended normally!
</span><span class="koboSpan" id="kobo.261.2">Custom error detected!
</span><span class="koboSpan" id="kobo.261.3">a 0 and b 0. </span><span class="koboSpan" id="kobo.261.4">UserID: 501
Int value is -123
strconv.Atoi: parsing "Y123": invalid syntax
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.262.1">Now that you know about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">error</span></code><span class="koboSpan" id="kobo.264.1"> data type, how to create custom errors, and how to use error values, we will continue with the basic data types of Go that can be logically divided into two main</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.265.1"> categories: </span><em class="italic"><span class="koboSpan" id="kobo.266.1">numeric data types</span></em><span class="koboSpan" id="kobo.267.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.268.1">non-numeric data types</span></em><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">Go also</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.270.1"> supports the </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">bool</span></code><span class="koboSpan" id="kobo.272.1"> data type, which can have a value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">true</span></code><span class="koboSpan" id="kobo.274.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">false</span></code><span class="koboSpan" id="kobo.276.1"> only.</span></p>
<h1 class="heading-1" id="_idParaDest-52"><span class="koboSpan" id="kobo.277.1">Numeric data types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.278.1">Go supports integer, floating-point, and complex number values in various versions depending on the memory space</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.279.1"> they consume—this saves memory and computing time. </span><span class="koboSpan" id="kobo.279.2">Integer data types can be either signed or unsigned, which is not the case for floating-point numbers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.280.1">The table that follows lists the numeric data types of Go.</span></p>
<table class="table-container" id="table001">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.281.1">Data Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.282.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">int8</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.284.1">8-bit signed integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">int16</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.286.1">16-bit signed integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">int32</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.288.1">32-bit signed integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">int64</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.290.1">64-bit signed integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">int</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.292.1">32- or 64-bit signed integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">uint8</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.294.1">8-bit unsigned integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">uint16</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.296.1">16-bit unsigned integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">uint32</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.298.1">32-bit unsigned integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">uint64</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.300.1">64-bit unsigned integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">uint</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.302.1">32- or 64-bit unsigned integer</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.303.1">float32</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.304.1">32-bit floating-point number</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">float64</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.306.1">64-bit floating-point number</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">complex64</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.308.1">Complex number with </span><code class="inlineCode"><span class="koboSpan" id="kobo.309.1">float32</span></code><span class="koboSpan" id="kobo.310.1"> parts</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.311.1">complex128</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.312.1">Complex number with </span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">float64</span></code><span class="koboSpan" id="kobo.314.1"> parts</span></p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="koboSpan" id="kobo.315.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">int</span></code><span class="koboSpan" id="kobo.317.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">uint</span></code><span class="koboSpan" id="kobo.319.1"> data types are special as they are the most efficient sizes for signed and unsigned integers on a given platform and can be either 32 or 64 bits each — their size is defined by Go itself based on the CPU register size. </span><span class="koboSpan" id="kobo.319.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">int</span></code><span class="koboSpan" id="kobo.321.1"> data type is the most widely used numeric data type in Go due to its versatility.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.322.1">The code that follows illustrates the use of numeric data types—you can find the entire program as </span><code class="inlineCode"><span class="koboSpan" id="kobo.323.1">numbers.go</span></code><span class="koboSpan" id="kobo.324.1"> inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">ch02</span></code><span class="koboSpan" id="kobo.326.1"> directory of the book GitHub repository:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.327.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.328.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.329.1">()</span></span><span class="koboSpan" id="kobo.330.1"> {
    c1 := </span><span class="hljs-number"><span class="koboSpan" id="kobo.331.1">12</span></span><span class="koboSpan" id="kobo.332.1"> + </span><span class="hljs-number"><span class="koboSpan" id="kobo.333.1">1i</span></span><span class="koboSpan" id="kobo.334.1">
    c2 := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.335.1">complex</span></span><span class="koboSpan" id="kobo.336.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.337.1">5</span></span><span class="koboSpan" id="kobo.338.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.339.1">7</span></span><span class="koboSpan" id="kobo.340.1">)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.341.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.342.1">Type of c1: %T\n"</span></span><span class="koboSpan" id="kobo.343.1">, c1)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.344.1">"Type of c2: %T\n"</span></span><span class="koboSpan" id="kobo.345.1">, c2)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.346.1">The preceding code creates two complex variables in two different ways—both ways are perfectly valid and equivalent. </span><span class="koboSpan" id="kobo.346.2">Unless you are into mathematics, you will most likely not use complex numbers in</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.347.1"> your programs. </span><span class="koboSpan" id="kobo.347.2">However, the direct support for complex numbers shows how modern Go is.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.348.1">var</span></span><span class="koboSpan" id="kobo.349.1"> c3 </span><span class="hljs-type"><span class="koboSpan" id="kobo.350.1">complex64</span></span><span class="koboSpan" id="kobo.351.1"> = </span><span class="hljs-type"><span class="koboSpan" id="kobo.352.1">complex64</span></span><span class="koboSpan" id="kobo.353.1">(c1 + c2)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.354.1">"c3:"</span></span><span class="koboSpan" id="kobo.355.1">, c3)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.356.1">"Type of c3: %T\n"</span></span><span class="koboSpan" id="kobo.357.1">, c3)
    cZero := c3 - c3
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.358.1">"cZero:"</span></span><span class="koboSpan" id="kobo.359.1">, cZero)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.360.1">The preceding code continues to work with complex numbers by adding and subtracting two pairs of them. </span><span class="koboSpan" id="kobo.360.2">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">cZero</span></code><span class="koboSpan" id="kobo.362.1"> is equal to zero, it is still a complex number and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">complex64</span></code><span class="koboSpan" id="kobo.364.1"> variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.365.1">    x := </span><span class="hljs-number"><span class="koboSpan" id="kobo.366.1">12</span></span><span class="koboSpan" id="kobo.367.1">
    k := </span><span class="hljs-number"><span class="koboSpan" id="kobo.368.1">5</span></span><span class="koboSpan" id="kobo.369.1">
    fmt.Println(x)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.370.1">"Type of x: %T\n"</span></span><span class="koboSpan" id="kobo.371.1">, x)
    div := x / k
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.372.1">"div"</span></span><span class="koboSpan" id="kobo.373.1">, div)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.374.1">In this part, we define two integer variables named </span><code class="inlineCode"><span class="koboSpan" id="kobo.375.1">x</span></code><span class="koboSpan" id="kobo.376.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">k</span></code><span class="koboSpan" id="kobo.378.1">—their data type is identified by Go based on their initial values. </span><span class="koboSpan" id="kobo.378.2">Both are of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.379.1">int</span></code><span class="koboSpan" id="kobo.380.1">, which is what Go prefers to use for storing integer values. </span><span class="koboSpan" id="kobo.380.2">Additionally, when you divide two integer values, you get an integer result even when the division is not perfect. </span><span class="koboSpan" id="kobo.380.3">Therefore, if this is not what you want, you should take extra actions—this is shown in the next code excerpt:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.381.1">var</span></span><span class="koboSpan" id="kobo.382.1"> m, n </span><span class="hljs-type"><span class="koboSpan" id="kobo.383.1">float64</span></span><span class="koboSpan" id="kobo.384.1">
    m = </span><span class="hljs-number"><span class="koboSpan" id="kobo.385.1">1.223</span></span><span class="koboSpan" id="kobo.386.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.387.1">"m, n:"</span></span><span class="koboSpan" id="kobo.388.1">, m, n)
    y := </span><span class="hljs-number"><span class="koboSpan" id="kobo.389.1">4</span></span><span class="koboSpan" id="kobo.390.1"> / </span><span class="hljs-number"><span class="koboSpan" id="kobo.391.1">2.3</span></span><span class="koboSpan" id="kobo.392.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.393.1">"y:"</span></span><span class="koboSpan" id="kobo.394.1">, y)
    divFloat := </span><span class="hljs-type"><span class="koboSpan" id="kobo.395.1">float64</span></span><span class="koboSpan" id="kobo.396.1">(x) / </span><span class="hljs-type"><span class="koboSpan" id="kobo.397.1">float64</span></span><span class="koboSpan" id="kobo.398.1">(k)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.399.1">"divFloat"</span></span><span class="koboSpan" id="kobo.400.1">, divFloat)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.401.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.402.1">Type of divFloat: %T\n"</span></span><span class="koboSpan" id="kobo.403.1">, divFloat)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.404.1">The preceding code works with </span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">float64</span></code><span class="koboSpan" id="kobo.406.1"> values and variables. </span><span class="koboSpan" id="kobo.406.2">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.407.1">n</span></code><span class="koboSpan" id="kobo.408.1"> does not have an initial value, it is automatically assigned with the zero value of its data type, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.409.1">0</span></code><span class="koboSpan" id="kobo.410.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">float64</span></code><span class="koboSpan" id="kobo.412.1"> data type. </span><span class="koboSpan" id="kobo.412.2">Additionally, the code presents a technique for dividing integer values and getting a floating-point result, which is the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">float64()</span></code><span class="koboSpan" id="kobo.414.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">divFloat := float64(x) / float64(k)</span></code><span class="koboSpan" id="kobo.416.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.417.1">This</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.418.1"> is a type conversion where two integers (</span><code class="inlineCode"><span class="koboSpan" id="kobo.419.1">x</span></code><span class="koboSpan" id="kobo.420.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.421.1">k</span></code><span class="koboSpan" id="kobo.422.1">) are converted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.423.1">float64</span></code><span class="koboSpan" id="kobo.424.1"> values. </span><span class="koboSpan" id="kobo.424.2">As the division between two </span><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">float64</span></code><span class="koboSpan" id="kobo.426.1"> values is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.427.1">float64</span></code><span class="koboSpan" id="kobo.428.1"> value, we get the result in the desired data type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.429.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">numbers.go</span></code><span class="koboSpan" id="kobo.431.1"> creates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.432.1">$ </span></span><span class="koboSpan" id="kobo.433.1">go run numbers.go
Type of c1: complex128
Type of c2: complex128
c3: (17+8i)
Type of c3: complex64
cZero: (0+0i)
12
Type of x: int
div 2
m, n: 1.223 0
y: 1.7391304347826086
divFloat 2.4
Type of divFloat: float64
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.434.1">The output shows that both </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">c1</span></code><span class="koboSpan" id="kobo.436.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.437.1">c2</span></code><span class="koboSpan" id="kobo.438.1"> are </span><code class="inlineCode"><span class="koboSpan" id="kobo.439.1">complex128</span></code><span class="koboSpan" id="kobo.440.1"> values, which is the preferred complex data type for the machine on which the code was executed. </span><span class="koboSpan" id="kobo.440.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.441.1">c3</span></code><span class="koboSpan" id="kobo.442.1"> is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.443.1">complex64</span></code><span class="koboSpan" id="kobo.444.1"> value because it was created using </span><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">complex64()</span></code><span class="koboSpan" id="kobo.446.1">. </span><span class="koboSpan" id="kobo.446.2">The value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">n</span></code><span class="koboSpan" id="kobo.448.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.449.1">0</span></code><span class="koboSpan" id="kobo.450.1"> because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.451.1">n</span></code><span class="koboSpan" id="kobo.452.1"> variable was not initialized, which means that Go automatically assigned the zero value of its data type to </span><code class="inlineCode"><span class="koboSpan" id="kobo.453.1">n</span></code><span class="koboSpan" id="kobo.454.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-53"><span class="koboSpan" id="kobo.455.1">Avoiding overflows</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.456.1">As each variable is stored in memory (bits), there is a limit to how much information we can store in the memory space of a </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.457.1">variable. </span><span class="koboSpan" id="kobo.457.2">Although in this subsection we are going to talk about integers, similar rules apply to all numeric data types. </span><span class="koboSpan" id="kobo.457.3">Go comes with constants in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">math</span></code><span class="koboSpan" id="kobo.459.1"> package that represent the maximum and minimum values of integer data types. </span><span class="koboSpan" id="kobo.459.2">For example, for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">int</span></code><span class="koboSpan" id="kobo.461.1"> data type, there exist the </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">math.MaxInt</span></code><span class="koboSpan" id="kobo.463.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">math.MinInt</span></code><span class="koboSpan" id="kobo.465.1"> constants that represent the maximum and minimum allowed values of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">int</span></code><span class="koboSpan" id="kobo.467.1"> variable, respectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.468.1">The important part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">overflows.go</span></code><span class="koboSpan" id="kobo.470.1"> can be found in two </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">for</span></code><span class="koboSpan" id="kobo.472.1"> loops. </span><span class="koboSpan" id="kobo.472.2">The first one concerns determining the maximum </span><code class="inlineCode"><span class="koboSpan" id="kobo.473.1">int</span></code><span class="koboSpan" id="kobo.474.1"> value:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">for</span></span><span class="koboSpan" id="kobo.476.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.477.1">if</span></span><span class="koboSpan" id="kobo.478.1"> i == math.MaxInt {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.479.1">break</span></span><span class="koboSpan" id="kobo.480.1">
    }
    i = i + </span><span class="hljs-number"><span class="koboSpan" id="kobo.481.1">1</span></span><span class="koboSpan" id="kobo.482.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.483.1">In the preceding code, we keep </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.484.1">increasing the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">i</span></code><span class="koboSpan" id="kobo.486.1"> until it reaches </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">math.MaxInt</span></code><span class="koboSpan" id="kobo.488.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.489.1">The next </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">for</span></code><span class="koboSpan" id="kobo.491.1"> loop is about finding out the minimum </span><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">int</span></code><span class="koboSpan" id="kobo.493.1"> value:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.494.1">for</span></span><span class="koboSpan" id="kobo.495.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.496.1">if</span></span><span class="koboSpan" id="kobo.497.1"> i == math.MinInt {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.498.1">break</span></span><span class="koboSpan" id="kobo.499.1">
    }
    i = i - </span><span class="hljs-number"><span class="koboSpan" id="kobo.500.1">1</span></span><span class="koboSpan" id="kobo.501.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.502.1">This time, we keep decreasing the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.503.1">i</span></code><span class="koboSpan" id="kobo.504.1"> until it reaches </span><code class="inlineCode"><span class="koboSpan" id="kobo.505.1">math.MinInt</span></code><span class="koboSpan" id="kobo.506.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.507.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">overflows.go</span></code><span class="koboSpan" id="kobo.509.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.510.1">$ </span></span><span class="koboSpan" id="kobo.511.1">go run overflows.go
Max: 9223372036854775807
Max overflow: -9223372036854775808
Min: -9223372036854775808
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.512.1">Therefore, the maximum </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">int</span></code><span class="koboSpan" id="kobo.514.1"> value on the current platform (MacBook Pro with M1 Max CPU) is </span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">9223372036854775807</span></code><span class="koboSpan" id="kobo.516.1"> and the minimum </span><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">int</span></code><span class="koboSpan" id="kobo.518.1"> value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">-9223372036854775808</span></code><span class="koboSpan" id="kobo.520.1">. </span><span class="koboSpan" id="kobo.520.2">When we try to increase the maximum </span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">int</span></code><span class="koboSpan" id="kobo.522.1"> value, we will get the minimum </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">int</span></code><span class="koboSpan" id="kobo.524.1"> value instead!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.525.1">After learning about numeric data types, it is time to learn about non-numeric data types, which is the subject of the next section.</span></p>
<h1 class="heading-1" id="_idParaDest-54"><span class="koboSpan" id="kobo.526.1">Non-numeric data types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.527.1">Go has support for strings, characters, runes, dates, and </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.528.1">times. </span><span class="koboSpan" id="kobo.528.2">However, Go does not have a dedicated char data type. </span><span class="koboSpan" id="kobo.528.3">In Go, dates and times are the same thing and are represented by the same data type. </span><span class="koboSpan" id="kobo.528.4">However, it is up to you to determine whether a time and date variable contains valid information or not.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.529.1">We begin by explaining the</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.530.1"> string-related data types.</span></p>
<h2 class="heading-2" id="_idParaDest-55"><span class="koboSpan" id="kobo.531.1">Strings, characters, and runes</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.532.1">Go supports the </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">string</span></code><span class="koboSpan" id="kobo.534.1"> data type for representing strings—strings are enclosed within either double quotes or back</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.535.1"> quotes. </span><span class="koboSpan" id="kobo.535.2">A Go string is just </span><em class="italic"><span class="koboSpan" id="kobo.536.1">a collection of bytes</span></em><span class="koboSpan" id="kobo.537.1"> and can be accessed as a whole or as an </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.538.1">array. </span><span class="koboSpan" id="kobo.538.2">A single byte can store any ASCII character—however, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.539.1">multiple bytes are usually needed for storing a single Unicode character</span></strong><span class="koboSpan" id="kobo.540.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.541.1">Nowadays, supporting Unicode characters</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.542.1"> is a common requirement—Go was designed with Unicode support in mind, which is the main reason for having the </span><code class="inlineCode"><span class="koboSpan" id="kobo.543.1">rune</span></code><span class="koboSpan" id="kobo.544.1"> data type. </span><span class="koboSpan" id="kobo.544.2">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">rune</span></code><span class="koboSpan" id="kobo.546.1"> is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.547.1">int32</span></code><span class="koboSpan" id="kobo.548.1"> value that is used for representing a single Unicode code point, which is an integer value that is used for representing single Unicode characters or, less frequently, providing formatting information.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.549.1">Although a </span><code class="inlineCode"><span class="koboSpan" id="kobo.550.1">rune</span></code><span class="koboSpan" id="kobo.551.1"> is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.552.1">int32</span></code><span class="koboSpan" id="kobo.553.1"> value, you cannot compare a </span><code class="inlineCode"><span class="koboSpan" id="kobo.554.1">rune</span></code><span class="koboSpan" id="kobo.555.1"> with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.556.1">int32</span></code><span class="koboSpan" id="kobo.557.1"> value. </span><span class="koboSpan" id="kobo.557.2">Go considers these two data types as totally different.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.558.1">You can create a new </span><em class="italic"><span class="koboSpan" id="kobo.559.1">byte slice</span></em><span class="koboSpan" id="kobo.560.1"> from a given string by using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.561.1">[]byte("A String")</span></code><span class="koboSpan" id="kobo.562.1"> statement. </span><span class="koboSpan" id="kobo.562.2">Given a byte slice variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.563.1">b</span></code><span class="koboSpan" id="kobo.564.1">, you can convert it into a string using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.565.1">string(b)</span></code><span class="koboSpan" id="kobo.566.1"> statement. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.567.1">When working with byte slices that contain Unicode characters, the number of bytes in a byte slice is not always connected to the number of characters in the byte slice, because most Unicode characters require more than one byte for their representation</span></strong><span class="koboSpan" id="kobo.568.1">. </span><span class="koboSpan" id="kobo.568.2">As a result, when you try to print each single byte of a byte slice using </span><code class="inlineCode"><span class="koboSpan" id="kobo.569.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.570.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.571.1">fmt.Print()</span></code><span class="koboSpan" id="kobo.572.1">, the output is not text presented as characters but instead integer values. </span><span class="koboSpan" id="kobo.572.2">If you want to print the contents of a byte slice as text, you should either print it using </span><code class="inlineCode"><span class="koboSpan" id="kobo.573.1">string(byteSliceVar)</span></code><span class="koboSpan" id="kobo.574.1"> or using </span><code class="inlineCode"><span class="koboSpan" id="kobo.575.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.576.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.577.1">%s</span></code><span class="koboSpan" id="kobo.578.1"> to tell </span><code class="inlineCode"><span class="koboSpan" id="kobo.579.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.580.1"> that you want to print a string. </span><span class="koboSpan" id="kobo.580.2">You can initialize a new byte slice with the desired string by using a statement such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.581.1">[]byte("My Initialization String")</span></code><span class="koboSpan" id="kobo.582.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.583.1">We will cover byte slices in more detail in the </span><em class="italic"><span class="koboSpan" id="kobo.584.1">Byte slices</span></em><span class="koboSpan" id="kobo.585.1"> section.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.586.1">You can define a rune using single quotes: </span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">r := '€'</span></code><span class="koboSpan" id="kobo.588.1"> and you can print the integer value of the bytes that compose it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">fmt.Println(r)</span></code><span class="koboSpan" id="kobo.590.1">—in this case, the integer value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.591.1">8364</span></code><span class="koboSpan" id="kobo.592.1">. </span><span class="koboSpan" id="kobo.592.2">Printing it as a single Unicode character requires the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.593.1">%c</span></code><span class="koboSpan" id="kobo.594.1"> control string in </span><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.596.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.597.1">As strings can be accessed as arrays, you can iterate over the runes of the string using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.598.1">for</span></code><span class="koboSpan" id="kobo.599.1"> loop or point to a specific character if you know its place in the string. </span><span class="koboSpan" id="kobo.599.2">The length of the string is the same as the number of characters found in the string, which is usually not true for byte slices because </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.600.1">Unicode characters usually require more than one byte.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.601.1">The following Go code illustrates the </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.602.1">use of strings and runes and how you can work with</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.603.1"> strings in your code. </span><span class="koboSpan" id="kobo.603.2">You can find the entire program as </span><code class="inlineCode"><span class="koboSpan" id="kobo.604.1">text.go</span></code><span class="koboSpan" id="kobo.605.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">ch02</span></code><span class="koboSpan" id="kobo.607.1"> directory of the GitHub repository of the book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.608.1">The first part of the program defines a string literal that contains a Unicode character. </span><span class="koboSpan" id="kobo.608.2">Then it accesses its first byte as if the string were an array:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.609.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.610.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.611.1">()</span></span><span class="koboSpan" id="kobo.612.1"> {
    aString := </span><span class="hljs-string"><span class="koboSpan" id="kobo.613.1">"Hello World! </span><span class="koboSpan" id="kobo.613.2">€"</span></span><span class="koboSpan" id="kobo.614.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.615.1">"First byte"</span></span><span class="koboSpan" id="kobo.616.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.617.1">string</span></span><span class="koboSpan" id="kobo.618.1">(aString[</span><span class="hljs-number"><span class="koboSpan" id="kobo.619.1">0</span></span><span class="koboSpan" id="kobo.620.1">]))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.621.1">The next part is about working with runes:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.622.1">    r := </span><span class="hljs-string"><span class="koboSpan" id="kobo.623.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.624.1">€'</span></span><span class="koboSpan" id="kobo.625.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.626.1">"As an int32 value:"</span></span><span class="koboSpan" id="kobo.627.1">, r)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.628.1">// Convert Runes to text</span></span><span class="koboSpan" id="kobo.629.1">
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.630.1">"As a string: %s and as a character: %c\n"</span></span><span class="koboSpan" id="kobo.631.1">, r, r)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.632.1">// Print an existing string as runes</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.633.1">for</span></span><span class="koboSpan" id="kobo.634.1"> _, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.635.1">range</span></span><span class="koboSpan" id="kobo.636.1"> aString {
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.637.1">"%x "</span></span><span class="koboSpan" id="kobo.638.1">, v)
    }
    fmt.Println()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.639.1">First, we define a rune named </span><code class="inlineCode"><span class="koboSpan" id="kobo.640.1">r</span></code><span class="koboSpan" id="kobo.641.1">. </span><span class="koboSpan" id="kobo.641.2">What makes this a rune is the use of single quotes around the </span><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">€</span></code><span class="koboSpan" id="kobo.643.1"> character. </span><span class="koboSpan" id="kobo.643.2">The rune is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.644.1">int32</span></code><span class="koboSpan" id="kobo.645.1"> value and is printed as such by </span><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.647.1">. </span><span class="koboSpan" id="kobo.647.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.648.1">%c</span></code><span class="koboSpan" id="kobo.649.1"> control string in </span><code class="inlineCode"><span class="koboSpan" id="kobo.650.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.651.1"> prints a rune as a character. </span><span class="koboSpan" id="kobo.651.2">Then we iterate over </span><code class="inlineCode"><span class="koboSpan" id="kobo.652.1">aString</span></code><span class="koboSpan" id="kobo.653.1"> as a slice or an array using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.654.1">for</span></code><span class="koboSpan" id="kobo.655.1"> loop with </span><code class="inlineCode"><span class="koboSpan" id="kobo.656.1">range</span></code><span class="koboSpan" id="kobo.657.1"> and print the contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.658.1">aString</span></code><span class="koboSpan" id="kobo.659.1"> as runes.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.660.1">// Print an existing string as characters</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.661.1">for</span></span><span class="koboSpan" id="kobo.662.1"> _, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.663.1">range</span></span><span class="koboSpan" id="kobo.664.1"> aString {
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.665.1">"%c"</span></span><span class="koboSpan" id="kobo.666.1">, v)
    }
    fmt.Println()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.667.1">Lastly, we iterate over </span><code class="inlineCode"><span class="koboSpan" id="kobo.668.1">aString</span></code><span class="koboSpan" id="kobo.669.1"> as a slice or an array using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">for</span></code><span class="koboSpan" id="kobo.671.1"> loop with </span><code class="inlineCode"><span class="koboSpan" id="kobo.672.1">range</span></code><span class="koboSpan" id="kobo.673.1"> and print the contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.674.1">aString</span></code><span class="koboSpan" id="kobo.675.1"> as characters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.676.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">text.go</span></code><span class="koboSpan" id="kobo.678.1"> produces the following</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.679.1"> output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.680.1">$ </span></span><span class="koboSpan" id="kobo.681.1">go run text.go
First byte H
As an int32 value: 8364
As a string: %!s(int32=8364) and as a character: €
48 65 6c 6c 6f 20 57 6f 72 6c 64 21 20 20ac
Hello World! </span><span class="koboSpan" id="kobo.681.2">€
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.682.1">The first line of the output shows that we can access a string as an array whereas the second line verifies that a rune is an integer value. </span><span class="koboSpan" id="kobo.682.2">The third line shows what to expect when you print a rune as a string and as a character—the correct way is to print it as a character. </span><span class="koboSpan" id="kobo.682.3">The fifth line shows</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.683.1"> how to print a string as runes and the last line shows the output of processing a string as characters using range and a for loop.</span></p>
<h2 class="heading-2" id="_idParaDest-56"><span class="koboSpan" id="kobo.684.1">Converting int to string</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.685.1">You can convert an integer value</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.686.1"> into a string in two main ways: using </span><code class="inlineCode"><span class="koboSpan" id="kobo.687.1">string()</span></code><span class="koboSpan" id="kobo.688.1"> and using a function from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.689.1">strconv</span></code><span class="koboSpan" id="kobo.690.1"> package. </span><span class="koboSpan" id="kobo.690.2">However, the two methods are fundamentally different. </span><span class="koboSpan" id="kobo.690.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.691.1">string()</span></code><span class="koboSpan" id="kobo.692.1"> function converts an integer value into a Unicode code point, which is a single character, whereas functions such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.693.1">strconv.FormatInt()</span></code><span class="koboSpan" id="kobo.694.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">strconv.Itoa()</span></code><span class="koboSpan" id="kobo.696.1"> convert an integer value into a string value with the same representation and the same number of characters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.697.1">This is illustrated in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">intString.go</span></code><span class="koboSpan" id="kobo.699.1"> program—its most important statements are the following. </span><span class="koboSpan" id="kobo.699.2">You can find the entire program in the GitHub repository of the book.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.700.1">    input := strconv.Itoa(n)
    input = strconv.FormatInt(</span><span class="hljs-type"><span class="koboSpan" id="kobo.701.1">int64</span></span><span class="koboSpan" id="kobo.702.1">(n), </span><span class="hljs-number"><span class="koboSpan" id="kobo.703.1">10</span></span><span class="koboSpan" id="kobo.704.1">)
    input = </span><span class="hljs-type"><span class="koboSpan" id="kobo.705.1">string</span></span><span class="koboSpan" id="kobo.706.1">(n)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.707.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.708.1">intString.go</span></code><span class="koboSpan" id="kobo.709.1"> generates</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.710.1"> the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.711.1">$ </span></span><span class="koboSpan" id="kobo.712.1">go run intString.go 100
strconv.Itoa() 100 of type string
strconv.FormatInt() 100 of type string
string() d of type string
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.713.1">The data type of the output is always string, however, </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">string()</span></code><span class="koboSpan" id="kobo.715.1"> converted </span><code class="inlineCode"><span class="koboSpan" id="kobo.716.1">100</span></code><span class="koboSpan" id="kobo.717.1"> into </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">d</span></code><span class="koboSpan" id="kobo.719.1"> because the ASCII representation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">d</span></code><span class="koboSpan" id="kobo.721.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">100</span></code><span class="koboSpan" id="kobo.723.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.724.1">Now that we have looked at converting integers into strings, it is time to learn how to work with Unicode text and code points.</span></p>
<h2 class="heading-2" id="_idParaDest-57"><span class="koboSpan" id="kobo.725.1">The unicode package</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.726.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">unicode</span></code><span class="koboSpan" id="kobo.728.1"> standard Go package contains </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.729.1">various handy functions for working with Unicode code points. </span><span class="koboSpan" id="kobo.729.2">One of them, which is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.730.1">unicode.IsPrint()</span></code><span class="koboSpan" id="kobo.731.1">, can help you to identify the parts of a string that are printable using runes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.732.1">The following code excerpt illustrates the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.733.1">unicode</span></code><span class="koboSpan" id="kobo.734.1"> package:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.735.1">for</span></span><span class="koboSpan" id="kobo.736.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.737.1">0</span></span><span class="koboSpan" id="kobo.738.1">; i &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.739.1">len</span></span><span class="koboSpan" id="kobo.740.1">(sL); i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.741.1">if</span></span><span class="koboSpan" id="kobo.742.1"> unicode.IsPrint(</span><span class="hljs-type"><span class="koboSpan" id="kobo.743.1">rune</span></span><span class="koboSpan" id="kobo.744.1">(sL[i])) {
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.745.1">"%c\n"</span></span><span class="koboSpan" id="kobo.746.1">, sL[i])
        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.747.1">else</span></span><span class="koboSpan" id="kobo.748.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.749.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.750.1">Not printable!"</span></span><span class="koboSpan" id="kobo.751.1">)
        }
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.752.1">The for loop iterates over the contents of a string defined as a list of runes (</span><code class="inlineCode"><span class="koboSpan" id="kobo.753.1">"\x99\x00ab\x50\x00\x23\x50\x29\x9c"</span></code><span class="koboSpan" id="kobo.754.1">) while </span><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">unicode.IsPrint()</span></code><span class="koboSpan" id="kobo.756.1"> examines whether the character is printable or not—if it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.757.1">true</span></code><span class="koboSpan" id="kobo.758.1"> then a rune is printable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.759.1">You can find this code excerpt inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.760.1">unicode.go</span></code><span class="koboSpan" id="kobo.761.1"> source file in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">ch02</span></code><span class="koboSpan" id="kobo.763.1"> directory in the GitHub repository of the book. </span><span class="koboSpan" id="kobo.763.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">unicode.go</span></code><span class="koboSpan" id="kobo.765.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.766.1">Not printable!
</span><span class="koboSpan" id="kobo.766.2">Not printable!
</span><span class="koboSpan" id="kobo.766.3">a
b
P
Not printable!
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.767.1">#</span></span><span class="koboSpan" id="kobo.768.1">
P
)
Not printable!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.769.1">This utility is very handy for filtering input or filtering data before printing it on screen, storing it in log files, transferring it on a network, or storing it in a database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.770.1">In the next subsection, we</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.771.1"> continue working with text with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">strings</span></code><span class="koboSpan" id="kobo.773.1"> package.</span></p>
<h2 class="heading-2" id="_idParaDest-58"><span class="koboSpan" id="kobo.774.1">The strings package</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.775.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">strings</span></code><span class="koboSpan" id="kobo.777.1"> standard Go package allows </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.778.1">you to manipulate UTF-8 strings in Go and includes many powerful functions. </span><span class="koboSpan" id="kobo.778.2">Many of these functions are illustrated in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.779.1">useStrings.go</span></code><span class="koboSpan" id="kobo.780.1"> source file, which can be found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">ch02</span></code><span class="koboSpan" id="kobo.782.1"> directory of the book GitHub repository.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.783.1">If you are working with text and text processing, you need to learn all the details and functions of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.784.1">strings</span></code><span class="koboSpan" id="kobo.785.1"> package, so make sure that you experiment with all these functions and create many examples that will help you to clarify things.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.786.1">The most important parts of </span><code class="inlineCode"><span class="koboSpan" id="kobo.787.1">useStrings.go</span></code><span class="koboSpan" id="kobo.788.1"> are the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.789.1">import</span></span><span class="koboSpan" id="kobo.790.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.791.1">"fmt"</span></span><span class="koboSpan" id="kobo.792.1">
    s </span><span class="hljs-string"><span class="koboSpan" id="kobo.793.1">"strings"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.794.1">"unicode"</span></span><span class="koboSpan" id="kobo.795.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.796.1">var</span></span><span class="koboSpan" id="kobo.797.1"> f = fmt.Printf
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.798.1">As we are going to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.799.1">strings</span></code><span class="koboSpan" id="kobo.800.1"> package multiple times, we create a convenient alias for it named </span><code class="inlineCode"><span class="koboSpan" id="kobo.801.1">s</span></code><span class="koboSpan" id="kobo.802.1"> – note that this is considered a bad practice and that we are just doing that here to prevent the lines from getting too long. </span><span class="koboSpan" id="kobo.802.2">We do the same for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.803.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.804.1"> function where we create a global alias using a variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.805.1">f</span></code><span class="koboSpan" id="kobo.806.1">. </span><span class="koboSpan" id="kobo.806.2">These two shortcuts reduce the amount of long, repeated lines of code. </span><span class="koboSpan" id="kobo.806.3">You can use them when learning Go, but this is not </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.807.1">recommended in any kind of production software as it makes the code less readable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.808.1">The first code excerpt is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.809.1">    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.810.1">"To Upper: %s\n"</span></span><span class="koboSpan" id="kobo.811.1">, s.ToUpper(</span><span class="hljs-string"><span class="koboSpan" id="kobo.812.1">"Hello THERE"</span></span><span class="koboSpan" id="kobo.813.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.814.1">"To Lower: %s\n"</span></span><span class="koboSpan" id="kobo.815.1">, s.ToLower(</span><span class="hljs-string"><span class="koboSpan" id="kobo.816.1">"Hello THERE"</span></span><span class="koboSpan" id="kobo.817.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.818.1">"%s\n"</span></span><span class="koboSpan" id="kobo.819.1">, s.Title(</span><span class="hljs-string"><span class="koboSpan" id="kobo.820.1">"tHis wiLL be A title!"</span></span><span class="koboSpan" id="kobo.821.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.822.1">"EqualFold: %v\n"</span></span><span class="koboSpan" id="kobo.823.1">, s.EqualFold(</span><span class="hljs-string"><span class="koboSpan" id="kobo.824.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.825.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.826.1">"MIHAlis"</span></span><span class="koboSpan" id="kobo.827.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.828.1">"EqualFold: %v\n"</span></span><span class="koboSpan" id="kobo.829.1">, s.EqualFold(</span><span class="hljs-string"><span class="koboSpan" id="kobo.830.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.831.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.832.1">"MIHAli"</span></span><span class="koboSpan" id="kobo.833.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.834.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.835.1">strings.EqualFold()</span></code><span class="koboSpan" id="kobo.836.1"> function compares two strings without considering their case and returns true when they are the same and false otherwise.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.837.1">    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.838.1">"Index: %v\n"</span></span><span class="koboSpan" id="kobo.839.1">, s.Index(</span><span class="hljs-string"><span class="koboSpan" id="kobo.840.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.841.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.842.1">"ha"</span></span><span class="koboSpan" id="kobo.843.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.844.1">"Index: %v\n"</span></span><span class="koboSpan" id="kobo.845.1">, s.Index(</span><span class="hljs-string"><span class="koboSpan" id="kobo.846.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.847.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.848.1">"Ha"</span></span><span class="koboSpan" id="kobo.849.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.850.1">"Count: %v\n"</span></span><span class="koboSpan" id="kobo.851.1">, s.Count(</span><span class="hljs-string"><span class="koboSpan" id="kobo.852.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.853.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.854.1">"i"</span></span><span class="koboSpan" id="kobo.855.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.856.1">"Count: %v\n"</span></span><span class="koboSpan" id="kobo.857.1">, s.Count(</span><span class="hljs-string"><span class="koboSpan" id="kobo.858.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.859.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.860.1">"I"</span></span><span class="koboSpan" id="kobo.861.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.862.1">"Repeat: %s\n"</span></span><span class="koboSpan" id="kobo.863.1">, s.Repeat(</span><span class="hljs-string"><span class="koboSpan" id="kobo.864.1">"ab"</span></span><span class="koboSpan" id="kobo.865.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.866.1">5</span></span><span class="koboSpan" id="kobo.867.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.868.1">"TrimSpace: %s\n"</span></span><span class="koboSpan" id="kobo.869.1">, s.TrimSpace(</span><span class="hljs-string"><span class="koboSpan" id="kobo.870.1">" \tThis is a line. </span><span class="koboSpan" id="kobo.870.2">\n"</span></span><span class="koboSpan" id="kobo.871.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.872.1">"TrimLeft: %s"</span></span><span class="koboSpan" id="kobo.873.1">, s.TrimLeft(</span><span class="hljs-string"><span class="koboSpan" id="kobo.874.1">" \tThis is a\t line. </span><span class="koboSpan" id="kobo.874.2">\n"</span></span><span class="koboSpan" id="kobo.875.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.876.1">"\n\t "</span></span><span class="koboSpan" id="kobo.877.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.878.1">"TrimRight: %s\n"</span></span><span class="koboSpan" id="kobo.879.1">, s.TrimRight(</span><span class="hljs-string"><span class="koboSpan" id="kobo.880.1">" \tThis is a\t line. </span><span class="koboSpan" id="kobo.880.2">\n"</span></span><span class="koboSpan" id="kobo.881.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.882.1">"\n\t "</span></span><span class="koboSpan" id="kobo.883.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.884.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.885.1">strings.Index()</span></code><span class="koboSpan" id="kobo.886.1"> function checks whether the string of the second parameter can be found in the string that is given as the first parameter and returns the index where it was found for the first time. </span><span class="koboSpan" id="kobo.886.2">On an unsuccessful search, it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.887.1">-1</span></code><span class="koboSpan" id="kobo.888.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.889.1">    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.890.1">"Prefix: %v\n"</span></span><span class="koboSpan" id="kobo.891.1">, s.HasPrefix(</span><span class="hljs-string"><span class="koboSpan" id="kobo.892.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.893.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.894.1">"Mi"</span></span><span class="koboSpan" id="kobo.895.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.896.1">"Prefix: %v\n"</span></span><span class="koboSpan" id="kobo.897.1">, s.HasPrefix(</span><span class="hljs-string"><span class="koboSpan" id="kobo.898.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.899.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.900.1">"mi"</span></span><span class="koboSpan" id="kobo.901.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.902.1">"Suffix: %v\n"</span></span><span class="koboSpan" id="kobo.903.1">, s.HasSuffix(</span><span class="hljs-string"><span class="koboSpan" id="kobo.904.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.905.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.906.1">"is"</span></span><span class="koboSpan" id="kobo.907.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.908.1">"Suffix: %v\n"</span></span><span class="koboSpan" id="kobo.909.1">, s.HasSuffix(</span><span class="hljs-string"><span class="koboSpan" id="kobo.910.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.911.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.912.1">"IS"</span></span><span class="koboSpan" id="kobo.913.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.914.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.915.1">strings.HasPrefix()</span></code><span class="koboSpan" id="kobo.916.1"> function checks whether the given string, which is the first parameter, begins with the string that is given as the second parameter. </span><span class="koboSpan" id="kobo.916.2">In the preceding code, the first call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">strings.HasPrefix()</span></code><span class="koboSpan" id="kobo.918.1"> returns true, whereas the second returns false. </span><span class="koboSpan" id="kobo.918.2">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.919.1">strings.HasSuffix()</span></code><span class="koboSpan" id="kobo.920.1"> checks whether the given string ends with the second string. </span><span class="koboSpan" id="kobo.920.2">Both functions consider the case of the input string and the case of the second parameter.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.921.1">    t := s.Fields(</span><span class="hljs-string"><span class="koboSpan" id="kobo.922.1">"This is a string!"</span></span><span class="koboSpan" id="kobo.923.1">)
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.924.1">"Fields: %v\n"</span></span><span class="koboSpan" id="kobo.925.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.926.1">len</span></span><span class="koboSpan" id="kobo.927.1">(t))
    t = s.Fields(</span><span class="hljs-string"><span class="koboSpan" id="kobo.928.1">"ThisIs a\tstring!"</span></span><span class="koboSpan" id="kobo.929.1">)
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.930.1">"Fields: %v\n"</span></span><span class="koboSpan" id="kobo.931.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.932.1">len</span></span><span class="koboSpan" id="kobo.933.1">(t))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.934.1">The handy </span><code class="inlineCode"><span class="koboSpan" id="kobo.935.1">strings.Fields()</span></code><span class="koboSpan" id="kobo.936.1"> function splits the given string around one or more whitespace characters as defined by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">unicode.IsSpace()</span></code><span class="koboSpan" id="kobo.938.1"> function and returns a slice of substrings found in the input </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.939.1">string. </span><span class="koboSpan" id="kobo.939.2">If the input string contains whitespace characters only, it returns an empty slice.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.940.1">    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.941.1">"%s\n"</span></span><span class="koboSpan" id="kobo.942.1">, s.Split(</span><span class="hljs-string"><span class="koboSpan" id="kobo.943.1">"abcd efg"</span></span><span class="koboSpan" id="kobo.944.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.945.1">""</span></span><span class="koboSpan" id="kobo.946.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.947.1">"%s\n"</span></span><span class="koboSpan" id="kobo.948.1">, s.Replace(</span><span class="hljs-string"><span class="koboSpan" id="kobo.949.1">"abcd efg"</span></span><span class="koboSpan" id="kobo.950.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.951.1">""</span></span><span class="koboSpan" id="kobo.952.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.953.1">"_"</span></span><span class="koboSpan" id="kobo.954.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.955.1">-1</span></span><span class="koboSpan" id="kobo.956.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.957.1">"%s\n"</span></span><span class="koboSpan" id="kobo.958.1">, s.Replace(</span><span class="hljs-string"><span class="koboSpan" id="kobo.959.1">"abcd efg"</span></span><span class="koboSpan" id="kobo.960.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.961.1">""</span></span><span class="koboSpan" id="kobo.962.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.963.1">"_"</span></span><span class="koboSpan" id="kobo.964.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.965.1">4</span></span><span class="koboSpan" id="kobo.966.1">))
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.967.1">"%s\n"</span></span><span class="koboSpan" id="kobo.968.1">, s.Replace(</span><span class="hljs-string"><span class="koboSpan" id="kobo.969.1">"abcd efg"</span></span><span class="koboSpan" id="kobo.970.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.971.1">""</span></span><span class="koboSpan" id="kobo.972.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.973.1">"_"</span></span><span class="koboSpan" id="kobo.974.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.975.1">2</span></span><span class="koboSpan" id="kobo.976.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.977.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">strings.Split()</span></code><span class="koboSpan" id="kobo.979.1"> function allows you to split the given string according to the desired separator string—the </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">strings.Split()</span></code><span class="koboSpan" id="kobo.981.1"> function returns a string slice. </span><span class="koboSpan" id="kobo.981.2">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">""</span></code><span class="koboSpan" id="kobo.983.1"> as the second parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.984.1">strings.Split()</span></code><span class="koboSpan" id="kobo.985.1"> allows you to </span><em class="italic"><span class="koboSpan" id="kobo.986.1">process a string character by character</span></em><span class="koboSpan" id="kobo.987.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.988.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">strings.Replace()</span></code><span class="koboSpan" id="kobo.990.1"> function takes four parameters. </span><span class="koboSpan" id="kobo.990.2">The first parameter is the string that you want to process. </span><span class="koboSpan" id="kobo.990.3">The second parameter contains the string that, if found, will be replaced by the third parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.991.1">strings.Replace()</span></code><span class="koboSpan" id="kobo.992.1">. </span><span class="koboSpan" id="kobo.992.2">The last parameter is the maximum number of replacements that are allowed to happen. </span><span class="koboSpan" id="kobo.992.3">If that parameter has a negative value, then there is no limit to the allowed number of replacements.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.993.1">    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.994.1">"SplitAfter: %s\n"</span></span><span class="koboSpan" id="kobo.995.1">, s.SplitAfter(</span><span class="hljs-string"><span class="koboSpan" id="kobo.996.1">"123++432++"</span></span><span class="koboSpan" id="kobo.997.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.998.1">"++"</span></span><span class="koboSpan" id="kobo.999.1">))
    trimFunction := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1000.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1001.1">(c </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1002.1">rune</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1003.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1004.1">bool</span></span><span class="koboSpan" id="kobo.1005.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1006.1">return</span></span><span class="koboSpan" id="kobo.1007.1"> !unicode.IsLetter(c)
    }
    f(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1008.1">"TrimFunc: %s\n"</span></span><span class="koboSpan" id="kobo.1009.1">, s.TrimFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1010.1">"123 abc ABC \t ."</span></span><span class="koboSpan" id="kobo.1011.1">, trimFunction))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1012.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1013.1">strings.SplitAfter()</span></code><span class="koboSpan" id="kobo.1014.1"> function splits its first parameter string into substrings based on the separator string that is given as the second parameter to the function. </span><span class="koboSpan" id="kobo.1014.2">The separator string is included in the returned slice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1015.1">The last lines of code define a trim function named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1016.1">trimFunction</span></code><span class="koboSpan" id="kobo.1017.1"> that is used as the second parameter to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1018.1">strings.TrimFunc()</span></code><span class="koboSpan" id="kobo.1019.1"> in order to filter the given input based on the return value of the trim function—in this case, the trim function keeps all letters and nothing else due to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1020.1">unicode.IsLetter()</span></code><span class="koboSpan" id="kobo.1021.1"> call.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1022.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1023.1">useStrings.go</span></code><span class="koboSpan" id="kobo.1024.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1025.1">To Upper: HELLO THERE!
</span><span class="koboSpan" id="kobo.1025.2">To Lower: hello there
THis WiLL Be A Title!
</span><span class="koboSpan" id="kobo.1025.3">EqualFold: true
EqualFold: false
Prefix: true
Prefix: false
Suffix: true
Suffix: false
Index: 2
Index: -1
Count: 2
Count: 0
Repeat: ababababab
TrimSpace: This is a line.
</span><span class="koboSpan" id="kobo.1025.4">TrimLeft: This is a      line. 
</span><span class="koboSpan" id="kobo.1025.5">TrimRight:      This is a        line.
</span><span class="koboSpan" id="kobo.1025.6">Compare: 1
Compare: 0
Compare: -1
Fields: 4
Fields: 3
[a b c d   e f g]
_a_b_c_d_ _e_f_g_
_a_b_c_d efg
_a_bcd efg
Join: Line 1+++Line 2+++Line 3
SplitAfter: [123++ 432++ ]
TrimFunc: abc ABC
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1026.1">Visit the documentation page of the strings package at </span><a href="https://pkg.go.dev/strings"><span class="url"><span class="koboSpan" id="kobo.1027.1">https://pkg.go.dev/strings</span></span></a><span class="koboSpan" id="kobo.1028.1"> for the complete list of available </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.1029.1">functions. </span><span class="koboSpan" id="kobo.1029.2">You will see the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1030.1">strings</span></code><span class="koboSpan" id="kobo.1031.1"> package in other places in this book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1032.1">Enough with strings and text, the next section is about working with dates and times in Go.</span></p>
<h2 class="heading-2" id="_idParaDest-59"><span class="koboSpan" id="kobo.1033.1">Times and dates</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1034.1">Often, we need to work with date and</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.1035.1"> time information to store the time an entry was last used in a database or the time an entry was inserted into a database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1036.1">The king of working with times and dates in Go is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1037.1">time.Time</span></code><span class="koboSpan" id="kobo.1038.1"> data type, which represents an instant in time with nanosecond precision. </span><span class="koboSpan" id="kobo.1038.2">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.1039.1">time.Time</span></code><span class="koboSpan" id="kobo.1040.1"> value is associated with a location (time zone).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1041.1">If you are a UNIX person, you might already know about the UNIX epoch time and wonder how to get it in Go. </span><span class="koboSpan" id="kobo.1041.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1042.1">time.Now().Unix()</span></code><span class="koboSpan" id="kobo.1043.1"> function returns the popular UNIX epoch time, which is the number of seconds that have elapsed since </span><code class="inlineCode"><span class="koboSpan" id="kobo.1044.1">00:00:00 UTC, January 1, 1970</span></code><span class="koboSpan" id="kobo.1045.1">. </span><span class="koboSpan" id="kobo.1045.2">If you want to convert the UNIX time to the equivalent </span><code class="inlineCode"><span class="koboSpan" id="kobo.1046.1">time.Time</span></code><span class="koboSpan" id="kobo.1047.1"> value, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1048.1">time.Unix()</span></code><span class="koboSpan" id="kobo.1049.1"> function. </span><span class="koboSpan" id="kobo.1049.2">If you are not a UNIX person, then you might not have heard about the </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.1050.1">UNIX epoch time before, but now you know what it is!</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1051.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1052.1">time.Since()</span></code><span class="koboSpan" id="kobo.1053.1"> function calculates the time that has passed since a given time and returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1054.1">time.Duration</span></code><span class="koboSpan" id="kobo.1055.1"> variable—the duration data type is defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1056.1">type Duration int64</span></code><span class="koboSpan" id="kobo.1057.1">. </span><span class="koboSpan" id="kobo.1057.2">Although a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1058.1">Duration</span></code><span class="koboSpan" id="kobo.1059.1"> is, in reality, an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">int64</span></code><span class="koboSpan" id="kobo.1061.1"> value, you cannot compare or convert a duration to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">int64</span></code><span class="koboSpan" id="kobo.1063.1"> value implicitly because Go does not allow implicit data type conversions.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1064.1">The single most important topic about Go and dates and times is the way Go parses a string in order to convert it into a date and a time. </span><span class="koboSpan" id="kobo.1064.2">The reason this is important is that usually such input is given as a string and not as a valid date variable. </span><span class="koboSpan" id="kobo.1064.3">The function used for parsing is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1065.1">time.Parse()</span></code><span class="koboSpan" id="kobo.1066.1"> and its full signature is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1067.1">Parse(layout, value string) (Time, error)</span></code><span class="koboSpan" id="kobo.1068.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">layout</span></code><span class="koboSpan" id="kobo.1070.1"> is the parse string and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">value</span></code><span class="koboSpan" id="kobo.1072.1"> is the input that is being parsed. </span><span class="koboSpan" id="kobo.1072.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1073.1">time.Time</span></code><span class="koboSpan" id="kobo.1074.1"> value that is returned is a moment in time with nanosecond precision and contains both date and time information.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1075.1">The next table shows the most widely used strings for parsing dates and times.</span></p>
<table class="table-container" id="table002">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1076.1">Parse Value</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1077.1">Meaning (examples)</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1078.1">03</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1079.1">12-hour value (12pm, 07am)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1080.1">15</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1081.1">24-hour value (23, 07)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1082.1">04</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1083.1">Minutes (55, 15)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1084.1">05</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1085.1">Seconds (5, 23)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1086.1">Mon </span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1087.1">Abbreviated day of week (Tue, Fri)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1088.1">Monday</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1089.1">Day of week (Tuesday, Friday)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1090.1">02</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1091.1">Day of month (15, 31)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1092.1">2006</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1093.1">Year with 4 digits (2020, 2004)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1094.1">06</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1095.1">Year with the last 2 digits (20, 04)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1096.1">Jan</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1097.1">Abbreviated month name (Feb, Mar)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1098.1">January</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1099.1">Full month name (July, August)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1100.1">MST</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1101.1">Time zone (EST, UTC)</span></p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="koboSpan" id="kobo.1102.1">The previous table shows that if you want to parse the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1103.1">30 January 2023</span></code><span class="koboSpan" id="kobo.1104.1"> string and convert it into a Go date variable, you should match it against the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1105.1">02 January 2006</span></code><span class="koboSpan" id="kobo.1106.1"> string because this string indicates the expected format of the input—you cannot use anything else in its place when matching a string like </span><code class="inlineCode"><span class="koboSpan" id="kobo.1107.1">30 January 2023</span></code><span class="koboSpan" id="kobo.1108.1">. </span><span class="koboSpan" id="kobo.1108.2">Similarly, if you want to parse the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1109.1">15 August 2023 10:00</span></code><span class="koboSpan" id="kobo.1110.1"> string, you should match it against the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1111.1">02 January 2006 15:04</span></code><span class="koboSpan" id="kobo.1112.1"> string</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.1113.1"> because this specifies the expected format of the input. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1114.1">The documentation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1115.1">time</span></code><span class="koboSpan" id="kobo.1116.1"> package (</span><a href="https://pkg.go.dev/time"><span class="url"><span class="koboSpan" id="kobo.1117.1">https://pkg.go.dev/time</span></span></a><span class="koboSpan" id="kobo.1118.1">) contains even more</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.1119.1"> detailed information about parsing dates and times—however, the ones presented here should be more than enough for regular use.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1120.1">Now that we know how to work with dates and times, it is time to learn more about working with time zones.</span></p>
<h2 class="heading-2" id="_idParaDest-60"><span class="koboSpan" id="kobo.1121.1">Working with different time zones</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1122.1">The presented utility accepts a date and a time</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.1123.1"> and converts them into different time zones. </span><span class="koboSpan" id="kobo.1123.2">This can be particularly handy when you want to preprocess log files from different sources that use different time zones to convert these different time zones into a common one. </span><span class="koboSpan" id="kobo.1123.3">Once again, you need </span><code class="inlineCode"><span class="koboSpan" id="kobo.1124.1">time.Parse()</span></code><span class="koboSpan" id="kobo.1125.1"> in order to convert a valid input into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1126.1">time.Time</span></code><span class="koboSpan" id="kobo.1127.1"> value before doing the conversions. </span><span class="koboSpan" id="kobo.1127.2">This time the input string contains the time zone and is parsed by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1128.1">"</span></code><code class="inlineCode"><span class="koboSpan" id="kobo.1129.1">02 January 2006 15:04 MST"</span></code><span class="koboSpan" id="kobo.1130.1"> string.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1131.1">In order to convert the parsed date and time into New York time, the program uses the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1132.1">    loc, _ = time.LoadLocation(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1133.1">"America/New_York"</span></span><span class="koboSpan" id="kobo.1134.1">)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1135.1">"New York Time: %s\n"</span></span><span class="koboSpan" id="kobo.1136.1">, now.In(loc))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1137.1">This technique is used multiple times in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1138.1">convertTimes.go</span></code><span class="koboSpan" id="kobo.1139.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1140.1">If a command line argument contains any space characters, you should put it in double quotes for the UNIX shell to treat it as a single command line argument.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1141.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1142.1">convertTimes.go</span></code><span class="koboSpan" id="kobo.1143.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1144.1">$ </span></span><span class="koboSpan" id="kobo.1145.1">go run convertTimes.go </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.1146.1">"14 December 2023 19:20 EET"</span></span><span class="koboSpan" id="kobo.1147.1">
Current Location: 2023-12-14 19:20:00 +0200 EET
New York Time: 2023-12-14 12:20:00 -0500 EST
London Time: 2023-12-14 17:20:00 +0000 GMT
Tokyo Time: 2023-12-15 02:20:00 +0900 JST
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1148.1">$ </span></span><span class="koboSpan" id="kobo.1149.1">go run convertTimes.go </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.1150.1">"</span></span><span class="hljs-con-string"><span class="koboSpan" id="kobo.1151.1">14 December 2023 19:20 UTC"</span></span><span class="koboSpan" id="kobo.1152.1">
Current Location: 2023-12-14 21:20:00 +0200 EET
New York Time: 2023-12-14 14:20:00 -0500 EST
London Time: 2023-12-14 19:20:00 +0000 GMT
Tokyo Time: 2023-12-15 04:20:00 +0900 JST
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1153.1">$ </span></span><span class="koboSpan" id="kobo.1154.1">go run convertTimes.go </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.1155.1">"14 December 2023 25:00 EET"</span></span><span class="koboSpan" id="kobo.1156.1">
parsing time "14 December 2023 25:00 EET": hour out of range
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1157.1">In the last execution of the program, the code must parse </span><code class="inlineCode"><span class="koboSpan" id="kobo.1158.1">25</span></code><span class="koboSpan" id="kobo.1159.1"> as the hour of the day, which is wrong and generates</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.1160.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1161.1">hour out of range</span></code><span class="koboSpan" id="kobo.1162.1"> error message.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1163.1">There is a known Go issue related to the parsing of times and dates that you can learn about at </span><a href="https://github.com/golang/go/issues/63345"><span class="url"><span class="koboSpan" id="kobo.1164.1">https://github.com/golang/go/issues/63345</span></span></a><span class="koboSpan" id="kobo.1165.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1166.1">The next subsection is about constant values.</span></p>
<h1 class="heading-1" id="_idParaDest-61"><span class="koboSpan" id="kobo.1167.1">Constants</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1168.1">Go supports constants, which behave like</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.1169.1"> variables but cannot change their values. </span><span class="koboSpan" id="kobo.1169.2">Constants in Go are defined with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1170.1">const</span></code><span class="koboSpan" id="kobo.1171.1"> keyword. </span><span class="koboSpan" id="kobo.1171.2">Constants can be either </span><em class="italic"><span class="koboSpan" id="kobo.1172.1">global or local</span></em><span class="koboSpan" id="kobo.1173.1">. </span><span class="koboSpan" id="kobo.1173.2">However, if you are defining too many constant values with a local scope, you might need to rethink your approach.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1174.1">The main benefit you get from using constants in your programs is the guarantee that their value will not change during program execution. </span><span class="koboSpan" id="kobo.1174.2">Strictly speaking, the value of a constant variable is defined at compile time, not at runtime—this means that it is included in the binary executable. </span><span class="koboSpan" id="kobo.1174.3">Behind the scenes, Go uses Boolean, string, or numeric as the type for storing constant values because this gives Go more flexibility when dealing with constants.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1175.1">Some possible uses of constants include defining configuration values such as the maximum number of connections or the TCP/IP port number used and defining physical constants such as the speed of light or the gravity on earth.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1176.1">The next subsection discusses</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.1177.1"> the constant generator iota, which is a handy way of creating sequences of constants.</span></p>
<h2 class="heading-2" id="_idParaDest-62"><span class="koboSpan" id="kobo.1178.1">The constant generator iota</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1179.1">The </span><em class="italic"><span class="koboSpan" id="kobo.1180.1">constant generator iota</span></em><span class="koboSpan" id="kobo.1181.1"> is used for declaring</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.1182.1"> a sequence of related values that use incrementing numbers without the need to explicitly type each one of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1183.1">The concepts related to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1184.1">const</span></code><span class="koboSpan" id="kobo.1185.1"> keyword, including the constant generator iota, are illustrated in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1186.1">constants.go</span></code><span class="koboSpan" id="kobo.1187.1"> file.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1188.1">type</span></span><span class="koboSpan" id="kobo.1189.1"> Digit </span><span class="hljs-type"><span class="koboSpan" id="kobo.1190.1">int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1191.1">type</span></span><span class="koboSpan" id="kobo.1192.1"> Power2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.1193.1">int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1194.1">const</span></span><span class="koboSpan" id="kobo.1195.1"> PI = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1196.1">3.1415926</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1197.1">const</span></span><span class="koboSpan" id="kobo.1198.1"> (
    C1 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1199.1">"C1C1C1"</span></span><span class="koboSpan" id="kobo.1200.1">
    C2 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1201.1">"C2C2C2"</span></span><span class="koboSpan" id="kobo.1202.1">
    C3 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1203.1">"C3C3C3"</span></span><span class="koboSpan" id="kobo.1204.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1205.1">In this part, we declare two new types named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1206.1">Digit</span></code><span class="koboSpan" id="kobo.1207.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1208.1">Power2</span></code><span class="koboSpan" id="kobo.1209.1"> that will be used in a while, and four new constants named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1210.1">PI</span></code><span class="koboSpan" id="kobo.1211.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1212.1">C1</span></code><span class="koboSpan" id="kobo.1213.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1214.1">C2</span></code><span class="koboSpan" id="kobo.1215.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1216.1">C3</span></code><span class="koboSpan" id="kobo.1217.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1218.1">A Go type is a way of defining a new named type that uses the same underlying type as an existing type. </span><span class="koboSpan" id="kobo.1218.2">This is mainly used for differentiating between different types that might use the same kind of data. </span><span class="koboSpan" id="kobo.1218.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1219.1">type</span></code><span class="koboSpan" id="kobo.1220.1"> keyword can also be used for defining structures and interfaces, which is not the case here.</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1221.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1222.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1223.1">()</span></span><span class="koboSpan" id="kobo.1224.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1225.1">const</span></span><span class="koboSpan" id="kobo.1226.1"> s1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1227.1">123</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1228.1">var</span></span><span class="koboSpan" id="kobo.1229.1"> v1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.1230.1">float32</span></span><span class="koboSpan" id="kobo.1231.1"> = s1 * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1232.1">12</span></span><span class="koboSpan" id="kobo.1233.1">
    fmt.Println(v1)
    fmt.Println(PI)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1234.1">const</span></span><span class="koboSpan" id="kobo.1235.1"> (
        Zero Digit = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1236.1">iota</span></span><span class="koboSpan" id="kobo.1237.1">
        One
        Two
        Three
        Four
    )
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1238.1">The preceding code defines a constant named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1239.1">s1</span></code><span class="koboSpan" id="kobo.1240.1">. </span><span class="koboSpan" id="kobo.1240.2">Here you also see the definition of a constant generator iota based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.1241.1">Digit</span></code><span class="koboSpan" id="kobo.1242.1">, which is equivalent to the next declaration of five constants:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1243.1">const</span></span><span class="koboSpan" id="kobo.1244.1"> (
    Zero = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1245.1">0</span></span><span class="koboSpan" id="kobo.1246.1">
    One = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1247.1">1</span></span><span class="koboSpan" id="kobo.1248.1">
    Two = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1249.1">2</span></span><span class="koboSpan" id="kobo.1250.1">
    Three = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1251.1">3</span></span><span class="koboSpan" id="kobo.1252.1">
    Four = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1253.1">4</span></span><span class="koboSpan" id="kobo.1254.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1255.1">Although we are defining constants inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.1256.1">main()</span></code><span class="koboSpan" id="kobo.1257.1">, constants can normally be found outside of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1258.1">main()</span></code><span class="koboSpan" id="kobo.1259.1"> or any other</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.1260.1"> function or method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1261.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1262.1">constants.go</span></code><span class="koboSpan" id="kobo.1263.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1264.1">    fmt.Println(One)
    fmt.Println(Two)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1265.1">const</span></span><span class="koboSpan" id="kobo.1266.1"> (
        p2_0 Power2 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1267.1">1</span></span><span class="koboSpan" id="kobo.1268.1"> &lt;&lt; </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1269.1">iota</span></span><span class="koboSpan" id="kobo.1270.1">
        _
        p2_2
        _
        p2_4
        _
        p2_6
    )
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1271.1">"2^0:"</span></span><span class="koboSpan" id="kobo.1272.1">, p2_0)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1273.1">"2^2:"</span></span><span class="koboSpan" id="kobo.1274.1">, p2_2)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1275.1">"2^4:"</span></span><span class="koboSpan" id="kobo.1276.1">, p2_4)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1277.1">"2^6:"</span></span><span class="koboSpan" id="kobo.1278.1">, p2_6)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1279.1">There is another constant generator iota here that is different than the previous one. </span><span class="koboSpan" id="kobo.1279.2">Firstly, you can see the use of the underscore character in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1280.1">const</span></code><span class="koboSpan" id="kobo.1281.1"> block with a constant generator iota, which allows you to skip unwanted values. </span><span class="koboSpan" id="kobo.1281.2">Secondly, the value of iota always increments and can be used in expressions, which is what occurred in this case.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1282.1">Now let us see what really happens inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1283.1">const</span></code><span class="koboSpan" id="kobo.1284.1"> block. </span><span class="koboSpan" id="kobo.1284.2">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.1285.1">p2_0</span></code><span class="koboSpan" id="kobo.1286.1">, iota has the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1287.1">0</span></code><span class="koboSpan" id="kobo.1288.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1289.1">p2_0</span></code><span class="koboSpan" id="kobo.1290.1"> is defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1291.1">1</span></code><span class="koboSpan" id="kobo.1292.1">. </span><span class="koboSpan" id="kobo.1292.2">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.1293.1">p2_2</span></code><span class="koboSpan" id="kobo.1294.1">, iota has the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1295.1">2</span></code><span class="koboSpan" id="kobo.1296.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1297.1">p2_2</span></code><span class="koboSpan" id="kobo.1298.1"> is defined as the result of the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.1299.1">1 &lt;&lt; 2</span></code><span class="koboSpan" id="kobo.1300.1">, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1301.1">00000100</span></code><span class="koboSpan" id="kobo.1302.1"> in binary representation. </span><span class="koboSpan" id="kobo.1302.2">The decimal value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1303.1">00000100</span></code><span class="koboSpan" id="kobo.1304.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1305.1">4</span></code><span class="koboSpan" id="kobo.1306.1">, which</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.1307.1"> is the result and the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1308.1">p2_2</span></code><span class="koboSpan" id="kobo.1309.1">. </span><span class="koboSpan" id="kobo.1309.2">Analogously, the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1310.1">p2_4</span></code><span class="koboSpan" id="kobo.1311.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1312.1">16</span></code><span class="koboSpan" id="kobo.1313.1"> and the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1314.1">p2_6</span></code><span class="koboSpan" id="kobo.1315.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1316.1">64</span></code><span class="koboSpan" id="kobo.1317.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1318.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1319.1">constants.go</span></code><span class="koboSpan" id="kobo.1320.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1321.1">$ </span></span><span class="koboSpan" id="kobo.1322.1">go run constants.go
1476
3.1415926
1
2
2^0: 1
2^2: 4
2^4: 16
2^6: 64
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-63"><span class="koboSpan" id="kobo.1323.1">Typed and untyped constants</span></h2>
<p class="normal"><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1324.1">Constant values can have a data type</span></strong><span class="koboSpan" id="kobo.1325.1">. </span><span class="koboSpan" id="kobo.1325.2">This can be restrictive because a constant value with a data type can only operate</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.1326.1"> with values and variables of the same data type, but it can save</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.1327.1"> you from bugs because the compiler can catch such situations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1328.1">The code excerpt from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1329.1">typedConstants.go</span></code><span class="koboSpan" id="kobo.1330.1"> is going to show the difference between </span><em class="italic"><span class="koboSpan" id="kobo.1331.1">typed</span></em><span class="koboSpan" id="kobo.1332.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1333.1">untyped constants</span></em><span class="koboSpan" id="kobo.1334.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1335.1">const</span></span><span class="koboSpan" id="kobo.1336.1"> (
    typedConstant   = </span><span class="hljs-type"><span class="koboSpan" id="kobo.1337.1">int16</span></span><span class="koboSpan" id="kobo.1338.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1339.1">100</span></span><span class="koboSpan" id="kobo.1340.1">)
    untypedConstant = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1341.1">100</span></span><span class="koboSpan" id="kobo.1342.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1343.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1344.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1345.1">()</span></span><span class="koboSpan" id="kobo.1346.1"> {
    i := </span><span class="hljs-type"><span class="koboSpan" id="kobo.1347.1">int</span></span><span class="koboSpan" id="kobo.1348.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1349.1">1</span></span><span class="koboSpan" id="kobo.1350.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1351.1">"unTyped:"</span></span><span class="koboSpan" id="kobo.1352.1">, i*untypedConstant)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1353.1">"Typed:"</span></span><span class="koboSpan" id="kobo.1354.1">, </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.1355.1">i*typedConstant</span></strong></span><span class="koboSpan" id="kobo.1356.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1357.1">So, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1358.1">untypedConstant</span></code><span class="koboSpan" id="kobo.1359.1"> does not have a data type associated with it whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.1360.1">typedConstant</span></code><span class="koboSpan" id="kobo.1361.1"> does. </span><span class="koboSpan" id="kobo.1361.2">If you try to run </span><code class="inlineCode"><span class="koboSpan" id="kobo.1362.1">typedConstants.go</span></code><span class="koboSpan" id="kobo.1363.1">, the compiler is not going to be able to compile it and it is going to produce the following error output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1364.1">$ </span></span><span class="koboSpan" id="kobo.1365.1">go run typedConstants.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1366.1"># </span></span><span class="koboSpan" id="kobo.1367.1">command-line-arguments
./typedConstants.go:13:24: invalid operation: i * typedConstant (mismatched types int and int16)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1368.1">The cause of the error condition can be found in the generated output: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1369.1">mismatched types int and int16</span></code><span class="koboSpan" id="kobo.1370.1">. </span><span class="koboSpan" id="kobo.1370.2">Put simply, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1371.1">i</span></code><span class="koboSpan" id="kobo.1372.1"> is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1373.1">int</span></code><span class="koboSpan" id="kobo.1374.1"> variable whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.1375.1">typedConstant</span></code><span class="koboSpan" id="kobo.1376.1"> is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1377.1">int16</span></code><span class="koboSpan" id="kobo.1378.1"> value and Go is unable</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.1379.1"> to perform their multiplication because the data types </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.1380.1">of the variables do not match. </span><span class="koboSpan" id="kobo.1380.2">On the other hand, there are no issues with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1381.1">i*untypedConstant</span></code><span class="koboSpan" id="kobo.1382.1"> multiplication because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1383.1">untypedConstant</span></code><span class="koboSpan" id="kobo.1384.1"> does not have a data type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1385.1">Having data is good but what happens when you have lots of similar data? </span><span class="koboSpan" id="kobo.1385.2">Do you need to have lots of variables to hold this data or is there a better way to do so? </span><span class="koboSpan" id="kobo.1385.3">Go answers these questions by introducing arrays and slices.</span></p>
<h1 class="heading-1" id="_idParaDest-64"><span class="koboSpan" id="kobo.1386.1">Grouping similar data</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1387.1">There are times when you want to keep multiple </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.1388.1">values of the same data type under a single variable and access them using an index number. </span><span class="koboSpan" id="kobo.1388.2">The simplest way to do that in Go is by using arrays</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.1389.1"> or slices. </span><em class="italic"><span class="koboSpan" id="kobo.1390.1">Arrays</span></em><span class="koboSpan" id="kobo.1391.1"> are the most widely used data structures and can be found in almost all programming languages due to their simplicity and speed of access. </span><span class="koboSpan" id="kobo.1391.2">Go provides an alternative to arrays that is called a </span><em class="italic"><span class="koboSpan" id="kobo.1392.1">slice</span></em><span class="koboSpan" id="kobo.1393.1">. </span><span class="koboSpan" id="kobo.1393.2">The subsections that </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.1394.1">follow help you understand the differences between arrays and slices so that you know which data structure to use and when. </span><span class="koboSpan" id="kobo.1394.2">The quick answer is that </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1395.1">you can use slices instead of arrays almost anywhere in Go,</span></strong><span class="koboSpan" id="kobo.1396.1"> but we are also demonstrating arrays because they can still be useful and because slices are implemented by Go using arrays!</span></p>
<h2 class="heading-2" id="_idParaDest-65"><span class="koboSpan" id="kobo.1397.1">Arrays</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1398.1">We are going to begin our </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.1399.1">discussion about arrays by examining their core characteristics and limitations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1400.1">When defining an array variable, you must define its size. </span><span class="koboSpan" id="kobo.1400.2">Otherwise, you should put </span><code class="inlineCode"><span class="koboSpan" id="kobo.1401.1">[...]</span></code><span class="koboSpan" id="kobo.1402.1"> in the array declaration and let the Go compiler find out the length for you. </span><span class="koboSpan" id="kobo.1402.2">So you can create an array with 4 string elements either as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">[4]string{"Zero", "One", "Two", "Three"}</span></code><span class="koboSpan" id="kobo.1404.1"> or as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1405.1">[...]string{"Zero", "One", "Two", "Three"}</span></code><span class="koboSpan" id="kobo.1406.1">. </span><span class="koboSpan" id="kobo.1406.2">If you put nothing in the square brackets, then a slice is going to be created instead. </span><span class="koboSpan" id="kobo.1406.3">As it contains four elements, the (valid) indexes for that array are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1407.1">0</span></code><span class="koboSpan" id="kobo.1408.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1409.1">1</span></code><span class="koboSpan" id="kobo.1410.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1411.1">2</span></code><span class="koboSpan" id="kobo.1412.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1413.1">3</span></code><span class="koboSpan" id="kobo.1414.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1415.1">You cannot change the size of an array after you have created it.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1416.1">When you pass an </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.1417.1">array to a function, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1418.1">Go creates a copy of that array</span></strong><span class="koboSpan" id="kobo.1419.1"> and passes that copy to that function—therefore any changes you make to an array inside a function are lost when the function exits.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1420.1">As a result, arrays in Go are not very powerful, which is the main reason that Go has introduced an additional data structure named slice that is like an array but is dynamic in nature, as explained in the next subsection. </span><span class="koboSpan" id="kobo.1420.2">However, data in both arrays and slices is accessed the same way.</span></p>
<h2 class="heading-2" id="_idParaDest-66"><span class="koboSpan" id="kobo.1421.1">Slices</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1422.1">Slices in Go are more powerful than </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.1423.1">arrays mainly because they are dynamic, which means that they can grow or shrink after creation as needed. </span><span class="koboSpan" id="kobo.1423.2">Additionally, any changes you make to a slice inside a function also affect the original slice. </span><span class="koboSpan" id="kobo.1423.3">Keep in mind that this is usually the case, but it is not always true—as discussed in a while, all slices have an underlying array for storing the data. </span><span class="koboSpan" id="kobo.1423.4">Only changes that do not cause an allocation of the underlying array are reflected back to the caller function. </span><span class="koboSpan" id="kobo.1423.5">However, functions working with slices do not usually change the size of the slice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1424.1">But how does this happen? </span><span class="koboSpan" id="kobo.1424.2">Strictly speaking, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1425.1">all parameters in Go are passed by value</span></strong><span class="koboSpan" id="kobo.1426.1">—there is no other way to pass parameters in Go. </span><span class="koboSpan" id="kobo.1426.2">However, you can explicitly pass a pointer to a variable in order to pass by reference. </span><span class="koboSpan" id="kobo.1426.3">A</span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1427.1"> slice value is a header that contains a pointer to an underlying array where the elements are actually stored, the length of the array, and its capacity</span></strong><span class="koboSpan" id="kobo.1428.1">—the capacity of a slice is explained in the next subsection. </span><span class="koboSpan" id="kobo.1428.2">Note that the slice value does not include its elements, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1429.1">just a pointer to the underlying array</span></strong><span class="koboSpan" id="kobo.1430.1">. </span><span class="koboSpan" id="kobo.1430.2">So, when you pass a slice to a function, Go makes a copy of that header and passes it to the function. </span><span class="koboSpan" id="kobo.1430.3">This copy of the slice header includes the pointer to the underlying array. </span><span class="koboSpan" id="kobo.1430.4">That slice header is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1431.1">reflect</span></code><span class="koboSpan" id="kobo.1432.1"> package (</span><a href="https://pkg.go.dev/reflect#SliceHeader"><span class="url"><span class="koboSpan" id="kobo.1433.1">https://pkg.go.dev/reflect#SliceHeader</span></span></a><span class="koboSpan" id="kobo.1434.1">) as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1435.1">type</span></span><span class="koboSpan" id="kobo.1436.1"> SliceHeader </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1437.1">struct</span></span><span class="koboSpan" id="kobo.1438.1"> {
    Data </span><span class="hljs-type"><span class="koboSpan" id="kobo.1439.1">uintptr</span></span><span class="koboSpan" id="kobo.1440.1">
    Len  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1441.1">int</span></span><span class="koboSpan" id="kobo.1442.1">
    Cap  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1443.1">int</span></span><span class="koboSpan" id="kobo.1444.1">
}
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1445.1">A side effect of passing the slice header is that it is faster to pass a slice to a function because Go does not need to make a copy of the slice and its elements, just a copy of the slice header.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1446.1">You can create a slice using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1447.1">make()</span></code><span class="koboSpan" id="kobo.1448.1"> or like an array without specifying its size or using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1449.1">[...]</span></code><span class="koboSpan" id="kobo.1450.1">. </span><span class="koboSpan" id="kobo.1450.2">If you do not want to initialize</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.1451.1"> a slice, then using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1452.1">make()</span></code><span class="koboSpan" id="kobo.1453.1"> is better and faster. </span><span class="koboSpan" id="kobo.1453.2">However, if you want to initialize it at the time of creation, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.1454.1">make()</span></code><span class="koboSpan" id="kobo.1455.1"> cannot help you. </span><span class="koboSpan" id="kobo.1455.2">As a result, you can create a slice with three </span><code class="inlineCode"><span class="koboSpan" id="kobo.1456.1">float64</span></code><span class="koboSpan" id="kobo.1457.1"> elements as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1458.1">aSlice := []float64{1.2, 3.2, -4.5}</span></code><span class="koboSpan" id="kobo.1459.1">. </span><span class="koboSpan" id="kobo.1459.2">Creating a slice with space for three </span><code class="inlineCode"><span class="koboSpan" id="kobo.1460.1">float64</span></code><span class="koboSpan" id="kobo.1461.1"> elements with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1462.1">make()</span></code><span class="koboSpan" id="kobo.1463.1"> is as simple as executing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1464.1">make([]float64, 3)</span></code><span class="koboSpan" id="kobo.1465.1">. </span><span class="koboSpan" id="kobo.1465.2">Each element of that slice has a value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1466.1">0</span></code><span class="koboSpan" id="kobo.1467.1">, which is the zero value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1468.1">float64</span></code><span class="koboSpan" id="kobo.1469.1"> data type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1470.1">Both slices and arrays can have many dimensions—creating a slice with two dimensions with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1471.1">make()</span></code><span class="koboSpan" id="kobo.1472.1"> is as simple as writing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1473.1">make([][]int, 2)</span></code><span class="koboSpan" id="kobo.1474.1">. </span><span class="koboSpan" id="kobo.1474.2">This returns a slice with two dimensions where the first dimension is 2 (rows) and the second dimension (columns) is unspecified and should be explicitly specified when adding data to it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1475.1">If you want to define and initialize a slice with two dimensions at the same time, you should execute something similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1476.1">twoD := [][]int{{1, 2, 3}, {4, 5, 6}}</span></code><span class="koboSpan" id="kobo.1477.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1478.1">You can find the length of an array or a slice using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1479.1">len()</span></code><span class="koboSpan" id="kobo.1480.1">. </span><span class="koboSpan" id="kobo.1480.2">You can add new elements to a full slice using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1481.1">append()</span></code><span class="koboSpan" id="kobo.1482.1"> function. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1483.1">append()</span></code><span class="koboSpan" id="kobo.1484.1"> automatically allocates the required memory space. </span><span class="koboSpan" id="kobo.1484.2">Keep in mind that you should assign the return value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1485.1">append()</span></code><span class="koboSpan" id="kobo.1486.1"> back to the desired variable as this is not an in-place change.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1487.1">The example that follows clarifies many things about slices—feel free to experiment with it. </span><span class="koboSpan" id="kobo.1487.2">Type the following code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1488.1">goSlices.go</span></code><span class="koboSpan" id="kobo.1489.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1490.1">package</span></span><span class="koboSpan" id="kobo.1491.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1492.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1493.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1494.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1495.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1496.1">()</span></span><span class="koboSpan" id="kobo.1497.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1498.1">// Create an empty slice</span></span><span class="koboSpan" id="kobo.1499.1">
    aSlice := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1500.1">float64</span></span><span class="koboSpan" id="kobo.1501.1">{}
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1502.1">// Both length and capacity are 0 because aSlice is empty</span></span><span class="koboSpan" id="kobo.1503.1">
    fmt.Println(aSlice, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1504.1">len</span></span><span class="koboSpan" id="kobo.1505.1">(aSlice), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1506.1">cap</span></span><span class="koboSpan" id="kobo.1507.1">(aSlice))
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1508.1">// Add elements to a slice</span></span><span class="koboSpan" id="kobo.1509.1">
    aSlice = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1510.1">append</span></span><span class="koboSpan" id="kobo.1511.1">(aSlice, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1512.1">1234.56</span></span><span class="koboSpan" id="kobo.1513.1">)
    aSlice = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1514.1">append</span></span><span class="koboSpan" id="kobo.1515.1">(aSlice, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1516.1">-34.0</span></span><span class="koboSpan" id="kobo.1517.1">)
    fmt.Println(aSlice, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1518.1">"with length"</span></span><span class="koboSpan" id="kobo.1519.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1520.1">len</span></span><span class="koboSpan" id="kobo.1521.1">(aSlice))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1522.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1523.1">append()</span></code><span class="koboSpan" id="kobo.1524.1"> commands add two new elements to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1525.1">aSlice</span></code><span class="koboSpan" id="kobo.1526.1">. </span><span class="koboSpan" id="kobo.1526.2">As stated before, the result of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1527.1">append()</span></code><span class="koboSpan" id="kobo.1528.1"> is not in-place and</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.1529.1"> must be assigned to the desired variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1530.1">// A slice with a length of 4</span></span><span class="koboSpan" id="kobo.1531.1">
    t := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1532.1">make</span></span><span class="koboSpan" id="kobo.1533.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1534.1">int</span></span><span class="koboSpan" id="kobo.1535.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1536.1">4</span></span><span class="koboSpan" id="kobo.1537.1">)
    t[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1538.1">0</span></span><span class="koboSpan" id="kobo.1539.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1540.1">-1</span></span><span class="koboSpan" id="kobo.1541.1">
    t[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1542.1">1</span></span><span class="koboSpan" id="kobo.1543.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1544.1">-2</span></span><span class="koboSpan" id="kobo.1545.1">
    t[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1546.1">2</span></span><span class="koboSpan" id="kobo.1547.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1548.1">-3</span></span><span class="koboSpan" id="kobo.1549.1">
    t[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1550.1">3</span></span><span class="koboSpan" id="kobo.1551.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1552.1">-4</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1553.1">// Now you will need to use append</span></span><span class="koboSpan" id="kobo.1554.1">
    t = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1555.1">append</span></span><span class="koboSpan" id="kobo.1556.1">(t, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1557.1">-5</span></span><span class="koboSpan" id="kobo.1558.1">)
    fmt.Println(t)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1559.1">Once a slice has no place left for more elements, you can only add new elements to it using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1560.1">append()</span></code><span class="koboSpan" id="kobo.1561.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1562.1">// A 2D slice</span></span><span class="koboSpan" id="kobo.1563.1">
    twoD := [][]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1564.1">int</span></span><span class="koboSpan" id="kobo.1565.1">{{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1566.1">1</span></span><span class="koboSpan" id="kobo.1567.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1568.1">2</span></span><span class="koboSpan" id="kobo.1569.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1570.1">3</span></span><span class="koboSpan" id="kobo.1571.1">}, {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1572.1">4</span></span><span class="koboSpan" id="kobo.1573.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1574.1">5</span></span><span class="koboSpan" id="kobo.1575.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1576.1">6</span></span><span class="koboSpan" id="kobo.1577.1">}}
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1578.1">// Visiting all elements of a 2D slice</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1579.1">// with a double for loop</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1580.1">for</span></span><span class="koboSpan" id="kobo.1581.1"> _, i := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1582.1">range</span></span><span class="koboSpan" id="kobo.1583.1"> twoD {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1584.1">for</span></span><span class="koboSpan" id="kobo.1585.1"> _, k := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1586.1">range</span></span><span class="koboSpan" id="kobo.1587.1"> i {
                fmt.Print(k, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1588.1">" "</span></span><span class="koboSpan" id="kobo.1589.1">)
            }
            fmt.Println()
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1590.1">The preceding code shows how to create a 2D slice variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1591.1">twoD</span></code><span class="koboSpan" id="kobo.1592.1"> and initialize it at the same time.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1593.1">    make2D := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1594.1">make</span></span><span class="koboSpan" id="kobo.1595.1">([][]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1596.1">int</span></span><span class="koboSpan" id="kobo.1597.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1598.1">2</span></span><span class="koboSpan" id="kobo.1599.1">)
    fmt.Println(make2D)
    make2D[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1600.1">0</span></span><span class="koboSpan" id="kobo.1601.1">] = []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1602.1">int</span></span><span class="koboSpan" id="kobo.1603.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1604.1">1</span></span><span class="koboSpan" id="kobo.1605.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1606.1">2</span></span><span class="koboSpan" id="kobo.1607.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1608.1">3</span></span><span class="koboSpan" id="kobo.1609.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1610.1">4</span></span><span class="koboSpan" id="kobo.1611.1">}
    make2D[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1612.1">1</span></span><span class="koboSpan" id="kobo.1613.1">] = []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1614.1">int</span></span><span class="koboSpan" id="kobo.1615.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1616.1">-1</span></span><span class="koboSpan" id="kobo.1617.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1618.1">-2</span></span><span class="koboSpan" id="kobo.1619.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1620.1">-3</span></span><span class="koboSpan" id="kobo.1621.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1622.1">-4</span></span><span class="koboSpan" id="kobo.1623.1">}
    fmt.Println(make2D)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1624.1">The previous part shows how to create a 2D slice with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1625.1">make()</span></code><span class="koboSpan" id="kobo.1626.1">. </span><span class="koboSpan" id="kobo.1626.2">What makes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1627.1">make2D</span></code><span class="koboSpan" id="kobo.1628.1"> a 2D slice is the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1629.1">[][]int</span></code><span class="koboSpan" id="kobo.1630.1"> in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1631.1">make()</span></code><span class="koboSpan" id="kobo.1632.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1633.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1634.1">goSlices.go</span></code><span class="koboSpan" id="kobo.1635.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1636.1">$ </span></span><span class="koboSpan" id="kobo.1637.1">go run goSlices.go 
[] 0 0
[1234.56 -34] with length 2
[-1 -2 -3 -4 -5]
1 2 3 
4 5 6 
[[] []]
[[1 2 3 4] [-1 -2 -3 -4]]
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-67"><span class="koboSpan" id="kobo.1638.1">About slice length and capacity</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1639.1">Both arrays and slices support the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1640.1">len()</span></code><span class="koboSpan" id="kobo.1641.1"> function for finding</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.1642.1"> out their length. </span><span class="koboSpan" id="kobo.1642.2">However, slices also have an additional property called </span><em class="italic"><span class="koboSpan" id="kobo.1643.1">capacity</span></em><span class="koboSpan" id="kobo.1644.1"> that can be found using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1645.1">cap()</span></code><span class="koboSpan" id="kobo.1646.1"> function. </span><span class="koboSpan" id="kobo.1646.2">The capacity of a slice is important when you want to select a part of a slice or when you want to reference an array using a slice.</span></p>
<p class="normal"><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1647.1">The capacity shows how much a slice can be expanded without the need to allocate more memory and change the underlying array</span></strong><span class="koboSpan" id="kobo.1648.1">. </span><span class="koboSpan" id="kobo.1648.2">Although after slice creation the capacity of a slice is handled by Go, a developer can define the capacity of a slice at creation time using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1649.1">make()</span></code><span class="koboSpan" id="kobo.1650.1"> function—after that, the capacity of the slice doubles each time the length of the slice is about to become bigger than its current capacity. </span><span class="koboSpan" id="kobo.1650.2">The first argument of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1651.1">make()</span></code><span class="koboSpan" id="kobo.1652.1"> is the type of the slice and its dimensions, the second is its initial length, and the third, which is optional, is the capacity of the slice. </span><span class="koboSpan" id="kobo.1652.2">Although the data type of a slice cannot change after creation, the other two properties can change.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1653.1">Writing something like </span><code class="inlineCode"><span class="koboSpan" id="kobo.1654.1">make([]int, 3, 2)</span></code><span class="koboSpan" id="kobo.1655.1"> generates an error message because at any given time the capacity of a slice (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1656.1">2</span></code><span class="koboSpan" id="kobo.1657.1">) cannot be smaller than its length (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1658.1">3</span></code><span class="koboSpan" id="kobo.1659.1">).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1660.1">The figure that follows illustrates how length and capacity work in slices.</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.1661.1"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" src="../Images/B21003_02_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1662.1">Figure 2.1: How slice length and capacity are related</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1663.1">For those of you that prefer code, here is</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.1664.1"> a small Go program that showcases the length and capacity properties of slices. </span><span class="koboSpan" id="kobo.1664.2">Type it and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1665.1">capLen.go</span></code><span class="koboSpan" id="kobo.1666.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1667.1">package</span></span><span class="koboSpan" id="kobo.1668.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1669.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1670.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1671.1">fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1672.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1673.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1674.1">()</span></span><span class="koboSpan" id="kobo.1675.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1676.1">// Only length is defined. </span><span class="koboSpan" id="kobo.1676.2">Capacity = length</span></span><span class="koboSpan" id="kobo.1677.1">
    a := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1678.1">make</span></span><span class="koboSpan" id="kobo.1679.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1680.1">int</span></span><span class="koboSpan" id="kobo.1681.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1682.1">4</span></span><span class="koboSpan" id="kobo.1683.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1684.1">In this case, the capacity of a is the same as its length, which is 4.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1685.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1686.1">"L:"</span></span><span class="koboSpan" id="kobo.1687.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1688.1">len</span></span><span class="koboSpan" id="kobo.1689.1">(a), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1690.1">"C:"</span></span><span class="koboSpan" id="kobo.1691.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1692.1">cap</span></span><span class="koboSpan" id="kobo.1693.1">(a))
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1694.1">// Initialize slice. </span><span class="koboSpan" id="kobo.1694.2">Capacity = length</span></span><span class="koboSpan" id="kobo.1695.1">
    b := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1696.1">int</span></span><span class="koboSpan" id="kobo.1697.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1698.1">0</span></span><span class="koboSpan" id="kobo.1699.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1700.1">1</span></span><span class="koboSpan" id="kobo.1701.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1702.1">2</span></span><span class="koboSpan" id="kobo.1703.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1704.1">3</span></span><span class="koboSpan" id="kobo.1705.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1706.1">4</span></span><span class="koboSpan" id="kobo.1707.1">}
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1708.1">"L:"</span></span><span class="koboSpan" id="kobo.1709.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1710.1">len</span></span><span class="koboSpan" id="kobo.1711.1">(b), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1712.1">"C:"</span></span><span class="koboSpan" id="kobo.1713.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1714.1">cap</span></span><span class="koboSpan" id="kobo.1715.1">(b))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1716.1">Once again, the capacity of slice </span><code class="inlineCode"><span class="koboSpan" id="kobo.1717.1">b</span></code><span class="koboSpan" id="kobo.1718.1"> is the same as its length, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1719.1">5</span></code><span class="koboSpan" id="kobo.1720.1"> because this is the default behavior.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1721.1">// Same length and capacity</span></span><span class="koboSpan" id="kobo.1722.1">
    aSlice := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1723.1">make</span></span><span class="koboSpan" id="kobo.1724.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1725.1">int</span></span><span class="koboSpan" id="kobo.1726.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1727.1">4</span></span><span class="koboSpan" id="kobo.1728.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1729.1">4</span></span><span class="koboSpan" id="kobo.1730.1">)
    fmt.Println(aSlice)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1731.1">This time the capacity of slice </span><code class="inlineCode"><span class="koboSpan" id="kobo.1732.1">aSlice</span></code><span class="koboSpan" id="kobo.1733.1"> is the same as its length, not because Go decided to do so but because we specified it in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1734.1">make()</span></code><span class="koboSpan" id="kobo.1735.1"> call.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1736.1">// Add an element</span></span><span class="koboSpan" id="kobo.1737.1">
    aSlice = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1738.1">append</span></span><span class="koboSpan" id="kobo.1739.1">(aSlice, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1740.1">5</span></span><span class="koboSpan" id="kobo.1741.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1742.1">When you add a new element to</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.1743.1"> slice </span><code class="inlineCode"><span class="koboSpan" id="kobo.1744.1">aSlice</span></code><span class="koboSpan" id="kobo.1745.1">, its capacity is doubled and becomes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1746.1">8</span></code><span class="koboSpan" id="kobo.1747.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1748.1">    fmt.Println(aSlice)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1749.1">// The capacity is doubled</span></span><span class="koboSpan" id="kobo.1750.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1751.1">"L:"</span></span><span class="koboSpan" id="kobo.1752.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1753.1">len</span></span><span class="koboSpan" id="kobo.1754.1">(aSlice), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1755.1">"C:"</span></span><span class="koboSpan" id="kobo.1756.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1757.1">cap</span></span><span class="koboSpan" id="kobo.1758.1">(aSlice))
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1759.1">// Now add four elements</span></span><span class="koboSpan" id="kobo.1760.1">
    aSlice = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1761.1">append</span></span><span class="koboSpan" id="kobo.1762.1">(aSlice, []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1763.1">int</span></span><span class="koboSpan" id="kobo.1764.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1765.1">-1</span></span><span class="koboSpan" id="kobo.1766.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1767.1">-2</span></span><span class="koboSpan" id="kobo.1768.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1769.1">-3</span></span><span class="koboSpan" id="kobo.1770.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1771.1">-4</span></span><span class="koboSpan" id="kobo.1772.1">}...)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1773.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1774.1">...</span></code><span class="koboSpan" id="kobo.1775.1"> operator expands </span><code class="inlineCode"><span class="koboSpan" id="kobo.1776.1">[]int{-1, -2, -3, -4}</span></code><span class="koboSpan" id="kobo.1777.1"> into multiple arguments and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1778.1">append()</span></code><span class="koboSpan" id="kobo.1779.1"> appends each argument one by one to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1780.1">aSlice</span></code><span class="koboSpan" id="kobo.1781.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1782.1">    fmt.Println(aSlice)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1783.1">// The capacity is doubled</span></span><span class="koboSpan" id="kobo.1784.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1785.1">"L:"</span></span><span class="koboSpan" id="kobo.1786.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1787.1">len</span></span><span class="koboSpan" id="kobo.1788.1">(aSlice), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1789.1">"C:"</span></span><span class="koboSpan" id="kobo.1790.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1791.1">cap</span></span><span class="koboSpan" id="kobo.1792.1">(aSlice))
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1793.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1794.1">capLen.go</span></code><span class="koboSpan" id="kobo.1795.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1796.1">$ </span></span><span class="koboSpan" id="kobo.1797.1">go run capLen.go 
L: 4 C: 4
L: 5 C: 5
[0 0 0 0]
[0 0 0 0 5]
L: 5 C: 8
[0 0 0 0 5 -1 -2 -3 -4]
L: 9 C: 16
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1798.1">Setting the correct capacity of a slice, if known in advance, will make your programs faster because Go will not have to allocate a new underlying array and have all the data copied over. </span><span class="koboSpan" id="kobo.1798.2">This is important when dealing with very large slices.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1799.1">Working with slices is good but what happens when you want to work with a continuous part of an existing slice? </span><span class="koboSpan" id="kobo.1799.2">Is there a practical way to select a part of a slice? </span><span class="koboSpan" id="kobo.1799.3">Fortunately, the answer is yes—the next subsection sheds some light on selecting a continuous part of a slice.</span></p>
<h2 class="heading-2" id="_idParaDest-68"><span class="koboSpan" id="kobo.1800.1">Selecting a part of a slice</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1801.1">Go allows you to select parts of a slice, provided that all desired elements are next to each other. </span><span class="koboSpan" id="kobo.1801.2">This can be handy when you select a</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.1802.1"> range of elements and you do not want to give their indexes one by one. </span><span class="koboSpan" id="kobo.1802.2">In Go, you select a part of a slice by specifying (directly or indirectly) two indexes, where the first one is the beginning of the selection and the second one is the end of the selection, without including the element at that index, separated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1803.1">:</span></code><span class="koboSpan" id="kobo.1804.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1805.1">If you want to process all the command line arguments of a utility apart from the first one, which is its file path, you can assign it to a new variable (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1806.1">arguments := os.Args</span></code><span class="koboSpan" id="kobo.1807.1">) for ease of use and use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1808.1">arguments[1:]</span></code><span class="koboSpan" id="kobo.1809.1"> notation to skip the first command line argument.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1810.1">However, there is a variation where you can add a third parameter that controls the capacity of the resulting slice. </span><span class="koboSpan" id="kobo.1810.2">So, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1811.1">aSlice[0:2:4]</span></code><span class="koboSpan" id="kobo.1812.1"> selects the first 2 elements of a slice (at indexes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1813.1">0</span></code><span class="koboSpan" id="kobo.1814.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1815.1">1</span></code><span class="koboSpan" id="kobo.1816.1">) and creates a new slice with a maximum capacity of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1817.1">4</span></code><span class="koboSpan" id="kobo.1818.1">. </span><span class="koboSpan" id="kobo.1818.2">The resulting capacity is defined as the result of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1819.1">4-0</span></code><span class="koboSpan" id="kobo.1820.1"> subtraction where 4 is the maximum capacity and 0 is the first index—if the first index is omitted, it is automatically set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1821.1">0</span></code><span class="koboSpan" id="kobo.1822.1">. </span><span class="koboSpan" id="kobo.1822.2">In this case, the capacity of the result slice will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1823.1">4</span></code><span class="koboSpan" id="kobo.1824.1"> because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1825.1">4-0</span></code><span class="koboSpan" id="kobo.1826.1"> equals </span><code class="inlineCode"><span class="koboSpan" id="kobo.1827.1">4</span></code><span class="koboSpan" id="kobo.1828.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1829.1">If we had used </span><code class="inlineCode"><span class="koboSpan" id="kobo.1830.1">aSlice[2:4:4]</span></code><span class="koboSpan" id="kobo.1831.1">, we would have created a new slice with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1832.1">aSlice[2]</span></code><span class="koboSpan" id="kobo.1833.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1834.1">aSlice[3]</span></code><span class="koboSpan" id="kobo.1835.1"> elements and with a capacity of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1836.1">4-2</span></code><span class="koboSpan" id="kobo.1837.1">. </span><span class="koboSpan" id="kobo.1837.2">Lastly, the resulting capacity cannot be bigger than the capacity of the original slice because in that case, you would need a different underlying array.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1838.1">Type the following code into your favorite editor and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1839.1">partSlice.go</span></code><span class="koboSpan" id="kobo.1840.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1841.1">package</span></span><span class="koboSpan" id="kobo.1842.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1843.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1844.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1845.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1846.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1847.1">()</span></span><span class="koboSpan" id="kobo.1848.1"> {
    aSlice := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1849.1">int</span></span><span class="koboSpan" id="kobo.1850.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1851.1">0</span></span><span class="koboSpan" id="kobo.1852.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1853.1">1</span></span><span class="koboSpan" id="kobo.1854.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1855.1">2</span></span><span class="koboSpan" id="kobo.1856.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1857.1">3</span></span><span class="koboSpan" id="kobo.1858.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1859.1">4</span></span><span class="koboSpan" id="kobo.1860.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1861.1">5</span></span><span class="koboSpan" id="kobo.1862.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1863.1">6</span></span><span class="koboSpan" id="kobo.1864.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1865.1">7</span></span><span class="koboSpan" id="kobo.1866.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1867.1">8</span></span><span class="koboSpan" id="kobo.1868.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1869.1">9</span></span><span class="koboSpan" id="kobo.1870.1">}
    fmt.Println(aSlice)
    l := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1871.1">len</span></span><span class="koboSpan" id="kobo.1872.1">(aSlice)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1873.1">// First 5 elements</span></span><span class="koboSpan" id="kobo.1874.1">
    fmt.Println(aSlice[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1875.1">0</span></span><span class="koboSpan" id="kobo.1876.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1877.1">5</span></span><span class="koboSpan" id="kobo.1878.1">])
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1879.1">// First 5 elements</span></span><span class="koboSpan" id="kobo.1880.1">
    fmt.Println(aSlice[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1881.1">5</span></span><span class="koboSpan" id="kobo.1882.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1883.1">In this first part, we define a new slice named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1884.1">aSlice</span></code><span class="koboSpan" id="kobo.1885.1"> that has 10 elements. </span><span class="koboSpan" id="kobo.1885.2">Its capacity is the same as its length. </span><span class="koboSpan" id="kobo.1885.3">Both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1886.1">0:5</span></code><span class="koboSpan" id="kobo.1887.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1888.1">:5</span></code><span class="koboSpan" id="kobo.1889.1"> notations select the first 5 elements of the slice, which are the elements found </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.1890.1">at indexes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1891.1">0</span></code><span class="koboSpan" id="kobo.1892.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1893.1">1</span></code><span class="koboSpan" id="kobo.1894.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1895.1">2</span></code><span class="koboSpan" id="kobo.1896.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1897.1">3</span></code><span class="koboSpan" id="kobo.1898.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1899.1">4</span></code><span class="koboSpan" id="kobo.1900.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1901.1">// Last 2 elements</span></span><span class="koboSpan" id="kobo.1902.1">
    fmt.Println(aSlice[l</span><span class="hljs-number"><span class="koboSpan" id="kobo.1903.1">-2</span></span><span class="koboSpan" id="kobo.1904.1"> : l])
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1905.1">// Last 2 elements</span></span><span class="koboSpan" id="kobo.1906.1">
    fmt.Println(aSlice[l</span><span class="hljs-number"><span class="koboSpan" id="kobo.1907.1">-2</span></span><span class="koboSpan" id="kobo.1908.1">:])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1909.1">Given the length of the slice (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1910.1">l</span></code><span class="koboSpan" id="kobo.1911.1">), we can select the last two elements of the slice either as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1912.1">l-2:l</span></code><span class="koboSpan" id="kobo.1913.1"> or as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1914.1">l-2:</span></code><span class="koboSpan" id="kobo.1915.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1916.1">// First 5 elements</span></span><span class="koboSpan" id="kobo.1917.1">
    t := aSlice[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1918.1">0</span></span><span class="koboSpan" id="kobo.1919.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1920.1">5</span></span><span class="koboSpan" id="kobo.1921.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1922.1">10</span></span><span class="koboSpan" id="kobo.1923.1">]
    fmt.Println(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1924.1">len</span></span><span class="koboSpan" id="kobo.1925.1">(t), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1926.1">cap</span></span><span class="koboSpan" id="kobo.1927.1">(t))
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1928.1">// Elements at indexes 2,3,4</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1929.1">// Capacity will be 10-2</span></span><span class="koboSpan" id="kobo.1930.1">
    t = aSlice[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1931.1">2</span></span><span class="koboSpan" id="kobo.1932.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1933.1">5</span></span><span class="koboSpan" id="kobo.1934.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1935.1">10</span></span><span class="koboSpan" id="kobo.1936.1">]
    fmt.Println(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1937.1">len</span></span><span class="koboSpan" id="kobo.1938.1">(t), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1939.1">cap</span></span><span class="koboSpan" id="kobo.1940.1">(t))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1941.1">Initially, the capacity of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1942.1">t</span></code><span class="koboSpan" id="kobo.1943.1"> will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1944.1">10-0</span></code><span class="koboSpan" id="kobo.1945.1">, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1946.1">10</span></code><span class="koboSpan" id="kobo.1947.1">. </span><span class="koboSpan" id="kobo.1947.2">In the second case, the capacity of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1948.1">t</span></code><span class="koboSpan" id="kobo.1949.1"> will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1950.1">10-2</span></code><span class="koboSpan" id="kobo.1951.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1952.1">// Elements at indexes 0,1,2,3,4</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1953.1">// New capacity will be 6-0</span></span><span class="koboSpan" id="kobo.1954.1">
    t = aSlice[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1955.1">5</span></span><span class="koboSpan" id="kobo.1956.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1957.1">6</span></span><span class="koboSpan" id="kobo.1958.1">]
    fmt.Println(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1959.1">len</span></span><span class="koboSpan" id="kobo.1960.1">(t), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1961.1">cap</span></span><span class="koboSpan" id="kobo.1962.1">(t))
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1963.1">The capacity of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1964.1">t</span></code><span class="koboSpan" id="kobo.1965.1"> is now </span><code class="inlineCode"><span class="koboSpan" id="kobo.1966.1">6-0</span></code><span class="koboSpan" id="kobo.1967.1"> and its length is going to be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1968.1">5</span></code><span class="koboSpan" id="kobo.1969.1"> because we have selected the first five elements of slice </span><code class="inlineCode"><span class="koboSpan" id="kobo.1970.1">aSlice</span></code><span class="koboSpan" id="kobo.1971.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1972.1">The output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1973.1">partSlice.go</span></code><span class="koboSpan" id="kobo.1974.1"> is presented in small chunks:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1975.1">$ </span></span><span class="koboSpan" id="kobo.1976.1">go run partSlice.go
[0 1 2 3 4 5 6 7 8 9]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1977.1">The previous line is the output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1978.1">fmt.Println(aSlice)</span></code><span class="koboSpan" id="kobo.1979.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1980.1">[0 1 2 3 4]
[0 1 2 3 4]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1981.1">The previous two lines are generated</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.1982.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1983.1">fmt.Println(aSlice[0:5])</span></code><span class="koboSpan" id="kobo.1984.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1985.1">fmt.Println(aSlice[:5])</span></code><span class="koboSpan" id="kobo.1986.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1987.1">[8 9]
[8 9]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1988.1">Analogously, the previous two lines are generated from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1989.1">fmt.Println(aSlice[l-2 : l])</span></code><span class="koboSpan" id="kobo.1990.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1991.1">fmt.Println(aSlice[l-2:])</span></code><span class="koboSpan" id="kobo.1992.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1993.1">5 10
3 8
5 6
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1994.1">The last three lines print the length and the capacity of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1995.1">aSlice[0:5:10]</span></code><span class="koboSpan" id="kobo.1996.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1997.1">aSlice[2:5:10]</span></code><span class="koboSpan" id="kobo.1998.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1999.1">aSlice[:5:6]</span></code><span class="koboSpan" id="kobo.2000.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-69"><span class="koboSpan" id="kobo.2001.1">Byte slices</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2002.1">A byte slice is a slice of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2003.1">byte</span></code><span class="koboSpan" id="kobo.2004.1"> data type (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2005.1">[]byte</span></code><span class="koboSpan" id="kobo.2006.1">). </span><span class="koboSpan" id="kobo.2006.2">Go knows that most byte slices are used to store strings and so makes it </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.2007.1">easy to switch between this type and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2008.1">string</span></code><span class="koboSpan" id="kobo.2009.1"> type. </span><span class="koboSpan" id="kobo.2009.2">There is nothing special in the way you can access a byte slice compared to the other types of slices. </span><span class="koboSpan" id="kobo.2009.3">What is special is that </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2010.1">Go uses byte slices for performing file I/O operations because they allow you to determine with precision the amount of data you want to read or write to a file</span></strong><span class="koboSpan" id="kobo.2011.1">. </span><span class="koboSpan" id="kobo.2011.2">This happens because bytes are a universal unit among computer systems.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2012.1">As Go does not have a data type for storing single characters, it uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.2013.1">byte</span></code><span class="koboSpan" id="kobo.2014.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2015.1">rune</span></code><span class="koboSpan" id="kobo.2016.1"> for storing character values. </span><span class="koboSpan" id="kobo.2016.2">A single byte can store a single ASCII character only whereas a rune can store Unicode characters. </span><span class="koboSpan" id="kobo.2016.3">As a result, a rune can occupy multiple bytes.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2017.1">The small program that follows illustrates how you can convert a byte slice into a string and vice versa, which you need for most file I/O operations—type it and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2018.1">byteSlices.go</span></code><span class="koboSpan" id="kobo.2019.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2020.1">package</span></span><span class="koboSpan" id="kobo.2021.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2022.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2023.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2024.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2025.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2026.1">()</span></span><span class="koboSpan" id="kobo.2027.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2028.1">// Byte slice</span></span><span class="koboSpan" id="kobo.2029.1">
    b := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2030.1">make</span></span><span class="koboSpan" id="kobo.2031.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2032.1">byte</span></span><span class="koboSpan" id="kobo.2033.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2034.1">12</span></span><span class="koboSpan" id="kobo.2035.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2036.1">"Byte slice:"</span></span><span class="koboSpan" id="kobo.2037.1">, b)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2038.1">An empty byte slice contains zeros—in this case, 12 zeros.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2039.1">    b = []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2040.1">byte</span></span><span class="koboSpan" id="kobo.2041.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2042.1">"Byte slice €"</span></span><span class="koboSpan" id="kobo.2043.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2044.1">"Byte slice:"</span></span><span class="koboSpan" id="kobo.2045.1">, b)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2046.1">In this case, the size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2047.1">b</span></code><span class="koboSpan" id="kobo.2048.1"> is the size of the string </span><code class="inlineCode"><span class="koboSpan" id="kobo.2049.1">"Byte slice €"</span></code><span class="koboSpan" id="kobo.2050.1">, without the double quotes—</span><code class="inlineCode"><span class="koboSpan" id="kobo.2051.1">b</span></code><span class="koboSpan" id="kobo.2052.1"> now points to a different</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.2053.1"> memory location than before, which is where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2054.1">"Byte slice €"</span></code><span class="koboSpan" id="kobo.2055.1"> is stored. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2056.1">This is how you convert a string into a byte slice</span></strong><span class="koboSpan" id="kobo.2057.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2058.1">As Unicode characters like </span><code class="inlineCode"><span class="koboSpan" id="kobo.2059.1">€</span></code><span class="koboSpan" id="kobo.2060.1"> need more than one byte for their representation, the length of the byte slice might not be the same as the length of the string that it stores.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2061.1">// Print byte slice contents as text</span></span><span class="koboSpan" id="kobo.2062.1">
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2063.1">"Byte slice as text: %s\n"</span></span><span class="koboSpan" id="kobo.2064.1">, b)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2065.1">"Byte slice as text:"</span></span><span class="koboSpan" id="kobo.2066.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2067.1">string</span></span><span class="koboSpan" id="kobo.2068.1">(b))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2069.1">The preceding code shows how to print the contents of a byte slice as text using two techniques. </span><span class="koboSpan" id="kobo.2069.2">The first one is by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2070.1">%s</span></code><span class="koboSpan" id="kobo.2071.1"> control string and the second one using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2072.1">string()</span></code><span class="koboSpan" id="kobo.2073.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2074.1">// Length of b</span></span><span class="koboSpan" id="kobo.2075.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2076.1">"Length of b:"</span></span><span class="koboSpan" id="kobo.2077.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2078.1">len</span></span><span class="koboSpan" id="kobo.2079.1">(b))
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2080.1">The preceding code prints the real length of the byte slice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2081.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2082.1">byteSlices.go</span></code><span class="koboSpan" id="kobo.2083.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2084.1">$ </span></span><span class="koboSpan" id="kobo.2085.1">go run byteSlices.go 
Byte slice: [0 0 0 0 0 0 0 0 0 0 0 0]
Byte slice: [66 121 116 101 32 115 108 105 99 101 32 226 130 172]
Byte slice as text: Byte slice €
Byte slice as text: Byte slice €
Length of b: 14
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2086.1">The last line of the output proves that although the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2087.1">b</span></code><span class="koboSpan" id="kobo.2088.1"> byte slice contains 12 characters, it has a size of 14.</span></p>
<h2 class="heading-2" id="_idParaDest-70"><span class="koboSpan" id="kobo.2089.1">Deleting an element from a slice</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2090.1">There is no default function for deleting an element from a slice without using a package such as</span><strong class="bold-italic" style="font-style: italic;"> </strong><code class="inlineCode"><span class="koboSpan" id="kobo.2091.1">slices</span></code><span class="koboSpan" id="kobo.2092.1">, which means that if you need to delete an element from a slice, you must write your own code. </span><span class="koboSpan" id="kobo.2092.2">However, starting with Go 1.21, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2093.1">slices.Delete()</span></code><span class="koboSpan" id="kobo.2094.1"> for that purpose. </span><span class="koboSpan" id="kobo.2094.2">Therefore, this subsection is relevant when using an older Go version or when you want to </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.2095.1">manually delete an element.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2096.1">Deleting an element from a slice can be tricky, so this subsection presents two techniques for doing so. </span><span class="koboSpan" id="kobo.2096.2">The first technique virtually divides the original slice into two slices, split at the index of the element that needs to be deleted. </span><span class="koboSpan" id="kobo.2096.3">Neither of the two slices includes the element that is going to be deleted. </span><span class="koboSpan" id="kobo.2096.4">After that, it concatenates these two slices and creates a new one.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2097.1">The second technique copies the last element at the place of the element that is going to be deleted and creates a new slice by excluding the last element from the original slice. </span><span class="koboSpan" id="kobo.2097.2">However, this particular technique changes the order of the slice elements, which in some cases might be important.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2098.1">The next figure shows a graphical representation of the two techniques for deleting an element from a slice.</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.2099.1"><img alt="A picture containing text, screenshot, font, design  Description automatically generated" src="../Images/B21003_02_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2100.1">Figure 2.2: Deleting an element from a slice</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2101.1">The following program shows the </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.2102.1">two techniques that can be used for deleting an element from a slice. </span><span class="koboSpan" id="kobo.2102.2">Create a text file by typing the following code—save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2103.1">deleteSlice.go</span></code><span class="koboSpan" id="kobo.2104.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2105.1">package</span></span><span class="koboSpan" id="kobo.2106.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2107.1">import</span></span><span class="koboSpan" id="kobo.2108.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2109.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2110.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2111.1">"strconv"</span></span><span class="koboSpan" id="kobo.2112.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2113.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2114.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2115.1">()</span></span><span class="koboSpan" id="kobo.2116.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2117.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2118.1">len</span></span><span class="koboSpan" id="kobo.2119.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2120.1">1</span></span><span class="koboSpan" id="kobo.2121.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2122.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2123.1">Need an integer value."</span></span><span class="koboSpan" id="kobo.2124.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2125.1">return</span></span><span class="koboSpan" id="kobo.2126.1">
    }
    index := arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2127.1">1</span></span><span class="koboSpan" id="kobo.2128.1">]
    i, err := strconv.Atoi(index)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2129.1">if</span></span><span class="koboSpan" id="kobo.2130.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2131.1">nil</span></span><span class="koboSpan" id="kobo.2132.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2133.1">return</span></span><span class="koboSpan" id="kobo.2134.1">
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2135.1">"Using index"</span></span><span class="koboSpan" id="kobo.2136.1">, i)
    aSlice := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2137.1">int</span></span><span class="koboSpan" id="kobo.2138.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2139.1">0</span></span><span class="koboSpan" id="kobo.2140.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2141.1">1</span></span><span class="koboSpan" id="kobo.2142.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2143.1">2</span></span><span class="koboSpan" id="kobo.2144.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2145.1">3</span></span><span class="koboSpan" id="kobo.2146.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2147.1">4</span></span><span class="koboSpan" id="kobo.2148.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2149.1">5</span></span><span class="koboSpan" id="kobo.2150.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2151.1">6</span></span><span class="koboSpan" id="kobo.2152.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2153.1">7</span></span><span class="koboSpan" id="kobo.2154.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2155.1">8</span></span><span class="koboSpan" id="kobo.2156.1">}
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2157.1">"Original slice:"</span></span><span class="koboSpan" id="kobo.2158.1">, aSlice)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2159.1">// Delete element at index i</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2160.1">if</span></span><span class="koboSpan" id="kobo.2161.1"> i &gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2162.1">len</span></span><span class="koboSpan" id="kobo.2163.1">(aSlice)</span><span class="hljs-number"><span class="koboSpan" id="kobo.2164.1">-1</span></span><span class="koboSpan" id="kobo.2165.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2166.1">"Cannot delete element"</span></span><span class="koboSpan" id="kobo.2167.1">, i)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2168.1">return</span></span><span class="koboSpan" id="kobo.2169.1">
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2170.1">// The ... </span><span class="koboSpan" id="kobo.2170.2">operator auto expands aSlice[i+1:] so that</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2171.1">// its elements can be appended to aSlice[:i] one by one</span></span><span class="koboSpan" id="kobo.2172.1">
    aSlice = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2173.1">append</span></span><span class="koboSpan" id="kobo.2174.1">(aSlice[:i], aSlice[i+</span><span class="hljs-number"><span class="koboSpan" id="kobo.2175.1">1</span></span><span class="koboSpan" id="kobo.2176.1">:]...)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2177.1">"After 1st deletion:"</span></span><span class="koboSpan" id="kobo.2178.1">, aSlice)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2179.1">Here we logically divide the original slice into two slices. </span><span class="koboSpan" id="kobo.2179.2">The two slices are split at the index of the element that needs</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.2180.1"> to be deleted. </span><span class="koboSpan" id="kobo.2180.2">After that, we concatenate these two slices with the help of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2181.1">...</span></code><span class="koboSpan" id="kobo.2182.1">. </span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2183.1">Go supports the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2184.1">...</span></code><span class="koboSpan" id="kobo.2185.1"> operator, which is used for exploding a slice or an array into multiple arguments before appending it to an existing slice.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2186.1">Next, we see the second technique in action:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2187.1">// Delete element at index i</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2188.1">if</span></span><span class="koboSpan" id="kobo.2189.1"> i &gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2190.1">len</span></span><span class="koboSpan" id="kobo.2191.1">(aSlice)</span><span class="hljs-number"><span class="koboSpan" id="kobo.2192.1">-1</span></span><span class="koboSpan" id="kobo.2193.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2194.1">"Cannot delete element"</span></span><span class="koboSpan" id="kobo.2195.1">, i)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2196.1">return</span></span><span class="koboSpan" id="kobo.2197.1">
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2198.1">// Replace element at index i with last element</span></span><span class="koboSpan" id="kobo.2199.1">
    aSlice[i] = aSlice[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2200.1">len</span></span><span class="koboSpan" id="kobo.2201.1">(aSlice)</span><span class="hljs-number"><span class="koboSpan" id="kobo.2202.1">-1</span></span><span class="koboSpan" id="kobo.2203.1">]
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2204.1">// Remove last element</span></span><span class="koboSpan" id="kobo.2205.1">
    aSlice = aSlice[:</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2206.1">len</span></span><span class="koboSpan" id="kobo.2207.1">(aSlice)</span><span class="hljs-number"><span class="koboSpan" id="kobo.2208.1">-1</span></span><span class="koboSpan" id="kobo.2209.1">]
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2210.1">"After 2nd deletion:"</span></span><span class="koboSpan" id="kobo.2211.1">, aSlice)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2212.1">We replace the element that we want to delete with the last element using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2213.1">aSlice[i] = aSlice[len(aSlice)-1]</span></code><span class="koboSpan" id="kobo.2214.1"> statement and then we remove the last element with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2215.1">aSlice = aSlice[:len(aSlice)-1]</span></code><span class="koboSpan" id="kobo.2216.1"> statement.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2217.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2218.1">deleteSlice.go</span></code><span class="koboSpan" id="kobo.2219.1"> produces </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.2220.1">the following kind of output, depending on your input:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2221.1">$ </span></span><span class="koboSpan" id="kobo.2222.1">go run deleteSlice.go 1
Using index 1
Original slice: [0 1 2 3 4 5 6 7 8]
After 1st deletion: [0 2 3 4 5 6 7 8]
After 2nd deletion: [0 8 3 4 5 6 7]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2223.1">As the slice has nine elements, you can delete the element at index value </span><code class="inlineCode"><span class="koboSpan" id="kobo.2224.1">1</span></code><span class="koboSpan" id="kobo.2225.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2226.1">$ </span></span><span class="koboSpan" id="kobo.2227.1">go run deleteSlice.go 10
Using index 10
Original slice: [0 1 2 3 4 5 6 7 8]
Cannot delete element 10
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2228.1">As the slice has only nine elements, you cannot delete an element with an index value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2229.1">10</span></code><span class="koboSpan" id="kobo.2230.1"> from the slice.</span></p>
<h2 class="heading-2" id="_idParaDest-71"><span class="koboSpan" id="kobo.2231.1">How slices are connected to arrays</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2232.1">As mentioned before, behind the scenes, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2233.1">a slice is implemented using an underlying array</span></strong><span class="koboSpan" id="kobo.2234.1">. </span><span class="koboSpan" id="kobo.2234.2">The length of the underlying array is the same as the capacity of the slice and there exist pointers that connect the slice elements to the appropriate array elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2235.1">You can understand that by connecting </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.2236.1">an existing array with a slice, Go allows you to reference an array or a part of an array using a slice. </span><span class="koboSpan" id="kobo.2236.2">This has some strange capabilities including the fact that the changes to the slice affect the referenced array! </span><span class="koboSpan" id="kobo.2236.3">However, when the capacity of the slice changes, the connection to the array ceases to exist! </span><span class="koboSpan" id="kobo.2236.4">This happens because when the capacity of a slice changes, so does the underlying array, and the connection between the slice and the original array does not exist anymore.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2237.1">Type the following code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2238.1">sliceArrays.go</span></code><span class="koboSpan" id="kobo.2239.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2240.1">package</span></span><span class="koboSpan" id="kobo.2241.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2242.1">import</span></span><span class="koboSpan" id="kobo.2243.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2244.1">"fmt"</span></span><span class="koboSpan" id="kobo.2245.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2246.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2247.1">change</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2248.1">(s []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2249.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2250.1">)</span></span><span class="koboSpan" id="kobo.2251.1"> {
    s[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2252.1">0</span></span><span class="koboSpan" id="kobo.2253.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2254.1">"Change_function"</span></span><span class="koboSpan" id="kobo.2255.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2256.1">This is a function that changes the first </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.2257.1">element of its input slice.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2258.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2259.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2260.1">()</span></span><span class="koboSpan" id="kobo.2261.1"> {
    a := [</span><span class="hljs-number"><span class="koboSpan" id="kobo.2262.1">4</span></span><span class="koboSpan" id="kobo.2263.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2264.1">string</span></span><span class="koboSpan" id="kobo.2265.1">{</span><span class="hljs-string"><span class="koboSpan" id="kobo.2266.1">"Zero"</span></span><span class="koboSpan" id="kobo.2267.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2268.1">"One"</span></span><span class="koboSpan" id="kobo.2269.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2270.1">"Two"</span></span><span class="koboSpan" id="kobo.2271.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2272.1">"Three"</span></span><span class="koboSpan" id="kobo.2273.1">}
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2274.1">"a:"</span></span><span class="koboSpan" id="kobo.2275.1">, a)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2276.1">Here we define an array named a with 4 elements.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2277.1">var</span></span><span class="koboSpan" id="kobo.2278.1"> S0 = a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2279.1">0</span></span><span class="koboSpan" id="kobo.2280.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.2281.1">1</span></span><span class="koboSpan" id="kobo.2282.1">]
    fmt.Println(S0)
    S0[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2283.1">0</span></span><span class="koboSpan" id="kobo.2284.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2285.1">"S0"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2286.1">Here we connect </span><code class="inlineCode"><span class="koboSpan" id="kobo.2287.1">S0</span></code><span class="koboSpan" id="kobo.2288.1"> with the first element of the array </span><code class="inlineCode"><span class="koboSpan" id="kobo.2289.1">a</span></code><span class="koboSpan" id="kobo.2290.1"> and we print it. </span><span class="koboSpan" id="kobo.2290.2">Then we change the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2291.1">S0[0]</span></code><span class="koboSpan" id="kobo.2292.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2293.1">var</span></span><span class="koboSpan" id="kobo.2294.1"> S12 = a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2295.1">1</span></span><span class="koboSpan" id="kobo.2296.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.2297.1">3</span></span><span class="koboSpan" id="kobo.2298.1">]
    fmt.Println(S12)
    S12[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2299.1">0</span></span><span class="koboSpan" id="kobo.2300.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2301.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2302.1">S12_0"</span></span><span class="koboSpan" id="kobo.2303.1">
    S12[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2304.1">1</span></span><span class="koboSpan" id="kobo.2305.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2306.1">"S12_1"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2307.1">In this part, we associate </span><code class="inlineCode"><span class="koboSpan" id="kobo.2308.1">S12</span></code><span class="koboSpan" id="kobo.2309.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2310.1">a[1]</span></code><span class="koboSpan" id="kobo.2311.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2312.1">a[2]</span></code><span class="koboSpan" id="kobo.2313.1">. </span><span class="koboSpan" id="kobo.2313.2">Therefore </span><code class="inlineCode"><span class="koboSpan" id="kobo.2314.1">S12[0] = a[1]</span></code><span class="koboSpan" id="kobo.2315.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2316.1">S12[1] = a[2]</span></code><span class="koboSpan" id="kobo.2317.1">. </span><span class="koboSpan" id="kobo.2317.2">Then, we change the values of both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2318.1">S12[0]</span></code><span class="koboSpan" id="kobo.2319.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2320.1">S12[1]</span></code><span class="koboSpan" id="kobo.2321.1">. </span><span class="koboSpan" id="kobo.2321.2">These two changes will also change the contents of a. </span><span class="koboSpan" id="kobo.2321.3">Put simply, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2322.1">a[1]</span></code><span class="koboSpan" id="kobo.2323.1"> takes the new value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2324.1">S12[0]</span></code><span class="koboSpan" id="kobo.2325.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2326.1">a[2]</span></code><span class="koboSpan" id="kobo.2327.1"> takes the new value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2328.1">S12[1]</span></code><span class="koboSpan" id="kobo.2329.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2330.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2331.1">"a:"</span></span><span class="koboSpan" id="kobo.2332.1">, a)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2333.1">And we print variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.2334.1">a</span></code><span class="koboSpan" id="kobo.2335.1">, which has not changed at all in a direct way. </span><span class="koboSpan" id="kobo.2335.2">However, due to the connections of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2336.1">a</span></code><span class="koboSpan" id="kobo.2337.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2338.1">S0</span></code><span class="koboSpan" id="kobo.2339.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2340.1">S12</span></code><span class="koboSpan" id="kobo.2341.1">, the contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2342.1">a</span></code><span class="koboSpan" id="kobo.2343.1"> have changed!</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2344.1">// Changes to slice -&gt; changes to array</span></span><span class="koboSpan" id="kobo.2345.1">
    change(S12)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2346.1">"a:"</span></span><span class="koboSpan" id="kobo.2347.1">, a)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2348.1">As the slice and the array are connected, any changes you make to the slice will also affect the array even if the changes take place inside a function.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2349.1">// capacity of S0</span></span><span class="koboSpan" id="kobo.2350.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2351.1">"Capacity of S0:"</span></span><span class="koboSpan" id="kobo.2352.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2353.1">cap</span></span><span class="koboSpan" id="kobo.2354.1">(S0), </span><span class="hljs-string"><span class="koboSpan" id="kobo.2355.1">"Length of S0:"</span></span><span class="koboSpan" id="kobo.2356.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2357.1">len</span></span><span class="koboSpan" id="kobo.2358.1">(S0))
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2359.1">// Adding 4 elements to S0</span></span><span class="koboSpan" id="kobo.2360.1">
    S0 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2361.1">append</span></span><span class="koboSpan" id="kobo.2362.1">(S0, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2363.1">"N1"</span></span><span class="koboSpan" id="kobo.2364.1">)
    S0 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2365.1">append</span></span><span class="koboSpan" id="kobo.2366.1">(S0, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2367.1">"N2"</span></span><span class="koboSpan" id="kobo.2368.1">)
    S0 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2369.1">append</span></span><span class="koboSpan" id="kobo.2370.1">(S0, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2371.1">"N3"</span></span><span class="koboSpan" id="kobo.2372.1">)
    a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2373.1">0</span></span><span class="koboSpan" id="kobo.2374.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2375.1">"-N1"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2376.1">As the capacity of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2377.1">S0</span></code><span class="koboSpan" id="kobo.2378.1"> changes, it is no longer connected to the same underlying array (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2379.1">a</span></code><span class="koboSpan" id="kobo.2380.1">).</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2381.1">// Changing the capacity of S0</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2382.1">// Not the same underlying array anymore!</span></span><span class="koboSpan" id="kobo.2383.1">
    S0 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2384.1">append</span></span><span class="koboSpan" id="kobo.2385.1">(S0, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2386.1">"N4"</span></span><span class="koboSpan" id="kobo.2387.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2388.1">"Capacity of S0:"</span></span><span class="koboSpan" id="kobo.2389.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2390.1">cap</span></span><span class="koboSpan" id="kobo.2391.1">(S0), </span><span class="hljs-string"><span class="koboSpan" id="kobo.2392.1">"Length of S0:"</span></span><span class="koboSpan" id="kobo.2393.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2394.1">len</span></span><span class="koboSpan" id="kobo.2395.1">(S0))
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2396.1">// This change does not go to S0</span></span><span class="koboSpan" id="kobo.2397.1">
    a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2398.1">0</span></span><span class="koboSpan" id="kobo.2399.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2400.1">"-N1-"</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2401.1">// This change goes to S12</span></span><span class="koboSpan" id="kobo.2402.1">
    a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2403.1">1</span></span><span class="koboSpan" id="kobo.2404.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2405.1">"-N2-"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2406.1">However, array </span><code class="inlineCode"><span class="koboSpan" id="kobo.2407.1">a</span></code><span class="koboSpan" id="kobo.2408.1"> and slice </span><code class="inlineCode"><span class="koboSpan" id="kobo.2409.1">S12</span></code><span class="koboSpan" id="kobo.2410.1"> are still connected </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.2411.1">because the capacity of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2412.1">S12</span></code><span class="koboSpan" id="kobo.2413.1"> has not changed.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2414.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2415.1">"S0:"</span></span><span class="koboSpan" id="kobo.2416.1">, S0)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2417.1">"a: "</span></span><span class="koboSpan" id="kobo.2418.1">, a)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2419.1">"S12:"</span></span><span class="koboSpan" id="kobo.2420.1">, S12)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2421.1">Lastly, we print the final versions of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2422.1">a</span></code><span class="koboSpan" id="kobo.2423.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2424.1">S0</span></code><span class="koboSpan" id="kobo.2425.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2426.1">S12</span></code><span class="koboSpan" id="kobo.2427.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2428.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2429.1">sliceArrays.go</span></code><span class="koboSpan" id="kobo.2430.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2431.1">$ </span></span><span class="koboSpan" id="kobo.2432.1">go run sliceArrays.go 
a: [Zero One Two Three]
[Zero]
[One Two]
a: [S0 S12_0 S12_1 Three]
a: [S0 Change_function S12_1 Three]
Capacity of S0: 4 Length of S0: 1
Capacity of S0: 8 Length of S0: 5
S0: [-N1 N1 N2 N3 N4]
a:  [-N1- -N2- N2 N3]
S12: [-N2- N2]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2433.1">The next subsection shows a technique for catching out of bound errors on slices as early as possible.</span></p>
<h2 class="heading-2" id="_idParaDest-72"><span class="koboSpan" id="kobo.2434.1">Catching out of bounds errors</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2435.1">In this subsection, we present a</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.2436.1"> technique for catching out of bounds errors. </span><span class="koboSpan" id="kobo.2436.2">The technique is illustrated with the help of two functions. </span><span class="koboSpan" id="kobo.2436.3">The first function is the next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2437.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2438.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2439.1">(s []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2440.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2441.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2442.1">int</span></span><span class="koboSpan" id="kobo.2443.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2444.1">return</span></span><span class="koboSpan" id="kobo.2445.1"> s[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2446.1">0</span></span><span class="koboSpan" id="kobo.2447.1">] + s[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2448.1">1</span></span><span class="koboSpan" id="kobo.2449.1">] + s[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2450.1">2</span></span><span class="koboSpan" id="kobo.2451.1">] + s[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2452.1">3</span></span><span class="koboSpan" id="kobo.2453.1">]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2454.1">In the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2455.1">foo()</span></code><span class="koboSpan" id="kobo.2456.1">, no bound checking is performed on slice </span><code class="inlineCode"><span class="koboSpan" id="kobo.2457.1">s</span></code><span class="koboSpan" id="kobo.2458.1">. </span><span class="koboSpan" id="kobo.2458.2">This means that we can use any index on it without being sure that we will get that index in the first place and without the compiler performing any checks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2459.1">The second function is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2460.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2461.1">bar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2462.1">(slice []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2463.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2464.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2465.1">int</span></span><span class="koboSpan" id="kobo.2466.1"> {
    a := (*[</span><span class="code-highlight"><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.2467.1">3</span></strong></span><span class="koboSpan" id="kobo.2468.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2469.1">int</span></span><span class="koboSpan" id="kobo.2470.1">)(slice)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2471.1">return</span></span><span class="koboSpan" id="kobo.2472.1"> a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2473.1">0</span></span><span class="koboSpan" id="kobo.2474.1">] + a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2475.1">1</span></span><span class="koboSpan" id="kobo.2476.1">] + a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2477.1">2</span></span><span class="koboSpan" id="kobo.2478.1">] + a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2479.1">3</span></span><span class="koboSpan" id="kobo.2480.1">]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2481.1">Keep in mind that the compiler is not going to check the slice provided as a parameter to the function. </span><span class="koboSpan" id="kobo.2481.2">However, the compiler is going to refuse to compile the preceding code. </span><span class="koboSpan" id="kobo.2481.3">The generated error is going to be </span><code class="inlineCode"><span class="koboSpan" id="kobo.2482.1">invalid argument: index 3 out of bounds [0:3]</span></code><span class="koboSpan" id="kobo.2483.1">. </span><span class="koboSpan" id="kobo.2483.2">The reason that the error was caught is that although we get three elements from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2484.1">slice</span></code><span class="koboSpan" id="kobo.2485.1"> and put them into </span><code class="inlineCode"><span class="koboSpan" id="kobo.2486.1">a</span></code><span class="koboSpan" id="kobo.2487.1">, we are using four elements from array </span><code class="inlineCode"><span class="koboSpan" id="kobo.2488.1">a</span></code><span class="koboSpan" id="kobo.2489.1">, which is clearly not allowed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2490.1">Let us now discuss the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2491.1">copy()</span></code><span class="koboSpan" id="kobo.2492.1"> function in the next subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-73"><span class="koboSpan" id="kobo.2493.1">The copy() function</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2494.1">Go offers the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2495.1">copy()</span></code><span class="koboSpan" id="kobo.2496.1"> function for copying an</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.2497.1"> existing array to a slice or an existing slice to another slice. </span><span class="koboSpan" id="kobo.2497.2">However, the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2498.1">copy()</span></code><span class="koboSpan" id="kobo.2499.1"> can be tricky because the destination slice is not auto-expanded if the source slice is bigger than the destination slice. </span><span class="koboSpan" id="kobo.2499.2">Additionally, if the destination slice is bigger than the source slice, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.2500.1">copy()</span></code><span class="koboSpan" id="kobo.2501.1"> does not empty the elements from the destination slice that did not get copied. </span><span class="koboSpan" id="kobo.2501.2">This is better illustrated in the figure that follows.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.2502.1"><img alt="A picture containing text, screenshot, font, number  Description automatically generated" src="../Images/B21003_02_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2503.1">Figure 2.3: The use of the copy() function</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2504.1">The following program illustrates the </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.2505.1">use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2506.1">copy()</span></code><span class="koboSpan" id="kobo.2507.1">—type it in your favorite text editor and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2508.1">copySlice.go</span></code><span class="koboSpan" id="kobo.2509.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2510.1">package</span></span><span class="koboSpan" id="kobo.2511.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2512.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2513.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2514.1">fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2515.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2516.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2517.1">()</span></span><span class="koboSpan" id="kobo.2518.1"> {
    a1 := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2519.1">int</span></span><span class="koboSpan" id="kobo.2520.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2521.1">1</span></span><span class="koboSpan" id="kobo.2522.1">}
    a2 := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2523.1">int</span></span><span class="koboSpan" id="kobo.2524.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2525.1">-1</span></span><span class="koboSpan" id="kobo.2526.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2527.1">-2</span></span><span class="koboSpan" id="kobo.2528.1">}
    a5 := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2529.1">int</span></span><span class="koboSpan" id="kobo.2530.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2531.1">10</span></span><span class="koboSpan" id="kobo.2532.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2533.1">11</span></span><span class="koboSpan" id="kobo.2534.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2535.1">12</span></span><span class="koboSpan" id="kobo.2536.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2537.1">13</span></span><span class="koboSpan" id="kobo.2538.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2539.1">14</span></span><span class="koboSpan" id="kobo.2540.1">}
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2541.1">"a1"</span></span><span class="koboSpan" id="kobo.2542.1">, a1)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2543.1">"a2"</span></span><span class="koboSpan" id="kobo.2544.1">, a2)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2545.1">"a5"</span></span><span class="koboSpan" id="kobo.2546.1">, a5)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2547.1">// copy(destination, input)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2548.1">// len(a2) &gt; len(a1)</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2549.1">copy</span></span><span class="koboSpan" id="kobo.2550.1">(a1, a2)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2551.1">"a1"</span></span><span class="koboSpan" id="kobo.2552.1">, a1)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2553.1">"a2"</span></span><span class="koboSpan" id="kobo.2554.1">, a2)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2555.1">Here we run the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2556.1">copy(a1, a2)</span></code><span class="koboSpan" id="kobo.2557.1"> command. </span><span class="koboSpan" id="kobo.2557.2">In this case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2558.1">a2</span></code><span class="koboSpan" id="kobo.2559.1"> slice is bigger than </span><code class="inlineCode"><span class="koboSpan" id="kobo.2560.1">a1</span></code><span class="koboSpan" id="kobo.2561.1">. </span><span class="koboSpan" id="kobo.2561.2">After </span><code class="inlineCode"><span class="koboSpan" id="kobo.2562.1">copy(a1, a2)</span></code><span class="koboSpan" id="kobo.2563.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2564.1">a2</span></code><span class="koboSpan" id="kobo.2565.1"> remains the same, which makes perfect sense as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2566.1">a2</span></code><span class="koboSpan" id="kobo.2567.1"> is the input slice, whereas the first element of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2568.1">a2</span></code><span class="koboSpan" id="kobo.2569.1"> is copied to the first element of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2570.1">a1</span></code><span class="koboSpan" id="kobo.2571.1"> because </span><code class="inlineCode"><span class="koboSpan" id="kobo.2572.1">a1</span></code><span class="koboSpan" id="kobo.2573.1"> has space for a single element only.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2574.1">// len(a5) &gt; len(a1)</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2575.1">copy</span></span><span class="koboSpan" id="kobo.2576.1">(a1, a5)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2577.1">"a1"</span></span><span class="koboSpan" id="kobo.2578.1">, a1)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2579.1">"a5"</span></span><span class="koboSpan" id="kobo.2580.1">, a5)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2581.1">In this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2582.1">a5</span></code><span class="koboSpan" id="kobo.2583.1"> is bigger than </span><code class="inlineCode"><span class="koboSpan" id="kobo.2584.1">a1</span></code><span class="koboSpan" id="kobo.2585.1">. </span><span class="koboSpan" id="kobo.2585.2">Once again, after </span><code class="inlineCode"><span class="koboSpan" id="kobo.2586.1">copy(a1, a5)</span></code><span class="koboSpan" id="kobo.2587.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2588.1">a5</span></code><span class="koboSpan" id="kobo.2589.1"> remains the same whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.2590.1">a5[0]</span></code><span class="koboSpan" id="kobo.2591.1"> is copied to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2592.1">a1[0]</span></code><span class="koboSpan" id="kobo.2593.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2594.1">// len(a2) &lt; len(a5) -&gt; OK</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2595.1">copy</span></span><span class="koboSpan" id="kobo.2596.1">(a5, a2)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2597.1">"a2"</span></span><span class="koboSpan" id="kobo.2598.1">, a2)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2599.1">"a5"</span></span><span class="koboSpan" id="kobo.2600.1">, a5)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2601.1">In this last case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2602.1">a2</span></code><span class="koboSpan" id="kobo.2603.1"> is shorter than </span><code class="inlineCode"><span class="koboSpan" id="kobo.2604.1">a5</span></code><span class="koboSpan" id="kobo.2605.1">. </span><span class="koboSpan" id="kobo.2605.2">This means that the entire </span><code class="inlineCode"><span class="koboSpan" id="kobo.2606.1">a2</span></code><span class="koboSpan" id="kobo.2607.1"> is copied into </span><code class="inlineCode"><span class="koboSpan" id="kobo.2608.1">a5</span></code><span class="koboSpan" id="kobo.2609.1"> as there is enough room. </span><span class="koboSpan" id="kobo.2609.2">As the </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.2610.1">length of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2611.1">a2</span></code><span class="koboSpan" id="kobo.2612.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2613.1">2</span></code><span class="koboSpan" id="kobo.2614.1">, only the first 2 elements of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2615.1">a5</span></code><span class="koboSpan" id="kobo.2616.1"> change.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2617.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2618.1">copySlice.go</span></code><span class="koboSpan" id="kobo.2619.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2620.1">$ </span></span><span class="koboSpan" id="kobo.2621.1">go run copySlice.go 
a1 [1]
a2 [-1 -2]
a5 [10 11 12 13 14]
a1 [-1]
a2 [-1 -2]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2622.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2623.1">copy(a1, a2)</span></code><span class="koboSpan" id="kobo.2624.1"> statement does not alter the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2625.1">a2</span></code><span class="koboSpan" id="kobo.2626.1"> slice, just </span><code class="inlineCode"><span class="koboSpan" id="kobo.2627.1">a1</span></code><span class="koboSpan" id="kobo.2628.1">. </span><span class="koboSpan" id="kobo.2628.2">As the size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2629.1">a1</span></code><span class="koboSpan" id="kobo.2630.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2631.1">1</span></code><span class="koboSpan" id="kobo.2632.1">, only the first element from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2633.1">a2</span></code><span class="koboSpan" id="kobo.2634.1"> is copied.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2635.1">a1 [10]
a5 [10 11 12 13 14]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2636.1">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2637.1">copy(a1, a5)</span></code><span class="koboSpan" id="kobo.2638.1"> alters </span><code class="inlineCode"><span class="koboSpan" id="kobo.2639.1">a1</span></code><span class="koboSpan" id="kobo.2640.1"> only. </span><span class="koboSpan" id="kobo.2640.2">As the size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2641.1">a1</span></code><span class="koboSpan" id="kobo.2642.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2643.1">1</span></code><span class="koboSpan" id="kobo.2644.1">, only the first element from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2645.1">a5</span></code><span class="koboSpan" id="kobo.2646.1"> is copied to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2647.1">a1</span></code><span class="koboSpan" id="kobo.2648.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2649.1">a2 [-1 -2]
a5 [-1 -2 12 13 14]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2650.1">Last, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2651.1">copy(a5, a2)</span></code><span class="koboSpan" id="kobo.2652.1"> alters </span><code class="inlineCode"><span class="koboSpan" id="kobo.2653.1">a5</span></code><span class="koboSpan" id="kobo.2654.1">. </span><span class="koboSpan" id="kobo.2654.2">As the size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2655.1">a5</span></code><span class="koboSpan" id="kobo.2656.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2657.1">5</span></code><span class="koboSpan" id="kobo.2658.1">, only the first two elements from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2659.1">a5</span></code><span class="koboSpan" id="kobo.2660.1"> are altered and become the same as the first two elements of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2661.1">a2</span></code><span class="koboSpan" id="kobo.2662.1">, which has a size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2663.1">2</span></code><span class="koboSpan" id="kobo.2664.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-74"><span class="koboSpan" id="kobo.2665.1">Sorting slices</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2666.1">There are times when you want to</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.2667.1"> present your information sorted and you want Go to do the job for you. </span><span class="koboSpan" id="kobo.2667.2">In this subsection, we are going to see how to sort slices of various standard data types using the functionality offered by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2668.1">sort</span></code><span class="koboSpan" id="kobo.2669.1"> package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2670.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2671.1">sort</span></code><span class="koboSpan" id="kobo.2672.1"> package can sort slices of built-in data types without the need to write any extra code. </span><span class="koboSpan" id="kobo.2672.2">Additionally, Go provides the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2673.1">sort.Reverse()</span></code><span class="koboSpan" id="kobo.2674.1"> function for sorting in reverse order. </span><span class="koboSpan" id="kobo.2674.2">However, what is really interesting is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2675.1">sort</span></code><span class="koboSpan" id="kobo.2676.1"> allows you to write your own sorting functions for custom data types by implementing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2677.1">sort.Interface</span></code><span class="koboSpan" id="kobo.2678.1"> interface—you will learn more about </span><code class="inlineCode"><span class="koboSpan" id="kobo.2679.1">sort.Interface</span></code><span class="koboSpan" id="kobo.2680.1"> and interfaces in general in </span><em class="chapterRef"><span class="koboSpan" id="kobo.2681.1">Chapter 5</span></em><span class="koboSpan" id="kobo.2682.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2683.1">Reflection and Interfaces</span></em><span class="koboSpan" id="kobo.2684.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2685.1">With Go generics, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2686.1">slices</span></code><span class="koboSpan" id="kobo.2687.1"> package was introduced in the standard Go library—the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2688.1">slices</span></code><span class="koboSpan" id="kobo.2689.1"> package is discussed in </span><em class="chapterRef"><span class="koboSpan" id="kobo.2690.1">Chapter 4</span></em><span class="koboSpan" id="kobo.2691.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2692.1">Go Generics</span></em><span class="koboSpan" id="kobo.2693.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2694.1">So, you can sort a slice of integers </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.2695.1">saved as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2696.1">sInts</span></code><span class="koboSpan" id="kobo.2697.1"> by typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2698.1">sort.Ints(sInts)</span></code><span class="koboSpan" id="kobo.2699.1">. </span><span class="koboSpan" id="kobo.2699.2">When sorting a slice of integers in reverse order using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2700.1">sort.Reverse()</span></code><span class="koboSpan" id="kobo.2701.1">, you need to pass the desired slice to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2702.1">sort.Reverse()</span></code><span class="koboSpan" id="kobo.2703.1"> using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2704.1">sort.IntSlice(sInts)</span></code><span class="koboSpan" id="kobo.2705.1"> because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2706.1">IntSlice</span></code><span class="koboSpan" id="kobo.2707.1"> type implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2708.1">sort.Interface</span></code><span class="koboSpan" id="kobo.2709.1"> internally, which allows you to sort in a different way than usual. </span><span class="koboSpan" id="kobo.2709.2">The same applies to the other standard Go data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2710.1">Create a text file with following the code that illustrates the use of sort and name it </span><code class="inlineCode"><span class="koboSpan" id="kobo.2711.1">sortSlice.go</span></code><span class="koboSpan" id="kobo.2712.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2713.1">package</span></span><span class="koboSpan" id="kobo.2714.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2715.1">import</span></span><span class="koboSpan" id="kobo.2716.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2717.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2718.1">"sort"</span></span><span class="koboSpan" id="kobo.2719.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2720.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2721.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2722.1">()</span></span><span class="koboSpan" id="kobo.2723.1"> {
    sInts := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2724.1">int</span></span><span class="koboSpan" id="kobo.2725.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2726.1">1</span></span><span class="koboSpan" id="kobo.2727.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2728.1">0</span></span><span class="koboSpan" id="kobo.2729.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2730.1">2</span></span><span class="koboSpan" id="kobo.2731.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2732.1">-3</span></span><span class="koboSpan" id="kobo.2733.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2734.1">4</span></span><span class="koboSpan" id="kobo.2735.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2736.1">-20</span></span><span class="koboSpan" id="kobo.2737.1">}
    sFloats := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2738.1">float64</span></span><span class="koboSpan" id="kobo.2739.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2740.1">1.0</span></span><span class="koboSpan" id="kobo.2741.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2742.1">0.2</span></span><span class="koboSpan" id="kobo.2743.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2744.1">0.22</span></span><span class="koboSpan" id="kobo.2745.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2746.1">-3</span></span><span class="koboSpan" id="kobo.2747.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2748.1">4.1</span></span><span class="koboSpan" id="kobo.2749.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2750.1">-0.1</span></span><span class="koboSpan" id="kobo.2751.1">}
    sStrings := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2752.1">string</span></span><span class="koboSpan" id="kobo.2753.1">{</span><span class="hljs-string"><span class="koboSpan" id="kobo.2754.1">"aa"</span></span><span class="koboSpan" id="kobo.2755.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2756.1">"a"</span></span><span class="koboSpan" id="kobo.2757.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2758.1">"A"</span></span><span class="koboSpan" id="kobo.2759.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2760.1">"Aa"</span></span><span class="koboSpan" id="kobo.2761.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2762.1">"aab"</span></span><span class="koboSpan" id="kobo.2763.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2764.1">"AAa"</span></span><span class="koboSpan" id="kobo.2765.1">}
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2766.1">"sInts original:"</span></span><span class="koboSpan" id="kobo.2767.1">, sInts)
    sort.Ints(sInts)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2768.1">"sInts:"</span></span><span class="koboSpan" id="kobo.2769.1">, sInts)
    sort.Sort(sort.Reverse(sort.IntSlice(sInts)))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2770.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2771.1">Reverse:"</span></span><span class="koboSpan" id="kobo.2772.1">, sInts)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2773.1">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.2774.1">sort.Interface</span></code><span class="koboSpan" id="kobo.2775.1"> knows how to sort integer values, it is trivial to sort them in reverse order.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2776.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2777.1">"sFloats original:"</span></span><span class="koboSpan" id="kobo.2778.1">, sFloats)
    sort.Float64s(sFloats)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2779.1">"sFloats:"</span></span><span class="koboSpan" id="kobo.2780.1">, sFloats)
    sort.Sort(sort.Reverse(sort.Float64Slice(sFloats)))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2781.1">"Reverse:"</span></span><span class="koboSpan" id="kobo.2782.1">, sFloats)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2783.1">"sStrings original:"</span></span><span class="koboSpan" id="kobo.2784.1">, sStrings)
    sort.Strings(sStrings)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2785.1">"sStrings:"</span></span><span class="koboSpan" id="kobo.2786.1">, sStrings)
    sort.Sort(sort.Reverse(sort.StringSlice(sStrings)))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2787.1">"Reverse:"</span></span><span class="koboSpan" id="kobo.2788.1">, sStrings)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2789.1">The same rules apply when sorting</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.2790.1"> floating point numbers and strings.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2791.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2792.1">sortSlice.go</span></code><span class="koboSpan" id="kobo.2793.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2794.1">$ </span></span><span class="koboSpan" id="kobo.2795.1">go run sortSlice.go
sInts original: [1 0 2 -3 4 -20]
sInts: [-20 -3 0 1 2 4]
Reverse: [4 2 1 0 -3 -20]
sFloats original: [1 0.2 0.22 -3 4.1 -0.1]
sFloats: [-3 -0.1 0.2 0.22 1 4.1]
Reverse: [4.1 1 0.22 0.2 -0.1 -3]
sStrings original: [aa a A Aa aab AAa]
sStrings: [A AAa Aa a aa aab]
Reverse: [aab aa a Aa AAa A]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2796.1">The output illustrates how the original slices were sorted in both normal and reverse order.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2797.1">The next section discusses pointers in Go. </span><span class="koboSpan" id="kobo.2797.2">Although Go does not support pointers in the same way that C does, Go allows you to work with pointers and pointer variables.</span></p>
<h1 class="heading-1" id="_idParaDest-75"><span class="koboSpan" id="kobo.2798.1">Pointers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2799.1">Go has </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2800.1">support for pointers but not for pointer arithmetic</span></strong><span class="koboSpan" id="kobo.2801.1">, which is the cause of many bugs and errors in programming languages like </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.2802.1">C. </span><span class="koboSpan" id="kobo.2802.2">A pointer is the memory address of a variable. </span><span class="koboSpan" id="kobo.2802.3">You need to </span><em class="italic"><span class="koboSpan" id="kobo.2803.1">dereference a pointer</span></em><span class="koboSpan" id="kobo.2804.1"> in order to get its value—dereferencing is performed using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2805.1">*</span></code><span class="koboSpan" id="kobo.2806.1"> character in front of the pointer variable. </span><span class="koboSpan" id="kobo.2806.2">Additionally, you can get the memory address of a normal variable using an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2807.1">&amp;</span></code><span class="koboSpan" id="kobo.2808.1"> in front of it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2809.1">The next diagram shows the difference between a pointer to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2810.1">int</span></code><span class="koboSpan" id="kobo.2811.1"> and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2812.1">int</span></code><span class="koboSpan" id="kobo.2813.1"> variable.</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.2814.1"><img alt="A picture containing text, screenshot, rectangle, font  Description automatically generated" src="../Images/B21003_02_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2815.1">Figure 2.4: An int variable and a pointer to an int</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2816.1">If a pointer variable points to an existing regular variable, then any changes you make to the stored value using the pointer</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.2817.1"> variable will modify the regular variable.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2818.1">The format and the values of memory addresses might be different between different machines, different operating systems, and different architectures.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2819.1">You might ask, what is the point of using pointers when there is no support for pointer arithmetic? </span><span class="koboSpan" id="kobo.2819.2">The main benefit you get from pointers is that passing a variable to a function as a pointer (we can call that by reference) does not discard any changes you make to the value of that variable inside that function when the function returns. </span><span class="koboSpan" id="kobo.2819.3">There exist times where you want that functionality because it simplifies your code, but the price you pay for that simplicity is being extra careful with what you do with a pointer variable. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2820.1">Remember that slices are passed to functions without the need to use a pointer—it is Go that passes the pointer to the underlying array of a slice and there is no way to change that behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2821.1">Apart from reasons of simplicity, there exist three more reasons for using pointers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2822.1">Pointers allow you to share and manipulate data between functions without explicitly returning values back to the caller. </span><span class="koboSpan" id="kobo.2822.2">However, when sharing data between functions and goroutines, you should be extra careful with </span><em class="italic"><span class="koboSpan" id="kobo.2823.1">race condition</span></em><span class="koboSpan" id="kobo.2824.1"> issues. </span><span class="koboSpan" id="kobo.2824.2">This allows multiple functions to try to alter the value of the same pointer variable at the same time, which causes unpredictable behavior in the final state of that pointer variable.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2825.1">Pointers are also very handy when you want to tell the difference between the zero value of a variable and a value that is not set (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2826.1">nil</span></code><span class="koboSpan" id="kobo.2827.1">). </span><span class="koboSpan" id="kobo.2827.2">This is particularly useful with structures because pointers (and therefore pointers to structures, which are fully covered in the next chapter) can have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2828.1">nil</span></code><span class="koboSpan" id="kobo.2829.1"> value, which means that you can compare a pointer to a structure with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2830.1">nil</span></code><span class="koboSpan" id="kobo.2831.1"> value, which is not </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.2832.1">allowed for normal structure variables.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2833.1">Having support for pointers and, more specifically, pointers to structures allows Go to support data structures such as linked lists and binary trees, which are widely used in computer science. </span><span class="koboSpan" id="kobo.2833.2">Therefore, you are allowed to define a structure field of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2834.1">Node</span></code><span class="koboSpan" id="kobo.2835.1"> structure as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2836.1">Next *Node</span></code><span class="koboSpan" id="kobo.2837.1">, which is a pointer to another </span><code class="inlineCode"><span class="koboSpan" id="kobo.2838.1">Node</span></code><span class="koboSpan" id="kobo.2839.1"> structure. </span><span class="koboSpan" id="kobo.2839.2">Without pointers, this would have been difficult to implement and possibly too slow.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2840.1">The following code illustrates how you can use pointers in Go—create a text file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2841.1">pointers.go</span></code><span class="koboSpan" id="kobo.2842.1"> and type the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2843.1">package</span></span><span class="koboSpan" id="kobo.2844.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2845.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2846.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2847.1">type</span></span><span class="koboSpan" id="kobo.2848.1"> aStructure </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2849.1">struct</span></span><span class="koboSpan" id="kobo.2850.1"> {
    field1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.2851.1">complex128</span></span><span class="koboSpan" id="kobo.2852.1">
    field2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.2853.1">int</span></span><span class="koboSpan" id="kobo.2854.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2855.1">This is a structure with two fields named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2856.1">field1</span></code><span class="koboSpan" id="kobo.2857.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2858.1">field2</span></code><span class="koboSpan" id="kobo.2859.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2860.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2861.1">processPointer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2862.1">(x *</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2863.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2864.1">)</span></span><span class="koboSpan" id="kobo.2865.1"> {
    *x = *x * *x
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2866.1">This is a function that gets a pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2867.1">float64</span></code><span class="koboSpan" id="kobo.2868.1"> variable as input. </span><span class="koboSpan" id="kobo.2868.2">As we are using a pointer, all changes to the function parameter inside the function will be persistent. </span><span class="koboSpan" id="kobo.2868.3">Additionally, there is no need to return something.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2869.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2870.1">returnPointer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2871.1">(x </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2872.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2873.1">)</span></span><span class="koboSpan" id="kobo.2874.1"> *</span><span class="hljs-type"><span class="koboSpan" id="kobo.2875.1">float64</span></span><span class="koboSpan" id="kobo.2876.1"> {
    temp := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2877.1">2</span></span><span class="koboSpan" id="kobo.2878.1"> * x
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2879.1">return</span></span><span class="koboSpan" id="kobo.2880.1"> &amp;temp
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2881.1">This is a function that requires a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2882.1">float64</span></code><span class="koboSpan" id="kobo.2883.1"> parameter as input and returns a pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2884.1">float64</span></code><span class="koboSpan" id="kobo.2885.1">. </span><span class="koboSpan" id="kobo.2885.2">To return the memory address of a regular variable, you need to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2886.1">&amp;</span></code><span class="koboSpan" id="kobo.2887.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2888.1">&amp;temp</span></code><span class="koboSpan" id="kobo.2889.1">). </span><span class="koboSpan" id="kobo.2889.2">In this case, Go is smart enough to</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.2890.1"> realize that the pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2891.1">temp</span></code><span class="koboSpan" id="kobo.2892.1"> escapes, so its value will be heap allocated, ensuring that the caller has a valid reference to work with as opposed to stack allocation where the reference is invalid when the function returns and the stack frame is eliminated.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2893.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2894.1">bothPointers</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2895.1">(x *</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2896.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2897.1">)</span></span><span class="koboSpan" id="kobo.2898.1"> *</span><span class="hljs-type"><span class="koboSpan" id="kobo.2899.1">float64</span></span><span class="koboSpan" id="kobo.2900.1"> {
    temp := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2901.1">2</span></span><span class="koboSpan" id="kobo.2902.1"> * *x
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2903.1">return</span></span><span class="koboSpan" id="kobo.2904.1"> &amp;temp
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2905.1">This is a function that requires a pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2906.1">float64</span></code><span class="koboSpan" id="kobo.2907.1"> as input and returns a pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2908.1">float64</span></code><span class="koboSpan" id="kobo.2909.1"> as output. </span><span class="koboSpan" id="kobo.2909.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2910.1">*x</span></code><span class="koboSpan" id="kobo.2911.1"> notation is used for getting </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.2912.1">the value stored in the memory address stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2913.1">x</span></code><span class="koboSpan" id="kobo.2914.1"> and is called dereferencing.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2915.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2916.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2917.1">()</span></span><span class="koboSpan" id="kobo.2918.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2919.1">var</span></span><span class="koboSpan" id="kobo.2920.1"> f </span><span class="hljs-type"><span class="koboSpan" id="kobo.2921.1">float64</span></span><span class="koboSpan" id="kobo.2922.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2923.1">12.123</span></span><span class="koboSpan" id="kobo.2924.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2925.1">"Memory address of f:"</span></span><span class="koboSpan" id="kobo.2926.1">, &amp;f)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2927.1">To get the memory address of a regular variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2928.1">f</span></code><span class="koboSpan" id="kobo.2929.1">, you should use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2930.1">&amp;f</span></code><span class="koboSpan" id="kobo.2931.1"> notation.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2932.1">// Pointer to f</span></span><span class="koboSpan" id="kobo.2933.1">
    fP := &amp;f
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2934.1">"Memory address of f:"</span></span><span class="koboSpan" id="kobo.2935.1">, fP)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2936.1">"Value of f:"</span></span><span class="koboSpan" id="kobo.2937.1">, *fP)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2938.1">// The value of f changes</span></span><span class="koboSpan" id="kobo.2939.1">
    processPointer(fP)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2940.1">"Value of f: %.2f\n"</span></span><span class="koboSpan" id="kobo.2941.1">, f)
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2942.1">fP</span></code><span class="koboSpan" id="kobo.2943.1"> is now a pointer to the memory address of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2944.1">f</span></code><span class="koboSpan" id="kobo.2945.1"> variable. </span><span class="koboSpan" id="kobo.2945.2">Any changes to the value stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2946.1">fP</span></code><span class="koboSpan" id="kobo.2947.1"> memory address influence the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2948.1">f</span></code><span class="koboSpan" id="kobo.2949.1"> value as well. </span><span class="koboSpan" id="kobo.2949.2">However, this is only true for as long as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2950.1">fP</span></code><span class="koboSpan" id="kobo.2951.1"> points to the memory address of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2952.1">f</span></code><span class="koboSpan" id="kobo.2953.1"> variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2954.1">// The value of f does not change</span></span><span class="koboSpan" id="kobo.2955.1">
    x := returnPointer(f)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2956.1">"Value of x: %.2f\n"</span></span><span class="koboSpan" id="kobo.2957.1">, *x)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2958.1">The value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2959.1">f</span></code><span class="koboSpan" id="kobo.2960.1"> does not change because the function only uses its value.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2961.1">// The value of f does not change</span></span><span class="koboSpan" id="kobo.2962.1">
    xx := bothPointers(fP)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2963.1">"Value of xx: %.2f\n"</span></span><span class="koboSpan" id="kobo.2964.1">, *xx)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2965.1">In this case, the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2966.1">f</span></code><span class="koboSpan" id="kobo.2967.1">, as well as the value stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2968.1">fP</span></code><span class="koboSpan" id="kobo.2969.1"> memory address, do not change because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2970.1">bothPointers()</span></code><span class="koboSpan" id="kobo.2971.1"> function does not make any changes to the value stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2972.1">fP</span></code><span class="koboSpan" id="kobo.2973.1"> memory address.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2974.1">// Check for empty structure</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2975.1">var</span></span><span class="koboSpan" id="kobo.2976.1"> k *aStructure
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2977.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2978.1">k</span></code><span class="koboSpan" id="kobo.2979.1"> variable is a pointer to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2980.1">aStructure</span></code><span class="koboSpan" id="kobo.2981.1"> structure. </span><span class="koboSpan" id="kobo.2981.2">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.2982.1">k</span></code><span class="koboSpan" id="kobo.2983.1"> points to nowhere, Go makes it point to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2984.1">nil</span></code><span class="koboSpan" id="kobo.2985.1">, which is the zero </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.2986.1">value for pointers.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2987.1">// This is nil because currently k points to nowhere</span></span><span class="koboSpan" id="kobo.2988.1">
    fmt.Println(k)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2989.1">// Therefore you are allowed to do this:</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2990.1">if</span></span><span class="koboSpan" id="kobo.2991.1"> k == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2992.1">nil</span></span><span class="koboSpan" id="kobo.2993.1"> {
        k = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2994.1">new</span></span><span class="koboSpan" id="kobo.2995.1">(aStructure)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2996.1">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.2997.1">k</span></code><span class="koboSpan" id="kobo.2998.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2999.1">nil</span></code><span class="koboSpan" id="kobo.3000.1">, we are allowed to assign it to an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.3001.1">aStructure</span></code><span class="koboSpan" id="kobo.3002.1"> value with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3003.1">new(aStructure)</span></code><span class="koboSpan" id="kobo.3004.1"> without losing any data—</span><code class="inlineCode"><span class="koboSpan" id="kobo.3005.1">new()</span></code><span class="koboSpan" id="kobo.3006.1"> allocates the required memory and sets the pointer to that memory. </span><span class="koboSpan" id="kobo.3006.2">Now, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3007.1">k</span></code><span class="koboSpan" id="kobo.3008.1"> is no longer </span><code class="inlineCode"><span class="koboSpan" id="kobo.3009.1">nil</span></code><span class="koboSpan" id="kobo.3010.1"> but both fields of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3011.1">aStructure</span></code><span class="koboSpan" id="kobo.3012.1"> have the zero values of their data types.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3013.1">    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3014.1">"%+v\n"</span></span><span class="koboSpan" id="kobo.3015.1">, k)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3016.1">if</span></span><span class="koboSpan" id="kobo.3017.1"> k != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3018.1">nil</span></span><span class="koboSpan" id="kobo.3019.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3020.1">"k is not nil!"</span></span><span class="koboSpan" id="kobo.3021.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3022.1">The preceding code is just making sure that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3023.1">k</span></code><span class="koboSpan" id="kobo.3024.1"> is not </span><code class="inlineCode"><span class="koboSpan" id="kobo.3025.1">nil</span></code><span class="koboSpan" id="kobo.3026.1">. </span><span class="koboSpan" id="kobo.3026.2">You might consider that check redundant, but it does not hurt to double-check because if you try to dereference a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3027.1">nil</span></code><span class="koboSpan" id="kobo.3028.1"> pointer, your program is going to crash.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3029.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.3030.1">pointers.go</span></code><span class="koboSpan" id="kobo.3031.1"> generates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3032.1">Memory address of f: 0x140000180d8
Memory address of f: 0x140000180d8
Value of f: 12.123
Value of f: 146.97
Value of x: 293.93
Value of xx: 293.93
&lt;nil&gt;
&amp;{field1:(0+0i) field2:0}
k is not nil!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3033.1">We are going to revisit pointers</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.3034.1"> in the next chapter when we discuss structures.</span></p>
<h2 class="heading-2" id="_idParaDest-76"><span class="koboSpan" id="kobo.3035.1">Converting a slice to an array or an array pointer</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3036.1">In this subsection, we are going to</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.3037.1"> learn how to convert a slice to an array or an array pointer. </span><span class="koboSpan" id="kobo.3037.2">The first part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3038.1">slice2array.go</span></code><span class="koboSpan" id="kobo.3039.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3040.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3041.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3042.1">()</span></span><span class="koboSpan" id="kobo.3043.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3044.1">// Go 1.17 feature</span></span><span class="koboSpan" id="kobo.3045.1">
    slice := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3046.1">make</span></span><span class="koboSpan" id="kobo.3047.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.3048.1">byte</span></span><span class="koboSpan" id="kobo.3049.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3050.1">3</span></span><span class="koboSpan" id="kobo.3051.1">)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3052.1">// Slice to array pointer</span></span><span class="koboSpan" id="kobo.3053.1">
    arrayPtr := (*[</span><span class="hljs-number"><span class="koboSpan" id="kobo.3054.1">3</span></span><span class="koboSpan" id="kobo.3055.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.3056.1">byte</span></span><span class="koboSpan" id="kobo.3057.1">)(slice)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3058.1">"Print array pointer:"</span></span><span class="koboSpan" id="kobo.3059.1">, arrayPtr)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3060.1">"Data type: %T\n"</span></span><span class="koboSpan" id="kobo.3061.1">, arrayPtr)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3062.1">"arrayPtr[0]:"</span></span><span class="koboSpan" id="kobo.3063.1">, arrayPtr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.3064.1">0</span></span><span class="koboSpan" id="kobo.3065.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3066.1">In the preceding code we convert </span><code class="inlineCode"><span class="koboSpan" id="kobo.3067.1">slice</span></code><span class="koboSpan" id="kobo.3068.1"> into an array pointer that points to an array with 3 elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3069.1">The rest of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3070.1">slice2array.go</span></code><span class="koboSpan" id="kobo.3071.1"> code is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.3072.1">// Go 1.20 feature</span></span><span class="koboSpan" id="kobo.3073.1">
    slice2 := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.3074.1">int</span></span><span class="koboSpan" id="kobo.3075.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.3076.1">-1</span></span><span class="koboSpan" id="kobo.3077.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3078.1">-2</span></span><span class="koboSpan" id="kobo.3079.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3080.1">-3</span></span><span class="koboSpan" id="kobo.3081.1">}
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3082.1">// Slice to array</span></span><span class="koboSpan" id="kobo.3083.1">
    array := </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.3084.1">[</span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.3085.1">3</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.3086.1">]</span></strong><strong class="hljs-type-slc"><span class="koboSpan" id="kobo.3087.1">int</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.3088.1">(slice2)</span></strong></span><span class="koboSpan" id="kobo.3089.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3090.1">"Print array contents:"</span></span><span class="koboSpan" id="kobo.3091.1">, array)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3092.1">"Data type: %T\n"</span></span><span class="koboSpan" id="kobo.3093.1">, array)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3094.1">In the preceding code we converted a slice into an array with 3 elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3095.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.3096.1">slice2array.go</span></code><span class="koboSpan" id="kobo.3097.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3098.1">$ </span></span><span class="koboSpan" id="kobo.3099.1">go run slice2array.go
Print array pointer: &amp;[0 0 0]
Data type: *[3]uint8
arrayPtr[0]: 0
Print array contents: [-1 -2 -3]
Data type: [3]int
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3100.1">The first three lines of output have</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.3101.1"> to do with the slice-to-array-pointer conversion whereas the last two have to do with the slice-to-array conversion. </span><span class="koboSpan" id="kobo.3101.2">The second line of output verifies that we are dealing with a pointer to an array with three elements (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3102.1">*[3]uint8</span></code><span class="koboSpan" id="kobo.3103.1">) and the last line verifies that we are dealing with an array with three elements (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3104.1">[3]int</span></code><span class="koboSpan" id="kobo.3105.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3106.1">Next, we discuss data types and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3107.1">unsafe</span></code><span class="koboSpan" id="kobo.3108.1"> package.</span></p>
<h1 class="heading-1" id="_idParaDest-77"><span class="koboSpan" id="kobo.3109.1">Data types and the unsafe package</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3110.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3111.1">unsafe</span></code><span class="koboSpan" id="kobo.3112.1"> package in Go provides facilities for performing operations that break the type safety guarantees of Go. </span><span class="koboSpan" id="kobo.3112.2">It is a powerful but potentially dangerous package, and its use is discouraged in most Go code. </span><span class="koboSpan" id="kobo.3112.3">Therefore, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3113.1">unsafe</span></code><span class="koboSpan" id="kobo.3114.1"> package is intended for specific situations where low-level programming is necessary, such as interfacing with non-Go code, dealing with memory</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.3115.1"> layout, or implementing certain advanced features.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3116.1">In this section, we are going to discuss</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.3117.1"> four functions of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3118.1">unsafe</span></code><span class="koboSpan" id="kobo.3119.1"> package that are related to strings and slices. </span><span class="koboSpan" id="kobo.3119.2">You might not have to use any of them on a regular basis, but it is good to know about them because they provide speed when dealing with large strings or slices that take lots of memory because they </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.3120.1">deal with memory addresses directly</span></strong><span class="koboSpan" id="kobo.3121.1">, which might be very dangerous if you do not know what you are doing. </span><span class="koboSpan" id="kobo.3121.2">The four functions that we are going to discuss are </span><code class="inlineCode"><span class="koboSpan" id="kobo.3122.1">unsafe.StringData()</span></code><span class="koboSpan" id="kobo.3123.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3124.1">unsafe.String()</span></code><span class="koboSpan" id="kobo.3125.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3126.1">unsafe.Slice()</span></code><span class="koboSpan" id="kobo.3127.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3128.1">unsafe.SliceData()</span></code><span class="koboSpan" id="kobo.3129.1">. </span><span class="koboSpan" id="kobo.3129.2">You can learn more details about their usage using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3130.1">go doc</span></code><span class="koboSpan" id="kobo.3131.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3132.1">Please bear in mind that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3133.1">unsafe</span></code><span class="koboSpan" id="kobo.3134.1"> package is called unsafe for a reason, and that in most cases you should not use this package!</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3135.1">The first part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3136.1">typeUnsafe.go</span></code><span class="koboSpan" id="kobo.3137.1"> comes with two functions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3138.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3139.1">byteToString</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3140.1">(bStr []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3141.1">byte</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3142.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3143.1">string</span></span><span class="koboSpan" id="kobo.3144.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3145.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3146.1">len</span></span><span class="koboSpan" id="kobo.3147.1">(bStr) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3148.1">0</span></span><span class="koboSpan" id="kobo.3149.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3150.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.3151.1">""</span></span><span class="koboSpan" id="kobo.3152.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3153.1">return</span></span> <span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.3154.1">unsafe.String(unsafe.SliceData(bStr), </span></strong><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.3155.1">len</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.3156.1">(bStr))</span></strong></span><span class="koboSpan" id="kobo.3157.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3158.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3159.1">stringToByte</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3160.1">(str </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3161.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3162.1">)</span></span><span class="koboSpan" id="kobo.3163.1"> []</span><span class="hljs-type"><span class="koboSpan" id="kobo.3164.1">byte</span></span><span class="koboSpan" id="kobo.3165.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3166.1">if</span></span><span class="koboSpan" id="kobo.3167.1"> str == </span><span class="hljs-string"><span class="koboSpan" id="kobo.3168.1">""</span></span><span class="koboSpan" id="kobo.3169.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3170.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.3171.1">nil</span></span><span class="koboSpan" id="kobo.3172.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3173.1">return</span></span> <span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.3174.1">unsafe.Slice(unsafe.StringData(str), </span></strong><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.3175.1">len</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.3176.1">(str))</span></strong></span><span class="koboSpan" id="kobo.3177.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3178.1">These two particular functions convert a byte slice to a string and vice versa using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3179.1">unsafe.String()</span></code><span class="koboSpan" id="kobo.3180.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3181.1">unsafe.Slice()</span></code><span class="koboSpan" id="kobo.3182.1">, respectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3183.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3184.1">unsafe.String()</span></code><span class="koboSpan" id="kobo.3185.1"> function requires a </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.3186.1">pointer parameter and a length value in order to know how far from the pointer it</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.3187.1"> is going to go for the data. </span><span class="koboSpan" id="kobo.3187.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3188.1">unsafe.SliceData()</span></code><span class="koboSpan" id="kobo.3189.1"> function returns a pointer to the underlying array of the function argument slice.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3190.1">unsafe.Slice()</span></code><span class="koboSpan" id="kobo.3191.1"> operates in an analogous way and returns a slice whose underlying array starts at the given pointer value and whose length and capacity are equal to the integer value that is passed as its second parameter—it is important to understand that when working with memory addresses via pointers and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3192.1">unsafe</span></code><span class="koboSpan" id="kobo.3193.1"> package, we need to specify how far in memory we need to go.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3194.1">As Go strings are immutable, the bytes returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3195.1">unsafe.StringData()</span></code><span class="koboSpan" id="kobo.3196.1"> should not be modified.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3197.1">The second part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3198.1">typeUnsafe.go</span></code><span class="koboSpan" id="kobo.3199.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3200.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3201.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3202.1">()</span></span><span class="koboSpan" id="kobo.3203.1"> {
    str := </span><span class="hljs-string"><span class="koboSpan" id="kobo.3204.1">"Go!"</span></span><span class="koboSpan" id="kobo.3205.1">
    d := </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.3206.1">unsafe.StringData(str)</span></strong></span><span class="koboSpan" id="kobo.3207.1">
    b := </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.3208.1">unsafe.Slice(d, </span></strong><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.3209.1">len</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.3210.1">(str))</span></strong></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.3211.1">// byte is an alias for uint8</span></span><span class="koboSpan" id="kobo.3212.1">
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3213.1">"Type %T contains %s\n"</span></span><span class="koboSpan" id="kobo.3214.1">, b, b)
    sData := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.3215.1">int</span></span><span class="koboSpan" id="kobo.3216.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.3217.1">10</span></span><span class="koboSpan" id="kobo.3218.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3219.1">20</span></span><span class="koboSpan" id="kobo.3220.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3221.1">30</span></span><span class="koboSpan" id="kobo.3222.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3223.1">40</span></span><span class="koboSpan" id="kobo.3224.1">}
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3225.1">// Get the memory address of sData</span></span><span class="koboSpan" id="kobo.3226.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3227.1">"Pointer:"</span></span><span class="koboSpan" id="kobo.3228.1">, unsafe.SliceData(sData))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3229.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3230.1">typeUnsafe.go</span></code><span class="koboSpan" id="kobo.3231.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.3232.1">// String to Byte slice</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3233.1">var</span></span><span class="koboSpan" id="kobo.3234.1"> hi </span><span class="hljs-type"><span class="koboSpan" id="kobo.3235.1">string</span></span><span class="koboSpan" id="kobo.3236.1"> = </span><span class="hljs-string"><span class="koboSpan" id="kobo.3237.1">"Mastering Go, 4th edition!"</span></span><span class="koboSpan" id="kobo.3238.1">
    myByteSlice := stringToByte(hi)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3239.1">"myByteSlice type: %T\n"</span></span><span class="koboSpan" id="kobo.3240.1">, myByteSlice)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3241.1">// Byte slice to string</span></span><span class="koboSpan" id="kobo.3242.1">
    myStr := byteToString(myByteSlice)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3243.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3244.1">myStr type: %T\n"</span></span><span class="koboSpan" id="kobo.3245.1">, myStr)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3246.1">The output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3247.1">typeUnsafe.go</span></code><span class="koboSpan" id="kobo.3248.1"> is the </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.3249.1">following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3250.1">$ </span></span><span class="koboSpan" id="kobo.3251.1">go run typeUnsafe.go
Type []uint8 contains Go!
</span><span class="koboSpan" id="kobo.3251.2">Pointer: 0x1400001e0c0
myByteSlice type: []uint8
myStr type: string
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3252.1">Remember that the most common purpose for using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3253.1">unsafe</span></code><span class="koboSpan" id="kobo.3254.1"> package is speed when dealing with large amounts of data because it allows you to perform pointer arithmetic and conversions between different pointer types without type safety checks. </span><span class="koboSpan" id="kobo.3254.2">When dealing with large amounts of data, pointer arithmetic can speed up things. </span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3255.1">Next, we discuss generating</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.3256.1"> random numbers and random strings.</span></p>
<h1 class="heading-1" id="_idParaDest-78"><span class="koboSpan" id="kobo.3257.1">Generating random numbers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3258.1">Random number generation is an art as well as a research area in computer science. </span><span class="koboSpan" id="kobo.3258.2">This is because computers are purely</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.3259.1"> logical machines, and it turns out that using them to generate random numbers is extremely difficult!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3260.1">Go can help you with that using the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3261.1">math/rand</span></code><span class="koboSpan" id="kobo.3262.1"> package. </span><span class="koboSpan" id="kobo.3262.2">Each random number generator needs a seed to start producing numbers. </span><span class="koboSpan" id="kobo.3262.3">The seed is used for initializing the entire process and is extremely important because if you always start with the same seed, you will always get the same sequence of pseudo-random numbers. </span><span class="koboSpan" id="kobo.3262.4">This means that everybody can regenerate that sequence, and that particular sequence will not be random after all. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.3263.1">However, this feature is very handy for testing purposes. </span><span class="koboSpan" id="kobo.3263.2">In Go, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3264.1">rand.Seed()</span></code><span class="koboSpan" id="kobo.3265.1"> function is used</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.3266.1"> for initializing a random number generator.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3267.1">If you are really interested in random number generation, you should start by reading the second volume of </span><em class="italic"><span class="koboSpan" id="kobo.3268.1">The Art of Computer Programming</span></em><span class="koboSpan" id="kobo.3269.1"> by Donald E. </span><span class="koboSpan" id="kobo.3269.2">Knuth (Addison-Wesley Professional, 2011).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3270.1">The following function, which is part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3271.1">randomNumbers.go</span></code><span class="koboSpan" id="kobo.3272.1"> found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3273.1">ch02</span></code><span class="koboSpan" id="kobo.3274.1"> in the book’s GitHub repository, is what generates random numbers in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3275.1">[min, max)</span></code><span class="koboSpan" id="kobo.3276.1"> range.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3277.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3278.1">random</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3279.1">(min, max </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3280.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3281.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3282.1">int</span></span><span class="koboSpan" id="kobo.3283.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3284.1">return</span></span><span class="koboSpan" id="kobo.3285.1"> rand.Intn(max-min) + min
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3286.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3287.1">random()</span></code><span class="koboSpan" id="kobo.3288.1"> function does all of the work, which is generating pseudo-random numbers in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3289.1">min</span></code><span class="koboSpan" id="kobo.3290.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3291.1">max-1</span></code><span class="koboSpan" id="kobo.3292.1"> range by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.3293.1">rand.Intn()</span></code><span class="koboSpan" id="kobo.3294.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.3295.1">rand.Intn()</span></code><span class="koboSpan" id="kobo.3296.1"> generates non-negative random integers from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3297.1">0</span></code><span class="koboSpan" id="kobo.3298.1"> up to the value of its single parameter minus 1.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3299.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3300.1">randomNumbers.go</span></code><span class="koboSpan" id="kobo.3301.1"> utility accepts four command line parameters but can also work with fewer parameters by using default values. </span><span class="koboSpan" id="kobo.3301.2">By default, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3302.1">randomNumbers.go</span></code><span class="koboSpan" id="kobo.3303.1"> produces 100 random integers from 0 up to and including 99.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3304.1">$ </span></span><span class="koboSpan" id="kobo.3305.1">go run randomNumbers.go 
Using default values!
</span><span class="koboSpan" id="kobo.3305.2">39 75 78 89 39 28 37 96 93 42 60 69 50 9 69 27 22 63 4 68 56 23 54 14 93 61 19 13 83 72 87 29 4 45 75 53 41 76 84 51 62 68 37 11 83 20 63 58 12 50 8 31 14 87 13 97 17 60 51 56 21 68 32 41 79 13 79 59 95 56 24 83 53 62 97 88 67 59 49 65 79 10 51 73 48 58 48 27 30 88 19 16 16 11 35 45 72 51 41 28
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3306.1">In the following output, we define</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.3307.1"> each of the parameters manually (the minimum value, maximum value, number of random values, and seed value):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3308.1">$ </span></span><span class="koboSpan" id="kobo.3309.1">go run randomNumbers.go 1 5 10 10
3 1 4 4 1 1 4 4 4 3
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3310.1">$ </span></span><span class="koboSpan" id="kobo.3311.1">go run randomNumbers.go 1 5 10 10
3 1 4 4 1 1 4 4 4 3
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3312.1">$ </span></span><span class="koboSpan" id="kobo.3313.1">go run randomNumbers.go 1 5 10 11
1 4 2 1 3 2 2 4 1 3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3314.1">The first two times the seed value was 10, so we got the same output. </span><span class="koboSpan" id="kobo.3314.2">The third time the value of the seed was 11, which </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.3315.1">generated a different output.</span></p>
<h2 class="heading-2" id="_idParaDest-79"><span class="koboSpan" id="kobo.3316.1">Generating random strings</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3317.1">Imagine that you want to generate </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.3318.1">random strings that can be used for difficult-to-guess passwords or for testing purposes. </span><span class="koboSpan" id="kobo.3318.2">Based on random number generation, we create a utility that produces random strings. </span><span class="koboSpan" id="kobo.3318.3">The utility is implemented as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3319.1">genPass.go</span></code><span class="koboSpan" id="kobo.3320.1"> and can be found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3321.1">ch02</span></code><span class="koboSpan" id="kobo.3322.1"> directory of the book’s GitHub repository. </span><span class="koboSpan" id="kobo.3322.2">The core functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3323.1">genPass.go</span></code><span class="koboSpan" id="kobo.3324.1"> is found in the next function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3325.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3326.1">getString</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3327.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3328.1">len</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3329.1">int64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3330.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3331.1">string</span></span><span class="koboSpan" id="kobo.3332.1"> {
    temp := </span><span class="hljs-string"><span class="koboSpan" id="kobo.3333.1">""</span></span><span class="koboSpan" id="kobo.3334.1">
    startChar := </span><span class="hljs-string"><span class="koboSpan" id="kobo.3335.1">"!"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3336.1">var</span></span><span class="koboSpan" id="kobo.3337.1"> i </span><span class="hljs-type"><span class="koboSpan" id="kobo.3338.1">int64</span></span><span class="koboSpan" id="kobo.3339.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3340.1">1</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3341.1">for</span></span><span class="koboSpan" id="kobo.3342.1"> {
        myRand := random(MIN, MAX)
        newChar := </span><span class="hljs-type"><span class="koboSpan" id="kobo.3343.1">string</span></span><span class="koboSpan" id="kobo.3344.1">(startChar[</span><span class="hljs-number"><span class="koboSpan" id="kobo.3345.1">0</span></span><span class="koboSpan" id="kobo.3346.1">] + </span><span class="hljs-type"><span class="koboSpan" id="kobo.3347.1">byte</span></span><span class="koboSpan" id="kobo.3348.1">(myRand))
        temp = temp + newChar
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3349.1">if</span></span><span class="koboSpan" id="kobo.3350.1"> i == </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3351.1">len</span></span><span class="koboSpan" id="kobo.3352.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3353.1">break</span></span><span class="koboSpan" id="kobo.3354.1">
        }
        i++
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3355.1">return</span></span><span class="koboSpan" id="kobo.3356.1"> temp
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3357.1">As we only want to get printable ASCII characters, we limit the range of pseudo-random numbers that can be generated. </span><span class="koboSpan" id="kobo.3357.2">The total number of printable characters in the ASCII table is 94. </span><span class="koboSpan" id="kobo.3357.3">This means that the range of the pseudo-random numbers that the program can generate should be from 0 to 94, without including 94. </span><span class="koboSpan" id="kobo.3357.4">Therefore, the values of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3358.1">MIN</span></code><span class="koboSpan" id="kobo.3359.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3360.1">MAX</span></code><span class="koboSpan" id="kobo.3361.1"> global variables, which are not shown here, are 0 and 94, respectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3362.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3363.1">startChar</span></code><span class="koboSpan" id="kobo.3364.1"> variable holds the first ASCII character that can be generated by the utility, which, in this case, is the exclamation mark, which has a decimal ASCII value of 33. </span><span class="koboSpan" id="kobo.3364.2">Given that the program can generate pseudo-random numbers up to 94, the maximum ASCII value that can be generated is 93 + 33, which is equal to 126, which is the ASCII value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3365.1">~</span></code><span class="koboSpan" id="kobo.3366.1">. </span><span class="koboSpan" id="kobo.3366.2">All generated characters are kept in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3367.1">temp</span></code><span class="koboSpan" id="kobo.3368.1"> variable, which is returned once the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3369.1">for</span></code><span class="koboSpan" id="kobo.3370.1"> loop exits. </span><span class="koboSpan" id="kobo.3370.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3371.1">string(startChar[0] + byte(myRand))</span></code><span class="koboSpan" id="kobo.3372.1"> statement converts the random integers into characters in the desired range.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3373.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3374.1">genPass.go</span></code><span class="koboSpan" id="kobo.3375.1"> utility accepts a single parameter, which is the length of the generated password. </span><span class="koboSpan" id="kobo.3375.2">If no parameter is given, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3376.1">genPass.go</span></code><span class="koboSpan" id="kobo.3377.1"> produces a password with 8 characters, which is the default value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3378.1">LENGTH</span></code><span class="koboSpan" id="kobo.3379.1"> variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3380.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.3381.1">genPass.go</span></code><span class="koboSpan" id="kobo.3382.1"> produces the</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.3383.1"> following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3384.1">$ </span></span><span class="koboSpan" id="kobo.3385.1">go run genPass.go
Using default values...
</span><span class="koboSpan" id="kobo.3385.2">!QrNq@;R
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3386.1">$ </span></span><span class="koboSpan" id="kobo.3387.1">go run genPass.go 20
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3388.1">sZL&gt;</span></span><span class="koboSpan" id="kobo.3389.1">{F~</span><span class="hljs-con-string"><span class="koboSpan" id="kobo.3390.1">"hQqY&gt;r_&gt;TX?O</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3391.1">The first program execution uses the default value for the length of the generated string whereas the second program execution creates a random string with 20 characters.</span></p>
<h2 class="heading-2" id="_idParaDest-80"><span class="koboSpan" id="kobo.3392.1">Generating secure random numbers</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3393.1">If you intend to use these pseudo-random</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.3394.1"> numbers for security-related work, it is important that you use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3395.1">crypto/rand</span></code><span class="koboSpan" id="kobo.3396.1"> package, which implements a cryptographically secure pseudo-random number generator. </span><span class="koboSpan" id="kobo.3396.2">You do not need to define a seed when using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3397.1">crypto/rand</span></code><span class="koboSpan" id="kobo.3398.1"> package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3399.1">The following function that is part of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3400.1">cryptoRand.go</span></code><span class="koboSpan" id="kobo.3401.1"> source code showcases how secure random numbers are generated with the functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3402.1">crypto/rand</span></code><span class="koboSpan" id="kobo.3403.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3404.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3405.1">generateBytes</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3406.1">(n </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3407.1">int64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3408.1">)</span></span><span class="koboSpan" id="kobo.3409.1"> ([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.3410.1">byte</span></span><span class="koboSpan" id="kobo.3411.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3412.1">error</span></span><span class="koboSpan" id="kobo.3413.1">) {
    b := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3414.1">make</span></span><span class="koboSpan" id="kobo.3415.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.3416.1">byte</span></span><span class="koboSpan" id="kobo.3417.1">, n)
    _, err := rand.Read(b)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3418.1">if</span></span><span class="koboSpan" id="kobo.3419.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3420.1">nil</span></span><span class="koboSpan" id="kobo.3421.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3422.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.3423.1">nil</span></span><span class="koboSpan" id="kobo.3424.1">, err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3425.1">return</span></span><span class="koboSpan" id="kobo.3426.1"> b, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3427.1">nil</span></span><span class="koboSpan" id="kobo.3428.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3429.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3430.1">rand.Read()</span></code><span class="koboSpan" id="kobo.3431.1"> function randomly generates numbers that occupy the entire </span><code class="inlineCode"><span class="koboSpan" id="kobo.3432.1">b</span></code><span class="koboSpan" id="kobo.3433.1"> byte slice. </span><span class="koboSpan" id="kobo.3433.2">You need to decode that byte slice using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3434.1">base64.URLEncoding.EncodeToString(b)</span></code><span class="koboSpan" id="kobo.3435.1"> in order to get a valid string without any control or unprintable characters. </span><span class="koboSpan" id="kobo.3435.2">This transformation takes place in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3436.1">generatePass()</span></code><span class="koboSpan" id="kobo.3437.1"> function, which is not shown here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3438.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.3439.1">cryptoRand.go</span></code><span class="koboSpan" id="kobo.3440.1"> creates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3441.1">$ </span></span><span class="koboSpan" id="kobo.3442.1">go run cryptoRand.go   
Using default values!
</span><span class="koboSpan" id="kobo.3442.2">Ce30g--D
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3443.1">$ </span></span><span class="koboSpan" id="kobo.3444.1">go run cryptoRand.go 20
AEIePSYb13KwkDnO5Xk_
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3445.1">The output is not different from the one generated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3446.1">genPass.go</span></code><span class="koboSpan" id="kobo.3447.1">, it is just that the random numbers are generated more</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.3448.1"> securely, which means that they can be used in applications where security is important.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3449.1">Now that we know how to generate random numbers, we are going to revisit the statistics application.</span></p>
<h1 class="heading-1" id="_idParaDest-81"><span class="koboSpan" id="kobo.3450.1">Updating the statistics application</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3451.1">In this section, we are going to improve the functionality and the operation of the statistics application. </span><span class="koboSpan" id="kobo.3451.2">When there is no</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.3452.1"> valid input, we are going to populate the statistics application with ten random values, which is pretty handy when you want to put lots of data in an application for testing purposes—you can change the number of random values to fit your needs. </span><span class="koboSpan" id="kobo.3452.2">However, keep in mind that this takes place when all user input is invalid.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3453.1">I have randomly generated data in the past in order to put sample data into Kafka topics, RabbitMQ queues and MySQL tables.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3454.1">Additionally, we are going to </span><em class="italic"><span class="koboSpan" id="kobo.3455.1">normalize</span></em><span class="koboSpan" id="kobo.3456.1"> the data. </span><span class="koboSpan" id="kobo.3456.2">Officially, this is called </span><em class="italic"><span class="koboSpan" id="kobo.3457.1">z-normalization</span></em><span class="koboSpan" id="kobo.3458.1"> and is helpful for allowing sequences of values to be </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.3459.1">compared more accurately. </span><span class="koboSpan" id="kobo.3459.2">We are going to use normalization in forthcoming chapters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3460.1">The function for the normalization of the data is implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3461.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3462.1">normalize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3463.1">(data []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3464.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3465.1">, mean </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3466.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3467.1">, stdDev </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3468.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3469.1">)</span></span><span class="koboSpan" id="kobo.3470.1"> []</span><span class="hljs-type"><span class="koboSpan" id="kobo.3471.1">float64</span></span><span class="koboSpan" id="kobo.3472.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3473.1">if</span></span><span class="koboSpan" id="kobo.3474.1"> stdDev == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3475.1">0</span></span><span class="koboSpan" id="kobo.3476.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3477.1">return</span></span><span class="koboSpan" id="kobo.3478.1"> data
}
normalized := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3479.1">make</span></span><span class="koboSpan" id="kobo.3480.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.3481.1">float64</span></span><span class="koboSpan" id="kobo.3482.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3483.1">len</span></span><span class="koboSpan" id="kobo.3484.1">(data))
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3485.1">for</span></span><span class="koboSpan" id="kobo.3486.1"> i, val := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3487.1">range</span></span><span class="koboSpan" id="kobo.3488.1"> data {
    normalized[i] = </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.3489.1">math.Floor((val-mean)/stdDev*</span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.3490.1">10000</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.3491.1">) / </span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.3492.1">10000</span></strong></span><span class="koboSpan" id="kobo.3493.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3494.1">return</span></span><span class="koboSpan" id="kobo.3495.1"> normalized
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3496.1">From the parameters of the function, you can see that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3497.1">normalize()</span></code><span class="koboSpan" id="kobo.3498.1"> needs the mean value and the standard deviation of the sample before normalizing it. </span><span class="koboSpan" id="kobo.3498.2">Apart from that, there is a small trick with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3499.1">math.Floor()</span></code><span class="koboSpan" id="kobo.3500.1"> for defining the accuracy of the normalized </span><code class="inlineCode"><span class="koboSpan" id="kobo.3501.1">float64</span></code><span class="koboSpan" id="kobo.3502.1"> values, which in this case</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.3503.1"> is four digits. </span><span class="koboSpan" id="kobo.3503.2">To get two digits of accuracy, you should change the code to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3504.1">math.Floor((val-mean)/stdDev*100)/100</span></code><span class="koboSpan" id="kobo.3505.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3506.1">Additionally, the function for generating random floating-point values is implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3507.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3508.1">randomFloat</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3509.1">(min, max </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3510.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3511.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3512.1">float64</span></span><span class="koboSpan" id="kobo.3513.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3514.1">return</span></span><span class="koboSpan" id="kobo.3515.1"> min + rand.Float64()*(max-min)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3516.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3517.1">rand.Float64()</span></code><span class="koboSpan" id="kobo.3518.1"> function returns values from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3519.1">0</span></code><span class="koboSpan" id="kobo.3520.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3521.1">1.0</span></code><span class="koboSpan" id="kobo.3522.1">, without including </span><code class="inlineCode"><span class="koboSpan" id="kobo.3523.1">1.0</span></code><span class="koboSpan" id="kobo.3524.1">. </span><span class="koboSpan" id="kobo.3524.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3525.1">randomFloat()</span></code><span class="koboSpan" id="kobo.3526.1"> function returns values from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3527.1">min</span></code><span class="koboSpan" id="kobo.3528.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3529.1">max</span></code><span class="koboSpan" id="kobo.3530.1">, without including </span><code class="inlineCode"><span class="koboSpan" id="kobo.3531.1">max</span></code><span class="koboSpan" id="kobo.3532.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3533.1">You can review the source code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3534.1">stats.go</span></code><span class="koboSpan" id="kobo.3535.1"> to learn about the remaining implementation details. </span><span class="koboSpan" id="kobo.3535.2">The main difference with the version of the previous chapter is that we are now using a slice called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3536.1">values</span></code><span class="koboSpan" id="kobo.3537.1"> for storing all the valid values that we are processing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3538.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.3539.1">stats.go</span></code><span class="koboSpan" id="kobo.3540.1"> produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3541.1">$ </span></span><span class="koboSpan" id="kobo.3542.1">go run stats.go 3 5 5 8 9 12 12 13 15 16 17 19 22 24 25 134
Number of values: 16
Min: 3
Max: 134
Mean value: 21.18750
Standard deviation: 29.84380
Normalized: [-0.6095 -0.5425 -0.5425 -0.4419 -0.4084 -0.3079 -0.3079 -0.2744 -0.2074 -0.1739 -0.1404 -0.0733 0.0272 0.0942 0.1277 3.78] 
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3543.1">Although randomly generated values might not be perfect at all times, they are usually more than enough for testing purposes.</span></p>
<h1 class="heading-1" id="_idParaDest-82"><span class="koboSpan" id="kobo.3544.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3545.1">In this chapter, we learned about the basic data types of Go, including numerical data types, strings, and errors. </span><span class="koboSpan" id="kobo.3545.2">Additionally, we learned how to group similar values using arrays and slices. </span><span class="koboSpan" id="kobo.3545.3">Lastly, we learned about the differences between arrays and slices and why slices are more versatile than arrays, as well as pointers and generating random numbers and strings in order to generate random data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3546.1">One thing that you should remember from this chapter is that a slice is empty if its length is equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3547.1">0</span></code><span class="koboSpan" id="kobo.3548.1">. </span><span class="koboSpan" id="kobo.3548.2">On the other hand, a slice is </span><code class="inlineCode"><span class="koboSpan" id="kobo.3549.1">nil</span></code><span class="koboSpan" id="kobo.3550.1"> if it is equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3551.1">nil</span></code><span class="koboSpan" id="kobo.3552.1">—this means that it points to no memory address. </span><span class="koboSpan" id="kobo.3552.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3553.1">var s []string</span></code><span class="koboSpan" id="kobo.3554.1"> statement creates a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3555.1">nil</span></code><span class="koboSpan" id="kobo.3556.1"> slice without allocating any memory. </span><span class="koboSpan" id="kobo.3556.2">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.3557.1">nil</span></code><span class="koboSpan" id="kobo.3558.1"> slice is always empty—the reverse is not always true.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3559.1">As far as Go strings are concerned, remember that double quotes define an interpreted string literal whereas back quotes define a raw string literal. </span><span class="koboSpan" id="kobo.3559.2">Most of the time, you need double quotes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3560.1">Last, keep in mind that the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3561.1">unsafe</span></code><span class="koboSpan" id="kobo.3562.1"> package can lead to subtle bugs and memory safety issues. </span><span class="koboSpan" id="kobo.3562.2">The Go language encourages type safety, and the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3563.1">unsafe</span></code><span class="koboSpan" id="kobo.3564.1"> should be limited to situations where there is a clear understanding of the risks and where no safer alternative exists.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3565.1">The next chapter discusses the composite data types of Go, namely, maps and structures. </span><span class="koboSpan" id="kobo.3565.2">Maps can use keys of different data types whereas structures can group multiple data types and create new ones that you can access as single entities. </span><span class="koboSpan" id="kobo.3565.3">As you will see in later chapters, structures play a key role in Go.</span></p>
<h1 class="heading-1" id="_idParaDest-83"><span class="koboSpan" id="kobo.3566.1">Exercises</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3567.1">Try to do the following exercises:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3568.1">Correct the error in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3569.1">typedConstants.go</span></code><span class="koboSpan" id="kobo.3570.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3571.1">Create and test a function that concatenates two arrays into a new slice.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3572.1">Create a function that concatenates two arrays into a new array. </span><span class="koboSpan" id="kobo.3572.2">Do not forget to test it with various types of input.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3573.1">Create a function that concatenates two slices into a new array.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3574.1">Run </span><code class="inlineCode"><span class="koboSpan" id="kobo.3575.1">go doc errors Is</span></code><span class="koboSpan" id="kobo.3576.1"> in order to learn about </span><code class="inlineCode"><span class="koboSpan" id="kobo.3577.1">errors.Is()</span></code><span class="koboSpan" id="kobo.3578.1"> and try to create a small Go program that uses it. </span><span class="koboSpan" id="kobo.3578.2">After that, modify </span><code class="inlineCode"><span class="koboSpan" id="kobo.3579.1">error.go</span></code><span class="koboSpan" id="kobo.3580.1"> to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3581.1">errors.Is()</span></code><span class="koboSpan" id="kobo.3582.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3583.1">Modify </span><code class="inlineCode"><span class="koboSpan" id="kobo.3584.1">stats.go</span></code><span class="koboSpan" id="kobo.3585.1"> in order to accept the number of randomly generated values as a command line argument.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3586.1">Modify </span><code class="inlineCode"><span class="koboSpan" id="kobo.3587.1">stats.go</span></code><span class="koboSpan" id="kobo.3588.1"> in order to always use randomly generated data.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-84"><span class="koboSpan" id="kobo.3589.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3590.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3591.1">sort</span></code><span class="koboSpan" id="kobo.3592.1"> package documentation: </span><a href="https://pkg.go.dev/sort"><span class="url"><span class="koboSpan" id="kobo.3593.1">https://pkg.go.dev/sort</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3594.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3595.1">time</span></code><span class="koboSpan" id="kobo.3596.1"> package documentation: </span><a href="https://pkg.go.dev/time"><span class="url"><span class="koboSpan" id="kobo.3597.1">https://pkg.go.dev/time</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3598.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3599.1">crypto/rand</span></code><span class="koboSpan" id="kobo.3600.1"> package documentation: </span><a href="https://pkg.go.dev/crypto/rand"><span class="url"><span class="koboSpan" id="kobo.3601.1">https://pkg.go.dev/crypto/rand</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3602.1">Go 1.20 release notes: </span><a href="https://tip.golang.org/doc/go1.20"><span class="url"><span class="koboSpan" id="kobo.3603.1">https://tip.golang.org/doc/go1.20</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3604.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3605.1">math/rand</span></code><span class="koboSpan" id="kobo.3606.1"> package documentation: </span><a href="https://pkg.go.dev/math/rand "><span class="url"><span class="koboSpan" id="kobo.3607.1">https://pkg.go.dev/math/rand</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.3608.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3609.1">Join our community’s Discord space for discussions with the authors and other readers:</span></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.3610.1">https://discord.gg/FzuQbc8zd6</span></span></a></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.3611.1"><img alt="" role="presentation" src="../Images/QR_Code2286825896190168453.png"/></span></span></a></p>
</div>
</body></html>