["```go\npackage main\nimport (\n    \"errors\"\n\"fmt\"\n\"os\"\n\"strconv\"\n) \n```", "```go\nfunc check(a, b int) error {\n    if a == 0 && b == 0 {\n        return errors.New(\"this is a custom error message\")\n    }\n    return nil\n} \n```", "```go\nfunc formattedError(a, b int) error {\n    if a == 0 && b == 0 {\n        return fmt.Errorf(\"a %d and b %d. UserID: %d\", a, b, os.Getuid())\n    }\n    return nil\n} \n```", "```go\nfunc main() {\n    err := check(0, 10)\n    if err == nil {\n        fmt.Println(\"check() executed normally!\")\n    } else {\n        fmt.Println(err)\n    }\n    err = check(0, 0)\n    if err.Error() == \"this is a custom error message\" {\n        fmt.Println(\"Custom error detected!\")\n    }\n    err = formattedError(0, 0)\n    if err != nil {\n        fmt.Println(err)\n    }\n    i, err := strconv.Atoi(\"-123\")\n    if err == nil {\n        fmt.Println(\"Int value is\", i)\n    }\n    i, err = strconv.Atoi(\"Y123\")\n    if err != nil {\n        fmt.Println(err)\n    }\n} \n```", "```go\n$ go run error.go\ncheck() ended normally!\nCustom error detected!\na 0 and b 0\\. UserID: 501\nInt value is -123\nstrconv.Atoi: parsing \"Y123\": invalid syntax \n```", "```go\nfunc main() {\n    c1 := 12 + 1i\n    c2 := complex(5, 7)\n    fmt.Printf(\"Type of c1: %T\\n\", c1)\n    fmt.Printf(\"Type of c2: %T\\n\", c2) \n```", "```go\n var c3 complex64 = complex64(c1 + c2)\n    fmt.Println(\"c3:\", c3)\n    fmt.Printf(\"Type of c3: %T\\n\", c3)\n    cZero := c3 - c3\n    fmt.Println(\"cZero:\", cZero) \n```", "```go\n x := 12\n    k := 5\n    fmt.Println(x)\n    fmt.Printf(\"Type of x: %T\\n\", x)\n    div := x / k\n    fmt.Println(\"div\", div) \n```", "```go\n var m, n float64\n    m = 1.223\n    fmt.Println(\"m, n:\", m, n)\n    y := 4 / 2.3\n    fmt.Println(\"y:\", y)\n    divFloat := float64(x) / float64(k)\n    fmt.Println(\"divFloat\", divFloat)\n    fmt.Printf(\"Type of divFloat: %T\\n\", divFloat)\n} \n```", "```go\n$ go run numbers.go\nType of c1: complex128\nType of c2: complex128\nc3: (17+8i)\nType of c3: complex64\ncZero: (0+0i)\n12\nType of x: int\ndiv 2\nm, n: 1.223 0\ny: 1.7391304347826086\ndivFloat 2.4\nType of divFloat: float64 \n```", "```go\nfor {\n    if i == math.MaxInt {\n        break\n    }\n    i = i + 1\n} \n```", "```go\nfor {\n    if i == math.MinInt {\n        break\n    }\n    i = i - 1\n} \n```", "```go\n$ go run overflows.go\nMax: 9223372036854775807\nMax overflow: -9223372036854775808\nMin: -9223372036854775808 \n```", "```go\nfunc main() {\n    aString := \"Hello World! €\"\n    fmt.Println(\"First byte\", string(aString[0])) \n```", "```go\n r := '€'\n    fmt.Println(\"As an int32 value:\", r)\n    // Convert Runes to text\n    fmt.Printf(\"As a string: %s and as a character: %c\\n\", r, r)\n    // Print an existing string as runes\nfor _, v := range aString {\n        fmt.Printf(\"%x \", v)\n    }\n    fmt.Println() \n```", "```go\n // Print an existing string as characters\nfor _, v := range aString {\n        fmt.Printf(\"%c\", v)\n    }\n    fmt.Println()\n} \n```", "```go\n$ go run text.go\nFirst byte H\nAs an int32 value: 8364\nAs a string: %!s(int32=8364) and as a character: €\n48 65 6c 6c 6f 20 57 6f 72 6c 64 21 20 20ac\nHello World! € \n```", "```go\n input := strconv.Itoa(n)\n    input = strconv.FormatInt(int64(n), 10)\n    input = string(n) \n```", "```go\n$ go run intString.go 100\nstrconv.Itoa() 100 of type string\nstrconv.FormatInt() 100 of type string\nstring() d of type string \n```", "```go\n for i := 0; i < len(sL); i++ {\n        if unicode.IsPrint(rune(sL[i])) {\n            fmt.Printf(\"%c\\n\", sL[i])\n        } else {\n            fmt.Println(\"Not printable!\")\n        }\n    } \n```", "```go\nNot printable!\nNot printable!\na\nb\nP\nNot printable!\n#\nP\n)\nNot printable! \n```", "```go\nimport (\n    \"fmt\"\n    s \"strings\"\n\"unicode\"\n)\nvar f = fmt.Printf \n```", "```go\n f(\"To Upper: %s\\n\", s.ToUpper(\"Hello THERE\"))\n    f(\"To Lower: %s\\n\", s.ToLower(\"Hello THERE\"))\n    f(\"%s\\n\", s.Title(\"tHis wiLL be A title!\"))\n    f(\"EqualFold: %v\\n\", s.EqualFold(\"Mihalis\", \"MIHAlis\"))\n    f(\"EqualFold: %v\\n\", s.EqualFold(\"Mihalis\", \"MIHAli\")) \n```", "```go\n f(\"Index: %v\\n\", s.Index(\"Mihalis\", \"ha\"))\n    f(\"Index: %v\\n\", s.Index(\"Mihalis\", \"Ha\"))\n    f(\"Count: %v\\n\", s.Count(\"Mihalis\", \"i\"))\n    f(\"Count: %v\\n\", s.Count(\"Mihalis\", \"I\"))\n    f(\"Repeat: %s\\n\", s.Repeat(\"ab\", 5))\n    f(\"TrimSpace: %s\\n\", s.TrimSpace(\" \\tThis is a line. \\n\"))\n    f(\"TrimLeft: %s\", s.TrimLeft(\" \\tThis is a\\t line. \\n\", \"\\n\\t \"))\n    f(\"TrimRight: %s\\n\", s.TrimRight(\" \\tThis is a\\t line. \\n\", \"\\n\\t \")) \n```", "```go\n f(\"Prefix: %v\\n\", s.HasPrefix(\"Mihalis\", \"Mi\"))\n    f(\"Prefix: %v\\n\", s.HasPrefix(\"Mihalis\", \"mi\"))\n    f(\"Suffix: %v\\n\", s.HasSuffix(\"Mihalis\", \"is\"))\n    f(\"Suffix: %v\\n\", s.HasSuffix(\"Mihalis\", \"IS\")) \n```", "```go\n t := s.Fields(\"This is a string!\")\n    f(\"Fields: %v\\n\", len(t))\n    t = s.Fields(\"ThisIs a\\tstring!\")\n    f(\"Fields: %v\\n\", len(t)) \n```", "```go\n f(\"%s\\n\", s.Split(\"abcd efg\", \"\"))\n    f(\"%s\\n\", s.Replace(\"abcd efg\", \"\", \"_\", -1))\n    f(\"%s\\n\", s.Replace(\"abcd efg\", \"\", \"_\", 4))\n    f(\"%s\\n\", s.Replace(\"abcd efg\", \"\", \"_\", 2)) \n```", "```go\n f(\"SplitAfter: %s\\n\", s.SplitAfter(\"123++432++\", \"++\"))\n    trimFunction := func(c rune) bool {\n        return !unicode.IsLetter(c)\n    }\n    f(\"TrimFunc: %s\\n\", s.TrimFunc(\"123 abc ABC \\t .\", trimFunction)) \n```", "```go\nTo Upper: HELLO THERE!\nTo Lower: hello there\nTHis WiLL Be A Title!\nEqualFold: true\nEqualFold: false\nPrefix: true\nPrefix: false\nSuffix: true\nSuffix: false\nIndex: 2\nIndex: -1\nCount: 2\nCount: 0\nRepeat: ababababab\nTrimSpace: This is a line.\nTrimLeft: This is a      line. \nTrimRight:      This is a        line.\nCompare: 1\nCompare: 0\nCompare: -1\nFields: 4\nFields: 3\n[a b c d   e f g]\n_a_b_c_d_ _e_f_g_\n_a_b_c_d efg\n_a_bcd efg\nJoin: Line 1+++Line 2+++Line 3\nSplitAfter: [123++ 432++ ]\nTrimFunc: abc ABC \n```", "```go\n loc, _ = time.LoadLocation(\"America/New_York\")\n    fmt.Printf(\"New York Time: %s\\n\", now.In(loc)) \n```", "```go\n$ go run convertTimes.go \"14 December 2023 19:20 EET\"\nCurrent Location: 2023-12-14 19:20:00 +0200 EET\nNew York Time: 2023-12-14 12:20:00 -0500 EST\nLondon Time: 2023-12-14 17:20:00 +0000 GMT\nTokyo Time: 2023-12-15 02:20:00 +0900 JST\n$ go run convertTimes.go \"14 December 2023 19:20 UTC\"\nCurrent Location: 2023-12-14 21:20:00 +0200 EET\nNew York Time: 2023-12-14 14:20:00 -0500 EST\nLondon Time: 2023-12-14 19:20:00 +0000 GMT\nTokyo Time: 2023-12-15 04:20:00 +0900 JST\n$ go run convertTimes.go \"14 December 2023 25:00 EET\"\nparsing time \"14 December 2023 25:00 EET\": hour out of range \n```", "```go\ntype Digit int\ntype Power2 int\nconst PI = 3.1415926\nconst (\n    C1 = \"C1C1C1\"\n    C2 = \"C2C2C2\"\n    C3 = \"C3C3C3\"\n) \n```", "```go\nfunc main() {\n    const s1 = 123\nvar v1 float32 = s1 * 12\n    fmt.Println(v1)\n    fmt.Println(PI)\n    const (\n        Zero Digit = iota\n        One\n        Two\n        Three\n        Four\n    ) \n```", "```go\nconst (\n    Zero = 0\n    One = 1\n    Two = 2\n    Three = 3\n    Four = 4\n) \n```", "```go\n fmt.Println(One)\n    fmt.Println(Two)\n    const (\n        p2_0 Power2 = 1 << iota\n        _\n        p2_2\n        _\n        p2_4\n        _\n        p2_6\n    )\n    fmt.Println(\"2^0:\", p2_0)\n    fmt.Println(\"2^2:\", p2_2)\n    fmt.Println(\"2^4:\", p2_4)\n    fmt.Println(\"2^6:\", p2_6)\n} \n```", "```go\n$ go run constants.go\n1476\n3.1415926\n1\n2\n2^0: 1\n2^2: 4\n2^4: 16\n2^6: 64 \n```", "```go\nconst (\n    typedConstant   = int16(100)\n    untypedConstant = 100\n)\nfunc main() {\n    i := int(1)\n    fmt.Println(\"unTyped:\", i*untypedConstant)\n    fmt.Println(\"Typed:\", **i*typedConstant**)\n} \n```", "```go\n$ go run typedConstants.go\n# command-line-arguments\n./typedConstants.go:13:24: invalid operation: i * typedConstant (mismatched types int and int16) \n```", "```go\ntype SliceHeader struct {\n    Data uintptr\n    Len  int\n    Cap  int\n} \n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n    // Create an empty slice\n    aSlice := []float64{}\n    // Both length and capacity are 0 because aSlice is empty\n    fmt.Println(aSlice, len(aSlice), cap(aSlice))\n    // Add elements to a slice\n    aSlice = append(aSlice, 1234.56)\n    aSlice = append(aSlice, -34.0)\n    fmt.Println(aSlice, \"with length\", len(aSlice)) \n```", "```go\n // A slice with a length of 4\n    t := make([]int, 4)\n    t[0] = -1\n    t[1] = -2\n    t[2] = -3\n    t[3] = -4\n// Now you will need to use append\n    t = append(t, -5)\n    fmt.Println(t) \n```", "```go\n // A 2D slice\n    twoD := [][]int{{1, 2, 3}, {4, 5, 6}}\n    // Visiting all elements of a 2D slice\n// with a double for loop\nfor _, i := range twoD {\n            for _, k := range i {\n                fmt.Print(k, \" \")\n            }\n            fmt.Println()\n    } \n```", "```go\n make2D := make([][]int, 2)\n    fmt.Println(make2D)\n    make2D[0] = []int{1, 2, 3, 4}\n    make2D[1] = []int{-1, -2, -3, -4}\n    fmt.Println(make2D)\n} \n```", "```go\n$ go run goSlices.go \n[] 0 0\n[1234.56 -34] with length 2\n[-1 -2 -3 -4 -5]\n1 2 3 \n4 5 6 \n[[] []]\n[[1 2 3 4] [-1 -2 -3 -4]] \n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n    // Only length is defined. Capacity = length\n    a := make([]int, 4) \n```", "```go\n fmt.Println(\"L:\", len(a), \"C:\", cap(a))\n    // Initialize slice. Capacity = length\n    b := []int{0, 1, 2, 3, 4}\n    fmt.Println(\"L:\", len(b), \"C:\", cap(b)) \n```", "```go\n // Same length and capacity\n    aSlice := make([]int, 4, 4)\n    fmt.Println(aSlice) \n```", "```go\n // Add an element\n    aSlice = append(aSlice, 5) \n```", "```go\n fmt.Println(aSlice)\n    // The capacity is doubled\n    fmt.Println(\"L:\", len(aSlice), \"C:\", cap(aSlice))\n    // Now add four elements\n    aSlice = append(aSlice, []int{-1, -2, -3, -4}...) \n```", "```go\n fmt.Println(aSlice)\n    // The capacity is doubled\n    fmt.Println(\"L:\", len(aSlice), \"C:\", cap(aSlice))\n} \n```", "```go\n$ go run capLen.go \nL: 4 C: 4\nL: 5 C: 5\n[0 0 0 0]\n[0 0 0 0 5]\nL: 5 C: 8\n[0 0 0 0 5 -1 -2 -3 -4]\nL: 9 C: 16 \n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n    aSlice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    fmt.Println(aSlice)\n    l := len(aSlice)\n    // First 5 elements\n    fmt.Println(aSlice[0:5])\n    // First 5 elements\n    fmt.Println(aSlice[:5]) \n```", "```go\n // Last 2 elements\n    fmt.Println(aSlice[l-2 : l])\n    // Last 2 elements\n    fmt.Println(aSlice[l-2:]) \n```", "```go\n // First 5 elements\n    t := aSlice[0:5:10]\n    fmt.Println(len(t), cap(t))\n    // Elements at indexes 2,3,4\n// Capacity will be 10-2\n    t = aSlice[2:5:10]\n    fmt.Println(len(t), cap(t)) \n```", "```go\n // Elements at indexes 0,1,2,3,4\n// New capacity will be 6-0\n    t = aSlice[:5:6]\n    fmt.Println(len(t), cap(t))\n} \n```", "```go\n$ go run partSlice.go\n[0 1 2 3 4 5 6 7 8 9] \n```", "```go\n[0 1 2 3 4]\n[0 1 2 3 4] \n```", "```go\n[8 9]\n[8 9] \n```", "```go\n5 10\n3 8\n5 6 \n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n    // Byte slice\n    b := make([]byte, 12)\n    fmt.Println(\"Byte slice:\", b) \n```", "```go\n b = []byte(\"Byte slice €\")\n    fmt.Println(\"Byte slice:\", b) \n```", "```go\n // Print byte slice contents as text\n    fmt.Printf(\"Byte slice as text: %s\\n\", b)\n    fmt.Println(\"Byte slice as text:\", string(b)) \n```", "```go\n // Length of b\n    fmt.Println(\"Length of b:\", len(b))\n} \n```", "```go\n$ go run byteSlices.go \nByte slice: [0 0 0 0 0 0 0 0 0 0 0 0]\nByte slice: [66 121 116 101 32 115 108 105 99 101 32 226 130 172]\nByte slice as text: Byte slice €\nByte slice as text: Byte slice €\nLength of b: 14 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"strconv\"\n)\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Need an integer value.\")\n        return\n    }\n    index := arguments[1]\n    i, err := strconv.Atoi(index)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"Using index\", i)\n    aSlice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8}\n    fmt.Println(\"Original slice:\", aSlice)\n    // Delete element at index i\nif i > len(aSlice)-1 {\n        fmt.Println(\"Cannot delete element\", i)\n        return\n    }\n    // The ... operator auto expands aSlice[i+1:] so that\n// its elements can be appended to aSlice[:i] one by one\n    aSlice = append(aSlice[:i], aSlice[i+1:]...)\n    fmt.Println(\"After 1st deletion:\", aSlice) \n```", "```go\n // Delete element at index i\nif i > len(aSlice)-1 {\n        fmt.Println(\"Cannot delete element\", i)\n        return\n    }\n    // Replace element at index i with last element\n    aSlice[i] = aSlice[len(aSlice)-1]\n    // Remove last element\n    aSlice = aSlice[:len(aSlice)-1]\n    fmt.Println(\"After 2nd deletion:\", aSlice)\n} \n```", "```go\n$ go run deleteSlice.go 1\nUsing index 1\nOriginal slice: [0 1 2 3 4 5 6 7 8]\nAfter 1st deletion: [0 2 3 4 5 6 7 8]\nAfter 2nd deletion: [0 8 3 4 5 6 7] \n```", "```go\n$ go run deleteSlice.go 10\nUsing index 10\nOriginal slice: [0 1 2 3 4 5 6 7 8]\nCannot delete element 10 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc change(s []string) {\n    s[0] = \"Change_function\"\n} \n```", "```go\nfunc main() {\n    a := [4]string{\"Zero\", \"One\", \"Two\", \"Three\"}\n    fmt.Println(\"a:\", a) \n```", "```go\n var S0 = a[0:1]\n    fmt.Println(S0)\n    S0[0] = \"S0\" \n```", "```go\n var S12 = a[1:3]\n    fmt.Println(S12)\n    S12[0] = \"S12_0\"\n    S12[1] = \"S12_1\" \n```", "```go\n fmt.Println(\"a:\", a) \n```", "```go\n // Changes to slice -> changes to array\n    change(S12)\n    fmt.Println(\"a:\", a) \n```", "```go\n // capacity of S0\n    fmt.Println(\"Capacity of S0:\", cap(S0), \"Length of S0:\", len(S0))\n    // Adding 4 elements to S0\n    S0 = append(S0, \"N1\")\n    S0 = append(S0, \"N2\")\n    S0 = append(S0, \"N3\")\n    a[0] = \"-N1\" \n```", "```go\n // Changing the capacity of S0\n// Not the same underlying array anymore!\n    S0 = append(S0, \"N4\")\n    fmt.Println(\"Capacity of S0:\", cap(S0), \"Length of S0:\", len(S0))\n    // This change does not go to S0\n    a[0] = \"-N1-\"\n// This change goes to S12\n    a[1] = \"-N2-\" \n```", "```go\n fmt.Println(\"S0:\", S0)\n    fmt.Println(\"a: \", a)\n    fmt.Println(\"S12:\", S12)\n} \n```", "```go\n$ go run sliceArrays.go \na: [Zero One Two Three]\n[Zero]\n[One Two]\na: [S0 S12_0 S12_1 Three]\na: [S0 Change_function S12_1 Three]\nCapacity of S0: 4 Length of S0: 1\nCapacity of S0: 8 Length of S0: 5\nS0: [-N1 N1 N2 N3 N4]\na:  [-N1- -N2- N2 N3]\nS12: [-N2- N2] \n```", "```go\nfunc foo(s []int) int {\n    return s[0] + s[1] + s[2] + s[3]\n} \n```", "```go\nfunc bar(slice []int) int {\n    a := (*[**3**]int)(slice)\n    return a[0] + a[1] + a[2] + a[3]\n} \n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n    a1 := []int{1}\n    a2 := []int{-1, -2}\n    a5 := []int{10, 11, 12, 13, 14}\n    fmt.Println(\"a1\", a1)\n    fmt.Println(\"a2\", a2)\n    fmt.Println(\"a5\", a5)\n    // copy(destination, input)\n// len(a2) > len(a1)\ncopy(a1, a2)\n    fmt.Println(\"a1\", a1)\n    fmt.Println(\"a2\", a2) \n```", "```go\n // len(a5) > len(a1)\ncopy(a1, a5)\n    fmt.Println(\"a1\", a1)\n    fmt.Println(\"a5\", a5) \n```", "```go\n // len(a2) < len(a5) -> OK\ncopy(a5, a2)\n    fmt.Println(\"a2\", a2)\n    fmt.Println(\"a5\", a5)\n} \n```", "```go\n$ go run copySlice.go \na1 [1]\na2 [-1 -2]\na5 [10 11 12 13 14]\na1 [-1]\na2 [-1 -2] \n```", "```go\na1 [10]\na5 [10 11 12 13 14] \n```", "```go\na2 [-1 -2]\na5 [-1 -2 12 13 14] \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"sort\"\n)\nfunc main() {\n    sInts := []int{1, 0, 2, -3, 4, -20}\n    sFloats := []float64{1.0, 0.2, 0.22, -3, 4.1, -0.1}\n    sStrings := []string{\"aa\", \"a\", \"A\", \"Aa\", \"aab\", \"AAa\"}\n    fmt.Println(\"sInts original:\", sInts)\n    sort.Ints(sInts)\n    fmt.Println(\"sInts:\", sInts)\n    sort.Sort(sort.Reverse(sort.IntSlice(sInts)))\n    fmt.Println(\"Reverse:\", sInts) \n```", "```go\n fmt.Println(\"sFloats original:\", sFloats)\n    sort.Float64s(sFloats)\n    fmt.Println(\"sFloats:\", sFloats)\n    sort.Sort(sort.Reverse(sort.Float64Slice(sFloats)))\n    fmt.Println(\"Reverse:\", sFloats)\n    fmt.Println(\"sStrings original:\", sStrings)\n    sort.Strings(sStrings)\n    fmt.Println(\"sStrings:\", sStrings)\n    sort.Sort(sort.Reverse(sort.StringSlice(sStrings)))\n    fmt.Println(\"Reverse:\", sStrings)\n} \n```", "```go\n$ go run sortSlice.go\nsInts original: [1 0 2 -3 4 -20]\nsInts: [-20 -3 0 1 2 4]\nReverse: [4 2 1 0 -3 -20]\nsFloats original: [1 0.2 0.22 -3 4.1 -0.1]\nsFloats: [-3 -0.1 0.2 0.22 1 4.1]\nReverse: [4.1 1 0.22 0.2 -0.1 -3]\nsStrings original: [aa a A Aa aab AAa]\nsStrings: [A AAa Aa a aa aab]\nReverse: [aab aa a Aa AAa A] \n```", "```go\npackage main\nimport \"fmt\"\ntype aStructure struct {\n    field1 complex128\n    field2 int\n} \n```", "```go\nfunc processPointer(x *float64) {\n    *x = *x * *x\n} \n```", "```go\nfunc returnPointer(x float64) *float64 {\n    temp := 2 * x\n    return &temp\n} \n```", "```go\nfunc bothPointers(x *float64) *float64 {\n    temp := 2 * *x\n    return &temp\n} \n```", "```go\nfunc main() {\n    var f float64 = 12.123\n    fmt.Println(\"Memory address of f:\", &f) \n```", "```go\n // Pointer to f\n    fP := &f\n    fmt.Println(\"Memory address of f:\", fP)\n    fmt.Println(\"Value of f:\", *fP)\n    // The value of f changes\n    processPointer(fP)\n    fmt.Printf(\"Value of f: %.2f\\n\", f) \n```", "```go\n // The value of f does not change\n    x := returnPointer(f)\n    fmt.Printf(\"Value of x: %.2f\\n\", *x) \n```", "```go\n // The value of f does not change\n    xx := bothPointers(fP)\n    fmt.Printf(\"Value of xx: %.2f\\n\", *xx) \n```", "```go\n // Check for empty structure\nvar k *aStructure \n```", "```go\n // This is nil because currently k points to nowhere\n    fmt.Println(k)\n    // Therefore you are allowed to do this:\nif k == nil {\n        k = new(aStructure)\n    } \n```", "```go\n fmt.Printf(\"%+v\\n\", k)\n    if k != nil {\n        fmt.Println(\"k is not nil!\")\n    }\n} \n```", "```go\nMemory address of f: 0x140000180d8\nMemory address of f: 0x140000180d8\nValue of f: 12.123\nValue of f: 146.97\nValue of x: 293.93\nValue of xx: 293.93\n<nil>\n&{field1:(0+0i) field2:0}\nk is not nil! \n```", "```go\nfunc main() {\n    // Go 1.17 feature\n    slice := make([]byte, 3)\n    // Slice to array pointer\n    arrayPtr := (*[3]byte)(slice)\n    fmt.Println(\"Print array pointer:\", arrayPtr)\n    fmt.Printf(\"Data type: %T\\n\", arrayPtr)\n    fmt.Println(\"arrayPtr[0]:\", arrayPtr[0]) \n```", "```go\n // Go 1.20 feature\n    slice2 := []int{-1, -2, -3}\n    // Slice to array\n    array := **[****3****]****int****(slice2)**\n    fmt.Println(\"Print array contents:\", array)\n    fmt.Printf(\"Data type: %T\\n\", array)\n} \n```", "```go\n$ go run slice2array.go\nPrint array pointer: &[0 0 0]\nData type: *[3]uint8\narrayPtr[0]: 0\nPrint array contents: [-1 -2 -3]\nData type: [3]int \n```", "```go\nfunc byteToString(bStr []byte) string {\n    if len(bStr) == 0 {\n        return \"\"\n    }\n    return **unsafe.String(unsafe.SliceData(bStr),** **len****(bStr))**\n}\nfunc stringToByte(str string) []byte {\n    if str == \"\" {\n        return nil\n    }\n    return **unsafe.Slice(unsafe.StringData(str),** **len****(str))**\n} \n```", "```go\nfunc main() {\n    str := \"Go!\"\n    d := **unsafe.StringData(str)**\n    b := **unsafe.Slice(d,** **len****(str))**\n// byte is an alias for uint8\n    fmt.Printf(\"Type %T contains %s\\n\", b, b)\n    sData := []int{10, 20, 30, 40}\n    // Get the memory address of sData\n    fmt.Println(\"Pointer:\", unsafe.SliceData(sData)) \n```", "```go\n // String to Byte slice\nvar hi string = \"Mastering Go, 4th edition!\"\n    myByteSlice := stringToByte(hi)\n    fmt.Printf(\"myByteSlice type: %T\\n\", myByteSlice)\n    // Byte slice to string\n    myStr := byteToString(myByteSlice)\n    fmt.Printf(\"myStr type: %T\\n\", myStr)\n} \n```", "```go\n$ go run typeUnsafe.go\nType []uint8 contains Go!\nPointer: 0x1400001e0c0\nmyByteSlice type: []uint8\nmyStr type: string \n```", "```go\nfunc random(min, max int) int {\n    return rand.Intn(max-min) + min\n} \n```", "```go\n$ go run randomNumbers.go \nUsing default values!\n39 75 78 89 39 28 37 96 93 42 60 69 50 9 69 27 22 63 4 68 56 23 54 14 93 61 19 13 83 72 87 29 4 45 75 53 41 76 84 51 62 68 37 11 83 20 63 58 12 50 8 31 14 87 13 97 17 60 51 56 21 68 32 41 79 13 79 59 95 56 24 83 53 62 97 88 67 59 49 65 79 10 51 73 48 58 48 27 30 88 19 16 16 11 35 45 72 51 41 28 \n```", "```go\n$ go run randomNumbers.go 1 5 10 10\n3 1 4 4 1 1 4 4 4 3\n$ go run randomNumbers.go 1 5 10 10\n3 1 4 4 1 1 4 4 4 3\n$ go run randomNumbers.go 1 5 10 11\n1 4 2 1 3 2 2 4 1 3 \n```", "```go\nfunc getString(len int64) string {\n    temp := \"\"\n    startChar := \"!\"\nvar i int64 = 1\nfor {\n        myRand := random(MIN, MAX)\n        newChar := string(startChar[0] + byte(myRand))\n        temp = temp + newChar\n        if i == len {\n            break\n        }\n        i++\n    }\n    return temp\n} \n```", "```go\n$ go run genPass.go\nUsing default values...\n!QrNq@;R\n$ go run genPass.go 20\nsZL>{F~\"hQqY>r_>TX?O \n```", "```go\nfunc generateBytes(n int64) ([]byte, error) {\n    b := make([]byte, n)\n    _, err := rand.Read(b)\n    if err != nil {\n        return nil, err\n    }\n    return b, nil\n} \n```", "```go\n$ go run cryptoRand.go   \nUsing default values!\nCe30g--D\n$ go run cryptoRand.go 20\nAEIePSYb13KwkDnO5Xk_ \n```", "```go\nfunc normalize(data []float64, mean float64, stdDev float64) []float64 {\nif stdDev == 0 {\n    return data\n}\nnormalized := make([]float64, len(data))\nfor i, val := range data {\n    normalized[i] = **math.Floor((val-mean)/stdDev*****10000****) /** **10000**\n}\nreturn normalized\n} \n```", "```go\nfunc randomFloat(min, max float64) float64 {\n    return min + rand.Float64()*(max-min)\n} \n```", "```go\n$ go run stats.go 3 5 5 8 9 12 12 13 15 16 17 19 22 24 25 134\nNumber of values: 16\nMin: 3\nMax: 134\nMean value: 21.18750\nStandard deviation: 29.84380\nNormalized: [-0.6095 -0.5425 -0.5425 -0.4419 -0.4084 -0.3079 -0.3079 -0.2744 -0.2074 -0.1739 -0.1404 -0.0733 0.0272 0.0942 0.1277 3.78] \n```"]