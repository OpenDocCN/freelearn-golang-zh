- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Basic Go Data Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基礎 Go 數據類型
- en: Data is stored and manipulated in variables—all Go variables should have a data
    type that is either determined implicitly or declared explicitly. Knowing the
    built-in data types of Go allows you to understand how to manipulate simple data
    values and construct more complex data structures when simple data types are not
    enough or not efficient for a job. **Go being a statically typed and compiled
    programming language** allows the compiler to perform various optimizations and
    checks prior to program execution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 數據存儲和操作在變數中——所有 Go 語言的變數都應該有一個數據類型，這個數據類型是顯式聲明或隱式確定的。了解 Go 的內置數據類型可以讓你理解如何操作簡單的數據值，並在簡單數據類型不足以或不高效於某項任務時構建更複雜的數據結構。**Go
    作為一種靜態類型和編譯的編程語言**，允許編譯器在程序執行前進行各種優化和檢查。
- en: The first part of this chapter is all about the basic data types of Go, and
    the second part logically follows, covering the data structures that allow you
    to group data of the same data type, which are arrays and the much more powerful
    slices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分全部关于 Go 语言的基礎數據類型，第二部分則合乎邏輯地接續，涵蓋了允許你將同種數據類型的數據分組的數據結構，這些是數組和功能更強大的切片。
- en: 'But let us begin with something more practical: imagine that you want to read
    data as command line arguments. How can you be sure that what you have read was
    what you expected? How can you handle error situations? What about reading not
    just numbers and strings but dates and times from the command line? Do you have
    to write your own parser for working with dates and times?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但讓我們從一些更實際的內容開始：想像一下你想讀取命令行參數中的數據。你如何確保你讀取的是你期望的內容？你如何處理錯誤情況？那麼，只讀取數字和字符串，而不是從命令行讀取日期和時間呢？你是否需要為處理日期和時間而編寫自己的解析器？
- en: 'In *Chapter 1*, *A Quick Introduction to Go*, we included the entire code of
    the presented source files. However, starting from this chapter, this will not
    always be the case. This serves two purposes: the first one is that you get to
    see the code that really matters, and the second one is that we save book space.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第一章*，*Go 快速入門* 中，我們包含了所展示的源文件的完整代碼。然而，從本章開始，這不總是這樣。這有兩個目的：第一個是讓你看到真正重要的代碼，第二個是為了節省書籍空間。
- en: 'This chapter will answer all these questions and many more, such as working
    with the `unsafe` package, the internals of slices and how slices are connected
    to arrays, and how to work with pointers in Go. Additionally, it implements utilities
    that generate random numbers and random strings and updates the statistics application.
    So, this chapter covers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章將回答所有這些問題以及許多其他問題，例如使用 `unsafe` 包、切片的內部結構以及切片如何與數組相關聯，以及如何在 Go 中使用指針。此外，它還實現了生成隨機數字和隨機字符串的公用程序，並更新統計應用程序。因此，本章涵蓋了：
- en: The `error` data type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 錯誤數據類型
- en: Numeric data types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 數字數據類型
- en: Non-numeric data types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非數字數據類型
- en: Constants
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量
- en: Grouping similar data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 將相似數據分組
- en: Pointers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指針
- en: Data types and the `unsafe` package
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 數據類型和 `unsafe` 包
- en: Generating random numbers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Updating the statistics application
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新統計應用程序
- en: We begin this chapter with the `error` data type because errors and error handling
    play a key role in Go.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我們以 `error` 數據類型開始本章，因為錯誤和錯誤處理在 Go 裡扮演著關鍵的角色。
- en: The error data type
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 錯誤數據類型
- en: Go provides a special data type, named `error`, for representing error conditions
    and error messages—in practice, this means that Go treats errors as values. **To
    program successfully in Go, you should be aware of the error conditions that might
    occur with the functions and methods you are using and handle them accordingly**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一種特殊的數據類型，稱為 `error`，用於表示錯誤條件和錯誤信息——實際上，這意味著 Go 將錯誤視為值。**要在 Go 中成功編程，你應該了解可能發生在您所使用的函數和方法中的錯誤條件，並相應地處理它們**。
- en: 'As you already know from the previous chapter, Go follows a particular convention
    concerning error values: if the value of an `error` variable is `nil`, then there
    is no error. As an example, let us consider `strconv.Atoi()`, which is used for
    converting a `string` value into an `int` value (`Atoi` stands for *ASCII to Int*).
    As specified by its signature, `strconv.Atoi()` returns `(int, error)`. Having
    an error value of `nil` means that the conversion was successful and that you
    can use the `int` value if you want. Having an error value that is not `nil` means
    that the conversion was unsuccessful and that the string input is not a valid
    `int` value.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Go遵循有关错误值的特定约定：如果一个`error`变量的值为`nil`，则表示没有错误。作为一个例子，让我们考虑`strconv.Atoi()`，它用于将`string`值转换为`int`值（`Atoi`代表*ASCII
    to Int*）。根据其签名，`strconv.Atoi()`返回`(int, error)`。具有`nil`错误值的表示转换成功，并且如果你想使用，你可以使用`int`值。具有非`nil`错误值的表示转换失败，并且字符串输入不是一个有效的`int`值。
- en: If you want to learn more about `strconv.Atoi()`, you should execute `go doc
    strconv.Atoi` in your terminal window.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`strconv.Atoi()`的信息，你应该在你的终端窗口中执行`go doc strconv.Atoi`。
- en: You might wonder what happens if you want to create your own error messages.
    Is this possible? Should you wish to return a custom error, you can use `errors.New()`
    from the `errors` package. This usually happens inside a function other than `main()`
    because `main()` does not return anything to any other function. Additionally,
    a good place to define your custom errors is inside the Go packages you create.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果你想要创建自己的错误信息会发生什么。这是可能的吗？如果你想返回一个自定义的错误，你可以使用`errors.New()`函数，它来自`errors`包。这种情况通常发生在`main()`函数之外的函数中，因为`main()`函数不向任何其他函数返回任何内容。此外，定义你自定义错误的好地方是在你创建的Go包内部。
- en: You will most likely work with errors in your programs without needing the functionality
    of the `errors` package. Additionally, **you are not going to need to define custom
    error messages unless you are creating big applications or packages**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能会在你的程序中处理错误，而不需要`errors`包的功能。此外，**除非你正在创建大型应用程序或包，否则你不需要定义自定义错误信息**。
- en: If you want to format your error messages in the way `fmt.Printf()` works, you
    can use the `fmt.Errorf()` function, which simplifies the creation of custom error
    messages—the `fmt.Errorf()` function returns an `error` value just like `errors.New()`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以`fmt.Printf()`工作的方式格式化错误信息，你可以使用`fmt.Errorf()`函数，它简化了自定义错误信息的创建——`fmt.Errorf()`函数返回一个`error`值，就像`errors.New()`一样。
- en: 'Now, we should talk about something important: you should have a global error-handling
    tactic in each application that should not change. In practice, this means the
    following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该谈谈一些重要的事情：你应该在每个应用程序中有一个全局的错误处理策略，这个策略不应该改变。在实践中，这意味着以下内容：
- en: All error messages should be handled at the same level, which means that all
    errors should either be returned to the calling function or be handled at the
    place they occurred.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有错误信息都应该在同一级别处理，这意味着所有错误要么应该返回给调用函数，要么在它们发生的地方处理。
- en: The handling of critical errors should be clearly documented. This means that
    there will be situations where a critical error should terminate the program and
    other times where a critical error might just create a warning message onscreen
    and continue.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临界错误的处理应该有明确的文档。这意味着在某些情况下，临界错误应该终止程序，而在其他情况下，临界错误可能只是在屏幕上创建一个警告消息并继续。
- en: It is considered a good practice to send all error messages to the log service
    of your machine because this way the error messages can be examined later. However,
    this is not always true, so exercise caution when setting this up—for example,
    cloud-native apps do not work that way. For cloud-native apps it is better to
    send the error output to standard error so that the error messages do not get
    lost.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被认为是一种好的做法，将所有错误信息发送到机器的日志服务，因为这样可以在以后检查错误信息。然而，这并不总是正确的，因此在设置时请谨慎——例如，云原生应用程序就不是这样工作的。对于云原生应用程序，最好将错误输出发送到标准错误，这样错误信息就不会丢失。
- en: The `error` data type is defined as an interface—interfaces are covered in *Chapter
    5*, *Reflection and Interfaces*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`数据类型被定义为接口——接口将在*第五章*，*反射和接口*中介绍。'
- en: Type the following code in your favorite text editor and save it as `error.go`
    in the directory where you put the code for this chapter. Using `ch02` as the
    directory name is a good idea.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在你最喜欢的文本编辑器中输入以下代码，并将其保存为`error.go`，放在你放置本章代码的目录中。使用`ch02`作为目录名是个好主意。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first part is the preamble of the program—`error.go` uses the `fmt`, `os`,
    `strconv`, and `errors` packages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是程序的序言部分——`error.go` 使用了 `fmt`、`os`、`strconv` 和 `errors` 包。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code implements a function named `check()` that returns an `error`
    value. If both input parameters of `check()` are equal to `0`, the function returns
    a custom error message using `errors.New()`—otherwise it returns `nil`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实现了一个名为 `check()` 的函数，该函数返回一个 `error` 值。如果 `check()` 的两个输入参数都等于 `0`，则该函数使用
    `errors.New()` 返回一个自定义错误信息；否则它返回 `nil`。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code implements `formattedError()`, which is a function that returns
    a formatted error message using `fmt.Errorf()`. Among other things, the error
    message prints the user ID of the user who executed the program with a call to
    `os.Getuid()`. When you want to create a custom error message, using `fmt.Errorf()`
    gives you more control over the output.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实现了 `formattedError()` 函数，该函数使用 `fmt.Errorf()` 返回一个格式化的错误信息。除此之外，错误信息通过调用
    `os.Getuid()` 打印出执行程序的用户的用户 ID。当你想要创建一个自定义错误信息时，使用 `fmt.Errorf()` 可以让你对输出有更多的控制。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code is the implementation of the `main()` function where you
    can see the use of the `if err != nil` statement multiple times as well as the
    use of `if err == nil`, which is used to make sure that everything was OK before
    executing the desired code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是 `main()` 函数的实现，你可以看到多次使用 `if err != nil` 语句以及使用 `if err == nil`，后者用于确保在执行所需代码之前一切正常。
- en: Bear in mind that although the preceding code compares an error message, this
    is considered a bad practice. It is better to print an error message when it is
    not `nil`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管前面的代码比较了一个错误信息，但这被认为是一种不好的做法。更好的做法是在不是 `nil` 的情况下打印错误信息。
- en: 'Running `error.go` produces the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `error.go` 产生以下输出：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that you know about the `error` data type, how to create custom errors,
    and how to use error values, we will continue with the basic data types of Go
    that can be logically divided into two main categories: *numeric data types* and
    *non-numeric data types*. Go also supports the `bool` data type, which can have
    a value of `true` or `false` only.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 `error` 数据类型、如何创建自定义错误以及如何使用错误值，我们将继续介绍 Go 的基本数据类型，这些数据类型可以逻辑上分为两大类：*数值数据类型*
    和 *非数值数据类型*。Go 还支持 `bool` 数据类型，它只能有 `true` 或 `false` 两个值。
- en: Numeric data types
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值数据类型
- en: Go supports integer, floating-point, and complex number values in various versions
    depending on the memory space they consume—this saves memory and computing time.
    Integer data types can be either signed or unsigned, which is not the case for
    floating-point numbers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Go 根据它们消耗的内存空间支持整数、浮点数和复数值，具体版本各异——这有助于节省内存和计算时间。整数数据类型可以是带符号的或无符号的，而浮点数则不是这样。
- en: The table that follows lists the numeric data types of Go.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 Go 的数值数据类型。
- en: '| **Data Type** | **Description** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **描述** |'
- en: '| `int8` | 8-bit signed integer |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `int8` | 8 位带符号整数 |'
- en: '| `int16` | 16-bit signed integer |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | 16 位带符号整数 |'
- en: '| `int32` | 32-bit signed integer |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | 32 位带符号整数 |'
- en: '| `int64` | 64-bit signed integer |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | 64 位带符号整数 |'
- en: '| `int` | 32- or 64-bit signed integer |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 32 位或 64 位带符号整数 |'
- en: '| `uint8` | 8-bit unsigned integer |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `uint8` | 8 位无符号整数 |'
- en: '| `uint16` | 16-bit unsigned integer |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | 16 位无符号整数 |'
- en: '| `uint32` | 32-bit unsigned integer |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | 32 位无符号整数 |'
- en: '| `uint64` | 64-bit unsigned integer |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | 64 位无符号整数 |'
- en: '| `uint` | 32- or 64-bit unsigned integer |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | 32 位或 64 位无符号整数 |'
- en: '| `float32` | 32-bit floating-point number |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | 32 位浮点数 |'
- en: '| `float64` | 64-bit floating-point number |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | 64 位浮点数 |'
- en: '| `complex64` | Complex number with `float32` parts |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` | 带有 `float32` 部分的复数 |'
- en: '| `complex128` | Complex number with `float64` parts |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `complex128` | 带有 `float64` 部分的复数 |'
- en: The `int` and `uint` data types are special as they are the most efficient sizes
    for signed and unsigned integers on a given platform and can be either 32 or 64
    bits each — their size is defined by Go itself based on the CPU register size.
    The `int` data type is the most widely used numeric data type in Go due to its
    versatility.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 和 `uint` 数据类型是特殊的，因为它们是在给定平台上带符号和无符号整数最有效的尺寸，每个可以是 32 或 64 位——它们的大小由
    Go 根据CPU寄存器大小自行定义。`int` 数据类型是 Go 中最广泛使用的数值数据类型，因为它具有多功能性。'
- en: 'The code that follows illustrates the use of numeric data types—you can find
    the entire program as `numbers.go` inside the `ch02` directory of the book GitHub
    repository:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了数字数据类型的使用——你可以在书籍GitHub仓库的`ch02`目录中的`numbers.go`文件中找到整个程序：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code creates two complex variables in two different ways—both
    ways are perfectly valid and equivalent. Unless you are into mathematics, you
    will most likely not use complex numbers in your programs. However, the direct
    support for complex numbers shows how modern Go is.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码以两种不同的方式创建了两个复数变量——这两种方式都是完全有效且等效的。除非你对数学感兴趣，否则你很可能不会在你的程序中使用复数。然而，对复数的直接支持展示了现代Go语言的特点。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code continues to work with complex numbers by adding and subtracting
    two pairs of them. Although `cZero` is equal to zero, it is still a complex number
    and a `complex64` variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码通过添加和减去两个复数对继续使用复数。尽管`cZero`等于零，但它仍然是一个复数和一个`complex64`变量。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this part, we define two integer variables named `x` and `k`—their data
    type is identified by Go based on their initial values. Both are of type `int`,
    which is what Go prefers to use for storing integer values. Additionally, when
    you divide two integer values, you get an integer result even when the division
    is not perfect. Therefore, if this is not what you want, you should take extra
    actions—this is shown in the next code excerpt:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们定义了两个名为`x`和`k`的整数变量——它们的数据类型由Go根据它们的初始值确定。两者都是`int`类型，这是Go首选用于存储整数值的类型。此外，当你除以两个整数值时，即使除法不是完美的，你也会得到一个整数值。因此，如果你不希望这样，你应该采取额外的措施——这将在下一段代码示例中展示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code works with `float64` values and variables. As `n` does not
    have an initial value, it is automatically assigned with the zero value of its
    data type, which is `0` for the `float64` data type. Additionally, the code presents
    a technique for dividing integer values and getting a floating-point result, which
    is the use of `float64()`: `divFloat := float64(x) / float64(k)`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用`float64`值和变量进行操作。由于`n`没有初始值，它自动被分配了其数据类型的零值，对于`float64`数据类型来说，这个值是`0`。此外，代码展示了一种将整数值除以得到浮点结果的技术，这就是使用`float64()`：`divFloat
    := float64(x) / float64(k)`。
- en: This is a type conversion where two integers (`x` and `k`) are converted to
    `float64` values. As the division between two `float64` values is a `float64`
    value, we get the result in the desired data type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类型转换，其中两个整数（`x`和`k`）被转换为`float64`值。由于两个`float64`值之间的除法结果是`float64`值，所以我们得到了所需的数据类型的结果。
- en: 'Running `numbers.go` creates the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`numbers.go`会生成以下输出：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output shows that both `c1` and `c2` are `complex128` values, which is the
    preferred complex data type for the machine on which the code was executed. However,
    `c3` is a `complex64` value because it was created using `complex64()`. The value
    of `n` is `0` because the `n` variable was not initialized, which means that Go
    automatically assigned the zero value of its data type to `n`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，`c1`和`c2`都是`complex128`类型的值，这是在执行代码的机器上首选的复数数据类型。然而，`c3`是一个`complex64`类型的值，因为它使用了`complex64()`创建。`n`的值是`0`，因为`n`变量没有被初始化，这意味着Go自动将其数据类型的零值分配给了`n`。
- en: Avoiding overflows
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免溢出
- en: As each variable is stored in memory (bits), there is a limit to how much information
    we can store in the memory space of a variable. Although in this subsection we
    are going to talk about integers, similar rules apply to all numeric data types.
    Go comes with constants in the `math` package that represent the maximum and minimum
    values of integer data types. For example, for the `int` data type, there exist
    the `math.MaxInt` and `math.MinInt` constants that represent the maximum and minimum
    allowed values of an `int` variable, respectively.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个变量都存储在内存（位）中，因此我们对变量内存空间中可以存储的信息量有一个限制。尽管在这个小节中我们将讨论整数，但类似的规则适用于所有数字数据类型。Go语言在`math`包中提供了代表整数数据类型最大和最小值的常量。例如，对于`int`数据类型，存在`math.MaxInt`和`math.MinInt`常量，分别代表`int`变量的最大和最小允许值。
- en: 'The important part of `overflows.go` can be found in two `for` loops. The first
    one concerns determining the maximum `int` value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`overflows.go`中的重要部分可以在两个`for`循环中找到。第一个循环是关于确定最大`int`值：'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we keep increasing the value of `i` until it reaches
    `math.MaxInt`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们不断增加`i`的值，直到它达到`math.MaxInt`。
- en: 'The next `for` loop is about finding out the minimum `int` value:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`for`循环是关于找出最小`int`值：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time, we keep decreasing the value of `i` until it reaches `math.MinInt`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不断减小 `i` 的值，直到它达到 `math.MinInt`。
- en: 'Running `overflows.go` produces the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `overflows.go` 产生以下输出：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Therefore, the maximum `int` value on the current platform (MacBook Pro with
    M1 Max CPU) is `9223372036854775807` and the minimum `int` value is `-9223372036854775808`.
    When we try to increase the maximum `int` value, we will get the minimum `int`
    value instead!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当前平台（配备 M1 Max CPU 的 MacBook Pro）上的最大 `int` 值是 `9223372036854775807`，最小 `int`
    值是 `-9223372036854775808`。当我们尝试增加最大 `int` 值时，我们将会得到最小 `int` 值！
- en: After learning about numeric data types, it is time to learn about non-numeric
    data types, which is the subject of the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了数值数据类型之后，现在是时候学习非数值数据类型了，这是下一节的主题。
- en: Non-numeric data types
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非数值数据类型
- en: Go has support for strings, characters, runes, dates, and times. However, Go
    does not have a dedicated char data type. In Go, dates and times are the same
    thing and are represented by the same data type. However, it is up to you to determine
    whether a time and date variable contains valid information or not.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持字符串、字符、`rune`、日期和时间。但是，Go 没有专门的 `char` 数据类型。在 Go 中，日期和时间是同一回事，由相同的数据类型表示。然而，是否一个时间和日期变量包含有效信息取决于你。
- en: We begin by explaining the string-related data types.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先解释与字符串相关的数据类型。
- en: Strings, characters, and runes
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串、字符和 `rune`
- en: Go supports the `string` data type for representing strings—strings are enclosed
    within either double quotes or back quotes. A Go string is just *a collection
    of bytes* and can be accessed as a whole or as an array. A single byte can store
    any ASCII character—however, **multiple bytes are usually needed for storing a
    single Unicode character**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持使用 `string` 数据类型来表示字符串——字符串被双引号或反引号包围。Go 字符串只是一个 *字节的集合*，可以作为一个整体或数组来访问。单个字节可以存储任何
    ASCII 字符——然而，**通常需要多个字节来存储单个 Unicode 字符**。
- en: Nowadays, supporting Unicode characters is a common requirement—Go was designed
    with Unicode support in mind, which is the main reason for having the `rune` data
    type. A `rune` is an `int32` value that is used for representing a single Unicode
    code point, which is an integer value that is used for representing single Unicode
    characters or, less frequently, providing formatting information.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，支持 Unicode 字符是一个常见的要求——Go 的设计考虑到了 Unicode 支持，这也是为什么有 `rune` 数据类型的原因。`rune`
    是一个 `int32` 类型的值，用于表示单个 Unicode 代码点，这是一个用于表示单个 Unicode 字符或，较少情况下，提供格式化信息的整数值。
- en: Although a `rune` is an `int32` value, you cannot compare a `rune` with an `int32`
    value. Go considers these two data types as totally different.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `rune` 是一个 `int32` 类型的值，但你不能将 `rune` 与 `int32` 类型的值进行比较。Go 将这两种数据类型视为完全不同。
- en: You can create a new *byte slice* from a given string by using a `[]byte("A
    String")` statement. Given a byte slice variable `b`, you can convert it into
    a string using the `string(b)` statement. **When working with byte slices that
    contain Unicode characters, the number of bytes in a byte slice is not always
    connected to the number of characters in the byte slice, because most Unicode
    characters require more than one byte for their representation**. As a result,
    when you try to print each single byte of a byte slice using `fmt.Println()` or
    `fmt.Print()`, the output is not text presented as characters but instead integer
    values. If you want to print the contents of a byte slice as text, you should
    either print it using `string(byteSliceVar)` or using `fmt.Printf()` with `%s`
    to tell `fmt.Printf()` that you want to print a string. You can initialize a new
    byte slice with the desired string by using a statement such as `[]byte("My Initialization
    String")`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `[]byte("A String")` 语句从一个给定的字符串创建一个新的 *字节切片*。给定一个字节切片变量 `b`，你可以使用 `string(b)`
    语句将其转换为字符串。**当处理包含 Unicode 字符的字节切片时，字节切片中的字节数并不总是与字节切片中的字符数相对应，因为大多数 Unicode 字符需要多个字节来表示**。因此，当你尝试使用
    `fmt.Println()` 或 `fmt.Print()` 打印字节切片的每个单独字节时，输出不是以字符形式呈现的文本，而是整数值。如果你想以文本形式打印字节切片的内容，你应该使用
    `string(byteSliceVar)` 或使用 `fmt.Printf()` 并带有 `%s` 来告诉 `fmt.Printf()` 你想打印一个字符串。你可以使用类似于
    `[]byte("My Initialization String")` 的语句来初始化一个新的字节切片。
- en: We will cover byte slices in more detail in the *Byte slices* section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *字节切片* 部分更详细地介绍字节切片。
- en: 'You can define a rune using single quotes: `r := ''€''` and you can print the
    integer value of the bytes that compose it as `fmt.Println(r)`—in this case, the
    integer value is `8364`. Printing it as a single Unicode character requires the
    use of the `%c` control string in `fmt.Printf()`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用单引号定义一个 rune：`r := '€'`，并且你可以打印组成它的字节的整数值，作为 `fmt.Println(r)`——在这种情况下，整数值是
    `8364`。将其打印为单个 Unicode 字符需要使用 `fmt.Printf()` 中的 `%c` 控制字符串。
- en: As strings can be accessed as arrays, you can iterate over the runes of the
    string using a `for` loop or point to a specific character if you know its place
    in the string. The length of the string is the same as the number of characters
    found in the string, which is usually not true for byte slices because Unicode
    characters usually require more than one byte.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串可以作为数组访问，你可以使用 `for` 循环遍历字符串中的 runes，或者如果你知道它在字符串中的位置，可以指向特定的字符。字符串的长度与字符串中找到的字符数相同，这对于字节切片通常不成立，因为
    Unicode 字符通常需要多个字节。
- en: The following Go code illustrates the use of strings and runes and how you can
    work with strings in your code. You can find the entire program as `text.go` in
    the `ch02` directory of the GitHub repository of the book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Go 代码说明了字符串和 runes 的使用以及如何在你的代码中处理字符串。你可以在本书 GitHub 仓库的 `ch02` 目录中找到整个程序作为
    `text.go`。
- en: 'The first part of the program defines a string literal that contains a Unicode
    character. Then it accesses its first byte as if the string were an array:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分定义了一个包含 Unicode 字符的字符串字面量。然后它像数组一样访问其第一个字节：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next part is about working with runes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是关于处理 runes：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we define a rune named `r`. What makes this a rune is the use of single
    quotes around the `€` character. The rune is an `int32` value and is printed as
    such by `fmt.Println()`. The `%c` control string in `fmt.Printf()` prints a rune
    as a character. Then we iterate over `aString` as a slice or an array using a
    `for` loop with `range` and print the contents of `aString` as runes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为 `r` 的 rune。使它成为 rune 的是 `€` 字符周围的单引号。rune 是一个 `int32` 值，并且由 `fmt.Println()`
    以这种方式打印出来。`fmt.Printf()` 中的 `%c` 控制字符串将 rune 打印为字符。然后我们使用带有 `range` 的 `for` 循环将
    `aString` 作为切片或数组迭代，并打印 `aString` 的内容作为 runes。
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Lastly, we iterate over `aString` as a slice or an array using a `for` loop
    with `range` and print the contents of `aString` as characters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用带有 `range` 的 `for` 循环将 `aString` 作为切片或数组迭代，并打印 `aString` 的内容作为字符。
- en: 'Running `text.go` produces the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `text.go` 产生以下输出：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line of the output shows that we can access a string as an array whereas
    the second line verifies that a rune is an integer value. The third line shows
    what to expect when you print a rune as a string and as a character—the correct
    way is to print it as a character. The fifth line shows how to print a string
    as runes and the last line shows the output of processing a string as characters
    using range and a for loop.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行显示我们可以将字符串作为数组访问，而第二行验证 rune 是一个整数值。第三行显示当你将 rune 作为字符串和字符打印时应该期待什么——正确的方式是将其作为字符打印。第五行显示如何将字符串作为
    runes 打印，最后一行显示使用 `range` 和 `for` 循环将字符串作为字符处理时的输出。
- en: Converting int to string
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 int 转换为字符串
- en: 'You can convert an integer value into a string in two main ways: using `string()`
    and using a function from the `strconv` package. However, the two methods are
    fundamentally different. The `string()` function converts an integer value into
    a Unicode code point, which is a single character, whereas functions such as `strconv.FormatInt()`
    and `strconv.Itoa()` convert an integer value into a string value with the same
    representation and the same number of characters.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将整数值转换为字符串的两种主要方式：使用 `string()` 和使用 `strconv` 包中的函数。然而，这两种方法在本质上是有区别的。`string()`
    函数将整数值转换为 Unicode 码点，这是一个单独的字符，而像 `strconv.FormatInt()` 和 `strconv.Itoa()` 这样的函数将整数值转换为具有相同表示和相同字符数的字符串值。
- en: This is illustrated in the `intString.go` program—its most important statements
    are the following. You can find the entire program in the GitHub repository of
    the book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `intString.go` 程序中得到了说明——其最重要的语句如下。你可以在本书的 GitHub 仓库中找到整个程序。
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running `intString.go` generates the following kind of output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `intString.go` 生成以下类型的输出：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The data type of the output is always string, however, `string()` converted
    `100` into `d` because the ASCII representation of `d` is `100`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出数据类型始终是字符串，然而，`string()` 将 `100` 转换为 `d`，因为 `d` 的 ASCII 表示是 `100`。
- en: Now that we have looked at converting integers into strings, it is time to learn
    how to work with Unicode text and code points.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何将整数转换为字符串，现在是时候学习如何处理Unicode文本和代码点了。
- en: The unicode package
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unicode包
- en: The `unicode` standard Go package contains various handy functions for working
    with Unicode code points. One of them, which is called `unicode.IsPrint()`, can
    help you to identify the parts of a string that are printable using runes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`unicode`标准Go包包含各种方便的函数，用于处理Unicode代码点。其中之一，称为`unicode.IsPrint()`，可以帮助你识别字符串中可打印的部分。'
- en: 'The following code excerpt illustrates the functionality of the `unicode` package:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码摘录展示了`unicode`包的功能：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The for loop iterates over the contents of a string defined as a list of runes
    (`"\x99\x00ab\x50\x00\x23\x50\x29\x9c"`) while `unicode.IsPrint()` examines whether
    the character is printable or not—if it returns `true` then a rune is printable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: for循环遍历一个定义为runes列表的字符串（`"\x99\x00ab\x50\x00\x23\x50\x29\x9c"`）的内容，同时`unicode.IsPrint()`检查字符是否可打印——如果它返回`true`，则rune是可打印的。
- en: 'You can find this code excerpt inside the `unicode.go` source file in the `ch02`
    directory in the GitHub repository of the book. Running `unicode.go` produces
    the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书的GitHub仓库中`ch02`目录下的`unicode.go`源文件中找到这段代码摘录。运行`unicode.go`会产生以下输出：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This utility is very handy for filtering input or filtering data before printing
    it on screen, storing it in log files, transferring it on a network, or storing
    it in a database.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用工具在过滤输入或过滤数据以便在屏幕上打印、存储在日志文件中、在网络中传输或存储在数据库中时非常方便。
- en: In the next subsection, we continue working with text with the help of the `strings`
    package.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将借助`strings`包继续处理文本。
- en: The strings package
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Strings包
- en: The `strings` standard Go package allows you to manipulate UTF-8 strings in
    Go and includes many powerful functions. Many of these functions are illustrated
    in the `useStrings.go` source file, which can be found in the `ch02` directory
    of the book GitHub repository.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings`标准Go包允许你在Go中操作UTF-8字符串，并包含许多强大的函数。其中许多函数在`useStrings.go`源文件中有展示，该文件位于书的GitHub仓库的`ch02`目录中。'
- en: If you are working with text and text processing, you need to learn all the
    details and functions of the `strings` package, so make sure that you experiment
    with all these functions and create many examples that will help you to clarify
    things.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理文本和文本处理，你需要学习`strings`包的所有细节和函数，所以请确保你尝试所有这些函数，并创建许多示例来帮助你澄清问题。
- en: 'The most important parts of `useStrings.go` are the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`useStrings.go`文件最重要的部分如下：'
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we are going to use the `strings` package multiple times, we create a convenient
    alias for it named `s` – note that this is considered a bad practice and that
    we are just doing that here to prevent the lines from getting too long. We do
    the same for the `fmt.Printf()` function where we create a global alias using
    a variable named `f`. These two shortcuts reduce the amount of long, repeated
    lines of code. You can use them when learning Go, but this is not recommended
    in any kind of production software as it makes the code less readable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将会多次使用`strings`包，我们创建了一个方便的别名`s`——请注意，这被认为是一种不好的做法，我们在这里这样做是为了防止代码行太长。我们对`fmt.Printf()`函数也做了同样的事情，创建了一个全局别名，使用变量`f`。这两个快捷方式减少了长代码行的重复。你可以在学习Go时使用它们，但在任何类型的生产软件中都不推荐这样做，因为它会使代码的可读性降低。
- en: 'The first code excerpt is the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码摘录如下：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `strings.EqualFold()` function compares two strings without considering
    their case and returns true when they are the same and false otherwise.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.EqualFold()`函数在不考虑字符串大小写的情况下比较两个字符串，当它们相同返回true，否则返回false。'
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `strings.Index()` function checks whether the string of the second parameter
    can be found in the string that is given as the first parameter and returns the
    index where it was found for the first time. On an unsuccessful search, it returns
    `-1`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.Index()`函数检查第二个参数的字符串是否可以在第一个参数指定的字符串中找到，并返回第一次找到的位置索引。如果搜索失败，则返回`-1`。'
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `strings.HasPrefix()` function checks whether the given string, which is
    the first parameter, begins with the string that is given as the second parameter.
    In the preceding code, the first call to `strings.HasPrefix()` returns true, whereas
    the second returns false. Similarly, `strings.HasSuffix()` checks whether the
    given string ends with the second string. Both functions consider the case of
    the input string and the case of the second parameter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.HasPrefix()` 函数检查给定的字符串（第一个参数）是否以第二个参数中给出的字符串开头。在前面的代码中，`strings.HasPrefix()`
    的第一次调用返回 true，而第二次返回 false。同样，`strings.HasSuffix()` 检查给定的字符串是否以第二个字符串结尾。这两个函数都考虑了输入字符串和第二个参数的大小写。'
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The handy `strings.Fields()` function splits the given string around one or
    more whitespace characters as defined by the `unicode.IsSpace()` function and
    returns a slice of substrings found in the input string. If the input string contains
    whitespace characters only, it returns an empty slice.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的 `strings.Fields()` 函数根据 `unicode.IsSpace()` 函数定义的一个或多个空白字符将给定的字符串分割开，并返回在输入字符串中找到的子字符串切片。如果输入字符串只包含空白字符，则返回空切片。
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `strings.Split()` function allows you to split the given string according
    to the desired separator string—the `strings.Split()` function returns a string
    slice. Using `""` as the second parameter of `strings.Split()` allows you to *process
    a string character by character*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.Split()` 函数允许你根据所需的分隔符字符串分割给定的字符串——`strings.Split()` 函数返回一个字符串切片。使用
    `""` 作为 `strings.Split()` 的第二个参数允许你 *逐字符处理字符串*。'
- en: The `strings.Replace()` function takes four parameters. The first parameter
    is the string that you want to process. The second parameter contains the string
    that, if found, will be replaced by the third parameter of `strings.Replace()`.
    The last parameter is the maximum number of replacements that are allowed to happen.
    If that parameter has a negative value, then there is no limit to the allowed
    number of replacements.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.Replace()` 函数接受四个参数。第一个参数是你想要处理的字符串。第二个参数包含一个字符串，如果找到，将被 `strings.Replace()`
    的第三个参数替换。最后一个参数是允许发生的最大替换次数。如果该参数为负值，则没有替换次数的限制。'
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `strings.SplitAfter()` function splits its first parameter string into substrings
    based on the separator string that is given as the second parameter to the function.
    The separator string is included in the returned slice.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.SplitAfter()` 函数根据作为函数第二个参数提供的分隔符字符串将第一个参数字符串分割成子字符串。分隔符字符串包含在返回的切片中。'
- en: The last lines of code define a trim function named `trimFunction` that is used
    as the second parameter to `strings.TrimFunc()` in order to filter the given input
    based on the return value of the trim function—in this case, the trim function
    keeps all letters and nothing else due to the `unicode.IsLetter()` call.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码定义了一个名为 `trimFunction` 的 trim 函数，该函数用作 `strings.TrimFunc()` 的第二个参数，以便根据
    trim 函数的返回值过滤给定的输入——在这种情况下，由于调用了 `unicode.IsLetter()`，trim 函数保留所有字母而忽略其他所有内容。
- en: 'Running `useStrings.go` produces the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `useStrings.go` 产生以下输出：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Visit the documentation page of the strings package at [https://pkg.go.dev/strings](https://pkg.go.dev/strings)
    for the complete list of available functions. You will see the functionality of
    the `strings` package in other places in this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://pkg.go.dev/strings](https://pkg.go.dev/strings) 上的字符串包文档页面，以获取可用函数的完整列表。你将在本书的其他地方看到
    `strings` 包的功能。
- en: Enough with strings and text, the next section is about working with dates and
    times in Go.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符串和文本的内容就到这里，下一节将介绍在 Go 中处理日期和时间。
- en: Times and dates
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间和日期
- en: Often, we need to work with date and time information to store the time an entry
    was last used in a database or the time an entry was inserted into a database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要处理日期和时间信息，以存储条目在数据库中最后使用的时间或条目被插入数据库的时间。
- en: The king of working with times and dates in Go is the `time.Time` data type,
    which represents an instant in time with nanosecond precision. Each `time.Time`
    value is associated with a location (time zone).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中处理时间和日期的王者是 `time.Time` 数据类型，它以纳秒精度表示时间的一个瞬间。每个 `time.Time` 值都与一个位置（时区）相关联。
- en: If you are a UNIX person, you might already know about the UNIX epoch time and
    wonder how to get it in Go. The `time.Now().Unix()` function returns the popular
    UNIX epoch time, which is the number of seconds that have elapsed since `00:00:00
    UTC, January 1, 1970`. If you want to convert the UNIX time to the equivalent
    `time.Time` value, you can use the `time.Unix()` function. If you are not a UNIX
    person, then you might not have heard about the UNIX epoch time before, but now
    you know what it is!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个UNIX用户，你可能已经了解UNIX纪元时间，想知道如何在Go中获取它。`time.Now().Unix()`函数返回流行的UNIX纪元时间，即自`00:00:00
    UTC, January 1, 1970`以来经过的秒数。如果你想将UNIX时间转换为等效的`time.Time`值，可以使用`time.Unix()`函数。如果你不是一个UNIX用户，那么你可能之前没有听说过UNIX纪元时间，但现在你了解了它！
- en: The `time.Since()` function calculates the time that has passed since a given
    time and returns a `time.Duration` variable—the duration data type is defined
    as `type Duration int64`. Although a `Duration` is, in reality, an `int64` value,
    you cannot compare or convert a duration to an `int64` value implicitly because
    Go does not allow implicit data type conversions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Since()`函数计算从给定时间以来经过的时间，并返回一个`time.Duration`变量——`Duration`数据类型定义为`type
    Duration int64`。尽管实际上`Duration`是一个`int64`值，但你不能隐式地将持续时间与`int64`值进行比较或转换，因为Go不允许隐式数据类型转换。'
- en: The single most important topic about Go and dates and times is the way Go parses
    a string in order to convert it into a date and a time. The reason this is important
    is that usually such input is given as a string and not as a valid date variable.
    The function used for parsing is called `time.Parse()` and its full signature
    is `Parse(layout, value string) (Time, error)`, where `layout` is the parse string
    and `value` is the input that is being parsed. The `time.Time` value that is returned
    is a moment in time with nanosecond precision and contains both date and time
    information.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Go语言和日期时间的最重要的话题是Go如何解析字符串以将其转换为日期和时间。这之所以重要，是因为通常此类输入是以字符串形式给出的，而不是有效的日期变量。用于解析的函数称为`time.Parse()`，其完整签名是`Parse(layout,
    value string) (Time, error)`，其中`layout`是解析字符串，`value`是要解析的输入。返回的`time.Time`值是一个具有纳秒精度的时刻，包含日期和时间信息。
- en: The next table shows the most widely used strings for parsing dates and times.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个表格显示了用于解析日期和时间的最常用的字符串。
- en: '| **Parse Value** | **Meaning (examples)** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **解析值** | **含义（示例）** |'
- en: '| `03` | 12-hour value (12pm, 07am) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `03` | 12小时制值（12pm, 07am） |'
- en: '| `15` | 24-hour value (23, 07) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `15` | 24小时制值（23, 07） |'
- en: '| `04` | Minutes (55, 15) |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `04` | 分钟（55, 15） |'
- en: '| `05` | Seconds (5, 23) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `05` | 秒（5, 23） |'
- en: '| `Mon` | Abbreviated day of week (Tue, Fri) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `Mon` | 星期简称（Tue, Fri） |'
- en: '| `Monday` | Day of week (Tuesday, Friday) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `Monday` | 星期（Tuesday, Friday） |'
- en: '| `02` | Day of month (15, 31) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `02` | 月份中的日期（15, 31） |'
- en: '| `2006` | Year with 4 digits (2020, 2004) |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `2006` | 四位数字的年份（2020, 2004） |'
- en: '| `06` | Year with the last 2 digits (20, 04) |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `06` | 最后两位数字的年份（20, 04） |'
- en: '| `Jan` | Abbreviated month name (Feb, Mar) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `Jan` | 月份简称（Feb, Mar） |'
- en: '| `January` | Full month name (July, August) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `January` | 月份全称（July, August） |'
- en: '| `MST` | Time zone (EST, UTC) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `MST` | 时区（EST, UTC） |'
- en: The previous table shows that if you want to parse the `30 January 2023` string
    and convert it into a Go date variable, you should match it against the `02 January
    2006` string because this string indicates the expected format of the input—you
    cannot use anything else in its place when matching a string like `30 January
    2023`. Similarly, if you want to parse the `15 August 2023 10:00` string, you
    should match it against the `02 January 2006 15:04` string because this specifies
    the expected format of the input.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的表格显示，如果你想解析`30 January 2023`字符串并将其转换为Go日期变量，你应该将其与`02 January 2006`字符串匹配，因为该字符串表示输入的预期格式——在匹配类似`30
    January 2023`的字符串时，不能使用其他任何内容。同样，如果你想解析`15 August 2023 10:00`字符串，你应该将其与`02 January
    2006 15:04`字符串匹配，因为这指定了输入的预期格式。
- en: The documentation of the `time` package ([https://pkg.go.dev/time](https://pkg.go.dev/time))
    contains even more detailed information about parsing dates and times—however,
    the ones presented here should be more than enough for regular use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`包的文档([https://pkg.go.dev/time](https://pkg.go.dev/time))包含了关于解析日期和时间的更多详细信息——然而，这里提供的应该已经足够用于常规用途。'
- en: Now that we know how to work with dates and times, it is time to learn more
    about working with time zones.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何处理日期和时间，是时候学习更多关于处理时区的内容了。
- en: Working with different time zones
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不同的时区
- en: The presented utility accepts a date and a time and converts them into different
    time zones. This can be particularly handy when you want to preprocess log files
    from different sources that use different time zones to convert these different
    time zones into a common one. Once again, you need `time.Parse()` in order to
    convert a valid input into a `time.Time` value before doing the conversions. This
    time the input string contains the time zone and is parsed by the `"``02 January
    2006 15:04 MST"` string.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所提供的实用程序接受日期和时间，并将它们转换为不同的时区。当您想要预处理来自不同来源且使用不同时区的日志文件时，这特别有用，将这些不同的时区转换为公共时区。再次强调，您需要`time.Parse()`在执行转换之前将有效输入转换为`time.Time`值。这次输入字符串包含时区，并由`"``02
    January 2006 15:04 MST"`字符串解析。
- en: 'In order to convert the parsed date and time into New York time, the program
    uses the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将解析的日期和时间转换为纽约时间，程序使用以下代码：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This technique is used multiple times in `convertTimes.go`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在`convertTimes.go`中多次使用。
- en: If a command line argument contains any space characters, you should put it
    in double quotes for the UNIX shell to treat it as a single command line argument.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令行参数包含任何空格字符，您应该将其放在双引号中，以便UNIX shell将其视为单个命令行参数。
- en: 'Running `convertTimes.go` generates the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`convertTimes.go`生成以下输出：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the last execution of the program, the code must parse `25` as the hour of
    the day, which is wrong and generates the `hour out of range` error message.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的最后一次执行中，代码必须将`25`解析为一天中的小时，这是错误的，并生成`hour out of range`错误信息。
- en: There is a known Go issue related to the parsing of times and dates that you
    can learn about at [https://github.com/golang/go/issues/63345](https://github.com/golang/go/issues/63345).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与时间和日期解析相关的已知Go问题，您可以在[https://github.com/golang/go/issues/63345](https://github.com/golang/go/issues/63345)了解更多信息。
- en: The next subsection is about constant values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节是关于常量值。
- en: Constants
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: Go supports constants, which behave like variables but cannot change their values.
    Constants in Go are defined with the help of the `const` keyword. Constants can
    be either *global or local*. However, if you are defining too many constant values
    with a local scope, you might need to rethink your approach.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持常量，它们的行为类似于变量，但无法更改它们的值。Go中的常量是通过`const`关键字定义的。常量可以是*全局的或局部的*。然而，如果您正在定义太多具有局部作用域的常量值，您可能需要重新考虑您的做法。
- en: The main benefit you get from using constants in your programs is the guarantee
    that their value will not change during program execution. Strictly speaking,
    the value of a constant variable is defined at compile time, not at runtime—this
    means that it is included in the binary executable. Behind the scenes, Go uses
    Boolean, string, or numeric as the type for storing constant values because this
    gives Go more flexibility when dealing with constants.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您在使用程序中的常量时获得的主要好处是保证它们的值在程序执行期间不会改变。严格来说，常量变量的值是在编译时定义的，而不是在运行时——这意味着它包含在二进制可执行文件中。在幕后，Go使用布尔型、字符串型或数值型作为存储常量值的类型，因为这使Go在处理常量时具有更大的灵活性。
- en: Some possible uses of constants include defining configuration values such as
    the maximum number of connections or the TCP/IP port number used and defining
    physical constants such as the speed of light or the gravity on earth.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 常量的可能用途包括定义配置值，如最大连接数或使用的TCP/IP端口号，以及定义物理常量，如光速或地球上的重力。
- en: The next subsection discusses the constant generator iota, which is a handy
    way of creating sequences of constants.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论了常量生成器iota，这是一种创建常量序列的便捷方式。
- en: The constant generator iota
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量生成器iota
- en: The *constant generator iota* is used for declaring a sequence of related values
    that use incrementing numbers without the need to explicitly type each one of
    them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量生成器iota*用于声明一系列相关的值，这些值使用递增的数字，而无需显式地指定每个值。'
- en: The concepts related to the `const` keyword, including the constant generator
    iota, are illustrated in the `constants.go` file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与`const`关键字相关的概念，包括常量生成器iota，在`constants.go`文件中有说明。
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this part, we declare two new types named `Digit` and `Power2` that will
    be used in a while, and four new constants named `PI`, `C1`, `C2`, and `C3`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们声明了两个新类型`Digit`和`Power2`，它们将在稍后使用，以及四个新常量`PI`、`C1`、`C2`和`C3`。
- en: A Go type is a way of defining a new named type that uses the same underlying
    type as an existing type. This is mainly used for differentiating between different
    types that might use the same kind of data. The `type` keyword can also be used
    for defining structures and interfaces, which is not the case here.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Go 类型是一种定义新命名类型的方式，它使用与现有类型相同的底层类型。这主要用于区分可能使用相同类型数据的不同类型。`type` 关键字也可以用于定义结构和接口，但在这里不是这种情况。
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code defines a constant named `s1`. Here you also see the definition
    of a constant generator iota based on `Digit`, which is equivalent to the next
    declaration of five constants:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为 `s1` 的常量。在这里，你还可以看到基于 `Digit` 的常量生成器 iota 的定义，这相当于以下五个常量的声明：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Although we are defining constants inside `main()`, constants can normally be
    found outside of `main()` or any other function or method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们是在 `main()` 内部定义常量，但常量通常可以在 `main()` 或任何其他函数或方法外部找到。
- en: 'The last part of `constants.go` is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`constants.go` 的最后一部分如下：'
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is another constant generator iota here that is different than the previous
    one. Firstly, you can see the use of the underscore character in a `const` block
    with a constant generator iota, which allows you to skip unwanted values. Secondly,
    the value of iota always increments and can be used in expressions, which is what
    occurred in this case.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个与之前不同的常量生成器 iota。首先，你可以看到在常量生成器 iota 的 `const` 块中使用下划线字符，这允许你跳过不想要的值。其次，iota
    的值总是递增的，并且可以在表达式中使用，这正是这种情况。
- en: Now let us see what really happens inside the `const` block. For `p2_0`, iota
    has the value of `0` and `p2_0` is defined as `1`. For `p2_2`, iota has the value
    of `2` and `p2_2` is defined as the result of the expression `1 << 2`, which is
    `00000100` in binary representation. The decimal value of `00000100` is `4`, which
    is the result and the value of `p2_2`. Analogously, the value of `p2_4` is `16`
    and the value of `p2_6` is `64`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `const` 块内部真正发生了什么。对于 `p2_0`，iota 的值为 `0`，`p2_0` 被定义为 `1`。对于 `p2_2`，iota
    的值为 `2`，`p2_2` 被定义为表达式 `1 << 2` 的结果，二进制表示为 `00000100`。`00000100` 的十进制值是 `4`，这是结果和
    `p2_2` 的值。类似地，`p2_4` 的值是 `16`，`p2_6` 的值是 `64`。
- en: 'Running `constants.go` produces the following output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `constants.go` 产生以下输出：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Typed and untyped constants
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化和非类型化常量
- en: '**Constant values can have a data type**. This can be restrictive because a
    constant value with a data type can only operate with values and variables of
    the same data type, but it can save you from bugs because the compiler can catch
    such situations.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**常量值可以有数据类型**。这可能会很限制性，因为具有数据类型的常量值只能与相同数据类型的值和变量操作，但它可以让你避免错误，因为编译器可以捕获这种情况。'
- en: 'The code excerpt from `typedConstants.go` is going to show the difference between
    *typed* and *untyped constants*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `typedConstants.go` 的代码片段中将展示类型化常量与非类型化常量之间的区别：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, `untypedConstant` does not have a data type associated with it whereas
    `typedConstant` does. If you try to run `typedConstants.go`, the compiler is not
    going to be able to compile it and it is going to produce the following error
    output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`untypedConstant` 没有与之关联的数据类型，而 `typedConstant` 有。如果你尝试运行 `typedConstants.go`，编译器将无法编译它，并产生以下错误输出：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The cause of the error condition can be found in the generated output: `mismatched
    types int and int16`. Put simply, `i` is an `int` variable whereas `typedConstant`
    is an `int16` value and Go is unable to perform their multiplication because the
    data types of the variables do not match. On the other hand, there are no issues
    with the `i*untypedConstant` multiplication because `untypedConstant` does not
    have a data type.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 错误条件的原因可以在生成的输出中找到：`mismatched types int and int16`。简单来说，`i` 是一个 `int` 变量，而
    `typedConstant` 是一个 `int16` 值，Go 无法执行它们的乘法，因为变量的数据类型不匹配。另一方面，`i*untypedConstant`
    的乘法没有问题，因为 `untypedConstant` 没有数据类型。
- en: Having data is good but what happens when you have lots of similar data? Do
    you need to have lots of variables to hold this data or is there a better way
    to do so? Go answers these questions by introducing arrays and slices.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有数据是好的，但当你拥有大量相似数据时会发生什么？你需要有很多变量来存储这些数据，还是有一种更好的方法来做这件事？Go 通过引入数组和切片来回答这些问题。
- en: Grouping similar data
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对相似数据的分组
- en: There are times when you want to keep multiple values of the same data type
    under a single variable and access them using an index number. The simplest way
    to do that in Go is by using arrays or slices. *Arrays* are the most widely used
    data structures and can be found in almost all programming languages due to their
    simplicity and speed of access. Go provides an alternative to arrays that is called
    a *slice*. The subsections that follow help you understand the differences between
    arrays and slices so that you know which data structure to use and when. The quick
    answer is that **you can use slices instead of arrays almost anywhere in Go,**
    but we are also demonstrating arrays because they can still be useful and because
    slices are implemented by Go using arrays!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你希望将相同数据类型的多个值放在单个变量下，并使用索引号访问它们。在Go中，最简单的方法是使用数组或切片。*数组*是最广泛使用的数结构，由于它们的简单性和访问速度，几乎可以在所有编程语言中找到。Go提供了一个名为*切片*的数组替代品。以下的小节将帮助你了解数组和切片之间的区别，以便你知道何时使用哪种数据结构。简而言之，**你几乎可以在Go的任何地方使用切片代替数组**，但我们也在演示数组，因为它们仍然有用，并且因为切片是Go使用数组实现的！
- en: Arrays
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'We are going to begin our discussion about arrays by examining their core characteristics
    and limitations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始讨论数组，首先检查它们的核心特性和限制：
- en: When defining an array variable, you must define its size. Otherwise, you should
    put `[...]` in the array declaration and let the Go compiler find out the length
    for you. So you can create an array with 4 string elements either as `[4]string{"Zero",
    "One", "Two", "Three"}` or as `[...]string{"Zero", "One", "Two", "Three"}`. If
    you put nothing in the square brackets, then a slice is going to be created instead.
    As it contains four elements, the (valid) indexes for that array are `0`, `1`,
    `2`, and `3`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当定义一个数组变量时，你必须定义其大小。否则，你应该在数组声明中放置`[...]`，让Go编译器为你找出长度。因此，你可以创建一个包含4个字符串元素的数组，既可以写成`[4]string{"Zero",
    "One", "Two", "Three"}`，也可以写成`[...]string{"Zero", "One", "Two", "Three"}`。如果你在方括号中不放置任何内容，那么将创建一个切片。由于它包含四个元素，该数组的（有效）索引为`0`、`1`、`2`和`3`。
- en: You cannot change the size of an array after you have created it.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数组后，你不能更改其大小。
- en: When you pass an array to a function, **Go creates a copy of that array** and
    passes that copy to that function—therefore any changes you make to an array inside
    a function are lost when the function exits.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将一个数组传递给一个函数时，**Go会创建该数组的副本**并将其传递给该函数——因此，你在函数内部对数组所做的任何更改，在函数退出时都会丢失。
- en: As a result, arrays in Go are not very powerful, which is the main reason that
    Go has introduced an additional data structure named slice that is like an array
    but is dynamic in nature, as explained in the next subsection. However, data in
    both arrays and slices is accessed the same way.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Go中的数组并不十分强大，这是Go引入名为切片的额外数据结构的主要原因，它类似于数组，但本质上是动态的，如下一小节所述。然而，数组和切片中的数据访问方式是相同的。
- en: Slices
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: Slices in Go are more powerful than arrays mainly because they are dynamic,
    which means that they can grow or shrink after creation as needed. Additionally,
    any changes you make to a slice inside a function also affect the original slice.
    Keep in mind that this is usually the case, but it is not always true—as discussed
    in a while, all slices have an underlying array for storing the data. Only changes
    that do not cause an allocation of the underlying array are reflected back to
    the caller function. However, functions working with slices do not usually change
    the size of the slice.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的切片比数组更强大，主要是因为它们是动态的，这意味着它们可以在创建后根据需要增长或缩小。此外，你在函数内部对切片所做的任何更改也会影响原始切片。请注意，这通常是情况，但并不总是如此——如稍后讨论的，所有切片都有一个用于存储数据的底层数组。只有不会导致底层数组分配的更改才会反映回调用函数。然而，处理切片的函数通常不会更改切片的大小。
- en: 'But how does this happen? Strictly speaking, **all parameters in Go are passed
    by value**—there is no other way to pass parameters in Go. However, you can explicitly
    pass a pointer to a variable in order to pass by reference. A **slice value is
    a header that contains a pointer to an underlying array where the elements are
    actually stored, the length of the array, and its capacity**—the capacity of a
    slice is explained in the next subsection. Note that the slice value does not
    include its elements, **just a pointer to the underlying array**. So, when you
    pass a slice to a function, Go makes a copy of that header and passes it to the
    function. This copy of the slice header includes the pointer to the underlying
    array. That slice header is defined in the `reflect` package ([https://pkg.go.dev/reflect#SliceHeader](https://pkg.go.dev/reflect#SliceHeader))
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是如何发生的呢？严格来说，**Go 中的所有参数都是按值传递的**——在 Go 中没有其他传递参数的方式。然而，你可以显式地传递一个变量的指针以按引用传递。**切片值是一个包含指向实际存储元素的底层数组的指针、数组的长度以及其容量**——切片的容量将在下一小节中解释。请注意，切片值不包括其元素，**只包含指向底层数组的指针**。因此，当你将切片传递给函数时，Go
    会复制该头并传递给函数。这个切片头的副本包括指向底层数组的指针。这个切片头在 `reflect` 包（[https://pkg.go.dev/reflect#SliceHeader](https://pkg.go.dev/reflect#SliceHeader)）中定义为以下内容：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A side effect of passing the slice header is that it is faster to pass a slice
    to a function because Go does not need to make a copy of the slice and its elements,
    just a copy of the slice header.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 传递切片头的一个副作用是，将切片传递给函数更快，因为 Go 不需要复制切片及其元素，只需复制切片头。
- en: You can create a slice using `make()` or like an array without specifying its
    size or using `[...]`. If you do not want to initialize a slice, then using `make()`
    is better and faster. However, if you want to initialize it at the time of creation,
    then `make()` cannot help you. As a result, you can create a slice with three
    `float64` elements as `aSlice := []float64{1.2, 3.2, -4.5}`. Creating a slice
    with space for three `float64` elements with `make()` is as simple as executing
    `make([]float64, 3)`. Each element of that slice has a value of `0`, which is
    the zero value of the `float64` data type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `make()` 或不指定大小或使用 `[...]` 创建切片，就像数组一样。如果你不想初始化切片，那么使用 `make()` 更好更快。然而，如果你想在创建时初始化它，那么
    `make()` 就帮不上忙了。因此，你可以创建一个包含三个 `float64` 元素的切片，如 `aSlice := []float64{1.2, 3.2,
    -4.5}`。使用 `make()` 创建具有三个 `float64` 元素空间的切片与执行 `make([]float64, 3)` 一样简单。该切片的每个元素都有一个值为
    `0`，这是 `float64` 数据类型的零值。
- en: Both slices and arrays can have many dimensions—creating a slice with two dimensions
    with `make()` is as simple as writing `make([][]int, 2)`. This returns a slice
    with two dimensions where the first dimension is 2 (rows) and the second dimension
    (columns) is unspecified and should be explicitly specified when adding data to
    it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 切片和数组都可以有多个维度——使用 `make()` 创建具有两个维度的切片与编写 `make([][]int, 2)` 一样简单。这返回一个具有两个维度的切片，其中第一个维度是
    2（行），第二个维度（列）未指定，在添加数据时应显式指定。
- en: If you want to define and initialize a slice with two dimensions at the same
    time, you should execute something similar to `twoD := [][]int{{1, 2, 3}, {4,
    5, 6}}`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想同时定义和初始化一个具有两个维度的切片，你应该执行类似于 `twoD := [][]int{{1, 2, 3}, {4, 5, 6}}` 的操作。
- en: You can find the length of an array or a slice using `len()`. You can add new
    elements to a full slice using the `append()` function. `append()` automatically
    allocates the required memory space. Keep in mind that you should assign the return
    value of `append()` back to the desired variable as this is not an in-place change.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `len()` 函数找到数组或切片的长度。你可以使用 `append()` 函数向满切片添加新元素。`append()` 会自动分配所需的内存空间。请注意，你应该将
    `append()` 的返回值赋给所需的变量，因为这并不是原地更改。
- en: 'The example that follows clarifies many things about slices—feel free to experiment
    with it. Type the following code and save it as `goSlices.go`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例将阐明许多关于切片的知识点——请随意尝试。输入以下代码并将其保存为 `goSlices.go`：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `append()` commands add two new elements to `aSlice`. As stated before,
    the result of `append()` is not in-place and must be assigned to the desired variable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()` 命令向 `aSlice` 添加了两个新元素。如前所述，`append()` 的结果不是原地更改，必须赋给所需的变量。'
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once a slice has no place left for more elements, you can only add new elements
    to it using `append()`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦切片没有更多空间添加元素，你只能使用 `append()` 向其添加新元素。
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code shows how to create a 2D slice variable named `twoD` and
    initialize it at the same time.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何创建一个名为 `twoD` 的二维切片变量并初始化它。
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The previous part shows how to create a 2D slice with `make()`. What makes the
    `make2D` a 2D slice is the use of `[][]int` in `make()`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前一部分展示了如何使用 `make()` 创建一个二维切片。使 `make2D` 成为二维切片的是在 `make()` 中使用 `[][]int`。
- en: 'Running `goSlices.go` produces the following output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `goSlices.go` 产生以下输出：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: About slice length and capacity
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于切片长度和容量
- en: Both arrays and slices support the `len()` function for finding out their length.
    However, slices also have an additional property called *capacity* that can be
    found using the `cap()` function. The capacity of a slice is important when you
    want to select a part of a slice or when you want to reference an array using
    a slice.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和切片都支持 `len()` 函数来找出它们的长度。然而，切片还有一个额外的属性称为 *容量*，可以使用 `cap()` 函数找到。当你想要选择切片的一部分或想要使用切片引用数组时，切片的容量很重要。
- en: '**The capacity shows how much a slice can be expanded without the need to allocate
    more memory and change the underlying array**. Although after slice creation the
    capacity of a slice is handled by Go, a developer can define the capacity of a
    slice at creation time using the `make()` function—after that, the capacity of
    the slice doubles each time the length of the slice is about to become bigger
    than its current capacity. The first argument of `make()` is the type of the slice
    and its dimensions, the second is its initial length, and the third, which is
    optional, is the capacity of the slice. Although the data type of a slice cannot
    change after creation, the other two properties can change.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**容量显示了切片在不需要分配更多内存和更改底层数组的情况下可以扩展多少**。尽管在切片创建后，切片的容量由 Go 处理，但开发人员可以在创建时使用
    `make()` 函数定义切片的容量——之后，每次切片长度即将超过当前容量时，切片的容量都会加倍。`make()` 的第一个参数是切片的类型和其维度，第二个是它的初始长度，第三个是可选的，是切片的容量。尽管切片的数据类型在创建后不能改变，但其他两个属性可以改变。'
- en: Writing something like `make([]int, 3, 2)` generates an error message because
    at any given time the capacity of a slice (`2`) cannot be smaller than its length
    (`3`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 写出 `make([]int, 3, 2)` 会生成错误信息，因为在任何给定时间，切片的容量（`2`）不能小于其长度（`3`）。
- en: The figure that follows illustrates how length and capacity work in slices.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了切片中长度和容量是如何工作的。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21003_02_01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述由中等置信度自动生成](img/B21003_02_01.png)'
- en: 'Figure 2.1: How slice length and capacity are related'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：切片长度和容量之间的关系
- en: 'For those of you that prefer code, here is a small Go program that showcases
    the length and capacity properties of slices. Type it and save it as `capLen.go`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些喜欢代码的人来说，这里有一个小的 Go 程序，展示了切片的长度和容量属性。将其输入并保存为 `capLen.go`：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, the capacity of a is the same as its length, which is 4.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，切片 `a` 的容量与其长度相同，都是 4。
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Once again, the capacity of slice `b` is the same as its length, which is `5`
    because this is the default behavior.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，切片 `b` 的容量与其长度相同，都是 `5`，因为这默认行为。
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This time the capacity of slice `aSlice` is the same as its length, not because
    Go decided to do so but because we specified it in the `make()` call.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这次切片 `aSlice` 的容量与长度相同，不是因为 Go 决定这样做，而是因为我们已经在 `make()` 调用中指定了它。
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When you add a new element to slice `aSlice`, its capacity is doubled and becomes
    `8`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向切片 `aSlice` 添加新元素时，其容量加倍并变为 `8`。
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `...` operator expands `[]int{-1, -2, -3, -4}` into multiple arguments and
    `append()` appends each argument one by one to `aSlice`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`...` 操作符将 `[]int{-1, -2, -3, -4}` 扩展为多个参数，并且 `append()` 将每个参数逐个追加到 `aSlice`
    中。'
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Running `capLen.go` produces the following output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `capLen.go` 产生以下输出：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Setting the correct capacity of a slice, if known in advance, will make your
    programs faster because Go will not have to allocate a new underlying array and
    have all the data copied over. This is important when dealing with very large
    slices.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预先知道切片的正确容量，这将使你的程序运行更快，因为 Go 不必分配新的底层数组并将所有数据复制过来。这在处理非常大的切片时非常重要。
- en: Working with slices is good but what happens when you want to work with a continuous
    part of an existing slice? Is there a practical way to select a part of a slice?
    Fortunately, the answer is yes—the next subsection sheds some light on selecting
    a continuous part of a slice.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片是好的，但当你想要处理现有切片的连续部分时会发生什么？有没有一种实用的方法来选择切片的一部分？幸运的是，答案是肯定的——下一小节将简要介绍如何选择切片的连续部分。
- en: Selecting a part of a slice
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择切片的一部分
- en: Go allows you to select parts of a slice, provided that all desired elements
    are next to each other. This can be handy when you select a range of elements
    and you do not want to give their indexes one by one. In Go, you select a part
    of a slice by specifying (directly or indirectly) two indexes, where the first
    one is the beginning of the selection and the second one is the end of the selection,
    without including the element at that index, separated by `:`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你选择切片的一部分，前提是所有需要的元素都相邻。当你选择一系列元素且不想逐个给出它们的索引时，这会很有用。在 Go 中，你通过指定（直接或间接）两个索引来选择切片的一部分，第一个索引是选择的开始，第二个索引是选择的结束，不包括该索引处的元素，两者之间用
    `:` 分隔。
- en: If you want to process all the command line arguments of a utility apart from
    the first one, which is its file path, you can assign it to a new variable (`arguments
    := os.Args`) for ease of use and use the `arguments[1:]` notation to skip the
    first command line argument.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要处理一个实用工具的所有命令行参数（除了第一个，即它的文件路径），你可以将其分配给一个新的变量（`arguments := os.Args`）以方便使用，并使用
    `arguments[1:]` 表示法跳过第一个命令行参数。
- en: However, there is a variation where you can add a third parameter that controls
    the capacity of the resulting slice. So, using `aSlice[0:2:4]` selects the first
    2 elements of a slice (at indexes `0` and `1`) and creates a new slice with a
    maximum capacity of `4`. The resulting capacity is defined as the result of the
    `4-0` subtraction where 4 is the maximum capacity and 0 is the first index—if
    the first index is omitted, it is automatically set to `0`. In this case, the
    capacity of the result slice will be `4` because `4-0` equals `4`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种变体，你可以添加第三个参数来控制结果切片的容量。所以，使用 `aSlice[0:2:4]` 选择切片的前 2 个元素（在索引 `0` 和 `1`），并创建一个最大容量为
    `4` 的新切片。结果的容量定义为 `4-0` 的减法，其中 4 是最大容量，0 是第一个索引——如果省略第一个索引，它将自动设置为 `0`。在这种情况下，结果切片的容量将是
    `4`，因为 `4-0` 等于 `4`。
- en: If we had used `aSlice[2:4:4]`, we would have created a new slice with the `aSlice[2]`
    and `aSlice[3]` elements and with a capacity of `4-2`. Lastly, the resulting capacity
    cannot be bigger than the capacity of the original slice because in that case,
    you would need a different underlying array.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了 `aSlice[2:4:4]`，我们将创建一个新的切片，包含 `aSlice[2]` 和 `aSlice[3]` 元素，并且容量为 `4-2`。最后，结果的容量不能大于原始切片的容量，因为在这种情况下，你需要一个不同的底层数组。
- en: 'Type the following code into your favorite editor and save it as `partSlice.go`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码输入你喜欢的编辑器，并保存为 `partSlice.go`：
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this first part, we define a new slice named `aSlice` that has 10 elements.
    Its capacity is the same as its length. Both the `0:5` and `:5` notations select
    the first 5 elements of the slice, which are the elements found at indexes `0`,
    `1`, `2`, `3`, and `4`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们定义了一个名为 `aSlice` 的新切片，它有 10 个元素。它的容量与其长度相同。`0:5` 和 `:5` 两种表示法都选择切片的前
    5 个元素，即索引 `0`、`1`、`2`、`3` 和 `4` 的元素。
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Given the length of the slice (`l`), we can select the last two elements of
    the slice either as `l-2:l` or as `l-2:`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 给定切片的长度（`l`），我们可以通过 `l-2:l` 或 `l-2:` 来选择切片的最后两个元素。
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Initially, the capacity of `t` will be `10-0`, which is `10`. In the second
    case, the capacity of `t` will be `10-2`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，`t` 的容量将是 `10-0`，即 `10`。在第二种情况下，`t` 的容量将是 `10-2`。
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The capacity of `t` is now `6-0` and its length is going to be `5` because we
    have selected the first five elements of slice `aSlice`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`t` 的容量现在是 `6-0`，其长度将是 `5`，因为我们选择了切片 `aSlice` 的前五个元素。'
- en: 'The output of `partSlice.go` is presented in small chunks:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`partSlice.go` 的输出以小部分呈现：'
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The previous line is the output of `fmt.Println(aSlice)`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行是 `fmt.Println(aSlice)` 的输出。
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The previous two lines are generated from `fmt.Println(aSlice[0:5])` and `fmt.Println(aSlice[:5])`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 上两行是由 `fmt.Println(aSlice[0:5])` 和 `fmt.Println(aSlice[:5])` 生成的。
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Analogously, the previous two lines are generated from `fmt.Println(aSlice[l-2
    : l])` and `fmt.Println(aSlice[l-2:])`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '类似地，前两行是由 `fmt.Println(aSlice[l-2 : l])` 和 `fmt.Println(aSlice[l-2:])` 生成的。'
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The last three lines print the length and the capacity of `aSlice[0:5:10]`,
    `aSlice[2:5:10]`, and `aSlice[:5:6]`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三行打印了`aSlice[0:5:10]`、`aSlice[2:5:10]`和`aSlice[:5:6]`的长度和容量。
- en: Byte slices
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节切片
- en: A byte slice is a slice of the `byte` data type (`[]byte`). Go knows that most
    byte slices are used to store strings and so makes it easy to switch between this
    type and the `string` type. There is nothing special in the way you can access
    a byte slice compared to the other types of slices. What is special is that **Go
    uses byte slices for performing file I/O operations because they allow you to
    determine with precision the amount of data you want to read or write to a file**.
    This happens because bytes are a universal unit among computer systems.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 字节切片是`byte`数据类型（`[]byte`）的切片。Go知道大多数字节切片用于存储字符串，因此使得在`byte`类型和`string`类型之间切换变得容易。与其他类型的切片相比，访问字节切片的方式没有特别之处。特别的是，**Go使用字节切片来执行文件I/O操作，因为它们允许你精确地确定要读取或写入文件的数据量**。这是因为字节在计算机系统之间是一个通用的单位。
- en: As Go does not have a data type for storing single characters, it uses `byte`
    and `rune` for storing character values. A single byte can store a single ASCII
    character only whereas a rune can store Unicode characters. As a result, a rune
    can occupy multiple bytes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go没有用于存储单个字符的数据类型，它使用`byte`和`rune`来存储字符值。单个字节只能存储一个ASCII字符，而`rune`可以存储Unicode字符。因此，`rune`可以占用多个字节。
- en: 'The small program that follows illustrates how you can convert a byte slice
    into a string and vice versa, which you need for most file I/O operations—type
    it and save it as `byteSlices.go`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的小程序演示了如何将字节切片转换为字符串以及相反的操作，这对于大多数文件I/O操作是必需的——将其键入并保存为`byteSlices.go`：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: An empty byte slice contains zeros—in this case, 12 zeros.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 空字节切片包含零——在这种情况下，12个零。
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this case, the size of `b` is the size of the string `"Byte slice €"`, without
    the double quotes—`b` now points to a different memory location than before, which
    is where `"Byte slice €"` is stored. **This is how you convert a string into a
    byte slice**.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`b`的大小是字符串`"Byte slice €"`的大小，不包括双引号——`b`现在指向与之前不同的内存位置，即`"Byte slice
    €"`存储的位置。**这就是将字符串转换为字节切片的方法**。
- en: As Unicode characters like `€` need more than one byte for their representation,
    the length of the byte slice might not be the same as the length of the string
    that it stores.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于像`€`这样的Unicode字符需要多个字节来表示，字节切片的长度可能与存储的字符串长度不同。
- en: '[PRE61]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code shows how to print the contents of a byte slice as text using
    two techniques. The first one is by using the `%s` control string and the second
    one using `string()`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码展示了如何使用两种技术将字节切片的内容作为文本打印出来。第一种是通过使用`%s`控制字符串，第二种是使用`string()`。
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The preceding code prints the real length of the byte slice.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码打印了字节切片的实际长度。
- en: 'Running `byteSlices.go` produces the following output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`byteSlices.go`产生以下输出：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The last line of the output proves that although the `b` byte slice contains
    12 characters, it has a size of 14.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一行证明了尽管`b`字节切片包含12个字符，但它的大小却是14。
- en: Deleting an element from a slice
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从切片中删除元素
- en: There is no default function for deleting an element from a slice without using
    a package such as`slices`, which means that if you need to delete an element from
    a slice, you must write your own code. However, starting with Go 1.21, you can
    use `slices.Delete()` for that purpose. Therefore, this subsection is relevant
    when using an older Go version or when you want to manually delete an element.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用如`slices`之类的包的情况下，从切片中删除元素没有默认函数，这意味着如果你需要从切片中删除元素，你必须编写自己的代码。然而，从Go 1.21版本开始，你可以使用`slices.Delete()`来达到这个目的。因此，本小节在使用较旧的Go版本或当你想手动删除元素时是相关的。
- en: Deleting an element from a slice can be tricky, so this subsection presents
    two techniques for doing so. The first technique virtually divides the original
    slice into two slices, split at the index of the element that needs to be deleted.
    Neither of the two slices includes the element that is going to be deleted. After
    that, it concatenates these two slices and creates a new one.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从切片中删除元素可能很棘手，因此本小节介绍了两种删除元素的技术。第一种技术将原始切片在需要删除的元素的索引处虚拟地分成两个切片。这两个切片都不包含将要删除的元素。然后，它将这些切片连接起来，创建一个新的切片。
- en: The second technique copies the last element at the place of the element that
    is going to be deleted and creates a new slice by excluding the last element from
    the original slice. However, this particular technique changes the order of the
    slice elements, which in some cases might be important.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个技术将最后一个元素复制到要删除的元素的位置，并通过从原始切片中排除最后一个元素来创建一个新的切片。然而，这个特定的技术改变了切片元素的顺序，这在某些情况下可能很重要。
- en: The next figure shows a graphical representation of the two techniques for deleting
    an element from a slice.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了从切片中删除元素的两个技术图形表示。
- en: '![A picture containing text, screenshot, font, design  Description automatically
    generated](img/B21003_02_02.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、设计的图片 描述自动生成](img/B21003_02_02.png)'
- en: 'Figure 2.2: Deleting an element from a slice'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：从切片中删除元素
- en: The following program shows the two techniques that can be used for deleting
    an element from a slice. Create a text file by typing the following code—save
    it as `deleteSlice.go`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序展示了可以从切片中删除元素的两个技术。通过输入以下代码创建一个文本文件——将其保存为`deleteSlice.go`。
- en: '[PRE64]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here we logically divide the original slice into two slices. The two slices
    are split at the index of the element that needs to be deleted. After that, we
    concatenate these two slices with the help of `...`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将原始切片逻辑上划分为两个切片。这两个切片在需要删除的元素的索引处被分割。之后，我们通过`...`的帮助将这两个切片连接起来。
- en: Go supports the `...` operator, which is used for exploding a slice or an array
    into multiple arguments before appending it to an existing slice.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持使用`...`操作符，它在将切片或数组展开为多个参数以附加到现有切片之前使用。
- en: 'Next, we see the second technique in action:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看第二个技术的实际应用：
- en: '[PRE65]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We replace the element that we want to delete with the last element using the
    `aSlice[i] = aSlice[len(aSlice)-1]` statement and then we remove the last element
    with the `aSlice = aSlice[:len(aSlice)-1]` statement.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`aSlice[i] = aSlice[len(aSlice)-1]`语句将我们要删除的元素替换为最后一个元素，然后使用`aSlice = aSlice[:len(aSlice)-1]`语句删除最后一个元素。
- en: 'Running `deleteSlice.go` produces the following kind of output, depending on
    your input:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`deleteSlice.go`会产生以下类型的输出，具体取决于你的输入：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As the slice has nine elements, you can delete the element at index value `1`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切片有九个元素，你可以删除索引值为`1`的元素。
- en: '[PRE67]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As the slice has only nine elements, you cannot delete an element with an index
    value of `10` from the slice.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切片只有九个元素，你不能从切片中删除索引值为`10`的元素。
- en: How slices are connected to arrays
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片如何连接到数组
- en: As mentioned before, behind the scenes, **a slice is implemented using an underlying
    array**. The length of the underlying array is the same as the capacity of the
    slice and there exist pointers that connect the slice elements to the appropriate
    array elements.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在幕后，**切片是通过底层数组实现的**。底层数组的长度与切片的容量相同，并且存在指针将切片元素连接到相应的数组元素。
- en: You can understand that by connecting an existing array with a slice, Go allows
    you to reference an array or a part of an array using a slice. This has some strange
    capabilities including the fact that the changes to the slice affect the referenced
    array! However, when the capacity of the slice changes, the connection to the
    array ceases to exist! This happens because when the capacity of a slice changes,
    so does the underlying array, and the connection between the slice and the original
    array does not exist anymore.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以理解，通过将现有数组与切片连接，Go 允许你使用切片引用数组或数组的一部分。这具有一些奇特的功能，包括切片的变化会影响引用的数组！然而，当切片的容量发生变化时，与数组的连接就会终止！这是因为当切片的容量发生变化时，底层数组也会发生变化，切片与原始数组之间的连接就不再存在了。
- en: 'Type the following code and save it as `sliceArrays.go`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码并将其保存为`sliceArrays.go`：
- en: '[PRE68]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is a function that changes the first element of its input slice.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个改变其输入切片的第一个元素的函数。
- en: '[PRE69]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here we define an array named a with 4 elements.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`a`的包含4个元素的数组。
- en: '[PRE70]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here we connect `S0` with the first element of the array `a` and we print it.
    Then we change the value of `S0[0]`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`S0`与数组`a`的第一个元素连接起来，并打印它。然后我们改变`S0[0]`的值。
- en: '[PRE71]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this part, we associate `S12` with `a[1]` and `a[2]`. Therefore `S12[0] =
    a[1]` and `S12[1] = a[2]`. Then, we change the values of both `S12[0]` and `S12[1]`.
    These two changes will also change the contents of a. Put simply, `a[1]` takes
    the new value of `S12[0]` and `a[2]` takes the new value of `S12[1]`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将 `S12` 与 `a[1]` 和 `a[2]` 关联。因此 `S12[0] = a[1]` 和 `S12[1] = a[2]`。然后，我们改变
    `S12[0]` 和 `S12[1]` 的值。这两个变化也将改变 `a` 的内容。简单地说，`a[1]` 取 `S12[0]` 的新值，而 `a[2]` 取
    `S12[1]` 的新值。
- en: '[PRE72]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: And we print variable `a`, which has not changed at all in a direct way. However,
    due to the connections of `a` with `S0` and `S12`, the contents of `a` have changed!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印变量 `a`，它以直接的方式完全没有改变。然而，由于 `a` 与 `S0` 和 `S12` 的连接，`a` 的内容已经改变！
- en: '[PRE73]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As the slice and the array are connected, any changes you make to the slice
    will also affect the array even if the changes take place inside a function.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切片和数组是连接的，您对切片所做的任何更改也会影响数组，即使这些更改发生在函数内部。
- en: '[PRE74]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As the capacity of `S0` changes, it is no longer connected to the same underlying
    array (`a`).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `S0` 容量的变化，它不再连接到相同的底层数组（`a`）。
- en: '[PRE75]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: However, array `a` and slice `S12` are still connected because the capacity
    of `S12` has not changed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数组 `a` 和切片 `S12` 仍然连接在一起，因为 `S12` 的容量没有改变。
- en: '[PRE76]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Lastly, we print the final versions of `a`, `S0`, and `S12`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印 `a`、`S0` 和 `S12` 的最终版本。
- en: 'Running `sliceArrays.go` produces the following output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `sliceArrays.go` 产生以下输出：
- en: '[PRE77]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The next subsection shows a technique for catching out of bound errors on slices
    as early as possible.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示一种在切片上尽早捕获越界错误的技术。
- en: Catching out of bounds errors
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获越界错误
- en: 'In this subsection, we present a technique for catching out of bounds errors.
    The technique is illustrated with the help of two functions. The first function
    is the next:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一种捕获越界错误的技术。该技术通过两个函数来展示。第一个函数如下：
- en: '[PRE78]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the case of `foo()`, no bound checking is performed on slice `s`. This means
    that we can use any index on it without being sure that we will get that index
    in the first place and without the compiler performing any checks.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `foo()` 的情况下，对切片 `s` 不执行边界检查。这意味着我们可以使用任何索引，而不确定我们最初是否会得到那个索引，也不需要编译器执行任何检查。
- en: 'The second function is the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个功能如下：
- en: '[PRE79]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Keep in mind that the compiler is not going to check the slice provided as
    a parameter to the function. However, the compiler is going to refuse to compile
    the preceding code. The generated error is going to be `invalid argument: index
    3 out of bounds [0:3]`. The reason that the error was caught is that although
    we get three elements from `slice` and put them into `a`, we are using four elements
    from array `a`, which is clearly not allowed.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，编译器不会检查传递给函数的切片。然而，编译器将拒绝编译前面的代码。生成的错误将是 `无效参数：索引 3 超出范围 [0:3]`。错误被捕获的原因是，尽管我们从
    `slice` 中获取了三个元素并将它们放入 `a` 中，但我们使用了数组 `a` 的四个元素，这显然是不允许的。
- en: Let us now discuss the use of the `copy()` function in the next subsection.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在讨论 `copy()` 函数的使用，在下一个子节中。
- en: The copy() function
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`copy()` 函数'
- en: Go offers the `copy()` function for copying an existing array to a slice or
    an existing slice to another slice. However, the use of `copy()` can be tricky
    because the destination slice is not auto-expanded if the source slice is bigger
    than the destination slice. Additionally, if the destination slice is bigger than
    the source slice, then `copy()` does not empty the elements from the destination
    slice that did not get copied. This is better illustrated in the figure that follows.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了 `copy()` 函数，用于将现有数组复制到切片或现有切片复制到另一个切片。然而，`copy()` 的使用可能很棘手，因为如果源切片比目标切片大，则目标切片不会自动扩展。此外，如果目标切片比源切片大，则
    `copy()` 不会清空目标切片中未复制的元素。这将在下面的图中更好地说明。
- en: '![A picture containing text, screenshot, font, number  Description automatically
    generated](img/B21003_02_03.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、数字的图片，自动生成描述](img/B21003_02_03.png)'
- en: 'Figure 2.3: The use of the copy() function'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：`copy()` 函数的使用
- en: 'The following program illustrates the use of `copy()`—type it in your favorite
    text editor and save it as `copySlice.go`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序说明了 `copy()` 函数的使用——将其输入您喜欢的文本编辑器并保存为 `copySlice.go`：
- en: '[PRE80]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here we run the `copy(a1, a2)` command. In this case, the `a2` slice is bigger
    than `a1`. After `copy(a1, a2)`, `a2` remains the same, which makes perfect sense
    as `a2` is the input slice, whereas the first element of `a2` is copied to the
    first element of `a1` because `a1` has space for a single element only.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行`copy(a1, a2)`命令。在这种情况下，`a2`切片比`a1`大。在`copy(a1, a2)`之后，`a2`保持不变，这是完全合理的，因为`a2`是输入切片，而`a2`的第一个元素被复制到`a1`的第一个元素，因为`a1`只有一个元素的空间。
- en: '[PRE81]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this case, `a5` is bigger than `a1`. Once again, after `copy(a1, a5)`, `a5`
    remains the same whereas `a5[0]` is copied to `a1[0]`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`a5`比`a1`大。再次，在`copy(a1, a5)`之后，`a5`保持不变，而`a5[0]`被复制到`a1[0]`。
- en: '[PRE82]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this last case, `a2` is shorter than `a5`. This means that the entire `a2`
    is copied into `a5` as there is enough room. As the length of `a2` is `2`, only
    the first 2 elements of `a5` change.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，`a2`的长度短于`a5`。这意味着由于有足够的空间，整个`a2`被复制到`a5`中。由于`a2`的长度是`2`，因此只有`a5`的前两个元素发生变化。
- en: 'Running `copySlice.go` produces the following output:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`copySlice.go`产生以下输出：
- en: '[PRE83]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `copy(a1, a2)` statement does not alter the `a2` slice, just `a1`. As the
    size of `a1` is `1`, only the first element from `a2` is copied.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy(a1, a2)`语句不会改变`a2`切片，只会改变`a1`。由于`a1`的大小是`1`，因此只会从`a2`复制第一个元素。'
- en: '[PRE84]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Similarly, `copy(a1, a5)` alters `a1` only. As the size of `a1` is `1`, only
    the first element from `a5` is copied to `a1`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`copy(a1, a5)`只改变了`a1`。由于`a1`的大小是`1`，因此只有`a5`的第一个元素被复制到`a1`。
- en: '[PRE85]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Last, `copy(a5, a2)` alters `a5`. As the size of `a5` is `5`, only the first
    two elements from `a5` are altered and become the same as the first two elements
    of `a2`, which has a size of `2`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`copy(a5, a2)`改变了`a5`。由于`a5`的大小是`5`，因此只有`a5`的前两个元素被改变，并成为`a2`的前两个元素，`a2`的大小为`2`。
- en: Sorting slices
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序切片
- en: There are times when you want to present your information sorted and you want
    Go to do the job for you. In this subsection, we are going to see how to sort
    slices of various standard data types using the functionality offered by the `sort`
    package.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您想以排序的方式呈现您的信息，并希望Go为您完成这项工作。在本节中，我们将看到如何使用`sort`包提供的功能对各种标准数据类型的切片进行排序。
- en: The `sort` package can sort slices of built-in data types without the need to
    write any extra code. Additionally, Go provides the `sort.Reverse()` function
    for sorting in reverse order. However, what is really interesting is that `sort`
    allows you to write your own sorting functions for custom data types by implementing
    the `sort.Interface` interface—you will learn more about `sort.Interface` and
    interfaces in general in *Chapter 5*, *Reflection and Interfaces*.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`包可以在不编写任何额外代码的情况下对内置数据类型的切片进行排序。此外，Go提供了`sort.Reverse()`函数以逆序排序。然而，真正有趣的是`sort`允许您通过实现`sort.Interface`接口来编写自己的排序函数以用于自定义数据类型——您将在*第5章*，*反射和接口*中了解更多关于`sort.Interface`和接口的一般知识。'
- en: With Go generics, the `slices` package was introduced in the standard Go library—the
    `slices` package is discussed in *Chapter 4*, *Go Generics*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go泛型中，`slices`包被引入到标准Go库中——`slices`包在*第4章*，*Go泛型*中进行了讨论。
- en: So, you can sort a slice of integers saved as `sInts` by typing `sort.Ints(sInts)`.
    When sorting a slice of integers in reverse order using `sort.Reverse()`, you
    need to pass the desired slice to `sort.Reverse()` using `sort.IntSlice(sInts)`
    because the `IntSlice` type implements the `sort.Interface` internally, which
    allows you to sort in a different way than usual. The same applies to the other
    standard Go data types.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以通过输入`sort.Ints(sInts)`来对保存为`sInts`的整数切片进行排序。当使用`sort.Reverse()`以逆序对整数切片进行排序时，您需要使用`sort.IntSlice(sInts)`将所需的切片传递给`sort.Reverse()`，因为`IntSlice`类型内部实现了`sort.Interface`，这允许您以不同于通常的方式排序。同样适用于其他标准Go数据类型。
- en: 'Create a text file with following the code that illustrates the use of sort
    and name it `sortSlice.go`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的文本文件，以说明排序的使用，并将其命名为`sortSlice.go`：
- en: '[PRE86]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As `sort.Interface` knows how to sort integer values, it is trivial to sort
    them in reverse order.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`sort.Interface`知道如何对整数值进行排序，因此以逆序排序它们是微不足道的。
- en: '[PRE87]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The same rules apply when sorting floating point numbers and strings.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当排序浮点数和字符串时，同样适用这些规则。
- en: 'Running `sortSlice.go` produces the following output:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`sortSlice.go`产生以下输出：
- en: '[PRE88]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The output illustrates how the original slices were sorted in both normal and
    reverse order.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 输出说明了原始切片在正常和逆序下的排序情况。
- en: The next section discusses pointers in Go. Although Go does not support pointers
    in the same way that C does, Go allows you to work with pointers and pointer variables.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将讨论Go中的指针。尽管Go不支持指针的方式与C相同，但Go允许你与指针和指针变量一起工作。
- en: Pointers
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: Go has **support for pointers but not for pointer arithmetic**, which is the
    cause of many bugs and errors in programming languages like C. A pointer is the
    memory address of a variable. You need to *dereference a pointer* in order to
    get its value—dereferencing is performed using the `*` character in front of the
    pointer variable. Additionally, you can get the memory address of a normal variable
    using an `&` in front of it.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持指针但不支持指针算术，这是C等编程语言中许多错误和bug的原因。指针是变量的内存地址。你需要*取消引用指针*以获取其值——取消引用是通过在指针变量前使用`*`字符来执行的。此外，你可以使用`&`在变量前获取普通变量的内存地址。
- en: The next diagram shows the difference between a pointer to an `int` and an `int`
    variable.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了`int`指针和`int`变量的区别。
- en: '![A picture containing text, screenshot, rectangle, font  Description automatically
    generated](img/B21003_02_04.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、矩形、字体的图片，描述自动生成](img/B21003_02_04.png)'
- en: 'Figure 2.4: An int variable and a pointer to an int'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：一个`int`变量和一个`int`指针
- en: If a pointer variable points to an existing regular variable, then any changes
    you make to the stored value using the pointer variable will modify the regular
    variable.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指针变量指向一个现有的普通变量，那么你使用指针变量对该存储值所做的任何更改都将修改普通变量。
- en: The format and the values of memory addresses might be different between different
    machines, different operating systems, and different architectures.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 内存地址的格式和值可能在不同的机器、不同的操作系统和不同的架构之间有所不同。
- en: You might ask, what is the point of using pointers when there is no support
    for pointer arithmetic? The main benefit you get from pointers is that passing
    a variable to a function as a pointer (we can call that by reference) does not
    discard any changes you make to the value of that variable inside that function
    when the function returns. There exist times where you want that functionality
    because it simplifies your code, but the price you pay for that simplicity is
    being extra careful with what you do with a pointer variable.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，当没有指针算术支持时，使用指针有什么意义？从指针中获得的主要好处是，将变量作为指针（我们可以称之为引用）传递给函数时（当函数返回时），不会丢弃你在该函数内部对该变量值所做的任何更改。有时你希望有这种功能，因为它简化了你的代码，但为此简单性付出的代价是必须格外小心地处理指针变量。
- en: Remember that slices are passed to functions without the need to use a pointer—it
    is Go that passes the pointer to the underlying array of a slice and there is
    no way to change that behavior.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，切片在传递给函数时不需要使用指针——是Go将切片的底层数组指针传递过去，而且无法改变这种行为。
- en: 'Apart from reasons of simplicity, there exist three more reasons for using
    pointers:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单性的原因之外，还有三个更多使用指针的原因：
- en: Pointers allow you to share and manipulate data between functions without explicitly
    returning values back to the caller. However, when sharing data between functions
    and goroutines, you should be extra careful with *race condition* issues. This
    allows multiple functions to try to alter the value of the same pointer variable
    at the same time, which causes unpredictable behavior in the final state of that
    pointer variable.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针允许你在函数之间共享和操作数据，而无需显式地将值返回给调用者。然而，当在函数和goroutine之间共享数据时，你应该格外小心处理*竞态条件*问题。这允许多个函数同时尝试更改相同指针变量的值，这会导致该指针变量的最终状态出现不可预测的行为。
- en: Pointers are also very handy when you want to tell the difference between the
    zero value of a variable and a value that is not set (`nil`). This is particularly
    useful with structures because pointers (and therefore pointers to structures,
    which are fully covered in the next chapter) can have a `nil` value, which means
    that you can compare a pointer to a structure with a `nil` value, which is not
    allowed for normal structure variables.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要区分变量的零值和未设置的值（`nil`）时，指针也非常有用。这对于结构体尤其有用，因为指针（以及因此结构体的指针，这在下一章中会全面介绍）可以有`nil`值，这意味着你可以比较一个结构体指针与`nil`值，这对于普通结构体变量是不允许的。
- en: Having support for pointers and, more specifically, pointers to structures allows
    Go to support data structures such as linked lists and binary trees, which are
    widely used in computer science. Therefore, you are allowed to define a structure
    field of a `Node` structure as `Next *Node`, which is a pointer to another `Node`
    structure. Without pointers, this would have been difficult to implement and possibly
    too slow.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持指针，特别是结构体指针，使得 Go 能够支持诸如链表和二叉树这样的数据结构，这些在计算机科学中得到了广泛应用。因此，你可以将 `Node` 结构体的结构字段定义为
    `Next *Node`，这是另一个 `Node` 结构体的指针。没有指针，这将很难实现，可能也太慢了。
- en: 'The following code illustrates how you can use pointers in Go—create a text
    file named `pointers.go` and type the following code:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何在 Go 中使用指针——创建一个名为 `pointers.go` 的文本文件并输入以下代码：
- en: '[PRE89]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This is a structure with two fields named `field1` and `field2`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有两个字段名为 `field1` 和 `field2` 的结构体。
- en: '[PRE90]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This is a function that gets a pointer to a `float64` variable as input. As
    we are using a pointer, all changes to the function parameter inside the function
    will be persistent. Additionally, there is no need to return something.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接收 `float64` 变量指针作为输入的函数。由于我们使用指针，函数内部对函数参数的所有更改都将持续存在。此外，不需要返回任何内容。
- en: '[PRE91]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This is a function that requires a `float64` parameter as input and returns
    a pointer to a `float64`. To return the memory address of a regular variable,
    you need to use `&` (`&temp`). In this case, Go is smart enough to realize that
    the pointer to `temp` escapes, so its value will be heap allocated, ensuring that
    the caller has a valid reference to work with as opposed to stack allocation where
    the reference is invalid when the function returns and the stack frame is eliminated.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要 `float64` 参数作为输入并返回 `float64` 指针的函数。要返回常规变量的内存地址，你需要使用 `&` (`&temp`)。在这种情况下，Go
    足够智能，能够意识到 `temp` 的指针会逃逸，因此其值将在堆上分配，确保调用者有一个有效的引用来工作，而不是在栈分配中，当函数返回且栈帧被消除时，引用将无效。
- en: '[PRE92]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is a function that requires a pointer to a `float64` as input and returns
    a pointer to a `float64` as output. The `*x` notation is used for getting the
    value stored in the memory address stored in `x` and is called dereferencing.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要 `float64` 指针作为输入并返回 `float64` 指针作为输出的函数。`*x` 符号用于获取存储在 `x` 中内存地址的值，这被称为解引用。
- en: '[PRE93]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: To get the memory address of a regular variable named `f`, you should use the
    `&f` notation.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取名为 `f` 的常规变量的内存地址，你应该使用 `&f` 符号。
- en: '[PRE94]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '`fP` is now a pointer to the memory address of the `f` variable. Any changes
    to the value stored in the `fP` memory address influence the `f` value as well.
    However, this is only true for as long as `fP` points to the memory address of
    the `f` variable.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`fP` 现在是指向 `f` 变量内存地址的指针。对存储在 `fP` 内存地址中的值的任何更改都会影响 `f` 的值。然而，这只有在 `fP` 指向
    `f` 变量的内存地址时才成立。'
- en: '[PRE95]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The value of `f` does not change because the function only uses its value.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`f` 的值没有改变，因为函数只使用了它的值。'
- en: '[PRE96]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In this case, the value of `f`, as well as the value stored in the `fP` memory
    address, do not change because the `bothPointers()` function does not make any
    changes to the value stored in the `fP` memory address.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`f` 的值以及存储在 `fP` 内存地址中的值都没有改变，因为 `bothPointers()` 函数没有对存储在 `fP` 内存地址中的值进行任何更改。
- en: '[PRE97]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `k` variable is a pointer to an `aStructure` structure. As `k` points to
    nowhere, Go makes it point to `nil`, which is the zero value for pointers.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`k` 变量是指向 `aStructure` 结构体的指针。由于 `k` 指向无地方，Go 使其指向 `nil`，这是指针的零值。'
- en: '[PRE98]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As `k` is `nil`, we are allowed to assign it to an empty `aStructure` value
    with `new(aStructure)` without losing any data—`new()` allocates the required
    memory and sets the pointer to that memory. Now, `k` is no longer `nil` but both
    fields of `aStructure` have the zero values of their data types.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `k` 是 `nil`，我们可以将其赋值给一个空的 `aStructure` 值，使用 `new(aStructure)` 而不会丢失任何数据——`new()`
    分配所需的内存并将指针设置为该内存。现在，`k` 已不再是 `nil`，但 `aStructure` 的两个字段都拥有它们数据类型的零值。
- en: '[PRE99]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The preceding code is just making sure that `k` is not `nil`. You might consider
    that check redundant, but it does not hurt to double-check because if you try
    to dereference a `nil` pointer, your program is going to crash.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是确保 `k` 不是 `nil`。你可能认为这个检查是多余的，但双重检查并不会有害，因为如果你尝试解引用一个 `nil` 指针，你的程序将会崩溃。
- en: 'Running `pointers.go` generates the following kind of output:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `pointers.go` 生成以下类型的输出：
- en: '[PRE100]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We are going to revisit pointers in the next chapter when we discuss structures.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论结构体时重新审视指针。
- en: Converting a slice to an array or an array pointer
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将切片转换为数组或数组指针
- en: 'In this subsection, we are going to learn how to convert a slice to an array
    or an array pointer. The first part of `slice2array.go` is the following:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将学习如何将切片转换为数组或数组指针。`slice2array.go` 的第一部分如下：
- en: '[PRE101]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In the preceding code we convert `slice` into an array pointer that points to
    an array with 3 elements.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `slice` 转换为一个指向具有 3 个元素的数组的数组指针。
- en: 'The rest of the `slice2array.go` code is the following:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice2array.go` 的其余代码如下：'
- en: '[PRE102]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: In the preceding code we converted a slice into an array with 3 elements.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将切片转换为一个具有 3 个元素的数组。
- en: 'Running `slice2array.go` produces the following output:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `slice2array.go` 产生以下输出：
- en: '[PRE103]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The first three lines of output have to do with the slice-to-array-pointer conversion
    whereas the last two have to do with the slice-to-array conversion. The second
    line of output verifies that we are dealing with a pointer to an array with three
    elements (`*[3]uint8`) and the last line verifies that we are dealing with an
    array with three elements (`[3]int`).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前三行与切片到数组指针的转换有关，而最后两行与切片到数组的转换有关。输出第二行验证我们正在处理一个指向具有三个元素的数组的指针（`*[3]uint8`），而最后一行验证我们正在处理一个具有三个元素的数组（`[3]int`）。
- en: Next, we discuss data types and the `unsafe` package.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论数据类型和 `unsafe` 包。
- en: Data types and the unsafe package
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型和 `unsafe` 包
- en: The `unsafe` package in Go provides facilities for performing operations that
    break the type safety guarantees of Go. It is a powerful but potentially dangerous
    package, and its use is discouraged in most Go code. Therefore, the `unsafe` package
    is intended for specific situations where low-level programming is necessary,
    such as interfacing with non-Go code, dealing with memory layout, or implementing
    certain advanced features.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 `unsafe` 包提供了执行破坏 Go 类型安全保证的操作的功能。它是一个强大但可能危险的包，在大多数 Go 代码中不建议使用。因此，`unsafe`
    包旨在用于特定情况，在这些情况下需要低级编程，例如与非 Go 代码接口、处理内存布局或实现某些高级功能。
- en: In this section, we are going to discuss four functions of the `unsafe` package
    that are related to strings and slices. You might not have to use any of them
    on a regular basis, but it is good to know about them because they provide speed
    when dealing with large strings or slices that take lots of memory because they
    **deal with memory addresses directly**, which might be very dangerous if you
    do not know what you are doing. The four functions that we are going to discuss
    are `unsafe.StringData()`, `unsafe.String()`, `unsafe.Slice()`, and `unsafe.SliceData()`.
    You can learn more details about their usage using `go doc`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论与字符串和切片相关的 `unsafe` 包的四个函数。你可能不需要经常使用它们，但了解它们是有好处的，因为它们在处理大型字符串或占用大量内存的切片时提供了速度，因为它们**直接处理内存地址**，如果你不知道自己在做什么，这可能会非常危险。我们将讨论的四个函数是
    `unsafe.StringData()`、`unsafe.String()`、`unsafe.Slice()` 和 `unsafe.SliceData()`。你可以使用
    `go doc` 了解它们使用的更多详细信息。
- en: Please bear in mind that the `unsafe` package is called unsafe for a reason,
    and that in most cases you should not use this package!
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`unsafe` 包之所以被称为 unsafe，是有原因的，而且在大多数情况下你不应该使用这个包！
- en: 'The first part of `typeUnsafe.go` comes with two functions:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeUnsafe.go` 的第一部分包含两个函数：'
- en: '[PRE104]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: These two particular functions convert a byte slice to a string and vice versa
    using `unsafe.String()` and `unsafe.Slice()`, respectively.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特定的函数分别使用 `unsafe.String()` 和 `unsafe.Slice()` 将字节切片转换为字符串，反之亦然。
- en: The `unsafe.String()` function requires a pointer parameter and a length value
    in order to know how far from the pointer it is going to go for the data. The
    `unsafe.SliceData()` function returns a pointer to the underlying array of the
    function argument slice.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe.String()` 函数需要一个指针参数和一个长度值，以便知道它将从指针开始走多远以获取数据。`unsafe.SliceData()`
    函数返回函数参数切片的底层数组的指针。'
- en: '`unsafe.Slice()` operates in an analogous way and returns a slice whose underlying
    array starts at the given pointer value and whose length and capacity are equal
    to the integer value that is passed as its second parameter—it is important to
    understand that when working with memory addresses via pointers and the `unsafe`
    package, we need to specify how far in memory we need to go.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsafe.Slice()` 以类似的方式操作，并返回一个底层数组从给定指针值开始，其长度和容量等于作为其第二个参数传递的整数值的切片——重要的是要理解，当通过指针和`unsafe`包处理内存地址时，我们需要指定需要走多远。'
- en: As Go strings are immutable, the bytes returned by `unsafe.StringData()` should
    not be modified.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go字符串是不可变的，`unsafe.StringData()` 返回的字节不应该被修改。
- en: 'The second part of `typeUnsafe.go` is the following:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeUnsafe.go` 的第二部分如下：'
- en: '[PRE105]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The last part of `typeUnsafe.go` is as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeUnsafe.go` 的最后一部分如下：'
- en: '[PRE106]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The output of `typeUnsafe.go` is the following:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeUnsafe.go` 的输出如下：'
- en: '[PRE107]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Remember that the most common purpose for using the `unsafe` package is speed
    when dealing with large amounts of data because it allows you to perform pointer
    arithmetic and conversions between different pointer types without type safety
    checks. When dealing with large amounts of data, pointer arithmetic can speed
    up things.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用 `unsafe` 包最常见的目的是在处理大量数据时提高速度，因为它允许你在不进行类型安全检查的情况下执行指针算术和不同指针类型之间的转换。在处理大量数据时，指针算术可以加快速度。
- en: Next, we discuss generating random numbers and random strings.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论生成随机数和随机字符串。
- en: Generating random numbers
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Random number generation is an art as well as a research area in computer science.
    This is because computers are purely logical machines, and it turns out that using
    them to generate random numbers is extremely difficult!
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成既是计算机科学中的一个研究领域，也是一种艺术。这是因为计算机是纯粹的逻辑机器，结果发现使用它们来生成随机数极其困难！
- en: Go can help you with that using the functionality of the `math/rand` package.
    Each random number generator needs a seed to start producing numbers. The seed
    is used for initializing the entire process and is extremely important because
    if you always start with the same seed, you will always get the same sequence
    of pseudo-random numbers. This means that everybody can regenerate that sequence,
    and that particular sequence will not be random after all.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Go可以使用`math/rand`包的功能来帮助你。每个随机数生成器需要一个种子来开始生成数字。种子用于初始化整个过程，并且非常重要，因为如果你总是从相同的种子开始，你将总是得到相同的伪随机数序列。这意味着每个人都可以重新生成那个序列，而那个特定的序列最终并不是随机的。
- en: However, this feature is very handy for testing purposes. In Go, the `rand.Seed()`
    function is used for initializing a random number generator.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个特性对于测试目的非常有用。在Go中，`rand.Seed()` 函数用于初始化随机数生成器。
- en: If you are really interested in random number generation, you should start by
    reading the second volume of *The Art of Computer Programming* by Donald E. Knuth
    (Addison-Wesley Professional, 2011).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的对随机数生成感兴趣，你应该从阅读唐纳德·E·克努特（Donald E. Knuth）的《计算机编程艺术》（The Art of Computer
    Programming）的第二卷开始，这本书由Addison-Wesley Professional于2011年出版。
- en: The following function, which is part of `randomNumbers.go` found in `ch02`
    in the book’s GitHub repository, is what generates random numbers in the `[min,
    max)` range.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是位于书籍GitHub仓库`ch02`中的`randomNumbers.go`的一部分，它用于生成 `[min, max)` 范围内的随机数。
- en: '[PRE108]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The `random()` function does all of the work, which is generating pseudo-random
    numbers in the `min` to `max-1` range by calling `rand.Intn()`. `rand.Intn()`
    generates non-negative random integers from `0` up to the value of its single
    parameter minus 1.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`random()` 函数完成所有工作，通过调用 `rand.Intn()` 在 `min` 到 `max-1` 范围内生成伪随机数。`rand.Intn()`
    生成从 `0` 到其单个参数值减一的非负随机整数。'
- en: The `randomNumbers.go` utility accepts four command line parameters but can
    also work with fewer parameters by using default values. By default, `randomNumbers.go`
    produces 100 random integers from 0 up to and including 99.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`randomNumbers.go` 工具接受四个命令行参数，但也可以通过使用默认值使用更少的参数。默认情况下，`randomNumbers.go`
    会生成100个从 `0` 到包括 `99` 的随机整数。'
- en: '[PRE109]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In the following output, we define each of the parameters manually (the minimum
    value, maximum value, number of random values, and seed value):'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下输出中，我们手动定义了每个参数（最小值、最大值、随机值的数量和种子值）：
- en: '[PRE110]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The first two times the seed value was 10, so we got the same output. The third
    time the value of the seed was 11, which generated a different output.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 前两次的种子值是10，所以我们得到了相同的输出。第三次种子值是11，这生成了不同的输出。
- en: Generating random strings
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成随机字符串
- en: 'Imagine that you want to generate random strings that can be used for difficult-to-guess
    passwords or for testing purposes. Based on random number generation, we create
    a utility that produces random strings. The utility is implemented as `genPass.go`
    and can be found in the `ch02` directory of the book’s GitHub repository. The
    core functionality of `genPass.go` is found in the next function:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想生成用于难以猜测的密码或测试目的的随机字符串。基于随机数生成，我们创建了一个生成随机字符串的工具。该工具实现为`genPass.go`，可以在书籍GitHub仓库的`ch02`目录中找到。`genPass.go`的核心功能在下一个函数中：
- en: '[PRE111]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: As we only want to get printable ASCII characters, we limit the range of pseudo-random
    numbers that can be generated. The total number of printable characters in the
    ASCII table is 94\. This means that the range of the pseudo-random numbers that
    the program can generate should be from 0 to 94, without including 94\. Therefore,
    the values of the `MIN` and `MAX` global variables, which are not shown here,
    are 0 and 94, respectively.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只想获取可打印的ASCII字符，我们限制了可以生成的伪随机数的范围。ASCII表中可打印字符的总数是94个。这意味着程序可以生成的伪随机数的范围应该是从0到94，不包括94。因此，`MIN`和`MAX`全局变量的值，这里没有显示，分别是0和94。
- en: The `startChar` variable holds the first ASCII character that can be generated
    by the utility, which, in this case, is the exclamation mark, which has a decimal
    ASCII value of 33\. Given that the program can generate pseudo-random numbers
    up to 94, the maximum ASCII value that can be generated is 93 + 33, which is equal
    to 126, which is the ASCII value of `~`. All generated characters are kept in
    the `temp` variable, which is returned once the `for` loop exits. The `string(startChar[0]
    + byte(myRand))` statement converts the random integers into characters in the
    desired range.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`startChar` 变量保存了工具可以生成的第一个ASCII字符，在这种情况下，是感叹号，其十进制ASCII值为33。鉴于程序可以生成高达94的伪随机数，可以生成的最大ASCII值是93
    + 33，等于126，这是波浪号的ASCII值。所有生成的字符都保存在`temp`变量中，一旦`for`循环退出，就返回该变量。`string(startChar[0]
    + byte(myRand))`语句将随机整数转换为所需范围内的字符。'
- en: The `genPass.go` utility accepts a single parameter, which is the length of
    the generated password. If no parameter is given, `genPass.go` produces a password
    with 8 characters, which is the default value of the `LENGTH` variable.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`genPass.go` 工具接受单个参数，即生成的密码长度。如果没有提供参数，`genPass.go` 将生成一个8个字符的密码，这是`LENGTH`变量的默认值。'
- en: 'Running `genPass.go` produces the following kind of output:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `genPass.go` 会产生以下类型的输出：
- en: '[PRE112]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The first program execution uses the default value for the length of the generated
    string whereas the second program execution creates a random string with 20 characters.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次程序执行使用生成字符串长度的默认值，而第二次程序执行创建了一个包含20个字符的随机字符串。
- en: Generating secure random numbers
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成安全的随机数
- en: If you intend to use these pseudo-random numbers for security-related work,
    it is important that you use the `crypto/rand` package, which implements a cryptographically
    secure pseudo-random number generator. You do not need to define a seed when using
    the `crypto/rand` package.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用这些伪随机数进行与安全相关的工作，那么使用 `crypto/rand` 包非常重要，该包实现了一个密码学安全的伪随机数生成器。使用 `crypto/rand`
    包时，你不需要定义种子。
- en: The following function that is part of the `cryptoRand.go` source code showcases
    how secure random numbers are generated with the functionality of `crypto/rand`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `cryptoRand.go` 源代码的一部分，展示了如何使用 `crypto/rand` 的功能生成安全的随机数。
- en: '[PRE113]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The `rand.Read()` function randomly generates numbers that occupy the entire
    `b` byte slice. You need to decode that byte slice using `base64.URLEncoding.EncodeToString(b)`
    in order to get a valid string without any control or unprintable characters.
    This transformation takes place in the `generatePass()` function, which is not
    shown here.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand.Read()` 函数随机生成填充整个 `b` 字节切片的数字。你需要使用 `base64.URLEncoding.EncodeToString(b)`
    对字节切片进行解码，以获取一个没有控制或不可打印字符的有效字符串。这种转换发生在`generatePass()`函数中，这里没有显示。'
- en: 'Running `cryptoRand.go` creates the following kind of output:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `cryptoRand.go` 会创建以下类型的输出：
- en: '[PRE114]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The output is not different from the one generated by `genPass.go`, it is just
    that the random numbers are generated more securely, which means that they can
    be used in applications where security is important.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与`genPass.go`生成的输出没有不同，只是随机数生成得更安全，这意味着它们可以在需要安全性的应用中使用。
- en: Now that we know how to generate random numbers, we are going to revisit the
    statistics application.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何生成随机数，我们将重新审视统计应用。
- en: Updating the statistics application
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新统计应用
- en: In this section, we are going to improve the functionality and the operation
    of the statistics application. When there is no valid input, we are going to populate
    the statistics application with ten random values, which is pretty handy when
    you want to put lots of data in an application for testing purposes—you can change
    the number of random values to fit your needs. However, keep in mind that this
    takes place when all user input is invalid.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提升统计应用的函数性和操作。当没有有效输入时，我们将使用十个随机值填充统计应用，这在需要将大量数据放入应用进行测试时非常方便——你可以根据需要更改随机值的数量。然而，请注意，这种情况发生在所有用户输入都无效时。
- en: I have randomly generated data in the past in order to put sample data into
    Kafka topics, RabbitMQ queues and MySQL tables.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我过去随机生成数据，以便将样本数据放入Kafka主题、RabbitMQ队列和MySQL表中。
- en: Additionally, we are going to *normalize* the data. Officially, this is called
    *z-normalization* and is helpful for allowing sequences of values to be compared
    more accurately. We are going to use normalization in forthcoming chapters.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将对数据进行*归一化*。官方上，这被称为*Z归一化*，有助于更准确地比较值序列。我们将在后续章节中使用归一化。
- en: 'The function for the normalization of the data is implemented as follows:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 数据归一化的函数实现如下：
- en: '[PRE115]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: From the parameters of the function, you can see that `normalize()` needs the
    mean value and the standard deviation of the sample before normalizing it. Apart
    from that, there is a small trick with `math.Floor()` for defining the accuracy
    of the normalized `float64` values, which in this case is four digits. To get
    two digits of accuracy, you should change the code to `math.Floor((val-mean)/stdDev*100)/100`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数的参数中，你可以看到`normalize()`在归一化之前需要样本的均值和标准差。除此之外，还有一个使用`math.Floor()`的小技巧来定义归一化`float64`值的精度，在这个例子中是四位数字。要获得两位数字的精度，你应该将代码更改为`math.Floor((val-mean)/stdDev*100)/100`。
- en: 'Additionally, the function for generating random floating-point values is implemented
    as follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，生成随机浮点数的函数实现如下：
- en: '[PRE116]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The `rand.Float64()` function returns values from `0` to `1.0`, without including
    `1.0`. The `randomFloat()` function returns values from `min` to `max`, without
    including `max`.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand.Float64()`函数返回从`0`到`1.0`的值，不包括`1.0`。`randomFloat()`函数返回从`min`到`max`的值，不包括`max`。'
- en: You can review the source code of `stats.go` to learn about the remaining implementation
    details. The main difference with the version of the previous chapter is that
    we are now using a slice called `values` for storing all the valid values that
    we are processing.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看`stats.go`的源代码来了解剩余的实现细节。与前一章的版本相比，主要区别在于我们现在使用一个名为`values`的切片来存储所有正在处理的有效值。
- en: 'Running `stats.go` produces the following kind of output:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`stats.go`会产生以下类型的输出：
- en: '[PRE117]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Although randomly generated values might not be perfect at all times, they are
    usually more than enough for testing purposes.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然随机生成的值可能并不总是完美的，但它们通常足以用于测试目的。
- en: Summary
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the basic data types of Go, including numerical
    data types, strings, and errors. Additionally, we learned how to group similar
    values using arrays and slices. Lastly, we learned about the differences between
    arrays and slices and why slices are more versatile than arrays, as well as pointers
    and generating random numbers and strings in order to generate random data.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Go的基本数据类型，包括数值数据类型、字符串和错误。此外，我们学习了如何使用数组来分组相似值，以及如何使用切片。最后，我们学习了数组和切片之间的区别，以及为什么切片比数组更灵活，以及如何生成随机数和字符串以生成随机数据。
- en: One thing that you should remember from this chapter is that a slice is empty
    if its length is equal to `0`. On the other hand, a slice is `nil` if it is equal
    to `nil`—this means that it points to no memory address. The `var s []string`
    statement creates a `nil` slice without allocating any memory. A `nil` slice is
    always empty—the reverse is not always true.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从本章记住的一件事是，如果切片的长度等于 `0`，则切片为空。另一方面，如果切片等于 `nil`，则切片为 `nil`——这意味着它指向没有内存地址。`var
    s []string` 语句创建了一个不分配任何内存的 `nil` 切片。`nil` 切片始终为空——反之则不一定成立。
- en: As far as Go strings are concerned, remember that double quotes define an interpreted
    string literal whereas back quotes define a raw string literal. Most of the time,
    you need double quotes.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Go 字符串，请记住双引号定义的是解释过的字符串字面量，而反引号定义的是原始字符串字面量。大多数情况下，你需要使用双引号。
- en: Last, keep in mind that the use of the `unsafe` package can lead to subtle bugs
    and memory safety issues. The Go language encourages type safety, and the use
    of `unsafe` should be limited to situations where there is a clear understanding
    of the risks and where no safer alternative exists.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，使用 `unsafe` 包可能会导致微妙的错误和内存安全问题。Go 语言鼓励类型安全，`unsafe` 的使用应限制在存在明确风险理解且没有更安全替代方案的情况下。
- en: The next chapter discusses the composite data types of Go, namely, maps and
    structures. Maps can use keys of different data types whereas structures can group
    multiple data types and create new ones that you can access as single entities.
    As you will see in later chapters, structures play a key role in Go.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论 Go 的复合数据类型，即映射和结构体。映射可以使用不同数据类型的键，而结构体可以组合多个数据类型并创建新的类型，你可以将其作为单个实体访问。正如你将在后面的章节中看到的，结构体在
    Go 中扮演着关键角色。
- en: Exercises
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to do the following exercises:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习：
- en: Correct the error in `typedConstants.go`.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修正 `typedConstants.go` 中的错误。
- en: Create and test a function that concatenates two arrays into a new slice.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并测试一个将两个数组连接成新切片的函数。
- en: Create a function that concatenates two arrays into a new array. Do not forget
    to test it with various types of input.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个将两个数组连接成新数组的函数。不要忘记用各种类型的输入测试它。
- en: Create a function that concatenates two slices into a new array.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个将两个切片连接成新数组的函数。
- en: Run `go doc errors Is` in order to learn about `errors.Is()` and try to create
    a small Go program that uses it. After that, modify `error.go` to use `errors.Is()`.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `go doc errors Is` 以了解 `errors.Is()`，并尝试创建一个小型 Go 程序使用它。之后，修改 `error.go`
    以使用 `errors.Is()`。
- en: Modify `stats.go` in order to accept the number of randomly generated values
    as a command line argument.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `stats.go` 以接受随机生成值的数量作为命令行参数。
- en: Modify `stats.go` in order to always use randomly generated data.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `stats.go` 以始终使用随机生成数据。
- en: Additional resources
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The `sort` package documentation: [https://pkg.go.dev/sort](https://pkg.go.dev/sort)'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort` 包文档：[https://pkg.go.dev/sort](https://pkg.go.dev/sort)'
- en: 'The `time` package documentation: [https://pkg.go.dev/time](https://pkg.go.dev/time)'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time` 包文档：[https://pkg.go.dev/time](https://pkg.go.dev/time)'
- en: 'The `crypto/rand` package documentation: [https://pkg.go.dev/crypto/rand](https://pkg.go.dev/crypto/rand)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypto/rand` 包文档：[https://pkg.go.dev/crypto/rand](https://pkg.go.dev/crypto/rand)'
- en: 'Go 1.20 release notes: [https://tip.golang.org/doc/go1.20](https://tip.golang.org/doc/go1.20)'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 1.20 版本发布说明：[https://tip.golang.org/doc/go1.20](https://tip.golang.org/doc/go1.20)
- en: 'The `math/rand` package documentation: [https://pkg.go.dev/math/rand](https://pkg.go.dev/math/rand
    )'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`math/rand` 包文档：[https://pkg.go.dev/math/rand](https://pkg.go.dev/math/rand)'
- en: Join our community on Discord
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6)'
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6)'
