- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic Go Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is stored and manipulated in variables—all Go variables should have a data
    type that is either determined implicitly or declared explicitly. Knowing the
    built-in data types of Go allows you to understand how to manipulate simple data
    values and construct more complex data structures when simple data types are not
    enough or not efficient for a job. **Go being a statically typed and compiled
    programming language** allows the compiler to perform various optimizations and
    checks prior to program execution.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this chapter is all about the basic data types of Go, and
    the second part logically follows, covering the data structures that allow you
    to group data of the same data type, which are arrays and the much more powerful
    slices.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let us begin with something more practical: imagine that you want to read
    data as command line arguments. How can you be sure that what you have read was
    what you expected? How can you handle error situations? What about reading not
    just numbers and strings but dates and times from the command line? Do you have
    to write your own parser for working with dates and times?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, *A Quick Introduction to Go*, we included the entire code of
    the presented source files. However, starting from this chapter, this will not
    always be the case. This serves two purposes: the first one is that you get to
    see the code that really matters, and the second one is that we save book space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will answer all these questions and many more, such as working
    with the `unsafe` package, the internals of slices and how slices are connected
    to arrays, and how to work with pointers in Go. Additionally, it implements utilities
    that generate random numbers and random strings and updates the statistics application.
    So, this chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: The `error` data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-numeric data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping similar data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types and the `unsafe` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the statistics application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We begin this chapter with the `error` data type because errors and error handling
    play a key role in Go.
  prefs: []
  type: TYPE_NORMAL
- en: The error data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides a special data type, named `error`, for representing error conditions
    and error messages—in practice, this means that Go treats errors as values. **To
    program successfully in Go, you should be aware of the error conditions that might
    occur with the functions and methods you are using and handle them accordingly**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you already know from the previous chapter, Go follows a particular convention
    concerning error values: if the value of an `error` variable is `nil`, then there
    is no error. As an example, let us consider `strconv.Atoi()`, which is used for
    converting a `string` value into an `int` value (`Atoi` stands for *ASCII to Int*).
    As specified by its signature, `strconv.Atoi()` returns `(int, error)`. Having
    an error value of `nil` means that the conversion was successful and that you
    can use the `int` value if you want. Having an error value that is not `nil` means
    that the conversion was unsuccessful and that the string input is not a valid
    `int` value.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about `strconv.Atoi()`, you should execute `go doc
    strconv.Atoi` in your terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder what happens if you want to create your own error messages.
    Is this possible? Should you wish to return a custom error, you can use `errors.New()`
    from the `errors` package. This usually happens inside a function other than `main()`
    because `main()` does not return anything to any other function. Additionally,
    a good place to define your custom errors is inside the Go packages you create.
  prefs: []
  type: TYPE_NORMAL
- en: You will most likely work with errors in your programs without needing the functionality
    of the `errors` package. Additionally, **you are not going to need to define custom
    error messages unless you are creating big applications or packages**.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to format your error messages in the way `fmt.Printf()` works, you
    can use the `fmt.Errorf()` function, which simplifies the creation of custom error
    messages—the `fmt.Errorf()` function returns an `error` value just like `errors.New()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should talk about something important: you should have a global error-handling
    tactic in each application that should not change. In practice, this means the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: All error messages should be handled at the same level, which means that all
    errors should either be returned to the calling function or be handled at the
    place they occurred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handling of critical errors should be clearly documented. This means that
    there will be situations where a critical error should terminate the program and
    other times where a critical error might just create a warning message onscreen
    and continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is considered a good practice to send all error messages to the log service
    of your machine because this way the error messages can be examined later. However,
    this is not always true, so exercise caution when setting this up—for example,
    cloud-native apps do not work that way. For cloud-native apps it is better to
    send the error output to standard error so that the error messages do not get
    lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `error` data type is defined as an interface—interfaces are covered in *Chapter
    5*, *Reflection and Interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: Type the following code in your favorite text editor and save it as `error.go`
    in the directory where you put the code for this chapter. Using `ch02` as the
    directory name is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first part is the preamble of the program—`error.go` uses the `fmt`, `os`,
    `strconv`, and `errors` packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements a function named `check()` that returns an `error`
    value. If both input parameters of `check()` are equal to `0`, the function returns
    a custom error message using `errors.New()`—otherwise it returns `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements `formattedError()`, which is a function that returns
    a formatted error message using `fmt.Errorf()`. Among other things, the error
    message prints the user ID of the user who executed the program with a call to
    `os.Getuid()`. When you want to create a custom error message, using `fmt.Errorf()`
    gives you more control over the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the implementation of the `main()` function where you
    can see the use of the `if err != nil` statement multiple times as well as the
    use of `if err == nil`, which is used to make sure that everything was OK before
    executing the desired code.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that although the preceding code compares an error message, this
    is considered a bad practice. It is better to print an error message when it is
    not `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `error.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you know about the `error` data type, how to create custom errors,
    and how to use error values, we will continue with the basic data types of Go
    that can be logically divided into two main categories: *numeric data types* and
    *non-numeric data types*. Go also supports the `bool` data type, which can have
    a value of `true` or `false` only.'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go supports integer, floating-point, and complex number values in various versions
    depending on the memory space they consume—this saves memory and computing time.
    Integer data types can be either signed or unsigned, which is not the case for
    floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The table that follows lists the numeric data types of Go.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `int8` | 8-bit signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `int16` | 16-bit signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `int32` | 32-bit signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `int64` | 64-bit signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | 32- or 64-bit signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `uint8` | 8-bit unsigned integer |'
  prefs: []
  type: TYPE_TB
- en: '| `uint16` | 16-bit unsigned integer |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | 32-bit unsigned integer |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | 64-bit unsigned integer |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | 32- or 64-bit unsigned integer |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | 32-bit floating-point number |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` | 64-bit floating-point number |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64` | Complex number with `float32` parts |'
  prefs: []
  type: TYPE_TB
- en: '| `complex128` | Complex number with `float64` parts |'
  prefs: []
  type: TYPE_TB
- en: The `int` and `uint` data types are special as they are the most efficient sizes
    for signed and unsigned integers on a given platform and can be either 32 or 64
    bits each — their size is defined by Go itself based on the CPU register size.
    The `int` data type is the most widely used numeric data type in Go due to its
    versatility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that follows illustrates the use of numeric data types—you can find
    the entire program as `numbers.go` inside the `ch02` directory of the book GitHub
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates two complex variables in two different ways—both
    ways are perfectly valid and equivalent. Unless you are into mathematics, you
    will most likely not use complex numbers in your programs. However, the direct
    support for complex numbers shows how modern Go is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code continues to work with complex numbers by adding and subtracting
    two pairs of them. Although `cZero` is equal to zero, it is still a complex number
    and a `complex64` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this part, we define two integer variables named `x` and `k`—their data
    type is identified by Go based on their initial values. Both are of type `int`,
    which is what Go prefers to use for storing integer values. Additionally, when
    you divide two integer values, you get an integer result even when the division
    is not perfect. Therefore, if this is not what you want, you should take extra
    actions—this is shown in the next code excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code works with `float64` values and variables. As `n` does not
    have an initial value, it is automatically assigned with the zero value of its
    data type, which is `0` for the `float64` data type. Additionally, the code presents
    a technique for dividing integer values and getting a floating-point result, which
    is the use of `float64()`: `divFloat := float64(x) / float64(k)`.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a type conversion where two integers (`x` and `k`) are converted to
    `float64` values. As the division between two `float64` values is a `float64`
    value, we get the result in the desired data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `numbers.go` creates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that both `c1` and `c2` are `complex128` values, which is the
    preferred complex data type for the machine on which the code was executed. However,
    `c3` is a `complex64` value because it was created using `complex64()`. The value
    of `n` is `0` because the `n` variable was not initialized, which means that Go
    automatically assigned the zero value of its data type to `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding overflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As each variable is stored in memory (bits), there is a limit to how much information
    we can store in the memory space of a variable. Although in this subsection we
    are going to talk about integers, similar rules apply to all numeric data types.
    Go comes with constants in the `math` package that represent the maximum and minimum
    values of integer data types. For example, for the `int` data type, there exist
    the `math.MaxInt` and `math.MinInt` constants that represent the maximum and minimum
    allowed values of an `int` variable, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important part of `overflows.go` can be found in two `for` loops. The first
    one concerns determining the maximum `int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we keep increasing the value of `i` until it reaches
    `math.MaxInt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next `for` loop is about finding out the minimum `int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This time, we keep decreasing the value of `i` until it reaches `math.MinInt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `overflows.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, the maximum `int` value on the current platform (MacBook Pro with
    M1 Max CPU) is `9223372036854775807` and the minimum `int` value is `-9223372036854775808`.
    When we try to increase the maximum `int` value, we will get the minimum `int`
    value instead!
  prefs: []
  type: TYPE_NORMAL
- en: After learning about numeric data types, it is time to learn about non-numeric
    data types, which is the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Non-numeric data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has support for strings, characters, runes, dates, and times. However, Go
    does not have a dedicated char data type. In Go, dates and times are the same
    thing and are represented by the same data type. However, it is up to you to determine
    whether a time and date variable contains valid information or not.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by explaining the string-related data types.
  prefs: []
  type: TYPE_NORMAL
- en: Strings, characters, and runes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go supports the `string` data type for representing strings—strings are enclosed
    within either double quotes or back quotes. A Go string is just *a collection
    of bytes* and can be accessed as a whole or as an array. A single byte can store
    any ASCII character—however, **multiple bytes are usually needed for storing a
    single Unicode character**.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, supporting Unicode characters is a common requirement—Go was designed
    with Unicode support in mind, which is the main reason for having the `rune` data
    type. A `rune` is an `int32` value that is used for representing a single Unicode
    code point, which is an integer value that is used for representing single Unicode
    characters or, less frequently, providing formatting information.
  prefs: []
  type: TYPE_NORMAL
- en: Although a `rune` is an `int32` value, you cannot compare a `rune` with an `int32`
    value. Go considers these two data types as totally different.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a new *byte slice* from a given string by using a `[]byte("A
    String")` statement. Given a byte slice variable `b`, you can convert it into
    a string using the `string(b)` statement. **When working with byte slices that
    contain Unicode characters, the number of bytes in a byte slice is not always
    connected to the number of characters in the byte slice, because most Unicode
    characters require more than one byte for their representation**. As a result,
    when you try to print each single byte of a byte slice using `fmt.Println()` or
    `fmt.Print()`, the output is not text presented as characters but instead integer
    values. If you want to print the contents of a byte slice as text, you should
    either print it using `string(byteSliceVar)` or using `fmt.Printf()` with `%s`
    to tell `fmt.Printf()` that you want to print a string. You can initialize a new
    byte slice with the desired string by using a statement such as `[]byte("My Initialization
    String")`.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover byte slices in more detail in the *Byte slices* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a rune using single quotes: `r := ''€''` and you can print the
    integer value of the bytes that compose it as `fmt.Println(r)`—in this case, the
    integer value is `8364`. Printing it as a single Unicode character requires the
    use of the `%c` control string in `fmt.Printf()`.'
  prefs: []
  type: TYPE_NORMAL
- en: As strings can be accessed as arrays, you can iterate over the runes of the
    string using a `for` loop or point to a specific character if you know its place
    in the string. The length of the string is the same as the number of characters
    found in the string, which is usually not true for byte slices because Unicode
    characters usually require more than one byte.
  prefs: []
  type: TYPE_NORMAL
- en: The following Go code illustrates the use of strings and runes and how you can
    work with strings in your code. You can find the entire program as `text.go` in
    the `ch02` directory of the GitHub repository of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program defines a string literal that contains a Unicode
    character. Then it accesses its first byte as if the string were an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part is about working with runes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a rune named `r`. What makes this a rune is the use of single
    quotes around the `€` character. The rune is an `int32` value and is printed as
    such by `fmt.Println()`. The `%c` control string in `fmt.Printf()` prints a rune
    as a character. Then we iterate over `aString` as a slice or an array using a
    `for` loop with `range` and print the contents of `aString` as runes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we iterate over `aString` as a slice or an array using a `for` loop
    with `range` and print the contents of `aString` as characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `text.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the output shows that we can access a string as an array whereas
    the second line verifies that a rune is an integer value. The third line shows
    what to expect when you print a rune as a string and as a character—the correct
    way is to print it as a character. The fifth line shows how to print a string
    as runes and the last line shows the output of processing a string as characters
    using range and a for loop.
  prefs: []
  type: TYPE_NORMAL
- en: Converting int to string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can convert an integer value into a string in two main ways: using `string()`
    and using a function from the `strconv` package. However, the two methods are
    fundamentally different. The `string()` function converts an integer value into
    a Unicode code point, which is a single character, whereas functions such as `strconv.FormatInt()`
    and `strconv.Itoa()` convert an integer value into a string value with the same
    representation and the same number of characters.'
  prefs: []
  type: TYPE_NORMAL
- en: This is illustrated in the `intString.go` program—its most important statements
    are the following. You can find the entire program in the GitHub repository of
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `intString.go` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The data type of the output is always string, however, `string()` converted
    `100` into `d` because the ASCII representation of `d` is `100`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at converting integers into strings, it is time to learn
    how to work with Unicode text and code points.
  prefs: []
  type: TYPE_NORMAL
- en: The unicode package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `unicode` standard Go package contains various handy functions for working
    with Unicode code points. One of them, which is called `unicode.IsPrint()`, can
    help you to identify the parts of a string that are printable using runes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code excerpt illustrates the functionality of the `unicode` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The for loop iterates over the contents of a string defined as a list of runes
    (`"\x99\x00ab\x50\x00\x23\x50\x29\x9c"`) while `unicode.IsPrint()` examines whether
    the character is printable or not—if it returns `true` then a rune is printable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find this code excerpt inside the `unicode.go` source file in the `ch02`
    directory in the GitHub repository of the book. Running `unicode.go` produces
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This utility is very handy for filtering input or filtering data before printing
    it on screen, storing it in log files, transferring it on a network, or storing
    it in a database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we continue working with text with the help of the `strings`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The strings package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `strings` standard Go package allows you to manipulate UTF-8 strings in
    Go and includes many powerful functions. Many of these functions are illustrated
    in the `useStrings.go` source file, which can be found in the `ch02` directory
    of the book GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with text and text processing, you need to learn all the
    details and functions of the `strings` package, so make sure that you experiment
    with all these functions and create many examples that will help you to clarify
    things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parts of `useStrings.go` are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we are going to use the `strings` package multiple times, we create a convenient
    alias for it named `s` – note that this is considered a bad practice and that
    we are just doing that here to prevent the lines from getting too long. We do
    the same for the `fmt.Printf()` function where we create a global alias using
    a variable named `f`. These two shortcuts reduce the amount of long, repeated
    lines of code. You can use them when learning Go, but this is not recommended
    in any kind of production software as it makes the code less readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first code excerpt is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `strings.EqualFold()` function compares two strings without considering
    their case and returns true when they are the same and false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `strings.Index()` function checks whether the string of the second parameter
    can be found in the string that is given as the first parameter and returns the
    index where it was found for the first time. On an unsuccessful search, it returns
    `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `strings.HasPrefix()` function checks whether the given string, which is
    the first parameter, begins with the string that is given as the second parameter.
    In the preceding code, the first call to `strings.HasPrefix()` returns true, whereas
    the second returns false. Similarly, `strings.HasSuffix()` checks whether the
    given string ends with the second string. Both functions consider the case of
    the input string and the case of the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The handy `strings.Fields()` function splits the given string around one or
    more whitespace characters as defined by the `unicode.IsSpace()` function and
    returns a slice of substrings found in the input string. If the input string contains
    whitespace characters only, it returns an empty slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `strings.Split()` function allows you to split the given string according
    to the desired separator string—the `strings.Split()` function returns a string
    slice. Using `""` as the second parameter of `strings.Split()` allows you to *process
    a string character by character*.
  prefs: []
  type: TYPE_NORMAL
- en: The `strings.Replace()` function takes four parameters. The first parameter
    is the string that you want to process. The second parameter contains the string
    that, if found, will be replaced by the third parameter of `strings.Replace()`.
    The last parameter is the maximum number of replacements that are allowed to happen.
    If that parameter has a negative value, then there is no limit to the allowed
    number of replacements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `strings.SplitAfter()` function splits its first parameter string into substrings
    based on the separator string that is given as the second parameter to the function.
    The separator string is included in the returned slice.
  prefs: []
  type: TYPE_NORMAL
- en: The last lines of code define a trim function named `trimFunction` that is used
    as the second parameter to `strings.TrimFunc()` in order to filter the given input
    based on the return value of the trim function—in this case, the trim function
    keeps all letters and nothing else due to the `unicode.IsLetter()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `useStrings.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Visit the documentation page of the strings package at [https://pkg.go.dev/strings](https://pkg.go.dev/strings)
    for the complete list of available functions. You will see the functionality of
    the `strings` package in other places in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Enough with strings and text, the next section is about working with dates and
    times in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Times and dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, we need to work with date and time information to store the time an entry
    was last used in a database or the time an entry was inserted into a database.
  prefs: []
  type: TYPE_NORMAL
- en: The king of working with times and dates in Go is the `time.Time` data type,
    which represents an instant in time with nanosecond precision. Each `time.Time`
    value is associated with a location (time zone).
  prefs: []
  type: TYPE_NORMAL
- en: If you are a UNIX person, you might already know about the UNIX epoch time and
    wonder how to get it in Go. The `time.Now().Unix()` function returns the popular
    UNIX epoch time, which is the number of seconds that have elapsed since `00:00:00
    UTC, January 1, 1970`. If you want to convert the UNIX time to the equivalent
    `time.Time` value, you can use the `time.Unix()` function. If you are not a UNIX
    person, then you might not have heard about the UNIX epoch time before, but now
    you know what it is!
  prefs: []
  type: TYPE_NORMAL
- en: The `time.Since()` function calculates the time that has passed since a given
    time and returns a `time.Duration` variable—the duration data type is defined
    as `type Duration int64`. Although a `Duration` is, in reality, an `int64` value,
    you cannot compare or convert a duration to an `int64` value implicitly because
    Go does not allow implicit data type conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The single most important topic about Go and dates and times is the way Go parses
    a string in order to convert it into a date and a time. The reason this is important
    is that usually such input is given as a string and not as a valid date variable.
    The function used for parsing is called `time.Parse()` and its full signature
    is `Parse(layout, value string) (Time, error)`, where `layout` is the parse string
    and `value` is the input that is being parsed. The `time.Time` value that is returned
    is a moment in time with nanosecond precision and contains both date and time
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The next table shows the most widely used strings for parsing dates and times.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parse Value** | **Meaning (examples)** |'
  prefs: []
  type: TYPE_TB
- en: '| `03` | 12-hour value (12pm, 07am) |'
  prefs: []
  type: TYPE_TB
- en: '| `15` | 24-hour value (23, 07) |'
  prefs: []
  type: TYPE_TB
- en: '| `04` | Minutes (55, 15) |'
  prefs: []
  type: TYPE_TB
- en: '| `05` | Seconds (5, 23) |'
  prefs: []
  type: TYPE_TB
- en: '| `Mon` | Abbreviated day of week (Tue, Fri) |'
  prefs: []
  type: TYPE_TB
- en: '| `Monday` | Day of week (Tuesday, Friday) |'
  prefs: []
  type: TYPE_TB
- en: '| `02` | Day of month (15, 31) |'
  prefs: []
  type: TYPE_TB
- en: '| `2006` | Year with 4 digits (2020, 2004) |'
  prefs: []
  type: TYPE_TB
- en: '| `06` | Year with the last 2 digits (20, 04) |'
  prefs: []
  type: TYPE_TB
- en: '| `Jan` | Abbreviated month name (Feb, Mar) |'
  prefs: []
  type: TYPE_TB
- en: '| `January` | Full month name (July, August) |'
  prefs: []
  type: TYPE_TB
- en: '| `MST` | Time zone (EST, UTC) |'
  prefs: []
  type: TYPE_TB
- en: The previous table shows that if you want to parse the `30 January 2023` string
    and convert it into a Go date variable, you should match it against the `02 January
    2006` string because this string indicates the expected format of the input—you
    cannot use anything else in its place when matching a string like `30 January
    2023`. Similarly, if you want to parse the `15 August 2023 10:00` string, you
    should match it against the `02 January 2006 15:04` string because this specifies
    the expected format of the input.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation of the `time` package ([https://pkg.go.dev/time](https://pkg.go.dev/time))
    contains even more detailed information about parsing dates and times—however,
    the ones presented here should be more than enough for regular use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to work with dates and times, it is time to learn more
    about working with time zones.
  prefs: []
  type: TYPE_NORMAL
- en: Working with different time zones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The presented utility accepts a date and a time and converts them into different
    time zones. This can be particularly handy when you want to preprocess log files
    from different sources that use different time zones to convert these different
    time zones into a common one. Once again, you need `time.Parse()` in order to
    convert a valid input into a `time.Time` value before doing the conversions. This
    time the input string contains the time zone and is parsed by the `"``02 January
    2006 15:04 MST"` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to convert the parsed date and time into New York time, the program
    uses the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This technique is used multiple times in `convertTimes.go`.
  prefs: []
  type: TYPE_NORMAL
- en: If a command line argument contains any space characters, you should put it
    in double quotes for the UNIX shell to treat it as a single command line argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `convertTimes.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the last execution of the program, the code must parse `25` as the hour of
    the day, which is wrong and generates the `hour out of range` error message.
  prefs: []
  type: TYPE_NORMAL
- en: There is a known Go issue related to the parsing of times and dates that you
    can learn about at [https://github.com/golang/go/issues/63345](https://github.com/golang/go/issues/63345).
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection is about constant values.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go supports constants, which behave like variables but cannot change their values.
    Constants in Go are defined with the help of the `const` keyword. Constants can
    be either *global or local*. However, if you are defining too many constant values
    with a local scope, you might need to rethink your approach.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit you get from using constants in your programs is the guarantee
    that their value will not change during program execution. Strictly speaking,
    the value of a constant variable is defined at compile time, not at runtime—this
    means that it is included in the binary executable. Behind the scenes, Go uses
    Boolean, string, or numeric as the type for storing constant values because this
    gives Go more flexibility when dealing with constants.
  prefs: []
  type: TYPE_NORMAL
- en: Some possible uses of constants include defining configuration values such as
    the maximum number of connections or the TCP/IP port number used and defining
    physical constants such as the speed of light or the gravity on earth.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection discusses the constant generator iota, which is a handy
    way of creating sequences of constants.
  prefs: []
  type: TYPE_NORMAL
- en: The constant generator iota
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *constant generator iota* is used for declaring a sequence of related values
    that use incrementing numbers without the need to explicitly type each one of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts related to the `const` keyword, including the constant generator
    iota, are illustrated in the `constants.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this part, we declare two new types named `Digit` and `Power2` that will
    be used in a while, and four new constants named `PI`, `C1`, `C2`, and `C3`.
  prefs: []
  type: TYPE_NORMAL
- en: A Go type is a way of defining a new named type that uses the same underlying
    type as an existing type. This is mainly used for differentiating between different
    types that might use the same kind of data. The `type` keyword can also be used
    for defining structures and interfaces, which is not the case here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a constant named `s1`. Here you also see the definition
    of a constant generator iota based on `Digit`, which is equivalent to the next
    declaration of five constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Although we are defining constants inside `main()`, constants can normally be
    found outside of `main()` or any other function or method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `constants.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There is another constant generator iota here that is different than the previous
    one. Firstly, you can see the use of the underscore character in a `const` block
    with a constant generator iota, which allows you to skip unwanted values. Secondly,
    the value of iota always increments and can be used in expressions, which is what
    occurred in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us see what really happens inside the `const` block. For `p2_0`, iota
    has the value of `0` and `p2_0` is defined as `1`. For `p2_2`, iota has the value
    of `2` and `p2_2` is defined as the result of the expression `1 << 2`, which is
    `00000100` in binary representation. The decimal value of `00000100` is `4`, which
    is the result and the value of `p2_2`. Analogously, the value of `p2_4` is `16`
    and the value of `p2_6` is `64`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `constants.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Typed and untyped constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Constant values can have a data type**. This can be restrictive because a
    constant value with a data type can only operate with values and variables of
    the same data type, but it can save you from bugs because the compiler can catch
    such situations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code excerpt from `typedConstants.go` is going to show the difference between
    *typed* and *untyped constants*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `untypedConstant` does not have a data type associated with it whereas
    `typedConstant` does. If you try to run `typedConstants.go`, the compiler is not
    going to be able to compile it and it is going to produce the following error
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The cause of the error condition can be found in the generated output: `mismatched
    types int and int16`. Put simply, `i` is an `int` variable whereas `typedConstant`
    is an `int16` value and Go is unable to perform their multiplication because the
    data types of the variables do not match. On the other hand, there are no issues
    with the `i*untypedConstant` multiplication because `untypedConstant` does not
    have a data type.'
  prefs: []
  type: TYPE_NORMAL
- en: Having data is good but what happens when you have lots of similar data? Do
    you need to have lots of variables to hold this data or is there a better way
    to do so? Go answers these questions by introducing arrays and slices.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping similar data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when you want to keep multiple values of the same data type
    under a single variable and access them using an index number. The simplest way
    to do that in Go is by using arrays or slices. *Arrays* are the most widely used
    data structures and can be found in almost all programming languages due to their
    simplicity and speed of access. Go provides an alternative to arrays that is called
    a *slice*. The subsections that follow help you understand the differences between
    arrays and slices so that you know which data structure to use and when. The quick
    answer is that **you can use slices instead of arrays almost anywhere in Go,**
    but we are also demonstrating arrays because they can still be useful and because
    slices are implemented by Go using arrays!
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to begin our discussion about arrays by examining their core characteristics
    and limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: When defining an array variable, you must define its size. Otherwise, you should
    put `[...]` in the array declaration and let the Go compiler find out the length
    for you. So you can create an array with 4 string elements either as `[4]string{"Zero",
    "One", "Two", "Three"}` or as `[...]string{"Zero", "One", "Two", "Three"}`. If
    you put nothing in the square brackets, then a slice is going to be created instead.
    As it contains four elements, the (valid) indexes for that array are `0`, `1`,
    `2`, and `3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot change the size of an array after you have created it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you pass an array to a function, **Go creates a copy of that array** and
    passes that copy to that function—therefore any changes you make to an array inside
    a function are lost when the function exits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, arrays in Go are not very powerful, which is the main reason that
    Go has introduced an additional data structure named slice that is like an array
    but is dynamic in nature, as explained in the next subsection. However, data in
    both arrays and slices is accessed the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slices in Go are more powerful than arrays mainly because they are dynamic,
    which means that they can grow or shrink after creation as needed. Additionally,
    any changes you make to a slice inside a function also affect the original slice.
    Keep in mind that this is usually the case, but it is not always true—as discussed
    in a while, all slices have an underlying array for storing the data. Only changes
    that do not cause an allocation of the underlying array are reflected back to
    the caller function. However, functions working with slices do not usually change
    the size of the slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how does this happen? Strictly speaking, **all parameters in Go are passed
    by value**—there is no other way to pass parameters in Go. However, you can explicitly
    pass a pointer to a variable in order to pass by reference. A **slice value is
    a header that contains a pointer to an underlying array where the elements are
    actually stored, the length of the array, and its capacity**—the capacity of a
    slice is explained in the next subsection. Note that the slice value does not
    include its elements, **just a pointer to the underlying array**. So, when you
    pass a slice to a function, Go makes a copy of that header and passes it to the
    function. This copy of the slice header includes the pointer to the underlying
    array. That slice header is defined in the `reflect` package ([https://pkg.go.dev/reflect#SliceHeader](https://pkg.go.dev/reflect#SliceHeader))
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: A side effect of passing the slice header is that it is faster to pass a slice
    to a function because Go does not need to make a copy of the slice and its elements,
    just a copy of the slice header.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a slice using `make()` or like an array without specifying its
    size or using `[...]`. If you do not want to initialize a slice, then using `make()`
    is better and faster. However, if you want to initialize it at the time of creation,
    then `make()` cannot help you. As a result, you can create a slice with three
    `float64` elements as `aSlice := []float64{1.2, 3.2, -4.5}`. Creating a slice
    with space for three `float64` elements with `make()` is as simple as executing
    `make([]float64, 3)`. Each element of that slice has a value of `0`, which is
    the zero value of the `float64` data type.
  prefs: []
  type: TYPE_NORMAL
- en: Both slices and arrays can have many dimensions—creating a slice with two dimensions
    with `make()` is as simple as writing `make([][]int, 2)`. This returns a slice
    with two dimensions where the first dimension is 2 (rows) and the second dimension
    (columns) is unspecified and should be explicitly specified when adding data to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to define and initialize a slice with two dimensions at the same
    time, you should execute something similar to `twoD := [][]int{{1, 2, 3}, {4,
    5, 6}}`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the length of an array or a slice using `len()`. You can add new
    elements to a full slice using the `append()` function. `append()` automatically
    allocates the required memory space. Keep in mind that you should assign the return
    value of `append()` back to the desired variable as this is not an in-place change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example that follows clarifies many things about slices—feel free to experiment
    with it. Type the following code and save it as `goSlices.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `append()` commands add two new elements to `aSlice`. As stated before,
    the result of `append()` is not in-place and must be assigned to the desired variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once a slice has no place left for more elements, you can only add new elements
    to it using `append()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how to create a 2D slice variable named `twoD` and
    initialize it at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The previous part shows how to create a 2D slice with `make()`. What makes the
    `make2D` a 2D slice is the use of `[][]int` in `make()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `goSlices.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: About slice length and capacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both arrays and slices support the `len()` function for finding out their length.
    However, slices also have an additional property called *capacity* that can be
    found using the `cap()` function. The capacity of a slice is important when you
    want to select a part of a slice or when you want to reference an array using
    a slice.
  prefs: []
  type: TYPE_NORMAL
- en: '**The capacity shows how much a slice can be expanded without the need to allocate
    more memory and change the underlying array**. Although after slice creation the
    capacity of a slice is handled by Go, a developer can define the capacity of a
    slice at creation time using the `make()` function—after that, the capacity of
    the slice doubles each time the length of the slice is about to become bigger
    than its current capacity. The first argument of `make()` is the type of the slice
    and its dimensions, the second is its initial length, and the third, which is
    optional, is the capacity of the slice. Although the data type of a slice cannot
    change after creation, the other two properties can change.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing something like `make([]int, 3, 2)` generates an error message because
    at any given time the capacity of a slice (`2`) cannot be smaller than its length
    (`3`).
  prefs: []
  type: TYPE_NORMAL
- en: The figure that follows illustrates how length and capacity work in slices.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21003_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: How slice length and capacity are related'
  prefs: []
  type: TYPE_NORMAL
- en: 'For those of you that prefer code, here is a small Go program that showcases
    the length and capacity properties of slices. Type it and save it as `capLen.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the capacity of a is the same as its length, which is 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the capacity of slice `b` is the same as its length, which is `5`
    because this is the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This time the capacity of slice `aSlice` is the same as its length, not because
    Go decided to do so but because we specified it in the `make()` call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When you add a new element to slice `aSlice`, its capacity is doubled and becomes
    `8`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `...` operator expands `[]int{-1, -2, -3, -4}` into multiple arguments and
    `append()` appends each argument one by one to `aSlice`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `capLen.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Setting the correct capacity of a slice, if known in advance, will make your
    programs faster because Go will not have to allocate a new underlying array and
    have all the data copied over. This is important when dealing with very large
    slices.
  prefs: []
  type: TYPE_NORMAL
- en: Working with slices is good but what happens when you want to work with a continuous
    part of an existing slice? Is there a practical way to select a part of a slice?
    Fortunately, the answer is yes—the next subsection sheds some light on selecting
    a continuous part of a slice.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a part of a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go allows you to select parts of a slice, provided that all desired elements
    are next to each other. This can be handy when you select a range of elements
    and you do not want to give their indexes one by one. In Go, you select a part
    of a slice by specifying (directly or indirectly) two indexes, where the first
    one is the beginning of the selection and the second one is the end of the selection,
    without including the element at that index, separated by `:`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to process all the command line arguments of a utility apart from
    the first one, which is its file path, you can assign it to a new variable (`arguments
    := os.Args`) for ease of use and use the `arguments[1:]` notation to skip the
    first command line argument.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a variation where you can add a third parameter that controls
    the capacity of the resulting slice. So, using `aSlice[0:2:4]` selects the first
    2 elements of a slice (at indexes `0` and `1`) and creates a new slice with a
    maximum capacity of `4`. The resulting capacity is defined as the result of the
    `4-0` subtraction where 4 is the maximum capacity and 0 is the first index—if
    the first index is omitted, it is automatically set to `0`. In this case, the
    capacity of the result slice will be `4` because `4-0` equals `4`.
  prefs: []
  type: TYPE_NORMAL
- en: If we had used `aSlice[2:4:4]`, we would have created a new slice with the `aSlice[2]`
    and `aSlice[3]` elements and with a capacity of `4-2`. Lastly, the resulting capacity
    cannot be bigger than the capacity of the original slice because in that case,
    you would need a different underlying array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code into your favorite editor and save it as `partSlice.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this first part, we define a new slice named `aSlice` that has 10 elements.
    Its capacity is the same as its length. Both the `0:5` and `:5` notations select
    the first 5 elements of the slice, which are the elements found at indexes `0`,
    `1`, `2`, `3`, and `4`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Given the length of the slice (`l`), we can select the last two elements of
    the slice either as `l-2:l` or as `l-2:`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Initially, the capacity of `t` will be `10-0`, which is `10`. In the second
    case, the capacity of `t` will be `10-2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The capacity of `t` is now `6-0` and its length is going to be `5` because we
    have selected the first five elements of slice `aSlice`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of `partSlice.go` is presented in small chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The previous line is the output of `fmt.Println(aSlice)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The previous two lines are generated from `fmt.Println(aSlice[0:5])` and `fmt.Println(aSlice[:5])`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Analogously, the previous two lines are generated from `fmt.Println(aSlice[l-2
    : l])` and `fmt.Println(aSlice[l-2:])`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The last three lines print the length and the capacity of `aSlice[0:5:10]`,
    `aSlice[2:5:10]`, and `aSlice[:5:6]`.
  prefs: []
  type: TYPE_NORMAL
- en: Byte slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A byte slice is a slice of the `byte` data type (`[]byte`). Go knows that most
    byte slices are used to store strings and so makes it easy to switch between this
    type and the `string` type. There is nothing special in the way you can access
    a byte slice compared to the other types of slices. What is special is that **Go
    uses byte slices for performing file I/O operations because they allow you to
    determine with precision the amount of data you want to read or write to a file**.
    This happens because bytes are a universal unit among computer systems.
  prefs: []
  type: TYPE_NORMAL
- en: As Go does not have a data type for storing single characters, it uses `byte`
    and `rune` for storing character values. A single byte can store a single ASCII
    character only whereas a rune can store Unicode characters. As a result, a rune
    can occupy multiple bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The small program that follows illustrates how you can convert a byte slice
    into a string and vice versa, which you need for most file I/O operations—type
    it and save it as `byteSlices.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: An empty byte slice contains zeros—in this case, 12 zeros.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the size of `b` is the size of the string `"Byte slice €"`, without
    the double quotes—`b` now points to a different memory location than before, which
    is where `"Byte slice €"` is stored. **This is how you convert a string into a
    byte slice**.
  prefs: []
  type: TYPE_NORMAL
- en: As Unicode characters like `€` need more than one byte for their representation,
    the length of the byte slice might not be the same as the length of the string
    that it stores.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how to print the contents of a byte slice as text using
    two techniques. The first one is by using the `%s` control string and the second
    one using `string()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code prints the real length of the byte slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `byteSlices.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the output proves that although the `b` byte slice contains
    12 characters, it has a size of 14.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an element from a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no default function for deleting an element from a slice without using
    a package such as`slices`, which means that if you need to delete an element from
    a slice, you must write your own code. However, starting with Go 1.21, you can
    use `slices.Delete()` for that purpose. Therefore, this subsection is relevant
    when using an older Go version or when you want to manually delete an element.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an element from a slice can be tricky, so this subsection presents
    two techniques for doing so. The first technique virtually divides the original
    slice into two slices, split at the index of the element that needs to be deleted.
    Neither of the two slices includes the element that is going to be deleted. After
    that, it concatenates these two slices and creates a new one.
  prefs: []
  type: TYPE_NORMAL
- en: The second technique copies the last element at the place of the element that
    is going to be deleted and creates a new slice by excluding the last element from
    the original slice. However, this particular technique changes the order of the
    slice elements, which in some cases might be important.
  prefs: []
  type: TYPE_NORMAL
- en: The next figure shows a graphical representation of the two techniques for deleting
    an element from a slice.
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, design  Description automatically
    generated](img/B21003_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Deleting an element from a slice'
  prefs: []
  type: TYPE_NORMAL
- en: The following program shows the two techniques that can be used for deleting
    an element from a slice. Create a text file by typing the following code—save
    it as `deleteSlice.go`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here we logically divide the original slice into two slices. The two slices
    are split at the index of the element that needs to be deleted. After that, we
    concatenate these two slices with the help of `...`.
  prefs: []
  type: TYPE_NORMAL
- en: Go supports the `...` operator, which is used for exploding a slice or an array
    into multiple arguments before appending it to an existing slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we see the second technique in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We replace the element that we want to delete with the last element using the
    `aSlice[i] = aSlice[len(aSlice)-1]` statement and then we remove the last element
    with the `aSlice = aSlice[:len(aSlice)-1]` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `deleteSlice.go` produces the following kind of output, depending on
    your input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As the slice has nine elements, you can delete the element at index value `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As the slice has only nine elements, you cannot delete an element with an index
    value of `10` from the slice.
  prefs: []
  type: TYPE_NORMAL
- en: How slices are connected to arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, behind the scenes, **a slice is implemented using an underlying
    array**. The length of the underlying array is the same as the capacity of the
    slice and there exist pointers that connect the slice elements to the appropriate
    array elements.
  prefs: []
  type: TYPE_NORMAL
- en: You can understand that by connecting an existing array with a slice, Go allows
    you to reference an array or a part of an array using a slice. This has some strange
    capabilities including the fact that the changes to the slice affect the referenced
    array! However, when the capacity of the slice changes, the connection to the
    array ceases to exist! This happens because when the capacity of a slice changes,
    so does the underlying array, and the connection between the slice and the original
    array does not exist anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code and save it as `sliceArrays.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is a function that changes the first element of its input slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here we define an array named a with 4 elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here we connect `S0` with the first element of the array `a` and we print it.
    Then we change the value of `S0[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this part, we associate `S12` with `a[1]` and `a[2]`. Therefore `S12[0] =
    a[1]` and `S12[1] = a[2]`. Then, we change the values of both `S12[0]` and `S12[1]`.
    These two changes will also change the contents of a. Put simply, `a[1]` takes
    the new value of `S12[0]` and `a[2]` takes the new value of `S12[1]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: And we print variable `a`, which has not changed at all in a direct way. However,
    due to the connections of `a` with `S0` and `S12`, the contents of `a` have changed!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As the slice and the array are connected, any changes you make to the slice
    will also affect the array even if the changes take place inside a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As the capacity of `S0` changes, it is no longer connected to the same underlying
    array (`a`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: However, array `a` and slice `S12` are still connected because the capacity
    of `S12` has not changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we print the final versions of `a`, `S0`, and `S12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `sliceArrays.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection shows a technique for catching out of bound errors on slices
    as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Catching out of bounds errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, we present a technique for catching out of bounds errors.
    The technique is illustrated with the help of two functions. The first function
    is the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the case of `foo()`, no bound checking is performed on slice `s`. This means
    that we can use any index on it without being sure that we will get that index
    in the first place and without the compiler performing any checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that the compiler is not going to check the slice provided as
    a parameter to the function. However, the compiler is going to refuse to compile
    the preceding code. The generated error is going to be `invalid argument: index
    3 out of bounds [0:3]`. The reason that the error was caught is that although
    we get three elements from `slice` and put them into `a`, we are using four elements
    from array `a`, which is clearly not allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us now discuss the use of the `copy()` function in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The copy() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go offers the `copy()` function for copying an existing array to a slice or
    an existing slice to another slice. However, the use of `copy()` can be tricky
    because the destination slice is not auto-expanded if the source slice is bigger
    than the destination slice. Additionally, if the destination slice is bigger than
    the source slice, then `copy()` does not empty the elements from the destination
    slice that did not get copied. This is better illustrated in the figure that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, number  Description automatically
    generated](img/B21003_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The use of the copy() function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program illustrates the use of `copy()`—type it in your favorite
    text editor and save it as `copySlice.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here we run the `copy(a1, a2)` command. In this case, the `a2` slice is bigger
    than `a1`. After `copy(a1, a2)`, `a2` remains the same, which makes perfect sense
    as `a2` is the input slice, whereas the first element of `a2` is copied to the
    first element of `a1` because `a1` has space for a single element only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `a5` is bigger than `a1`. Once again, after `copy(a1, a5)`, `a5`
    remains the same whereas `a5[0]` is copied to `a1[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In this last case, `a2` is shorter than `a5`. This means that the entire `a2`
    is copied into `a5` as there is enough room. As the length of `a2` is `2`, only
    the first 2 elements of `a5` change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `copySlice.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `copy(a1, a2)` statement does not alter the `a2` slice, just `a1`. As the
    size of `a1` is `1`, only the first element from `a2` is copied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `copy(a1, a5)` alters `a1` only. As the size of `a1` is `1`, only
    the first element from `a5` is copied to `a1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Last, `copy(a5, a2)` alters `a5`. As the size of `a5` is `5`, only the first
    two elements from `a5` are altered and become the same as the first two elements
    of `a2`, which has a size of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when you want to present your information sorted and you want
    Go to do the job for you. In this subsection, we are going to see how to sort
    slices of various standard data types using the functionality offered by the `sort`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The `sort` package can sort slices of built-in data types without the need to
    write any extra code. Additionally, Go provides the `sort.Reverse()` function
    for sorting in reverse order. However, what is really interesting is that `sort`
    allows you to write your own sorting functions for custom data types by implementing
    the `sort.Interface` interface—you will learn more about `sort.Interface` and
    interfaces in general in *Chapter 5*, *Reflection and Interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: With Go generics, the `slices` package was introduced in the standard Go library—the
    `slices` package is discussed in *Chapter 4*, *Go Generics*.
  prefs: []
  type: TYPE_NORMAL
- en: So, you can sort a slice of integers saved as `sInts` by typing `sort.Ints(sInts)`.
    When sorting a slice of integers in reverse order using `sort.Reverse()`, you
    need to pass the desired slice to `sort.Reverse()` using `sort.IntSlice(sInts)`
    because the `IntSlice` type implements the `sort.Interface` internally, which
    allows you to sort in a different way than usual. The same applies to the other
    standard Go data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a text file with following the code that illustrates the use of sort
    and name it `sortSlice.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As `sort.Interface` knows how to sort integer values, it is trivial to sort
    them in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The same rules apply when sorting floating point numbers and strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `sortSlice.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The output illustrates how the original slices were sorted in both normal and
    reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses pointers in Go. Although Go does not support pointers
    in the same way that C does, Go allows you to work with pointers and pointer variables.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has **support for pointers but not for pointer arithmetic**, which is the
    cause of many bugs and errors in programming languages like C. A pointer is the
    memory address of a variable. You need to *dereference a pointer* in order to
    get its value—dereferencing is performed using the `*` character in front of the
    pointer variable. Additionally, you can get the memory address of a normal variable
    using an `&` in front of it.
  prefs: []
  type: TYPE_NORMAL
- en: The next diagram shows the difference between a pointer to an `int` and an `int`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, rectangle, font  Description automatically
    generated](img/B21003_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: An int variable and a pointer to an int'
  prefs: []
  type: TYPE_NORMAL
- en: If a pointer variable points to an existing regular variable, then any changes
    you make to the stored value using the pointer variable will modify the regular
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The format and the values of memory addresses might be different between different
    machines, different operating systems, and different architectures.
  prefs: []
  type: TYPE_NORMAL
- en: You might ask, what is the point of using pointers when there is no support
    for pointer arithmetic? The main benefit you get from pointers is that passing
    a variable to a function as a pointer (we can call that by reference) does not
    discard any changes you make to the value of that variable inside that function
    when the function returns. There exist times where you want that functionality
    because it simplifies your code, but the price you pay for that simplicity is
    being extra careful with what you do with a pointer variable.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that slices are passed to functions without the need to use a pointer—it
    is Go that passes the pointer to the underlying array of a slice and there is
    no way to change that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from reasons of simplicity, there exist three more reasons for using
    pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: Pointers allow you to share and manipulate data between functions without explicitly
    returning values back to the caller. However, when sharing data between functions
    and goroutines, you should be extra careful with *race condition* issues. This
    allows multiple functions to try to alter the value of the same pointer variable
    at the same time, which causes unpredictable behavior in the final state of that
    pointer variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers are also very handy when you want to tell the difference between the
    zero value of a variable and a value that is not set (`nil`). This is particularly
    useful with structures because pointers (and therefore pointers to structures,
    which are fully covered in the next chapter) can have a `nil` value, which means
    that you can compare a pointer to a structure with a `nil` value, which is not
    allowed for normal structure variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having support for pointers and, more specifically, pointers to structures allows
    Go to support data structures such as linked lists and binary trees, which are
    widely used in computer science. Therefore, you are allowed to define a structure
    field of a `Node` structure as `Next *Node`, which is a pointer to another `Node`
    structure. Without pointers, this would have been difficult to implement and possibly
    too slow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code illustrates how you can use pointers in Go—create a text
    file named `pointers.go` and type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This is a structure with two fields named `field1` and `field2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This is a function that gets a pointer to a `float64` variable as input. As
    we are using a pointer, all changes to the function parameter inside the function
    will be persistent. Additionally, there is no need to return something.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This is a function that requires a `float64` parameter as input and returns
    a pointer to a `float64`. To return the memory address of a regular variable,
    you need to use `&` (`&temp`). In this case, Go is smart enough to realize that
    the pointer to `temp` escapes, so its value will be heap allocated, ensuring that
    the caller has a valid reference to work with as opposed to stack allocation where
    the reference is invalid when the function returns and the stack frame is eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This is a function that requires a pointer to a `float64` as input and returns
    a pointer to a `float64` as output. The `*x` notation is used for getting the
    value stored in the memory address stored in `x` and is called dereferencing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: To get the memory address of a regular variable named `f`, you should use the
    `&f` notation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '`fP` is now a pointer to the memory address of the `f` variable. Any changes
    to the value stored in the `fP` memory address influence the `f` value as well.
    However, this is only true for as long as `fP` points to the memory address of
    the `f` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The value of `f` does not change because the function only uses its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the value of `f`, as well as the value stored in the `fP` memory
    address, do not change because the `bothPointers()` function does not make any
    changes to the value stored in the `fP` memory address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The `k` variable is a pointer to an `aStructure` structure. As `k` points to
    nowhere, Go makes it point to `nil`, which is the zero value for pointers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: As `k` is `nil`, we are allowed to assign it to an empty `aStructure` value
    with `new(aStructure)` without losing any data—`new()` allocates the required
    memory and sets the pointer to that memory. Now, `k` is no longer `nil` but both
    fields of `aStructure` have the zero values of their data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is just making sure that `k` is not `nil`. You might consider
    that check redundant, but it does not hurt to double-check because if you try
    to dereference a `nil` pointer, your program is going to crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `pointers.go` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We are going to revisit pointers in the next chapter when we discuss structures.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a slice to an array or an array pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, we are going to learn how to convert a slice to an array
    or an array pointer. The first part of `slice2array.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code we convert `slice` into an array pointer that points to
    an array with 3 elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the `slice2array.go` code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code we converted a slice into an array with 3 elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `slice2array.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines of output have to do with the slice-to-array-pointer conversion
    whereas the last two have to do with the slice-to-array conversion. The second
    line of output verifies that we are dealing with a pointer to an array with three
    elements (`*[3]uint8`) and the last line verifies that we are dealing with an
    array with three elements (`[3]int`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss data types and the `unsafe` package.
  prefs: []
  type: TYPE_NORMAL
- en: Data types and the unsafe package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `unsafe` package in Go provides facilities for performing operations that
    break the type safety guarantees of Go. It is a powerful but potentially dangerous
    package, and its use is discouraged in most Go code. Therefore, the `unsafe` package
    is intended for specific situations where low-level programming is necessary,
    such as interfacing with non-Go code, dealing with memory layout, or implementing
    certain advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to discuss four functions of the `unsafe` package
    that are related to strings and slices. You might not have to use any of them
    on a regular basis, but it is good to know about them because they provide speed
    when dealing with large strings or slices that take lots of memory because they
    **deal with memory addresses directly**, which might be very dangerous if you
    do not know what you are doing. The four functions that we are going to discuss
    are `unsafe.StringData()`, `unsafe.String()`, `unsafe.Slice()`, and `unsafe.SliceData()`.
    You can learn more details about their usage using `go doc`.
  prefs: []
  type: TYPE_NORMAL
- en: Please bear in mind that the `unsafe` package is called unsafe for a reason,
    and that in most cases you should not use this package!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `typeUnsafe.go` comes with two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: These two particular functions convert a byte slice to a string and vice versa
    using `unsafe.String()` and `unsafe.Slice()`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `unsafe.String()` function requires a pointer parameter and a length value
    in order to know how far from the pointer it is going to go for the data. The
    `unsafe.SliceData()` function returns a pointer to the underlying array of the
    function argument slice.
  prefs: []
  type: TYPE_NORMAL
- en: '`unsafe.Slice()` operates in an analogous way and returns a slice whose underlying
    array starts at the given pointer value and whose length and capacity are equal
    to the integer value that is passed as its second parameter—it is important to
    understand that when working with memory addresses via pointers and the `unsafe`
    package, we need to specify how far in memory we need to go.'
  prefs: []
  type: TYPE_NORMAL
- en: As Go strings are immutable, the bytes returned by `unsafe.StringData()` should
    not be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `typeUnsafe.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of `typeUnsafe.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `typeUnsafe.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the most common purpose for using the `unsafe` package is speed
    when dealing with large amounts of data because it allows you to perform pointer
    arithmetic and conversions between different pointer types without type safety
    checks. When dealing with large amounts of data, pointer arithmetic can speed
    up things.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss generating random numbers and random strings.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Random number generation is an art as well as a research area in computer science.
    This is because computers are purely logical machines, and it turns out that using
    them to generate random numbers is extremely difficult!
  prefs: []
  type: TYPE_NORMAL
- en: Go can help you with that using the functionality of the `math/rand` package.
    Each random number generator needs a seed to start producing numbers. The seed
    is used for initializing the entire process and is extremely important because
    if you always start with the same seed, you will always get the same sequence
    of pseudo-random numbers. This means that everybody can regenerate that sequence,
    and that particular sequence will not be random after all.
  prefs: []
  type: TYPE_NORMAL
- en: However, this feature is very handy for testing purposes. In Go, the `rand.Seed()`
    function is used for initializing a random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: If you are really interested in random number generation, you should start by
    reading the second volume of *The Art of Computer Programming* by Donald E. Knuth
    (Addison-Wesley Professional, 2011).
  prefs: []
  type: TYPE_NORMAL
- en: The following function, which is part of `randomNumbers.go` found in `ch02`
    in the book’s GitHub repository, is what generates random numbers in the `[min,
    max)` range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The `random()` function does all of the work, which is generating pseudo-random
    numbers in the `min` to `max-1` range by calling `rand.Intn()`. `rand.Intn()`
    generates non-negative random integers from `0` up to the value of its single
    parameter minus 1.
  prefs: []
  type: TYPE_NORMAL
- en: The `randomNumbers.go` utility accepts four command line parameters but can
    also work with fewer parameters by using default values. By default, `randomNumbers.go`
    produces 100 random integers from 0 up to and including 99.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following output, we define each of the parameters manually (the minimum
    value, maximum value, number of random values, and seed value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The first two times the seed value was 10, so we got the same output. The third
    time the value of the seed was 11, which generated a different output.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you want to generate random strings that can be used for difficult-to-guess
    passwords or for testing purposes. Based on random number generation, we create
    a utility that produces random strings. The utility is implemented as `genPass.go`
    and can be found in the `ch02` directory of the book’s GitHub repository. The
    core functionality of `genPass.go` is found in the next function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: As we only want to get printable ASCII characters, we limit the range of pseudo-random
    numbers that can be generated. The total number of printable characters in the
    ASCII table is 94\. This means that the range of the pseudo-random numbers that
    the program can generate should be from 0 to 94, without including 94\. Therefore,
    the values of the `MIN` and `MAX` global variables, which are not shown here,
    are 0 and 94, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `startChar` variable holds the first ASCII character that can be generated
    by the utility, which, in this case, is the exclamation mark, which has a decimal
    ASCII value of 33\. Given that the program can generate pseudo-random numbers
    up to 94, the maximum ASCII value that can be generated is 93 + 33, which is equal
    to 126, which is the ASCII value of `~`. All generated characters are kept in
    the `temp` variable, which is returned once the `for` loop exits. The `string(startChar[0]
    + byte(myRand))` statement converts the random integers into characters in the
    desired range.
  prefs: []
  type: TYPE_NORMAL
- en: The `genPass.go` utility accepts a single parameter, which is the length of
    the generated password. If no parameter is given, `genPass.go` produces a password
    with 8 characters, which is the default value of the `LENGTH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `genPass.go` produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The first program execution uses the default value for the length of the generated
    string whereas the second program execution creates a random string with 20 characters.
  prefs: []
  type: TYPE_NORMAL
- en: Generating secure random numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you intend to use these pseudo-random numbers for security-related work,
    it is important that you use the `crypto/rand` package, which implements a cryptographically
    secure pseudo-random number generator. You do not need to define a seed when using
    the `crypto/rand` package.
  prefs: []
  type: TYPE_NORMAL
- en: The following function that is part of the `cryptoRand.go` source code showcases
    how secure random numbers are generated with the functionality of `crypto/rand`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The `rand.Read()` function randomly generates numbers that occupy the entire
    `b` byte slice. You need to decode that byte slice using `base64.URLEncoding.EncodeToString(b)`
    in order to get a valid string without any control or unprintable characters.
    This transformation takes place in the `generatePass()` function, which is not
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `cryptoRand.go` creates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The output is not different from the one generated by `genPass.go`, it is just
    that the random numbers are generated more securely, which means that they can
    be used in applications where security is important.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to generate random numbers, we are going to revisit the
    statistics application.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the statistics application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to improve the functionality and the operation
    of the statistics application. When there is no valid input, we are going to populate
    the statistics application with ten random values, which is pretty handy when
    you want to put lots of data in an application for testing purposes—you can change
    the number of random values to fit your needs. However, keep in mind that this
    takes place when all user input is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: I have randomly generated data in the past in order to put sample data into
    Kafka topics, RabbitMQ queues and MySQL tables.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we are going to *normalize* the data. Officially, this is called
    *z-normalization* and is helpful for allowing sequences of values to be compared
    more accurately. We are going to use normalization in forthcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for the normalization of the data is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: From the parameters of the function, you can see that `normalize()` needs the
    mean value and the standard deviation of the sample before normalizing it. Apart
    from that, there is a small trick with `math.Floor()` for defining the accuracy
    of the normalized `float64` values, which in this case is four digits. To get
    two digits of accuracy, you should change the code to `math.Floor((val-mean)/stdDev*100)/100`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the function for generating random floating-point values is implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The `rand.Float64()` function returns values from `0` to `1.0`, without including
    `1.0`. The `randomFloat()` function returns values from `min` to `max`, without
    including `max`.
  prefs: []
  type: TYPE_NORMAL
- en: You can review the source code of `stats.go` to learn about the remaining implementation
    details. The main difference with the version of the previous chapter is that
    we are now using a slice called `values` for storing all the valid values that
    we are processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `stats.go` produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Although randomly generated values might not be perfect at all times, they are
    usually more than enough for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the basic data types of Go, including numerical
    data types, strings, and errors. Additionally, we learned how to group similar
    values using arrays and slices. Lastly, we learned about the differences between
    arrays and slices and why slices are more versatile than arrays, as well as pointers
    and generating random numbers and strings in order to generate random data.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that you should remember from this chapter is that a slice is empty
    if its length is equal to `0`. On the other hand, a slice is `nil` if it is equal
    to `nil`—this means that it points to no memory address. The `var s []string`
    statement creates a `nil` slice without allocating any memory. A `nil` slice is
    always empty—the reverse is not always true.
  prefs: []
  type: TYPE_NORMAL
- en: As far as Go strings are concerned, remember that double quotes define an interpreted
    string literal whereas back quotes define a raw string literal. Most of the time,
    you need double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Last, keep in mind that the use of the `unsafe` package can lead to subtle bugs
    and memory safety issues. The Go language encourages type safety, and the use
    of `unsafe` should be limited to situations where there is a clear understanding
    of the risks and where no safer alternative exists.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter discusses the composite data types of Go, namely, maps and
    structures. Maps can use keys of different data types whereas structures can group
    multiple data types and create new ones that you can access as single entities.
    As you will see in later chapters, structures play a key role in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to do the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Correct the error in `typedConstants.go`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and test a function that concatenates two arrays into a new slice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a function that concatenates two arrays into a new array. Do not forget
    to test it with various types of input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a function that concatenates two slices into a new array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `go doc errors Is` in order to learn about `errors.Is()` and try to create
    a small Go program that uses it. After that, modify `error.go` to use `errors.Is()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `stats.go` in order to accept the number of randomly generated values
    as a command line argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `stats.go` in order to always use randomly generated data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sort` package documentation: [https://pkg.go.dev/sort](https://pkg.go.dev/sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `time` package documentation: [https://pkg.go.dev/time](https://pkg.go.dev/time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `crypto/rand` package documentation: [https://pkg.go.dev/crypto/rand](https://pkg.go.dev/crypto/rand)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go 1.20 release notes: [https://tip.golang.org/doc/go1.20](https://tip.golang.org/doc/go1.20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `math/rand` package documentation: [https://pkg.go.dev/math/rand](https://pkg.go.dev/math/rand
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
