<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer066">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 class="chapterTitle" id="_idParaDest-85"><span class="koboSpan" id="kobo.2.1">Composite Data Types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Go offers support for maps and structures, which are composite data types and the main subject of this chapter. </span><span class="koboSpan" id="kobo.3.2">The reason that we present them separately from arrays and slices is that both maps and structures are more flexible and powerful than arrays and slices. </span><span class="koboSpan" id="kobo.3.3">Each map can use keys of a given predefined data type, whereas structures can group multiple data types and create new data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">Maps and slices are used for completely different reasons. </span><span class="koboSpan" id="kobo.4.2">Arrays and slices are used to store contiguous data and benefit from memory locality and indexing. </span><span class="koboSpan" id="kobo.4.3">Maps are useful when you do not need the locality of data but still need a way to reference it in constant time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">The general idea is that if an array or a slice cannot do the job, you might need to look at maps. </span><span class="koboSpan" id="kobo.5.2">If a map cannot help you store your data the way you want, then you should consider creating and using a structure—you can also group structures of the same type using arrays or slices. </span><span class="koboSpan" id="kobo.5.3">Keep in mind that maps and structures are distinct in their use case. </span><span class="koboSpan" id="kobo.5.4">You can easily have a map of structures, as well as an array or slice of structures. </span><span class="koboSpan" id="kobo.5.5">However, a structure is useful when you need to combine multiple pieces of logically grouped data and/or variables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">Additionally, the knowledge of this chapter will allow us to read and save data in the CSV format using structures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.7.1">Also, we are going to improve the statistics application we originally developed in </span><em class="chapterRef"><span class="koboSpan" id="kobo.8.1">Chapter 1</span></em><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">A Quick Introduction to Go</span></em><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">The new version of the utility is going to be able to load data from disk, which means that you no longer need to hardcode your data or generate random numbers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.12.1">This chapter covers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Maps</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Structures</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Regular expressions and pattern matching</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Improving the statistics application</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.17.1">Without further ado, let us begin by presenting maps.</span></p>
<h1 class="heading-1" id="_idParaDest-86"><span class="koboSpan" id="kobo.18.1">Maps</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.19.1">Both </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.20.1">arrays and slices limit you to using positive integers as indexes, which start from </span><code class="inlineCode"><span class="koboSpan" id="kobo.21.1">0</span></code><span class="koboSpan" id="kobo.22.1"> and cannot have gaps in them—this means that even if you want to put data in the slice element at index 99 only, the slice is still going to occupy 100 elements in memory. </span><span class="koboSpan" id="kobo.22.2">Maps are more powerful data structures because they allow you to use indexes of various data types as keys to look up your data, as long as these keys are </span><em class="italic"><span class="koboSpan" id="kobo.23.1">comparable</span></em><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">Comparable means that Go should be able to tell if two values are equal or which value is bigger (or smaller) than the other.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.25.1">Although Boolean variables are comparable, it makes no sense to use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.26.1">bool</span></code><span class="koboSpan" id="kobo.27.1"> variable as the key to a map because it only allows for two distinct values. </span><span class="koboSpan" id="kobo.27.2">Additionally, although floating point values are comparable, precision issues caused by the internal representation of such values might create bugs and crashes, so you might want to avoid using floating point values as keys to maps.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.28.1">You might ask, why </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.29.1">do we need maps, and what are their advantages? </span><span class="koboSpan" id="kobo.29.2">The following list will help clarify things:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.30.1">Maps are very versatile. </span><span class="koboSpan" id="kobo.30.2">You can even create a database index using a map, which allows you to search and access elements based on a given key or, in more advanced situations, a combination of keys.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">Although this is not always the case, working with maps in Go is fast, as you can access all elements of a map in constant time. </span><span class="koboSpan" id="kobo.31.2">Inserting and retrieving elements from a map is a constant time operation.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">Maps are easy to understand, which often leads to clear designs.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.33.1">You can create a new map variable using either </span><code class="inlineCode"><span class="koboSpan" id="kobo.34.1">make()</span></code><span class="koboSpan" id="kobo.35.1"> or a map literal. </span><span class="koboSpan" id="kobo.35.2">Creating a new map with </span><code class="inlineCode"><span class="koboSpan" id="kobo.36.1">string</span></code><span class="koboSpan" id="kobo.37.1"> keys and </span><code class="inlineCode"><span class="koboSpan" id="kobo.38.1">int</span></code><span class="koboSpan" id="kobo.39.1"> values using </span><code class="inlineCode"><span class="koboSpan" id="kobo.40.1">make()</span></code><span class="koboSpan" id="kobo.41.1"> is as simple as writing </span><code class="inlineCode"><span class="koboSpan" id="kobo.42.1">make(map[string]int)</span></code><span class="koboSpan" id="kobo.43.1"> and assigning its return value to a variable. </span><span class="koboSpan" id="kobo.43.2">On the other hand, if you decide to create </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.44.1">a map using a map literal, you need to write something like the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.45.1">m := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.46.1">map</span></span><span class="koboSpan" id="kobo.47.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.48.1">string</span></span><span class="koboSpan" id="kobo.49.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.50.1">int</span></span><span class="koboSpan" id="kobo.51.1"> {
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.52.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.53.1">key1"</span></span><span class="koboSpan" id="kobo.54.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.55.1">-1</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.56.1">"key2"</span></span><span class="koboSpan" id="kobo.57.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.58.1">123</span></span><span class="koboSpan" id="kobo.59.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.60.1">The map literal version is faster when you want to add data to a map at the time of creation. </span><span class="koboSpan" id="kobo.60.2">The previous map literal contains two keys and two values—two pairs in total.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.61.1">You should make no assumptions about the order of the elements inside a map. </span><span class="koboSpan" id="kobo.61.2">Go randomizes keys when iterating over a map— this is done on purpose and is an intentional part of the language design.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.62.1">You can find the length of a map, which is the number of keys in the map, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">len()</span></code><span class="koboSpan" id="kobo.64.1"> function, which also works with arrays and slices; also, you can delete a key and value pair from a map using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.65.1">delete()</span></code><span class="koboSpan" id="kobo.66.1"> function, which accepts two arguments: the name of the map and the name of the key, in that order.</span></p>
<h2 class="heading-2" id="_idParaDest-87"><span class="koboSpan" id="kobo.67.1">How to tell whether a key exists on a map</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.68.1">You can tell </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.69.1">whether a key </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">k</span></code><span class="koboSpan" id="kobo.71.1"> exists on a map named </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">aMap</span></code><span class="koboSpan" id="kobo.73.1"> by the second return value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">v, ok := aMap[k]</span></code><span class="koboSpan" id="kobo.75.1"> statement. </span><span class="koboSpan" id="kobo.75.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">ok</span></code><span class="koboSpan" id="kobo.77.1"> is set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">true</span></code><span class="koboSpan" id="kobo.79.1">, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">k</span></code><span class="koboSpan" id="kobo.81.1"> exists, and its value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">v</span></code><span class="koboSpan" id="kobo.83.1">. </span><span class="koboSpan" id="kobo.83.2">If it does not exist, </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">v</span></code><span class="koboSpan" id="kobo.85.1"> will be set to the zero value of its data type, which depends on the definition of the map.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.86.1">Now, a very important detail: </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.87.1">if you try to get the value of a key that does not exist in a map, Go will not complain about it and return the zero value of the data type of the value.</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.88.1">Now, let us discuss a special case where a map variable has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.89.1">nil</span></code><span class="koboSpan" id="kobo.90.1"> value.</span></p>
<h2 class="heading-2" id="_idParaDest-88"><span class="koboSpan" id="kobo.91.1">Storing to a nil map</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.92.1">You are</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.93.1"> allowed to assign a map variable to </span><code class="inlineCode"><span class="koboSpan" id="kobo.94.1">nil</span></code><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">In that case, you will not be able to use that variable until you assign it to a new map variable. </span><span class="koboSpan" id="kobo.95.3">Put simply, if you try to store data on a </span><code class="inlineCode"><span class="koboSpan" id="kobo.96.1">nil</span></code><span class="koboSpan" id="kobo.97.1"> map, your program will crash. </span><span class="koboSpan" id="kobo.97.2">This is illustrated in the next bit of code, which is the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">main()</span></code><span class="koboSpan" id="kobo.99.1"> function of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">nilMap.go</span></code><span class="koboSpan" id="kobo.101.1"> source file that can be found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">ch03</span></code><span class="koboSpan" id="kobo.103.1"> directory of the GitHub repository of this book:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.104.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.105.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.106.1">()</span></span><span class="koboSpan" id="kobo.107.1"> {
    aMap := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.108.1">map</span></span><span class="koboSpan" id="kobo.109.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.110.1">string</span></span><span class="koboSpan" id="kobo.111.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.112.1">int</span></span><span class="koboSpan" id="kobo.113.1">{}
    aMap[</span><span class="hljs-string"><span class="koboSpan" id="kobo.114.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.115.1">test"</span></span><span class="koboSpan" id="kobo.116.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.117.1">1</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.118.1">This </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.119.1">works because </span><code class="inlineCode"><span class="koboSpan" id="kobo.120.1">aMap</span></code><span class="koboSpan" id="kobo.121.1"> points to an existing map, which is the return value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.122.1">map[string]int{}</span></code><span class="koboSpan" id="kobo.123.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.124.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.125.1">"aMap:"</span></span><span class="koboSpan" id="kobo.126.1">, aMap)
    aMap = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.127.1">nil</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.128.1">At this point, </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">aMap</span></code><span class="koboSpan" id="kobo.130.1"> points to </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">nil</span></code><span class="koboSpan" id="kobo.132.1">, which in Go is a synonym for nothing.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.133.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.134.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.135.1">aMap:"</span></span><span class="koboSpan" id="kobo.136.1">, aMap)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.137.1">if</span></span><span class="koboSpan" id="kobo.138.1"> aMap == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.139.1">nil</span></span><span class="koboSpan" id="kobo.140.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.141.1">"nil map!"</span></span><span class="koboSpan" id="kobo.142.1">)
        aMap = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.143.1">map</span></span><span class="koboSpan" id="kobo.144.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.145.1">string</span></span><span class="koboSpan" id="kobo.146.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.147.1">int</span></span><span class="koboSpan" id="kobo.148.1">{}
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.149.1">Testing whether a map points to </span><code class="inlineCode"><span class="koboSpan" id="kobo.150.1">nil</span></code><span class="koboSpan" id="kobo.151.1"> before using it is a good practice. </span><span class="koboSpan" id="kobo.151.2">In this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.152.1">if aMap == nil</span></code><span class="koboSpan" id="kobo.153.1"> allows us to determine whether we can store a key/value pair to </span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">aMap</span></code><span class="koboSpan" id="kobo.155.1"> or not—we cannot, and if we try it, the program will crash. </span><span class="koboSpan" id="kobo.155.2">We correct that by issuing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">aMap = map[string]int{}</span></code><span class="koboSpan" id="kobo.157.1"> statement.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.158.1">    aMap[</span><span class="hljs-string"><span class="koboSpan" id="kobo.159.1">"test"</span></span><span class="koboSpan" id="kobo.160.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.161.1">1</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.162.1">// This will crash!</span></span><span class="koboSpan" id="kobo.163.1">
    aMap = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.164.1">nil</span></span><span class="koboSpan" id="kobo.165.1">
    aMap[</span><span class="hljs-string"><span class="koboSpan" id="kobo.166.1">"test"</span></span><span class="koboSpan" id="kobo.167.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.168.1">1</span></span><span class="koboSpan" id="kobo.169.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.170.1">In this last part of the program, we illustrate how your program will crash if you try to store data on a </span><code class="inlineCode"><span class="koboSpan" id="kobo.171.1">nil</span></code><span class="koboSpan" id="kobo.172.1"> map—never use such code in production!</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.173.1">In real-world applications, if a function accepts a map argument, then it should check that the map is not </span><code class="inlineCode"><span class="koboSpan" id="kobo.174.1">nil</span></code><span class="koboSpan" id="kobo.175.1"> before working with it.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.176.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">nilMap.go</span></code><span class="koboSpan" id="kobo.178.1"> produces this output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.179.1">$ </span></span><span class="koboSpan" id="kobo.180.1">go run nilMap.go
aMap: map[test:1]
aMap: map[]
nil map!
</span><span class="koboSpan" id="kobo.180.2">panic: assignment to entry in nil map
goroutine 1 [running]:
main.main()
    /Users/mtsouk/Desktop/mGo4th/code/ch03/nilMap.go:21 +0x17c
exit status 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.181.1">The reason</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.182.1"> the program crashed is shown in the program output: </span><code class="inlineCode"><span class="koboSpan" id="kobo.183.1">panic: assignment to entry in nil map</span></code><span class="koboSpan" id="kobo.184.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-89"><span class="koboSpan" id="kobo.185.1">Iterating over maps</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.186.1">When </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">for</span></code><span class="koboSpan" id="kobo.188.1"> is</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.189.1"> combined with </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">range</span></code><span class="koboSpan" id="kobo.191.1">, it implements the functionality of the </span><em class="italic"><span class="koboSpan" id="kobo.192.1">foreach loops</span></em><span class="koboSpan" id="kobo.193.1"> found in other programming languages and allows you to iterate over all the elements of a map without knowing its size or its keys. </span><span class="koboSpan" id="kobo.193.2">In that case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">range</span></code><span class="koboSpan" id="kobo.195.1"> returns key and value pairs, in that order.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.196.1">Type the following code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">forMaps.go</span></code><span class="koboSpan" id="kobo.198.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.199.1">package</span></span><span class="koboSpan" id="kobo.200.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.201.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.202.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.203.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.204.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.205.1">()</span></span><span class="koboSpan" id="kobo.206.1"> {
    aMap := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.207.1">make</span></span><span class="koboSpan" id="kobo.208.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.209.1">map</span></span><span class="koboSpan" id="kobo.210.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.211.1">string</span></span><span class="koboSpan" id="kobo.212.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.213.1">string</span></span><span class="koboSpan" id="kobo.214.1">)
    aMap[</span><span class="hljs-string"><span class="koboSpan" id="kobo.215.1">"123"</span></span><span class="koboSpan" id="kobo.216.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.217.1">"456"</span></span><span class="koboSpan" id="kobo.218.1">
    aMap[</span><span class="hljs-string"><span class="koboSpan" id="kobo.219.1">"key"</span></span><span class="koboSpan" id="kobo.220.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.221.1">"A value"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.222.1">for</span></span><span class="koboSpan" id="kobo.223.1"> key, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.224.1">range</span></span><span class="koboSpan" id="kobo.225.1"> aMap {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.226.1">"key:"</span></span><span class="koboSpan" id="kobo.227.1">, key, </span><span class="hljs-string"><span class="koboSpan" id="kobo.228.1">"value:"</span></span><span class="koboSpan" id="kobo.229.1">, v)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.230.1">In this case, we use both the key and the value that returned from </span><code class="inlineCode"><span class="koboSpan" id="kobo.231.1">range</span></code><span class="koboSpan" id="kobo.232.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.233.1">for</span></span><span class="koboSpan" id="kobo.234.1"> _, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.235.1">range</span></span><span class="koboSpan" id="kobo.236.1"> aMap {
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.237.1">" # "</span></span><span class="koboSpan" id="kobo.238.1">, v)
    }
    fmt.Println()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.239.1">In this case, as we are only interested in the values returned by the map, we ignore the keys.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.240.1">As you already know, you should make </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.241.1">no assumptions about the order</span></strong><span class="koboSpan" id="kobo.242.1"> that the key and value pairs of a map will be returned in from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.243.1">for</span></code><span class="koboSpan" id="kobo.244.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">range</span></code><span class="koboSpan" id="kobo.246.1"> loop.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.247.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">forMaps.go</span></code><span class="koboSpan" id="kobo.249.1"> produces </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.250.1">this output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.251.1">$ </span></span><span class="koboSpan" id="kobo.252.1">go run forMaps.go
key: key value: A value
key: 123 value: 456
 # 456 # A value
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.253.1">Having covered maps, it is time to learn about Go structures.</span></p>
<h1 class="heading-1" id="_idParaDest-90"><span class="koboSpan" id="kobo.254.1">Structures</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.255.1">Structures</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.256.1"> in Go are both very powerful and very popular and are used for organizing and grouping various types of data under the same name. </span><span class="koboSpan" id="kobo.256.2">Structures are the more versatile data type in Go—they can even have associated functions, which are called methods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.257.1">Structures, as well as other user-defined data types, are usually defined outside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">main()</span></code><span class="koboSpan" id="kobo.259.1"> function or any other package function so that they can have a global scope and be available to the entire Go package. </span><span class="koboSpan" id="kobo.259.2">Therefore, unless you want to make clear that a type is only useful within the current local scope and is not expected to be used elsewhere, you should write the definitions of new data types outside functions.</span></p>
<h2 class="heading-2" id="_idParaDest-91"><span class="koboSpan" id="kobo.260.1">The type keyword</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.261.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">type</span></code><span class="koboSpan" id="kobo.263.1"> keyword </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.264.1">allows you to define new data types or </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.265.1">create aliases for existing ones. </span><span class="koboSpan" id="kobo.265.2">Therefore, you are allowed to say </span><code class="inlineCode"><span class="koboSpan" id="kobo.266.1">type myInt int</span></code><span class="koboSpan" id="kobo.267.1"> and define a new data type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.268.1">myInt</span></code><span class="koboSpan" id="kobo.269.1">, which is an alias for </span><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">int</span></code><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">However, Go considers </span><code class="inlineCode"><span class="koboSpan" id="kobo.272.1">myInt</span></code><span class="koboSpan" id="kobo.273.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">int</span></code><span class="koboSpan" id="kobo.275.1"> as totally different data types that you cannot compare directly, even though they store the same kind of values. </span><span class="koboSpan" id="kobo.275.2">Each structure defines a new data type, hence the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.276.1">type</span></code><span class="koboSpan" id="kobo.277.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-92"><span class="koboSpan" id="kobo.278.1">Defining new structures</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.279.1">When you</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.280.1"> define a new structure, which is called a struct in the Go documentation, you group a set of values into a single data type, which allows you to pass and receive this set of values as a single entity. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.281.1">A structure has fields, and each field has its own data type</span></strong><span class="koboSpan" id="kobo.282.1">, which can even be another structure or a slice of structures. </span><span class="koboSpan" id="kobo.282.2">Additionally, as a structure is a new data type, it is defined using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">type</span></code><span class="koboSpan" id="kobo.284.1"> keyword, followed by the name of the structure, and ending with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">struct</span></code><span class="koboSpan" id="kobo.286.1"> keyword, which signifies that we</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.287.1"> are defining a new structure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.288.1">The following code defines a new structure named </span><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">Entry</span></code><span class="koboSpan" id="kobo.290.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.291.1">type</span></span><span class="koboSpan" id="kobo.292.1"> Entry </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.293.1">struct</span></span><span class="koboSpan" id="kobo.294.1"> {
    Name    </span><span class="hljs-type"><span class="koboSpan" id="kobo.295.1">string</span></span><span class="koboSpan" id="kobo.296.1">
    Surname </span><span class="hljs-type"><span class="koboSpan" id="kobo.297.1">string</span></span><span class="koboSpan" id="kobo.298.1">
    Year    </span><span class="hljs-type"><span class="koboSpan" id="kobo.299.1">int</span></span><span class="koboSpan" id="kobo.300.1">
}
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.301.1">Although you can embed a structure definition into another structure, it is generally a bad idea and should be avoided. </span><span class="koboSpan" id="kobo.301.2">If you even think about doing so, you might need to think about your design decisions. </span><span class="koboSpan" id="kobo.301.3">However, it is perfectly acceptable to have existing structs as types inside a struct.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.302.1">For reasons that will become evident in </span><em class="chapterRef"><span class="koboSpan" id="kobo.303.1">Chapter 6</span></em><span class="koboSpan" id="kobo.304.1">, </span><em class="italic"><span class="koboSpan" id="kobo.305.1">Go Packages and Functions</span></em><span class="koboSpan" id="kobo.306.1">, the fields of a structure usually begin with an uppercase letter—this depends on what you want to do with the fields and how their visibility outside of the current package might affect that. </span><span class="koboSpan" id="kobo.306.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">Entry</span></code><span class="koboSpan" id="kobo.308.1"> structure has three fields, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.309.1">Name</span></code><span class="koboSpan" id="kobo.310.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.311.1">Surname</span></code><span class="koboSpan" id="kobo.312.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">Year</span></code><span class="koboSpan" id="kobo.314.1">. </span><span class="koboSpan" id="kobo.314.2">The first two fields are of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">string</span></code><span class="koboSpan" id="kobo.316.1"> data type, whereas the last field holds an </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">int</span></code><span class="koboSpan" id="kobo.318.1"> value.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.319.1">These three fields can be accessed with the </span><em class="italic"><span class="koboSpan" id="kobo.320.1">dot notation</span></em><span class="koboSpan" id="kobo.321.1"> as </span><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">V.Name</span></code><span class="koboSpan" id="kobo.323.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">V.Surname</span></code><span class="koboSpan" id="kobo.325.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">V.Year</span></code><span class="koboSpan" id="kobo.327.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.328.1">V</span></code><span class="koboSpan" id="kobo.329.1"> is the name of the variable holding an instance of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.330.1">Entry</span></code><span class="koboSpan" id="kobo.331.1"> structure. </span><span class="koboSpan" id="kobo.331.2">A structure literal named </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">p1</span></code><span class="koboSpan" id="kobo.333.1"> can be defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.334.1">p1 := Entry{"Joe", "D.", 2012}</span></code><span class="koboSpan" id="kobo.335.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.336.1">Two ways exist to work with structure variables. </span><span class="koboSpan" id="kobo.336.2">The first one is as regular variables, and the second one is as pointer variables that point to the memory address of a structure. </span><span class="koboSpan" id="kobo.336.3">Both ways are equally good and are usually embedded into separate functions, because they allow you to initialize some or all of the fields of structure variables properly and/or do any other tasks you want before using the structure variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.337.1">As a result, there exist two main ways to create a new structure variable using a function. </span><span class="koboSpan" id="kobo.337.2">The first one returns a regular structure variable whereas the second one returns a pointer to a structure. </span><span class="koboSpan" id="kobo.337.3">Each one of these two ways has two variations. </span><span class="koboSpan" id="kobo.337.4">The first variation returns a structure instance that is initialized by the Go compiler, whereas the second variation returns a structure instance that is initialized by the developer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.338.1">Last, keep in mind that the order in which you put the fields in the definition of a structure </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.339.1">type is significant for the type identity of the defined structure. </span><span class="koboSpan" id="kobo.339.2">Put simply, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.340.1">two structures with the same fields will not be considered identical in Go if their fields are not in the same order</span></strong><span class="koboSpan" id="kobo.341.1">. </span><span class="koboSpan" id="kobo.341.2">This mainly has to do with exchanging data between server and client software because variables of different structures cannot be compared, even if they have the exact same list of fields with the exact data types in the exact same order, as they belong to different data types.</span></p>
<h2 class="heading-2" id="_idParaDest-93"><span class="koboSpan" id="kobo.342.1">Using the new keyword</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.343.1">Additionally, you </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.344.1">can create new structure instances using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">new()</span></code><span class="koboSpan" id="kobo.346.1"> keyword </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.347.1">with statements such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">pS := new(Entry)</span></code><span class="koboSpan" id="kobo.349.1">. </span><span class="koboSpan" id="kobo.349.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">new()</span></code><span class="koboSpan" id="kobo.351.1"> keyword has the following properties:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.352.1">It allocates the proper memory space, which depends on the data type, and then it zeroes it.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.353.1">It always returns a pointer to the allocated memory.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.354.1">It works for all data types except channels and maps.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.355.1">All these techniques are illustrated in the code that follows. </span><span class="koboSpan" id="kobo.355.2">Type the following code in your favorite text editor and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">structures.go</span></code><span class="koboSpan" id="kobo.357.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.358.1">package</span></span><span class="koboSpan" id="kobo.359.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.360.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.361.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.362.1">type</span></span><span class="koboSpan" id="kobo.363.1"> Entry </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.364.1">struct</span></span><span class="koboSpan" id="kobo.365.1"> {
    Name    </span><span class="hljs-type"><span class="koboSpan" id="kobo.366.1">string</span></span><span class="koboSpan" id="kobo.367.1">
    Surname </span><span class="hljs-type"><span class="koboSpan" id="kobo.368.1">string</span></span><span class="koboSpan" id="kobo.369.1">
    Year    </span><span class="hljs-type"><span class="koboSpan" id="kobo.370.1">int</span></span><span class="koboSpan" id="kobo.371.1">
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.372.1">// Initialized by Go</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.373.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.374.1">zeroS</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.375.1">()</span></span><span class="koboSpan" id="kobo.376.1"> Entry {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.377.1">return</span></span><span class="koboSpan" id="kobo.378.1"> Entry{}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.379.1">Now is a good time to remind you of an important Go rule: </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.380.1">if no initial value is given to a variable, the Go compiler automatically initializes that variable to the zero value of its data type</span></strong><span class="koboSpan" id="kobo.381.1">. </span><span class="koboSpan" id="kobo.381.2">For structures, this means that a structure variable without an initial value is initialized to the zero values of the data type of each one of its fields. </span><span class="koboSpan" id="kobo.381.3">Therefore, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">zeroS()</span></code><span class="koboSpan" id="kobo.383.1"> function returns a zero-initialized </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">Entry</span></code><span class="koboSpan" id="kobo.385.1"> structure.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.386.1">// Initialized by the user</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.387.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.388.1">initS</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.389.1">(N, S </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.390.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.391.1">, Y </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.392.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.393.1">)</span></span><span class="koboSpan" id="kobo.394.1"> Entry {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.395.1">if</span></span><span class="koboSpan" id="kobo.396.1"> Y &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.397.1">2000</span></span><span class="koboSpan" id="kobo.398.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.399.1">return</span></span><span class="koboSpan" id="kobo.400.1"> Entry{Name: N, Surname: S, Year: </span><span class="hljs-number"><span class="koboSpan" id="kobo.401.1">2000</span></span><span class="koboSpan" id="kobo.402.1">}
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.403.1">return</span></span><span class="koboSpan" id="kobo.404.1"> Entry{Name: N, Surname: S, Year: Y}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.405.1">In this </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.406.1">case, the</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.407.1"> user initializes the new structure variable. </span><span class="koboSpan" id="kobo.407.2">Additionally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">initS()</span></code><span class="koboSpan" id="kobo.409.1"> function checks whether the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">Year</span></code><span class="koboSpan" id="kobo.411.1"> field is smaller than </span><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">2000</span></code><span class="koboSpan" id="kobo.413.1"> and acts; if it is smaller than </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">2000</span></code><span class="koboSpan" id="kobo.415.1">, then the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">Year</span></code><span class="koboSpan" id="kobo.417.1"> field becomes </span><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">2000</span></code><span class="koboSpan" id="kobo.419.1">. </span><span class="koboSpan" id="kobo.419.2">This condition is specific to the requirements of the application you are developing—what this shows is that the place where you initialize a structure is also good for checking your input.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.420.1">// Initialized by Go - returns pointer</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.421.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.422.1">zeroPtoS</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.423.1">()</span></span><span class="koboSpan" id="kobo.424.1"> *Entry {
    t := &amp;Entry{}
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.425.1">return</span></span><span class="koboSpan" id="kobo.426.1"> t
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.427.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">zeroPtoS()</span></code><span class="koboSpan" id="kobo.429.1"> function returns a pointer to a zero-initialized structure.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.430.1">// Initialized by the user - returns pointer</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.431.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.432.1">initPtoS</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.433.1">(N, S </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.434.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.435.1">, Y </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.436.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.437.1">)</span></span><span class="koboSpan" id="kobo.438.1"> *Entry {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.439.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.440.1">len</span></span><span class="koboSpan" id="kobo.441.1">(S) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.442.1">0</span></span><span class="koboSpan" id="kobo.443.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.444.1">return</span></span><span class="koboSpan" id="kobo.445.1"> &amp;Entry{Name: N, Surname: </span><span class="hljs-string"><span class="koboSpan" id="kobo.446.1">"Unknown"</span></span><span class="koboSpan" id="kobo.447.1">, Year: Y}
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.448.1">return</span></span><span class="koboSpan" id="kobo.449.1"> &amp;Entry{Name: N, Surname: S, Year: Y}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.450.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.451.1">initPtoS()</span></code><span class="koboSpan" id="kobo.452.1"> function also returns a pointer to a structure but also checks the length of the user input. </span><span class="koboSpan" id="kobo.452.2">Again, this kind of checking is application specific.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.453.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.454.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.455.1">()</span></span><span class="koboSpan" id="kobo.456.1"> {
    s1 := zeroS()
    p1 := zeroPtoS()
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.457.1">"s1:"</span></span><span class="koboSpan" id="kobo.458.1">, s1, </span><span class="hljs-string"><span class="koboSpan" id="kobo.459.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.460.1">p1:"</span></span><span class="koboSpan" id="kobo.461.1">, *p1)
    s2 := initS(</span><span class="hljs-string"><span class="koboSpan" id="kobo.462.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.463.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.464.1">"Tsoukalos"</span></span><span class="koboSpan" id="kobo.465.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.466.1">2024</span></span><span class="koboSpan" id="kobo.467.1">)
    p2 := initPtoS(</span><span class="hljs-string"><span class="koboSpan" id="kobo.468.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.469.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.470.1">"Tsoukalos"</span></span><span class="koboSpan" id="kobo.471.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.472.1">2024</span></span><span class="koboSpan" id="kobo.473.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.474.1">"s2:"</span></span><span class="koboSpan" id="kobo.475.1">, s2, </span><span class="hljs-string"><span class="koboSpan" id="kobo.476.1">"p2:"</span></span><span class="koboSpan" id="kobo.477.1">, *p2)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.478.1">"Year:"</span></span><span class="koboSpan" id="kobo.479.1">, s1.Year, s2.Year, p1.Year, p2.Year)
    pS := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.480.1">new</span></span><span class="koboSpan" id="kobo.481.1">(Entry)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.482.1">"pS:"</span></span><span class="koboSpan" id="kobo.483.1">, pS)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.484.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">new(Entry)</span></code><span class="koboSpan" id="kobo.486.1"> call returns a pointer to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">Entry</span></code><span class="koboSpan" id="kobo.488.1"> structure. </span><span class="koboSpan" id="kobo.488.2">As a rule of thumb, when you have to </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.489.1">initialize </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.490.1">lots of structure variables, it is considered good practice to create a function for doing so, as this is less error-prone.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.491.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">structures.go</span></code><span class="koboSpan" id="kobo.493.1"> creates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.494.1">s1: {  0} p1: {  0}
s2: {Mihalis Tsoukalos 2024} p2: {Mihalis Tsoukalos 2024}
Year: 0 2024 0 2024
pS: &amp;{  0}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.495.1">As the zero value of a string is the empty string, </span><code class="inlineCode"><span class="koboSpan" id="kobo.496.1">s1</span></code><span class="koboSpan" id="kobo.497.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">p1</span></code><span class="koboSpan" id="kobo.499.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">pS</span></code><span class="koboSpan" id="kobo.501.1"> do not show any data for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">Name</span></code><span class="koboSpan" id="kobo.503.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">Surname</span></code><span class="koboSpan" id="kobo.505.1"> fields.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.506.1">The next subsection shows how to group structures of the same data type and use them as the elements of a slice.</span></p>
<h2 class="heading-2" id="_idParaDest-94"><span class="koboSpan" id="kobo.507.1">Slices of structures</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.508.1">You can </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.509.1">create slices of structures to group and handle multiple structures under a single variable name. </span><span class="koboSpan" id="kobo.509.2">However, accessing a field of a given structure requires knowing the exact place of the structure in the slice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.510.1">Have a look at the following figure to better understand how a slice of structures works and how you can access the fields of a specific slice element.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.511.1"><img alt="A black background with a black square  Description automatically generated" src="../Images/B21003_03_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.512.1">Figure 3.1: A slice of structures</span></p>
<p class="normal"><span class="koboSpan" id="kobo.513.1">So each slice </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.514.1">element is a structure that is accessed using a slice index. </span><span class="koboSpan" id="kobo.514.2">Once we select the slice element we want, we can select any one of its fields.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.515.1">As the whole process can be a little perplexing, the code that follows sheds some light and clarifies things. </span><span class="koboSpan" id="kobo.515.2">Type the following code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.516.1">sliceStruct.go</span></code><span class="koboSpan" id="kobo.517.1">. </span><span class="koboSpan" id="kobo.517.2">You can also find it by the same name in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">ch03</span></code><span class="koboSpan" id="kobo.519.1"> directory in the GitHub repository of the book.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.520.1">package</span></span><span class="koboSpan" id="kobo.521.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.522.1">import</span></span><span class="koboSpan" id="kobo.523.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.524.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.525.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.526.1">strconv"</span></span><span class="koboSpan" id="kobo.527.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.528.1">type</span></span><span class="koboSpan" id="kobo.529.1"> record </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.530.1">struct</span></span><span class="koboSpan" id="kobo.531.1"> {
    Field1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.532.1">int</span></span><span class="koboSpan" id="kobo.533.1">
    Field2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.534.1">string</span></span><span class="koboSpan" id="kobo.535.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.536.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.537.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.538.1">()</span></span><span class="koboSpan" id="kobo.539.1"> {
    s := []record{}
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.540.1">for</span></span><span class="koboSpan" id="kobo.541.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.542.1">0</span></span><span class="koboSpan" id="kobo.543.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.544.1">10</span></span><span class="koboSpan" id="kobo.545.1">; i++ {
        text := </span><span class="hljs-string"><span class="koboSpan" id="kobo.546.1">"text"</span></span><span class="koboSpan" id="kobo.547.1"> + strconv.Itoa(i)
        temp := record{Field1: i, Field2: text}
        s = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.548.1">append</span></span><span class="koboSpan" id="kobo.549.1">(s, temp)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.550.1">You still need </span><code class="inlineCode"><span class="koboSpan" id="kobo.551.1">append()</span></code><span class="koboSpan" id="kobo.552.1"> to add a new structure to a slice.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.553.1">// Accessing the fields of the first element</span></span><span class="koboSpan" id="kobo.554.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.555.1">"Index 0:"</span></span><span class="koboSpan" id="kobo.556.1">, s[</span><span class="hljs-number"><span class="koboSpan" id="kobo.557.1">0</span></span><span class="koboSpan" id="kobo.558.1">].Field1, s[</span><span class="hljs-number"><span class="koboSpan" id="kobo.559.1">0</span></span><span class="koboSpan" id="kobo.560.1">].Field2)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.561.1">"Number of structures:"</span></span><span class="koboSpan" id="kobo.562.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.563.1">len</span></span><span class="koboSpan" id="kobo.564.1">(s))
    sum := </span><span class="hljs-number"><span class="koboSpan" id="kobo.565.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.566.1">for</span></span><span class="koboSpan" id="kobo.567.1"> _, k := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.568.1">range</span></span><span class="koboSpan" id="kobo.569.1"> s {
        sum += k.Field1
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.570.1">"Sum:"</span></span><span class="koboSpan" id="kobo.571.1">, sum)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.572.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.573.1">sliceStruct.go</span></code><span class="koboSpan" id="kobo.574.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.575.1">Index 0: 0 text0
Number of structures: 10
Sum: 45
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.576.1">We revisit </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.577.1">structures in </span><em class="chapterRef"><span class="koboSpan" id="kobo.578.1">Chapter 5</span></em><span class="koboSpan" id="kobo.579.1">, where we discuss reflection, as well as </span><em class="chapterRef"><span class="koboSpan" id="kobo.580.1">Chapter 7</span></em><span class="koboSpan" id="kobo.581.1">, </span><em class="italic"><span class="koboSpan" id="kobo.582.1">Telling a UNIX System What to Do</span></em><span class="koboSpan" id="kobo.583.1">, where we learn how to work with JSON data using structures. </span><span class="koboSpan" id="kobo.583.2">For now, let us discuss regular expressions and pattern matching.</span></p>
<h1 class="heading-1" id="_idParaDest-95"><span class="koboSpan" id="kobo.584.1">Regular expressions and pattern matching</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.585.1">You might wonder why we are talking about regular expressions and pattern matching in this chapter. </span><span class="koboSpan" id="kobo.585.2">The reason is simple. </span><span class="koboSpan" id="kobo.585.3">In a while, you will learn how to store and read CSV data from plain text files, and you should be able to tell whether the data is valid or not.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.586.1">Pattern matching</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.587.1"> is a technique for searching a string for some set of characters, based on a specific search pattern that is based on regular expressions and grammars.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.588.1">A regular expression is</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.589.1"> a sequence of characters that defines a search pattern. </span><span class="koboSpan" id="kobo.589.2">Every regular expression is compiled into a recognizer by building a generalized transition diagram called a finite automaton. </span><span class="koboSpan" id="kobo.589.3">A finite automaton can be either deterministic or nondeterministic. </span><span class="koboSpan" id="kobo.589.4">Nondeterministic means that more than one transition out of a state can be possible for the same input. </span><span class="koboSpan" id="kobo.589.5">A recognizer is a program that takes a string </span><code class="inlineCode"><span class="koboSpan" id="kobo.590.1">x</span></code><span class="koboSpan" id="kobo.591.1"> as input and can tell whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.592.1">x</span></code><span class="koboSpan" id="kobo.593.1"> is a sentence of a given language or not.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.594.1">A grammar is a set of production rules for strings in a formal language—the production rules describe how to create strings from the alphabet of the language that are valid according to the syntax of the language. </span><span class="koboSpan" id="kobo.594.2">A grammar does not describe the meaning of a string or what can be done with it in whatever context—it only describes its form. </span><span class="koboSpan" id="kobo.594.3">What is important here is to realize that grammars are at the heart of regular expressions because, without a grammar, you cannot define and therefore use a regular expression.</span></p>
<h2 class="heading-2" id="_idParaDest-96"><span class="koboSpan" id="kobo.595.1">About regexp.Compile and regexp.MustCompile</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.596.1">The Go package</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.597.1"> responsible for defining regular</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.598.1"> expressions and performing pattern matching is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">regexp</span></code><span class="koboSpan" id="kobo.600.1">. </span><span class="koboSpan" id="kobo.600.2">Inside that package exists </span><code class="inlineCode"><span class="koboSpan" id="kobo.601.1">regexp.Compile()</span></code><span class="koboSpan" id="kobo.602.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.603.1">regexp.MustCompile()</span></code><span class="koboSpan" id="kobo.604.1">, which have similar capabilities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.605.1">Both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">regexp.MustCompile()</span></code><span class="koboSpan" id="kobo.607.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.608.1">regexp.Compile()</span></code><span class="koboSpan" id="kobo.609.1"> functions parse the given regular expression and return a pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">regexp.Regexp</span></code><span class="koboSpan" id="kobo.611.1"> variable that can be used for matching—</span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">regexp.Regexp</span></code><span class="koboSpan" id="kobo.613.1"> is the representation of a compiled regular expression. </span><span class="koboSpan" id="kobo.613.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">re.Match()</span></code><span class="koboSpan" id="kobo.615.1"> method returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.616.1">true</span></code><span class="koboSpan" id="kobo.617.1"> if the given byte slice matches the </span><code class="inlineCode"><span class="koboSpan" id="kobo.618.1">re</span></code><span class="koboSpan" id="kobo.619.1"> regular expression, which is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.620.1">regexp.Regexp</span></code><span class="koboSpan" id="kobo.621.1"> variable, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.622.1">false</span></code><span class="koboSpan" id="kobo.623.1"> otherwise.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.624.1">The main and crucial difference between </span><code class="inlineCode"><span class="koboSpan" id="kobo.625.1">regexp.Compile()</span></code><span class="koboSpan" id="kobo.626.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.627.1">regexp.MustCompile()</span></code><span class="koboSpan" id="kobo.628.1"> is that the former returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.629.1">*regexp.Regexp</span></code><span class="koboSpan" id="kobo.630.1"> pointer and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.631.1">error</span></code><span class="koboSpan" id="kobo.632.1"> variable, whereas the latter returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.633.1">*regexp.Regexp</span></code><span class="koboSpan" id="kobo.634.1"> pointer only. </span><span class="koboSpan" id="kobo.634.2">As a result, if there is some kind of error in the parsing of the regular expression, </span><code class="inlineCode"><span class="koboSpan" id="kobo.635.1">regexp.MustCompile()</span></code><span class="koboSpan" id="kobo.636.1"> is going to panic and therefore crash your program!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.637.1">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.638.1">regexp.MustCompile()</span></code><span class="koboSpan" id="kobo.639.1"> panicking is not necessarily a bad thing because if a regular expression cannot be parsed, you will know that your expression is invalid early in the process. </span><span class="koboSpan" id="kobo.639.2">At the end of the day, it is the developer that decides the overall policy regarding regular expression parsing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.640.1">There are times when we want to find only those matches for a pattern that are followed or preceded by another given pattern. </span><span class="koboSpan" id="kobo.640.2">These kinds of operations are called lookahead and lookbehind, respectively. </span><span class="koboSpan" id="kobo.640.3">Go offers no support for either lookahead or lookbehind and will throw an error message when used. </span><span class="koboSpan" id="kobo.640.4">The general syntax of lookahead is </span><code class="inlineCode"><span class="koboSpan" id="kobo.641.1">X(?=Y)</span></code><span class="koboSpan" id="kobo.642.1">, which means, match </span><code class="inlineCode"><span class="koboSpan" id="kobo.643.1">X</span></code><span class="koboSpan" id="kobo.644.1"> only if it is followed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">Y</span></code><span class="koboSpan" id="kobo.646.1">. </span><span class="koboSpan" id="kobo.646.2">The difference between </span><code class="inlineCode"><span class="koboSpan" id="kobo.647.1">regexp.Compile()</span></code><span class="koboSpan" id="kobo.648.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">regexp.MustCompile()</span></code><span class="koboSpan" id="kobo.650.1"> is illustrated in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">main()</span></code><span class="koboSpan" id="kobo.652.1"> function of </span><code class="inlineCode"><span class="koboSpan" id="kobo.653.1">diffRegExp.go</span></code><span class="koboSpan" id="kobo.654.1">, which is going to be presented in two parts.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.655.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.656.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.657.1">()</span></span><span class="koboSpan" id="kobo.658.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.659.1">// This is a raw string literal</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.660.1">var</span></span><span class="koboSpan" id="kobo.661.1"> re </span><span class="hljs-type"><span class="koboSpan" id="kobo.662.1">string</span></span><span class="koboSpan" id="kobo.663.1"> = </span><span class="hljs-string"><span class="koboSpan" id="kobo.664.1">`</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.665.1">^.*(?=.{7,})(?=.*\d)$`</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.666.1">What is </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.667.1">wrong with the preceding regular expression? </span><span class="koboSpan" id="kobo.667.2">The </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.668.1">problem is that it is using lookahead, which is not supported in Go.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.669.1">The second part is next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.670.1">    exp1, err := regexp.Compile(re)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.671.1">if</span></span><span class="koboSpan" id="kobo.672.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.673.1">nil</span></span><span class="koboSpan" id="kobo.674.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.675.1">"Error:"</span></span><span class="koboSpan" id="kobo.676.1">, err)
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.677.1">"RegExp:"</span></span><span class="koboSpan" id="kobo.678.1">, exp1)
    exp2 := regexp.MustCompile(re)
    fmt.Println(exp2)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.679.1">In this second code segment, the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.680.1">regexp.Compile()</span></code><span class="koboSpan" id="kobo.681.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.682.1">regexp.MustCompile()</span></code><span class="koboSpan" id="kobo.683.1"> is illustrated.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.684.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.685.1">diffRegExp.go</span></code><span class="koboSpan" id="kobo.686.1"> produces the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.687.1">$ </span></span><span class="koboSpan" id="kobo.688.1">go run diffRegExp.go
Error: error parsing regexp: invalid or unsupported Perl syntax: `(?=`
RegExp: &lt;nil&gt;
panic: regexp: Compile(`^.*(?=.{7,})(?=.*\d)$`): error parsing regexp: invalid or unsupported Perl syntax: `(?=`
goroutine 1 [running]:
regexp.MustCompile({0x100a0c681, 0x15})
    /opt/homebrew/Cellar/go/1.20.6/libexec/src/regexp/regexp.go:319 +0xac
main.main()
    /Users/mtsouk/Desktop/mGo4th/code/ch03/diffRegExp.go:20 +0xf8
exit status 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.689.1">So, in the first case, we know that there is an error in the regular expression because of the return value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.690.1">regexp.Compile()</span></code><span class="koboSpan" id="kobo.691.1">, whereas when using </span><code class="inlineCode"><span class="koboSpan" id="kobo.692.1">regexp.MustCompile()</span></code><span class="koboSpan" id="kobo.693.1"> with an erroneous regular expression, the program panics and automatically terminates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.694.1">The next subsection shows how to define regular expressions.</span></p>
<h2 class="heading-2" id="_idParaDest-97"><span class="koboSpan" id="kobo.695.1">Go regular expressions</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.696.1">We begin this subsection by presenting</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.697.1"> some common match patterns used to construct regular expressions.</span></p>
<table class="table-container" id="table001-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.698.1">Expression</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.699.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">.</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.701.1">Matches any character</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.703.1">Means any number of times—cannot be used on its own</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.705.1">Zero or once—cannot be used on its own</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.706.1">+</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.707.1">Means one or more times—cannot be used on its own </span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.708.1">^</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.709.1">This denotes the beginning of the line</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.710.1">$</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.711.1">This denotes the end of the line</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.712.1">[]</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">[]</span></code><span class="koboSpan" id="kobo.714.1"> is for grouping characters</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">[A-Z]</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.716.1">This means all characters from capital </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">A</span></code><span class="koboSpan" id="kobo.718.1"> to capital </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">Z</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">\d</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.721.1">Any digit in </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">0-9</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.723.1">\D</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.724.1">A non-digit</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">\w</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.726.1">Any word character: </span><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">[0-9A-Za-z_]</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">\W</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.729.1">Any non-word character</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.730.1">\s</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.731.1">A whitespace character</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">\S</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.733.1">A non-whitespace character</span></p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><span class="koboSpan" id="kobo.734.1">The characters presented in the previous table are used for constructing and defining the grammar of a regular expression.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.735.1">Creating separate functions for pattern matching can be handy because it allows you to reuse the functions without worrying about the context of the program.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.736.1">Keep in mind that although regular expressions and pattern matching look convenient at first, they are the root </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.737.1">of lots of bugs. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.738.1">My advice is to use the simplest regular expression that can solve your problem</span></strong><span class="koboSpan" id="kobo.739.1">. </span><span class="koboSpan" id="kobo.739.2">However, avoiding using regular expressions while still doing your job would be much better in the long run!</span></p>
<h3 class="heading-3" id="_idParaDest-98"><span class="koboSpan" id="kobo.740.1">About raw string and interpreted string literals</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.741.1">Although we </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.742.1">discussed strings in the previous chapter, it is in the definition of the </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.743.1">regular expression in </span><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">diffRegExp.go</span></code><span class="koboSpan" id="kobo.745.1"> that we have used a </span><em class="italic"><span class="koboSpan" id="kobo.746.1">raw string literal</span></em><span class="koboSpan" id="kobo.747.1"> for the first time, so let us talk a little bit more about</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.748.1"> raw string literals, which are included in back quotes instead of double quotes. </span><span class="koboSpan" id="kobo.748.2">The advantages of raw string literals are the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.749.1">They can keep huge amounts of text inside them without the need for control characters, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">\n</span></code><span class="koboSpan" id="kobo.751.1">, for changing lines.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.752.1">They are handy when defining regular expressions because you do not need to use backquotes (</span><code class="codeHighlighted" style="font-weight: bold;"><span class="koboSpan" id="kobo.753.1">\</span></code><span class="koboSpan" id="kobo.754.1">) to escape special characters.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.755.1">They are used in structure tags, which are explained in </span><em class="chapterRef"><span class="koboSpan" id="kobo.756.1">Chapter 11</span></em><span class="koboSpan" id="kobo.757.1">, </span><em class="italic"><span class="koboSpan" id="kobo.758.1">Working with REST APIs</span></em><span class="koboSpan" id="kobo.759.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.760.1">So, in summary, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.761.1">raw string literals are for storing strings without any escape processing, whereas interpreted string literals are processed when the string is created</span></strong><span class="koboSpan" id="kobo.762.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.763.1">The next subsection presents regular expressions for matching names and surnames.</span></p>
<h2 class="heading-2" id="_idParaDest-99"><span class="koboSpan" id="kobo.764.1">Matching names and surnames</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.765.1">The presented </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.766.1">utility matches names and surnames—according to our definition, these are strings that begin with an uppercase letter and continue with lowercase letters. </span><span class="koboSpan" id="kobo.766.2">The input should not contain any numbers or other characters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.767.1">The source code of the utility can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.768.1">nameSurRE.go</span></code><span class="koboSpan" id="kobo.769.1">, which is in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">ch03</span></code><span class="koboSpan" id="kobo.771.1"> folder. </span><span class="koboSpan" id="kobo.771.2">The function that supports the desired functionality is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">matchNameSur()</span></code><span class="koboSpan" id="kobo.773.1"> and is implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.774.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.775.1">matchNameSur</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.776.1">(s </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.777.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.778.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.779.1">bool</span></span><span class="koboSpan" id="kobo.780.1"> {
    t := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.781.1">byte</span></span><span class="koboSpan" id="kobo.782.1">(s)
    re := regexp.MustCompile(</span><span class="hljs-string"><span class="koboSpan" id="kobo.783.1">`^[A-Z][a-z]*$`</span></span><span class="koboSpan" id="kobo.784.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.785.1">return</span></span><span class="koboSpan" id="kobo.786.1"> re.Match(t)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.787.1">The </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.788.1">logic of the function is in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.789.1">`^[A-Z][a-z]*$`</span></code><span class="koboSpan" id="kobo.790.1"> regular expression, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.791.1">^</span></code><span class="koboSpan" id="kobo.792.1"> denotes the beginning of a line and </span><code class="inlineCode"><span class="koboSpan" id="kobo.793.1">$</span></code><span class="koboSpan" id="kobo.794.1"> denotes the end of a line. </span><span class="koboSpan" id="kobo.794.2">What the regular expression does is to match anything that begins with an uppercase letter (</span><code class="inlineCode"><span class="koboSpan" id="kobo.795.1">[A-Z]</span></code><span class="koboSpan" id="kobo.796.1">) and continue with any number of lowercase letters (</span><code class="inlineCode"><span class="koboSpan" id="kobo.797.1">[a-z]*</span></code><span class="koboSpan" id="kobo.798.1">). </span><span class="koboSpan" id="kobo.798.2">This means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.799.1">Z</span></code><span class="koboSpan" id="kobo.800.1"> is a match, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.801.1">ZA</span></code><span class="koboSpan" id="kobo.802.1"> is not a match because the second letter is in uppercase. </span><span class="koboSpan" id="kobo.802.2">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.803.1">Jo+</span></code><span class="koboSpan" id="kobo.804.1"> is not a match because it contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.805.1">+</span></code><span class="koboSpan" id="kobo.806.1"> character.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.807.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.808.1">nameSurRE.go</span></code><span class="koboSpan" id="kobo.809.1"> with various types of input produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.810.1">$ </span></span><span class="koboSpan" id="kobo.811.1">go run nameSurRE.go Z 
true
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.812.1">$ </span></span><span class="koboSpan" id="kobo.813.1">go run nameSurRE.go ZA
false
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.814.1">$ </span></span><span class="koboSpan" id="kobo.815.1">go run nameSurRE.go Mihalis
True
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.816.1">This technique can help you check the validity of user input. </span><span class="koboSpan" id="kobo.816.2">The next subsection is about matching integers.</span></p>
<h2 class="heading-2" id="_idParaDest-100"><span class="koboSpan" id="kobo.817.1">Matching integers</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.818.1">The</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.819.1"> presented utility matches both signed and </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.820.1">unsigned integers—this is implemented in the way we define the regular expression. </span><span class="koboSpan" id="kobo.820.2">If we want to match unsigned integers only, then we should replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.821.1">[-+]?</span></code><span class="koboSpan" id="kobo.822.1"> in the regular expression with </span><code class="inlineCode"><span class="koboSpan" id="kobo.823.1">[+]?</span></code><span class="koboSpan" id="kobo.824.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.825.1">A better alternative than using a regular expression for matching integer values would have been the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.826.1">strconv.Atoi()</span></code><span class="koboSpan" id="kobo.827.1">. </span><span class="koboSpan" id="kobo.827.2">As a piece of advice, if you can avoid using regular expressions, opt for the alternative method. </span><span class="koboSpan" id="kobo.827.3">However, regular expressions are invaluable when you do not know in advance the kind or the amount of data to expect in the input. </span><span class="koboSpan" id="kobo.827.4">In general, regular expressions are invaluable for separating the various parts of the input. </span><span class="koboSpan" id="kobo.827.5">Keep in mind that regular expressions are always matching strings, and you can also find digits in strings.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.828.1">The source code of the utility can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.829.1">intRE.go</span></code><span class="koboSpan" id="kobo.830.1">, which is in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.831.1">ch03</span></code><span class="koboSpan" id="kobo.832.1"> directory. </span><span class="koboSpan" id="kobo.832.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.833.1">matchInt()</span></code><span class="koboSpan" id="kobo.834.1"> function that supports the desired functionality is implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.835.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.836.1">matchInt</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.837.1">(s </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.838.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.839.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.840.1">bool</span></span><span class="koboSpan" id="kobo.841.1"> {
    t := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.842.1">byte</span></span><span class="koboSpan" id="kobo.843.1">(s)
    re := regexp.MustCompile(</span><span class="hljs-string"><span class="koboSpan" id="kobo.844.1">`^[-+]?\d+$`</span></span><span class="koboSpan" id="kobo.845.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.846.1">return</span></span><span class="koboSpan" id="kobo.847.1"> re.Match(t)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.848.1">As before, the</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.849.1"> logic of the function is found in the regular</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.850.1"> expression that is used for matching integers, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.851.1">`^[-+]?\d+$`</span></code><span class="koboSpan" id="kobo.852.1">. </span><span class="koboSpan" id="kobo.852.2">In plain English, what we mean here is that we want to match something that begins with </span><code class="inlineCode"><span class="koboSpan" id="kobo.853.1">–</span></code><span class="koboSpan" id="kobo.854.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.855.1">+</span></code><span class="koboSpan" id="kobo.856.1">, which is optional (</span><code class="inlineCode"><span class="koboSpan" id="kobo.857.1">?</span></code><span class="koboSpan" id="kobo.858.1">), and ends with any number of digits (</span><code class="inlineCode"><span class="koboSpan" id="kobo.859.1">\d+</span></code><span class="koboSpan" id="kobo.860.1">)—it is required that we have at least one digit before the end of the string that is examined (</span><code class="inlineCode"><span class="koboSpan" id="kobo.861.1">$</span></code><span class="koboSpan" id="kobo.862.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.863.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.864.1">intRE.go</span></code><span class="koboSpan" id="kobo.865.1"> with various types of input produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.866.1">$ </span></span><span class="koboSpan" id="kobo.867.1">go run intRE.go 123
true
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.868.1">$ </span></span><span class="koboSpan" id="kobo.869.1">go run intRE.go /123
false
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.870.1">$ </span></span><span class="koboSpan" id="kobo.871.1">go run intRE.go +123.2
false
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.872.1">$ </span></span><span class="koboSpan" id="kobo.873.1">go run intRE.go +
false
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.874.1">$ </span></span><span class="koboSpan" id="kobo.875.1">go run intRE.go -123.2
false 
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.876.1">Later in this book, you will learn how to test Go code by writing testing functions—for now, we will do most of the testing manually.</span></p>
<h1 class="heading-1" id="_idParaDest-101"><span class="koboSpan" id="kobo.877.1">Improving the statistics application</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.878.1">It is time to update the statistics application. </span><span class="koboSpan" id="kobo.878.2">The new version of the statistics utility has the following</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.879.1"> improvements:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.880.1">It uses functions to simplify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.881.1">main()</span></code><span class="koboSpan" id="kobo.882.1"> function and improve the overall design.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.883.1">It can read CSV files that contain the numeric input.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.884.1">But first, we need to learn how to work with CVS files in Go, which is the subject of the next subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-102"><span class="koboSpan" id="kobo.885.1">Working with CSV files</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.886.1">Most of</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.887.1"> the time, you do not want to lose your data or have to begin without any data every time you execute your application. </span><span class="koboSpan" id="kobo.887.2">There exist many techniques for doing so—the easiest one is by saving your data locally. </span><span class="koboSpan" id="kobo.887.3">A very easy-to-work-with plain text file format is CSV, which is what is explained here and used in the statistics application later on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.888.1">The good thing is that Go provides a dedicated package for working with CSV data, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.889.1">encoding/csv</span></code><span class="koboSpan" id="kobo.890.1"> (</span><a href="https://pkg.go.dev/encoding/csv"><span class="url"><span class="koboSpan" id="kobo.891.1">https://pkg.go.dev/encoding/csv</span></span></a><span class="koboSpan" id="kobo.892.1">). </span><span class="koboSpan" id="kobo.892.2">For the presented utility, both the input and output files are given as command line arguments.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.893.1">When reading or writing CSV data from disk, everything is considered a string. </span><span class="koboSpan" id="kobo.893.2">Therefore, if you have numeric data that you want to treat as such during the reading phase, you might need to convert it to the proper data type on your own.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.894.1">There exist two very popular Go interfaces, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">io.Reader</span></code><span class="koboSpan" id="kobo.896.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.897.1">io.Write</span></code><span class="koboSpan" id="kobo.898.1">, that relate to reading and writing files, respectively. </span><span class="koboSpan" id="kobo.898.2">Almost all reading and writing operations in Go use these two interfaces. </span><span class="koboSpan" id="kobo.898.3">The use of the same interface for all readers allows readers to share some common characteristics, but most importantly, it allows you to create your own readers and use them anywhere that Go expects an </span><code class="inlineCode"><span class="koboSpan" id="kobo.899.1">io.Reader</span></code><span class="koboSpan" id="kobo.900.1"> reader. </span><span class="koboSpan" id="kobo.900.2">The same applies to writers that satisfy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.901.1">io.Write</span></code><span class="koboSpan" id="kobo.902.1"> interface. </span><span class="koboSpan" id="kobo.902.2">You are going to learn more about interfaces in </span><em class="chapterRef"><span class="koboSpan" id="kobo.903.1">Chapter 5</span></em><span class="koboSpan" id="kobo.904.1">, </span><em class="italic"><span class="koboSpan" id="kobo.905.1">Reflection and Interfaces</span></em><span class="koboSpan" id="kobo.906.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.907.1">The main tasks that need to be implemented are the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.908.1">Loading CSV data from disk and putting it into a slice of structures</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.909.1">Saving data to disk using the CSV format</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.910.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.911.1">encoding/csv</span></code><span class="koboSpan" id="kobo.912.1"> package contains functions that can help you read and write CSV files. </span><span class="koboSpan" id="kobo.912.2">As we are dealing with small CSV files, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.913.1">csv.NewReader(f).ReadAll()</span></code><span class="koboSpan" id="kobo.914.1"> to read the entire input file at once. </span><span class="koboSpan" id="kobo.914.2">For bigger data files, or if we wanted to check the input or make any changes to the input as we read it, it would have been better to read it line by line using </span><code class="inlineCode"><span class="koboSpan" id="kobo.915.1">Read()</span></code><span class="koboSpan" id="kobo.916.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">ReadAll()</span></code><span class="koboSpan" id="kobo.918.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.919.1">Go assumes that the CSV file uses the comma character (</span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">,</span></code><span class="koboSpan" id="kobo.921.1">) for separating the different fields of each line. </span><span class="koboSpan" id="kobo.921.2">Should we wish to change that behavior, we should change the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.922.1">Comma</span></code><span class="koboSpan" id="kobo.923.1"> variable of the CSV reader or the writer, depending on the task we want to perform. </span><span class="koboSpan" id="kobo.923.2">We </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.924.1">change that behavior in the output CSV file, which separates its fields using the tab character.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.925.1">For reasons of compatibility, it is better if the input and output CSV files use the same field delimiter. </span><span class="koboSpan" id="kobo.925.2">We are just using the tab character as the field delimiter in the output file to illustrate the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">Comma</span></code><span class="koboSpan" id="kobo.927.1"> variable.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.928.1">As working with CSV files is a new topic, there is a separate utility named </span><code class="inlineCode"><span class="koboSpan" id="kobo.929.1">csvData.go</span></code><span class="koboSpan" id="kobo.930.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.931.1">ch03</span></code><span class="koboSpan" id="kobo.932.1"> directory of the GitHub repository of this book that illustrates the techniques for reading and writing CSV files. </span><span class="koboSpan" id="kobo.932.2">The source code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.933.1">csvData.go</span></code><span class="koboSpan" id="kobo.934.1"> is presented in chunks. </span><span class="koboSpan" id="kobo.934.2">First, we present the preamble of </span><code class="inlineCode"><span class="koboSpan" id="kobo.935.1">csvData.go</span></code><span class="koboSpan" id="kobo.936.1"> that contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">import</span></code><span class="koboSpan" id="kobo.938.1"> section as well as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.939.1">Record</span></code><span class="koboSpan" id="kobo.940.1"> structure and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.941.1">myData</span></code><span class="koboSpan" id="kobo.942.1"> global variable, which is a slice of </span><code class="inlineCode"><span class="koboSpan" id="kobo.943.1">Record</span></code><span class="koboSpan" id="kobo.944.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.945.1">package</span></span><span class="koboSpan" id="kobo.946.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.947.1">import</span></span><span class="koboSpan" id="kobo.948.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.949.1">"encoding/csv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.950.1">"log"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.951.1">"os"</span></span><span class="koboSpan" id="kobo.952.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.953.1">type</span></span><span class="koboSpan" id="kobo.954.1"> Record </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.955.1">struct</span></span><span class="koboSpan" id="kobo.956.1"> {
    Name       </span><span class="hljs-type"><span class="koboSpan" id="kobo.957.1">string</span></span><span class="koboSpan" id="kobo.958.1">
    Surname    </span><span class="hljs-type"><span class="koboSpan" id="kobo.959.1">string</span></span><span class="koboSpan" id="kobo.960.1">
    Number     </span><span class="hljs-type"><span class="koboSpan" id="kobo.961.1">string</span></span><span class="koboSpan" id="kobo.962.1">
    LastAccess </span><span class="hljs-type"><span class="koboSpan" id="kobo.963.1">string</span></span><span class="koboSpan" id="kobo.964.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.965.1">var</span></span><span class="koboSpan" id="kobo.966.1"> myData = []Record{}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.967.1">Then, we present the </span><code class="inlineCode"><span class="koboSpan" id="kobo.968.1">readCSVFile()</span></code><span class="koboSpan" id="kobo.969.1"> function, which reads the plain text file with the CSV data.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.970.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.971.1">readCSVFile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.972.1">(filepath </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.973.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.974.1">)</span></span><span class="koboSpan" id="kobo.975.1"> ([][]</span><span class="hljs-type"><span class="koboSpan" id="kobo.976.1">string</span></span><span class="koboSpan" id="kobo.977.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.978.1">error</span></span><span class="koboSpan" id="kobo.979.1">) {
    _, err := os.Stat(filepath)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.980.1">if</span></span><span class="koboSpan" id="kobo.981.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.982.1">nil</span></span><span class="koboSpan" id="kobo.983.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.984.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.985.1">nil</span></span><span class="koboSpan" id="kobo.986.1">, err
    }
    f, err := os.Open(filepath)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.987.1">if</span></span><span class="koboSpan" id="kobo.988.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.989.1">nil</span></span><span class="koboSpan" id="kobo.990.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.991.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.992.1">nil</span></span><span class="koboSpan" id="kobo.993.1">, err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.994.1">defer</span></span><span class="koboSpan" id="kobo.995.1"> f.Close()
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.996.1">// CSV file read all at once</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.997.1">// lines data type is [][]string</span></span><span class="koboSpan" id="kobo.998.1">
    lines, err := csv.NewReader(f).ReadAll()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.999.1">if</span></span><span class="koboSpan" id="kobo.1000.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1001.1">nil</span></span><span class="koboSpan" id="kobo.1002.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1003.1">return</span></span><span class="koboSpan" id="kobo.1004.1"> [][]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1005.1">string</span></span><span class="koboSpan" id="kobo.1006.1">{}, err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1007.1">return</span></span><span class="koboSpan" id="kobo.1008.1"> lines, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1009.1">nil</span></span><span class="koboSpan" id="kobo.1010.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1011.1">Note that</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.1012.1"> we check whether the given file path exists and is associated with a regular file inside the function. </span><span class="koboSpan" id="kobo.1012.2">There is no right or wrong decision about where to perform that checking—you just have to be consistent. </span><span class="koboSpan" id="kobo.1012.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1013.1">readCSVFile()</span></code><span class="koboSpan" id="kobo.1014.1"> function returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1015.1">[][]string</span></code><span class="koboSpan" id="kobo.1016.1"> slice that contains all the lines we have read. </span><span class="koboSpan" id="kobo.1016.2">Additionally, keep in mind that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1017.1">csv.NewReader()</span></code><span class="koboSpan" id="kobo.1018.1"> does separate the fields of each input line, which is the main reason for needing a slice with two dimensions to store the input.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1019.1">After that, we illustrate the writing to a CSV file technique with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1020.1">saveCSVFile()</span></code><span class="koboSpan" id="kobo.1021.1"> function.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1022.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1023.1">saveCSVFile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1024.1">(filepath </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1025.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1026.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1027.1">error</span></span><span class="koboSpan" id="kobo.1028.1"> {
    csvfile, err := os.Create(filepath)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1029.1">if</span></span><span class="koboSpan" id="kobo.1030.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1031.1">nil</span></span><span class="koboSpan" id="kobo.1032.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1033.1">return</span></span><span class="koboSpan" id="kobo.1034.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1035.1">defer</span></span><span class="koboSpan" id="kobo.1036.1"> csvfile.Close()
    csvwriter := csv.NewWriter(csvfile)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1037.1">// Changing the default field delimiter to tab</span></span><span class="koboSpan" id="kobo.1038.1">
    csvwriter.Comma = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1039.1">'\t'</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1040.1">for</span></span><span class="koboSpan" id="kobo.1041.1"> _, row := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1042.1">range</span></span><span class="koboSpan" id="kobo.1043.1"> myData {
        temp := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1044.1">string</span></span><span class="koboSpan" id="kobo.1045.1">{row.Name, row.Surname, row.Number, row.LastAccess}
        err = csvwriter.Write(temp)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1046.1">if</span></span><span class="koboSpan" id="kobo.1047.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1048.1">nil</span></span><span class="koboSpan" id="kobo.1049.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1050.1">return</span></span><span class="koboSpan" id="kobo.1051.1"> err
        }
    }
    csvwriter.Flush()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1052.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1053.1">nil</span></span><span class="koboSpan" id="kobo.1054.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1055.1">Note the change in the default value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1056.1">csvwriter.Comma</span></code><span class="koboSpan" id="kobo.1057.1"> to match our needs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1058.1">Lastly, we can</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.1059.1"> see the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">main()</span></code><span class="koboSpan" id="kobo.1061.1"> function.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1062.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1063.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1064.1">()</span></span><span class="koboSpan" id="kobo.1065.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1066.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1067.1">len</span></span><span class="koboSpan" id="kobo.1068.1">(os.Args) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.1069.1">3</span></span><span class="koboSpan" id="kobo.1070.1"> {
        log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1071.1">"csvData input output!"</span></span><span class="koboSpan" id="kobo.1072.1">)
        os.Exit(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1073.1">1</span></span><span class="koboSpan" id="kobo.1074.1">)
    }
    input := os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1075.1">1</span></span><span class="koboSpan" id="kobo.1076.1">]
    output := os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1077.1">2</span></span><span class="koboSpan" id="kobo.1078.1">]
    lines, err := readCSVFile(input)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1079.1">if</span></span><span class="koboSpan" id="kobo.1080.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1081.1">nil</span></span><span class="koboSpan" id="kobo.1082.1"> {
        log.Println(err)
        os.Exit(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1083.1">1</span></span><span class="koboSpan" id="kobo.1084.1">)
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1085.1">// CSV data is read in columns - each line is a slice</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1086.1">for</span></span><span class="koboSpan" id="kobo.1087.1"> _, line := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1088.1">range</span></span><span class="koboSpan" id="kobo.1089.1"> lines {
        temp := Record{
            Name:       line[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1090.1">0</span></span><span class="koboSpan" id="kobo.1091.1">],
            Surname:    line[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1092.1">1</span></span><span class="koboSpan" id="kobo.1093.1">],
            Number:     line[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1094.1">2</span></span><span class="koboSpan" id="kobo.1095.1">],
            LastAccess: line[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1096.1">3</span></span><span class="koboSpan" id="kobo.1097.1">],
        }
        myData = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1098.1">append</span></span><span class="koboSpan" id="kobo.1099.1">(myData, temp)
        log.Println(temp)
    }
    err = saveCSVFile(output)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1100.1">if</span></span><span class="koboSpan" id="kobo.1101.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1102.1">nil</span></span><span class="koboSpan" id="kobo.1103.1"> {
        log.Println(err)
        os.Exit(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1104.1">1</span></span><span class="koboSpan" id="kobo.1105.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1106.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1107.1">main()</span></code><span class="koboSpan" id="kobo.1108.1"> function puts what you have read with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1109.1">readCSVFile()</span></code><span class="koboSpan" id="kobo.1110.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1111.1">myData</span></code><span class="koboSpan" id="kobo.1112.1"> slice—remember that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1113.1">lines</span></code><span class="koboSpan" id="kobo.1114.1"> is a slice with two dimensions and that each row in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1115.1">lines</span></code><span class="koboSpan" id="kobo.1116.1"> is already separated into fields. </span><span class="koboSpan" id="kobo.1116.2">In this case, each line of input contains four fields. </span><span class="koboSpan" id="kobo.1116.3">So we process that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1117.1">[][]string</span></code><span class="koboSpan" id="kobo.1118.1"> slice and put the desired information in the slice of structures (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1119.1">myData</span></code><span class="koboSpan" id="kobo.1120.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1121.1">The contents of the CSV data file used as input are as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1122.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1123.1">cat</span></span><span class="koboSpan" id="kobo.1124.1"> ~/csv.data
Dimitris,Tsoukalos,2101112223,1600665563
Mihalis,Tsoukalos,2109416471,1600665563
Jane,Doe,0800123456,1608559903
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1125.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1126.1">csvData.go</span></code><span class="koboSpan" id="kobo.1127.1"> produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1128.1">$ </span></span><span class="koboSpan" id="kobo.1129.1">go run csvData.go ~/csv.data /tmp/output.data
{Dimitris Tsoukalos 2101112223 1600665563}
{Mihalis Tsoukalos 2109416471 1600665563}
{Jane Doe 0800123456 1608559903}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1130.1">The</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.1131.1"> contents of the output CSV file are the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1132.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1133.1">cat</span></span><span class="koboSpan" id="kobo.1134.1"> /tmp/output.data
Dimitris        Tsoukalos       2101112223      1600665563
Mihalis Tsoukalos       2109416471      1600665563
Jane    Doe     0800123456      1608559903
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1135.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1136.1">output.data</span></code><span class="koboSpan" id="kobo.1137.1"> file uses tab characters to separate the different fields of each record, hence the generated output. </span><span class="koboSpan" id="kobo.1137.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1138.1">csvData.go</span></code><span class="koboSpan" id="kobo.1139.1"> utility can be handy for performing conversions between different types of CSV files.</span></p>
<h2 class="heading-2" id="_idParaDest-103"><span class="koboSpan" id="kobo.1140.1">The updated version of the statistics application</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1141.1">In this subsection, we </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.1142.1">are going to show the updated code of the statistics application. </span><span class="koboSpan" id="kobo.1142.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1143.1">normalized()</span></code><span class="koboSpan" id="kobo.1144.1"> function has not changed, so it is not presented again.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1145.1">The first code excerpt from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1146.1">stats.go</span></code><span class="koboSpan" id="kobo.1147.1"> is the implementation of the function that reads the CSV file as text and converts it into a slice of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1148.1">float64</span></code><span class="koboSpan" id="kobo.1149.1"> values.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1150.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1151.1">readFile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1152.1">(filepath </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1153.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1154.1">)</span></span><span class="koboSpan" id="kobo.1155.1"> ([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1156.1">float64</span></span><span class="koboSpan" id="kobo.1157.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1158.1">error</span></span><span class="koboSpan" id="kobo.1159.1">) {
    _, err := os.Stat(filepath)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1160.1">if</span></span><span class="koboSpan" id="kobo.1161.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1162.1">nil</span></span><span class="koboSpan" id="kobo.1163.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1164.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1165.1">nil</span></span><span class="koboSpan" id="kobo.1166.1">, err
    }
    f, err := os.Open(filepath)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1167.1">if</span></span><span class="koboSpan" id="kobo.1168.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1169.1">nil</span></span><span class="koboSpan" id="kobo.1170.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1171.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1172.1">nil</span></span><span class="koboSpan" id="kobo.1173.1">, err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1174.1">defer</span></span><span class="koboSpan" id="kobo.1175.1"> f.Close()
    lines, err := csv.NewReader(f).ReadAll()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1176.1">if</span></span><span class="koboSpan" id="kobo.1177.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1178.1">nil</span></span><span class="koboSpan" id="kobo.1179.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1180.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1181.1">nil</span></span><span class="koboSpan" id="kobo.1182.1">, err
    }
    values := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1183.1">make</span></span><span class="koboSpan" id="kobo.1184.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1185.1">float64</span></span><span class="koboSpan" id="kobo.1186.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1187.1">0</span></span><span class="koboSpan" id="kobo.1188.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1189.1">for</span></span><span class="koboSpan" id="kobo.1190.1"> _, line := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1191.1">range</span></span><span class="koboSpan" id="kobo.1192.1"> lines {
        </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.1193.1">tmp, err := strconv.ParseFloat(line[</span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.1194.1">0</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.1195.1">], </span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.1196.1">64</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.1197.1">)</span></strong></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1198.1">if</span></span><span class="koboSpan" id="kobo.1199.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1200.1">nil</span></span><span class="koboSpan" id="kobo.1201.1"> {
            log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1202.1">"Error reading:"</span></span><span class="koboSpan" id="kobo.1203.1">, line[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1204.1">0</span></span><span class="koboSpan" id="kobo.1205.1">], err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1206.1">continue</span></span><span class="koboSpan" id="kobo.1207.1">
        }
        values = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1208.1">append</span></span><span class="koboSpan" id="kobo.1209.1">(values, tmp)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1210.1">return</span></span><span class="koboSpan" id="kobo.1211.1"> values, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1212.1">nil</span></span><span class="koboSpan" id="kobo.1213.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1214.1">Once the </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.1215.1">specified CSV file is read, its data is put into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1216.1">lines</span></code><span class="koboSpan" id="kobo.1217.1"> variable. </span><span class="koboSpan" id="kobo.1217.2">Keep in mind that, in our case, each line in the CSV file has a single field. </span><span class="koboSpan" id="kobo.1217.3">Nevertheless, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1218.1">lines</span></code><span class="koboSpan" id="kobo.1219.1"> has two dimensions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1220.1">As we want to return a slice of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1221.1">float64</span></code><span class="koboSpan" id="kobo.1222.1"> values, we have to convert the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1223.1">[][]string</span></code><span class="koboSpan" id="kobo.1224.1"> variable into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1225.1">[]float64</span></code><span class="koboSpan" id="kobo.1226.1"> variable, which is the purpose of the last </span><code class="inlineCode"><span class="koboSpan" id="kobo.1227.1">for</span></code><span class="koboSpan" id="kobo.1228.1"> loop. </span><span class="koboSpan" id="kobo.1228.2">The most important task of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1229.1">for</span></code><span class="koboSpan" id="kobo.1230.1"> loop is to make sure that all strings are valid </span><code class="inlineCode"><span class="koboSpan" id="kobo.1231.1">float64</span></code><span class="koboSpan" id="kobo.1232.1"> values, in order to put them in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1233.1">values</span></code><span class="koboSpan" id="kobo.1234.1"> slice—this is the purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1235.1">strconv.ParseFloat(line[0], 64)</span></code><span class="koboSpan" id="kobo.1236.1"> call.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1237.1">Next, we have the implementation of the function that computes the standard deviation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1238.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1239.1">stdDev</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1240.1">(x []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1241.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1242.1">)</span></span><span class="koboSpan" id="kobo.1243.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.1244.1">float64</span></span><span class="koboSpan" id="kobo.1245.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1246.1">float64</span></span><span class="koboSpan" id="kobo.1247.1">) {
    sum := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1248.1">0.0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1249.1">for</span></span><span class="koboSpan" id="kobo.1250.1"> _, val := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1251.1">range</span></span><span class="koboSpan" id="kobo.1252.1"> x {
        sum = sum + val
    }
    meanValue := sum / </span><span class="hljs-type"><span class="koboSpan" id="kobo.1253.1">float64</span></span><span class="koboSpan" id="kobo.1254.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1255.1">len</span></span><span class="koboSpan" id="kobo.1256.1">(x))
    </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.1257.1">fmt.Printf(</span></strong><strong class="hljs-string-slc"><span class="koboSpan" id="kobo.1258.1">"Mean value: %.5f\n"</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.1259.1">, meanValue)</span></strong></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1260.1">// Standard deviation</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1261.1">var</span></span><span class="koboSpan" id="kobo.1262.1"> squared </span><span class="hljs-type"><span class="koboSpan" id="kobo.1263.1">float64</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1264.1">for</span></span><span class="koboSpan" id="kobo.1265.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1266.1">0</span></span><span class="koboSpan" id="kobo.1267.1">; i &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1268.1">len</span></span><span class="koboSpan" id="kobo.1269.1">(x); i++ {
        squared = squared + math.Pow((x[i]-meanValue), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1270.1">2</span></span><span class="koboSpan" id="kobo.1271.1">)
    }
    standardDeviation := math.Sqrt(squared / </span><span class="hljs-type"><span class="koboSpan" id="kobo.1272.1">float64</span></span><span class="koboSpan" id="kobo.1273.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1274.1">len</span></span><span class="koboSpan" id="kobo.1275.1">(x)))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1276.1">return</span></span><span class="koboSpan" id="kobo.1277.1"> meanValue, standardDeviation
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1278.1">First, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1279.1">stdDev()</span></code><span class="koboSpan" id="kobo.1280.1"> computes </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.1281.1">the sum of all given values and, after that, the mean value of the data. </span><span class="koboSpan" id="kobo.1281.2">Last, the standard deviation is computed. </span><span class="koboSpan" id="kobo.1281.3">You can remove the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1282.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.1283.1"> call inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1284.1">stdDev()</span></code><span class="koboSpan" id="kobo.1285.1"> function when you are sure that everything works as expected.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1286.1">Lastly, here is the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1287.1">main()</span></code><span class="koboSpan" id="kobo.1288.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1289.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1290.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1291.1">()</span></span><span class="koboSpan" id="kobo.1292.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1293.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1294.1">len</span></span><span class="koboSpan" id="kobo.1295.1">(os.Args) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1296.1">1</span></span><span class="koboSpan" id="kobo.1297.1"> {
        log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1298.1">"Need one argument!"</span></span><span class="koboSpan" id="kobo.1299.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1300.1">return</span></span><span class="koboSpan" id="kobo.1301.1">
    }
    file := os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1302.1">1</span></span><span class="koboSpan" id="kobo.1303.1">]
    values, err := readFile(file)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1304.1">if</span></span><span class="koboSpan" id="kobo.1305.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1306.1">nil</span></span><span class="koboSpan" id="kobo.1307.1"> {
        log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1308.1">"Error reading:"</span></span><span class="koboSpan" id="kobo.1309.1">, file, err)
        os.Exit(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1310.1">0</span></span><span class="koboSpan" id="kobo.1311.1">)
    }
    sort.Float64s(values)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1312.1">"Number of values:"</span></span><span class="koboSpan" id="kobo.1313.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1314.1">len</span></span><span class="koboSpan" id="kobo.1315.1">(values))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1316.1">"Min:"</span></span><span class="koboSpan" id="kobo.1317.1">, values[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1318.1">0</span></span><span class="koboSpan" id="kobo.1319.1">])
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1320.1">"Max:"</span></span><span class="koboSpan" id="kobo.1321.1">, values[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1322.1">len</span></span><span class="koboSpan" id="kobo.1323.1">(values)</span><span class="hljs-number"><span class="koboSpan" id="kobo.1324.1">-1</span></span><span class="koboSpan" id="kobo.1325.1">])
    meanValue, standardDeviation := stdDev(values)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1326.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1327.1">Standard deviation: %.5f\n"</span></span><span class="koboSpan" id="kobo.1328.1">, standardDeviation)
    normalized := normalize(values, meanValue, standardDeviation)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1329.1">"Normalized:"</span></span><span class="koboSpan" id="kobo.1330.1">, normalized)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1331.1">Although the core functionality of the updated version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1332.1">stats.go</span></code><span class="koboSpan" id="kobo.1333.1"> is the same as the version developed in the previous chapter, the use of functions simplifies the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1334.1">main()</span></code><span class="koboSpan" id="kobo.1335.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1336.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1337.1">stats.go</span></code><span class="koboSpan" id="kobo.1338.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1339.1">$ </span></span><span class="koboSpan" id="kobo.1340.1">go run stats.go csvData.txt
Error reading: a strconv.ParseFloat: parsing "a": invalid syntax
Number of values: 6
Min: -1.2
Max: 3
Mean value: 0.66667
Standard deviation: 1.54883
Normalized: [-1.2053 -1.0761 -0.4305 0.2797 0.9254 1.5065
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1341.1">The previous</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.1342.1"> output shows that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1343.1">csvData.txt</span></code><span class="koboSpan" id="kobo.1344.1"> contains an invalid line—the contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1345.1">csvData.txt</span></code><span class="koboSpan" id="kobo.1346.1"> are the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1347.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1348.1">cat</span></span><span class="koboSpan" id="kobo.1349.1"> csvData.txt
1.1
2.1
-1.2
-1
0
a
3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1350.1">Despite being much better than the previous version, the new version of the statistics utility is still not perfect. </span><span class="koboSpan" id="kobo.1350.2">Here is a list of things that can be improved:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1351.1">The ability to process multiple CSV data files.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1352.1">The ability to sort its output based on a predefined statistics property, such as the mean value when dealing with multiple CSV data files.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1353.1">The ability to use JSON records and JSON slices for the data instead of CSV files.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1354.1">The statistics application will keep improving, starting from </span><em class="chapterRef"><span class="koboSpan" id="kobo.1355.1">Chapter 5</span></em><span class="koboSpan" id="kobo.1356.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1357.1">Reflection and Interfaces</span></em><span class="koboSpan" id="kobo.1358.1">, where sorting slices with structure elements is implemented.</span></p>
<h1 class="heading-1" id="_idParaDest-104"><span class="koboSpan" id="kobo.1359.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1360.1">In this chapter, we discussed the composite data types of Go, which are maps and structures. </span><span class="koboSpan" id="kobo.1360.2">Additionally, we talked about working with CSV files as well as using regular expressions and pattern matching. </span><span class="koboSpan" id="kobo.1360.3">We can now keep our data in proper structures, validate it using regular expressions, and store it in CSV files to achieve data persistency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1361.1">Always keep in mind that </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1362.1">if you try to get the value of a key that does not exist in a map, Go will not complain about it and will return the zero value of the data type of the value.</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.1363.1">The next chapter is about Go generics, which is a relatively new Go feature.</span></p>
<h1 class="heading-1" id="_idParaDest-105"><span class="koboSpan" id="kobo.1364.1">Exercises</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1365.1">Write a Go program that converts an existing array into a map.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1366.1">Write a Go program that converts an existing map into two slices—the first slice containing the keys of the map whereas the second one containing the values. </span><span class="koboSpan" id="kobo.1366.2">The values at index </span><code class="inlineCode"><span class="koboSpan" id="kobo.1367.1">n</span></code><span class="koboSpan" id="kobo.1368.1"> of the two slices should correspond to a key and value pair that can be found in the original map.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1369.1">Make the necessary changes to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1370.1">nameSurRE.go</span></code><span class="koboSpan" id="kobo.1371.1"> to be able to process multiple command line arguments.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1372.1">Change the code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1373.1">intRE.go</span></code><span class="koboSpan" id="kobo.1374.1"> to process multiple command line arguments and display totals of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1375.1">true</span></code><span class="koboSpan" id="kobo.1376.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1377.1">false</span></code><span class="koboSpan" id="kobo.1378.1"> results at the end.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1379.1">Make changes to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1380.1">csvData.go</span></code><span class="koboSpan" id="kobo.1381.1"> to separate the fields of a record based on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1382.1">#</span></code><span class="koboSpan" id="kobo.1383.1"> character.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1384.1">To understand how difficult regular expressions might end up, look on the internet for a regular expression to match email addresses.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1385.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1386.1">regexp</span></code><span class="koboSpan" id="kobo.1387.1"> package includes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1388.1">MatchString()</span></code><span class="koboSpan" id="kobo.1389.1"> method. </span><span class="koboSpan" id="kobo.1389.2">Try to understand its main difference from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1390.1">Match</span></code><span class="koboSpan" id="kobo.1391.1"> method and create a working example.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1392.1">Write a Go utility that converts </span><code class="inlineCode"><span class="koboSpan" id="kobo.1393.1">os.Args</span></code><span class="koboSpan" id="kobo.1394.1"> into a slice of structures, with fields for storing the index and the value of each command line argument—you should define the structure that is going to be used.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1395.1">Make changes to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1396.1">csvData.go</span></code><span class="koboSpan" id="kobo.1397.1"> to separate the fields of a record, using a single character that is given as a command line argument.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1398.1">Modify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1399.1">stdDev()</span></code><span class="koboSpan" id="kobo.1400.1"> function of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1401.1">stats.go</span></code><span class="koboSpan" id="kobo.1402.1">, in order to save the mean value of the sample into a global variable and delete the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.1404.1"> call from it.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-106"><span class="koboSpan" id="kobo.1405.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1406.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1407.1">encoding/csv</span></code><span class="koboSpan" id="kobo.1408.1"> documentation: </span><a href="https://pkg.go.dev/encoding/csv"><span class="url"><span class="koboSpan" id="kobo.1409.1">https://pkg.go.dev/encoding/csv</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1410.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1411.1">runtime</span></code><span class="koboSpan" id="kobo.1412.1"> package documentation: </span><a href="https://pkg.go.dev/runtime"><span class="url"><span class="koboSpan" id="kobo.1413.1">https://pkg.go.dev/runtime</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1414.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1415.1">regexp</span></code><span class="koboSpan" id="kobo.1416.1"> package documentation: </span><a href="https://pkg.go.dev/regexp "><span class="url"><span class="koboSpan" id="kobo.1417.1">https://pkg.go.dev/regexp</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1418.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1419.1">Join our community’s Discord space for discussions with the authors and other readers:</span></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.1420.1">https://discord.gg/FzuQbc8zd6</span></span></a></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.1421.1"><img alt="" role="presentation" src="../Images/QR_Code2286825896190168453.png"/></span></span></a></p>
</div>
</body></html>