["```go\nm := map[string]int {\n    \"key1\": -1\n\"key2\": 123\n} \n```", "```go\nfunc main() {\n    aMap := map[string]int{}\n    aMap[\"test\"] = 1 \n```", "```go\n fmt.Println(\"aMap:\", aMap)\n    aMap = nil \n```", "```go\n fmt.Println(\"aMap:\", aMap)\n    if aMap == nil {\n        fmt.Println(\"nil map!\")\n        aMap = map[string]int{}\n    } \n```", "```go\n aMap[\"test\"] = 1\n// This will crash!\n    aMap = nil\n    aMap[\"test\"] = 1\n} \n```", "```go\n$ go run nilMap.go\naMap: map[test:1]\naMap: map[]\nnil map!\npanic: assignment to entry in nil map\ngoroutine 1 [running]:\nmain.main()\n    /Users/mtsouk/Desktop/mGo4th/code/ch03/nilMap.go:21 +0x17c\nexit status 2 \n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n    aMap := make(map[string]string)\n    aMap[\"123\"] = \"456\"\n    aMap[\"key\"] = \"A value\"\nfor key, v := range aMap {\n        fmt.Println(\"key:\", key, \"value:\", v)\n    } \n```", "```go\n for _, v := range aMap {\n        fmt.Print(\" # \", v)\n    }\n    fmt.Println()\n} \n```", "```go\n$ go run forMaps.go\nkey: key value: A value\nkey: 123 value: 456\n # 456 # A value \n```", "```go\ntype Entry struct {\n    Name    string\n    Surname string\n    Year    int\n} \n```", "```go\npackage main\nimport \"fmt\"\ntype Entry struct {\n    Name    string\n    Surname string\n    Year    int\n}\n// Initialized by Go\nfunc zeroS() Entry {\n    return Entry{}\n} \n```", "```go\n// Initialized by the user\nfunc initS(N, S string, Y int) Entry {\n    if Y < 2000 {\n        return Entry{Name: N, Surname: S, Year: 2000}\n    }\n    return Entry{Name: N, Surname: S, Year: Y}\n} \n```", "```go\n// Initialized by Go - returns pointer\nfunc zeroPtoS() *Entry {\n    t := &Entry{}\n    return t\n} \n```", "```go\n// Initialized by the user - returns pointer\nfunc initPtoS(N, S string, Y int) *Entry {\n    if len(S) == 0 {\n        return &Entry{Name: N, Surname: \"Unknown\", Year: Y}\n    }\n    return &Entry{Name: N, Surname: S, Year: Y}\n} \n```", "```go\nfunc main() {\n    s1 := zeroS()\n    p1 := zeroPtoS()\n    fmt.Println(\"s1:\", s1, \"p1:\", *p1)\n    s2 := initS(\"Mihalis\", \"Tsoukalos\", 2024)\n    p2 := initPtoS(\"Mihalis\", \"Tsoukalos\", 2024)\n    fmt.Println(\"s2:\", s2, \"p2:\", *p2)\n    fmt.Println(\"Year:\", s1.Year, s2.Year, p1.Year, p2.Year)\n    pS := new(Entry)\n    fmt.Println(\"pS:\", pS)\n} \n```", "```go\ns1: {  0} p1: {  0}\ns2: {Mihalis Tsoukalos 2024} p2: {Mihalis Tsoukalos 2024}\nYear: 0 2024 0 2024\npS: &{  0} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"strconv\"\n)\ntype record struct {\n    Field1 int\n    Field2 string\n}\nfunc main() {\n    s := []record{}\n    for i := 0; i < 10; i++ {\n        text := \"text\" + strconv.Itoa(i)\n        temp := record{Field1: i, Field2: text}\n        s = append(s, temp)\n    } \n```", "```go\n // Accessing the fields of the first element\n    fmt.Println(\"Index 0:\", s[0].Field1, s[0].Field2)\n    fmt.Println(\"Number of structures:\", len(s))\n    sum := 0\nfor _, k := range s {\n        sum += k.Field1\n    }\n    fmt.Println(\"Sum:\", sum)\n} \n```", "```go\nIndex 0: 0 text0\nNumber of structures: 10\nSum: 45 \n```", "```go\nfunc main() {\n    // This is a raw string literal\nvar re string = `^.*(?=.{7,})(?=.*\\d)$` \n```", "```go\n exp1, err := regexp.Compile(re)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n    fmt.Println(\"RegExp:\", exp1)\n    exp2 := regexp.MustCompile(re)\n    fmt.Println(exp2)\n} \n```", "```go\n$ go run diffRegExp.go\nError: error parsing regexp: invalid or unsupported Perl syntax: `(?=`\nRegExp: <nil>\npanic: regexp: Compile(`^.*(?=.{7,})(?=.*\\d)$`): error parsing regexp: invalid or unsupported Perl syntax: `(?=`\ngoroutine 1 [running]:\nregexp.MustCompile({0x100a0c681, 0x15})\n    /opt/homebrew/Cellar/go/1.20.6/libexec/src/regexp/regexp.go:319 +0xac\nmain.main()\n    /Users/mtsouk/Desktop/mGo4th/code/ch03/diffRegExp.go:20 +0xf8\nexit status 2 \n```", "```go\nfunc matchNameSur(s string) bool {\n    t := []byte(s)\n    re := regexp.MustCompile(`^[A-Z][a-z]*$`)\n    return re.Match(t)\n} \n```", "```go\n$ go run nameSurRE.go Z \ntrue\n$ go run nameSurRE.go ZA\nfalse\n$ go run nameSurRE.go Mihalis\nTrue \n```", "```go\nfunc matchInt(s string) bool {\n    t := []byte(s)\n    re := regexp.MustCompile(`^[-+]?\\d+$`)\n    return re.Match(t)\n} \n```", "```go\n$ go run intRE.go 123\ntrue\n$ go run intRE.go /123\nfalse\n$ go run intRE.go +123.2\nfalse\n$ go run intRE.go +\nfalse\n$ go run intRE.go -123.2\nfalse \n```", "```go\npackage main\nimport (\n    \"encoding/csv\"\n\"log\"\n\"os\"\n)\ntype Record struct {\n    Name       string\n    Surname    string\n    Number     string\n    LastAccess string\n}\nvar myData = []Record{} \n```", "```go\nfunc readCSVFile(filepath string) ([][]string, error) {\n    _, err := os.Stat(filepath)\n    if err != nil {\n        return nil, err\n    }\n    f, err := os.Open(filepath)\n    if err != nil {\n        return nil, err\n    }\n    defer f.Close()\n    // CSV file read all at once\n// lines data type is [][]string\n    lines, err := csv.NewReader(f).ReadAll()\n    if err != nil {\n        return [][]string{}, err\n    }\n    return lines, nil\n} \n```", "```go\nfunc saveCSVFile(filepath string) error {\n    csvfile, err := os.Create(filepath)\n    if err != nil {\n        return err\n    }\n    defer csvfile.Close()\n    csvwriter := csv.NewWriter(csvfile)\n    // Changing the default field delimiter to tab\n    csvwriter.Comma = '\\t'\nfor _, row := range myData {\n        temp := []string{row.Name, row.Surname, row.Number, row.LastAccess}\n        err = csvwriter.Write(temp)\n        if err != nil {\n            return err\n        }\n    }\n    csvwriter.Flush()\n    return nil\n} \n```", "```go\nfunc main() {\n    if len(os.Args) != 3 {\n        log.Println(\"csvData input output!\")\n        os.Exit(1)\n    }\n    input := os.Args[1]\n    output := os.Args[2]\n    lines, err := readCSVFile(input)\n    if err != nil {\n        log.Println(err)\n        os.Exit(1)\n    }\n    // CSV data is read in columns - each line is a slice\nfor _, line := range lines {\n        temp := Record{\n            Name:       line[0],\n            Surname:    line[1],\n            Number:     line[2],\n            LastAccess: line[3],\n        }\n        myData = append(myData, temp)\n        log.Println(temp)\n    }\n    err = saveCSVFile(output)\n    if err != nil {\n        log.Println(err)\n        os.Exit(1)\n    }\n} \n```", "```go\n$ cat ~/csv.data\nDimitris,Tsoukalos,2101112223,1600665563\nMihalis,Tsoukalos,2109416471,1600665563\nJane,Doe,0800123456,1608559903 \n```", "```go\n$ go run csvData.go ~/csv.data /tmp/output.data\n{Dimitris Tsoukalos 2101112223 1600665563}\n{Mihalis Tsoukalos 2109416471 1600665563}\n{Jane Doe 0800123456 1608559903} \n```", "```go\n$ cat /tmp/output.data\nDimitris        Tsoukalos       2101112223      1600665563\nMihalis Tsoukalos       2109416471      1600665563\nJane    Doe     0800123456      1608559903 \n```", "```go\nfunc readFile(filepath string) ([]float64, error) {\n    _, err := os.Stat(filepath)\n    if err != nil {\n        return nil, err\n    }\n    f, err := os.Open(filepath)\n    if err != nil {\n        return nil, err\n    }\n    defer f.Close()\n    lines, err := csv.NewReader(f).ReadAll()\n    if err != nil {\n        return nil, err\n    }\n    values := make([]float64, 0)\n    for _, line := range lines {\n        **tmp, err := strconv.ParseFloat(line[****0****],** **64****)**\nif err != nil {\n            log.Println(\"Error reading:\", line[0], err)\n            continue\n        }\n        values = append(values, tmp)\n    }\n    return values, nil\n} \n```", "```go\nfunc stdDev(x []float64) (float64, float64) {\n    sum := 0.0\nfor _, val := range x {\n        sum = sum + val\n    }\n    meanValue := sum / float64(len(x))\n    **fmt.Printf(****\"Mean value: %.5f\\n\"****, meanValue)**\n// Standard deviation\nvar squared float64\nfor i := 0; i < len(x); i++ {\n        squared = squared + math.Pow((x[i]-meanValue), 2)\n    }\n    standardDeviation := math.Sqrt(squared / float64(len(x)))\n    return meanValue, standardDeviation\n} \n```", "```go\nfunc main() {\n    if len(os.Args) == 1 {\n        log.Println(\"Need one argument!\")\n        return\n    }\n    file := os.Args[1]\n    values, err := readFile(file)\n    if err != nil {\n        log.Println(\"Error reading:\", file, err)\n        os.Exit(0)\n    }\n    sort.Float64s(values)\n    fmt.Println(\"Number of values:\", len(values))\n    fmt.Println(\"Min:\", values[0])\n    fmt.Println(\"Max:\", values[len(values)-1])\n    meanValue, standardDeviation := stdDev(values)\n    fmt.Printf(\"Standard deviation: %.5f\\n\", standardDeviation)\n    normalized := normalize(values, meanValue, standardDeviation)\n    fmt.Println(\"Normalized:\", normalized)\n} \n```", "```go\n$ go run stats.go csvData.txt\nError reading: a strconv.ParseFloat: parsing \"a\": invalid syntax\nNumber of values: 6\nMin: -1.2\nMax: 3\nMean value: 0.66667\nStandard deviation: 1.54883\nNormalized: [-1.2053 -1.0761 -0.4305 0.2797 0.9254 1.5065 \n```", "```go\n$ cat csvData.txt\n1.1\n2.1\n-1.2\n-1\n0\na\n3 \n```"]