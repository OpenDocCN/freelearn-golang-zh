- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Composite Data Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合数据类型
- en: Go offers support for maps and structures, which are composite data types and
    the main subject of this chapter. The reason that we present them separately from
    arrays and slices is that both maps and structures are more flexible and powerful
    than arrays and slices. Each map can use keys of a given predefined data type,
    whereas structures can group multiple data types and create new data types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了对映射（Maps）和结构体（Structures）的支持，它们是复合数据类型，也是本章的主要内容。我们之所以将它们与数组和切片分开介绍，是因为映射和结构体都比数组和切片更灵活、更强大。每个映射可以使用给定预定义数据类型的键，而结构体可以将多个数据类型组合在一起并创建新的数据类型。
- en: Maps and slices are used for completely different reasons. Arrays and slices
    are used to store contiguous data and benefit from memory locality and indexing.
    Maps are useful when you do not need the locality of data but still need a way
    to reference it in constant time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 映射和切片用于完全不同的原因。数组和切片用于存储连续数据，并从内存局部性和索引中受益。当您不需要数据的局部性但仍然需要以恒定时间引用它时，映射是有用的。
- en: The general idea is that if an array or a slice cannot do the job, you might
    need to look at maps. If a map cannot help you store your data the way you want,
    then you should consider creating and using a structure—you can also group structures
    of the same type using arrays or slices. Keep in mind that maps and structures
    are distinct in their use case. You can easily have a map of structures, as well
    as an array or slice of structures. However, a structure is useful when you need
    to combine multiple pieces of logically grouped data and/or variables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的想法是，如果数组或切片无法完成工作，您可能需要查看映射。如果映射无法以您想要的方式存储数据，那么您应该考虑创建和使用结构体——您还可以使用数组或切片来分组相同类型的结构体。请记住，映射和结构体在用途上是不同的。您可以轻松地有一个结构体的映射，以及结构体的数组或切片。然而，当您需要组合多个逻辑上分组的数据和/或变量时，结构体是有用的。
- en: Additionally, the knowledge of this chapter will allow us to read and save data
    in the CSV format using structures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章的知识将使我们能够使用结构体读取和保存 CSV 格式的数据。
- en: Also, we are going to improve the statistics application we originally developed
    in *Chapter 1*, *A Quick Introduction to Go*. The new version of the utility is
    going to be able to load data from disk, which means that you no longer need to
    hardcode your data or generate random numbers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将改进在 *第 1 章，Go 快速入门* 中最初开发的统计应用程序。新版本的实用程序将能够从磁盘加载数据，这意味着您不再需要将数据硬编码或生成随机数。
- en: 'This chapter covers:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: Maps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射（Maps）
- en: Structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Regular expressions and pattern matching
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式和模式匹配
- en: Improving the statistics application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进统计应用程序
- en: Without further ado, let us begin by presenting maps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，让我们首先介绍映射（Maps）。
- en: Maps
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射（Maps）
- en: Both arrays and slices limit you to using positive integers as indexes, which
    start from `0` and cannot have gaps in them—this means that even if you want to
    put data in the slice element at index 99 only, the slice is still going to occupy
    100 elements in memory. Maps are more powerful data structures because they allow
    you to use indexes of various data types as keys to look up your data, as long
    as these keys are *comparable*. Comparable means that Go should be able to tell
    if two values are equal or which value is bigger (or smaller) than the other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和切片都限制您只能使用正整数作为索引，这些索引从 `0` 开始，且不能有间隔——这意味着即使您只想在索引 99 的切片元素中放置数据，切片仍然会在内存中占用
    100 个元素。映射（Maps）是更强大的数据结构，因为它们允许您使用各种数据类型的索引作为键来查找数据，只要这些键是*可比较的*。可比较意味着 Go 应该能够判断两个值是否相等，或者哪个值比另一个值更大（或更小）。
- en: Although Boolean variables are comparable, it makes no sense to use a `bool`
    variable as the key to a map because it only allows for two distinct values. Additionally,
    although floating point values are comparable, precision issues caused by the
    internal representation of such values might create bugs and crashes, so you might
    want to avoid using floating point values as keys to maps.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管布尔变量是可比较的，但将 `bool` 变量用作映射的键是没有意义的，因为它只允许两个不同的值。此外，尽管浮点值是可比较的，但由这些值的内部表示引起的精度问题可能会产生错误和崩溃，因此您可能想避免将浮点值用作映射的键。
- en: 'You might ask, why do we need maps, and what are their advantages? The following
    list will help clarify things:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问，为什么我们需要映射，它们有什么优势？以下列表将帮助澄清这些问题：
- en: Maps are very versatile. You can even create a database index using a map, which
    allows you to search and access elements based on a given key or, in more advanced
    situations, a combination of keys.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射非常灵活。你甚至可以使用映射创建数据库索引，这允许你根据给定的键或更高级情况下键的组合来搜索和访问元素。
- en: Although this is not always the case, working with maps in Go is fast, as you
    can access all elements of a map in constant time. Inserting and retrieving elements
    from a map is a constant time operation.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这并不总是如此，但在 Go 中使用映射是快速的，因为你可以以常数时间访问映射的所有元素。在映射中插入和检索元素是常数时间操作。
- en: Maps are easy to understand, which often leads to clear designs.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射易于理解，这通常会导致清晰的设计。
- en: 'You can create a new map variable using either `make()` or a map literal. Creating
    a new map with `string` keys and `int` values using `make()` is as simple as writing
    `make(map[string]int)` and assigning its return value to a variable. On the other
    hand, if you decide to create a map using a map literal, you need to write something
    like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `make()` 或映射字面量来创建一个新的映射变量。使用 `make()` 创建具有 `string` 键和 `int` 值的新映射与编写
    `make(map[string]int)` 并将返回值赋给变量一样简单。另一方面，如果你决定使用映射字面量创建映射，你需要写如下内容：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The map literal version is faster when you want to add data to a map at the
    time of creation. The previous map literal contains two keys and two values—two
    pairs in total.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望在创建映射时添加数据时，映射字面量版本更快。之前的映射字面量包含两个键和两个值——总共两个键值对。
- en: You should make no assumptions about the order of the elements inside a map.
    Go randomizes keys when iterating over a map— this is done on purpose and is an
    intentional part of the language design.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该对映射内部元素的顺序做出任何假设。Go 在迭代映射时会随机化键——这是故意为之，并且是语言设计的一部分。
- en: 'You can find the length of a map, which is the number of keys in the map, using
    the `len()` function, which also works with arrays and slices; also, you can delete
    a key and value pair from a map using the `delete()` function, which accepts two
    arguments: the name of the map and the name of the key, in that order.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `len()` 函数找到映射的长度，即映射中的键的数量，这个函数也适用于数组和切片；此外，你可以使用 `delete()` 函数从映射中删除键值对，该函数接受两个参数：映射的名称和键的名称，顺序如下。
- en: How to tell whether a key exists on a map
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何判断映射中是否存在键
- en: You can tell whether a key `k` exists on a map named `aMap` by the second return
    value of the `v, ok := aMap[k]` statement. If `ok` is set to `true`, then `k`
    exists, and its value is `v`. If it does not exist, `v` will be set to the zero
    value of its data type, which depends on the definition of the map.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `v, ok := aMap[k]` 语句的第二个返回值来判断名为 `aMap` 的映射中是否存在键 `k`。如果 `ok` 被设置为 `true`，则
    `k` 存在，其值为 `v`。如果它不存在，`v` 将被设置为其数据类型的零值，这取决于映射的定义。
- en: 'Now, a very important detail: **if you try to get the value of a key that does
    not exist in a map, Go will not complain about it and return the zero value of
    the data type of the value.**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个非常重要的细节：**如果你尝试获取映射中不存在的键的值，Go 不会对此提出任何异议，并返回值的数据类型的零值**。
- en: Now, let us discuss a special case where a map variable has the `nil` value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一个特殊情况，即映射变量具有 `nil` 值。
- en: Storing to a nil map
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据存储到 `nil` 映射中
- en: 'You are allowed to assign a map variable to `nil`. In that case, you will not
    be able to use that variable until you assign it to a new map variable. Put simply,
    if you try to store data on a `nil` map, your program will crash. This is illustrated
    in the next bit of code, which is the implementation of the `main()` function
    of the `nilMap.go` source file that can be found in the `ch03` directory of the
    GitHub repository of this book:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将映射变量赋值为 `nil`。在这种情况下，直到你将其赋值给新的映射变量，你将无法使用该变量。简单来说，如果你尝试在 `nil` 映射上存储数据，你的程序将会崩溃。这在下一段代码中得到了说明，这是可以在本书
    GitHub 仓库 `ch03` 目录中找到的 `nilMap.go` 源文件的 `main()` 函数的实现：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This works because `aMap` points to an existing map, which is the return value
    of `map[string]int{}`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以可行，是因为 `aMap` 指向一个现有的映射，这是 `map[string]int{}` 的返回值。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, `aMap` points to `nil`, which in Go is a synonym for nothing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，`aMap` 指向 `nil`，在 Go 中 `nil` 是“无”的同义词。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Testing whether a map points to `nil` before using it is a good practice. In
    this case, `if aMap == nil` allows us to determine whether we can store a key/value
    pair to `aMap` or not—we cannot, and if we try it, the program will crash. We
    correct that by issuing the `aMap = map[string]int{}` statement.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用映射之前测试映射是否指向`nil`是一种良好的实践。在这种情况下，`if aMap == nil`允许我们确定是否可以将键值对存储到`aMap`中——我们不能，如果我们尝试这样做，程序将会崩溃。我们通过发出`aMap
    = map[string]int{}`语句来纠正这一点。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this last part of the program, we illustrate how your program will crash
    if you try to store data on a `nil` map—never use such code in production!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的最后一部分，我们展示了如果您尝试在`nil`映射上存储数据，程序会如何崩溃——永远不要在生产环境中使用此类代码！
- en: In real-world applications, if a function accepts a map argument, then it should
    check that the map is not `nil` before working with it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，如果一个函数接受映射（map）作为参数，那么在处理它之前应该检查该映射是否为`nil`。
- en: 'Running `nilMap.go` produces this output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`nilMap.go`会产生以下输出：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The reason the program crashed is shown in the program output: `panic: assignment
    to entry in nil map`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '程序崩溃的原因显示在程序输出中：`panic: assignment to entry in nil map`。'
- en: Iterating over maps
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历映射
- en: When `for` is combined with `range`, it implements the functionality of the
    *foreach loops* found in other programming languages and allows you to iterate
    over all the elements of a map without knowing its size or its keys. In that case,
    `range` returns key and value pairs, in that order.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当`for`与`range`结合使用时，它实现了在其他编程语言中找到的*foreach循环*的功能，允许您遍历映射的所有元素，而无需知道其大小或其键。在这种情况下，`range`按顺序返回键值对。
- en: 'Type the following code and save it as `forMaps.go`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码并将其保存为`forMaps.go`：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, we use both the key and the value that returned from `range`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用从`range`返回的键和值。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, as we are only interested in the values returned by the map, we
    ignore the keys.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为我们只对映射返回的值感兴趣，所以我们忽略了键。
- en: As you already know, you should make **no assumptions about the order** that
    the key and value pairs of a map will be returned in from a `for`/`range` loop.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，您不应该对从`for`/`range`循环中返回的映射（map）键值对的顺序做出任何假设。
- en: 'Running `forMaps.go` produces this output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`forMaps.go`会产生以下输出：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Having covered maps, it is time to learn about Go structures.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了映射之后，现在是时候学习Go中的结构体了。
- en: Structures
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: Structures in Go are both very powerful and very popular and are used for organizing
    and grouping various types of data under the same name. Structures are the more
    versatile data type in Go—they can even have associated functions, which are called
    methods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的结构体（struct）既强大又流行，用于在同一个名称下组织并分组各种类型的数据。结构体是Go中更通用的数据类型——它们甚至可以有相关联的函数，这些函数被称为方法。
- en: Structures, as well as other user-defined data types, are usually defined outside
    the `main()` function or any other package function so that they can have a global
    scope and be available to the entire Go package. Therefore, unless you want to
    make clear that a type is only useful within the current local scope and is not
    expected to be used elsewhere, you should write the definitions of new data types
    outside functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体以及其他用户定义的数据类型通常定义在`main()`函数或任何其他包函数之外，这样它们就可以具有全局作用域，并可供整个Go包使用。因此，除非您想明确指出一个类型仅在当前局部作用域内有用，并且不期望在其他地方使用，否则您应该将新数据类型的定义写在函数外部。
- en: The type keyword
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型关键字
- en: The `type` keyword allows you to define new data types or create aliases for
    existing ones. Therefore, you are allowed to say `type myInt int` and define a
    new data type called `myInt`, which is an alias for `int`. However, Go considers
    `myInt` and `int` as totally different data types that you cannot compare directly,
    even though they store the same kind of values. Each structure defines a new data
    type, hence the use of `type`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`关键字允许您定义新的数据类型或为现有类型创建别名。因此，您可以说`type myInt int`并定义一个新的数据类型`myInt`，它是`int`的别名。然而，Go将`myInt`和`int`视为完全不同的数据类型，您不能直接比较它们，即使它们存储的是相同类型的值。每个结构体定义了一个新的数据类型，因此使用了`type`。'
- en: Defining new structures
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义新的结构体
- en: When you define a new structure, which is called a struct in the Go documentation,
    you group a set of values into a single data type, which allows you to pass and
    receive this set of values as a single entity. **A structure has fields, and each
    field has its own data type**, which can even be another structure or a slice
    of structures. Additionally, as a structure is a new data type, it is defined
    using the `type` keyword, followed by the name of the structure, and ending with
    the `struct` keyword, which signifies that we are defining a new structure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个新的结构体时，在 Go 文档中称为 struct，你将一组值组合成一个单一的数据类型，这使得你可以将这组值作为一个单一实体传递和接收。**结构体有字段，每个字段都有自己的数据类型**，这甚至可以是另一个结构体或结构体的切片。此外，由于结构体是一个新的数据类型，它使用
    `type` 关键字定义，后跟结构体的名称，并以 `struct` 关键字结尾，表示我们正在定义一个新的结构体。
- en: 'The following code defines a new structure named `Entry`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了一个名为 `Entry` 的新结构体：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although you can embed a structure definition into another structure, it is
    generally a bad idea and should be avoided. If you even think about doing so,
    you might need to think about your design decisions. However, it is perfectly
    acceptable to have existing structs as types inside a struct.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以将结构体定义嵌入到另一个结构体中，但这通常不是一个好主意，应该避免这样做。如果你甚至考虑这样做，你可能需要重新考虑你的设计决策。然而，在结构体内部将现有的结构体作为类型是完全可以接受的。
- en: For reasons that will become evident in *Chapter 6*, *Go Packages and Functions*,
    the fields of a structure usually begin with an uppercase letter—this depends
    on what you want to do with the fields and how their visibility outside of the
    current package might affect that. The `Entry` structure has three fields, named
    `Name`, `Surname`, and `Year`. The first two fields are of the `string` data type,
    whereas the last field holds an `int` value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 *第6章*，*Go 包和函数* 中将要变得明显的原因，结构体的字段通常以大写字母开头——这取决于你想要对字段做什么，以及它们在当前包之外的可视性可能会如何影响。`Entry`
    结构体有三个字段，分别命名为 `Name`、`Surname` 和 `Year`。前两个字段是 `string` 数据类型，而最后一个字段包含一个 `int`
    值。
- en: These three fields can be accessed with the *dot notation* as `V.Name`, `V.Surname`,
    and `V.Year`, where `V` is the name of the variable holding an instance of the
    `Entry` structure. A structure literal named `p1` can be defined as `p1 := Entry{"Joe",
    "D.", 2012}`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个字段可以通过 *点表示法* 访问，例如 `V.Name`、`V.Surname` 和 `V.Year`，其中 `V` 是持有 `Entry` 结构体实例的变量的名称。可以定义一个名为
    `p1` 的结构体字面量，如下所示：`p1 := Entry{"Joe", "D.", 2012}`。
- en: Two ways exist to work with structure variables. The first one is as regular
    variables, and the second one is as pointer variables that point to the memory
    address of a structure. Both ways are equally good and are usually embedded into
    separate functions, because they allow you to initialize some or all of the fields
    of structure variables properly and/or do any other tasks you want before using
    the structure variable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种方式来处理结构变量。第一种是将它们作为常规变量，第二种是将它们作为指针变量，这些指针变量指向结构体的内存地址。这两种方式同样有效，通常会被嵌入到不同的函数中，因为它们允许你正确地初始化结构变量的一些或所有字段，并在使用结构变量之前执行任何其他你想要的任务。
- en: As a result, there exist two main ways to create a new structure variable using
    a function. The first one returns a regular structure variable whereas the second
    one returns a pointer to a structure. Each one of these two ways has two variations.
    The first variation returns a structure instance that is initialized by the Go
    compiler, whereas the second variation returns a structure instance that is initialized
    by the developer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用函数创建新结构体的主要方式有两种。第一种返回一个常规结构体变量，而第二种返回一个指向结构体的指针。这两种方式各有两种变体。第一种变体返回由 Go
    编译器初始化的结构体实例，而第二种变体返回由开发者初始化的结构体实例。
- en: Last, keep in mind that the order in which you put the fields in the definition
    of a structure type is significant for the type identity of the defined structure.
    Put simply, **two structures with the same fields will not be considered identical
    in Go if their fields are not in the same order**. This mainly has to do with
    exchanging data between server and client software because variables of different
    structures cannot be compared, even if they have the exact same list of fields
    with the exact data types in the exact same order, as they belong to different
    data types.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，你在结构类型定义中放置字段的顺序对于定义的结构类型身份是重要的。简单来说，**在Go中，如果两个结构具有相同的字段但顺序不同，则它们不会被考虑为相同**。这主要与服务器和客户端软件之间的数据交换有关，因为不同结构体的变量无法比较，即使它们具有完全相同的字段列表、完全相同的数据类型和完全相同的顺序，因为它们属于不同的数据类型。
- en: Using the new keyword
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`new`关键字
- en: 'Additionally, you can create new structure instances using the `new()` keyword
    with statements such as `pS := new(Entry)`. The `new()` keyword has the following
    properties:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用`new()`关键字和如`pS := new(Entry)`之类的语句创建新的结构实例。`new()`关键字具有以下特性：
- en: It allocates the proper memory space, which depends on the data type, and then
    it zeroes it.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它分配适当的内存空间，这取决于数据类型，然后将其清零。
- en: It always returns a pointer to the allocated memory.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它总是返回指向已分配内存的指针。
- en: It works for all data types except channels and maps.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适用于所有数据类型，除了通道和映射。
- en: 'All these techniques are illustrated in the code that follows. Type the following
    code in your favorite text editor and save it as `structures.go`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术都在下面的代码中得到了说明。请在您喜欢的文本编辑器中输入以下代码，并将其保存为`structures.go`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now is a good time to remind you of an important Go rule: **if no initial value
    is given to a variable, the Go compiler automatically initializes that variable
    to the zero value of its data type**. For structures, this means that a structure
    variable without an initial value is initialized to the zero values of the data
    type of each one of its fields. Therefore, the `zeroS()` function returns a zero-initialized
    `Entry` structure.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是提醒您一个重要的Go规则的好时机：**如果未为变量提供初始值，Go编译器会自动将该变量初始化为其数据类型的零值**。对于结构体，这意味着没有初始值的结构体变量将初始化为其每个字段的零值。因此，`zeroS()`函数返回一个零初始化的`Entry`结构体。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, the user initializes the new structure variable. Additionally,
    the `initS()` function checks whether the value of the `Year` field is smaller
    than `2000` and acts; if it is smaller than `2000`, then the value of the `Year`
    field becomes `2000`. This condition is specific to the requirements of the application
    you are developing—what this shows is that the place where you initialize a structure
    is also good for checking your input.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户初始化新的结构体变量。此外，`initS()`函数检查`Year`字段的值是否小于`2000`并采取行动；如果小于`2000`，则`Year`字段的值变为`2000`。这个条件是针对你正在开发的应用程序的需求特定的——这表明初始化结构体的位置也是检查输入的好地方。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `zeroPtoS()` function returns a pointer to a zero-initialized structure.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`zeroPtoS()`函数返回一个指向零初始化结构的指针。'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `initPtoS()` function also returns a pointer to a structure but also checks
    the length of the user input. Again, this kind of checking is application specific.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`initPtoS()`函数也返回一个指向结构的指针，但同时也检查用户输入的长度。这种检查是特定于应用的。'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `new(Entry)` call returns a pointer to an `Entry` structure. As a rule of
    thumb, when you have to initialize lots of structure variables, it is considered
    good practice to create a function for doing so, as this is less error-prone.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`new(Entry)`调用返回一个指向`Entry`结构的指针。一般来说，当你需要初始化大量的结构变量时，创建一个用于此目的的函数被认为是良好的实践，因为这可以减少出错的可能性。'
- en: 'Running `structures.go` creates the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`structures.go`将生成以下输出：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As the zero value of a string is the empty string, `s1`, `p1`, and `pS` do not
    show any data for the `Name` and `Surname` fields.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串的零值是空字符串，因此`s1`、`p1`和`pS`在`Name`和`Surname`字段中不显示任何数据。
- en: The next subsection shows how to group structures of the same data type and
    use them as the elements of a slice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何将相同数据类型的结构分组，并将它们用作切片的元素。
- en: Slices of structures
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体的切片
- en: You can create slices of structures to group and handle multiple structures
    under a single variable name. However, accessing a field of a given structure
    requires knowing the exact place of the structure in the slice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建结构切片来将多个结构分组并使用单个变量名处理。然而，访问给定结构的字段需要知道该结构在切片中的确切位置。
- en: Have a look at the following figure to better understand how a slice of structures
    works and how you can access the fields of a specific slice element.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下图表，以更好地理解结构切片的工作原理以及如何访问特定切片元素的字段。
- en: '![A black background with a black square  Description automatically generated](img/B21003_03_01.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![黑色背景上的黑色方块  自动生成的描述](img/B21003_03_01.png)'
- en: 'Figure 3.1: A slice of structures'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：结构切片
- en: So each slice element is a structure that is accessed using a slice index. Once
    we select the slice element we want, we can select any one of its fields.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个切片元素都是一个使用切片索引访问的结构。一旦我们选择了我们想要的切片元素，我们就可以选择其任意一个字段。
- en: As the whole process can be a little perplexing, the code that follows sheds
    some light and clarifies things. Type the following code and save it as `sliceStruct.go`.
    You can also find it by the same name in the `ch03` directory in the GitHub repository
    of the book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个过程可能有点令人困惑，下面的代码提供了一些启示并澄清了问题。请输入以下代码并将其保存为 `sliceStruct.go`。你还可以在书的GitHub仓库的
    `ch03` 目录中找到相同名称的文件。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You still need `append()` to add a new structure to a slice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要使用 `append()` 函数向切片中添加一个新的结构。
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running `sliceStruct.go` produces the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `sliceStruct.go` 产生以下输出：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We revisit structures in *Chapter 5*, where we discuss reflection, as well as
    *Chapter 7*, *Telling a UNIX System What to Do*, where we learn how to work with
    JSON data using structures. For now, let us discuss regular expressions and pattern
    matching.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第五章*中回顾了结构，其中我们讨论了反射，以及在*第七章* *告诉UNIX系统做什么* 中，我们学习了如何使用结构处理JSON数据。现在，让我们讨论正则表达式和模式匹配。
- en: Regular expressions and pattern matching
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式和模式匹配
- en: You might wonder why we are talking about regular expressions and pattern matching
    in this chapter. The reason is simple. In a while, you will learn how to store
    and read CSV data from plain text files, and you should be able to tell whether
    the data is valid or not.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们在本章中讨论正则表达式和模式匹配。原因很简单。在不久的将来，你将学习如何从纯文本文件中存储和读取CSV数据，你应该能够判断数据是否有效。
- en: Pattern matching is a technique for searching a string for some set of characters,
    based on a specific search pattern that is based on regular expressions and grammars.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一种搜索字符串中某些字符的技术，它基于基于正则表达式和语法的特定搜索模式。
- en: A regular expression is a sequence of characters that defines a search pattern.
    Every regular expression is compiled into a recognizer by building a generalized
    transition diagram called a finite automaton. A finite automaton can be either
    deterministic or nondeterministic. Nondeterministic means that more than one transition
    out of a state can be possible for the same input. A recognizer is a program that
    takes a string `x` as input and can tell whether `x` is a sentence of a given
    language or not.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一系列定义搜索模式的字符。每个正则表达式都被编译成一个识别器，通过构建一个称为有限自动机的通用转换图来实现。有限自动机可以是确定性的或非确定性的。非确定性意味着对于相同的输入，从状态中可能有多个转换是可能的。识别器是一个程序，它接受一个字符串
    `x` 作为输入，并可以判断 `x` 是否是给定语言的句子。
- en: A grammar is a set of production rules for strings in a formal language—the
    production rules describe how to create strings from the alphabet of the language
    that are valid according to the syntax of the language. A grammar does not describe
    the meaning of a string or what can be done with it in whatever context—it only
    describes its form. What is important here is to realize that grammars are at
    the heart of regular expressions because, without a grammar, you cannot define
    and therefore use a regular expression.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是一组用于形式语言中字符串的生产规则——生产规则描述了如何从语言的字母表中创建字符串，这些字符串根据语言的语法是有效的。语法不描述字符串的意义或在任何上下文中可以用它做什么——它只描述其形式。这里重要的是要意识到，语法是正则表达式的核心，因为没有语法，你无法定义和因此使用正则表达式。
- en: About regexp.Compile and regexp.MustCompile
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 regexp.Compile 和 regexp.MustCompile
- en: The Go package responsible for defining regular expressions and performing pattern
    matching is called `regexp`. Inside that package exists `regexp.Compile()` and
    `regexp.MustCompile()`, which have similar capabilities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 负责定义正则表达式和执行模式匹配的 Go 包称为 `regexp`。在该包内部存在 `regexp.Compile()` 和 `regexp.MustCompile()`，它们具有相似的功能。
- en: Both the `regexp.MustCompile()` and `regexp.Compile()` functions parse the given
    regular expression and return a pointer to a `regexp.Regexp` variable that can
    be used for matching—`regexp.Regexp` is the representation of a compiled regular
    expression. The `re.Match()` method returns `true` if the given byte slice matches
    the `re` regular expression, which is a `regexp.Regexp` variable, and `false`
    otherwise.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp.MustCompile()` 和 `regexp.Compile()` 函数解析给定的正则表达式，并返回一个指向 `regexp.Regexp`
    变量的指针，该变量可用于匹配——`regexp.Regexp` 是编译后的正则表达式的表示。`re.Match()` 方法返回 `true` 如果给定的字节切片与
    `re` 正则表达式匹配，即 `regexp.Regexp` 变量，否则返回 `false`。'
- en: The main and crucial difference between `regexp.Compile()` and `regexp.MustCompile()`
    is that the former returns a `*regexp.Regexp` pointer and an `error` variable,
    whereas the latter returns a `*regexp.Regexp` pointer only. As a result, if there
    is some kind of error in the parsing of the regular expression, `regexp.MustCompile()`
    is going to panic and therefore crash your program!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp.Compile()` 和 `regexp.MustCompile()` 之间的主要和关键区别在于，前者返回一个 `*regexp.Regexp`
    指针和一个 `error` 变量，而后者只返回一个 `*regexp.Regexp` 指针。因此，如果正则表达式的解析过程中出现某种错误，`regexp.MustCompile()`
    将会引发恐慌，从而导致你的程序崩溃！'
- en: However, `regexp.MustCompile()` panicking is not necessarily a bad thing because
    if a regular expression cannot be parsed, you will know that your expression is
    invalid early in the process. At the end of the day, it is the developer that
    decides the overall policy regarding regular expression parsing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`regexp.MustCompile()` 引发恐慌并不一定是坏事，因为如果正则表达式无法解析，你将知道你的表达式在早期过程中是无效的。最终，关于正则表达式解析的整体策略是由开发者决定的。
- en: There are times when we want to find only those matches for a pattern that are
    followed or preceded by another given pattern. These kinds of operations are called
    lookahead and lookbehind, respectively. Go offers no support for either lookahead
    or lookbehind and will throw an error message when used. The general syntax of
    lookahead is `X(?=Y)`, which means, match `X` only if it is followed by `Y`. The
    difference between `regexp.Compile()` and `regexp.MustCompile()` is illustrated
    in the `main()` function of `diffRegExp.go`, which is going to be presented in
    two parts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们只想找到那些后面或前面跟着另一个给定模式的匹配模式。这类操作分别称为前瞻和后顾。Go 不支持前瞻或后顾，使用时将抛出错误信息。前瞻的一般语法是
    `X(?=Y)`，这意味着，只有当 `X` 后面跟着 `Y` 时才匹配 `X`。`regexp.Compile()` 和 `regexp.MustCompile()`
    之间的区别在 `diffRegExp.go` 的 `main()` 函数中得到了说明，该函数将分两部分展示。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What is wrong with the preceding regular expression? The problem is that it
    is using lookahead, which is not supported in Go.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的正则表达式有什么问题？问题是它使用了前瞻，这在 Go 中不受支持。
- en: 'The second part is next:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this second code segment, the use of `regexp.Compile()` and `regexp.MustCompile()`
    is illustrated.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个代码段中，展示了 `regexp.Compile()` 和 `regexp.MustCompile()` 的使用。
- en: 'Running `diffRegExp.go` produces the next output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `diffRegExp.go` 产生以下输出：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, in the first case, we know that there is an error in the regular expression
    because of the return value of `regexp.Compile()`, whereas when using `regexp.MustCompile()`
    with an erroneous regular expression, the program panics and automatically terminates.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第一种情况下，我们知道正则表达式中存在错误，因为 `regexp.Compile()` 的返回值，而使用带有错误正则表达式的 `regexp.MustCompile()`
    时，程序会引发恐慌并自动终止。
- en: The next subsection shows how to define regular expressions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何定义正则表达式。
- en: Go regular expressions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 正则表达式
- en: We begin this subsection by presenting some common match patterns used to construct
    regular expressions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个子节开始，展示一些常用的匹配模式，这些模式用于构建正则表达式。
- en: '| **Expression** | **Description** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `.` | Matches any character |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 匹配任何字符 |'
- en: '| `*` | Means any number of times—cannot be used on its own |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 表示任意次数——不能单独使用 |'
- en: '| `?` | Zero or once—cannot be used on its own |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 零次或一次——不能单独使用 |'
- en: '| + | Means one or more times—cannot be used on its own |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 表示一次或多次——不能单独使用 |'
- en: '| `^` | This denotes the beginning of the line |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 表示行的开头 |'
- en: '| `$` | This denotes the end of the line |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 表示行的末尾 |'
- en: '| `[]` | `[]` is for grouping characters |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | `[]` 用于分组字符 |'
- en: '| `[A-Z]` | This means all characters from capital `A` to capital `Z` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `[A-Z]` | 这意味着从大写字母 `A` 到大写字母 `Z` 的所有字符 |'
- en: '| `\d` | Any digit in `0-9` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | `0-9` 中的任何数字 |'
- en: '| `\D` | A non-digit |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 非数字 |'
- en: '| `\w` | Any word character: `[0-9A-Za-z_]` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 任何单词字符：`[0-9A-Za-z_]` |'
- en: '| `\W` | Any non-word character |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 任何非单词字符 |'
- en: '| `\s` | A whitespace character |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 空白字符 |'
- en: '| `\S` | A non-whitespace character |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 非空白字符 |'
- en: The characters presented in the previous table are used for constructing and
    defining the grammar of a regular expression.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之前表格中展示的字符用于构建和定义正则表达式的语法。
- en: Creating separate functions for pattern matching can be handy because it allows
    you to reuse the functions without worrying about the context of the program.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单独的函数进行模式匹配可能很有用，因为它允许你在不担心程序上下文的情况下重用这些函数。
- en: Keep in mind that although regular expressions and pattern matching look convenient
    at first, they are the root of lots of bugs. **My advice is to use the simplest
    regular expression that can solve your problem**. However, avoiding using regular
    expressions while still doing your job would be much better in the long run!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管正则表达式和模式匹配一开始看起来很方便，但它们是许多错误的原因。**我的建议是使用最简单的正则表达式来解决你的问题**。然而，在长期来看，避免使用正则表达式同时完成你的工作会更好！
- en: About raw string and interpreted string literals
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于原始字符串和解释字符串字面量
- en: 'Although we discussed strings in the previous chapter, it is in the definition
    of the regular expression in `diffRegExp.go` that we have used a *raw string literal*
    for the first time, so let us talk a little bit more about raw string literals,
    which are included in back quotes instead of double quotes. The advantages of
    raw string literals are the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在上一章讨论了字符串，但我们第一次在 `diffRegExp.go` 中定义正则表达式时使用了*原始字符串字面量*，因此让我们再谈谈原始字符串字面量，它们包含在反引号中而不是双引号中。原始字符串字面量的优点如下：
- en: They can keep huge amounts of text inside them without the need for control
    characters, such as `\n`, for changing lines.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在其中包含大量文本，而无需使用控制字符，如 `\n` 来换行。
- en: They are handy when defining regular expressions because you do not need to
    use backquotes (`\`) to escape special characters.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在定义正则表达式时很有用，因为你不需要使用反引号（`\`）来转义特殊字符。
- en: They are used in structure tags, which are explained in *Chapter 11*, *Working
    with REST APIs*.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们用于结构标签中，这些标签在*第11章*，*与REST API协同工作*中有所解释。
- en: So, in summary, **raw string literals are for storing strings without any escape
    processing, whereas interpreted string literals are processed when the string
    is created**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，**原始字符串字面量用于存储不进行任何转义处理的字符串，而解释字符串字面量在字符串创建时进行处理**。
- en: The next subsection presents regular expressions for matching names and surnames.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示用于匹配姓名和姓氏的正则表达式。
- en: Matching names and surnames
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配姓名和姓氏
- en: The presented utility matches names and surnames—according to our definition,
    these are strings that begin with an uppercase letter and continue with lowercase
    letters. The input should not contain any numbers or other characters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的实用工具匹配姓名和姓氏——根据我们的定义，这些是以大写字母开头并继续以小写字母开头的字符串。输入不应包含任何数字或其他字符。
- en: 'The source code of the utility can be found in `nameSurRE.go`, which is in
    the `ch03` folder. The function that supports the desired functionality is named
    `matchNameSur()` and is implemented as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实用工具的源代码可以在 `ch03` 文件夹中的 `nameSurRE.go` 文件中找到。支持所需功能的函数名为 `matchNameSur()`，其实现如下：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The logic of the function is in the `` `^[A-Z][a-z]*$` `` regular expression,
    where `^` denotes the beginning of a line and `$` denotes the end of a line. What
    the regular expression does is to match anything that begins with an uppercase
    letter (`[A-Z]`) and continue with any number of lowercase letters (`[a-z]*`).
    This means that `Z` is a match, but `ZA` is not a match because the second letter
    is in uppercase. Similarly, `Jo+` is not a match because it contains the `+` character.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的逻辑在 `` `^[A-Z][a-z]*$` `` 正则表达式中，其中 `^` 表示行的开始，`$` 表示行的结束。正则表达式所做的匹配是以大写字母开头（`[A-Z]`）并继续以任意数量的小写字母（`[a-z]*`）开头的任何内容。这意味着
    `Z` 是一个匹配项，但 `ZA` 不是一个匹配项，因为第二个字母是大写的。同样，`Jo+` 不是一个匹配项，因为它包含 `+` 字符。
- en: 'Running `nameSurRE.go` with various types of input produces the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用各种类型的输入运行 `nameSurRE.go` 产生以下输出：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This technique can help you check the validity of user input. The next subsection
    is about matching integers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以帮助你检查用户输入的有效性。下一小节将介绍匹配整数。
- en: Matching integers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配整数
- en: The presented utility matches both signed and unsigned integers—this is implemented
    in the way we define the regular expression. If we want to match unsigned integers
    only, then we should replace `[-+]?` in the regular expression with `[+]?`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具可以匹配有符号和无符号整数——这是通过我们定义的正则表达式实现的。如果我们只想匹配无符号整数，那么我们应该将正则表达式中的 `[-+]?` 替换为
    `[+]?`。
- en: A better alternative than using a regular expression for matching integer values
    would have been the use of `strconv.Atoi()`. As a piece of advice, if you can
    avoid using regular expressions, opt for the alternative method. However, regular
    expressions are invaluable when you do not know in advance the kind or the amount
    of data to expect in the input. In general, regular expressions are invaluable
    for separating the various parts of the input. Keep in mind that regular expressions
    are always matching strings, and you can also find digits in strings.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用正则表达式匹配整数值相比，使用 `strconv.Atoi()` 会是一个更好的替代方案。作为一个建议，如果你能避免使用正则表达式，请选择替代方法。然而，当你事先不知道期望输入的数据类型或数量时，正则表达式是无价的。一般来说，正则表达式对于分离输入的各个部分非常有价值。请记住，正则表达式始终匹配字符串，你也可以在字符串中找到数字。
- en: 'The source code of the utility can be found in `intRE.go`, which is in the
    `ch03` directory. The `matchInt()` function that supports the desired functionality
    is implemented as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的源代码位于 `intRE.go` 文件中，该文件位于 `ch03` 目录下。支持所需功能的 `matchInt()` 函数实现如下：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As before, the logic of the function is found in the regular expression that
    is used for matching integers, which is `` `^[-+]?\d+$` ``. In plain English,
    what we mean here is that we want to match something that begins with `–` or `+`,
    which is optional (`?`), and ends with any number of digits (`\d+`)—it is required
    that we have at least one digit before the end of the string that is examined
    (`$`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，函数的逻辑可以在用于匹配整数的正则表达式中找到，即 `` `^[-+]?\d+$` ``。用简单的话来说，我们这里的意思是我们想匹配以 `–`
    或 `+` 开头的东西，这是可选的（`?`），并以任意数量的数字（`\d+`）结束——在字符串的末尾之前至少需要一个数字（`$`）。
- en: 'Running `intRE.go` with various types of input produces the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用各种类型的输入运行 `intRE.go` 产生以下输出：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Later in this book, you will learn how to test Go code by writing testing functions—for
    now, we will do most of the testing manually.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，你将学习如何通过编写测试函数来测试 Go 代码——现在，我们将大部分测试手动进行。
- en: Improving the statistics application
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升统计应用程序
- en: 'It is time to update the statistics application. The new version of the statistics
    utility has the following improvements:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候更新统计应用程序了。统计工具的新版本有以下改进：
- en: It uses functions to simplify the `main()` function and improve the overall
    design.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用函数简化 `main()` 函数并改进整体设计。
- en: It can read CSV files that contain the numeric input.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以读取包含数值输入的 CSV 文件。
- en: But first, we need to learn how to work with CVS files in Go, which is the subject
    of the next subsection.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要学习如何在 Go 中处理 CSV 文件，这是下一小节的主题。
- en: Working with CSV files
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 CSV 文件
- en: Most of the time, you do not want to lose your data or have to begin without
    any data every time you execute your application. There exist many techniques
    for doing so—the easiest one is by saving your data locally. A very easy-to-work-with
    plain text file format is CSV, which is what is explained here and used in the
    statistics application later on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你不想丢失数据或每次执行应用程序时都必须在没有数据的情况下开始。为此存在许多技术——最简单的一种是将数据本地保存。一个非常易于处理的纯文本文件格式是
    CSV，这就是这里所解释的，并在后面的统计应用程序中使用。
- en: The good thing is that Go provides a dedicated package for working with CSV
    data, named `encoding/csv` ([https://pkg.go.dev/encoding/csv](https://pkg.go.dev/encoding/csv)).
    For the presented utility, both the input and output files are given as command
    line arguments.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 好的一点是，Go 提供了一个专门用于处理 CSV 数据的包，名为 `encoding/csv` ([https://pkg.go.dev/encoding/csv](https://pkg.go.dev/encoding/csv))。对于所提供的工具，输入和输出文件都作为命令行参数给出。
- en: When reading or writing CSV data from disk, everything is considered a string.
    Therefore, if you have numeric data that you want to treat as such during the
    reading phase, you might need to convert it to the proper data type on your own.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当从磁盘读取或写入 CSV 数据时，所有内容都被视为字符串。因此，如果你在读取阶段希望将数值数据视为此类数据，你可能需要自行将其转换为适当的数据类型。
- en: There exist two very popular Go interfaces, named `io.Reader` and `io.Write`,
    that relate to reading and writing files, respectively. Almost all reading and
    writing operations in Go use these two interfaces. The use of the same interface
    for all readers allows readers to share some common characteristics, but most
    importantly, it allows you to create your own readers and use them anywhere that
    Go expects an `io.Reader` reader. The same applies to writers that satisfy the
    `io.Write` interface. You are going to learn more about interfaces in *Chapter
    5*, *Reflection and Interfaces*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两个非常流行的 Go 接口，分别命名为 `io.Reader` 和 `io.Writer`，它们分别与读取和写入文件相关。几乎所有的读取和写入操作在
    Go 中都使用这两个接口。所有读取器使用相同接口的做法使得读取器可以共享一些共同特性，但最重要的是，它允许你在 Go 需要任何 `io.Reader` 读取器的地方创建自己的读取器并使用它们。对于满足
    `io.Writer` 接口的写入器也是如此。你将在 *第五章*，*反射与接口* 中了解更多关于接口的内容。
- en: 'The main tasks that need to be implemented are the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 需要实现的主要任务如下：
- en: Loading CSV data from disk and putting it into a slice of structures
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁盘加载 CSV 数据并将其放入结构体切片中
- en: Saving data to disk using the CSV format
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CSV 格式将数据保存到磁盘
- en: The `encoding/csv` package contains functions that can help you read and write
    CSV files. As we are dealing with small CSV files, we use `csv.NewReader(f).ReadAll()`
    to read the entire input file at once. For bigger data files, or if we wanted
    to check the input or make any changes to the input as we read it, it would have
    been better to read it line by line using `Read()` instead of `ReadAll()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`encoding/csv` 包包含可以帮助你读取和写入 CSV 文件的函数。由于我们处理的是小型 CSV 文件，我们使用 `csv.NewReader(f).ReadAll()`
    一次性读取整个输入文件。对于较大的数据文件，或者如果我们想在读取时检查输入或对其进行任何更改，使用 `Read()` 而不是 `ReadAll()` 会更好。'
- en: Go assumes that the CSV file uses the comma character (`,`) for separating the
    different fields of each line. Should we wish to change that behavior, we should
    change the value of the `Comma` variable of the CSV reader or the writer, depending
    on the task we want to perform. We change that behavior in the output CSV file,
    which separates its fields using the tab character.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Go 假设 CSV 文件使用逗号字符 (`,`) 来分隔每行的不同字段。如果我们希望改变这种行为，我们应该根据我们想要执行的任务更改 CSV 读取器或写入器的
    `Comma` 变量的值。我们在输出 CSV 文件中改变了这种行为，它使用制表符来分隔字段。
- en: For reasons of compatibility, it is better if the input and output CSV files
    use the same field delimiter. We are just using the tab character as the field
    delimiter in the output file to illustrate the use of the `Comma` variable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于兼容性的原因，如果输入和输出 CSV 文件使用相同的字段分隔符会更好。我们只是在输出文件中使用制表符作为字段分隔符来展示 `Comma` 变量的使用。
- en: As working with CSV files is a new topic, there is a separate utility named
    `csvData.go` in the `ch03` directory of the GitHub repository of this book that
    illustrates the techniques for reading and writing CSV files. The source code
    of `csvData.go` is presented in chunks. First, we present the preamble of `csvData.go`
    that contains the `import` section as well as the `Record` structure and the `myData`
    global variable, which is a slice of `Record`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理 CSV 文件是一个新主题，本书 GitHub 仓库的 `ch03` 目录中有一个名为 `csvData.go` 的单独实用工具，它展示了读取和写入
    CSV 文件的技巧。`csvData.go` 的源代码以块的形式展示。首先，我们展示 `csvData.go` 的前言部分，其中包含 `import` 部分、`Record`
    结构体以及 `myData` 全局变量，它是一个 `Record` 切片。
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, we present the `readCSVFile()` function, which reads the plain text file
    with the CSV data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍 `readCSVFile()` 函数，该函数读取包含 CSV 数据的纯文本文件。
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we check whether the given file path exists and is associated with
    a regular file inside the function. There is no right or wrong decision about
    where to perform that checking—you just have to be consistent. The `readCSVFile()`
    function returns a `[][]string` slice that contains all the lines we have read.
    Additionally, keep in mind that `csv.NewReader()` does separate the fields of
    each input line, which is the main reason for needing a slice with two dimensions
    to store the input.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在函数内部检查了给定的文件路径是否存在，并且与一个常规文件相关联。关于在哪里执行这种检查没有正确或错误的选择——你只需要保持一致。`readCSVFile()`
    函数返回一个包含所有读取行的 `[][]string` 切片。此外，请记住，`csv.NewReader()` 会分隔每条输入行的字段，这是需要使用二维切片来存储输入的主要原因。
- en: After that, we illustrate the writing to a CSV file technique with the help
    of the `saveCSVFile()` function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们借助 `saveCSVFile()` 函数展示了将内容写入 CSV 文件的技巧。
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note the change in the default value of `csvwriter.Comma` to match our needs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `csvwriter.Comma` 的默认值发生了变化，以符合我们的需求。
- en: Lastly, we can see the implementation of the `main()` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到 `main()` 函数的实现。
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `main()` function puts what you have read with `readCSVFile()` in the `myData`
    slice—remember that `lines` is a slice with two dimensions and that each row in
    `lines` is already separated into fields. In this case, each line of input contains
    four fields. So we process that `[][]string` slice and put the desired information
    in the slice of structures (`myData`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数将 `readCSVFile()` 读取的内容放入 `myData` 切片中——请记住，`lines` 是一个二维切片，并且 `lines`
    中的每一行已经被分隔成字段。在这种情况下，输入的每一行包含四个字段。因此，我们处理这个 `[][]string` 切片，并将所需信息放入结构体切片（`myData`）中。'
- en: 'The contents of the CSV data file used as input are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入使用的 CSV 数据文件的内容如下：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running `csvData.go` produces the following kind of output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `csvData.go` 产生以下类型的输出：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The contents of the output CSV file are the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 CSV 文件的内容如下：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `output.data` file uses tab characters to separate the different fields
    of each record, hence the generated output. The `csvData.go` utility can be handy
    for performing conversions between different types of CSV files.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`output.data` 文件使用制表符来分隔每条记录的不同字段，因此生成了相应的输出。`csvData.go` 工具在执行不同类型 CSV 文件之间的转换时可能很有用。'
- en: The updated version of the statistics application
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计应用程序的更新版本
- en: In this subsection, we are going to show the updated code of the statistics
    application. The `normalized()` function has not changed, so it is not presented
    again.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将展示统计应用程序的更新代码。`normalized()` 函数没有变化，因此不再展示。
- en: The first code excerpt from `stats.go` is the implementation of the function
    that reads the CSV file as text and converts it into a slice of `float64` values.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `stats.go` 的第一段代码是实现了一个函数，该函数将 CSV 文件作为文本读取，并将其转换为 `float64` 值的切片。
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once the specified CSV file is read, its data is put into the `lines` variable.
    Keep in mind that, in our case, each line in the CSV file has a single field.
    Nevertheless, `lines` has two dimensions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取了指定的 CSV 文件，其数据就被放入 `lines` 变量中。请注意，在我们的案例中，CSV 文件中的每一行只有一个字段。尽管如此，`lines`
    有两个维度。
- en: As we want to return a slice of `float64` values, we have to convert the `[][]string`
    variable into a `[]float64` variable, which is the purpose of the last `for` loop.
    The most important task of the `for` loop is to make sure that all strings are
    valid `float64` values, in order to put them in the `values` slice—this is the
    purpose of the `strconv.ParseFloat(line[0], 64)` call.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要返回一个 `float64` 值的切片，我们必须将 `[][]string` 变量转换为 `[]float64` 变量，这正是最后一个 `for`
    循环的目的。`for` 循环最重要的任务是确保所有字符串都是有效的 `float64` 值，以便将它们放入 `values` 切片中——这是 `strconv.ParseFloat(line[0],
    64)` 调用的目的。
- en: 'Next, we have the implementation of the function that computes the standard
    deviation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有计算标准差的函数实现：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, `stdDev()` computes the sum of all given values and, after that, the
    mean value of the data. Last, the standard deviation is computed. You can remove
    the `fmt.Printf()` call inside the `stdDev()` function when you are sure that
    everything works as expected.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`stdDev()` 函数计算所有给定值的总和，然后计算数据的平均值。最后，计算标准差。当你确定一切按预期工作后，可以移除 `stdDev()`
    函数内的 `fmt.Printf()` 调用。
- en: 'Lastly, here is the implementation of `main()`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是 `main()` 函数的实现：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Although the core functionality of the updated version of `stats.go` is the
    same as the version developed in the previous chapter, the use of functions simplifies
    the implementation of `main()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管更新版本的`stats.go`的核心功能与上一章开发的版本相同，但使用函数简化了`main()`的实现。
- en: 'Running `stats.go` produces the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`stats.go`会产生以下输出：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The previous output shows that `csvData.txt` contains an invalid line—the contents
    of `csvData.txt` are the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示`csvData.txt`包含无效行——`csvData.txt`的内容如下：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Despite being much better than the previous version, the new version of the
    statistics utility is still not perfect. Here is a list of things that can be
    improved:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管比上一个版本好得多，但新的统计实用工具版本仍然不完美。以下是可以改进的事项列表：
- en: The ability to process multiple CSV data files.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理多个CSV数据文件。
- en: The ability to sort its output based on a predefined statistics property, such
    as the mean value when dealing with multiple CSV data files.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够根据预定义的统计属性（如处理多个CSV数据文件时的平均值）对输出进行排序。
- en: The ability to use JSON records and JSON slices for the data instead of CSV
    files.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用JSON记录和JSON切片来存储数据，而不是CSV文件。
- en: The statistics application will keep improving, starting from *Chapter 5*, *Reflection
    and Interfaces*, where sorting slices with structure elements is implemented.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 统计应用程序将从第5章开始不断改进，该章介绍了反射和接口，其中实现了对结构体元素的切片排序。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed the composite data types of Go, which are maps
    and structures. Additionally, we talked about working with CSV files as well as
    using regular expressions and pattern matching. We can now keep our data in proper
    structures, validate it using regular expressions, and store it in CSV files to
    achieve data persistency.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Go的复合数据类型，即映射（map）和结构体。此外，我们还讨论了处理CSV文件以及使用正则表达式和模式匹配。现在我们可以将数据保存在适当的结构体中，使用正则表达式进行验证，并将其存储在CSV文件中以实现数据持久性。
- en: Always keep in mind that **if you try to get the value of a key that does not
    exist in a map, Go will not complain about it and will return the zero value of
    the data type of the value.**
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，**如果你尝试获取映射中不存在的键的值，Go不会对此提出异议，并将返回值的零值。**
- en: The next chapter is about Go generics, which is a relatively new Go feature.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于Go泛型的内容，这是一个相对较新的Go特性。
- en: Exercises
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Write a Go program that converts an existing array into a map.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个Go程序，将现有的数组转换为映射（map）。
- en: Write a Go program that converts an existing map into two slices—the first slice
    containing the keys of the map whereas the second one containing the values. The
    values at index `n` of the two slices should correspond to a key and value pair
    that can be found in the original map.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个Go程序，将现有的映射（map）转换为两个切片——第一个切片包含映射的键，而第二个切片包含映射的值。两个切片中索引`n`的值应该对应于原始映射中可以找到的键值对。
- en: Make the necessary changes to `nameSurRE.go` to be able to process multiple
    command line arguments.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`nameSurRE.go`进行必要的修改，以便能够处理多个命令行参数。
- en: Change the code of `intRE.go` to process multiple command line arguments and
    display totals of `true` and `false` results at the end.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`intRE.go`的代码，以处理多个命令行参数并在最后显示`true`和`false`结果的总计。
- en: Make changes to `csvData.go` to separate the fields of a record based on the
    `#` character.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`csvData.go`进行修改，根据`#`字符来分隔记录的字段。
- en: To understand how difficult regular expressions might end up, look on the internet
    for a regular expression to match email addresses.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解正则表达式可能有多难，请在互联网上搜索一个匹配电子邮件地址的正则表达式。
- en: The `regexp` package includes the `MatchString()` method. Try to understand
    its main difference from the `Match` method and create a working example.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp`包包括`MatchString()`方法。尝试理解它与`Match`方法的主要区别，并创建一个工作示例。'
- en: Write a Go utility that converts `os.Args` into a slice of structures, with
    fields for storing the index and the value of each command line argument—you should
    define the structure that is going to be used.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个Go实用工具，将`os.Args`转换为结构体切片，其中包含存储每个命令行参数索引和值的字段——你应该定义将要使用的结构体。
- en: Make changes to `csvData.go` to separate the fields of a record, using a single
    character that is given as a command line argument.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`csvData.go`进行修改，使用单个字符（作为命令行参数给出）来分隔记录的字段。
- en: Modify the `stdDev()` function of `stats.go`, in order to save the mean value
    of the sample into a global variable and delete the `fmt.Printf()` call from it.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `stats.go` 中的 `stdDev()` 函数，以便将样本的平均值保存到一个全局变量中，并从其中删除 `fmt.Printf()` 调用。
- en: Additional resources
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The `encoding/csv` documentation: [https://pkg.go.dev/encoding/csv](https://pkg.go.dev/encoding/csv)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding/csv` 文档：[https://pkg.go.dev/encoding/csv](https://pkg.go.dev/encoding/csv)'
- en: 'The `runtime` package documentation: [https://pkg.go.dev/runtime](https://pkg.go.dev/runtime)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime` 包文档：[https://pkg.go.dev/runtime](https://pkg.go.dev/runtime)'
- en: 'The `regexp` package documentation: [https://pkg.go.dev/regexp](https://pkg.go.dev/regexp
    )'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp` 包文档：[https://pkg.go.dev/regexp](https://pkg.go.dev/regexp)'
- en: Join our community on Discord
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6)'
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6)'
