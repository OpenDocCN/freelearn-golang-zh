<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer072">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 class="chapterTitle" id="_idParaDest-107"><span class="koboSpan" id="kobo.2.1">Go Generics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">This chapter is about generics and how to use the new syntax to write generic functions and define generic data types. </span><span class="koboSpan" id="kobo.3.2">Generic programming is a programming paradigm that allows the developer to implement a function using one or more data types that are going to be provided at a later time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">The Go generics support came with Go 1.18, which was officially released in February 2022. </span><span class="koboSpan" id="kobo.4.2">As a result, Go generics is now old news! </span><span class="koboSpan" id="kobo.4.3">Nevertheless, the Go community is still trying to make sense and good use of generics. </span><span class="koboSpan" id="kobo.4.4">In fact, most Go developers are already doing their job without the help of generics.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.5.1">If you feel that this chapter does not interest you at this point of your learning journey, feel free to skip it and come back at a later stage. </span><span class="koboSpan" id="kobo.5.2">However, I suggest that you read it even though it might not interest you right now.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.6.1">This brings us to the following fact: </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.7.1">you do not have to use Go generics if you do not want to, have doubts about the usefulness of generics, or have a different approach in mind</span></strong><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">After all, you</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.9.1"> can still write wonderful, efficient, maintainable, and correct software in Go without using generics! </span><span class="koboSpan" id="kobo.9.2">Additionally, the fact that you can use generics and support lots of data types, if not all available data types, does not mean that you should do that. </span><span class="koboSpan" id="kobo.9.3">Always support the required data types, no more, no less, but do not forget to keep an eye on the future of your data and the possibility of supporting data types that were not known at the time of writing your code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.10.1">This chapter covers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">An introduction to generics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Constraints</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Defining new data types with generics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">When to use generics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.16.1">cmp</span></code><span class="koboSpan" id="kobo.17.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.19.1">slices</span></code><span class="koboSpan" id="kobo.20.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.22.1">maps</span></code><span class="koboSpan" id="kobo.23.1"> package</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-108"><span class="koboSpan" id="kobo.24.1">An introduction to generics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.25.1">Generics is a </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.26.1">feature that allows you the capability of not precisely specifying the data type of </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.27.1">one or more function parameters</span></strong><span class="koboSpan" id="kobo.28.1">, mainly because you want to make your functions as universal as possible. </span><span class="koboSpan" id="kobo.28.2">In other words, generics allow functions to process several data types without the need to write any special code, as is the case with the empty interface and interfaces in general. </span><span class="koboSpan" id="kobo.28.3">Interfaces are covered in </span><em class="chapterRef"><span class="koboSpan" id="kobo.29.1">Chapter 5</span></em><span class="koboSpan" id="kobo.30.1">, </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Reflection and Interfaces</span></em><span class="koboSpan" id="kobo.32.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.33.1">When working with interfaces in Go, you must write extra code to determine the data type of the interface variable you are working with, which is not the case with generics.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.34.1">Let me begin by presenting a </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.35.1">small code example that implements a function that clearly shows a case where generics can be handy and save you from having to write lots of code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.36.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.37.1">PrintSlice</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.38.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.39.1">T</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.40.1">any</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.41.1">]</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.42.1">(s []T)</span></span><span class="koboSpan" id="kobo.43.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.44.1">for</span></span><span class="koboSpan" id="kobo.45.1"> _, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.46.1">range</span></span><span class="koboSpan" id="kobo.47.1"> s {
        fmt.Println(v)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.48.1">So, what do we have here? </span><span class="koboSpan" id="kobo.48.2">There is a function named </span><code class="inlineCode"><span class="koboSpan" id="kobo.49.1">PrintSlice()</span></code><span class="koboSpan" id="kobo.50.1"> that accepts a slice of any data type. </span><span class="koboSpan" id="kobo.50.2">This is denoted by the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.51.1">[]T</span></code><span class="koboSpan" id="kobo.52.1"> in the function signature, which specifies that the function accepts a slice, in combination with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.53.1">[T any]</span></code><span class="koboSpan" id="kobo.54.1"> part that specifies that all data types are accepted and therefore supported. </span><span class="koboSpan" id="kobo.54.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">[T any]</span></code><span class="koboSpan" id="kobo.56.1"> part tells the compiler that the data type </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">T</span></code><span class="koboSpan" id="kobo.58.1"> is not going to be determined at execution time but it is still going to be determined and enforced at compile time based on the type provided by the calling code. </span><span class="koboSpan" id="kobo.58.2">We are also free to use multiple (generics) data types using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">[T, U, W any]</span></code><span class="koboSpan" id="kobo.60.1"> notation—after which we should use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">T</span></code><span class="koboSpan" id="kobo.62.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">U</span></code><span class="koboSpan" id="kobo.64.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.65.1">W</span></code><span class="koboSpan" id="kobo.66.1"> data types in the function signature.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.67.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.68.1">any</span></code><span class="koboSpan" id="kobo.69.1"> keyword </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.70.1">tells the compiler that there are no constraints about the data type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.71.1">T</span></code><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">We are going to discuss constraints in a bit—for now, we will just learn about the syntax of generics.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.73.1">Now, imagine writing separate functions to implement the functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">PrintSlice()</span></code><span class="koboSpan" id="kobo.75.1"> for slices of integers, strings, floating-point numbers, complex values, and so on. </span><span class="koboSpan" id="kobo.75.2">So, we have found a profound case where using generics simplifies the code and our programming efforts. </span><span class="koboSpan" id="kobo.75.3">However, not all cases are so obvious, and we should be very careful about overusing </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">any</span></code><span class="koboSpan" id="kobo.77.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-109"><span class="koboSpan" id="kobo.78.1">Hello, generics!</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.79.1">The following (</span><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">hw.go</span></code><span class="koboSpan" id="kobo.81.1">) is a piece </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.82.1">of code that uses generics, to help you understand more about them before going into more advanced examples:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.83.1">package</span></span><span class="koboSpan" id="kobo.84.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.85.1">import</span></span><span class="koboSpan" id="kobo.86.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.87.1">"fmt"</span></span><span class="koboSpan" id="kobo.88.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.89.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.90.1">PrintSlice</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.91.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.92.1">T</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.93.1">any</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.94.1">]</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.95.1">(s []T)</span></span><span class="koboSpan" id="kobo.96.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.97.1">for</span></span><span class="koboSpan" id="kobo.98.1"> _, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.99.1">range</span></span><span class="koboSpan" id="kobo.100.1"> s {
        fmt.Print(v, </span><span class="hljs-string"><span class="koboSpan" id="kobo.101.1">" "</span></span><span class="koboSpan" id="kobo.102.1">)
    }
    fmt.Println()
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">PrintSlice()</span></code><span class="koboSpan" id="kobo.104.1"> is similar to the function that we saw earlier in this chapter. </span><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">PrintSlice()</span></code><span class="koboSpan" id="kobo.106.1"> prints the elements of each slice in the same line and prints a new line at the end with the help of </span><code class="inlineCode"><span class="koboSpan" id="kobo.107.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.108.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.109.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.110.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.111.1">()</span></span><span class="koboSpan" id="kobo.112.1"> {
    PrintSlice([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.113.1">int</span></span><span class="koboSpan" id="kobo.114.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.115.1">1</span></span><span class="koboSpan" id="kobo.116.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.117.1">2</span></span><span class="koboSpan" id="kobo.118.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.119.1">3</span></span><span class="koboSpan" id="kobo.120.1">})
    PrintSlice([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.121.1">string</span></span><span class="koboSpan" id="kobo.122.1">{</span><span class="hljs-string"><span class="koboSpan" id="kobo.123.1">"a"</span></span><span class="koboSpan" id="kobo.124.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.125.1">"b"</span></span><span class="koboSpan" id="kobo.126.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.127.1">"c"</span></span><span class="koboSpan" id="kobo.128.1">})
    PrintSlice([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.129.1">float64</span></span><span class="koboSpan" id="kobo.130.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.131.1">1.2</span></span><span class="koboSpan" id="kobo.132.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.133.1">-2.33</span></span><span class="koboSpan" id="kobo.134.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.135.1">4.55</span></span><span class="koboSpan" id="kobo.136.1">})
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.137.1">Here, we call the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">PrintSlice()</span></code><span class="koboSpan" id="kobo.139.1"> with three different data types: </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">int</span></code><span class="koboSpan" id="kobo.141.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">string</span></code><span class="koboSpan" id="kobo.143.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">float64</span></code><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">The</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.146.1"> Go compiler is not going to complain about that. </span><span class="koboSpan" id="kobo.146.2">Instead, it is going to execute the code as if we had three separate functions, one for each data type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.147.1">Therefore, running </span><code class="inlineCode"><span class="koboSpan" id="kobo.148.1">hw.go</span></code><span class="koboSpan" id="kobo.149.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.150.1">1 2 3
a b c
1.2 -2.33 4.55
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.151.1">So, each slice is printed as expected using a single generic function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.152.1">With that information in mind, let us begin by discussing generics and constraints.</span></p>
<h1 class="heading-1" id="_idParaDest-110"><span class="koboSpan" id="kobo.153.1">Constraints</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.154.1">Let us say</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.155.1"> that you have a function that works with generics that multiplies two numeric values. </span><span class="koboSpan" id="kobo.155.2">Should this function work with all data types? </span><span class="koboSpan" id="kobo.155.3">Can this function work with all data types? </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.156.1">Can you multiply two strings or two structures?</span></strong><span class="koboSpan" id="kobo.157.1"> The solution for avoiding that kind of issue is the use of constraints. </span><em class="italic"><span class="koboSpan" id="kobo.158.1">Type constraints</span></em><span class="koboSpan" id="kobo.159.1"> allow you to specify the list of data types that you want to work with in order to avoid logical errors and bugs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.160.1">Forget about multiplication for a while and think about something simpler. </span><span class="koboSpan" id="kobo.160.2">Let us say that we want to compare variables for equality—is there a way to tell Go that we only want to work with values that can be compared? </span><span class="koboSpan" id="kobo.160.3">Go 1.18 came with predefined type constraints—one of them is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">comparable</span></code><span class="koboSpan" id="kobo.162.1"> and includes data types that can be compared for equality or inequality.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.163.1">For more predefined constraints, you should look at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.164.1">constraints</span></code><span class="koboSpan" id="kobo.165.1"> package (</span><a href="https://pkg.go.dev/golang.org/x/exp/constraints"><span class="url"><span class="koboSpan" id="kobo.166.1">https://pkg.go.dev/golang.org/x/exp/constraints</span></span></a><span class="koboSpan" id="kobo.167.1">).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.168.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">allowed.go</span></code><span class="koboSpan" id="kobo.170.1"> illustrates the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.171.1">comparable</span></code><span class="koboSpan" id="kobo.172.1"> constraint.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.173.1">package</span></span><span class="koboSpan" id="kobo.174.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.175.1">import</span></span><span class="koboSpan" id="kobo.176.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.177.1">"fmt"</span></span><span class="koboSpan" id="kobo.178.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.179.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.180.1">Same</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.181.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.182.1">T</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.183.1">comparable</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.184.1">]</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.185.1">(a, b T)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.186.1">bool</span></span><span class="koboSpan" id="kobo.187.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.188.1">// Or</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.189.1">// return a == b</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.190.1">if</span></span><span class="koboSpan" id="kobo.191.1"> a == b {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.192.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.193.1">true</span></span><span class="koboSpan" id="kobo.194.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.195.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.196.1">false</span></span><span class="koboSpan" id="kobo.197.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.198.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">Same()</span></code><span class="koboSpan" id="kobo.200.1"> function uses the predefined </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">comparable</span></code><span class="koboSpan" id="kobo.202.1"> constraint instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">any</span></code><span class="koboSpan" id="kobo.204.1">. </span><span class="koboSpan" id="kobo.204.2">In reality, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.205.1">comparable</span></code><span class="koboSpan" id="kobo.206.1"> constraint is just a predefined interface that includes all data types that can be </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.207.1">compared with </span><code class="inlineCode"><span class="koboSpan" id="kobo.208.1">==</span></code><span class="koboSpan" id="kobo.209.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">!=</span></code><span class="koboSpan" id="kobo.211.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.212.1">We do not have to write any extra code for checking our input as the function signature makes sure that we are going to deal with acceptable and functional data types only.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.213.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.214.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.215.1">()</span></span><span class="koboSpan" id="kobo.216.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.217.1">"4 = 3 is"</span></span><span class="koboSpan" id="kobo.218.1">, Same(</span><span class="hljs-number"><span class="koboSpan" id="kobo.219.1">4</span></span><span class="koboSpan" id="kobo.220.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.221.1">3</span></span><span class="koboSpan" id="kobo.222.1">))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.223.1">"aa = aa is"</span></span><span class="koboSpan" id="kobo.224.1">, Same(</span><span class="hljs-string"><span class="koboSpan" id="kobo.225.1">"aa"</span></span><span class="koboSpan" id="kobo.226.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.227.1">"aa"</span></span><span class="koboSpan" id="kobo.228.1">))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.229.1">"4.1 = 4.15 is"</span></span><span class="koboSpan" id="kobo.230.1">, Same(</span><span class="hljs-number"><span class="koboSpan" id="kobo.231.1">4.1</span></span><span class="koboSpan" id="kobo.232.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.233.1">4.15</span></span><span class="koboSpan" id="kobo.234.1">))
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.235.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">main()</span></code><span class="koboSpan" id="kobo.237.1"> function calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">Same()</span></code><span class="koboSpan" id="kobo.239.1"> three times, using different data types, and prints its results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.240.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">allowed.go</span></code><span class="koboSpan" id="kobo.242.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.243.1">4 = 3 is false
aa = aa is true
4.1 = 4.15 is false
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.244.1">As only </span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">Same("aa","aa")</span></code><span class="koboSpan" id="kobo.246.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">true</span></code><span class="koboSpan" id="kobo.248.1">, we get the respective output.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.249.1">If you try to run a statement like </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">Same([]int{1,2},[]int{1,3})</span></code><span class="koboSpan" id="kobo.251.1">, which tries to compare two slices, the compiler is going to generate the following error message:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.252.1"># </span></span><span class="koboSpan" id="kobo.253.1">command-line-arguments
./allowed.go:19:10: []int does not satisfy comparable
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.254.1">This happens because we cannot directly compare two slices—this kind of functionality should be implemented manually. </span><span class="koboSpan" id="kobo.254.2">Note that you are allowed to compare two arrays!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.255.1">The next subsection shows how to create your own constraints.</span></p>
<h2 class="heading-2" id="_idParaDest-111"><span class="koboSpan" id="kobo.256.1">Creating constraints</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.257.1">This</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.258.1"> subsection presents an example where we define the data types that are allowed to be passed as parameters to a generic function using an interface. </span><span class="koboSpan" id="kobo.258.2">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.259.1">numeric.go</span></code><span class="koboSpan" id="kobo.260.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.261.1">package</span></span><span class="koboSpan" id="kobo.262.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.263.1">import</span></span><span class="koboSpan" id="kobo.264.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.265.1">"fmt"</span></span><span class="koboSpan" id="kobo.266.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.267.1">type</span></span><span class="koboSpan" id="kobo.268.1"> Numeric </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.269.1">interface</span></span><span class="koboSpan" id="kobo.270.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.271.1">int</span></span><span class="koboSpan" id="kobo.272.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.273.1">int8</span></span><span class="koboSpan" id="kobo.274.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.275.1">int16</span></span><span class="koboSpan" id="kobo.276.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.277.1">int32</span></span><span class="koboSpan" id="kobo.278.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.279.1">int64</span></span><span class="koboSpan" id="kobo.280.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.281.1">float64</span></span><span class="koboSpan" id="kobo.282.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.283.1">Here, we define a new interface called </span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">Numeric</span></code><span class="koboSpan" id="kobo.285.1">, which specifies the list of supported data types. </span><span class="koboSpan" id="kobo.285.2">You can use any data type you want as long as it can be used with the generic function that you are going to implement. </span><span class="koboSpan" id="kobo.285.3">In this case, we could have added </span><code class="inlineCode"><span class="koboSpan" id="kobo.286.1">string</span></code><span class="koboSpan" id="kobo.287.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">uint</span></code><span class="koboSpan" id="kobo.289.1"> to the list of supported data types, if that makes sense. </span><span class="koboSpan" id="kobo.289.2">In this case, adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">string</span></code><span class="koboSpan" id="kobo.291.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">Numeric</span></code><span class="koboSpan" id="kobo.293.1"> interface does not make any sense.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.294.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.295.1">Add</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.296.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.297.1">T</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.298.1">Numeric</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.299.1">]</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.300.1">(a, b T)</span></span><span class="koboSpan" id="kobo.301.1"> T {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.302.1">return</span></span><span class="koboSpan" id="kobo.303.1"> a + b
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.304.1">This is the definition of the generic function with two generic parameters that use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">Numeric</span></code><span class="koboSpan" id="kobo.306.1"> constraint.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.307.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.308.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.309.1">()</span></span><span class="koboSpan" id="kobo.310.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.311.1">"4 + 3 ="</span></span><span class="koboSpan" id="kobo.312.1">, Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.313.1">4</span></span><span class="koboSpan" id="kobo.314.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.315.1">3</span></span><span class="koboSpan" id="kobo.316.1">))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.317.1">"4.1 + 3.2 ="</span></span><span class="koboSpan" id="kobo.318.1">, Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.319.1">4.1</span></span><span class="koboSpan" id="kobo.320.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.321.1">3.2</span></span><span class="koboSpan" id="kobo.322.1">))
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.323.1">The previous code is the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">main()</span></code><span class="koboSpan" id="kobo.325.1"> function with the calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">Add()</span></code><span class="koboSpan" id="kobo.327.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.328.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">numeric.go</span></code><span class="koboSpan" id="kobo.330.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.331.1">4 + 3 = 7
4.1 + 3.2 = 7.3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.332.1">Nevertheless, the Go rules still apply. </span><span class="koboSpan" id="kobo.332.2">Therefore, if you try to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">Add(4.1,3)</span></code><span class="koboSpan" id="kobo.334.1">, you are going to get the following error message:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.335.1"># </span></span><span class="koboSpan" id="kobo.336.1">command-line-arguments
./numeric.go:19:15: default type int of 3 does not match inferred type float64 for T
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.337.1">The reason</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.338.1"> for this error is that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">Add()</span></code><span class="koboSpan" id="kobo.340.1"> function expects two parameters of the same data type. </span><span class="koboSpan" id="kobo.340.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">4.1</span></code><span class="koboSpan" id="kobo.342.1"> is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">float64</span></code><span class="koboSpan" id="kobo.344.1"> whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">3</span></code><span class="koboSpan" id="kobo.346.1"> is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">int</span></code><span class="koboSpan" id="kobo.348.1">, so not the same data type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.349.1">There is an additional issue with constraints that we have not discussed so far. </span><span class="koboSpan" id="kobo.349.2">As we already know, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.350.1">Go treats different data types differently even if the underlying data type is the same</span></strong><span class="koboSpan" id="kobo.351.1">. </span><span class="koboSpan" id="kobo.351.2">This means that if we create a new data type that is based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">int</span></code><span class="koboSpan" id="kobo.353.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">type aType int</span></code><span class="koboSpan" id="kobo.355.1">), it is not going to be supported by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">Numeric</span></code><span class="koboSpan" id="kobo.357.1"> constraint as this is not specified. </span><span class="koboSpan" id="kobo.357.2">The next subsection shows us how to deal with it and overcome that limitation.</span></p>
<h2 class="heading-2" id="_idParaDest-112"><span class="koboSpan" id="kobo.358.1">Supporting underlying data types</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.359.1">With supertypes, we</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.360.1"> are adding support for the underlying data type—the real one—and not the data type at hand, which might be an alias for an existing Go data type. </span><span class="koboSpan" id="kobo.360.2">Supertypes are supported by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">~</span></code><span class="koboSpan" id="kobo.362.1"> operator. </span><span class="koboSpan" id="kobo.362.2">The use of supertypes is illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">supertypes.go</span></code><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">The first part of the code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">supertypes.go</span></code><span class="koboSpan" id="kobo.366.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.367.1">type</span></span><span class="koboSpan" id="kobo.368.1"> AnotherInt </span><span class="hljs-type"><span class="koboSpan" id="kobo.369.1">int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.370.1">type</span></span><span class="koboSpan" id="kobo.371.1"> AllInts </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.372.1">interface</span></span><span class="koboSpan" id="kobo.373.1"> {
    ~</span><span class="hljs-type"><span class="koboSpan" id="kobo.374.1">int</span></span><span class="koboSpan" id="kobo.375.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.376.1">In the previous code, we define a constraint named </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">AllInts</span></code><span class="koboSpan" id="kobo.378.1"> that uses a supertype (</span><code class="inlineCode"><span class="koboSpan" id="kobo.379.1">~int</span></code><span class="koboSpan" id="kobo.380.1">) as well as a new data type that is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.381.1">AnotherInt</span></code><span class="koboSpan" id="kobo.382.1"> and is in reality </span><code class="inlineCode"><span class="koboSpan" id="kobo.383.1">int</span></code><span class="koboSpan" id="kobo.384.1">. </span><span class="koboSpan" id="kobo.384.2">The definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.385.1">AllInts</span></code><span class="koboSpan" id="kobo.386.1"> constraint allows </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">AnotherInt</span></code><span class="koboSpan" id="kobo.388.1"> to be supported by </span><code class="inlineCode"><span class="koboSpan" id="kobo.389.1">AllInts</span></code><span class="koboSpan" id="kobo.390.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.391.1">The second part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">supertypes.go</span></code><span class="koboSpan" id="kobo.393.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.394.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.395.1">AddElements</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.396.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.397.1">T</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.398.1">AllInts</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.399.1">]</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.400.1">(s []T)</span></span><span class="koboSpan" id="kobo.401.1"> T {
    sum := T(</span><span class="hljs-number"><span class="koboSpan" id="kobo.402.1">0</span></span><span class="koboSpan" id="kobo.403.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.404.1">for</span></span><span class="koboSpan" id="kobo.405.1"> _, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.406.1">range</span></span><span class="koboSpan" id="kobo.407.1"> s {
        sum = sum + v
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.408.1">return</span></span><span class="koboSpan" id="kobo.409.1"> sum
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.410.1">In this part, we have defined a generic function. </span><span class="koboSpan" id="kobo.410.2">The function comes with a constraint as it supports slices of </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">AllInts</span></code><span class="koboSpan" id="kobo.412.1"> only.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.413.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">supertypes.go</span></code><span class="koboSpan" id="kobo.415.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.416.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.417.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.418.1">()</span></span><span class="koboSpan" id="kobo.419.1"> {
    s := []AnotherInt{</span><span class="hljs-number"><span class="koboSpan" id="kobo.420.1">0</span></span><span class="koboSpan" id="kobo.421.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.422.1">1</span></span><span class="koboSpan" id="kobo.423.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.424.1">2</span></span><span class="koboSpan" id="kobo.425.1">}
    fmt.Println(AddElements(s))
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.426.1">In this</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.427.1"> last part, we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">AddElements()</span></code><span class="koboSpan" id="kobo.429.1"> using a slice of </span><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">AnotherInt</span></code><span class="koboSpan" id="kobo.431.1"> as its parameter—this capability is offered by the use of the supertype in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">AllInts</span></code><span class="koboSpan" id="kobo.433.1"> constraint.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.434.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">supertypes.go</span></code><span class="koboSpan" id="kobo.436.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.437.1">$ </span></span><span class="koboSpan" id="kobo.438.1">go run supertypes.go
3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.439.1">So, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.440.1">the use of supertypes in type constraints allows Go to deal with the actual underlying data type</span></strong><span class="koboSpan" id="kobo.441.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-113"><span class="koboSpan" id="kobo.442.1">Supporting slices of any type</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.443.1">In this </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.444.1">subsection, we are going to specify that a function parameter can only be a slice of any data type. </span><span class="koboSpan" id="kobo.444.2">The relevant code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">sliceConstraint.go</span></code><span class="koboSpan" id="kobo.446.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.447.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.448.1">f1</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.449.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.450.1">S</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.451.1">interface</span></span><span class="koboSpan" id="kobo.452.1">{ ~[]E }, E </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.453.1">interface</span></span><span class="koboSpan" id="kobo.454.1">{}](x S) </span><span class="hljs-type"><span class="koboSpan" id="kobo.455.1">int</span></span><span class="koboSpan" id="kobo.456.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.457.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.458.1">len</span></span><span class="koboSpan" id="kobo.459.1">(x)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.460.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.461.1">f2</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.462.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.463.1">S</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.464.1"> ~[]</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.465.1">E</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.466.1">, </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.467.1">E</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.468.1">interface</span></span><span class="koboSpan" id="kobo.469.1">{}](x S) </span><span class="hljs-type"><span class="koboSpan" id="kobo.470.1">int</span></span><span class="koboSpan" id="kobo.471.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.472.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.473.1">len</span></span><span class="koboSpan" id="kobo.474.1">(x)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.476.1">f3</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.477.1">[</span></span><span class="code-highlight"><strong class="hljs-title-slc"><span class="koboSpan" id="kobo.478.1">S</span></strong><strong class="hljs-function-slc"><span class="koboSpan" id="kobo.479.1"> ~[]</span></strong><strong class="hljs-title-slc"><span class="koboSpan" id="kobo.480.1">E</span></strong><strong class="hljs-function-slc"><span class="koboSpan" id="kobo.481.1">, </span></strong><strong class="hljs-title-slc"><span class="koboSpan" id="kobo.482.1">E</span></strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc"><span class="koboSpan" id="kobo.483.1">any</span></strong></span><span class="hljs-function"><span class="koboSpan" id="kobo.484.1">]</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.485.1">(x S)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.486.1">int</span></span><span class="koboSpan" id="kobo.487.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.488.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.489.1">len</span></span><span class="koboSpan" id="kobo.490.1">(x)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.491.1">All three generic functions are equivalent. </span><span class="koboSpan" id="kobo.491.2">The use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">~[]E</span></code><span class="koboSpan" id="kobo.493.1"> specifies that the underlying data type should be a slice even if it is a type by a different name.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.494.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">f1()</span></code><span class="koboSpan" id="kobo.496.1"> function</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.497.1"> is the long version of the function signature. </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">interface{ ~[]E }</span></code><span class="koboSpan" id="kobo.499.1"> specifies that we only want to work with slices of any data type (</span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">E interface{}</span></code><span class="koboSpan" id="kobo.501.1">). </span><span class="koboSpan" id="kobo.501.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">f2()</span></code><span class="koboSpan" id="kobo.503.1"> function replaces </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">interface{ ~[]E }</span></code><span class="koboSpan" id="kobo.505.1"> with just </span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">~[]E</span></code><span class="koboSpan" id="kobo.507.1"> because Go allows you to omit the enclosing </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">interface{}</span></code><span class="koboSpan" id="kobo.509.1"> for interfaces in the constraint position. </span><span class="koboSpan" id="kobo.509.2">Last, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">f3()</span></code><span class="koboSpan" id="kobo.511.1"> function replaces the commonly used </span><code class="inlineCode"><span class="koboSpan" id="kobo.512.1">interface{}</span></code><span class="koboSpan" id="kobo.513.1"> with its predefined equivalent </span><code class="inlineCode"><span class="koboSpan" id="kobo.514.1">any</span></code><span class="koboSpan" id="kobo.515.1">, which we have already seen in action. </span><span class="koboSpan" id="kobo.515.2">I find the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.516.1">f3()</span></code><span class="koboSpan" id="kobo.517.1"> much simpler and easier to understand.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.518.1">The next section shows us how to use generics when defining new data types.</span></p>
<h1 class="heading-1" id="_idParaDest-114"><span class="koboSpan" id="kobo.519.1">Defining new data types with generics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.520.1">In this section, we are </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.521.1">going to create a new data type </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.522.1">with the use of generics, which is presented in </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">newDT.go</span></code><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">newDT.go</span></code><span class="koboSpan" id="kobo.526.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.527.1">package</span></span><span class="koboSpan" id="kobo.528.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.529.1">import</span></span><span class="koboSpan" id="kobo.530.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.531.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.532.1">"errors"</span></span><span class="koboSpan" id="kobo.533.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.534.1">type</span></span><span class="koboSpan" id="kobo.535.1"> TreeLast[T any] []T
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.536.1">The previous statement declares a new data type named </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">TreeLast</span></code><span class="koboSpan" id="kobo.538.1"> that uses generics.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.539.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.540.1">(t TreeLast[T])</span></span><span class="koboSpan" id="kobo.541.1"> replaceLast(element T) (TreeLast[T], </span><span class="hljs-type"><span class="koboSpan" id="kobo.542.1">error</span></span><span class="koboSpan" id="kobo.543.1">) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.544.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.545.1">len</span></span><span class="koboSpan" id="kobo.546.1">(t) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.547.1">0</span></span><span class="koboSpan" id="kobo.548.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.549.1">return</span></span><span class="koboSpan" id="kobo.550.1"> t, errors.New(</span><span class="hljs-string"><span class="koboSpan" id="kobo.551.1">"This is empty!"</span></span><span class="koboSpan" id="kobo.552.1">)
    }
    
    t[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.553.1">len</span></span><span class="koboSpan" id="kobo.554.1">(t) - </span><span class="hljs-number"><span class="koboSpan" id="kobo.555.1">1</span></span><span class="koboSpan" id="kobo.556.1">] = element
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.557.1">return</span></span><span class="koboSpan" id="kobo.558.1"> t, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.559.1">nil</span></span><span class="koboSpan" id="kobo.560.1">
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.561.1">replaceLast()</span></code><span class="koboSpan" id="kobo.562.1"> is a method that operates on </span><code class="inlineCode"><span class="koboSpan" id="kobo.563.1">TreeLast</span></code><span class="koboSpan" id="kobo.564.1"> variables. </span><span class="koboSpan" id="kobo.564.2">Apart from the function signature, there is nothing else that shows the use of generics.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.565.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.566.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.567.1">()</span></span><span class="koboSpan" id="kobo.568.1"> {
    tempStr := TreeLast[</span><span class="hljs-type"><span class="koboSpan" id="kobo.569.1">string</span></span><span class="koboSpan" id="kobo.570.1">]{</span><span class="hljs-string"><span class="koboSpan" id="kobo.571.1">"aa"</span></span><span class="koboSpan" id="kobo.572.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.573.1">"bb"</span></span><span class="koboSpan" id="kobo.574.1">}
    fmt.Println(tempStr)
    tempStr.replaceLast(</span><span class="hljs-string"><span class="koboSpan" id="kobo.575.1">"cc"</span></span><span class="koboSpan" id="kobo.576.1">)
    fmt.Println(tempStr)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.577.1">In this</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.578.1"> first part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.579.1">main()</span></code><span class="koboSpan" id="kobo.580.1">, we create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.581.1">TreeLast</span></code><span class="koboSpan" id="kobo.582.1"> variable </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.583.1">with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.584.1">aa</span></code><span class="koboSpan" id="kobo.585.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.586.1">bb</span></code><span class="koboSpan" id="kobo.587.1"> string values and then we replace the </span><code class="inlineCode"><span class="koboSpan" id="kobo.588.1">bb</span></code><span class="koboSpan" id="kobo.589.1"> value with </span><code class="inlineCode"><span class="koboSpan" id="kobo.590.1">cc</span></code><span class="koboSpan" id="kobo.591.1">, using a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.592.1">replaceLast("cc")</span></code><span class="koboSpan" id="kobo.593.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.594.1">    tempInt := TreeLast[</span><span class="hljs-type"><span class="koboSpan" id="kobo.595.1">int</span></span><span class="koboSpan" id="kobo.596.1">]{</span><span class="hljs-number"><span class="koboSpan" id="kobo.597.1">12</span></span><span class="koboSpan" id="kobo.598.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.599.1">-3</span></span><span class="koboSpan" id="kobo.600.1">}
    fmt.Println(tempInt)
    tempInt.replaceLast(</span><span class="hljs-number"><span class="koboSpan" id="kobo.601.1">0</span></span><span class="koboSpan" id="kobo.602.1">)
    fmt.Println(tempInt)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.603.1">The second part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.604.1">main()</span></code><span class="koboSpan" id="kobo.605.1"> does a similar thing to the first part using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">TreeLast</span></code><span class="koboSpan" id="kobo.607.1"> variable populated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.608.1">int</span></code><span class="koboSpan" id="kobo.609.1"> values. </span><span class="koboSpan" id="kobo.609.2">So, </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">TreeLast</span></code><span class="koboSpan" id="kobo.611.1"> works with both </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">string</span></code><span class="koboSpan" id="kobo.613.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">int</span></code><span class="koboSpan" id="kobo.615.1"> values without any issues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.616.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.617.1">newDT.go</span></code><span class="koboSpan" id="kobo.618.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.619.1">[aa bb]
[aa cc]
[12 -3]
[12 0]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.620.1">The first two lines of the output are related to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.621.1">TreeLast[string]</span></code><span class="koboSpan" id="kobo.622.1"> variable whereas the last two lines of the output are related to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.623.1">TreeLast[int]</span></code><span class="koboSpan" id="kobo.624.1"> variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.625.1">The next subsection is about using generics in Go structures.</span></p>
<h2 class="heading-2" id="_idParaDest-115"><span class="koboSpan" id="kobo.626.1">Using generics in Go structures</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.627.1">In this section, we</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.628.1"> are going to implement a linked list that works with generics—this is one of the cases where the use of generics simplifies things because it allows you to implement the linked list once while being able to work with multiple data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.629.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.630.1">structures.go</span></code><span class="koboSpan" id="kobo.631.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.632.1">package</span></span><span class="koboSpan" id="kobo.633.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.634.1">import</span></span><span class="koboSpan" id="kobo.635.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.636.1">"fmt"</span></span><span class="koboSpan" id="kobo.637.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.638.1">type</span></span><span class="koboSpan" id="kobo.639.1"> node[T any] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.640.1">struct</span></span><span class="koboSpan" id="kobo.641.1"> {
    Data T
    next *node[T]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.642.1">The </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.643.1">node structure uses generics in order to support nodes that can store all kinds of data. </span><span class="koboSpan" id="kobo.643.2">This does not mean that the next field of a node can point to another node with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.644.1">Data</span></code><span class="koboSpan" id="kobo.645.1"> field with a different data type. </span><span class="koboSpan" id="kobo.645.2">The rule that a linked list contains elements of the same data type still applies—it just means that if you want to create three linked lists, one for storing </span><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">string</span></code><span class="koboSpan" id="kobo.647.1"> values, one for storing </span><code class="inlineCode"><span class="koboSpan" id="kobo.648.1">int</span></code><span class="koboSpan" id="kobo.649.1"> values, and a third one for storing JSON records of a given </span><code class="inlineCode"><span class="koboSpan" id="kobo.650.1">struct</span></code><span class="koboSpan" id="kobo.651.1"> data type, you do not need to write any extra code to do so.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.652.1">type</span></span><span class="koboSpan" id="kobo.653.1"> list[T any] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.654.1">struct</span></span><span class="koboSpan" id="kobo.655.1"> {
    start *node[T]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.656.1">This is the definition of the root node of a linked list of </span><code class="inlineCode"><span class="koboSpan" id="kobo.657.1">node</span></code><span class="koboSpan" id="kobo.658.1"> nodes. </span><span class="koboSpan" id="kobo.658.2">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.659.1">list</span></code><span class="koboSpan" id="kobo.660.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.661.1">node</span></code><span class="koboSpan" id="kobo.662.1"> must share the same data type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">T</span></code><span class="koboSpan" id="kobo.664.1">. </span><span class="koboSpan" id="kobo.664.2">However, as stated before, this does not prevent you from creating multiple linked lists of various data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.665.1">You can still replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.666.1">any</span></code><span class="koboSpan" id="kobo.667.1"> with a constraint in both the definition of </span><code class="inlineCode"><span class="koboSpan" id="kobo.668.1">node</span></code><span class="koboSpan" id="kobo.669.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">list</span></code><span class="koboSpan" id="kobo.671.1"> if you want to restrict the list of allowed data types.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.672.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.673.1">(l *list[T])</span></span><span class="koboSpan" id="kobo.674.1"> add(data T) {
    n := node[T]{
        Data: data,
        next: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.675.1">nil</span></span><span class="koboSpan" id="kobo.676.1">,
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.677.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.678.1">add()</span></code><span class="koboSpan" id="kobo.679.1"> function is generic in order to be able to work with all kinds of nodes. </span><span class="koboSpan" id="kobo.679.2">Apart from the signature of </span><code class="inlineCode"><span class="koboSpan" id="kobo.680.1">add()</span></code><span class="koboSpan" id="kobo.681.1">, the remaining code is not associated with the use of generics.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.682.1">if</span></span><span class="koboSpan" id="kobo.683.1"> l.start == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.684.1">nil</span></span><span class="koboSpan" id="kobo.685.1"> {
        l.start = &amp;n
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.686.1">return</span></span><span class="koboSpan" id="kobo.687.1">
    }
    
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.688.1">if</span></span><span class="koboSpan" id="kobo.689.1"> l.start.next == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.690.1">nil</span></span><span class="koboSpan" id="kobo.691.1"> {
        l.start.next = &amp;n
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.692.1">return</span></span><span class="koboSpan" id="kobo.693.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.694.1">These two </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">if</span></code><span class="koboSpan" id="kobo.696.1"> blocks</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.697.1"> have to do with the addition of a new node to the linked list. </span><span class="koboSpan" id="kobo.697.2">The first </span><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">if</span></code><span class="koboSpan" id="kobo.699.1"> block is when the list is empty whereas the second </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">if</span></code><span class="koboSpan" id="kobo.701.1"> block is when we are dealing with the last node of the current list.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.702.1">    temp := l.start
    l.start = l.start.next
    l.add(data)
    l.start = temp
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.703.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">add()</span></code><span class="koboSpan" id="kobo.705.1"> has to do with defining the proper associations between nodes when adding a new node to the list.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.706.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.707.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.708.1">()</span></span><span class="koboSpan" id="kobo.709.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.710.1">var</span></span><span class="koboSpan" id="kobo.711.1"> myList list[</span><span class="hljs-type"><span class="koboSpan" id="kobo.712.1">int</span></span><span class="koboSpan" id="kobo.713.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.714.1">First, we define a linked list of int values in </span><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">main()</span></code><span class="koboSpan" id="kobo.716.1">, which is the linked list that we are going to work with.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.717.1">    fmt.Println(myList)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.718.1">The initial value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">myList</span></code><span class="koboSpan" id="kobo.720.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.721.1">nil</span></code><span class="koboSpan" id="kobo.722.1">, as the list is empty and does not contain any nodes.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.723.1">    myList.add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.724.1">12</span></span><span class="koboSpan" id="kobo.725.1">)
    myList.add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.726.1">9</span></span><span class="koboSpan" id="kobo.727.1">)
    myList.add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.728.1">3</span></span><span class="koboSpan" id="kobo.729.1">)
    myList.add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.730.1">9</span></span><span class="koboSpan" id="kobo.731.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.732.1">In this first part, we add four elements to the linked list.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.733.1">// Print all elements</span></span><span class="koboSpan" id="kobo.734.1">
    cur := myList.start
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.735.1">for</span></span><span class="koboSpan" id="kobo.736.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.737.1">"*"</span></span><span class="koboSpan" id="kobo.738.1">, cur)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.739.1">if</span></span><span class="koboSpan" id="kobo.740.1"> cur == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.741.1">nil</span></span><span class="koboSpan" id="kobo.742.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.743.1">break</span></span><span class="koboSpan" id="kobo.744.1">
        }
        cur= cur.next
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.745.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">main()</span></code><span class="koboSpan" id="kobo.747.1"> is about printing all the elements of the list by traversing it with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">next</span></code><span class="koboSpan" id="kobo.749.1"> field, which points to the next node in the list.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.750.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.751.1">structures.go</span></code><span class="koboSpan" id="kobo.752.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.753.1">{&lt;nil&gt;}
* &amp;{12 0x14000096240}
* &amp;{9 0x14000096260}
* &amp;{3 0x14000096290}
* &amp;{9 &lt;nil&gt;}
* &lt;nil&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.754.1">Let us</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.755.1"> discuss the output a little more. </span><span class="koboSpan" id="kobo.755.2">The first line shows that the value of the empty list is </span><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">nil</span></code><span class="koboSpan" id="kobo.757.1">. </span><span class="koboSpan" id="kobo.757.2">The first node of the list holds a value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.758.1">12</span></code><span class="koboSpan" id="kobo.759.1"> and a memory address (</span><code class="inlineCode"><span class="koboSpan" id="kobo.760.1">0x14000096240</span></code><span class="koboSpan" id="kobo.761.1">) that points to the second node. </span><span class="koboSpan" id="kobo.761.2">This goes on until we reach the last node, which holds the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">9</span></code><span class="koboSpan" id="kobo.763.1">, which appears twice in this linked list, and points to </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">nil</span></code><span class="koboSpan" id="kobo.765.1">, because it is the last node. </span><span class="koboSpan" id="kobo.765.2">Therefore, the use of generics makes the linked list able to work with multiple data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.766.1">The next three sections present three packages that use generics—feel free to look into their implementations for details (see the </span><em class="italic"><span class="koboSpan" id="kobo.767.1">Additional resources</span></em><span class="koboSpan" id="kobo.768.1"> section).</span></p>
<h1 class="heading-1" id="_idParaDest-116"><span class="koboSpan" id="kobo.769.1">The cmp package</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.770.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.771.1">cmp</span></code><span class="koboSpan" id="kobo.772.1"> package, which</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.773.1"> became part of the standard Go library in Go 1.21, contains types and functions for comparing ordered values. </span><span class="koboSpan" id="kobo.773.2">The reason for presenting it before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">slices</span></code><span class="koboSpan" id="kobo.775.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">maps</span></code><span class="koboSpan" id="kobo.777.1"> packages is that it is used by the other two. </span><span class="koboSpan" id="kobo.777.2">Keep in mind that in its current version, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.778.1">cmp</span></code><span class="koboSpan" id="kobo.779.1"> package is simplistic but it might get enriched in the future with more functionality.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.780.1">Under the hood, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">cmp</span></code><span class="koboSpan" id="kobo.782.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.783.1">slices</span></code><span class="koboSpan" id="kobo.784.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.785.1">maps</span></code><span class="koboSpan" id="kobo.786.1"> packages use generics and constraints, which is the main reason for presenting them in this chapter. </span><span class="koboSpan" id="kobo.786.2">So, generics can be used for creating packages that work with multiple data types.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.787.1">The important code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.788.1">cmpPackage.go</span></code><span class="koboSpan" id="kobo.789.1"> can be found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.790.1">main()</span></code><span class="koboSpan" id="kobo.791.1"> function.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.792.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.793.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.794.1">()</span></span><span class="koboSpan" id="kobo.795.1"> {
    fmt.Println(cmp.Compare(</span><span class="hljs-number"><span class="koboSpan" id="kobo.796.1">5</span></span><span class="koboSpan" id="kobo.797.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.798.1">4</span></span><span class="koboSpan" id="kobo.799.1">))
    fmt.Println(cmp.Compare(</span><span class="hljs-number"><span class="koboSpan" id="kobo.800.1">4</span></span><span class="koboSpan" id="kobo.801.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.802.1">5</span></span><span class="koboSpan" id="kobo.803.1">))
    fmt.Println(cmp.Less(</span><span class="hljs-number"><span class="koboSpan" id="kobo.804.1">4</span></span><span class="koboSpan" id="kobo.805.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.806.1">5.1</span></span><span class="koboSpan" id="kobo.807.1">))
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.808.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.809.1">cmp.Compare(x, y)</span></code><span class="koboSpan" id="kobo.810.1"> compares two values and returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.811.1">-1</span></code><span class="koboSpan" id="kobo.812.1"> when </span><code class="inlineCode"><span class="koboSpan" id="kobo.813.1">x &lt; y</span></code><span class="koboSpan" id="kobo.814.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.815.1">0</span></code><span class="koboSpan" id="kobo.816.1"> when </span><code class="inlineCode"><span class="koboSpan" id="kobo.817.1">x=y</span></code><span class="koboSpan" id="kobo.818.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.819.1">1</span></code><span class="koboSpan" id="kobo.820.1">, when </span><code class="inlineCode"><span class="koboSpan" id="kobo.821.1">x &gt; y</span></code><span class="koboSpan" id="kobo.822.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.823.1">cmp.Compare(x, y)</span></code><span class="koboSpan" id="kobo.824.1"> returns an </span><code class="inlineCode"><span class="koboSpan" id="kobo.825.1">int</span></code><span class="koboSpan" id="kobo.826.1"> value. </span><span class="koboSpan" id="kobo.826.2">On the other hand, </span><code class="inlineCode"><span class="koboSpan" id="kobo.827.1">cmp.Less(x, y)</span></code><span class="koboSpan" id="kobo.828.1"> returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.829.1">bool</span></code><span class="koboSpan" id="kobo.830.1"> value that is set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.831.1">true</span></code><span class="koboSpan" id="kobo.832.1"> when </span><code class="inlineCode"><span class="koboSpan" id="kobo.833.1">x &lt; y</span></code><span class="koboSpan" id="kobo.834.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.835.1">false</span></code><span class="koboSpan" id="kobo.836.1"> otherwise.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.837.1">Note that in the</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.838.1"> last statement, we are comparing an integer value with a floating point value. </span><span class="koboSpan" id="kobo.838.2">However, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.839.1">cmp</span></code><span class="koboSpan" id="kobo.840.1"> package is clever enough to convert the </span><code class="inlineCode"><span class="koboSpan" id="kobo.841.1">int</span></code><span class="koboSpan" id="kobo.842.1"> value into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.843.1">float64</span></code><span class="koboSpan" id="kobo.844.1"> value and compare the two values!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.845.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.846.1">cmpPackage.go</span></code><span class="koboSpan" id="kobo.847.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.848.1">$ </span></span><span class="koboSpan" id="kobo.849.1">go run cmpPackage.go
1
-1
true
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.850.1">The output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.851.1">cmp.Compare(5, 4)</span></code><span class="koboSpan" id="kobo.852.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.853.1">1</span></code><span class="koboSpan" id="kobo.854.1">, the output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.855.1">cmp.Compare(4, 5)</span></code><span class="koboSpan" id="kobo.856.1"> is -</span><code class="inlineCode"><span class="koboSpan" id="kobo.857.1">1</span></code><span class="koboSpan" id="kobo.858.1">, and the output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.859.1">cmp.Less(4, 5)</span></code><span class="koboSpan" id="kobo.860.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.861.1">true</span></code><span class="koboSpan" id="kobo.862.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-117"><span class="koboSpan" id="kobo.863.1">The slices package</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.864.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.865.1">slices</span></code><span class="koboSpan" id="kobo.866.1"> package </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.867.1">has been part of the standard Go library since Go 1.21 and offers functions for slices of any data type. </span><span class="koboSpan" id="kobo.867.2">Before continuing our discussion of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.868.1">slices</span></code><span class="koboSpan" id="kobo.869.1"> package, let us talk about the </span><em class="italic"><span class="koboSpan" id="kobo.870.1">shallow copy</span></em><span class="koboSpan" id="kobo.871.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.872.1">deep copy</span></em><span class="koboSpan" id="kobo.873.1"> functionality, including their differences.</span></p>
<h2 class="heading-2" id="_idParaDest-118"><span class="koboSpan" id="kobo.874.1">Shallow and deep copies</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.875.1">A </span><em class="italic"><span class="koboSpan" id="kobo.876.1">shallow copy</span></em><span class="koboSpan" id="kobo.877.1"> creates </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.878.1">a new variable and then it assigns to it all the values that are found in the original version of the variable. </span><span class="koboSpan" id="kobo.878.2">If we are talking about a map, then this process assigns all keys and values using ordinary assignment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.879.1">A </span><em class="italic"><span class="koboSpan" id="kobo.880.1">deep copy</span></em><span class="koboSpan" id="kobo.881.1"> first </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.882.1">creates a new variable and then, it inserts all the values that are found in the original variable. </span><span class="koboSpan" id="kobo.882.2">However, each value must be copied recursively—this might not be an issue if we are talking about a string, but it might become an issue if we are talking about a structure, a reference to a structure, or a pointer. </span><span class="koboSpan" id="kobo.882.3">Among other things, this process might create never-ending circles. </span><span class="koboSpan" id="kobo.882.4">The key word here is </span><em class="italic"><span class="koboSpan" id="kobo.883.1">recursively</span></em><span class="koboSpan" id="kobo.884.1">—this means that we need to go through all the values (if we are talking about a slice or a map) or fields (if we are talking about a structure) and find out what needs to be copied, recursively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.885.1">Therefore, the </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.886.1">main difference between a shallow copy and a deep copy is that in the deep copy, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.887.1">the actual values are being copied recursively</span></strong><span class="koboSpan" id="kobo.888.1"> whereas in the shallow copy, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.889.1">we assign the original values using ordinary assignment</span></strong><span class="koboSpan" id="kobo.890.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.891.1">We are now ready to </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.892.1">continue with the presentation of the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.893.1">slices</span></code><span class="koboSpan" id="kobo.894.1"> package. </span><span class="koboSpan" id="kobo.894.2">The first part of the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">main()</span></code><span class="koboSpan" id="kobo.896.1"> in </span><code class="inlineCode"><span class="koboSpan" id="kobo.897.1">slicesPackage.go</span></code><span class="koboSpan" id="kobo.898.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.899.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.900.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.901.1">()</span></span><span class="koboSpan" id="kobo.902.1"> {
    s1 := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.903.1">int</span></span><span class="koboSpan" id="kobo.904.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.905.1">1</span></span><span class="koboSpan" id="kobo.906.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.907.1">2</span></span><span class="koboSpan" id="kobo.908.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.909.1">-1</span></span><span class="koboSpan" id="kobo.910.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.911.1">-2</span></span><span class="koboSpan" id="kobo.912.1">}
    s2 := slices.Clone(s1)
    s3 := slices.Clone(s1[</span><span class="hljs-number"><span class="koboSpan" id="kobo.913.1">2</span></span><span class="koboSpan" id="kobo.914.1">:])
    fmt.Println(s1[</span><span class="hljs-number"><span class="koboSpan" id="kobo.915.1">2</span></span><span class="koboSpan" id="kobo.916.1">], s2[</span><span class="hljs-number"><span class="koboSpan" id="kobo.917.1">2</span></span><span class="koboSpan" id="kobo.918.1">], s3[</span><span class="hljs-number"><span class="koboSpan" id="kobo.919.1">0</span></span><span class="koboSpan" id="kobo.920.1">])
    s1[</span><span class="hljs-number"><span class="koboSpan" id="kobo.921.1">2</span></span><span class="koboSpan" id="kobo.922.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.923.1">0</span></span><span class="koboSpan" id="kobo.924.1">
    s1[</span><span class="hljs-number"><span class="koboSpan" id="kobo.925.1">3</span></span><span class="koboSpan" id="kobo.926.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.927.1">0</span></span><span class="koboSpan" id="kobo.928.1">
    fmt.Println(s1[</span><span class="hljs-number"><span class="koboSpan" id="kobo.929.1">2</span></span><span class="koboSpan" id="kobo.930.1">], s2[</span><span class="hljs-number"><span class="koboSpan" id="kobo.931.1">2</span></span><span class="koboSpan" id="kobo.932.1">], s3[</span><span class="hljs-number"><span class="koboSpan" id="kobo.933.1">0</span></span><span class="koboSpan" id="kobo.934.1">])
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.935.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.936.1">slices.Clone()</span></code><span class="koboSpan" id="kobo.937.1"> function returns a shallow copy of the given slice—the elements are copied using assignment. </span><span class="koboSpan" id="kobo.937.2">After the </span><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">s2 := slices.Clone(s1)</span></code><span class="koboSpan" id="kobo.939.1"> call, </span><code class="inlineCode"><span class="koboSpan" id="kobo.940.1">s1</span></code><span class="koboSpan" id="kobo.941.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.942.1">s2</span></code><span class="koboSpan" id="kobo.943.1"> are equal, yet have separate memory spaces for their elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.944.1">The second part is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.945.1">    s1 = slices.Compact(s1)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.946.1">"s1 (compact):"</span></span><span class="koboSpan" id="kobo.947.1">, s1)
    fmt.Println(slices.Contains(s1, </span><span class="hljs-number"><span class="koboSpan" id="kobo.948.1">2</span></span><span class="koboSpan" id="kobo.949.1">), slices.Contains(s1, </span><span class="hljs-number"><span class="koboSpan" id="kobo.950.1">-2</span></span><span class="koboSpan" id="kobo.951.1">))
    s4 := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.952.1">make</span></span><span class="koboSpan" id="kobo.953.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.954.1">int</span></span><span class="koboSpan" id="kobo.955.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.956.1">10</span></span><span class="koboSpan" id="kobo.957.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.958.1">100</span></span><span class="koboSpan" id="kobo.959.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.960.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.961.1">Len:"</span></span><span class="koboSpan" id="kobo.962.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.963.1">len</span></span><span class="koboSpan" id="kobo.964.1">(s4), </span><span class="hljs-string"><span class="koboSpan" id="kobo.965.1">"Cap:"</span></span><span class="koboSpan" id="kobo.966.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.967.1">cap</span></span><span class="koboSpan" id="kobo.968.1">(s4))
    s4 = slices.Clip(s4)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.969.1">"Len:"</span></span><span class="koboSpan" id="kobo.970.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.971.1">len</span></span><span class="koboSpan" id="kobo.972.1">(s4), </span><span class="hljs-string"><span class="koboSpan" id="kobo.973.1">"Cap:"</span></span><span class="koboSpan" id="kobo.974.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.975.1">cap</span></span><span class="koboSpan" id="kobo.976.1">(s4))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.977.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">slices.Compact()</span></code><span class="koboSpan" id="kobo.979.1"> function replaces consecutive appearances of equal elements with a single copy. </span><span class="koboSpan" id="kobo.979.2">Therefore, </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">-1 -1 -1</span></code><span class="koboSpan" id="kobo.981.1"> is going to become </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">-1</span></code><span class="koboSpan" id="kobo.983.1"> whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.984.1">-1 0 -1</span></code><span class="koboSpan" id="kobo.985.1"> is not going to change. </span><span class="koboSpan" id="kobo.985.2">As a rule of thumb, </span><code class="inlineCode"><span class="koboSpan" id="kobo.986.1">slices.Compact()</span></code><span class="koboSpan" id="kobo.987.1"> works best on sorted slices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.988.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">slices.Contains()</span></code><span class="koboSpan" id="kobo.990.1"> function reports whether a given value is present in a slice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.991.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.992.1">slices.Clip()</span></code><span class="koboSpan" id="kobo.993.1"> function removes unused capacity from a slice. </span><span class="koboSpan" id="kobo.993.2">Put simply, the capacity of the slice becomes equal to the length of the slice. </span><span class="koboSpan" id="kobo.993.3">This can save you lots of memory when the capacity is much larger than the length of a slice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.994.1">The last part comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.995.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.996.1">"Min"</span></span><span class="koboSpan" id="kobo.997.1">, slices.Min(s1), </span><span class="hljs-string"><span class="koboSpan" id="kobo.998.1">"Max:"</span></span><span class="koboSpan" id="kobo.999.1">, slices.Max(s1))
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1000.1">// Replace s2[1] and s2[2]</span></span><span class="koboSpan" id="kobo.1001.1">
    s2 = slices.Replace(s2, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1002.1">1</span></span><span class="koboSpan" id="kobo.1003.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1004.1">3</span></span><span class="koboSpan" id="kobo.1005.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1006.1">100</span></span><span class="koboSpan" id="kobo.1007.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1008.1">200</span></span><span class="koboSpan" id="kobo.1009.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1010.1">"s2 (replaced):"</span></span><span class="koboSpan" id="kobo.1011.1">, s2)
    slices.Sort(s2)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1012.1">"s2 (sorted):"</span></span><span class="koboSpan" id="kobo.1013.1">, s2)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1014.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1015.1">slices.Min()</span></code><span class="koboSpan" id="kobo.1016.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1017.1">slices.Max()</span></code><span class="koboSpan" id="kobo.1018.1"> functions return the minimum and maximum values in a slice, respectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1019.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1020.1">slices.Replace()</span></code><span class="koboSpan" id="kobo.1021.1"> function </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.1022.1">replaces the elements in the given range, which in this case is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1023.1">s2[1:3]</span></code><span class="koboSpan" id="kobo.1024.1">, with the provided values, which in this case are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1025.1">100</span></code><span class="koboSpan" id="kobo.1026.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1027.1">200</span></code><span class="koboSpan" id="kobo.1028.1">, and returns the </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.1029.1">modified slice. </span><span class="koboSpan" id="kobo.1029.2">Last, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1030.1">slices.Sort()</span></code><span class="koboSpan" id="kobo.1031.1"> sorts a slice with values of any ordered type in ascending order.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1032.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1033.1">slicesPackage.go</span></code><span class="koboSpan" id="kobo.1034.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1035.1">$ </span></span><span class="koboSpan" id="kobo.1036.1">go run slicesPackage.go
-1 -1 -1
0 -1 -1
s1 (compact): [1 2 0]
true false
Len: 10 Cap: 100
Len: 10 Cap: 10
Min: 0 Max: 2
s2 (replaced): [1 100 200 -2]
s2 (sorted): [-2 1 100 200]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1037.1">You can see the effect of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1038.1">slices.Clip()</span></code><span class="koboSpan" id="kobo.1039.1"> in the capacity of the slice and the effect of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1040.1">slices.Replace()</span></code><span class="koboSpan" id="kobo.1041.1"> in the values of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1042.1">s2</span></code><span class="koboSpan" id="kobo.1043.1"> slice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1044.1">The next section presents the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1045.1">maps</span></code><span class="koboSpan" id="kobo.1046.1"> package.</span></p>
<h1 class="heading-1" id="_idParaDest-119"><span class="koboSpan" id="kobo.1047.1">The maps package</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1048.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1049.1">maps</span></code><span class="koboSpan" id="kobo.1050.1"> package</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.1051.1"> has been part of the standard Go library since Go 1.21 and offers functions for maps of any type—its use is illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1052.1">mapsPackage.go</span></code><span class="koboSpan" id="kobo.1053.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1054.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1055.1">mapsPackage.go</span></code><span class="koboSpan" id="kobo.1056.1"> program uses two helper functions that are defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1057.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1058.1">delete</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1059.1">(k </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1060.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1061.1">, v </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1062.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1063.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1064.1">bool</span></span><span class="koboSpan" id="kobo.1065.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1066.1">return</span></span><span class="koboSpan" id="kobo.1067.1"> v%</span><span class="hljs-number"><span class="koboSpan" id="kobo.1068.1">2</span></span><span class="koboSpan" id="kobo.1069.1"> != </span><span class="hljs-number"><span class="koboSpan" id="kobo.1070.1">0</span></span><span class="koboSpan" id="kobo.1071.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1072.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1073.1">equal</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1074.1">(v1 </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1075.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1076.1">, v2 </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1077.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1078.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1079.1">bool</span></span><span class="koboSpan" id="kobo.1080.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1081.1">return</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1082.1">float64</span></span><span class="koboSpan" id="kobo.1083.1">(v1) == v2
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1084.1">The</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.1085.1"> purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1086.1">delete()</span></code><span class="koboSpan" id="kobo.1087.1"> function is to define which pairs are going to be deleted from the map—this function is called as a parameter to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1088.1">maps.DeleteFunc()</span></code><span class="koboSpan" id="kobo.1089.1">. </span><span class="koboSpan" id="kobo.1089.2">The current implementation returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1090.1">true</span></code><span class="koboSpan" id="kobo.1091.1"> for all odd values. </span><span class="koboSpan" id="kobo.1091.2">This means that all odd values along with their keys are going to be deleted. </span><span class="koboSpan" id="kobo.1091.3">The first parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1092.1">delete()</span></code><span class="koboSpan" id="kobo.1093.1"> has the data type of the keys of the map whereas the second one has the data type of the values of the map.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1094.1">The purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1095.1">equal()</span></code><span class="koboSpan" id="kobo.1096.1"> function is to define how the equality of the values of the two maps is defined. </span><span class="koboSpan" id="kobo.1096.2">In this case, we want to compare </span><code class="inlineCode"><span class="koboSpan" id="kobo.1097.1">int</span></code><span class="koboSpan" id="kobo.1098.1"> values to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1099.1">float64</span></code><span class="koboSpan" id="kobo.1100.1"> values. </span><span class="koboSpan" id="kobo.1100.2">For this to be legitimate, we need to convert the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1101.1">int</span></code><span class="koboSpan" id="kobo.1102.1"> values to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1103.1">float64</span></code><span class="koboSpan" id="kobo.1104.1"> values, which takes place inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.1105.1">equal()</span></code><span class="koboSpan" id="kobo.1106.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1107.1">Let us now continue with the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1108.1">main()</span></code><span class="koboSpan" id="kobo.1109.1"> function. </span><span class="koboSpan" id="kobo.1109.2">The first part of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1110.1">main()</span></code><span class="koboSpan" id="kobo.1111.1"> function as found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1112.1">mapsPackage.go</span></code><span class="koboSpan" id="kobo.1113.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1114.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1115.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1116.1">()</span></span><span class="koboSpan" id="kobo.1117.1"> {
    m := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1118.1">map</span></span><span class="koboSpan" id="kobo.1119.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1120.1">string</span></span><span class="koboSpan" id="kobo.1121.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1122.1">int</span></span><span class="koboSpan" id="kobo.1123.1">{
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.1124.1">"one"</span></span><span class="koboSpan" id="kobo.1125.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1126.1">1</span></span><span class="koboSpan" id="kobo.1127.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1128.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1129.1">two"</span></span><span class="koboSpan" id="kobo.1130.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1131.1">2</span></span><span class="koboSpan" id="kobo.1132.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.1133.1">"three"</span></span><span class="koboSpan" id="kobo.1134.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1135.1">3</span></span><span class="koboSpan" id="kobo.1136.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1137.1">"four"</span></span><span class="koboSpan" id="kobo.1138.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1139.1">4</span></span><span class="koboSpan" id="kobo.1140.1">,
    }
    maps.DeleteFunc(m, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1141.1">delete</span></span><span class="koboSpan" id="kobo.1142.1">)
    fmt.Println(m)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1143.1">In the previous code, we define a map named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1144.1">m</span></code><span class="koboSpan" id="kobo.1145.1"> and call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1146.1">maps.DeleteFunc()</span></code><span class="koboSpan" id="kobo.1147.1"> in order to delete some of its elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1148.1">The second part is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1149.1">    n := maps.Clone(m)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1150.1">if</span></span><span class="koboSpan" id="kobo.1151.1"> maps.Equal(m, n) {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1152.1">"Equal!"</span></span><span class="koboSpan" id="kobo.1153.1">)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1154.1">else</span></span><span class="koboSpan" id="kobo.1155.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1156.1">"Not equal!"</span></span><span class="koboSpan" id="kobo.1157.1">)
    }
    n[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1158.1">"three"</span></span><span class="koboSpan" id="kobo.1159.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1160.1">3</span></span><span class="koboSpan" id="kobo.1161.1">
    n[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1162.1">"two"</span></span><span class="koboSpan" id="kobo.1163.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1164.1">22</span></span><span class="koboSpan" id="kobo.1165.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1166.1">"Before n:"</span></span><span class="koboSpan" id="kobo.1167.1">, n, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1168.1">"m:"</span></span><span class="koboSpan" id="kobo.1169.1">, m)
    maps.Copy(m, n)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1170.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1171.1">After n:"</span></span><span class="koboSpan" id="kobo.1172.1">, n, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1173.1">"m:"</span></span><span class="koboSpan" id="kobo.1174.1">, m)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1175.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1176.1">maps.Clone()</span></code><span class="koboSpan" id="kobo.1177.1"> function</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.1178.1"> returns a shallow clone of its argument. </span><span class="koboSpan" id="kobo.1178.2">After that, we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1179.1">maps.Equal()</span></code><span class="koboSpan" id="kobo.1180.1"> to make sure that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1181.1">maps.Clone()</span></code><span class="koboSpan" id="kobo.1182.1"> works as expected.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1183.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1184.1">maps.Copy(dst, src)</span></code><span class="koboSpan" id="kobo.1185.1"> function copies all pairs in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1186.1">src</span></code><span class="koboSpan" id="kobo.1187.1"> into </span><code class="inlineCode"><span class="koboSpan" id="kobo.1188.1">dst</span></code><span class="koboSpan" id="kobo.1189.1">. </span><span class="koboSpan" id="kobo.1189.2">When a key in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1190.1">src</span></code><span class="koboSpan" id="kobo.1191.1"> already exists in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1192.1">dst</span></code><span class="koboSpan" id="kobo.1193.1">, then the value in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1194.1">dst</span></code><span class="koboSpan" id="kobo.1195.1"> will be overwritten by the value associated with the respective key in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1196.1">src</span></code><span class="koboSpan" id="kobo.1197.1">. </span><span class="koboSpan" id="kobo.1197.2">In our program, we copy </span><code class="inlineCode"><span class="koboSpan" id="kobo.1198.1">n</span></code><span class="koboSpan" id="kobo.1199.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1200.1">m</span></code><span class="koboSpan" id="kobo.1201.1"> map.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1202.1">The last part is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1203.1">    t := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1204.1">map</span></span><span class="koboSpan" id="kobo.1205.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1206.1">string</span></span><span class="koboSpan" id="kobo.1207.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1208.1">int</span></span><span class="koboSpan" id="kobo.1209.1">{
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.1210.1">"one"</span></span><span class="koboSpan" id="kobo.1211.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1212.1">1</span></span><span class="koboSpan" id="kobo.1213.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1214.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1215.1">two"</span></span><span class="koboSpan" id="kobo.1216.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1217.1">2</span></span><span class="koboSpan" id="kobo.1218.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.1219.1">"three"</span></span><span class="koboSpan" id="kobo.1220.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1221.1">3</span></span><span class="koboSpan" id="kobo.1222.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1223.1">"four"</span></span><span class="koboSpan" id="kobo.1224.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1225.1">4</span></span><span class="koboSpan" id="kobo.1226.1">,
    }
    mFloat := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1227.1">map</span></span><span class="koboSpan" id="kobo.1228.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1229.1">string</span></span><span class="koboSpan" id="kobo.1230.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1231.1">float64</span></span><span class="koboSpan" id="kobo.1232.1">{
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.1233.1">"one"</span></span><span class="koboSpan" id="kobo.1234.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1235.1">1.00</span></span><span class="koboSpan" id="kobo.1236.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1237.1">"two"</span></span><span class="koboSpan" id="kobo.1238.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1239.1">2.00</span></span><span class="koboSpan" id="kobo.1240.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.1241.1">"three"</span></span><span class="koboSpan" id="kobo.1242.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1243.1">3.00</span></span><span class="koboSpan" id="kobo.1244.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1245.1">"four"</span></span><span class="koboSpan" id="kobo.1246.1">: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1247.1">4.00</span></span><span class="koboSpan" id="kobo.1248.1">,
    }
    eq := maps.EqualFunc(t, mFloat, equal)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1249.1">"Is t equal to mFloat?"</span></span><span class="koboSpan" id="kobo.1250.1">, eq)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1251.1">In this last part, we test the operation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1252.1">maps.EqualFunc()</span></code><span class="koboSpan" id="kobo.1253.1"> by creating two maps, one that uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.1254.1">int</span></code><span class="koboSpan" id="kobo.1255.1"> values and the other that uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.1256.1">float64</span></code><span class="koboSpan" id="kobo.1257.1"> values, and comparing them according to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1258.1">equal()</span></code><span class="koboSpan" id="kobo.1259.1"> function that we have created earlier. </span><span class="koboSpan" id="kobo.1259.2">In other words, the purpose of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1260.1">maps.EqualFunc()</span></code><span class="koboSpan" id="kobo.1261.1"> is to find out whether two maps contain the same key and value pairs by comparing them according to their function argument.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1262.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1263.1">mapsPackage.go</span></code><span class="koboSpan" id="kobo.1264.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1265.1">$ </span></span><span class="koboSpan" id="kobo.1266.1">go run mapsPackage.go
map[four:4 two:2]
Equal!
</span><span class="koboSpan" id="kobo.1266.2">Before n: map[four:4 three:3 two:22] m: map[four:4 two:2]
After n: map[four:4 three:3 two:22] m: map[four:4 three:3 two:22]
Is t equal to mFloat? </span><span class="koboSpan" id="kobo.1266.3">true
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1267.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1268.1">maps.DeleteFunc(m, delete)</span></code><span class="koboSpan" id="kobo.1269.1"> statement deletes all key and value pairs where the value is odd</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.1270.1"> leaving </span><code class="inlineCode"><span class="koboSpan" id="kobo.1271.1">m</span></code><span class="koboSpan" id="kobo.1272.1"> with even values only. </span><span class="koboSpan" id="kobo.1272.2">Additionally, the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1273.1">maps.Equal()</span></code><span class="koboSpan" id="kobo.1274.1"> returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1275.1">true</span></code><span class="koboSpan" id="kobo.1276.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1277.1">Equal!</span></code><span class="koboSpan" id="kobo.1278.1"> message is displayed on the screen. </span><span class="koboSpan" id="kobo.1278.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1279.1">maps.Copy(m, n)</span></code><span class="koboSpan" id="kobo.1280.1"> statement changes the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1281.1">m["two"]</span></code><span class="koboSpan" id="kobo.1282.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1283.1">22</span></code><span class="koboSpan" id="kobo.1284.1"> and adds the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1285.1">three</span></code><span class="koboSpan" id="kobo.1286.1"> key to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1287.1">m</span></code><span class="koboSpan" id="kobo.1288.1"> with a value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1289.1">3</span></code><span class="koboSpan" id="kobo.1290.1"> as it was not present in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1291.1">m</span></code><span class="koboSpan" id="kobo.1292.1"> before the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1293.1">maps.Copy()</span></code><span class="koboSpan" id="kobo.1294.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-120"><span class="koboSpan" id="kobo.1295.1">When to use generics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1296.1">Generics is not a panacea</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.1297.1"> and cannot replace good, accurate, and rational program design. </span><span class="koboSpan" id="kobo.1297.2">Therefore, here are some principles and personal suggestions to keep in mind when thinking about using generics to solve a problem:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1298.1">Generics might be used when creating code that needs to work with multiple data types.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1299.1">Generics should be used when an implementation with interfaces and reflection makes the code more complex and more difficult to understand than necessary.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1300.1">Moreover, generics might be used when you expect to support more data types in the future.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1301.1">Once again, the goal of using anything while coding is code simplicity and easier maintenance, not bragging about your coding capabilities.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1302.1">Lastly, generics can be used when the developer is feeling comfortable with generics. </span><span class="koboSpan" id="kobo.1302.2">There is no Go rule that makes the use of generics mandatory.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1303.1">This section concludes this chapter. </span><span class="koboSpan" id="kobo.1303.2">Keep in mind that in order to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1304.1">cmp</span></code><span class="koboSpan" id="kobo.1305.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1306.1">slices</span></code><span class="koboSpan" id="kobo.1307.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1308.1">maps</span></code><span class="koboSpan" id="kobo.1309.1"> packages, you need Go version 1.21 or later.</span></p>
<h1 class="heading-1" id="_idParaDest-121"><span class="koboSpan" id="kobo.1310.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1311.1">This chapter presented generics and gave you the rationale behind the invention of generics. </span><span class="koboSpan" id="kobo.1311.2">Additionally, it presented the Go syntax for generics as well as some issues that might come up if you use generics carelessly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1312.1">While the Go community is still trying to figure out how to use generics, two things are important: first, you do not have to use generics if you do not want to or if you do not feel comfortable with them, and second, when you use generics the right way, you will write less code for supporting multiple data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1313.1">Although a function with generics is more flexible, code with generics usually runs slower than code that works with predefined static data types. </span><span class="koboSpan" id="kobo.1313.2">So, the price you pay for flexibility is execution speed. </span><span class="koboSpan" id="kobo.1313.3">Similarly, Go code with generics has a longer compilation time than equivalent code that does not use generics. </span><span class="koboSpan" id="kobo.1313.4">Once the Go community begins working with generics in real-world scenarios, the cases where generics offer the highest productivity are going to become much more evident. </span><span class="koboSpan" id="kobo.1313.5">At the end of the day, programming is about understanding the cost of your decisions. </span><span class="koboSpan" id="kobo.1313.6">Only then can you consider yourself a programmer. </span><span class="koboSpan" id="kobo.1313.7">So, understanding the cost of using generics instead of interfaces, reflection, or other techniques is important.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1314.1">The next chapter is about type methods, which are functions attached to a data type, reflection, and interfaces. </span><span class="koboSpan" id="kobo.1314.2">All these things will allow us to further improve the statistics application. </span><span class="koboSpan" id="kobo.1314.3">Additionally, the next chapter will compare generics with interfaces and reflection as there is an overlap in their use.</span></p>
<h1 class="heading-1" id="_idParaDest-122"><span class="koboSpan" id="kobo.1315.1">Exercises</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1316.1">Try to solve the following exercises:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1317.1">Create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1318.1">PrintMe()</span></code><span class="koboSpan" id="kobo.1319.1"> method in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1320.1">structures.go</span></code><span class="koboSpan" id="kobo.1321.1"> that prints all the elements of the linked list.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1322.1">Go 1.21 comes with a new function named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1323.1">clear</span></code><span class="koboSpan" id="kobo.1324.1"> that clears maps and slices. </span><span class="koboSpan" id="kobo.1324.2">For maps, it deletes all entries whereas for slices it zeros all existing values. </span><span class="koboSpan" id="kobo.1324.3">Experiment with it to learn how it works.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1325.1">Implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1326.1">delete()</span></code><span class="koboSpan" id="kobo.1327.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1328.1">search()</span></code><span class="koboSpan" id="kobo.1329.1"> functionality using generics for the linked list found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1330.1">structures.go</span></code><span class="koboSpan" id="kobo.1331.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1332.1">Implement a doubly-linked list using generics starting with the code found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1333.1">structures.go</span></code><span class="koboSpan" id="kobo.1334.1">.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-123"><span class="koboSpan" id="kobo.1335.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1336.1">Why Generics? </span><a href="https://blog.golang.org/why-generics"><span class="url"><span class="koboSpan" id="kobo.1337.1">https://blog.golang.org/why-generics</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1338.1">An Introduction to Generics: </span><a href="https://go.dev/blog/intro-generics"><span class="url"><span class="koboSpan" id="kobo.1339.1">https://go.dev/blog/intro-generics</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1340.1">The Next Step for Generics: </span><a href="https://blog.golang.org/generics-next-step"><span class="url"><span class="koboSpan" id="kobo.1341.1">https://blog.golang.org/generics-next-step</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1342.1">A Proposal for Adding Generics to Go: </span><a href="https://blog.golang.org/generics-proposal"><span class="url"><span class="koboSpan" id="kobo.1343.1">https://blog.golang.org/generics-proposal</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1344.1">All your comparable types: </span><a href="https://go.dev/blog/comparable"><span class="url"><span class="koboSpan" id="kobo.1345.1">https://go.dev/blog/comparable</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1346.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1347.1">constraints</span></code><span class="koboSpan" id="kobo.1348.1"> package: </span><a href="https://pkg.go.dev/golang.org/x/exp/constraints"><span class="url"><span class="koboSpan" id="kobo.1349.1">https://pkg.go.dev/golang.org/x/exp/constraints</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1350.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1351.1">cmp</span></code><span class="koboSpan" id="kobo.1352.1"> package: </span><a href="https://pkg.go.dev/cmp"><span class="url"><span class="koboSpan" id="kobo.1353.1">https://pkg.go.dev/cmp</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1354.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1355.1">slices</span></code><span class="koboSpan" id="kobo.1356.1"> package: </span><a href="https://pkg.go.dev/slices"><span class="url"><span class="koboSpan" id="kobo.1357.1">https://pkg.go.dev/slices</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1358.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1359.1">maps</span></code><span class="koboSpan" id="kobo.1360.1"> package: </span><a href="https://pkg.go.dev/maps"><span class="url"><span class="koboSpan" id="kobo.1361.1">https://pkg.go.dev/maps</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1362.1">The official proposal for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1363.1">slices</span></code><span class="koboSpan" id="kobo.1364.1"> package (similar proposals exist for other Go features): </span><a href="https://github.com/golang/go/issues/45955"><span class="url"><span class="koboSpan" id="kobo.1365.1">https://github.com/golang/go/issues/45955</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1366.1">Leave a review!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1367.1">Enjoying this book? </span><span class="koboSpan" id="kobo.1367.2">Help readers like you by leaving an Amazon review. </span><span class="koboSpan" id="kobo.1367.3">Scan the QR code below to get a free eBook of your choice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1368.1"><img alt="" role="presentation" src="../Images/Review_QR_Code.png"/></span></p>
</div>
</body></html>