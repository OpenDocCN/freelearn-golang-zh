["```go\nfunc PrintSlice[T any](s []T) {\n    for _, v := range s {\n        fmt.Println(v)\n    }\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc PrintSlice[T any](s []T) {\n    for _, v := range s {\n        fmt.Print(v, \" \")\n    }\n    fmt.Println()\n} \n```", "```go\nfunc main() {\n    PrintSlice([]int{1, 2, 3})\n    PrintSlice([]string{\"a\", \"b\", \"c\"})\n    PrintSlice([]float64{1.2, -2.33, 4.55})\n} \n```", "```go\n1 2 3\na b c\n1.2 -2.33 4.55 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc Same[T comparable](a, b T) bool {\n    // Or\n// return a == b\nif a == b {\n        return true\n    }\n    return false\n} \n```", "```go\nfunc main() {\n    fmt.Println(\"4 = 3 is\", Same(4,3))\n    fmt.Println(\"aa = aa is\", Same(\"aa\",\"aa\"))\n    fmt.Println(\"4.1 = 4.15 is\", Same(4.1,4.15))\n} \n```", "```go\n4 = 3 is false\naa = aa is true\n4.1 = 4.15 is false \n```", "```go\n# command-line-arguments\n./allowed.go:19:10: []int does not satisfy comparable \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\ntype Numeric interface {\n    int | int8 | int16 | int32 | int64 | float64\n} \n```", "```go\nfunc Add[T Numeric](a, b T) T {\n    return a + b\n} \n```", "```go\nfunc main() {\n    fmt.Println(\"4 + 3 =\", Add(4,3))\n    fmt.Println(\"4.1 + 3.2 =\", Add(4.1,3.2))\n} \n```", "```go\n4 + 3 = 7\n4.1 + 3.2 = 7.3 \n```", "```go\n# command-line-arguments\n./numeric.go:19:15: default type int of 3 does not match inferred type float64 for T \n```", "```go\ntype AnotherInt int\ntype AllInts interface {\n    ~int\n} \n```", "```go\nfunc AddElements[T AllInts](s []T) T {\n    sum := T(0)\n    for _, v := range s {\n        sum = sum + v\n    }\n    return sum\n} \n```", "```go\nfunc main() {\n    s := []AnotherInt{0, 1, 2}\n    fmt.Println(AddElements(s))\n} \n```", "```go\n$ go run supertypes.go\n3 \n```", "```go\nfunc f1[S interface{ ~[]E }, E interface{}](x S) int {\n    return len(x)\n}\nfunc f2[S ~[]E, E interface{}](x S) int {\n    return len(x)\n}\nfunc f3[**S** **~[]****E****,** **E****any**](x S) int {\n    return len(x)\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"errors\"\n)\ntype TreeLast[T any] []T \n```", "```go\nfunc (t TreeLast[T]) replaceLast(element T) (TreeLast[T], error) {\n    if len(t) == 0 {\n        return t, errors.New(\"This is empty!\")\n    }\n\n    t[len(t) - 1] = element\n    return t, nil\n} \n```", "```go\nfunc main() {\n    tempStr := TreeLast[string]{\"aa\", \"bb\"}\n    fmt.Println(tempStr)\n    tempStr.replaceLast(\"cc\")\n    fmt.Println(tempStr) \n```", "```go\n tempInt := TreeLast[int]{12, -3}\n    fmt.Println(tempInt)\n    tempInt.replaceLast(0)\n    fmt.Println(tempInt)\n} \n```", "```go\n[aa bb]\n[aa cc]\n[12 -3]\n[12 0] \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\ntype node[T any] struct {\n    Data T\n    next *node[T]\n} \n```", "```go\ntype list[T any] struct {\n    start *node[T]\n} \n```", "```go\nfunc (l *list[T]) add(data T) {\n    n := node[T]{\n        Data: data,\n        next: nil,\n    } \n```", "```go\n if l.start == nil {\n        l.start = &n\n        return\n    }\n\n    if l.start.next == nil {\n        l.start.next = &n\n        return\n    } \n```", "```go\n temp := l.start\n    l.start = l.start.next\n    l.add(data)\n    l.start = temp\n} \n```", "```go\nfunc main() {\n    var myList list[int] \n```", "```go\n fmt.Println(myList) \n```", "```go\n myList.add(12)\n    myList.add(9)\n    myList.add(3)\n    myList.add(9) \n```", "```go\n // Print all elements\n    cur := myList.start\n    for {\n        fmt.Println(\"*\", cur)\n        if cur == nil {\n            break\n        }\n        cur= cur.next\n    }\n} \n```", "```go\n{<nil>}\n* &{12 0x14000096240}\n* &{9 0x14000096260}\n* &{3 0x14000096290}\n* &{9 <nil>}\n* <nil> \n```", "```go\nfunc main() {\n    fmt.Println(cmp.Compare(5, 4))\n    fmt.Println(cmp.Compare(4, 5))\n    fmt.Println(cmp.Less(4, 5.1))\n} \n```", "```go\n$ go run cmpPackage.go\n1\n-1\ntrue \n```", "```go\nfunc main() {\n    s1 := []int{1, 2, -1, -2}\n    s2 := slices.Clone(s1)\n    s3 := slices.Clone(s1[2:])\n    fmt.Println(s1[2], s2[2], s3[0])\n    s1[2] = 0\n    s1[3] = 0\n    fmt.Println(s1[2], s2[2], s3[0]) \n```", "```go\n s1 = slices.Compact(s1)\n    fmt.Println(\"s1 (compact):\", s1)\n    fmt.Println(slices.Contains(s1, 2), slices.Contains(s1, -2))\n    s4 := make([]int, 10, 100)\n    fmt.Println(\"Len:\", len(s4), \"Cap:\", cap(s4))\n    s4 = slices.Clip(s4)\n    fmt.Println(\"Len:\", len(s4), \"Cap:\", cap(s4)) \n```", "```go\n fmt.Println(\"Min\", slices.Min(s1), \"Max:\", slices.Max(s1))\n    // Replace s2[1] and s2[2]\n    s2 = slices.Replace(s2, 1, 3, 100, 200)\n    fmt.Println(\"s2 (replaced):\", s2)\n    slices.Sort(s2)\n    fmt.Println(\"s2 (sorted):\", s2)\n} \n```", "```go\n$ go run slicesPackage.go\n-1 -1 -1\n0 -1 -1\ns1 (compact): [1 2 0]\ntrue false\nLen: 10 Cap: 100\nLen: 10 Cap: 10\nMin: 0 Max: 2\ns2 (replaced): [1 100 200 -2]\ns2 (sorted): [-2 1 100 200] \n```", "```go\nfunc delete(k string, v int) bool {\n    return v%2 != 0\n}\nfunc equal(v1 int, v2 float64) bool {\n    return float64(v1) == v2\n} \n```", "```go\nfunc main() {\n    m := map[string]int{\n        \"one\": 1, \"two\": 2,\n        \"three\": 3, \"four\": 4,\n    }\n    maps.DeleteFunc(m, delete)\n    fmt.Println(m) \n```", "```go\n n := maps.Clone(m)\n    if maps.Equal(m, n) {\n        fmt.Println(\"Equal!\")\n    } else {\n        fmt.Println(\"Not equal!\")\n    }\n    n[\"three\"] = 3\n    n[\"two\"] = 22\n    fmt.Println(\"Before n:\", n, \"m:\", m)\n    maps.Copy(m, n)\n    fmt.Println(\"After n:\", n, \"m:\", m) \n```", "```go\n t := map[string]int{\n        \"one\": 1, \"two\": 2,\n        \"three\": 3, \"four\": 4,\n    }\n    mFloat := map[string]float64{\n        \"one\": 1.00, \"two\": 2.00,\n        \"three\": 3.00, \"four\": 4.00,\n    }\n    eq := maps.EqualFunc(t, mFloat, equal)\n    fmt.Println(\"Is t equal to mFloat?\", eq)\n} \n```", "```go\n$ go run mapsPackage.go\nmap[four:4 two:2]\nEqual!\nBefore n: map[four:4 three:3 two:22] m: map[four:4 two:2]\nAfter n: map[four:4 three:3 two:22] m: map[four:4 three:3 two:22]\nIs t equal to mFloat? true \n```"]