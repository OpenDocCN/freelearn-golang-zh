- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about generics and how to use the new syntax to write generic
    functions and define generic data types. Generic programming is a programming
    paradigm that allows the developer to implement a function using one or more data
    types that are going to be provided at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: The Go generics support came with Go 1.18, which was officially released in
    February 2022\. As a result, Go generics is now old news! Nevertheless, the Go
    community is still trying to make sense and good use of generics. In fact, most
    Go developers are already doing their job without the help of generics.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel that this chapter does not interest you at this point of your learning
    journey, feel free to skip it and come back at a later stage. However, I suggest
    that you read it even though it might not interest you right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the following fact: **you do not have to use Go generics
    if you do not want to, have doubts about the usefulness of generics, or have a
    different approach in mind**. After all, you can still write wonderful, efficient,
    maintainable, and correct software in Go without using generics! Additionally,
    the fact that you can use generics and support lots of data types, if not all
    available data types, does not mean that you should do that. Always support the
    required data types, no more, no less, but do not forget to keep an eye on the
    future of your data and the possibility of supporting data types that were not
    known at the time of writing your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining new data types with generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmp` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `slices` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `maps` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics is a feature that allows you the capability of not precisely specifying
    the data type of **one or more function parameters**, mainly because you want
    to make your functions as universal as possible. In other words, generics allow
    functions to process several data types without the need to write any special
    code, as is the case with the empty interface and interfaces in general. Interfaces
    are covered in *Chapter 5*, *Reflection and Interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: When working with interfaces in Go, you must write extra code to determine the
    data type of the interface variable you are working with, which is not the case
    with generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me begin by presenting a small code example that implements a function
    that clearly shows a case where generics can be handy and save you from having
    to write lots of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, what do we have here? There is a function named `PrintSlice()` that accepts
    a slice of any data type. This is denoted by the use of `[]T` in the function
    signature, which specifies that the function accepts a slice, in combination with
    the `[T any]` part that specifies that all data types are accepted and therefore
    supported. The `[T any]` part tells the compiler that the data type `T` is not
    going to be determined at execution time but it is still going to be determined
    and enforced at compile time based on the type provided by the calling code. We
    are also free to use multiple (generics) data types using the `[T, U, W any]`
    notation—after which we should use the `T`, `U`, and `W` data types in the function
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: The `any` keyword tells the compiler that there are no constraints about the
    data type of `T`. We are going to discuss constraints in a bit—for now, we will
    just learn about the syntax of generics.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine writing separate functions to implement the functionality of `PrintSlice()`
    for slices of integers, strings, floating-point numbers, complex values, and so
    on. So, we have found a profound case where using generics simplifies the code
    and our programming efforts. However, not all cases are so obvious, and we should
    be very careful about overusing `any`.
  prefs: []
  type: TYPE_NORMAL
- en: Hello, generics!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following (`hw.go`) is a piece of code that uses generics, to help you
    understand more about them before going into more advanced examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`PrintSlice()` is similar to the function that we saw earlier in this chapter.
    `PrintSlice()` prints the elements of each slice in the same line and prints a
    new line at the end with the help of `fmt.Println()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we call the same `PrintSlice()` with three different data types: `int`,
    `string`, and `float64`. The Go compiler is not going to complain about that.
    Instead, it is going to execute the code as if we had three separate functions,
    one for each data type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, running `hw.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, each slice is printed as expected using a single generic function.
  prefs: []
  type: TYPE_NORMAL
- en: With that information in mind, let us begin by discussing generics and constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us say that you have a function that works with generics that multiplies
    two numeric values. Should this function work with all data types? Can this function
    work with all data types? **Can you multiply two strings or two structures?**
    The solution for avoiding that kind of issue is the use of constraints. *Type
    constraints* allow you to specify the list of data types that you want to work
    with in order to avoid logical errors and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Forget about multiplication for a while and think about something simpler. Let
    us say that we want to compare variables for equality—is there a way to tell Go
    that we only want to work with values that can be compared? Go 1.18 came with
    predefined type constraints—one of them is called `comparable` and includes data
    types that can be compared for equality or inequality.
  prefs: []
  type: TYPE_NORMAL
- en: For more predefined constraints, you should look at the `constraints` package
    ([https://pkg.go.dev/golang.org/x/exp/constraints](https://pkg.go.dev/golang.org/x/exp/constraints)).
  prefs: []
  type: TYPE_NORMAL
- en: The code of `allowed.go` illustrates the use of the `comparable` constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Same()` function uses the predefined `comparable` constraint instead of
    `any`. In reality, the `comparable` constraint is just a predefined interface
    that includes all data types that can be compared with `==` or `!=`.
  prefs: []
  type: TYPE_NORMAL
- en: We do not have to write any extra code for checking our input as the function
    signature makes sure that we are going to deal with acceptable and functional
    data types only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `main()` function calls `Same()` three times, using different data types,
    and prints its results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `allowed.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As only `Same("aa","aa")` is `true`, we get the respective output.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to run a statement like `Same([]int{1,2},[]int{1,3})`, which tries
    to compare two slices, the compiler is going to generate the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This happens because we cannot directly compare two slices—this kind of functionality
    should be implemented manually. Note that you are allowed to compare two arrays!
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection shows how to create your own constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Creating constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection presents an example where we define the data types that are
    allowed to be passed as parameters to a generic function using an interface. The
    code of `numeric.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a new interface called `Numeric`, which specifies the list of
    supported data types. You can use any data type you want as long as it can be
    used with the generic function that you are going to implement. In this case,
    we could have added `string` or `uint` to the list of supported data types, if
    that makes sense. In this case, adding `string` to the `Numeric` interface does
    not make any sense.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the definition of the generic function with two generic parameters that
    use the `Numeric` constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is the implementation of the `main()` function with the calls
    to `Add()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `numeric.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Nevertheless, the Go rules still apply. Therefore, if you try to call `Add(4.1,3)`,
    you are going to get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this error is that the `Add()` function expects two parameters
    of the same data type. However, `4.1` is a `float64` whereas `3` is an `int`,
    so not the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: There is an additional issue with constraints that we have not discussed so
    far. As we already know, **Go treats different data types differently even if
    the underlying data type is the same**. This means that if we create a new data
    type that is based on `int` (`type aType int`), it is not going to be supported
    by the `Numeric` constraint as this is not specified. The next subsection shows
    us how to deal with it and overcome that limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting underlying data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With supertypes, we are adding support for the underlying data type—the real
    one—and not the data type at hand, which might be an alias for an existing Go
    data type. Supertypes are supported by the `~` operator. The use of supertypes
    is illustrated in `supertypes.go`. The first part of the code in `supertypes.go`
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we define a constraint named `AllInts` that uses a supertype
    (`~int`) as well as a new data type that is named `AnotherInt` and is in reality
    `int`. The definition of the `AllInts` constraint allows `AnotherInt` to be supported
    by `AllInts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `supertypes.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this part, we have defined a generic function. The function comes with a
    constraint as it supports slices of `AllInts` only.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `supertypes.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this last part, we call `AddElements()` using a slice of `AnotherInt` as
    its parameter—this capability is offered by the use of the supertype in the `AllInts`
    constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `supertypes.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, **the use of supertypes in type constraints allows Go to deal with the actual
    underlying data type**.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting slices of any type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, we are going to specify that a function parameter can only
    be a slice of any data type. The relevant code in `sliceConstraint.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All three generic functions are equivalent. The use of `~[]E` specifies that
    the underlying data type should be a slice even if it is a type by a different
    name.
  prefs: []
  type: TYPE_NORMAL
- en: The `f1()` function is the long version of the function signature. `interface{
    ~[]E }` specifies that we only want to work with slices of any data type (`E interface{}`).
    The `f2()` function replaces `interface{ ~[]E }` with just `~[]E` because Go allows
    you to omit the enclosing `interface{}` for interfaces in the constraint position.
    Last, the `f3()` function replaces the commonly used `interface{}` with its predefined
    equivalent `any`, which we have already seen in action. I find the implementation
    of `f3()` much simpler and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows us how to use generics when defining new data types.
  prefs: []
  type: TYPE_NORMAL
- en: Defining new data types with generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to create a new data type with the use of generics,
    which is presented in `newDT.go`. The code of `newDT.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous statement declares a new data type named `TreeLast` that uses generics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`replaceLast()` is a method that operates on `TreeLast` variables. Apart from
    the function signature, there is nothing else that shows the use of generics.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this first part of `main()`, we create a `TreeLast` variable with the `aa`
    and `bb` string values and then we replace the `bb` value with `cc`, using a call
    to `replaceLast("cc")`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The second part of `main()` does a similar thing to the first part using a `TreeLast`
    variable populated with `int` values. So, `TreeLast` works with both `string`
    and `int` values without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `newDT.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of the output are related to the `TreeLast[string]` variable
    whereas the last two lines of the output are related to the `TreeLast[int]` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection is about using generics in Go structures.
  prefs: []
  type: TYPE_NORMAL
- en: Using generics in Go structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to implement a linked list that works with generics—this
    is one of the cases where the use of generics simplifies things because it allows
    you to implement the linked list once while being able to work with multiple data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `structures.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The node structure uses generics in order to support nodes that can store all
    kinds of data. This does not mean that the next field of a node can point to another
    node with a `Data` field with a different data type. The rule that a linked list
    contains elements of the same data type still applies—it just means that if you
    want to create three linked lists, one for storing `string` values, one for storing
    `int` values, and a third one for storing JSON records of a given `struct` data
    type, you do not need to write any extra code to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is the definition of the root node of a linked list of `node` nodes. Both
    `list` and `node` must share the same data type, `T`. However, as stated before,
    this does not prevent you from creating multiple linked lists of various data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: You can still replace `any` with a constraint in both the definition of `node`
    and `list` if you want to restrict the list of allowed data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `add()` function is generic in order to be able to work with all kinds of
    nodes. Apart from the signature of `add()`, the remaining code is not associated
    with the use of generics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These two `if` blocks have to do with the addition of a new node to the linked
    list. The first `if` block is when the list is empty whereas the second `if` block
    is when we are dealing with the last node of the current list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The last part of `add()` has to do with defining the proper associations between
    nodes when adding a new node to the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a linked list of int values in `main()`, which is the linked
    list that we are going to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The initial value of `myList` is `nil`, as the list is empty and does not contain
    any nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this first part, we add four elements to the linked list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The last part of `main()` is about printing all the elements of the list by
    traversing it with the help of the `next` field, which points to the next node
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `structures.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let us discuss the output a little more. The first line shows that the value
    of the empty list is `nil`. The first node of the list holds a value of `12` and
    a memory address (`0x14000096240`) that points to the second node. This goes on
    until we reach the last node, which holds the value of `9`, which appears twice
    in this linked list, and points to `nil`, because it is the last node. Therefore,
    the use of generics makes the linked list able to work with multiple data types.
  prefs: []
  type: TYPE_NORMAL
- en: The next three sections present three packages that use generics—feel free to
    look into their implementations for details (see the *Additional resources* section).
  prefs: []
  type: TYPE_NORMAL
- en: The cmp package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cmp` package, which became part of the standard Go library in Go 1.21,
    contains types and functions for comparing ordered values. The reason for presenting
    it before the `slices` and `maps` packages is that it is used by the other two.
    Keep in mind that in its current version, the `cmp` package is simplistic but
    it might get enriched in the future with more functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the `cmp`, `slices`, and `maps` packages use generics and constraints,
    which is the main reason for presenting them in this chapter. So, generics can
    be used for creating packages that work with multiple data types.
  prefs: []
  type: TYPE_NORMAL
- en: The important code of `cmpPackage.go` can be found in the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, `cmp.Compare(x, y)` compares two values and returns `-1` when `x < y`,
    `0` when `x=y`, and `1`, when `x > y`. `cmp.Compare(x, y)` returns an `int` value.
    On the other hand, `cmp.Less(x, y)` returns a `bool` value that is set to `true`
    when `x < y` and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the last statement, we are comparing an integer value with a floating
    point value. However, the `cmp` package is clever enough to convert the `int`
    value into a `float64` value and compare the two values!
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `cmpPackage.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The output of `cmp.Compare(5, 4)` is `1`, the output of `cmp.Compare(4, 5)`
    is -`1`, and the output of `cmp.Less(4, 5)` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The slices package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `slices` package has been part of the standard Go library since Go 1.21
    and offers functions for slices of any data type. Before continuing our discussion
    of the `slices` package, let us talk about the *shallow copy* and *deep copy*
    functionality, including their differences.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow and deep copies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *shallow copy* creates a new variable and then it assigns to it all the values
    that are found in the original version of the variable. If we are talking about
    a map, then this process assigns all keys and values using ordinary assignment.
  prefs: []
  type: TYPE_NORMAL
- en: A *deep copy* first creates a new variable and then, it inserts all the values
    that are found in the original variable. However, each value must be copied recursively—this
    might not be an issue if we are talking about a string, but it might become an
    issue if we are talking about a structure, a reference to a structure, or a pointer.
    Among other things, this process might create never-ending circles. The key word
    here is *recursively*—this means that we need to go through all the values (if
    we are talking about a slice or a map) or fields (if we are talking about a structure)
    and find out what needs to be copied, recursively.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the main difference between a shallow copy and a deep copy is that
    in the deep copy, **the actual values are being copied recursively** whereas in
    the shallow copy, **we assign the original values using ordinary assignment**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to continue with the presentation of the functionality of
    the `slices` package. The first part of the implementation of `main()` in `slicesPackage.go`
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `slices.Clone()` function returns a shallow copy of the given slice—the
    elements are copied using assignment. After the `s2 := slices.Clone(s1)` call,
    `s1` and `s2` are equal, yet have separate memory spaces for their elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `slices.Compact()` function replaces consecutive appearances of equal elements
    with a single copy. Therefore, `-1 -1 -1` is going to become `-1` whereas `-1
    0 -1` is not going to change. As a rule of thumb, `slices.Compact()` works best
    on sorted slices.
  prefs: []
  type: TYPE_NORMAL
- en: The `slices.Contains()` function reports whether a given value is present in
    a slice.
  prefs: []
  type: TYPE_NORMAL
- en: The `slices.Clip()` function removes unused capacity from a slice. Put simply,
    the capacity of the slice becomes equal to the length of the slice. This can save
    you lots of memory when the capacity is much larger than the length of a slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part comes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `slices.Min()` and `slices.Max()` functions return the minimum and maximum
    values in a slice, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `slices.Replace()` function replaces the elements in the given range, which
    in this case is `s2[1:3]`, with the provided values, which in this case are `100`
    and `200`, and returns the modified slice. Last, `slices.Sort()` sorts a slice
    with values of any ordered type in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `slicesPackage.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can see the effect of `slices.Clip()` in the capacity of the slice and the
    effect of `slices.Replace()` in the values of the `s2` slice.
  prefs: []
  type: TYPE_NORMAL
- en: The next section presents the `maps` package.
  prefs: []
  type: TYPE_NORMAL
- en: The maps package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `maps` package has been part of the standard Go library since Go 1.21 and
    offers functions for maps of any type—its use is illustrated in `mapsPackage.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mapsPackage.go` program uses two helper functions that are defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the `delete()` function is to define which pairs are going to
    be deleted from the map—this function is called as a parameter to `maps.DeleteFunc()`.
    The current implementation returns `true` for all odd values. This means that
    all odd values along with their keys are going to be deleted. The first parameter
    of `delete()` has the data type of the keys of the map whereas the second one
    has the data type of the values of the map.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the `equal()` function is to define how the equality of the values
    of the two maps is defined. In this case, we want to compare `int` values to `float64`
    values. For this to be legitimate, we need to convert the `int` values to `float64`
    values, which takes place inside `equal()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now continue with the implementation of the `main()` function. The first
    part of the `main()` function as found in `mapsPackage.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we define a map named `m` and call `maps.DeleteFunc()`
    in order to delete some of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `maps.Clone()` function returns a shallow clone of its argument. After that,
    we call `maps.Equal()` to make sure that `maps.Clone()` works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The `maps.Copy(dst, src)` function copies all pairs in `src` into `dst`. When
    a key in `src` already exists in `dst`, then the value in `dst` will be overwritten
    by the value associated with the respective key in `src`. In our program, we copy
    `n` to the `m` map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this last part, we test the operation of `maps.EqualFunc()` by creating two
    maps, one that uses `int` values and the other that uses `float64` values, and
    comparing them according to the `equal()` function that we have created earlier.
    In other words, the purpose of `maps.EqualFunc()` is to find out whether two maps
    contain the same key and value pairs by comparing them according to their function
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `mapsPackage.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `maps.DeleteFunc(m, delete)` statement deletes all key and value pairs where
    the value is odd leaving `m` with even values only. Additionally, the call to
    `maps.Equal()` returns `true` and the `Equal!` message is displayed on the screen.
    The `maps.Copy(m, n)` statement changes the value of `m["two"]` to `22` and adds
    the `three` key to `m` with a value of `3` as it was not present in `m` before
    the call to `maps.Copy()`.
  prefs: []
  type: TYPE_NORMAL
- en: When to use generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generics is not a panacea and cannot replace good, accurate, and rational program
    design. Therefore, here are some principles and personal suggestions to keep in
    mind when thinking about using generics to solve a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Generics might be used when creating code that needs to work with multiple data
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics should be used when an implementation with interfaces and reflection
    makes the code more complex and more difficult to understand than necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, generics might be used when you expect to support more data types
    in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, the goal of using anything while coding is code simplicity and easier
    maintenance, not bragging about your coding capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, generics can be used when the developer is feeling comfortable with
    generics. There is no Go rule that makes the use of generics mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section concludes this chapter. Keep in mind that in order to use the `cmp`,
    `slices`, and `maps` packages, you need Go version 1.21 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented generics and gave you the rationale behind the invention
    of generics. Additionally, it presented the Go syntax for generics as well as
    some issues that might come up if you use generics carelessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the Go community is still trying to figure out how to use generics, two
    things are important: first, you do not have to use generics if you do not want
    to or if you do not feel comfortable with them, and second, when you use generics
    the right way, you will write less code for supporting multiple data types.'
  prefs: []
  type: TYPE_NORMAL
- en: Although a function with generics is more flexible, code with generics usually
    runs slower than code that works with predefined static data types. So, the price
    you pay for flexibility is execution speed. Similarly, Go code with generics has
    a longer compilation time than equivalent code that does not use generics. Once
    the Go community begins working with generics in real-world scenarios, the cases
    where generics offer the highest productivity are going to become much more evident.
    At the end of the day, programming is about understanding the cost of your decisions.
    Only then can you consider yourself a programmer. So, understanding the cost of
    using generics instead of interfaces, reflection, or other techniques is important.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about type methods, which are functions attached to a data
    type, reflection, and interfaces. All these things will allow us to further improve
    the statistics application. Additionally, the next chapter will compare generics
    with interfaces and reflection as there is an overlap in their use.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to solve the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `PrintMe()` method in `structures.go` that prints all the elements
    of the linked list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go 1.21 comes with a new function named `clear` that clears maps and slices.
    For maps, it deletes all entries whereas for slices it zeros all existing values.
    Experiment with it to learn how it works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `delete()` and `search()` functionality using generics for the
    linked list found in `structures.go`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a doubly-linked list using generics starting with the code found in
    `structures.go`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why Generics? [https://blog.golang.org/why-generics](https://blog.golang.org/why-generics)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An Introduction to Generics: [https://go.dev/blog/intro-generics](https://go.dev/blog/intro-generics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Next Step for Generics: [https://blog.golang.org/generics-next-step](https://blog.golang.org/generics-next-step)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Proposal for Adding Generics to Go: [https://blog.golang.org/generics-proposal](https://blog.golang.org/generics-proposal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All your comparable types: [https://go.dev/blog/comparable](https://go.dev/blog/comparable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `constraints` package: [https://pkg.go.dev/golang.org/x/exp/constraints](https://pkg.go.dev/golang.org/x/exp/constraints)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `cmp` package: [https://pkg.go.dev/cmp](https://pkg.go.dev/cmp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `slices` package: [https://pkg.go.dev/slices](https://pkg.go.dev/slices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `maps` package: [https://pkg.go.dev/maps](https://pkg.go.dev/maps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official proposal for the `slices` package (similar proposals exist for
    other Go features): [https://github.com/golang/go/issues/45955](https://github.com/golang/go/issues/45955)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Review_QR_Code.png)'
  prefs: []
  type: TYPE_IMG
