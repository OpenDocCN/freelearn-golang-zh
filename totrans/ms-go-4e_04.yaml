- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Go Generics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go泛型
- en: This chapter is about generics and how to use the new syntax to write generic
    functions and define generic data types. Generic programming is a programming
    paradigm that allows the developer to implement a function using one or more data
    types that are going to be provided at a later time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍泛型以及如何使用新的语法来编写泛型函数和定义泛型数据类型。泛型编程是一种编程范式，它允许开发者使用一个或多个将在以后提供的数据类型来实现函数。
- en: The Go generics support came with Go 1.18, which was officially released in
    February 2022\. As a result, Go generics is now old news! Nevertheless, the Go
    community is still trying to make sense and good use of generics. In fact, most
    Go developers are already doing their job without the help of generics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go的泛型支持是在Go 1.18中引入的，该版本于2022年2月正式发布。因此，Go的泛型现在已经不再是新闻了！尽管如此，Go社区仍在努力理解并充分利用泛型。事实上，大多数Go开发者已经在没有泛型帮助的情况下完成了他们的工作。
- en: If you feel that this chapter does not interest you at this point of your learning
    journey, feel free to skip it and come back at a later stage. However, I suggest
    that you read it even though it might not interest you right now.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得在这一学习旅程的这个阶段你对这一章不感兴趣，你可以自由地跳过它，稍后再回来。然而，即使你现在可能不感兴趣，我仍然建议你阅读它。
- en: 'This brings us to the following fact: **you do not have to use Go generics
    if you do not want to, have doubts about the usefulness of generics, or have a
    different approach in mind**. After all, you can still write wonderful, efficient,
    maintainable, and correct software in Go without using generics! Additionally,
    the fact that you can use generics and support lots of data types, if not all
    available data types, does not mean that you should do that. Always support the
    required data types, no more, no less, but do not forget to keep an eye on the
    future of your data and the possibility of supporting data types that were not
    known at the time of writing your code.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了以下事实：**如果你不想使用Go泛型，对泛型的有用性有疑问，或者有其他的想法，你不必使用Go泛型**。毕竟，你仍然可以在不使用泛型的情况下编写出色、高效、可维护和正确的软件！此外，你可以使用泛型并支持大量数据类型，如果不是所有可用的数据类型，这并不意味着你应该这样做。始终支持所需的数据类型，不多也不少，但不要忘记关注你数据未来的发展以及支持在编写代码时未知的数据类型的可能性。
- en: 'This chapter covers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: An introduction to generics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型简介
- en: Constraints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束
- en: Defining new data types with generics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型定义新数据类型
- en: When to use generics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用泛型
- en: The `cmp` package
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmp`包'
- en: The `slices` package
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slices`包'
- en: The `maps` package
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maps`包'
- en: An introduction to generics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型简介
- en: Generics is a feature that allows you the capability of not precisely specifying
    the data type of **one or more function parameters**, mainly because you want
    to make your functions as universal as possible. In other words, generics allow
    functions to process several data types without the need to write any special
    code, as is the case with the empty interface and interfaces in general. Interfaces
    are covered in *Chapter 5*, *Reflection and Interfaces*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一种功能，它允许你不必精确指定一个或多个函数参数的数据类型，主要是因为你希望使你的函数尽可能通用。换句话说，泛型允许函数处理多种数据类型，而无需编写任何特殊代码，就像空接口和一般接口的情况一样。接口在*第5章*，*反射与接口*中有详细说明。
- en: When working with interfaces in Go, you must write extra code to determine the
    data type of the interface variable you are working with, which is not the case
    with generics.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中使用接口时，你必须编写额外的代码来确定你正在处理的接口变量的数据类型，而泛型则不需要这样做。
- en: 'Let me begin by presenting a small code example that implements a function
    that clearly shows a case where generics can be handy and save you from having
    to write lots of code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从展示一个小型代码示例开始，该示例实现了一个函数，清楚地展示了泛型可以派上用场并帮助你避免编写大量代码的情况：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, what do we have here? There is a function named `PrintSlice()` that accepts
    a slice of any data type. This is denoted by the use of `[]T` in the function
    signature, which specifies that the function accepts a slice, in combination with
    the `[T any]` part that specifies that all data types are accepted and therefore
    supported. The `[T any]` part tells the compiler that the data type `T` is not
    going to be determined at execution time but it is still going to be determined
    and enforced at compile time based on the type provided by the calling code. We
    are also free to use multiple (generics) data types using the `[T, U, W any]`
    notation—after which we should use the `T`, `U`, and `W` data types in the function
    signature.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里有什么呢？有一个名为`PrintSlice()`的函数，它接受任何数据类型的切片。这通过函数签名中使用`[]T`来表示，它指定了该函数接受一个切片，并结合`[T
    any]`部分指定所有数据类型都被接受并支持。`[T any]`部分告诉编译器数据类型`T`在执行时不会被确定，但它在编译时仍然会根据调用代码提供的类型来确定和强制执行。我们还可以使用多个（泛型）数据类型，使用`[T,
    U, W any]`表示法——之后我们应该在函数签名中使用`T`、`U`和`W`数据类型。
- en: The `any` keyword tells the compiler that there are no constraints about the
    data type of `T`. We are going to discuss constraints in a bit—for now, we will
    just learn about the syntax of generics.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`关键字告诉编译器关于`T`的数据类型没有任何约束。我们将在稍后讨论约束——现在，我们只学习泛型的语法。'
- en: Now, imagine writing separate functions to implement the functionality of `PrintSlice()`
    for slices of integers, strings, floating-point numbers, complex values, and so
    on. So, we have found a profound case where using generics simplifies the code
    and our programming efforts. However, not all cases are so obvious, and we should
    be very careful about overusing `any`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下为整数切片、字符串切片、浮点数切片、复数值切片等实现`PrintSlice()`功能的功能分别编写单独的函数。因此，我们发现了一个深刻的案例，使用泛型简化了代码和我们的编程工作。然而，并非所有情况都如此明显，我们应该非常小心地避免过度使用`any`。
- en: Hello, generics!
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嗨，泛型！
- en: 'The following (`hw.go`) is a piece of code that uses generics, to help you
    understand more about them before going into more advanced examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下（`hw.go`）是一段使用泛型的代码，它可以帮助你在深入了解更高级的示例之前更好地理解它们：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`PrintSlice()` is similar to the function that we saw earlier in this chapter.
    `PrintSlice()` prints the elements of each slice in the same line and prints a
    new line at the end with the help of `fmt.Println()`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintSlice()`与我们在本章前面看到的函数类似。`PrintSlice()`在同一行中打印每个切片的元素，并在`fmt.Println()`的帮助下在末尾打印一个新行。'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we call the same `PrintSlice()` with three different data types: `int`,
    `string`, and `float64`. The Go compiler is not going to complain about that.
    Instead, it is going to execute the code as if we had three separate functions,
    one for each data type.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用相同的`PrintSlice()`函数，但传入三种不同的数据类型：`int`、`string`和`float64`。Go 编译器不会对此提出异议。相反，它将像我们分别为每种数据类型编写了三个单独的函数一样执行代码。
- en: 'Therefore, running `hw.go` produces the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行`hw.go`会产生以下输出：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, each slice is printed as expected using a single generic function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个切片都使用单个泛型函数按预期打印。
- en: With that information in mind, let us begin by discussing generics and constraints.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，让我们首先讨论泛型和约束。
- en: Constraints
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束
- en: Let us say that you have a function that works with generics that multiplies
    two numeric values. Should this function work with all data types? Can this function
    work with all data types? **Can you multiply two strings or two structures?**
    The solution for avoiding that kind of issue is the use of constraints. *Type
    constraints* allow you to specify the list of data types that you want to work
    with in order to avoid logical errors and bugs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个使用泛型乘以两个数值的函数。这个函数应该与所有数据类型一起工作吗？这个函数可以与所有数据类型一起工作吗？**你能乘以两个字符串或两个结构体吗？**避免这种问题的解决方案是使用约束。*类型约束*允许你指定你想要与之一起工作的数据类型列表，以避免逻辑错误和错误。
- en: Forget about multiplication for a while and think about something simpler. Let
    us say that we want to compare variables for equality—is there a way to tell Go
    that we only want to work with values that can be compared? Go 1.18 came with
    predefined type constraints—one of them is called `comparable` and includes data
    types that can be compared for equality or inequality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时忘记乘法，考虑一些更简单的事情。假设我们想要比较变量以检查它们是否相等——有没有办法告诉Go我们只想与可以比较的值一起工作？Go 1.18带来了预定义的类型约束——其中之一被称为`comparable`，包括可以比较相等或不等的数据类型。
- en: For more predefined constraints, you should look at the `constraints` package
    ([https://pkg.go.dev/golang.org/x/exp/constraints](https://pkg.go.dev/golang.org/x/exp/constraints)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多预定义的约束，你应该查看 `constraints` 包（[https://pkg.go.dev/golang.org/x/exp/constraints](https://pkg.go.dev/golang.org/x/exp/constraints)）。
- en: The code of `allowed.go` illustrates the use of the `comparable` constraint.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowed.go` 的代码展示了 `comparable` 约束的使用。'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Same()` function uses the predefined `comparable` constraint instead of
    `any`. In reality, the `comparable` constraint is just a predefined interface
    that includes all data types that can be compared with `==` or `!=`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Same()` 函数使用预定义的 `comparable` 约束而不是 `any`。实际上，`comparable` 约束只是一个预定义的接口，它包括所有可以用
    `==` 或 `!=` 比较的数据类型。'
- en: We do not have to write any extra code for checking our input as the function
    signature makes sure that we are going to deal with acceptable and functional
    data types only.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要编写任何额外的代码来检查我们的输入，因为函数签名确保我们只会处理可接受和功能性的数据类型。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `main()` function calls `Same()` three times, using different data types,
    and prints its results.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数三次调用 `Same()`，使用不同的数据类型，并打印其结果。'
- en: 'Running `allowed.go` produces the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `allowed.go` 产生以下输出：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As only `Same("aa","aa")` is `true`, we get the respective output.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有 `Same("aa","aa")` 是 `true`，我们得到相应的输出。
- en: 'If you try to run a statement like `Same([]int{1,2},[]int{1,3})`, which tries
    to compare two slices, the compiler is going to generate the following error message:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行一个类似于 `Same([]int{1,2},[]int{1,3})` 的语句，该语句尝试比较两个切片，编译器将生成以下错误信息：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This happens because we cannot directly compare two slices—this kind of functionality
    should be implemented manually. Note that you are allowed to compare two arrays!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们无法直接比较两个切片——这种功能应该手动实现。请注意，你可以比较两个数组！
- en: The next subsection shows how to create your own constraints.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将展示如何创建你自己的约束。
- en: Creating constraints
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建约束
- en: 'This subsection presents an example where we define the data types that are
    allowed to be passed as parameters to a generic function using an interface. The
    code of `numeric.go` is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节提供了一个示例，其中我们定义了可以使用接口作为泛型函数参数传递的数据类型。`numeric.go` 的代码如下：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we define a new interface called `Numeric`, which specifies the list of
    supported data types. You can use any data type you want as long as it can be
    used with the generic function that you are going to implement. In this case,
    we could have added `string` or `uint` to the list of supported data types, if
    that makes sense. In this case, adding `string` to the `Numeric` interface does
    not make any sense.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个新的接口 `Numeric`，它指定了支持的数据类型列表。只要你可以使用你将要实现的泛型函数，你就可以使用任何你想要的数据类型。在这种情况下，如果我们想添加
    `string` 或 `uint` 到支持的数据类型列表中，这是有意义的。在这种情况下，将 `string` 添加到 `Numeric` 接口中没有任何意义。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the definition of the generic function with two generic parameters that
    use the `Numeric` constraint.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义具有两个泛型参数的泛型函数的定义，这些参数使用 `Numeric` 约束。
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous code is the implementation of the `main()` function with the calls
    to `Add()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是 `main()` 函数的实现，其中调用了 `Add()`。
- en: 'Running `numeric.go` produces the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `numeric.go` 产生以下输出：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Nevertheless, the Go rules still apply. Therefore, if you try to call `Add(4.1,3)`,
    you are going to get the following error message:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Go 的规则仍然适用。因此，如果你尝试调用 `Add(4.1,3)`，你将得到以下错误信息：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The reason for this error is that the `Add()` function expects two parameters
    of the same data type. However, `4.1` is a `float64` whereas `3` is an `int`,
    so not the same data type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误的理由是 `Add()` 函数期望两个相同数据类型的参数。然而，`4.1` 是 `float64` 类型，而 `3` 是 `int` 类型，所以它们不是同一数据类型。
- en: There is an additional issue with constraints that we have not discussed so
    far. As we already know, **Go treats different data types differently even if
    the underlying data type is the same**. This means that if we create a new data
    type that is based on `int` (`type aType int`), it is not going to be supported
    by the `Numeric` constraint as this is not specified. The next subsection shows
    us how to deal with it and overcome that limitation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论的一个额外问题是约束。正如我们已经知道的，**Go 对不同数据类型有不同的处理，即使底层数据类型相同**。这意味着如果我们创建一个基于 `int`
    的新数据类型（`type aType int`），它将不会由 `Numeric` 约束支持，因为这是未指定的。下一小节将展示如何处理这种情况并克服这一限制。
- en: Supporting underlying data types
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持底层数据类型
- en: 'With supertypes, we are adding support for the underlying data type—the real
    one—and not the data type at hand, which might be an alias for an existing Go
    data type. Supertypes are supported by the `~` operator. The use of supertypes
    is illustrated in `supertypes.go`. The first part of the code in `supertypes.go`
    is the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用超类型，我们正在添加对底层数据类型（真实的那个）的支持，而不是当前的数据类型，这可能是现有 Go 数据类型的别名。超类型由 `~` 运算符支持。`supertypes.go`
    中的 `supertypes.go` 部分展示了超类型的使用。`supertypes.go` 中的代码第一部分如下：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code, we define a constraint named `AllInts` that uses a supertype
    (`~int`) as well as a new data type that is named `AnotherInt` and is in reality
    `int`. The definition of the `AllInts` constraint allows `AnotherInt` to be supported
    by `AllInts`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们定义了一个名为 `AllInts` 的约束，它使用了一个超类型（`~int`）以及一个名为 `AnotherInt` 的新数据类型，实际上它是
    `int`。`AllInts` 约束的定义允许 `AnotherInt` 由 `AllInts` 支持。
- en: 'The second part of `supertypes.go` is the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`supertypes.go` 的第二部分如下：'
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this part, we have defined a generic function. The function comes with a
    constraint as it supports slices of `AllInts` only.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们定义了一个泛型函数。该函数附带了一个约束，因为它只支持 `AllInts` 的切片。
- en: 'The last part of `supertypes.go` is the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`supertypes.go` 的最后一部分如下：'
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this last part, we call `AddElements()` using a slice of `AnotherInt` as
    its parameter—this capability is offered by the use of the supertype in the `AllInts`
    constraint.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分，我们使用 `AnotherInt` 的切片作为参数调用 `AddElements()`——这种能力是通过在 `AllInts` 约束中使用超类型提供的。
- en: 'Running `supertypes.go` produces the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `supertypes.go` 产生以下输出：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, **the use of supertypes in type constraints allows Go to deal with the actual
    underlying data type**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**在类型约束中使用超类型允许 Go 处理实际的底层数据类型**。
- en: Supporting slices of any type
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持任何类型的切片
- en: 'In this subsection, we are going to specify that a function parameter can only
    be a slice of any data type. The relevant code in `sliceConstraint.go` is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将指定函数参数只能为任何数据类型的切片。`sliceConstraint.go` 中的相关代码如下：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All three generic functions are equivalent. The use of `~[]E` specifies that
    the underlying data type should be a slice even if it is a type by a different
    name.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个泛型函数是等效的。使用 `~[]E` 指定底层数据类型应该是切片，即使它是由不同名称的类型。
- en: The `f1()` function is the long version of the function signature. `interface{
    ~[]E }` specifies that we only want to work with slices of any data type (`E interface{}`).
    The `f2()` function replaces `interface{ ~[]E }` with just `~[]E` because Go allows
    you to omit the enclosing `interface{}` for interfaces in the constraint position.
    Last, the `f3()` function replaces the commonly used `interface{}` with its predefined
    equivalent `any`, which we have already seen in action. I find the implementation
    of `f3()` much simpler and easier to understand.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1()` 函数是函数签名的长版本。`interface{ ~[]E }` 指定我们只想与任何数据类型的切片（`E interface{}`）一起工作。`f2()`
    函数将 `interface{ ~[]E }` 替换为仅 `~[]E`，因为 Go 允许你在约束位置省略 `interface{}`。最后，`f3()` 函数将常用的
    `interface{}` 替换为其预定义的等效项 `any`，这是我们之前已经看到过其作用的。我发现 `f3()` 的实现更简单，更容易理解。'
- en: The next section shows us how to use generics when defining new data types.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节展示了在定义新数据类型时如何使用泛型。
- en: Defining new data types with generics
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型定义新数据类型
- en: 'In this section, we are going to create a new data type with the use of generics,
    which is presented in `newDT.go`. The code of `newDT.go` is the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用泛型创建一个新的数据类型，这在 `newDT.go` 中展示。`newDT.go` 的代码如下：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous statement declares a new data type named `TreeLast` that uses generics.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的语句声明了一个名为 `TreeLast` 的新数据类型，它使用了泛型。
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`replaceLast()` is a method that operates on `TreeLast` variables. Apart from
    the function signature, there is nothing else that shows the use of generics.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`replaceLast()` 是一个操作 `TreeLast` 变量的方法。除了函数签名外，没有其他内容显示泛型的使用。'
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this first part of `main()`, we create a `TreeLast` variable with the `aa`
    and `bb` string values and then we replace the `bb` value with `cc`, using a call
    to `replaceLast("cc")`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 的第一部分中，我们使用 `aa` 和 `bb` 字符串值创建了一个 `TreeLast` 变量，然后我们通过调用 `replaceLast("cc")`
    将 `bb` 值替换为 `cc`。
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The second part of `main()` does a similar thing to the first part using a `TreeLast`
    variable populated with `int` values. So, `TreeLast` works with both `string`
    and `int` values without any issues.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 的第二部分使用 `TreeLast` 变量（用 `int` 值填充）执行与第一部分类似的操作。因此，`TreeLast` 可以与 `string`
    和 `int` 值一起工作而不会出现任何问题。'
- en: 'Running `newDT.go` produces the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `newDT.go` 产生以下输出：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first two lines of the output are related to the `TreeLast[string]` variable
    whereas the last two lines of the output are related to the `TreeLast[int]` variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前两行与 `TreeLast[string]` 变量相关，而输出的最后两行与 `TreeLast[int]` 变量相关。
- en: The next subsection is about using generics in Go structures.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子部分是关于在 Go 结构中使用泛型。
- en: Using generics in Go structures
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Go 结构中使用泛型
- en: In this section, we are going to implement a linked list that works with generics—this
    is one of the cases where the use of generics simplifies things because it allows
    you to implement the linked list once while being able to work with multiple data
    types.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个使用泛型的链表——这是泛型使用简化事情的一个例子，因为它允许你一次性实现链表，同时能够处理多种数据类型。
- en: 'The code of `structures.go` is the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`structures.go` 的代码如下：'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The node structure uses generics in order to support nodes that can store all
    kinds of data. This does not mean that the next field of a node can point to another
    node with a `Data` field with a different data type. The rule that a linked list
    contains elements of the same data type still applies—it just means that if you
    want to create three linked lists, one for storing `string` values, one for storing
    `int` values, and a third one for storing JSON records of a given `struct` data
    type, you do not need to write any extra code to do so.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 节点结构使用泛型来支持可以存储所有类型数据的节点。这并不意味着节点的下一个字段可以指向另一个具有不同数据类型 `Data` 字段的节点。链表包含相同数据类型元素的规则仍然适用——这仅仅意味着，如果你想创建三个链表，一个用于存储
    `string` 值，一个用于存储 `int` 值，第三个用于存储给定 `struct` 数据类型的 JSON 记录，你不需要为此编写任何额外的代码。
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the definition of the root node of a linked list of `node` nodes. Both
    `list` and `node` must share the same data type, `T`. However, as stated before,
    this does not prevent you from creating multiple linked lists of various data
    types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `node` 节点构成的链表的根节点定义。`list` 和 `node` 必须共享相同的数据类型 `T`。然而，正如之前所述，这并不阻止你创建多个不同数据类型的链表。
- en: You can still replace `any` with a constraint in both the definition of `node`
    and `list` if you want to restrict the list of allowed data types.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要限制允许的数据类型列表，你仍然可以在 `node` 和 `list` 的定义中将 `any` 替换为约束。
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `add()` function is generic in order to be able to work with all kinds of
    nodes. Apart from the signature of `add()`, the remaining code is not associated
    with the use of generics.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()` 函数是泛型的，以便能够与所有类型的节点一起工作。除了 `add()` 的签名外，其余代码与泛型的使用无关。'
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These two `if` blocks have to do with the addition of a new node to the linked
    list. The first `if` block is when the list is empty whereas the second `if` block
    is when we are dealing with the last node of the current list.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 `if` 块与向链表中添加新节点有关。第一个 `if` 块是当列表为空时的情况，而第二个 `if` 块是当我们处理当前列表的最后一个节点时的情况。
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last part of `add()` has to do with defining the proper associations between
    nodes when adding a new node to the list.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()` 的最后一部分与在列表中添加新节点时定义节点之间的适当关联有关。'
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we define a linked list of int values in `main()`, which is the linked
    list that we are going to work with.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 `main()` 中定义一个整数值的链表，这是我们将要处理的链表。
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The initial value of `myList` is `nil`, as the list is empty and does not contain
    any nodes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`myList` 的初始值是 `nil`，因为列表为空且不包含任何节点。'
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this first part, we add four elements to the linked list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们向链表中添加了四个元素。
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The last part of `main()` is about printing all the elements of the list by
    traversing it with the help of the `next` field, which points to the next node
    in the list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 的最后一部分是关于通过使用指向列表中下一个节点的 `next` 字段来遍历列表并打印所有元素。'
- en: 'Running `structures.go` produces the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `structures.go` 产生以下输出：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let us discuss the output a little more. The first line shows that the value
    of the empty list is `nil`. The first node of the list holds a value of `12` and
    a memory address (`0x14000096240`) that points to the second node. This goes on
    until we reach the last node, which holds the value of `9`, which appears twice
    in this linked list, and points to `nil`, because it is the last node. Therefore,
    the use of generics makes the linked list able to work with multiple data types.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论一下输出。第一行显示空列表的值为`nil`。列表的第一个节点包含一个值为`12`和内存地址（`0x14000096240`），该地址指向第二个节点。这个过程一直持续到我们达到最后一个节点，它包含值为`9`的值，在这个链表中出现了两次，并指向`nil`，因为它是最后的节点。因此，泛型使得链表能够与多种数据类型一起工作。
- en: The next three sections present three packages that use generics—feel free to
    look into their implementations for details (see the *Additional resources* section).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个部分介绍了三个使用泛型的包——您可以自由地查看它们的实现细节（见*附加资源*部分）。
- en: The cmp package
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The cmp package
- en: The `cmp` package, which became part of the standard Go library in Go 1.21,
    contains types and functions for comparing ordered values. The reason for presenting
    it before the `slices` and `maps` packages is that it is used by the other two.
    Keep in mind that in its current version, the `cmp` package is simplistic but
    it might get enriched in the future with more functionality.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp`包在Go 1.21中成为标准Go库的一部分，包含用于比较有序值的类型和函数。之所以在`slices`和`maps`包之前介绍它，是因为它被其他两个包使用。请记住，在其当前版本中，`cmp`包很简单，但它可能会在未来通过更多功能得到丰富。'
- en: Under the hood, the `cmp`, `slices`, and `maps` packages use generics and constraints,
    which is the main reason for presenting them in this chapter. So, generics can
    be used for creating packages that work with multiple data types.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`cmp`、`slices`和`maps`包使用泛型和约束，这是在本章中介绍它们的主要原因。因此，泛型可以用来创建可以与多种数据类型一起工作的包。
- en: The important code of `cmpPackage.go` can be found in the `main()` function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmpPackage.go`中的重要代码可以在`main()`函数中找到。'
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, `cmp.Compare(x, y)` compares two values and returns `-1` when `x < y`,
    `0` when `x=y`, and `1`, when `x > y`. `cmp.Compare(x, y)` returns an `int` value.
    On the other hand, `cmp.Less(x, y)` returns a `bool` value that is set to `true`
    when `x < y` and `false` otherwise.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cmp.Compare(x, y)`比较两个值，当`x < y`时返回`-1`，当`x=y`时返回`0`，当`x > y`时返回`1`。`cmp.Compare(x,
    y)`返回一个`int`值。另一方面，`cmp.Less(x, y)`返回一个`bool`值，当`x < y`时设置为`true`，否则为`false`。
- en: Note that in the last statement, we are comparing an integer value with a floating
    point value. However, the `cmp` package is clever enough to convert the `int`
    value into a `float64` value and compare the two values!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后一个语句中，我们正在比较一个整数值和一个浮点值。然而，`cmp`包足够聪明，可以将`int`值转换为`float64`值，并比较这两个值！
- en: 'Running `cmpPackage.go` produces the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cmpPackage.go`产生以下输出：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output of `cmp.Compare(5, 4)` is `1`, the output of `cmp.Compare(4, 5)`
    is -`1`, and the output of `cmp.Less(4, 5)` is `true`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp.Compare(5, 4)`的输出是`1`，`cmp.Compare(4, 5)`的输出是`-1`，而`cmp.Less(4, 5)`的输出是`true`。'
- en: The slices package
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The slices package
- en: The `slices` package has been part of the standard Go library since Go 1.21
    and offers functions for slices of any data type. Before continuing our discussion
    of the `slices` package, let us talk about the *shallow copy* and *deep copy*
    functionality, including their differences.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`slices`包自Go 1.21以来一直是标准Go库的一部分，并为任何数据类型的切片提供了函数。在我们继续讨论`slices`包之前，让我们谈谈*浅拷贝*和*深拷贝*功能，包括它们之间的区别。'
- en: Shallow and deep copies
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浅拷贝和深拷贝
- en: A *shallow copy* creates a new variable and then it assigns to it all the values
    that are found in the original version of the variable. If we are talking about
    a map, then this process assigns all keys and values using ordinary assignment.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*浅拷贝*会创建一个新的变量，然后将其赋值为原始变量版本中找到的所有值。如果我们谈论的是映射，那么这个过程会使用普通赋值来分配所有键和值。
- en: A *deep copy* first creates a new variable and then, it inserts all the values
    that are found in the original variable. However, each value must be copied recursively—this
    might not be an issue if we are talking about a string, but it might become an
    issue if we are talking about a structure, a reference to a structure, or a pointer.
    Among other things, this process might create never-ending circles. The key word
    here is *recursively*—this means that we need to go through all the values (if
    we are talking about a slice or a map) or fields (if we are talking about a structure)
    and find out what needs to be copied, recursively.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*深度复制* 首先创建一个新的变量，然后插入原始变量中找到的所有值。然而，每个值都必须递归地复制——如果我们谈论的是字符串，这可能不是问题，但如果我们谈论的是结构体、结构体的引用或指针，这可能会成为一个问题。在这个过程中，可能会创建无限循环。关键词在这里是
    *递归*——这意味着我们需要遍历所有值（如果我们谈论的是切片或映射）或字段（如果我们谈论的是结构体），并找出需要递归复制的部分。'
- en: Therefore, the main difference between a shallow copy and a deep copy is that
    in the deep copy, **the actual values are being copied recursively** whereas in
    the shallow copy, **we assign the original values using ordinary assignment**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，浅复制和深度复制之间的主要区别在于，在深度复制中，**实际值是递归复制的**，而在浅复制中，**我们使用普通赋值来分配原始值**。
- en: 'We are now ready to continue with the presentation of the functionality of
    the `slices` package. The first part of the implementation of `main()` in `slicesPackage.go`
    is the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续介绍 `slices` 包的功能。`slicesPackage.go` 中 `main()` 实现的第一部分如下：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `slices.Clone()` function returns a shallow copy of the given slice—the
    elements are copied using assignment. After the `s2 := slices.Clone(s1)` call,
    `s1` and `s2` are equal, yet have separate memory spaces for their elements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`slices.Clone()` 函数返回给定切片的浅复制——元素通过赋值复制。在执行 `s2 := slices.Clone(s1)` 调用后，`s1`
    和 `s2` 相等，但它们的元素具有各自的内存空间。'
- en: 'The second part is the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `slices.Compact()` function replaces consecutive appearances of equal elements
    with a single copy. Therefore, `-1 -1 -1` is going to become `-1` whereas `-1
    0 -1` is not going to change. As a rule of thumb, `slices.Compact()` works best
    on sorted slices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`slices.Compact()` 函数将连续出现的相等元素替换为单个副本。因此，`-1 -1 -1` 将变成 `-1`，而 `-1 0 -1` 则不会改变。一般来说，`slices.Compact()`
    在排序切片上工作得最好。'
- en: The `slices.Contains()` function reports whether a given value is present in
    a slice.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`slices.Contains()` 函数报告给定值是否存在于切片中。'
- en: The `slices.Clip()` function removes unused capacity from a slice. Put simply,
    the capacity of the slice becomes equal to the length of the slice. This can save
    you lots of memory when the capacity is much larger than the length of a slice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`slices.Clip()` 函数从切片中移除未使用的容量。简单来说，切片的容量将等于切片的长度。当容量远大于切片长度时，这可以为您节省大量内存。'
- en: 'The last part comes with the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分包含以下代码：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `slices.Min()` and `slices.Max()` functions return the minimum and maximum
    values in a slice, respectively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`slices.Min()` 和 `slices.Max()` 函数分别返回切片中的最小值和最大值。'
- en: The `slices.Replace()` function replaces the elements in the given range, which
    in this case is `s2[1:3]`, with the provided values, which in this case are `100`
    and `200`, and returns the modified slice. Last, `slices.Sort()` sorts a slice
    with values of any ordered type in ascending order.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`slices.Replace()` 函数用提供的值替换给定范围内的元素，在这个例子中是 `s2[1:3]`，这些值在这个例子中是 `100` 和 `200`，并返回修改后的切片。最后，`slices.Sort()`
    以升序对任何有序类型的值进行排序。'
- en: 'Running `slicesPackage.go` produces the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `slicesPackage.go` 产生以下输出：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can see the effect of `slices.Clip()` in the capacity of the slice and the
    effect of `slices.Replace()` in the values of the `s2` slice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在切片的容量中看到 `slices.Clip()` 的效果，以及在 `s2` 切片的值中看到 `slices.Replace()` 的效果。
- en: The next section presents the `maps` package.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍 `maps` 包。
- en: The maps package
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`maps` 包'
- en: The `maps` package has been part of the standard Go library since Go 1.21 and
    offers functions for maps of any type—its use is illustrated in `mapsPackage.go`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`maps` 包自 Go 1.21 版本以来一直是标准 Go 库的一部分，并为任何类型的映射提供了函数——其用法在 `mapsPackage.go`
    中得到了说明。'
- en: 'The `mapsPackage.go` program uses two helper functions that are defined as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapsPackage.go` 程序使用了两个辅助函数，定义如下：'
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The purpose of the `delete()` function is to define which pairs are going to
    be deleted from the map—this function is called as a parameter to `maps.DeleteFunc()`.
    The current implementation returns `true` for all odd values. This means that
    all odd values along with their keys are going to be deleted. The first parameter
    of `delete()` has the data type of the keys of the map whereas the second one
    has the data type of the values of the map.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()` 函数的目的是定义要从映射中删除哪些键值对——这个函数作为参数调用 `maps.DeleteFunc()`。当前实现对所有奇数值返回
    `true`。这意味着所有奇数值及其键都将被删除。`delete()` 的第一个参数具有映射键的数据类型，而第二个参数具有映射值的数据类型。'
- en: The purpose of the `equal()` function is to define how the equality of the values
    of the two maps is defined. In this case, we want to compare `int` values to `float64`
    values. For this to be legitimate, we need to convert the `int` values to `float64`
    values, which takes place inside `equal()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal()` 函数的目的是定义两个映射的值如何定义相等。在这种情况下，我们想要比较 `int` 值和 `float64` 值。为了使其合法，我们需要将
    `int` 值转换为 `float64` 值，这发生在 `equal()` 内部。'
- en: 'Let us now continue with the implementation of the `main()` function. The first
    part of the `main()` function as found in `mapsPackage.go` is the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现 `main()` 函数。在 `mapsPackage.go` 中找到的 `main()` 函数的第一部分如下：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the previous code, we define a map named `m` and call `maps.DeleteFunc()`
    in order to delete some of its elements.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们定义了一个名为 `m` 的映射，并调用 `maps.DeleteFunc()` 来删除其中的一些元素。
- en: 'The second part is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `maps.Clone()` function returns a shallow clone of its argument. After that,
    we call `maps.Equal()` to make sure that `maps.Clone()` works as expected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`maps.Clone()` 函数返回其参数的浅拷贝。之后，我们调用 `maps.Equal()` 来确保 `maps.Clone()` 正如预期那样工作。'
- en: The `maps.Copy(dst, src)` function copies all pairs in `src` into `dst`. When
    a key in `src` already exists in `dst`, then the value in `dst` will be overwritten
    by the value associated with the respective key in `src`. In our program, we copy
    `n` to the `m` map.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`maps.Copy(dst, src)` 函数将 `src` 中的所有键值对复制到 `dst` 中。当 `src` 中的键已存在于 `dst` 中时，则
    `dst` 中的值将被 `src` 中相应键的值覆盖。在我们的程序中，我们将 `n` 复制到 `m` 映射中。'
- en: 'The last part is the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this last part, we test the operation of `maps.EqualFunc()` by creating two
    maps, one that uses `int` values and the other that uses `float64` values, and
    comparing them according to the `equal()` function that we have created earlier.
    In other words, the purpose of `maps.EqualFunc()` is to find out whether two maps
    contain the same key and value pairs by comparing them according to their function
    argument.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分，我们通过创建两个映射来测试 `maps.EqualFunc()` 的操作，一个使用 `int` 值，另一个使用 `float64` 值，并根据我们之前创建的
    `equal()` 函数进行比较。换句话说，`maps.EqualFunc()` 的目的是通过比较它们的函数参数来确定两个映射是否包含相同的键值对。
- en: 'Running `mapsPackage.go` produces the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `mapsPackage.go` 产生以下输出：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `maps.DeleteFunc(m, delete)` statement deletes all key and value pairs where
    the value is odd leaving `m` with even values only. Additionally, the call to
    `maps.Equal()` returns `true` and the `Equal!` message is displayed on the screen.
    The `maps.Copy(m, n)` statement changes the value of `m["two"]` to `22` and adds
    the `three` key to `m` with a value of `3` as it was not present in `m` before
    the call to `maps.Copy()`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`maps.DeleteFunc(m, delete)` 语句删除所有值是奇数的键值对，使 `m` 只保留偶数值。此外，对 `maps.Equal()`
    的调用返回 `true`，并在屏幕上显示 `Equal!` 消息。`maps.Copy(m, n)` 语句将 `m["two"]` 的值更改为 `22`，并将
    `three` 键添加到 `m` 中，其值为 `3`，因为在调用 `maps.Copy()` 之前 `m` 中不存在该键。'
- en: When to use generics
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用泛型
- en: 'Generics is not a panacea and cannot replace good, accurate, and rational program
    design. Therefore, here are some principles and personal suggestions to keep in
    mind when thinking about using generics to solve a problem:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型并非万能，不能取代良好的、准确的和理性的程序设计。因此，在考虑使用泛型解决问题时，以下是一些需要记住的原则和个人建议：
- en: Generics might be used when creating code that needs to work with multiple data
    types.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建需要与多种数据类型一起工作的代码时，可能会使用泛型。
- en: Generics should be used when an implementation with interfaces and reflection
    makes the code more complex and more difficult to understand than necessary.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接口和反射的实现使代码比必要的更复杂、更难以理解时，应该使用泛型。
- en: Moreover, generics might be used when you expect to support more data types
    in the future.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，当预期未来要支持更多数据类型时，可能会使用泛型。
- en: Once again, the goal of using anything while coding is code simplicity and easier
    maintenance, not bragging about your coding capabilities.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，在编码时使用任何东西的目标是代码的简洁性和易于维护，而不是炫耀你的编码能力。
- en: Lastly, generics can be used when the developer is feeling comfortable with
    generics. There is no Go rule that makes the use of generics mandatory.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当开发者对泛型感到舒适时，可以使用泛型。没有 Go 规则强制使用泛型。
- en: This section concludes this chapter. Keep in mind that in order to use the `cmp`,
    `slices`, and `maps` packages, you need Go version 1.21 or later.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本节总结了本章内容。请注意，为了使用 `cmp`、`slices` 和 `maps` 包，你需要 Go 版本 1.21 或更高版本。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented generics and gave you the rationale behind the invention
    of generics. Additionally, it presented the Go syntax for generics as well as
    some issues that might come up if you use generics carelessly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了泛型，并解释了泛型发明的理由。此外，它还介绍了 Go 泛型的语法以及如果你不小心使用泛型可能会出现的一些问题。
- en: 'While the Go community is still trying to figure out how to use generics, two
    things are important: first, you do not have to use generics if you do not want
    to or if you do not feel comfortable with them, and second, when you use generics
    the right way, you will write less code for supporting multiple data types.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Go 社区仍在努力探索如何使用泛型时，有两点是重要的：首先，如果你不想使用泛型或者对它们感到不舒服，你不必使用泛型；其次，当你正确使用泛型时，你将需要为支持多种数据类型编写更少的代码。
- en: Although a function with generics is more flexible, code with generics usually
    runs slower than code that works with predefined static data types. So, the price
    you pay for flexibility is execution speed. Similarly, Go code with generics has
    a longer compilation time than equivalent code that does not use generics. Once
    the Go community begins working with generics in real-world scenarios, the cases
    where generics offer the highest productivity are going to become much more evident.
    At the end of the day, programming is about understanding the cost of your decisions.
    Only then can you consider yourself a programmer. So, understanding the cost of
    using generics instead of interfaces, reflection, or other techniques is important.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然泛型函数更灵活，但使用泛型的代码通常比使用预定义静态数据类型的代码运行得更慢。因此，你为灵活性付出的代价是执行速度。同样，使用泛型的 Go 代码的编译时间也比不使用泛型的等效代码长。一旦
    Go 社区开始在现实场景中使用泛型，泛型提供最高生产力的案例将变得更加明显。最终，编程是关于理解你决策的成本。只有在这种情况下，你才能称自己为程序员。因此，理解使用泛型而不是接口、反射或其他技术的成本是很重要的。
- en: The next chapter is about type methods, which are functions attached to a data
    type, reflection, and interfaces. All these things will allow us to further improve
    the statistics application. Additionally, the next chapter will compare generics
    with interfaces and reflection as there is an overlap in their use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍类型方法，这些方法是附加到数据类型上的函数、反射和接口。所有这些都将使我们能够进一步改进统计应用程序。此外，下一章将比较泛型与接口和反射，因为它们在使用上有重叠。
- en: Exercises
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to solve the following exercises:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解决以下练习：
- en: Create a `PrintMe()` method in `structures.go` that prints all the elements
    of the linked list.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `structures.go` 中创建一个 `PrintMe()` 方法，用于打印链表的所有元素。
- en: Go 1.21 comes with a new function named `clear` that clears maps and slices.
    For maps, it deletes all entries whereas for slices it zeros all existing values.
    Experiment with it to learn how it works.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 1.21 版本附带了一个名为 `clear` 的新函数，该函数用于清除映射和切片。对于映射，它会删除所有条目，而对于切片，它会将所有现有值置零。尝试使用它来了解它是如何工作的。
- en: Implement the `delete()` and `search()` functionality using generics for the
    linked list found in `structures.go`.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型实现 `delete()` 和 `search()` 功能，针对 `structures.go` 中找到的链表。
- en: Implement a doubly-linked list using generics starting with the code found in
    `structures.go`.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `structures.go` 中找到的代码，使用泛型实现一个双链表。
- en: Additional resources
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: Why Generics? [https://blog.golang.org/why-generics](https://blog.golang.org/why-generics)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用泛型？[https://blog.golang.org/why-generics](https://blog.golang.org/why-generics)
- en: 'An Introduction to Generics: [https://go.dev/blog/intro-generics](https://go.dev/blog/intro-generics)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型简介：[https://go.dev/blog/intro-generics](https://go.dev/blog/intro-generics)
- en: 'The Next Step for Generics: [https://blog.golang.org/generics-next-step](https://blog.golang.org/generics-next-step)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型的下一步：[https://blog.golang.org/generics-next-step](https://blog.golang.org/generics-next-step)
- en: 'A Proposal for Adding Generics to Go: [https://blog.golang.org/generics-proposal](https://blog.golang.org/generics-proposal)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Go 添加泛型的提案：[https://blog.golang.org/generics-proposal](https://blog.golang.org/generics-proposal)
- en: 'All your comparable types: [https://go.dev/blog/comparable](https://go.dev/blog/comparable)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有可比较的类型：[https://go.dev/blog/comparable](https://go.dev/blog/comparable)
- en: 'The `constraints` package: [https://pkg.go.dev/golang.org/x/exp/constraints](https://pkg.go.dev/golang.org/x/exp/constraints)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constraints` 包：[https://pkg.go.dev/golang.org/x/exp/constraints](https://pkg.go.dev/golang.org/x/exp/constraints)'
- en: 'The `cmp` package: [https://pkg.go.dev/cmp](https://pkg.go.dev/cmp)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmp` 包：[https://pkg.go.dev/cmp](https://pkg.go.dev/cmp)'
- en: 'The `slices` package: [https://pkg.go.dev/slices](https://pkg.go.dev/slices)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slices` 包：[https://pkg.go.dev/slices](https://pkg.go.dev/slices)'
- en: 'The `maps` package: [https://pkg.go.dev/maps](https://pkg.go.dev/maps)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maps` 包：[https://pkg.go.dev/maps](https://pkg.go.dev/maps)'
- en: 'The official proposal for the `slices` package (similar proposals exist for
    other Go features): [https://github.com/golang/go/issues/45955](https://github.com/golang/go/issues/45955)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slices` 包的官方提案（其他 Go 功能也存在类似提案）：[https://github.com/golang/go/issues/45955](https://github.com/golang/go/issues/45955)'
- en: Leave a review!
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论来帮助像你这样的读者。扫描下面的二维码，获取你选择的免费电子书。
- en: '![](img/Review_QR_Code.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Review_QR_Code.png)'
