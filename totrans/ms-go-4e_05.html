<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer087">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 class="chapterTitle" id="_idParaDest-124"><span class="koboSpan" id="kobo.2.1">Reflection and Interfaces</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">You might wonder what happens if you want to sort user-defined data structures, such as phone records or numeric data, based on your own criteria, such as a surname or a statistical property such as the mean value of a dataset. </span><span class="koboSpan" id="kobo.3.2">What happens when you want to sort different datasets that share a common behavior without having to implement sorting from scratch for each one of the different data types using multiple functions? </span><span class="koboSpan" id="kobo.3.3">Also, imagine that you want to write a utility that sorts uncommon data. </span><span class="koboSpan" id="kobo.3.4">For example, imagine that you want to sort a slice that holds various kinds of 3D shapes based on their volume. </span><span class="koboSpan" id="kobo.3.5">Can this be performed easily and in a way that makes sense?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">The answer to all these questions and concerns is the use of interfaces. </span><span class="koboSpan" id="kobo.4.2">However, interfaces are not just about data manipulation and sorting. </span><span class="koboSpan" id="kobo.4.3">Interfaces are about expressing abstractions and identifying and defining behaviors that can be shared among different data types. </span><span class="koboSpan" id="kobo.4.4">Once you have implemented an interface for a data type, a new world of functionality becomes available for the variables and the values of that type, which can save you time and increase your productivity. </span><span class="koboSpan" id="kobo.4.5">Interfaces work with </span><em class="italic"><span class="koboSpan" id="kobo.5.1">methods on types</span></em><span class="koboSpan" id="kobo.6.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.7.1">type methods</span></em><span class="koboSpan" id="kobo.8.1">, which are like functions attached to given data types, which, in Go, are usually structures. </span><span class="koboSpan" id="kobo.8.2">In Go, interfaces are satisfied implicitly. </span><span class="koboSpan" id="kobo.8.3">This means that you do not explicitly declare that a type implements an interface. </span><span class="koboSpan" id="kobo.8.4">Instead, a type is considered to implement an interface if it provides implementations for all the methods declared by that interface. </span><span class="koboSpan" id="kobo.8.5">Now, let us talk about the </span><em class="italic"><span class="koboSpan" id="kobo.9.1">empty interface</span></em><span class="koboSpan" id="kobo.10.1">, which is represented by </span><code class="inlineCode"><span class="koboSpan" id="kobo.11.1">interface{}</span></code><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">The empty interface specifies zero methods, meaning that any type satisfies the empty interface. </span><span class="koboSpan" id="kobo.12.3">This can be powerful but also requires caution because it essentially says “I can hold a value of any type.”</span></p>
<p class="normal"><span class="koboSpan" id="kobo.13.1">Another handy yet advanced Go feature is reflection, which allows you to examine the internal structure of a data type at execution time. </span><span class="koboSpan" id="kobo.13.2">However, as reflection is an advanced Go feature, you might not need to use it on a regular basis.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.14.1">This chapter covers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Reflection</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Type methods</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Interfaces</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Object-oriented programming in Go</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Interfaces versus generics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Reflection versus generics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Updating the statistics application</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-125"><span class="koboSpan" id="kobo.22.1">Reflection</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.23.1">We begin this</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.24.1"> chapter with reflection, which is an advanced Go feature, not because it is an easy subject but because it is going to help you understand how Go works with different data types, including interfaces, and why it is needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.25.1">You might be wondering how you can find out the names of the fields of a structure at execution time. </span><span class="koboSpan" id="kobo.25.2">In such cases, you need to use reflection. </span><span class="koboSpan" id="kobo.25.3">Apart from enabling you to print the fields and the values of a structure, reflection also allows you to explore and manipulate unknown structures like the ones created from decoding JSON data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.26.1">The two main questions that I asked myself when I was introduced to reflection for the first time were the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">Why is reflection included in Go?</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.28.1">When should reflection be used?</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.29.1">To answer the first question, reflection allows you to dynamically learn the type of an arbitrary object along with information about its structure. </span><span class="koboSpan" id="kobo.29.2">Go provides the </span><code class="inlineCode"><span class="koboSpan" id="kobo.30.1">reflect</span></code><span class="koboSpan" id="kobo.31.1"> package for working with reflection. </span><span class="koboSpan" id="kobo.31.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.32.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.33.1"> function is clever enough to understand the data types of its parameters and act accordingly because, behind the scenes, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.34.1">fmt</span></code><span class="koboSpan" id="kobo.35.1"> package uses reflection to do that.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.36.1">As far as the second question is concerned, reflection allows you to handle and work with data types that do not exist at the time at which you write your code but might exist in the future, which is when we use an existing package with new user-defined data types—Go functions can accept unknown data types with the use of the empty interface. </span><span class="koboSpan" id="kobo.36.2">Additionally, reflection might come in handy when you have to work with data types that do not implement a common interface and therefore have an uncommon or unknown behavior—this does not mean that they have bad or erroneous behavior, just uncommon/unusual behavior such as user-defined structures. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.37.1">Interfaces are covered later in this chapter, so stay tuned for more!</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.38.1">The introduction of generics in Go might make the use of reflection less frequent in some cases because, with generics, you can work with different data types more easily and without the need to know their exact data types in advance. </span><span class="koboSpan" id="kobo.38.2">However, nothing beats reflection for fully exploring the structure and the data types of a variable. </span><span class="koboSpan" id="kobo.38.3">We compare reflection with generics at the end of this chapter.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.39.1">The most useful parts of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.40.1">reflect</span></code><span class="koboSpan" id="kobo.41.1"> package are two data types named </span><code class="inlineCode"><span class="koboSpan" id="kobo.42.1">reflect.Value</span></code><span class="koboSpan" id="kobo.43.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.44.1">reflect.Type</span></code><span class="koboSpan" id="kobo.45.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.46.1">reflect.Value</span></code><span class="koboSpan" id="kobo.47.1"> is used for storing values of any type, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.48.1">reflect.Type</span></code><span class="koboSpan" id="kobo.49.1"> is used for representing Go types. </span><span class="koboSpan" id="kobo.49.2">There exist two functions named </span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">reflect.TypeOf()</span></code><span class="koboSpan" id="kobo.51.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.52.1">reflect.ValueOf()</span></code><span class="koboSpan" id="kobo.53.1"> that return </span><code class="inlineCode"><span class="koboSpan" id="kobo.54.1">reflect.Type</span></code><span class="koboSpan" id="kobo.55.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.56.1">reflect.Value</span></code><span class="koboSpan" id="kobo.57.1"> values, respectively. </span><span class="koboSpan" id="kobo.57.2">Note that </span><code class="inlineCode"><span class="koboSpan" id="kobo.58.1">reflect.TypeOf()</span></code><span class="koboSpan" id="kobo.59.1"> returns the actual type of a variable—if we are examining a structure, it returns the name of the structure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.60.1">As structures are really</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.61.1"> important in Go, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.62.1">reflect</span></code><span class="koboSpan" id="kobo.63.1"> package offers the </span><code class="inlineCode"><span class="koboSpan" id="kobo.64.1">reflect.NumField()</span></code><span class="koboSpan" id="kobo.65.1"> method for listing the number of fields in a structure as well as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.66.1">Field()</span></code><span class="koboSpan" id="kobo.67.1"> method for getting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.68.1">reflect.Value</span></code><span class="koboSpan" id="kobo.69.1"> value of a specific field of a structure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.70.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.71.1">reflect</span></code><span class="koboSpan" id="kobo.72.1"> package also defines the </span><code class="inlineCode"><span class="koboSpan" id="kobo.73.1">reflect.Kind</span></code><span class="koboSpan" id="kobo.74.1"> data type, which is used for representing the specific data type of a variable: </span><code class="inlineCode"><span class="koboSpan" id="kobo.75.1">int</span></code><span class="koboSpan" id="kobo.76.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.77.1">struct</span></code><span class="koboSpan" id="kobo.78.1">, etc. </span><span class="koboSpan" id="kobo.78.2">The documentation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.79.1">reflect</span></code><span class="koboSpan" id="kobo.80.1"> package lists all possible values of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.81.1">reflect.Kind</span></code><span class="koboSpan" id="kobo.82.1"> data type. </span><span class="koboSpan" id="kobo.82.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.83.1">Kind()</span></code><span class="koboSpan" id="kobo.84.1"> function returns the kind of a variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">Last, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.86.1">Int()</span></code><span class="koboSpan" id="kobo.87.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">String()</span></code><span class="koboSpan" id="kobo.89.1"> methods return the integer and string value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">reflect.Value</span></code><span class="koboSpan" id="kobo.91.1">, respectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.92.1">Reflection code can look unpleasant and hard to read sometimes. </span><span class="koboSpan" id="kobo.92.2">Therefore, according to the Go philosophy, you should rarely use reflection unless it is necessary because, despite its cleverness, it does not create clean code.</span></p>
<h2 class="heading-2" id="_idParaDest-126"><span class="koboSpan" id="kobo.93.1">Understanding the internal structure of a Go structure</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.94.1">The next utility </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.95.1">shows how to use reflection </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.96.1">to discover the internal structure and fields of a Go structure variable. </span><span class="koboSpan" id="kobo.96.2">Type it and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.97.1">reflection.go</span></code><span class="koboSpan" id="kobo.98.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.99.1">package</span></span><span class="koboSpan" id="kobo.100.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.101.1">import</span></span><span class="koboSpan" id="kobo.102.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.103.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.104.1">fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.105.1">"reflect"</span></span><span class="koboSpan" id="kobo.106.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.107.1">type</span></span><span class="koboSpan" id="kobo.108.1"> Secret </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.109.1">struct</span></span><span class="koboSpan" id="kobo.110.1"> {
    Username </span><span class="hljs-type"><span class="koboSpan" id="kobo.111.1">string</span></span><span class="koboSpan" id="kobo.112.1">
    Password </span><span class="hljs-type"><span class="koboSpan" id="kobo.113.1">string</span></span><span class="koboSpan" id="kobo.114.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.115.1">type</span></span><span class="koboSpan" id="kobo.116.1"> Record </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.117.1">struct</span></span><span class="koboSpan" id="kobo.118.1"> {
    Field1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.119.1">string</span></span><span class="koboSpan" id="kobo.120.1">
    Field2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.121.1">float64</span></span><span class="koboSpan" id="kobo.122.1">
    Field3 Secret
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.123.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.124.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.125.1">()</span></span><span class="koboSpan" id="kobo.126.1"> {
    A := Record{</span><span class="hljs-string"><span class="koboSpan" id="kobo.127.1">"String value"</span></span><span class="koboSpan" id="kobo.128.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.129.1">-12.123</span></span><span class="koboSpan" id="kobo.130.1">, Secret{</span><span class="hljs-string"><span class="koboSpan" id="kobo.131.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.132.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.133.1">"Tsoukalos"</span></span><span class="koboSpan" id="kobo.134.1">}}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.135.1">We begin by defining a </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">Record</span></code><span class="koboSpan" id="kobo.137.1"> structure variable that contains another structure value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">Secret{"Mihalis", "Tsoukalos"}</span></code><span class="koboSpan" id="kobo.139.1">).</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.140.1">    r := reflect.ValueOf(A)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.141.1">"String value:"</span></span><span class="koboSpan" id="kobo.142.1">, r.String())
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.143.1">This returns the </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">reflect.Value</span></code><span class="koboSpan" id="kobo.145.1"> of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.146.1">A</span></code><span class="koboSpan" id="kobo.147.1"> variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.148.1">    iType := r.Type()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.149.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.150.1">Type()</span></code><span class="koboSpan" id="kobo.151.1"> is how we get the data type of a variable—in this case, variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.152.1">A</span></code><span class="koboSpan" id="kobo.153.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.154.1">    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.155.1">"i Type: %s\n"</span></span><span class="koboSpan" id="kobo.156.1">, iType)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.157.1">"The %d fields of %s are\n"</span></span><span class="koboSpan" id="kobo.158.1">, r.NumField(), iType)
    for i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.159.1">0</span></span><span class="koboSpan" id="kobo.160.1">; i &lt; r.NumField(); i++ {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.161.1">The previous </span><code class="inlineCode"><span class="koboSpan" id="kobo.162.1">for</span></code><span class="koboSpan" id="kobo.163.1"> loop allows the visiting of all fields of a structure and the examination of their characteristics.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.164.1">        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.165.1">"\t%s "</span></span><span class="koboSpan" id="kobo.166.1">, iType.Field(i).Name)
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.167.1">"\twith type: %s "</span></span><span class="koboSpan" id="kobo.168.1">, r.Field(i).Type())
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.169.1">"\tand value _%v_\n"</span></span><span class="koboSpan" id="kobo.170.1">, r.Field(i).Interface())
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.171.1">The previous </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.173.1"> statements return the name, the data type, and the value of the fields.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.174.1">// Check whether there are other structures embedded in Record</span></span><span class="koboSpan" id="kobo.175.1">
        k := reflect.TypeOf(r.Field(i).Interface()).Kind()
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.176.1">// Need to convert it to string in order to compare it</span></span><span class="koboSpan" id="kobo.177.1">
        if k.String() == </span><span class="hljs-string"><span class="koboSpan" id="kobo.178.1">"struct"</span></span><span class="koboSpan" id="kobo.179.1"> {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.180.1">To check the data type of a variable with a string, we need to convert the data type into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">string</span></code><span class="koboSpan" id="kobo.182.1"> variable first.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.183.1">            fmt.Println(r.Field(i).Type())
        }
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.184.1">// Same as before but using the internal value</span></span><span class="koboSpan" id="kobo.185.1">
        if k == reflect.Struct {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.186.1">You can also use </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.187.1">the internal representation</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.188.1"> of a data type during checking. </span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.189.1">            fmt.Println(r.Field(i).Type())
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.190.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">reflection.go</span></code><span class="koboSpan" id="kobo.192.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.193.1">$ </span></span><span class="koboSpan" id="kobo.194.1">go run reflection.go
String value: &lt;main.Record Value&gt;
i Type: main.Record
The 3 fields of main.Record are
        Field1  with type: string       and value _String value_
        Field2  with type: float64      and value _-12.123_
        Field3  with type: main.Secret  and value _{Mihalis Tsoukalos}_
main.Secret
main.Secret
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">main.Record</span></code><span class="koboSpan" id="kobo.196.1"> is the full unique name of the structure as defined by Go—</span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">main</span></code><span class="koboSpan" id="kobo.198.1"> is the package name and </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">Record</span></code><span class="koboSpan" id="kobo.200.1"> is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">struct</span></code><span class="koboSpan" id="kobo.202.1"> name. </span><span class="koboSpan" id="kobo.202.2">This happens so that Go can differentiate between the elements of different packages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.203.1">The presented code does not modify any values of the structure. </span><span class="koboSpan" id="kobo.203.2">If you were to make changes to the values of the structure fields, you would use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">Elem()</span></code><span class="koboSpan" id="kobo.205.1"> method and pass the structure as a pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">ValueOf()</span></code><span class="koboSpan" id="kobo.207.1">—remember that pointers allow you to make changes to actual variables. </span><span class="koboSpan" id="kobo.207.2">There exist methods for modifying existing values. </span><span class="koboSpan" id="kobo.207.3">In our case, we are</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.208.1"> going to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">SetString()</span></code><span class="koboSpan" id="kobo.210.1"> to</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.211.1"> modify a </span><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">string</span></code><span class="koboSpan" id="kobo.213.1"> field and </span><code class="inlineCode"><span class="koboSpan" id="kobo.214.1">SetInt()</span></code><span class="koboSpan" id="kobo.215.1"> to modify an </span><code class="inlineCode"><span class="koboSpan" id="kobo.216.1">int</span></code><span class="koboSpan" id="kobo.217.1"> field.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.218.1">This technique is illustrated in the next subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-127"><span class="koboSpan" id="kobo.219.1">Changing structure values using reflection</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.220.1">Learning about</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.221.1"> the internal structure of a Go structure is handy, but what is more practical is being able to change values in the Go structure, which is the subject of this subsection. </span><span class="koboSpan" id="kobo.221.2">However, keep in mind that this approach is an exception and that the vast majority of Go programs should not need to implement this.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.222.1">Type the following Go code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.223.1">setValues.go</span></code><span class="koboSpan" id="kobo.224.1">—it can also be found in the GitHub repository of the book inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.225.1">ch05</span></code><span class="koboSpan" id="kobo.226.1"> directory.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.227.1">package</span></span><span class="koboSpan" id="kobo.228.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.229.1">import</span></span><span class="koboSpan" id="kobo.230.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.231.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.232.1">"reflect"</span></span><span class="koboSpan" id="kobo.233.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.234.1">type</span></span><span class="koboSpan" id="kobo.235.1"> T </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.236.1">struct</span></span><span class="koboSpan" id="kobo.237.1"> {
    F1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.238.1">int</span></span><span class="koboSpan" id="kobo.239.1">
    F2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.240.1">string</span></span><span class="koboSpan" id="kobo.241.1">
    F3 </span><span class="hljs-type"><span class="koboSpan" id="kobo.242.1">float64</span></span><span class="koboSpan" id="kobo.243.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.244.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.245.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.246.1">()</span></span><span class="koboSpan" id="kobo.247.1"> {
    A := T{</span><span class="hljs-number"><span class="koboSpan" id="kobo.248.1">1</span></span><span class="koboSpan" id="kobo.249.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.250.1">"F2"</span></span><span class="koboSpan" id="kobo.251.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.252.1">3.0</span></span><span class="koboSpan" id="kobo.253.1">}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.254.1">A</span></code><span class="koboSpan" id="kobo.255.1"> is the variable that is being examined in this program.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.256.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.257.1">"A:"</span></span><span class="koboSpan" id="kobo.258.1">, A)
    r := reflect.ValueOf(&amp;A).Elem()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.259.1">With the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">Elem()</span></code><span class="koboSpan" id="kobo.261.1"> and a pointer to variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">A</span></code><span class="koboSpan" id="kobo.263.1">, variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">A</span></code><span class="koboSpan" id="kobo.265.1"> can be modified if needed.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.266.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.267.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.268.1">String value:"</span></span><span class="koboSpan" id="kobo.269.1">, r.String())
    typeOfA := r.Type()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.270.1">for</span></span><span class="koboSpan" id="kobo.271.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.272.1">0</span></span><span class="koboSpan" id="kobo.273.1">; i &lt; r.NumField(); i++ {
        f := r.Field(i)
        tOfA := typeOfA.Field(i).Name
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.274.1">"%d: %s %s = %v\n"</span></span><span class="koboSpan" id="kobo.275.1">, i, tOfA, f.Type(), f.Interface())
        k := reflect.TypeOf(r.Field(i).Interface()).Kind()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.276.1">if</span></span><span class="koboSpan" id="kobo.277.1"> k == reflect.Int {
            r.Field(i).SetInt(</span><span class="hljs-number"><span class="koboSpan" id="kobo.278.1">-100</span></span><span class="koboSpan" id="kobo.279.1">)
        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.280.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.281.1">if</span></span><span class="koboSpan" id="kobo.282.1"> k == reflect.String {
            r.Field(i).SetString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.283.1">"Changed!"</span></span><span class="koboSpan" id="kobo.284.1">)
        }
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.285.1">We are using </span><code class="inlineCode"><span class="koboSpan" id="kobo.286.1">SetInt()</span></code><span class="koboSpan" id="kobo.287.1"> to modify an integer value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">reflect.Int</span></code><span class="koboSpan" id="kobo.289.1">) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">SetString()</span></code><span class="koboSpan" id="kobo.291.1"> to modify a string value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">reflect.String</span></code><span class="koboSpan" id="kobo.293.1">). </span><span class="koboSpan" id="kobo.293.2">Integer values are set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">-100</span></code><span class="koboSpan" id="kobo.295.1"> and string values are set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">Changed!</span></code><span class="koboSpan" id="kobo.297.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.298.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.299.1">"A:"</span></span><span class="koboSpan" id="kobo.300.1">, A)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.301.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">setValues.go</span></code><span class="koboSpan" id="kobo.303.1"> creates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.304.1">$ </span></span><span class="koboSpan" id="kobo.305.1">go run setValues.go
A: {1 F2 3}
String value: &lt;main.T Value&gt;
0: F1 int = 1
1: F2 string = F2
2: F3 float64 = 3
A: {-100 Changed! </span><span class="koboSpan" id="kobo.305.2">3}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.306.1">The first line of output shows the initial version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">A</span></code><span class="koboSpan" id="kobo.308.1">, whereas the last line shows the final version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.309.1">A</span></code><span class="koboSpan" id="kobo.310.1"> with the </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.311.1">modified fields. </span><span class="koboSpan" id="kobo.311.2">The main use of such code is for dynamically changing the values of the fields of a structure without knowing the internals of the structure in advance.</span></p>
<h2 class="heading-2" id="_idParaDest-128"><span class="koboSpan" id="kobo.312.1">The three disadvantages of reflection</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.313.1">Without a doubt, reflection</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.314.1"> is a powerful Go feature. </span><span class="koboSpan" id="kobo.314.2">However, as with all tools, reflection should be used sparingly for three main reasons:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.315.1">The first reason is that extensive use of reflection will make your programs hard to read and maintain. </span><span class="koboSpan" id="kobo.315.2">A potential solution to this problem is good documentation, but developers are notorious for not having the time to write proper documentation.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.316.1">The second reason is that the Go code that uses reflection makes your programs slower. </span><span class="koboSpan" id="kobo.316.2">Generally speaking, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.317.1">Go code that works with a particular data type is always faster than Go code that uses reflection to dynamically work with any Go data type</span></strong><span class="koboSpan" id="kobo.318.1">. </span><span class="koboSpan" id="kobo.318.2">Additionally, such dynamic code makes it difficult for tools to refactor or analyze your code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.319.1">The last reason is that reflection errors cannot be caught at build time and are reported at runtime as panics, which means that reflection errors can potentially crash your programs. </span><span class="koboSpan" id="kobo.319.2">This can happen months or even years after the development of a Go program! </span><span class="koboSpan" id="kobo.319.3">One solution to this problem is extensive testing before a dangerous function call. </span><span class="koboSpan" id="kobo.319.4">However, this adds even more Go code to your programs, which makes them even slower.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.320.1">With the disadvantages of reflection in mind, it is important to remember that reflection is needed for cases such as JSON and XML serialization, dynamic code generation, and dynamic mapping </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.321.1">of Go structs to database tables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.322.1">Now that we know about reflection and what it can do for us, it is time to begin the discussion about type methods, which are necessary for understanding interfaces.</span></p>
<h1 class="heading-1" id="_idParaDest-129"><span class="koboSpan" id="kobo.323.1">Type methods</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.324.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.325.1">type method</span></strong><span class="koboSpan" id="kobo.326.1"> is a </span><em class="italic"><span class="koboSpan" id="kobo.327.1">function that is attached to a specific data type</span></em><span class="koboSpan" id="kobo.328.1">. </span><span class="koboSpan" id="kobo.328.2">Although type methods (or </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.329.1">methods on types) are functions, in reality, they are defined and used in a slightly different way.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.330.1">The methods on types feature gives some object-oriented capabilities to Go, which is very handy, and it’s used extensively in Go. </span><span class="koboSpan" id="kobo.330.2">Additionally, interfaces require type methods to work.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.331.1">Defining new type methods is as simple as creating new functions, provided that you follow certain rules that associate the function with a data type.</span></p>
<h2 class="heading-2" id="_idParaDest-130"><span class="koboSpan" id="kobo.332.1">Creating type methods</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.333.1">So, imagine that you </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.334.1">want to do calculations with 2x2 matrices. </span><span class="koboSpan" id="kobo.334.2">A very natural way of implementing that is by defining a new data type and defining type methods for adding, subtracting, and multiplying 2x2 matrices using that new data type. </span><span class="koboSpan" id="kobo.334.3">To make it even more interesting and generic, we are going to create a command line utility that accepts the elements of two 2x2 matrices as command line arguments, which are eight integer values in total, and performs all three calculations between them using the defined type methods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.335.1">By having a data type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">ar2x2</span></code><span class="koboSpan" id="kobo.337.1">, you can create a type method named </span><code class="inlineCode"><span class="koboSpan" id="kobo.338.1">FunctionName</span></code><span class="koboSpan" id="kobo.339.1"> for it as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.340.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.341.1">(a ar2x2)</span></span><span class="koboSpan" id="kobo.342.1"> FunctionName(parameters) &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.343.1">return</span></span><span class="koboSpan" id="kobo.344.1"> values&gt; {
    ...
</span><span class="koboSpan" id="kobo.344.2">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.345.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.346.1">(a ar2x2)</span></code><span class="koboSpan" id="kobo.347.1"> part is what makes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">FunctionName()</span></code><span class="koboSpan" id="kobo.349.1"> function a type method because it associates </span><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">FunctionName()</span></code><span class="koboSpan" id="kobo.351.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">ar2x2</span></code><span class="koboSpan" id="kobo.353.1"> data type. </span><span class="koboSpan" id="kobo.353.2">No other data type can use that function. </span><span class="koboSpan" id="kobo.353.3">However, you are free to implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">FunctionName()</span></code><span class="koboSpan" id="kobo.355.1"> for other data types or as a regular function. </span><span class="koboSpan" id="kobo.355.2">If you have an </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">ar2x2</span></code><span class="koboSpan" id="kobo.357.1"> variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">varAr</span></code><span class="koboSpan" id="kobo.359.1">, you can invoke </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">FunctionName()</span></code><span class="koboSpan" id="kobo.361.1"> as </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">varAr.FunctionName(...)</span></code><span class="koboSpan" id="kobo.363.1">, which looks like selecting the field of a structure variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.364.1">You are not obligated to develop type methods if you do not want to unless you are dealing with interfaces. </span><span class="koboSpan" id="kobo.364.2">Additionally, each type method can be rewritten as a regular function. </span><span class="koboSpan" id="kobo.364.3">Therefore, </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">FunctionName()</span></code><span class="koboSpan" id="kobo.366.1"> can be rewritten as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.367.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.368.1">FunctionName</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.369.1">(a ar2x2, parameters...)</span></span><span class="koboSpan" id="kobo.370.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.371.1">return</span></span><span class="koboSpan" id="kobo.372.1"> values&gt; {
    ...
</span><span class="koboSpan" id="kobo.372.2">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.373.1">Bear in mind that, under the hood, the Go compiler does turn methods into regular function calls with the self-value as the first parameter. </span><span class="koboSpan" id="kobo.373.2">However, keep in mind that </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.374.1">interfaces require the use of type methods to work</span></strong><span class="koboSpan" id="kobo.375.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.376.1">The expressions used for selecting a field of a structure or a type method of a data type, which would replace the ellipsis after the variable name above, are called </span><em class="italic"><span class="koboSpan" id="kobo.377.1">selectors</span></em><span class="koboSpan" id="kobo.378.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.379.1">Performing calculations between matrices of a given predefined size is one of the rare cases where using an array instead of a slice makes more sense because you do not have to modify the size of the matrices. </span><span class="koboSpan" id="kobo.379.2">Some people might argue that using a slice instead of an array pointer is a better practice—you are allowed to use what makes more sense to you and the problem at hand. </span><span class="koboSpan" id="kobo.379.3">As a rule of thumb, arrays should be preferred to slices when a fixed-size, contiguous block of memory is required or when performance is a critical concern. </span><span class="koboSpan" id="kobo.379.4">So, it is common to use slices for most dynamic collections and arrays for situations where a fixed-size, performance-critical structure is needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.380.1">Most of the time, the results of a type method are saved in the variable that invoked the type method—in</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.381.1"> order to implement that for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">ar2x2</span></code><span class="koboSpan" id="kobo.383.1"> data type, we pass a pointer to the array that invoked the type method, like </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">func (a *ar2x2)</span></code><span class="koboSpan" id="kobo.385.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-131"><span class="koboSpan" id="kobo.386.1">Value and point receivers</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.387.1">As you already</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.388.1"> know, a method can be associated with a named type, and the receiver of the method can be either a value receiver or a pointer receiver. </span><span class="koboSpan" id="kobo.388.2">A value receiver is a receiver associated with a method that operates on a copy of the value rather than the actual value itself. </span><span class="koboSpan" id="kobo.388.3">A pointer receiver is a receiver associated with a method that operates directly on the value pointed to by the receiver, rather than on a copy of the value.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.389.1">The choice between value and pointer receivers has implications for how the method behaves, particularly in terms of modifying the underlying value and performance considerations. </span><span class="koboSpan" id="kobo.389.2">In general, it is recommended to use a value receiver when the method does not need to modify the state of the receiver, when working with small, immutable types, or for methods that logically belong to the value itself, not a specific instance. </span><span class="koboSpan" id="kobo.389.3">On the other hand, you might prefer to use a pointer receiver when the method needs to modify the state of the receiver, when working with large data structures to avoid any copying overhead, or for methods that logically belong to a particular instance of the type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.390.1">The next subsection illustrates type methods in action.</span></p>
<h2 class="heading-2" id="_idParaDest-132"><span class="koboSpan" id="kobo.391.1">Using type methods</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.392.1">This subsection</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.393.1"> shows the use of type methods using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.394.1">ar2x2</span></code><span class="koboSpan" id="kobo.395.1"> data type as an example. </span><span class="koboSpan" id="kobo.395.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.396.1">Add()</span></code><span class="koboSpan" id="kobo.397.1"> function and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.398.1">Add()</span></code><span class="koboSpan" id="kobo.399.1"> method use the exact same algorithm for adding two matrices. </span><span class="koboSpan" id="kobo.399.2">The only difference between them is the way they are called and the fact that the function returns an array, whereas the method saves the result to the calling variable because of the use of a pointer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.400.1">Although adding and subtracting matrices is a straightforward process—you just add or subtract each element of the first matrix with the element of the second matrix that is located at the same position—matrix multiplication is a more complex process. </span><span class="koboSpan" id="kobo.400.2">This is the main reason that both addition and subtraction use </span><code class="inlineCode"><span class="koboSpan" id="kobo.401.1">for</span></code><span class="koboSpan" id="kobo.402.1"> loops, which means that the code can also work with bigger matrices, whereas multiplication uses static code that cannot be applied to bigger matrices without major changes.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.403.1">If you are defining type methods for a structure, you should make sure that the names of the type methods do not conflict with any field name of the structure because the Go compiler will reject such ambiguities.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.404.1">Type the following code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">methods.go</span></code><span class="koboSpan" id="kobo.406.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.407.1">package</span></span><span class="koboSpan" id="kobo.408.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.409.1">import</span></span><span class="koboSpan" id="kobo.410.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.411.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.412.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.413.1">"strconv"</span></span><span class="koboSpan" id="kobo.414.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.415.1">type</span></span><span class="koboSpan" id="kobo.416.1"> ar2x2 [</span><span class="hljs-number"><span class="koboSpan" id="kobo.417.1">2</span></span><span class="koboSpan" id="kobo.418.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.419.1">2</span></span><span class="koboSpan" id="kobo.420.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.421.1">int</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.422.1">// Traditional Add() function</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.423.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.424.1">Add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.425.1">(a, b ar2x2)</span></span><span class="koboSpan" id="kobo.426.1"> ar2x2 {
    c := ar2x2{}
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.427.1">for</span></span><span class="koboSpan" id="kobo.428.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.429.1">0</span></span><span class="koboSpan" id="kobo.430.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.431.1">2</span></span><span class="koboSpan" id="kobo.432.1">; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.433.1">for</span></span><span class="koboSpan" id="kobo.434.1"> j := </span><span class="hljs-number"><span class="koboSpan" id="kobo.435.1">0</span></span><span class="koboSpan" id="kobo.436.1">; j &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.437.1">2</span></span><span class="koboSpan" id="kobo.438.1">; j++ {
            c[i][j] = a[i][j] + b[i][j]
        }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.439.1">return</span></span><span class="koboSpan" id="kobo.440.1"> c
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.441.1">Here, we have a traditional function that adds two </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">ar2x2</span></code><span class="koboSpan" id="kobo.443.1"> variables and returns their result.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.444.1">// Type method Add()</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.445.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.446.1">(a *ar2x2)</span></span><span class="koboSpan" id="kobo.447.1"> Add(b ar2x2) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.448.1">for</span></span><span class="koboSpan" id="kobo.449.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.450.1">0</span></span><span class="koboSpan" id="kobo.451.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.452.1">2</span></span><span class="koboSpan" id="kobo.453.1">; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.454.1">for</span></span><span class="koboSpan" id="kobo.455.1"> j := </span><span class="hljs-number"><span class="koboSpan" id="kobo.456.1">0</span></span><span class="koboSpan" id="kobo.457.1">; j &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.458.1">2</span></span><span class="koboSpan" id="kobo.459.1">; j++ {
            a[i][j] = a[i][j] + b[i][j]
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.460.1">Here, we have a type method named </span><code class="inlineCode"><span class="koboSpan" id="kobo.461.1">Add()</span></code><span class="koboSpan" id="kobo.462.1"> that is attached to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.463.1">ar2x2</span></code><span class="koboSpan" id="kobo.464.1"> data type. </span><span class="koboSpan" id="kobo.464.2">The result of the addition is not returned. </span><span class="koboSpan" id="kobo.464.3">What happens is that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.465.1">ar2x2</span></code><span class="koboSpan" id="kobo.466.1"> variable that called the </span><code class="inlineCode"><span class="koboSpan" id="kobo.467.1">Add()</span></code><span class="koboSpan" id="kobo.468.1"> method is going to be modified and hold that result—this is the reason for using a pointer when defining the type method. </span><span class="koboSpan" id="kobo.468.2">If you do not want that behavior, you should modify </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.469.1">the signature and the implementation of the type method to match your needs.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.470.1">// Type method Subtract()</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.471.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.472.1">(a *ar2x2)</span></span><span class="koboSpan" id="kobo.473.1"> Subtract(b ar2x2) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.474.1">for</span></span><span class="koboSpan" id="kobo.475.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.476.1">0</span></span><span class="koboSpan" id="kobo.477.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.478.1">2</span></span><span class="koboSpan" id="kobo.479.1">; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.480.1">for</span></span><span class="koboSpan" id="kobo.481.1"> j := </span><span class="hljs-number"><span class="koboSpan" id="kobo.482.1">0</span></span><span class="koboSpan" id="kobo.483.1">; j &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.484.1">2</span></span><span class="koboSpan" id="kobo.485.1">; j++ {
            a[i][j] = a[i][j] - b[i][j]
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.486.1">The previous method subtracts </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">ar2x2</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.488.1">b</span></code><span class="koboSpan" id="kobo.489.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">ar2x2</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.491.1">a</span></code><span class="koboSpan" id="kobo.492.1"> and the result is saved in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.493.1">a</span></code><span class="koboSpan" id="kobo.494.1"> variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.495.1">// Type method Multiply()</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.496.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.497.1">(a *ar2x2)</span></span><span class="koboSpan" id="kobo.498.1"> Multiply(b ar2x2) {
    a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.499.1">0</span></span><span class="koboSpan" id="kobo.500.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.501.1">0</span></span><span class="koboSpan" id="kobo.502.1">] = a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.503.1">0</span></span><span class="koboSpan" id="kobo.504.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.505.1">0</span></span><span class="koboSpan" id="kobo.506.1">]*b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.507.1">0</span></span><span class="koboSpan" id="kobo.508.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.509.1">0</span></span><span class="koboSpan" id="kobo.510.1">] + a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.511.1">0</span></span><span class="koboSpan" id="kobo.512.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.513.1">1</span></span><span class="koboSpan" id="kobo.514.1">]*b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.515.1">1</span></span><span class="koboSpan" id="kobo.516.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.517.1">0</span></span><span class="koboSpan" id="kobo.518.1">]
    a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.519.1">1</span></span><span class="koboSpan" id="kobo.520.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.521.1">0</span></span><span class="koboSpan" id="kobo.522.1">] = a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.523.1">1</span></span><span class="koboSpan" id="kobo.524.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.525.1">0</span></span><span class="koboSpan" id="kobo.526.1">]*b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.527.1">0</span></span><span class="koboSpan" id="kobo.528.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.529.1">0</span></span><span class="koboSpan" id="kobo.530.1">] + a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.531.1">1</span></span><span class="koboSpan" id="kobo.532.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.533.1">1</span></span><span class="koboSpan" id="kobo.534.1">]*b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.535.1">1</span></span><span class="koboSpan" id="kobo.536.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.537.1">0</span></span><span class="koboSpan" id="kobo.538.1">]
    a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.539.1">0</span></span><span class="koboSpan" id="kobo.540.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.541.1">1</span></span><span class="koboSpan" id="kobo.542.1">] = a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.543.1">0</span></span><span class="koboSpan" id="kobo.544.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.545.1">0</span></span><span class="koboSpan" id="kobo.546.1">]*b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.547.1">0</span></span><span class="koboSpan" id="kobo.548.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.549.1">1</span></span><span class="koboSpan" id="kobo.550.1">] + a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.551.1">0</span></span><span class="koboSpan" id="kobo.552.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.553.1">1</span></span><span class="koboSpan" id="kobo.554.1">]*b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.555.1">1</span></span><span class="koboSpan" id="kobo.556.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.557.1">1</span></span><span class="koboSpan" id="kobo.558.1">]
    a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.559.1">1</span></span><span class="koboSpan" id="kobo.560.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.561.1">1</span></span><span class="koboSpan" id="kobo.562.1">] = a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.563.1">1</span></span><span class="koboSpan" id="kobo.564.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.565.1">0</span></span><span class="koboSpan" id="kobo.566.1">]*b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.567.1">0</span></span><span class="koboSpan" id="kobo.568.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.569.1">1</span></span><span class="koboSpan" id="kobo.570.1">] + a[</span><span class="hljs-number"><span class="koboSpan" id="kobo.571.1">1</span></span><span class="koboSpan" id="kobo.572.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.573.1">1</span></span><span class="koboSpan" id="kobo.574.1">]*b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.575.1">1</span></span><span class="koboSpan" id="kobo.576.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.577.1">1</span></span><span class="koboSpan" id="kobo.578.1">]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.579.1">As we are working with small arrays, we do the multiplications without using any </span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">for</span></code><span class="koboSpan" id="kobo.581.1"> loops.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.582.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.583.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.584.1">()</span></span><span class="koboSpan" id="kobo.585.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.586.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.587.1">len</span></span><span class="koboSpan" id="kobo.588.1">(os.Args) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.589.1">9</span></span><span class="koboSpan" id="kobo.590.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.591.1">"Need 8 integers"</span></span><span class="koboSpan" id="kobo.592.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.593.1">return</span></span><span class="koboSpan" id="kobo.594.1">
    }
    k := [</span><span class="hljs-number"><span class="koboSpan" id="kobo.595.1">8</span></span><span class="koboSpan" id="kobo.596.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.597.1">int</span></span><span class="koboSpan" id="kobo.598.1">{}
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.599.1">for</span></span><span class="koboSpan" id="kobo.600.1"> index, i := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.601.1">range</span></span><span class="koboSpan" id="kobo.602.1"> os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.603.1">1</span></span><span class="koboSpan" id="kobo.604.1">:] {
        v, err := strconv.Atoi(i)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.605.1">if</span></span><span class="koboSpan" id="kobo.606.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.607.1">nil</span></span><span class="koboSpan" id="kobo.608.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.609.1">return</span></span><span class="koboSpan" id="kobo.610.1">
        }
        k[index] = v
    }
    a := ar2x2{{k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.611.1">0</span></span><span class="koboSpan" id="kobo.612.1">], k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.613.1">1</span></span><span class="koboSpan" id="kobo.614.1">]}, {k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.615.1">2</span></span><span class="koboSpan" id="kobo.616.1">], k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.617.1">3</span></span><span class="koboSpan" id="kobo.618.1">]}}
    b := ar2x2{{k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.619.1">4</span></span><span class="koboSpan" id="kobo.620.1">], k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.621.1">5</span></span><span class="koboSpan" id="kobo.622.1">]}, {k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.623.1">6</span></span><span class="koboSpan" id="kobo.624.1">], k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.625.1">7</span></span><span class="koboSpan" id="kobo.626.1">]}}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.627.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">main()</span></code><span class="koboSpan" id="kobo.629.1"> function gets the input and creates two 2x2 matrices. </span><span class="koboSpan" id="kobo.629.2">After that, it performs the desired calculations with these two matrices.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.630.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.631.1">"Traditional a+b:"</span></span><span class="koboSpan" id="kobo.632.1">, Add(a, b))
    a.Add(b)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.633.1">"a+b:"</span></span><span class="koboSpan" id="kobo.634.1">, a)
    a.Subtract(a)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.635.1">"a-a:"</span></span><span class="koboSpan" id="kobo.636.1">, a)
    a = ar2x2{{k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.637.1">0</span></span><span class="koboSpan" id="kobo.638.1">], k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.639.1">1</span></span><span class="koboSpan" id="kobo.640.1">]}, {k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.641.1">2</span></span><span class="koboSpan" id="kobo.642.1">], k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.643.1">3</span></span><span class="koboSpan" id="kobo.644.1">]}}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.645.1">We calculate </span><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">a+b</span></code><span class="koboSpan" id="kobo.647.1"> using</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.648.1"> two different ways: using a regular function and using a type method. </span><span class="koboSpan" id="kobo.648.2">As both </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">a.Add(b)</span></code><span class="koboSpan" id="kobo.650.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">a.Subtract(a)</span></code><span class="koboSpan" id="kobo.652.1"> change the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.653.1">a</span></code><span class="koboSpan" id="kobo.654.1">, we have to initialize </span><code class="inlineCode"><span class="koboSpan" id="kobo.655.1">a</span></code><span class="koboSpan" id="kobo.656.1"> before using it again.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.657.1">    a.Multiply(b)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.658.1">"a*b:"</span></span><span class="koboSpan" id="kobo.659.1">, a)
    a = ar2x2{{k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.660.1">0</span></span><span class="koboSpan" id="kobo.661.1">], k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.662.1">1</span></span><span class="koboSpan" id="kobo.663.1">]}, {k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.664.1">2</span></span><span class="koboSpan" id="kobo.665.1">], k[</span><span class="hljs-number"><span class="koboSpan" id="kobo.666.1">3</span></span><span class="koboSpan" id="kobo.667.1">]}}
    b.Multiply(a)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.668.1">"b*a:"</span></span><span class="koboSpan" id="kobo.669.1">, b)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.670.1">Last, we calculate </span><code class="inlineCode"><span class="koboSpan" id="kobo.671.1">a*b</span></code><span class="koboSpan" id="kobo.672.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">b*a</span></code><span class="koboSpan" id="kobo.674.1"> to show that they are different because the commutative property does not apply to matrix multiplication.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.675.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.676.1">methods.go</span></code><span class="koboSpan" id="kobo.677.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.678.1">$ </span></span><span class="koboSpan" id="kobo.679.1">go run methods.go 1 2 0 0 2 1 1 1
Traditional a+b: [[3 3] [1 1]]
a+b: [[3 3] [1 1]]
a-a: [[0 0] [0 0]]
a*b: [[4 6] [0 0]]
b*a: [[2 4] [1 2]]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.680.1">The input here is two 2x2 matrices, </span><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">[[1 2] [0 0]]</span></code><span class="koboSpan" id="kobo.682.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.683.1">[[2 1] [1 1]]</span></code><span class="koboSpan" id="kobo.684.1">, and the output is their calculations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.685.1">Now that we know </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.686.1">about type methods, it is time to begin exploring interfaces as interfaces cannot be implemented without type methods.</span></p>
<h1 class="heading-1" id="_idParaDest-133"><span class="koboSpan" id="kobo.687.1">Interfaces</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.688.1">An interface is a Go </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.689.1">mechanism for defining behavior that is implemented using a set of methods. </span><span class="koboSpan" id="kobo.689.2">Interfaces have a core role in Go and can simplify the code of your programs when they have to deal with multiple data types that perform the same task—recall that </span><code class="inlineCode"><span class="koboSpan" id="kobo.690.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.691.1"> works for almost all data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.692.1">But remember, interfaces should not be unnecessarily complex. </span><span class="koboSpan" id="kobo.692.2">If you decide to create your own interfaces, then you should begin with a common behavior that you want to be used by multiple data types. </span><span class="koboSpan" id="kobo.692.3">Additionally, you should not design your programs by defining interfaces. </span><span class="koboSpan" id="kobo.692.4">You should start designing your program and wait for common behaviors to reveal themselves and then convert those common behaviors into interfaces. </span><span class="koboSpan" id="kobo.692.5">Last, if the use of interfaces does not make your code simpler, consider removing some or all of your interfaces.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.693.1">Interfaces define none, a single, or multiple type methods that need to be implemented. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.694.1">As you already know, once you implement the required type methods of an interface, that interface is satisfied implicitly</span></strong><span class="koboSpan" id="kobo.695.1">. </span><span class="koboSpan" id="kobo.695.2">In simpler terms, once you implement the methods of an interface for a given data type, that interface is satisfied automatically for that data type.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.696.1">The empty interface is defined as just </span><code class="inlineCode"><span class="koboSpan" id="kobo.697.1">interface{}</span></code><span class="koboSpan" id="kobo.698.1">. </span><span class="koboSpan" id="kobo.698.2">As the empty interface has no methods, it means that it is already implemented by all data types. </span><span class="koboSpan" id="kobo.698.3">In Go generics terms, the empty interface is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.699.1">any</span></code><span class="koboSpan" id="kobo.700.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.701.1">In a more formal way, a Go interface type defines (or describes) the behavior of other types by specifying a set of methods that need to be implemented to support that behavior. </span><span class="koboSpan" id="kobo.701.2">For a data type to satisfy an interface, it needs to implement all the type methods required by that interface. </span><span class="koboSpan" id="kobo.701.3">Therefore, interfaces are abstract types that specify a set of methods that need to be implemented so that another type can be considered an instance of the interface. </span><span class="koboSpan" id="kobo.701.4">So, an interface is two things: a set of methods and a data type. </span><span class="koboSpan" id="kobo.701.5">Bear in mind that small and well-defined interfaces are usually the most popular ones because they can be used in a much larger variety of cases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.702.1">As a rule of thumb, only create a new interface when you want to share a common behavior between two or more concrete data types. </span><span class="koboSpan" id="kobo.702.2">This is basically duck typing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.703.1">The biggest advantage you get from interfaces is that, if needed, you can pass a variable of a data type that implements a particular interface to any function that expects a parameter of that specific interface, which saves you from having to write separate functions for each supported data type. </span><span class="koboSpan" id="kobo.703.2">However, Go offers an alternative to this with the recent addition of generics.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.704.1">Interfaces can also be used to provide a kind of polymorphism in Go, which is an object-oriented concept. </span><em class="italic"><span class="koboSpan" id="kobo.705.1">Polymorphism</span></em><span class="koboSpan" id="kobo.706.1"> offers a way of accessing objects of different types in the same uniform way when they share a common behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.707.1">Last, interfaces can be used for composition. </span><span class="koboSpan" id="kobo.707.2">In practice, this means that you can combine existing interfaces and create new ones that offer the combined behavior of the interfaces that were</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.708.1"> brought together. </span><span class="koboSpan" id="kobo.708.2">The next figure shows interface composition in a graphical way.</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.709.1"><img alt="" role="presentation" src="../Images/B21003_05_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.710.1">Figure 5.1: Interface composition</span></p>
<p class="normal"><span class="koboSpan" id="kobo.711.1">Put simply, the previous figure illustrates that because of its definition, satisfying interface </span><code class="inlineCode"><span class="koboSpan" id="kobo.712.1">ABC</span></code><span class="koboSpan" id="kobo.713.1"> requires satisfying </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">InterfaceA</span></code><span class="koboSpan" id="kobo.715.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.716.1">InterfaceB</span></code><span class="koboSpan" id="kobo.717.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">InterfaceC</span></code><span class="koboSpan" id="kobo.719.1">. </span><span class="koboSpan" id="kobo.719.2">Additionally, any </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">ABC</span></code><span class="koboSpan" id="kobo.721.1"> variable can be used instead of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">InterfaceA</span></code><span class="koboSpan" id="kobo.723.1"> variable, an </span><code class="inlineCode"><span class="koboSpan" id="kobo.724.1">InterfaceB</span></code><span class="koboSpan" id="kobo.725.1"> variable, or an </span><code class="inlineCode"><span class="koboSpan" id="kobo.726.1">InterfaceC</span></code><span class="koboSpan" id="kobo.727.1"> variable because it supports all these three behaviors. </span><span class="koboSpan" id="kobo.727.2">Last, only </span><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">ABC</span></code><span class="koboSpan" id="kobo.729.1"> variables can be used where an </span><code class="inlineCode"><span class="koboSpan" id="kobo.730.1">ABC</span></code><span class="koboSpan" id="kobo.731.1"> variable is expected. </span><span class="koboSpan" id="kobo.731.2">There is nothing prohibiting you from including additional methods in the definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">ABC</span></code><span class="koboSpan" id="kobo.733.1"> interface if the combination of existing interfaces does not describe the desired behavior accurately.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.734.1">When you combine existing interfaces, it is better that the interfaces do not contain methods with the same name.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.735.1">What you should keep in mind is that there is no need for an interface to be impressive and require the implementation of a large number of methods. </span><span class="koboSpan" id="kobo.735.2">In fact, the fewer methods an interface </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.736.1">has, the more generic and widely used it is going to be, which increases its usefulness and therefore its usage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.737.1">The subsection that follows illustrates the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">sort.Interface</span></code><span class="koboSpan" id="kobo.739.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-134"><span class="koboSpan" id="kobo.740.1">The sort.Interface interface</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.741.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">sort</span></code><span class="koboSpan" id="kobo.743.1"> package </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.744.1">contains an interface named </span><code class="inlineCode"><span class="koboSpan" id="kobo.745.1">sort.Interface</span></code><span class="koboSpan" id="kobo.746.1"> that</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.747.1"> allows you to sort slices according to your needs and your data, provided that you implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">sort.Interface</span></code><span class="koboSpan" id="kobo.749.1"> for the custom data types stored in your slices. </span><span class="koboSpan" id="kobo.749.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">sort</span></code><span class="koboSpan" id="kobo.751.1"> package defines the </span><code class="inlineCode"><span class="koboSpan" id="kobo.752.1">sort.Interface</span></code><span class="koboSpan" id="kobo.753.1"> as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.754.1">type</span></span><span class="koboSpan" id="kobo.755.1"> Interface </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.756.1">interface</span></span><span class="koboSpan" id="kobo.757.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.758.1">// Len is the number of elements in the collection.</span></span><span class="koboSpan" id="kobo.759.1">
    Len() </span><span class="hljs-type"><span class="koboSpan" id="kobo.760.1">int</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.761.1">// Less reports whether the element with</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.762.1">// index i should sort before the element with index j.</span></span><span class="koboSpan" id="kobo.763.1">
    Less(i, j </span><span class="hljs-type"><span class="koboSpan" id="kobo.764.1">int</span></span><span class="koboSpan" id="kobo.765.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.766.1">bool</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.767.1">// Swap swaps the elements with indexes i and j.</span></span><span class="koboSpan" id="kobo.768.1">
    Swap(i, j </span><span class="hljs-type"><span class="koboSpan" id="kobo.769.1">int</span></span><span class="koboSpan" id="kobo.770.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.771.1">What we can understand from the definition of </span><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">sort.Interface</span></code><span class="koboSpan" id="kobo.773.1"> is that in order to implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">sort.Interface</span></code><span class="koboSpan" id="kobo.775.1">, we need to implement the following three type methods:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">Len() int</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.777.1">Less(i, j int) bool</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.778.1">Swap(i, j int)</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.779.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.780.1">Len()</span></code><span class="koboSpan" id="kobo.781.1"> method returns the length of the slice that will be sorted and helps the interface to process all slice elements, whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.782.1">Less()</span></code><span class="koboSpan" id="kobo.783.1"> method, which compares and sorts elements in pairs, defines how elements, are going to be compared and therefore sorted. </span><span class="koboSpan" id="kobo.783.2">The return value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.784.1">Less()</span></code><span class="koboSpan" id="kobo.785.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.786.1">bool</span></code><span class="koboSpan" id="kobo.787.1">, which means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.788.1">Less()</span></code><span class="koboSpan" id="kobo.789.1"> only cares about whether the element at index </span><code class="inlineCode"><span class="koboSpan" id="kobo.790.1">i</span></code><span class="koboSpan" id="kobo.791.1"> is bigger or not than the element at index </span><code class="inlineCode"><span class="koboSpan" id="kobo.792.1">j</span></code><span class="koboSpan" id="kobo.793.1"> in the way that the two elements are being compared. </span><span class="koboSpan" id="kobo.793.2">Last, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.794.1">Swap()</span></code><span class="koboSpan" id="kobo.795.1"> method is used for swapping two elements of the slice, which is required for the sorting algorithm to work.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.796.1">The following </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.797.1">code, which </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.798.1">can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.799.1">sort.go</span></code><span class="koboSpan" id="kobo.800.1">, illustrates the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.801.1">sort.Interface</span></code><span class="koboSpan" id="kobo.802.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.803.1">package</span></span><span class="koboSpan" id="kobo.804.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.805.1">import</span></span><span class="koboSpan" id="kobo.806.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.807.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.808.1">"sort"</span></span><span class="koboSpan" id="kobo.809.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.810.1">type</span></span><span class="koboSpan" id="kobo.811.1"> Size </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.812.1">struct</span></span><span class="koboSpan" id="kobo.813.1"> {
    F1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.814.1">int</span></span><span class="koboSpan" id="kobo.815.1">
    F2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.816.1">string</span></span><span class="koboSpan" id="kobo.817.1">
    F3 </span><span class="hljs-type"><span class="koboSpan" id="kobo.818.1">int</span></span><span class="koboSpan" id="kobo.819.1">
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.820.1">// We want to sort Person records based on the value of Size.F1</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.821.1">// Which is Size.F1 as F3 is an Size structure</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.822.1">type</span></span><span class="koboSpan" id="kobo.823.1"> Person </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.824.1">struct</span></span><span class="koboSpan" id="kobo.825.1"> {
    F1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.826.1">int</span></span><span class="koboSpan" id="kobo.827.1">
    F2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.828.1">string</span></span><span class="koboSpan" id="kobo.829.1">
    F3 Size
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.830.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.831.1">Person</span></code><span class="koboSpan" id="kobo.832.1"> structure includes a field named </span><code class="inlineCode"><span class="koboSpan" id="kobo.833.1">F3</span></code><span class="koboSpan" id="kobo.834.1"> that is of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.835.1">Size</span></code><span class="koboSpan" id="kobo.836.1"> data type, which is also a structure.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.837.1">type</span></span><span class="koboSpan" id="kobo.838.1"> Personslice []Person
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.839.1">You need to have a slice because all sorting operations work on slices. </span><span class="koboSpan" id="kobo.839.2">It is for this slice, which should be a new data type that in this case is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.840.1">Personslice</span></code><span class="koboSpan" id="kobo.841.1">, that you are going to implement the three type methods of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.842.1">sort.Interface</span></code><span class="koboSpan" id="kobo.843.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.844.1">// Implementing sort.Interface for Personslice</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.845.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.846.1">(a Personslice)</span></span><span class="koboSpan" id="kobo.847.1"> Len() </span><span class="hljs-type"><span class="koboSpan" id="kobo.848.1">int</span></span><span class="koboSpan" id="kobo.849.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.850.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.851.1">len</span></span><span class="koboSpan" id="kobo.852.1">(a)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.853.1">Here is the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.854.1">Len()</span></code><span class="koboSpan" id="kobo.855.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.856.1">Personslice</span></code><span class="koboSpan" id="kobo.857.1"> data type. </span><span class="koboSpan" id="kobo.857.2">It is usually that simple.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.858.1">// What field to use when comparing</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.859.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.860.1">(a Personslice)</span></span><span class="koboSpan" id="kobo.861.1"> Less(i, j </span><span class="hljs-type"><span class="koboSpan" id="kobo.862.1">int</span></span><span class="koboSpan" id="kobo.863.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.864.1">bool</span></span><span class="koboSpan" id="kobo.865.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.866.1">return</span></span><span class="koboSpan" id="kobo.867.1"> a[i].F3.F1 &lt; a[j].F3.F1
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.868.1">Here is the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.869.1">Less()</span></code><span class="koboSpan" id="kobo.870.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.871.1">Personslice</span></code><span class="koboSpan" id="kobo.872.1"> data type. </span><span class="koboSpan" id="kobo.872.2">This method defines the way elements get sorted. </span><span class="koboSpan" id="kobo.872.3">In this case, by using a field of the embedded data structure (</span><code class="inlineCode"><span class="koboSpan" id="kobo.873.1">F3.F1</span></code><span class="koboSpan" id="kobo.874.1">).</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.875.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.876.1">(a Personslice)</span></span><span class="koboSpan" id="kobo.877.1"> Swap(i, j </span><span class="hljs-type"><span class="koboSpan" id="kobo.878.1">int</span></span><span class="koboSpan" id="kobo.879.1">) {
    a[i], a[j] = a[j], a[i]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.880.1">This is the</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.881.1"> implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.882.1">Swap()</span></code><span class="koboSpan" id="kobo.883.1"> type method that defines the</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.884.1"> way to swap slice elements during sorting. </span><span class="koboSpan" id="kobo.884.2">It is usually that simple.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.885.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.886.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.887.1">()</span></span><span class="koboSpan" id="kobo.888.1"> {
    data := []Person{
        Person{</span><span class="hljs-number"><span class="koboSpan" id="kobo.889.1">1</span></span><span class="koboSpan" id="kobo.890.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.891.1">"One"</span></span><span class="koboSpan" id="kobo.892.1">, Size{</span><span class="hljs-number"><span class="koboSpan" id="kobo.893.1">1</span></span><span class="koboSpan" id="kobo.894.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.895.1">"Person_1"</span></span><span class="koboSpan" id="kobo.896.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.897.1">10</span></span><span class="koboSpan" id="kobo.898.1">}},
        Person{</span><span class="hljs-number"><span class="koboSpan" id="kobo.899.1">2</span></span><span class="koboSpan" id="kobo.900.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.901.1">"Two"</span></span><span class="koboSpan" id="kobo.902.1">, Size{</span><span class="hljs-number"><span class="koboSpan" id="kobo.903.1">2</span></span><span class="koboSpan" id="kobo.904.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.905.1">"Person_2"</span></span><span class="koboSpan" id="kobo.906.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.907.1">20</span></span><span class="koboSpan" id="kobo.908.1">}},
        Person{</span><span class="hljs-number"><span class="koboSpan" id="kobo.909.1">-1</span></span><span class="koboSpan" id="kobo.910.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.911.1">"Two"</span></span><span class="koboSpan" id="kobo.912.1">, Size{</span><span class="hljs-number"><span class="koboSpan" id="kobo.913.1">-1</span></span><span class="koboSpan" id="kobo.914.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.915.1">"Person_3"</span></span><span class="koboSpan" id="kobo.916.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.917.1">-20</span></span><span class="koboSpan" id="kobo.918.1">}},
    }
    
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.919.1">"Before:"</span></span><span class="koboSpan" id="kobo.920.1">, data)
    sort.Sort(Personslice(data))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.921.1">"After:"</span></span><span class="koboSpan" id="kobo.922.1">, data)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.923.1">// Reverse sorting works automatically</span></span><span class="koboSpan" id="kobo.924.1">
    sort.Sort(sort.Reverse(Personslice(data)))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.925.1">"Reverse:"</span></span><span class="koboSpan" id="kobo.926.1">, data)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.927.1">Once you have implemented </span><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">sort.Interface</span></code><span class="koboSpan" id="kobo.929.1">, you are going to see that </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">sort.Reverse()</span></code><span class="koboSpan" id="kobo.931.1">, which is used for reverse sorting your slice, works automatically.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.932.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.933.1">sort.go</span></code><span class="koboSpan" id="kobo.934.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.935.1">$ </span></span><span class="koboSpan" id="kobo.936.1">go run sort.go
Before: [{1 One {1 Person_1 10}} {2 Two {2 Person_2 20}} {-1 Two {-1 Person_3 -20}}]
After: [{-1 Two {-1 Person_3 -20}} {1 One {1 Person_1 10}} {2 Two {2 Person_2 20}}]
Reverse: [{2 Two {2 Person_2 20}} {1 One {1 Person_1 10}} {-1 Two {-1 Person_3 -20}}]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.937.1">The first line shows the elements of the slice as initially stored. </span><span class="koboSpan" id="kobo.937.2">The second line shows the sorted </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.938.1">version, whereas </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.939.1">the last line shows the reverse sorted version.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.940.1">Let us now present the handy empty interface.</span></p>
<h2 class="heading-2" id="_idParaDest-135"><span class="koboSpan" id="kobo.941.1">The empty interface</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.942.1">As mentioned</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.943.1"> before, the empty interface is defined as just </span><code class="inlineCode"><span class="koboSpan" id="kobo.944.1">interface{}</span></code><span class="koboSpan" id="kobo.945.1"> and is</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.946.1"> already implemented by all data types. </span><span class="koboSpan" id="kobo.946.2">Therefore, variables of any data type can be put in the place of a parameter of the empty interface data type. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.947.1">Therefore, a function with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.948.1">interface{}</span></code><span class="koboSpan" id="kobo.949.1"> parameter can accept variables of any data type in this place. </span><span class="koboSpan" id="kobo.949.2">However, if you intend to work with </span><code class="inlineCode"><span class="koboSpan" id="kobo.950.1">interface{}</span></code><span class="koboSpan" id="kobo.951.1"> function parameters without examining their data type inside the function, you should process them with statements that work on all data types; otherwise, your code may crash or misbehave. </span><span class="koboSpan" id="kobo.951.2">Alternatively, you can use generics with proper constraints to avoid any undesired effects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.952.1">The program that follows defines two structures named </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">S1</span></code><span class="koboSpan" id="kobo.954.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.955.1">S2</span></code><span class="koboSpan" id="kobo.956.1"> but just a single function named </span><code class="inlineCode"><span class="koboSpan" id="kobo.957.1">Print()</span></code><span class="koboSpan" id="kobo.958.1"> for printing any of them. </span><span class="koboSpan" id="kobo.958.2">This is allowed because </span><code class="inlineCode"><span class="koboSpan" id="kobo.959.1">Print()</span></code><span class="koboSpan" id="kobo.960.1"> requires an </span><code class="inlineCode"><span class="koboSpan" id="kobo.961.1">interface{}</span></code><span class="koboSpan" id="kobo.962.1"> parameter that can accept both </span><code class="inlineCode"><span class="koboSpan" id="kobo.963.1">S1</span></code><span class="koboSpan" id="kobo.964.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.965.1">S2</span></code><span class="koboSpan" id="kobo.966.1"> variables. </span><span class="koboSpan" id="kobo.966.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.967.1">fmt.Println(s)</span></code><span class="koboSpan" id="kobo.968.1"> statement inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.969.1">Print()</span></code><span class="koboSpan" id="kobo.970.1"> can work with both </span><code class="inlineCode"><span class="koboSpan" id="kobo.971.1">S1</span></code><span class="koboSpan" id="kobo.972.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.973.1">S2</span></code><span class="koboSpan" id="kobo.974.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.975.1">If you create a function that accepts one or more </span><code class="inlineCode"><span class="koboSpan" id="kobo.976.1">interface{}</span></code><span class="koboSpan" id="kobo.977.1"> parameters and you run a statement that can only be applied to a limited number of data types, things will not work out well. </span><span class="koboSpan" id="kobo.977.2">As an example, not all </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">interface{}</span></code><span class="koboSpan" id="kobo.979.1"> parameters can be multiplied by 5 or be used in </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.981.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">%d</span></code><span class="koboSpan" id="kobo.983.1"> control string.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.984.1">The source code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.985.1">empty.go</span></code><span class="koboSpan" id="kobo.986.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.987.1">package</span></span><span class="koboSpan" id="kobo.988.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.989.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.990.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.991.1">type</span></span><span class="koboSpan" id="kobo.992.1"> S1 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.993.1">struct</span></span><span class="koboSpan" id="kobo.994.1"> {
    F1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.995.1">int</span></span><span class="koboSpan" id="kobo.996.1">
    F2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.997.1">string</span></span><span class="koboSpan" id="kobo.998.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.999.1">type</span></span><span class="koboSpan" id="kobo.1000.1"> S2 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1001.1">struct</span></span><span class="koboSpan" id="kobo.1002.1"> {
    F1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.1003.1">int</span></span><span class="koboSpan" id="kobo.1004.1">
    F2 S1
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1005.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1006.1">Print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1007.1">(s </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1008.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1009.1">{})</span></span><span class="koboSpan" id="kobo.1010.1"> {
    fmt.Println(s)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1011.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1012.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1013.1">()</span></span><span class="koboSpan" id="kobo.1014.1"> {
    v1 := S1{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1015.1">10</span></span><span class="koboSpan" id="kobo.1016.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1017.1">"Hello"</span></span><span class="koboSpan" id="kobo.1018.1">}
    v2 := S2{F1: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1019.1">-1</span></span><span class="koboSpan" id="kobo.1020.1">, F2: v1}
    Print(v1)
    Print(v2)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1021.1">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.1022.1">v1</span></code><span class="koboSpan" id="kobo.1023.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1024.1">v2</span></code><span class="koboSpan" id="kobo.1025.1"> are of different data types, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1026.1">Print()</span></code><span class="koboSpan" id="kobo.1027.1"> can work with both of them.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1028.1">// Printing an integer</span></span><span class="koboSpan" id="kobo.1029.1">
    Print(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1030.1">123</span></span><span class="koboSpan" id="kobo.1031.1">)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1032.1">// Printing a string</span></span><span class="koboSpan" id="kobo.1033.1">
    Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1034.1">"Go is the best!"</span></span><span class="koboSpan" id="kobo.1035.1">)
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1036.1">Print()</span></code><span class="koboSpan" id="kobo.1037.1"> can also work with integers and strings.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1038.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1039.1">empty.go</span></code><span class="koboSpan" id="kobo.1040.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1041.1">{10 Hello}
{-1 {10 Hello}}
123
Go is the best!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1042.1">Using the empty interface is easy as soon as you realize that you can pass any type of variable in the place of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1043.1">interface{}</span></code><span class="koboSpan" id="kobo.1044.1"> parameter and you can return any data type as an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1045.1">interface{}</span></code><span class="koboSpan" id="kobo.1046.1"> return value. </span><span class="koboSpan" id="kobo.1046.2">However, with great power comes great responsibility—you should be very careful with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1047.1">interface{}</span></code><span class="koboSpan" id="kobo.1048.1"> parameters and their return values because, in</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.1049.1"> order</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.1050.1"> to use their real values, you have to be sure about their underlying data type. </span><span class="koboSpan" id="kobo.1050.2">We are going to discuss this in the next section.</span></p>
<h2 class="heading-2" id="_idParaDest-136"><span class="koboSpan" id="kobo.1051.1">Type assertions and type switches</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1052.1">A </span><em class="italic"><span class="koboSpan" id="kobo.1053.1">type assertion</span></em><span class="koboSpan" id="kobo.1054.1"> is a</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.1055.1"> mechanism for working with</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.1056.1"> the </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.1057.1">underlying concrete value of an interface. </span><span class="koboSpan" id="kobo.1057.2">This mainly happens because interfaces are virtual data types without their own values—interfaces just define behavior and do not hold data of their own. </span><span class="koboSpan" id="kobo.1057.3">But what happens when you do not know the data type before attempting a type assertion? </span><span class="koboSpan" id="kobo.1057.4">How can you differentiate between the supported data types and the unsupported ones? </span><span class="koboSpan" id="kobo.1057.5">How can you choose a different action for each supported data type? </span><span class="koboSpan" id="kobo.1057.6">The answer is by using type switches. </span><span class="koboSpan" id="kobo.1057.7">Type switches use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1058.1">switch</span></code><span class="koboSpan" id="kobo.1059.1"> blocks for data types and allow you to differentiate between type assertion values, which are data types, and process each data type the way you want. </span><span class="koboSpan" id="kobo.1059.2">Additionally, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1060.1">to use the empty interface in type switches, you need to use type assertions</span></strong><span class="koboSpan" id="kobo.1061.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1062.1">You can have type switches for all kinds of interfaces and data types in general. </span><span class="koboSpan" id="kobo.1062.2">What is really important is to remember that the order of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1063.1">case</span></code><span class="koboSpan" id="kobo.1064.1"> clauses in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1065.1">switch</span></code><span class="koboSpan" id="kobo.1066.1"> statement is important as only the first match is going to be executed.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1067.1">Therefore, the real work begins once you enter the function because this is where you need to define the supported data types and the actions that take place for each supported data type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1068.1">Type assertions use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">x.(T)</span></code><span class="koboSpan" id="kobo.1070.1"> notation, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">x</span></code><span class="koboSpan" id="kobo.1072.1"> is an interface type and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1073.1">T</span></code><span class="koboSpan" id="kobo.1074.1"> is a type, and help you extract the value that is hidden behind the empty interface. </span><span class="koboSpan" id="kobo.1074.2">For a type assertion to work, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">x</span></code><span class="koboSpan" id="kobo.1076.1"> should not be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">nil</span></code><span class="koboSpan" id="kobo.1078.1"> and the dynamic type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1079.1">x</span></code><span class="koboSpan" id="kobo.1080.1"> should be identical to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1081.1">T</span></code><span class="koboSpan" id="kobo.1082.1"> type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1083.1">The following code can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1084.1">typeSwitch.go</span></code><span class="koboSpan" id="kobo.1085.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1086.1">package</span></span><span class="koboSpan" id="kobo.1087.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1088.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1089.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1090.1">type</span></span><span class="koboSpan" id="kobo.1091.1"> Secret </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1092.1">struct</span></span><span class="koboSpan" id="kobo.1093.1"> {
    SecretValue </span><span class="hljs-type"><span class="koboSpan" id="kobo.1094.1">string</span></span><span class="koboSpan" id="kobo.1095.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1096.1">type</span></span><span class="koboSpan" id="kobo.1097.1"> Entry </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1098.1">struct</span></span><span class="koboSpan" id="kobo.1099.1"> {
    F1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.1100.1">int</span></span><span class="koboSpan" id="kobo.1101.1">
    F2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.1102.1">string</span></span><span class="koboSpan" id="kobo.1103.1">
    F3 Secret
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1104.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1105.1">Teststruct</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1106.1">(x </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1107.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1108.1">{})</span></span><span class="koboSpan" id="kobo.1109.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1110.1">// type switch</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1111.1">switch</span></span><span class="koboSpan" id="kobo.1112.1"> T := x.(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1113.1">type</span></span><span class="koboSpan" id="kobo.1114.1">) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1115.1">case</span></span><span class="koboSpan" id="kobo.1116.1"> Secret:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1117.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1118.1">Secret type"</span></span><span class="koboSpan" id="kobo.1119.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1120.1">case</span></span><span class="koboSpan" id="kobo.1121.1"> Entry:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1122.1">"Entry type"</span></span><span class="koboSpan" id="kobo.1123.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1124.1">default</span></span><span class="koboSpan" id="kobo.1125.1">:
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1126.1">"Not supported type: %T\n"</span></span><span class="koboSpan" id="kobo.1127.1">, T)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1128.1">This is a type switch with direct support for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1129.1">Secret</span></code><span class="koboSpan" id="kobo.1130.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1131.1">Entry</span></code><span class="koboSpan" id="kobo.1132.1"> data types only. </span><span class="koboSpan" id="kobo.1132.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1133.1">default</span></code><span class="koboSpan" id="kobo.1134.1"> case handles the remaining data types.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1135.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1136.1">Learn</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1137.1">(x </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1138.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1139.1">{})</span></span><span class="koboSpan" id="kobo.1140.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1141.1">switch</span></span><span class="koboSpan" id="kobo.1142.1"> T := x.(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1143.1">type</span></span><span class="koboSpan" id="kobo.1144.1">) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1145.1">default</span></span><span class="koboSpan" id="kobo.1146.1">:
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1147.1">"Data type: %T\n"</span></span><span class="koboSpan" id="kobo.1148.1">, T)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1149.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1150.1">Learn()</span></code><span class="koboSpan" id="kobo.1151.1"> function prints the data type of its </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.1152.1">input </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.1153.1">parameter.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1154.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1155.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1156.1">()</span></span><span class="koboSpan" id="kobo.1157.1"> {
    A := Entry{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1158.1">100</span></span><span class="koboSpan" id="kobo.1159.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1160.1">"F2"</span></span><span class="koboSpan" id="kobo.1161.1">, Secret{</span><span class="hljs-string"><span class="koboSpan" id="kobo.1162.1">"myPassword"</span></span><span class="koboSpan" id="kobo.1163.1">}}
    Teststruct(A)
    Teststruct(A.F3)
    Teststruct(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1164.1">"A string"</span></span><span class="koboSpan" id="kobo.1165.1">)
    Learn(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1166.1">12.23</span></span><span class="koboSpan" id="kobo.1167.1">)
    Learn(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1168.1">'€'</span></span><span class="koboSpan" id="kobo.1169.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1170.1">The last part of the code calls the desired functions to explore variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1171.1">A</span></code><span class="koboSpan" id="kobo.1172.1">. </span><span class="koboSpan" id="kobo.1172.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1173.1">typeSwitch.go</span></code><span class="koboSpan" id="kobo.1174.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1175.1">$ </span></span><span class="koboSpan" id="kobo.1176.1">go run typeSwitch.go
Entry type
Secret type
Not supported type: string
Data type: float64
Data type: int32
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1177.1">As you can see, we have managed to execute different code based on the data type of the variable passed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1178.1">TestStruct()</span></code><span class="koboSpan" id="kobo.1179.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1180.1">Learn()</span></code><span class="koboSpan" id="kobo.1181.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1182.1">Strictly speaking, type assertions allow you to perform two main tasks. </span><span class="koboSpan" id="kobo.1182.2">The first task is checking whether an interface value keeps a particular type. </span><span class="koboSpan" id="kobo.1182.3">When used this way, a type assertion returns two values: the underlying value and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1183.1">bool</span></code><span class="koboSpan" id="kobo.1184.1"> value. </span><span class="koboSpan" id="kobo.1184.2">The underlying value is what you might want to use. </span><span class="koboSpan" id="kobo.1184.3">However, it is the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1185.1">bool</span></code><span class="koboSpan" id="kobo.1186.1"> variable that tells you whether the type assertion was successful or not and, therefore, whether you can use the underlying value or not. </span><span class="koboSpan" id="kobo.1186.2">For example, checking whether a variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1187.1">aVar</span></code><span class="koboSpan" id="kobo.1188.1"> is of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1189.1">int</span></code><span class="koboSpan" id="kobo.1190.1"> type requires the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1191.1">aVar.(int)</span></code><span class="koboSpan" id="kobo.1192.1"> notation, which returns two values. </span><span class="koboSpan" id="kobo.1192.2">If successful, it returns the real </span><code class="inlineCode"><span class="koboSpan" id="kobo.1193.1">int</span></code><span class="koboSpan" id="kobo.1194.1"> value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1195.1">aVar</span></code><span class="koboSpan" id="kobo.1196.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1197.1">true</span></code><span class="koboSpan" id="kobo.1198.1">. </span><span class="koboSpan" id="kobo.1198.2">Otherwise, it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1199.1">false</span></code><span class="koboSpan" id="kobo.1200.1"> as the second value, which means that the type assertion was not successful and that the real value could not be extracted. </span><span class="koboSpan" id="kobo.1200.2">And the second task is using the concrete value stored in an interface or assigning it to a new variable. </span><span class="koboSpan" id="kobo.1200.3">This means that if there is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1201.1">float64</span></code><span class="koboSpan" id="kobo.1202.1"> variable in an interface, a type assertion allows you to get that value.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1203.1">The functionality offered by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1204.1">reflect</span></code><span class="koboSpan" id="kobo.1205.1"> package helps Go identify the underlying data type and the real value of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1206.1">interface{}</span></code><span class="koboSpan" id="kobo.1207.1"> variable.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1208.1">So far, we have seen a variation of the first case where we extract the data type stored in an empty interface variable. </span><span class="koboSpan" id="kobo.1208.2">Now, we are going to learn how to extract the real value stored in an empty </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.1209.1">interface variable. </span><span class="koboSpan" id="kobo.1209.2">As </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.1210.1">already </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.1211.1">explained, trying to extract the concrete value from an interface using a type assertion can have one of the following two outcomes:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1212.1">If you use the correct concrete data type, you get the underlying value without any issues.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1213.1">If you use an incorrect concrete data type, your program will panic.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1214.1">All these are illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1215.1">assertions.go</span></code><span class="koboSpan" id="kobo.1216.1">, which contains the next code as well as lots of code comments that explain the process.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1217.1">package</span></span><span class="koboSpan" id="kobo.1218.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1219.1">import</span></span><span class="koboSpan" id="kobo.1220.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1221.1">"fmt"</span></span><span class="koboSpan" id="kobo.1222.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1223.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1224.1">returnNumber</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1225.1">()</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1226.1">interface</span></span><span class="koboSpan" id="kobo.1227.1">{} {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1228.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1229.1">12</span></span><span class="koboSpan" id="kobo.1230.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1231.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1232.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1233.1">()</span></span><span class="koboSpan" id="kobo.1234.1"> {
    anInt := returnNumber()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1235.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1236.1">returnNumber()</span></code><span class="koboSpan" id="kobo.1237.1"> function returns an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1238.1">int</span></code><span class="koboSpan" id="kobo.1239.1"> value that is </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1240.1">wrapped in an empty interface</span></strong><span class="koboSpan" id="kobo.1241.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1242.1">    Number, ok := anInt.(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1243.1">int</span></span><span class="koboSpan" id="kobo.1244.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1245.1">if</span></span><span class="koboSpan" id="kobo.1246.1"> ok {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1247.1">"Type assertion successful: "</span></span><span class="koboSpan" id="kobo.1248.1">, number)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1249.1">else</span></span><span class="koboSpan" id="kobo.1250.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1251.1">"Type assertion failed!"</span></span><span class="koboSpan" id="kobo.1252.1">)
    }
    number++
    fmt.Println(number)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1253.1">In the previous code, we </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.1254.1">get the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1255.1">int</span></code><span class="koboSpan" id="kobo.1256.1"> value wrapped in </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.1257.1">an </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.1258.1">empty interface variable (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1259.1">anInt</span></code><span class="koboSpan" id="kobo.1260.1">).</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1261.1">// The next statement would fail because there</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1262.1">// is no type assertion to get the value:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1263.1">// anInt++</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1264.1">// The next statement fails but the failure is under </span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1265.1">// control because of the ok bool variable that tells</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1266.1">// whether the type assertion is successful or not</span></span><span class="koboSpan" id="kobo.1267.1">
    value, ok := anInt.(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1268.1">int64</span></span><span class="koboSpan" id="kobo.1269.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1270.1">if</span></span><span class="koboSpan" id="kobo.1271.1"> ok {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1272.1">"Type assertion successful: "</span></span><span class="koboSpan" id="kobo.1273.1">, value)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1274.1">else</span></span><span class="koboSpan" id="kobo.1275.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1276.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1277.1">Type assertion failed!"</span></span><span class="koboSpan" id="kobo.1278.1">)
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1279.1">// The next statement is successful but </span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1280.1">// dangerous because it does not make sure that</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1281.1">// the type assertion is successful.</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1282.1">// It just happens to be successful</span></span><span class="koboSpan" id="kobo.1283.1">
    i := anInt.(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1284.1">int</span></span><span class="koboSpan" id="kobo.1285.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1286.1">"i:"</span></span><span class="koboSpan" id="kobo.1287.1">, i)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1288.1">// The following will PANIC because anInt is not bool</span></span><span class="koboSpan" id="kobo.1289.1">
    _ = anInt.(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1290.1">bool</span></span><span class="koboSpan" id="kobo.1291.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1292.1">The last statement panics the program because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1293.1">anInt</span></code><span class="koboSpan" id="kobo.1294.1"> variable does not hold a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1295.1">bool</span></code><span class="koboSpan" id="kobo.1296.1"> value. </span><span class="koboSpan" id="kobo.1296.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1297.1">assertions.go</span></code><span class="koboSpan" id="kobo.1298.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1299.1">$ </span></span><span class="koboSpan" id="kobo.1300.1">go run assertions.go
13
Type assertion failed!
</span><span class="koboSpan" id="kobo.1300.2">i: 12
panic: interface conversion: interface {} is int, not bool
goroutine 1 [running]:
main.main()
    /Users/mtsouk/mGo4th/code/ch05/assertions.go:39 +0x130
exit status 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1301.1">The reason for</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.1302.1"> the panic is written onscreen: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1303.1">panic: interface conversion: interface {} is int, not bool</span></code><span class="koboSpan" id="kobo.1304.1">. </span><span class="koboSpan" id="kobo.1304.2">What else can the Go</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.1305.1"> compiler</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.1306.1"> do to help you?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1307.1">Next, we discuss the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1308.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1309.1"> map and its use.</span></p>
<h2 class="heading-2" id="_idParaDest-137"><span class="koboSpan" id="kobo.1310.1">The map[string]interface{} map</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1311.1">You have a utility </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.1312.1">that processes its command line </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.1313.1">arguments; if everything goes as expected, then you get the supported types of command line arguments and everything goes smoothly. </span><span class="koboSpan" id="kobo.1313.2">But what happens when something unexpected occurs? </span><span class="koboSpan" id="kobo.1313.3">In that case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1314.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1315.1"> map is here to help, and this subsection shows how! </span><span class="koboSpan" id="kobo.1315.2">This is just one of the cases where the handy </span><code class="inlineCode"><span class="koboSpan" id="kobo.1316.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1317.1"> map can be used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1318.1">Remember that the biggest advantage you get from using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1319.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1320.1"> map, or any map that stores an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1321.1">interface{}</span></code><span class="koboSpan" id="kobo.1322.1"> value in general, is that you still have your data in its original state and data type. </span><span class="koboSpan" id="kobo.1322.2">If you use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1323.1">map[string]string</span></code><span class="koboSpan" id="kobo.1324.1"> instead, or anything similar, then any data you have is going to be converted into a string, which means that you are going to lose information about the original data type and the structure of the data you are storing in the map.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1325.1">Nowadays, web services work by exchanging JSON records. </span><span class="koboSpan" id="kobo.1325.2">If you get a JSON record in an anticipated format, then you can process it as expected and everything will be fine. </span><span class="koboSpan" id="kobo.1325.3">However, there are times when you might get an erroneous record or a record in an unsupported JSON format. </span><span class="koboSpan" id="kobo.1325.4">In these cases, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1326.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1327.1"> for storing these unknown JSON records (arbitrary data) is a good choice because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1328.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1329.1"> is good at storing JSON records of unknown types. </span><span class="koboSpan" id="kobo.1329.2">We are going to illustrate that using a utility named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1330.1">mapEmpty.go</span></code><span class="koboSpan" id="kobo.1331.1"> that processes arbitrary JSON records given as command line arguments. </span><span class="koboSpan" id="kobo.1331.2">We process the input JSON record in two ways that are similar but not identical. </span><span class="koboSpan" id="kobo.1331.3">There is no real difference between the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1332.1">exploreMap()</span></code><span class="koboSpan" id="kobo.1333.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1334.1">typeSwitch()</span></code><span class="koboSpan" id="kobo.1335.1"> functions apart from the fact that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1336.1">typeSwitch()</span></code><span class="koboSpan" id="kobo.1337.1"> generates a much richer output. </span><span class="koboSpan" id="kobo.1337.2">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1338.1">mapEmpty.go</span></code><span class="koboSpan" id="kobo.1339.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1340.1">package</span></span><span class="koboSpan" id="kobo.1341.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1342.1">import</span></span><span class="koboSpan" id="kobo.1343.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1344.1">"encoding/json"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1345.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1346.1">"os"</span></span><span class="koboSpan" id="kobo.1347.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1348.1">var</span></span><span class="koboSpan" id="kobo.1349.1"> JSONrecord = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1350.1">`{</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1351.1">    "Flag": true,</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1352.1">    "Array": ["a","b","c"],</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1353.1">    "Entity": {</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1354.1">      "a1": "b1",</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1355.1">      "a2": "b2",</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1356.1">      "Value": -456,</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1357.1">      "Null": null</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1358.1">    },</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1359.1">    "Message": "Hello Go!"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1360.1">  }`</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1361.1">This global variable </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.1362.1">holds the default value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1363.1">JSONrecord</span></code><span class="koboSpan" id="kobo.1364.1">, in</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.1365.1"> case there is no user input.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1366.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1367.1">typeSwitch</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1368.1">(m </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1369.1">map</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1370.1">[</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1371.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1372.1">]</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1373.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1374.1">{})</span></span><span class="koboSpan" id="kobo.1375.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1376.1">for</span></span><span class="koboSpan" id="kobo.1377.1"> k, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1378.1">range</span></span><span class="koboSpan" id="kobo.1379.1"> m {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1380.1">switch</span></span><span class="koboSpan" id="kobo.1381.1"> c := v.(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1382.1">type</span></span><span class="koboSpan" id="kobo.1383.1">) {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1384.1">case</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1385.1">string</span></span><span class="koboSpan" id="kobo.1386.1">:
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1387.1">"Is a string!"</span></span><span class="koboSpan" id="kobo.1388.1">, k, c)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1389.1">case</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1390.1">float64</span></span><span class="koboSpan" id="kobo.1391.1">:
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1392.1">"Is a float64!"</span></span><span class="koboSpan" id="kobo.1393.1">, k, c)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1394.1">case</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1395.1">bool</span></span><span class="koboSpan" id="kobo.1396.1">:
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1397.1">"Is a Boolean!"</span></span><span class="koboSpan" id="kobo.1398.1">, k, c)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1399.1">case</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1400.1">map</span></span><span class="koboSpan" id="kobo.1401.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1402.1">string</span></span><span class="koboSpan" id="kobo.1403.1">]</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1404.1">interface</span></span><span class="koboSpan" id="kobo.1405.1">{}:
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1406.1">"Is a map!"</span></span><span class="koboSpan" id="kobo.1407.1">, k, c)
            typeSwitch(v.(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1408.1">map</span></span><span class="koboSpan" id="kobo.1409.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1410.1">string</span></span><span class="koboSpan" id="kobo.1411.1">]</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1412.1">interface</span></span><span class="koboSpan" id="kobo.1413.1">{}))
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1414.1">default</span></span><span class="koboSpan" id="kobo.1415.1">:
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1416.1">"...Is %v: %T!\n"</span></span><span class="koboSpan" id="kobo.1417.1">, k, c)
        }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1418.1">return</span></span><span class="koboSpan" id="kobo.1419.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1420.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1421.1">typeSwitch()</span></code><span class="koboSpan" id="kobo.1422.1"> function uses a type switch for differentiating between the values in its input map. </span><span class="koboSpan" id="kobo.1422.2">If a map is found, then we recursively call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1423.1">typeSwitch()</span></code><span class="koboSpan" id="kobo.1424.1"> on the new map in order to examine it even more. </span><span class="koboSpan" id="kobo.1424.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1425.1">for</span></code><span class="koboSpan" id="kobo.1426.1"> loop allows you to examine all the elements of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1427.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1428.1"> map.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1429.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1430.1">exploreMap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1431.1">(m </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1432.1">map</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1433.1">[</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1434.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1435.1">]</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1436.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1437.1">{})</span></span><span class="koboSpan" id="kobo.1438.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1439.1">for</span></span><span class="koboSpan" id="kobo.1440.1"> k, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1441.1">range</span></span><span class="koboSpan" id="kobo.1442.1"> m {
        embMap, ok := v.(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1443.1">map</span></span><span class="koboSpan" id="kobo.1444.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1445.1">string</span></span><span class="koboSpan" id="kobo.1446.1">]</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1447.1">interface</span></span><span class="koboSpan" id="kobo.1448.1">{})
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1449.1">// If it is a map, explore deeper</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1450.1">if</span></span><span class="koboSpan" id="kobo.1451.1"> ok {
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1452.1">"{\"%v\": \n"</span></span><span class="koboSpan" id="kobo.1453.1">, k)
            exploreMap(embMap)
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1454.1">"}\n"</span></span><span class="koboSpan" id="kobo.1455.1">)
        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1456.1">else</span></span><span class="koboSpan" id="kobo.1457.1"> {
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1458.1">"%v: %v\n"</span></span><span class="koboSpan" id="kobo.1459.1">, k, v)
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1460.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1461.1">exploreMap()</span></code><span class="koboSpan" id="kobo.1462.1"> function inspects the contents of its input map. </span><span class="koboSpan" id="kobo.1462.2">If a map is found, then we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1463.1">exploreMap()</span></code><span class="koboSpan" id="kobo.1464.1"> on </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.1465.1">the new map recursively in order to</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.1466.1"> examine it on its own.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1467.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1468.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1469.1">()</span></span><span class="koboSpan" id="kobo.1470.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1471.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1472.1">len</span></span><span class="koboSpan" id="kobo.1473.1">(os.Args) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1474.1">1</span></span><span class="koboSpan" id="kobo.1475.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1476.1">"*** Using default JSON record."</span></span><span class="koboSpan" id="kobo.1477.1">)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1478.1">else</span></span><span class="koboSpan" id="kobo.1479.1"> {
        JSONrecord = os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1480.1">1</span></span><span class="koboSpan" id="kobo.1481.1">]
    }
    JSONMap := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1482.1">make</span></span><span class="koboSpan" id="kobo.1483.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1484.1">map</span></span><span class="koboSpan" id="kobo.1485.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1486.1">string</span></span><span class="koboSpan" id="kobo.1487.1">]</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1488.1">interface</span></span><span class="koboSpan" id="kobo.1489.1">{})
    err := json.Unmarshal([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1490.1">byte</span></span><span class="koboSpan" id="kobo.1491.1">(JSONrecord), &amp;JSONMap)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1492.1">As you will learn in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1493.1">Chapter 7</span></em><span class="koboSpan" id="kobo.1494.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1495.1">Telling a UNIX System What To Do</span></em><span class="koboSpan" id="kobo.1496.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1497.1">json.Unmarshal()</span></code><span class="koboSpan" id="kobo.1498.1"> processes JSON data and converts it into a Go value. </span><span class="koboSpan" id="kobo.1498.2">Although this value is usually a Go structure, in this case, we are using a map as specified by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1499.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1500.1"> variable. </span><span class="koboSpan" id="kobo.1500.2">Strictly speaking, the second parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1501.1">json.Unmarshal()</span></code><span class="koboSpan" id="kobo.1502.1"> is of the empty interface data type, which means that its data type can be anything.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1503.1">if</span></span><span class="koboSpan" id="kobo.1504.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1505.1">nil</span></span><span class="koboSpan" id="kobo.1506.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1507.1">return</span></span><span class="koboSpan" id="kobo.1508.1">
    }
    exploreMap(JSONMap)
    typeSwitch(JSONMap)
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1509.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1510.1"> is extremely handy for storing JSON records when you do not know their schema in advance. </span><span class="koboSpan" id="kobo.1510.2">In other words, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1511.1">map[string]interface{}</span></code><span class="koboSpan" id="kobo.1512.1"> is good at </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1513.1">storing arbitrary JSON data of unknown schema</span></strong><span class="koboSpan" id="kobo.1514.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1515.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1516.1">mapEmpty.go</span></code><span class="koboSpan" id="kobo.1517.1"> produces</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.1518.1"> the following output—bear in </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.1519.1">mind that you might see a different output since maps do not guarantee order:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1520.1">$ </span></span><span class="koboSpan" id="kobo.1521.1">go run mapEmpty.go 
*** Using default JSON record.
</span><span class="koboSpan" id="kobo.1521.2">Flag: true
Array: [a b c]
{"Entity":
a2: b2
Value: -456
Null: &lt;nil&gt;
a1: b1
}
Message: Hello Go!
</span><span class="koboSpan" id="kobo.1521.3">...Is Array: []interface {}!
</span><span class="koboSpan" id="kobo.1521.4">Is a map! </span><span class="koboSpan" id="kobo.1521.5">Entity map[Null:&lt;nil&gt; Value:-456 a1:b1 a2:b2]
Is a float64! </span><span class="koboSpan" id="kobo.1521.6">Value -456
...Is Null: &lt;nil&gt;!
</span><span class="koboSpan" id="kobo.1521.7">Is a string! </span><span class="koboSpan" id="kobo.1521.8">a1 b1
Is a string! </span><span class="koboSpan" id="kobo.1521.9">a2 b2
Is a string! </span><span class="koboSpan" id="kobo.1521.10">Message Hello Go!
</span><span class="koboSpan" id="kobo.1521.11">Is a Boolean! </span><span class="koboSpan" id="kobo.1521.12">Flag true
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1522.1">$ </span></span><span class="koboSpan" id="kobo.1523.1">go run mapEmpty.go </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.1524.1">'{"Array": [3, 4], "Null": null, "String": "Hello Go!"}'</span></span><span class="koboSpan" id="kobo.1525.1">
Array: [3 4]
Null: &lt;nil&gt;
String: Hello Go!
</span><span class="koboSpan" id="kobo.1525.2">...Is Array: []interface {}!
</span><span class="koboSpan" id="kobo.1525.3">...Is Null: &lt;nil&gt;!
</span><span class="koboSpan" id="kobo.1525.4">Is a string! </span><span class="koboSpan" id="kobo.1525.5">String Hello Go!
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1526.1">$ </span></span><span class="koboSpan" id="kobo.1527.1">go run mapEmpty.go </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.1528.1">'{"Array":"Error"'</span></span><span class="koboSpan" id="kobo.1529.1"> 
unexpected end of JSON input
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1530.1">The first run is without any command line parameters, which means that the utility uses the default value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1531.1">JSONrecord</span></code><span class="koboSpan" id="kobo.1532.1"> and therefore outputs the hardcoded data. </span><span class="koboSpan" id="kobo.1532.2">The other two executions use user-specified data. </span><span class="koboSpan" id="kobo.1532.3">First, valid data, and then data that does not represent a valid JSON record. </span><span class="koboSpan" id="kobo.1532.4">The error message in the third execution is generated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1533.1">json.Unmarshal()</span></code><span class="koboSpan" id="kobo.1534.1"> as </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.1535.1">it cannot understand the schema of the</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.1536.1"> erroneous JSON record.</span></p>
<h2 class="heading-2" id="_idParaDest-138"><span class="koboSpan" id="kobo.1537.1">The error data type</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1538.1">As promised, we are </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.1539.1">revisiting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1540.1">error</span></code><span class="koboSpan" id="kobo.1541.1"> data type because it is an</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.1542.1"> interface defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1543.1">type</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1544.1">error</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1545.1">interface</span></span><span class="koboSpan" id="kobo.1546.1"> {
    Error() </span><span class="hljs-type"><span class="koboSpan" id="kobo.1547.1">string</span></span><span class="koboSpan" id="kobo.1548.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1549.1">So, in order to satisfy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1550.1">error</span></code><span class="koboSpan" id="kobo.1551.1"> interface, you just need to implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1552.1">Error()</span></code><span class="koboSpan" id="kobo.1553.1"> string type method. </span><span class="koboSpan" id="kobo.1553.2">This does not change the way we use errors to find out whether the execution of a function or method was successful or not but shows how important interfaces are in Go as they are used transparently all the time. </span><span class="koboSpan" id="kobo.1553.3">However, the crucial question is when you should implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1554.1">error</span></code><span class="koboSpan" id="kobo.1555.1"> interface on your own instead of using the default one. </span><span class="koboSpan" id="kobo.1555.2">The answer to that question is when you want to give more context to an error condition.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1556.1">Now, let us talk about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1557.1">error</span></code><span class="koboSpan" id="kobo.1558.1"> interface in a more practical situation. </span><span class="koboSpan" id="kobo.1558.2">When there is nothing more to read from a file, Go returns an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1559.1">io.EOF</span></code><span class="koboSpan" id="kobo.1560.1"> error, which, strictly speaking, is not an error condition but a logical part of reading a file. </span><span class="koboSpan" id="kobo.1560.2">If a file is totally empty, you still get </span><code class="inlineCode"><span class="koboSpan" id="kobo.1561.1">io.EOF</span></code><span class="koboSpan" id="kobo.1562.1"> when you try to read it for the first time. </span><span class="koboSpan" id="kobo.1562.2">However, this might cause problems in some situations, and you might need to have a way of differentiating between a totally empty file and a file that has been read fully and there is nothing more to read. </span><span class="koboSpan" id="kobo.1562.3">One way of dealing with that issue is with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1563.1">error</span></code><span class="koboSpan" id="kobo.1564.1"> interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1565.1">The code example that is presented here is connected to file I/O. </span><span class="koboSpan" id="kobo.1565.2">Putting it here might generate some questions about reading files in Go—however, I feel that this is the appropriate place to put it because it is connected to errors and error handling more than it is connected to file reading in Go.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1566.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1567.1">errorInt.go</span></code><span class="koboSpan" id="kobo.1568.1"> without the package and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1569.1">import</span></code><span class="koboSpan" id="kobo.1570.1"> blocks is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1571.1">type</span></span><span class="koboSpan" id="kobo.1572.1"> emptyFile </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1573.1">struct</span></span><span class="koboSpan" id="kobo.1574.1"> {
    Ended </span><span class="hljs-type"><span class="koboSpan" id="kobo.1575.1">bool</span></span><span class="koboSpan" id="kobo.1576.1">
    Read  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1577.1">int</span></span><span class="koboSpan" id="kobo.1578.1">
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1579.1">emptyFile</span></code><span class="koboSpan" id="kobo.1580.1"> is a new data type that is used in the program.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1581.1">// Implement error interface</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1582.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1583.1">(e emptyFile)</span></span><span class="koboSpan" id="kobo.1584.1"> Error() </span><span class="hljs-type"><span class="koboSpan" id="kobo.1585.1">string</span></span><span class="koboSpan" id="kobo.1586.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1587.1">return</span></span><span class="koboSpan" id="kobo.1588.1"> fmt.Sprintf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1589.1">"Ended with io.EOF (%t) but read (%d) bytes"</span></span><span class="koboSpan" id="kobo.1590.1">, e.Ended, e.Read)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1591.1">This is the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1592.1">error</span></code><span class="koboSpan" id="kobo.1593.1"> interface for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1594.1">emptyFile</span></code><span class="koboSpan" id="kobo.1595.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1596.1">// Check values</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1597.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1598.1">isFileEmpty</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1599.1">(e </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1600.1">error</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1601.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1602.1">bool</span></span><span class="koboSpan" id="kobo.1603.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1604.1">// Type assertion</span></span><span class="koboSpan" id="kobo.1605.1">
    v, ok := e.(emptyFile)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1606.1">This is a type </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.1607.1">assertion </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.1608.1">for getting an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1609.1">emptyFile</span></code><span class="koboSpan" id="kobo.1610.1"> structure from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1611.1">error</span></code><span class="koboSpan" id="kobo.1612.1"> variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1613.1">if</span></span><span class="koboSpan" id="kobo.1614.1"> ok {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1615.1">if</span></span><span class="koboSpan" id="kobo.1616.1"> v.Read == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1617.1">0</span></span><span class="koboSpan" id="kobo.1618.1"> &amp;&amp; v.Ended == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1619.1">true</span></span><span class="koboSpan" id="kobo.1620.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1621.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1622.1">true</span></span><span class="koboSpan" id="kobo.1623.1">
        }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1624.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1625.1">false</span></span><span class="koboSpan" id="kobo.1626.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1627.1">This is a method for checking whether a file is empty or not. </span><span class="koboSpan" id="kobo.1627.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1628.1">if</span></code><span class="koboSpan" id="kobo.1629.1"> condition translates as: If you have read zero bytes (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1630.1">v.Read == 0</span></code><span class="koboSpan" id="kobo.1631.1">) and you have reached the end of the file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1632.1">v.Ended == true</span></code><span class="koboSpan" id="kobo.1633.1">), then the file is empty.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1634.1">If you want to deal with multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.1635.1">error</span></code><span class="koboSpan" id="kobo.1636.1"> variables, you should add a type switch to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1637.1">isFileEmpty()</span></code><span class="koboSpan" id="kobo.1638.1"> function after the type assertion.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1639.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1640.1">readFile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1641.1">(file </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1642.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1643.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1644.1">error</span></span><span class="koboSpan" id="kobo.1645.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1646.1">var</span></span><span class="koboSpan" id="kobo.1647.1"> err </span><span class="hljs-type"><span class="koboSpan" id="kobo.1648.1">error</span></span><span class="koboSpan" id="kobo.1649.1">
    fd, err := os.Open(file)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1650.1">if</span></span><span class="koboSpan" id="kobo.1651.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1652.1">nil</span></span><span class="koboSpan" id="kobo.1653.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1654.1">return</span></span><span class="koboSpan" id="kobo.1655.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1656.1">defer</span></span><span class="koboSpan" id="kobo.1657.1"> fd.Close()
    reader := bufio.NewReader(fd)
    n := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1658.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1659.1">for</span></span><span class="koboSpan" id="kobo.1660.1"> {
        line, err := reader.ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1661.1">'\n'</span></span><span class="koboSpan" id="kobo.1662.1">)
        n += </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1663.1">len</span></span><span class="koboSpan" id="kobo.1664.1">(line)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1665.1">We read the input file line by line—you are going to learn more about file I/O in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1666.1">Chapter 7</span></em><span class="koboSpan" id="kobo.1667.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1668.1">Telling a UNIX System What to Do</span></em><span class="koboSpan" id="kobo.1669.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1670.1">if</span></span><span class="koboSpan" id="kobo.1671.1"> err == io.EOF {
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1672.1">// End of File: nothing more to read</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1673.1">if</span></span><span class="koboSpan" id="kobo.1674.1"> n == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1675.1">0</span></span><span class="koboSpan" id="kobo.1676.1"> {
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1677.1">return</span></span><span class="koboSpan" id="kobo.1678.1"> emptyFile{</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1679.1">true</span></span><span class="koboSpan" id="kobo.1680.1">, n}
            }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1681.1">If we have reached the end of a file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1682.1">io.EOF</span></code><span class="koboSpan" id="kobo.1683.1">) and we have read zero characters, then we are dealing with </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.1684.1">an</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.1685.1"> empty file. </span><span class="koboSpan" id="kobo.1685.2">This kind of context is added to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1686.1">emptyFile</span></code><span class="koboSpan" id="kobo.1687.1"> structure and returned as an error value.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1688.1">break</span></span><span class="koboSpan" id="kobo.1689.1">
        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1690.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1691.1">if</span></span><span class="koboSpan" id="kobo.1692.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1693.1">nil</span></span><span class="koboSpan" id="kobo.1694.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1695.1">return</span></span><span class="koboSpan" id="kobo.1696.1"> err
        }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1697.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1698.1">nil</span></span><span class="koboSpan" id="kobo.1699.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1700.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1701.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1702.1">()</span></span><span class="koboSpan" id="kobo.1703.1"> {
    flag.Parse()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1704.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1705.1">len</span></span><span class="koboSpan" id="kobo.1706.1">(flag.Args()) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1707.1">0</span></span><span class="koboSpan" id="kobo.1708.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1709.1">"usage: errorInt &lt;file1&gt; [&lt;file2&gt; ...]"</span></span><span class="koboSpan" id="kobo.1710.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1711.1">return</span></span><span class="koboSpan" id="kobo.1712.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1713.1">for</span></span><span class="koboSpan" id="kobo.1714.1"> _, file := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1715.1">range</span></span><span class="koboSpan" id="kobo.1716.1"> flag.Args() {
        err := readFile(file)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1717.1">if</span></span><span class="koboSpan" id="kobo.1718.1"> isFileEmpty(err) {
            fmt.Println(file, err)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1719.1">This is where we check the error message of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1720.1">readFile()</span></code><span class="koboSpan" id="kobo.1721.1"> function. </span><span class="koboSpan" id="kobo.1721.2">The order we do the checking in is important because only the first match is executed. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1722.1">This means that we must go from more specific cases to more generic ones</span></strong><span class="koboSpan" id="kobo.1723.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1724.1">        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1725.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1726.1">if</span></span><span class="koboSpan" id="kobo.1727.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1728.1">nil</span></span><span class="koboSpan" id="kobo.1729.1"> {
            fmt.Println(file, err)
        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1730.1">else</span></span><span class="koboSpan" id="kobo.1731.1"> {
            fmt.Println(file, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1732.1">"is OK."</span></span><span class="koboSpan" id="kobo.1733.1">)
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1734.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1735.1">errorInt.go</span></code><span class="koboSpan" id="kobo.1736.1"> produces the following output—your output might differ:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1737.1">$ </span></span><span class="koboSpan" id="kobo.1738.1">go run errorInt.go /etc/hosts /tmp/doesNotExist /tmp/empty /tmp /tmp/Empty.txt
/etc/hosts is OK.
</span><span class="koboSpan" id="kobo.1738.2">/tmp/doesNotExist open /tmp/doesNotExist: no such file or directory
/tmp/empty open /tmp/empty: permission denied
/tmp read /tmp: is a directory
/tmp/Empty.txt Ended with io.EOF (true) but read (0) bytes
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1739.1">The first file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1740.1">/etc/hosts</span></code><span class="koboSpan" id="kobo.1741.1">) was read without any issues, whereas the second file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1742.1">/tmp/doesNotExist</span></code><span class="koboSpan" id="kobo.1743.1">) could not be found. </span><span class="koboSpan" id="kobo.1743.2">The third file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1744.1">/tmp/empty</span></code><span class="koboSpan" id="kobo.1745.1">) was there but we did not have the required file permissions to read it, whereas the fourth file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1746.1">/tmp</span></code><span class="koboSpan" id="kobo.1747.1">) was, in reality, a </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.1748.1">directory. </span><span class="koboSpan" id="kobo.1748.2">The last file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1749.1">/tmp/Empty.txt</span></code><span class="koboSpan" id="kobo.1750.1">) was there but was empty, which</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.1751.1"> is the error situation that we wanted to catch in the first place.</span></p>
<h2 class="heading-2" id="_idParaDest-139"><span class="koboSpan" id="kobo.1752.1">Writing your own interfaces</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1753.1">In this section, we</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.1754.1"> are going to learn how to write our own interfaces. </span><span class="koboSpan" id="kobo.1754.2">Creating your own interfaces is easy. </span><span class="koboSpan" id="kobo.1754.3">For reasons of simplicity, we include our own interface in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1755.1">main</span></code><span class="koboSpan" id="kobo.1756.1"> package. </span><span class="koboSpan" id="kobo.1756.2">However, this is rarely the case as we usually want to share our interfaces, which means that interfaces are usually included in Go packages other than </span><code class="inlineCode"><span class="koboSpan" id="kobo.1757.1">main</span></code><span class="koboSpan" id="kobo.1758.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1759.1">The following code excerpt defines a new interface.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1760.1">type</span></span><span class="koboSpan" id="kobo.1761.1"> Shape2D </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1762.1">interface</span></span><span class="koboSpan" id="kobo.1763.1"> {
    Perimeter() </span><span class="hljs-type"><span class="koboSpan" id="kobo.1764.1">float64</span></span><span class="koboSpan" id="kobo.1765.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1766.1">This interface has the following properties:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1767.1">It is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1768.1">Shape2D</span></code><span class="koboSpan" id="kobo.1769.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1770.1">It requires the implementation of a single method named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1771.1">Perimeter()</span></code><span class="koboSpan" id="kobo.1772.1"> that returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1773.1">float64</span></code><span class="koboSpan" id="kobo.1774.1"> value.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1775.1">Apart from being user-defined, there is nothing special about that interface compared to the built-in Go interfaces—you can use it as you do all other existing interfaces. </span><span class="koboSpan" id="kobo.1775.2">So, in order for a data type</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.1776.1"> to satisfy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1777.1">Shape2D</span></code><span class="koboSpan" id="kobo.1778.1"> interface, it needs to implement a type method named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1779.1">Perimeter()</span></code><span class="koboSpan" id="kobo.1780.1"> that returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1781.1">float64</span></code><span class="koboSpan" id="kobo.1782.1"> value.</span></p>
<h3 class="heading-3" id="_idParaDest-140"><span class="koboSpan" id="kobo.1783.1">Using a Go interface</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1784.1">The code that follows</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.1785.1"> presents the simplest way of using an interface, which is by calling its method directly, as if it were a function, to get a result. </span><span class="koboSpan" id="kobo.1785.2">Although this is allowed, it is rarely the case as we usually create functions that accept interface parameters in order for these functions to be able to work with multiple data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1786.1">The code uses a handy technique for quickly finding out whether a given variable is of a given data type that was presented earlier in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1787.1">assertions.go</span></code><span class="koboSpan" id="kobo.1788.1">. </span><span class="koboSpan" id="kobo.1788.2">In this case, we examine whether a variable is of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1789.1">Shape2D</span></code><span class="koboSpan" id="kobo.1790.1"> interface by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1791.1">interface{}(a).(Shape2D)</span></code><span class="koboSpan" id="kobo.1792.1"> notation, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1793.1">a</span></code><span class="koboSpan" id="kobo.1794.1"> is the variable that is being examined and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1795.1">Shape2D</span></code><span class="koboSpan" id="kobo.1796.1"> is the data type against the variable being checked.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1797.1">The next program is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1798.1">Shape2D.go</span></code><span class="koboSpan" id="kobo.1799.1">—its most interesting parts are the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1800.1">type</span></span><span class="koboSpan" id="kobo.1801.1"> Shape2D </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1802.1">interface</span></span><span class="koboSpan" id="kobo.1803.1"> {
    Perimeter() </span><span class="hljs-type"><span class="koboSpan" id="kobo.1804.1">float64</span></span><span class="koboSpan" id="kobo.1805.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1806.1">This is the definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1807.1">Shape2D</span></code><span class="koboSpan" id="kobo.1808.1"> interface that requires the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1809.1">Perimeter()</span></code><span class="koboSpan" id="kobo.1810.1"> type method.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1811.1">type</span></span><span class="koboSpan" id="kobo.1812.1"> circle </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1813.1">struct</span></span><span class="koboSpan" id="kobo.1814.1"> {
    R </span><span class="hljs-type"><span class="koboSpan" id="kobo.1815.1">float64</span></span><span class="koboSpan" id="kobo.1816.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1817.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1818.1">(c circle)</span></span><span class="koboSpan" id="kobo.1819.1"> Perimeter() </span><span class="hljs-type"><span class="koboSpan" id="kobo.1820.1">float64</span></span><span class="koboSpan" id="kobo.1821.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1822.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1823.1">2</span></span><span class="koboSpan" id="kobo.1824.1"> * math.Pi * c.R
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1825.1">This is where the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1826.1">circle</span></code><span class="koboSpan" id="kobo.1827.1"> type implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1828.1">Shape2D</span></code><span class="koboSpan" id="kobo.1829.1"> interface with the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1830.1">Perimeter()</span></code><span class="koboSpan" id="kobo.1831.1"> type method.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1832.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1833.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1834.1">()</span></span><span class="koboSpan" id="kobo.1835.1"> {
    a := circle{R: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1836.1">1.5</span></span><span class="koboSpan" id="kobo.1837.1">}
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1838.1">"R %.2f -&gt; Perimeter %.3f \n"</span></span><span class="koboSpan" id="kobo.1839.1">, a.R, a.Perimeter())
    _, ok := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1840.1">interface</span></span><span class="koboSpan" id="kobo.1841.1">{}(a).(Shape2D)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1842.1">if</span></span><span class="koboSpan" id="kobo.1843.1"> ok {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1844.1">"a is a Shape2D!"</span></span><span class="koboSpan" id="kobo.1845.1">)
    }
    i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1846.1">12</span></span><span class="koboSpan" id="kobo.1847.1">
    _, ok = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1848.1">interface</span></span><span class="koboSpan" id="kobo.1849.1">{}(i).(Shape2D)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1850.1">if</span></span><span class="koboSpan" id="kobo.1851.1"> ok {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1852.1">"i is a Shape2D!"</span></span><span class="koboSpan" id="kobo.1853.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1854.1">As stated before, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1855.1">interface{}(a).(Shape2D)</span></code><span class="koboSpan" id="kobo.1856.1"> notation checks whether the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1857.1">a</span></code><span class="koboSpan" id="kobo.1858.1"> variable satisfies the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1859.1">Shape2D</span></code><span class="koboSpan" id="kobo.1860.1"> interface without using its underlying value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1861.1">circle{R: 1.5}</span></code><span class="koboSpan" id="kobo.1862.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1863.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1864.1">Shape2D.go</span></code><span class="koboSpan" id="kobo.1865.1"> creates</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.1866.1"> the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1867.1">R 1.50 -&gt; Perimeter 9.425 
a is a Shape2D!
</span></code></pre>
<h1 class="heading-1" id="_idParaDest-141"><span class="koboSpan" id="kobo.1868.1">Object-oriented programming in Go</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1869.1">As Go does not </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.1870.1">support all object-oriented features, it cannot replace</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.1871.1"> an object-oriented programming language fully. </span><span class="koboSpan" id="kobo.1871.2">However, it can mimic some object-oriented concepts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1872.1">First, a Go structure with its type methods is like an object with its methods. </span><span class="koboSpan" id="kobo.1872.2">Second, interfaces are like abstract data types that define behaviors and objects of the same class, which is similar to polymorphism. </span><span class="koboSpan" id="kobo.1872.3">Third, Go supports encapsulation, which means it supports hiding data and functions from the user by making them private to the structure and the current Go package. </span><span class="koboSpan" id="kobo.1872.4">Last, combining interfaces and structures is like composition in object-oriented terminology.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1873.1">If you really want to develop applications using the object-oriented methodology, then choosing Go might not be your best option. </span><span class="koboSpan" id="kobo.1873.2">As I am not really into Java, I would suggest looking at C++ or Python instead. </span><span class="koboSpan" id="kobo.1873.3">The general rule here is to choose the best tool for your job.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1874.1">You have already seen some of these points earlier in this chapter—the next chapter discusses how to define private fields and functions. </span><span class="koboSpan" id="kobo.1874.2">The example that follows, which is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1875.1">objO.go</span></code><span class="koboSpan" id="kobo.1876.1">, illustrates composition and polymorphism as well as embedding an anonymous structure into an existing one to get all its fields.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1877.1">package</span></span><span class="koboSpan" id="kobo.1878.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1879.1">import</span></span><span class="koboSpan" id="kobo.1880.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1881.1">"fmt"</span></span><span class="koboSpan" id="kobo.1882.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1883.1">type</span></span><span class="koboSpan" id="kobo.1884.1"> IntA </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1885.1">interface</span></span><span class="koboSpan" id="kobo.1886.1"> {
    foo()
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1887.1">type</span></span><span class="koboSpan" id="kobo.1888.1"> IntB </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1889.1">interface</span></span><span class="koboSpan" id="kobo.1890.1"> {
    bar()
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1891.1">type</span></span><span class="koboSpan" id="kobo.1892.1"> IntC </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1893.1">interface</span></span><span class="koboSpan" id="kobo.1894.1"> {
    IntA
    IntB
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1895.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1896.1">IntC</span></code><span class="koboSpan" id="kobo.1897.1"> interface </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.1898.1">combines</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.1899.1"> interfaces </span><code class="inlineCode"><span class="koboSpan" id="kobo.1900.1">IntA</span></code><span class="koboSpan" id="kobo.1901.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1902.1">IntB</span></code><span class="koboSpan" id="kobo.1903.1">. </span><span class="koboSpan" id="kobo.1903.2">If you implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.1904.1">IntA</span></code><span class="koboSpan" id="kobo.1905.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1906.1">IntB</span></code><span class="koboSpan" id="kobo.1907.1"> for a data type, then this data type implicitly satisfies </span><code class="inlineCode"><span class="koboSpan" id="kobo.1908.1">IntC</span></code><span class="koboSpan" id="kobo.1909.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1910.1">type</span></span><span class="koboSpan" id="kobo.1911.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1912.1">struct</span></span><span class="koboSpan" id="kobo.1913.1"> {
    XX </span><span class="hljs-type"><span class="koboSpan" id="kobo.1914.1">int</span></span><span class="koboSpan" id="kobo.1915.1">
    YY </span><span class="hljs-type"><span class="koboSpan" id="kobo.1916.1">int</span></span><span class="koboSpan" id="kobo.1917.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1918.1">type</span></span><span class="koboSpan" id="kobo.1919.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1920.1">struct</span></span><span class="koboSpan" id="kobo.1921.1"> {
    AA </span><span class="hljs-type"><span class="koboSpan" id="kobo.1922.1">string</span></span><span class="koboSpan" id="kobo.1923.1">
    XX </span><span class="hljs-type"><span class="koboSpan" id="kobo.1924.1">int</span></span><span class="koboSpan" id="kobo.1925.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1926.1">type</span></span><span class="koboSpan" id="kobo.1927.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1928.1">struct</span></span><span class="koboSpan" id="kobo.1929.1"> {
    A a
    B b
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1930.1">This structure has two fields named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1931.1">A</span></code><span class="koboSpan" id="kobo.1932.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1933.1">B</span></code><span class="koboSpan" id="kobo.1934.1"> that are of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1935.1">a</span></code><span class="koboSpan" id="kobo.1936.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1937.1">b</span></code><span class="koboSpan" id="kobo.1938.1"> data types, respectively.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1939.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1940.1">processA</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1941.1">(s IntA)</span></span><span class="koboSpan" id="kobo.1942.1"> {
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1943.1">"%T\n"</span></span><span class="koboSpan" id="kobo.1944.1">, s)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1945.1">This function works with data types that satisfy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1946.1">IntA</span></code><span class="koboSpan" id="kobo.1947.1"> interface.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1948.1">// Satisfying IntA</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1949.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1950.1">(varC c)</span></span><span class="koboSpan" id="kobo.1951.1"> foo() {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1952.1">"Foo Processing"</span></span><span class="koboSpan" id="kobo.1953.1">, varC)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1954.1">Structure </span><code class="inlineCode"><span class="koboSpan" id="kobo.1955.1">c</span></code><span class="koboSpan" id="kobo.1956.1"> satisfies </span><code class="inlineCode"><span class="koboSpan" id="kobo.1957.1">IntA</span></code><span class="koboSpan" id="kobo.1958.1"> as it implements </span><code class="inlineCode"><span class="koboSpan" id="kobo.1959.1">foo()</span></code><span class="koboSpan" id="kobo.1960.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1961.1">// Satisfying IntB</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1962.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1963.1">(varC c)</span></span><span class="koboSpan" id="kobo.1964.1"> bar() {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1965.1">"Bar Processing"</span></span><span class="koboSpan" id="kobo.1966.1">, varC)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1967.1">Now, structure </span><code class="inlineCode"><span class="koboSpan" id="kobo.1968.1">c</span></code><span class="koboSpan" id="kobo.1969.1"> satisfies </span><code class="inlineCode"><span class="koboSpan" id="kobo.1970.1">IntB</span></code><span class="koboSpan" id="kobo.1971.1">. </span><span class="koboSpan" id="kobo.1971.2">As structure </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">c</span></code><span class="koboSpan" id="kobo.1973.1"> satisfies both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1974.1">IntA</span></code><span class="koboSpan" id="kobo.1975.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1976.1">IntB</span></code><span class="koboSpan" id="kobo.1977.1">, it implicitly satisfies </span><code class="inlineCode"><span class="koboSpan" id="kobo.1978.1">IntC</span></code><span class="koboSpan" id="kobo.1979.1">, which</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.1980.1"> is a </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.1981.1">composition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1982.1">IntA</span></code><span class="koboSpan" id="kobo.1983.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1984.1">IntB</span></code><span class="koboSpan" id="kobo.1985.1"> interfaces.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1986.1">// Structure compose gets the fields of structure a</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1987.1">type</span></span><span class="koboSpan" id="kobo.1988.1"> compose </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1989.1">struct</span></span><span class="koboSpan" id="kobo.1990.1"> {
    field1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.1991.1">int</span></span><span class="koboSpan" id="kobo.1992.1">
    a
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1993.1">This new structure uses an anonymous structure (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1994.1">a</span></code><span class="koboSpan" id="kobo.1995.1">), which means that it gets the fields of that anonymous structure.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1996.1">// Different structures can have methods with the same name</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1997.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1998.1">(A a)</span></span><span class="koboSpan" id="kobo.1999.1"> A() {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2000.1">"Function A() for A"</span></span><span class="koboSpan" id="kobo.2001.1">)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2002.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.2003.1">(B b)</span></span><span class="koboSpan" id="kobo.2004.1"> A() {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2005.1">"Function A() for B"</span></span><span class="koboSpan" id="kobo.2006.1">)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2007.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2008.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2009.1">()</span></span><span class="koboSpan" id="kobo.2010.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2011.1">var</span></span><span class="koboSpan" id="kobo.2012.1"> iC c = c{a{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2013.1">120</span></span><span class="koboSpan" id="kobo.2014.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2015.1">12</span></span><span class="koboSpan" id="kobo.2016.1">}, b{</span><span class="hljs-string"><span class="koboSpan" id="kobo.2017.1">"-12"</span></span><span class="koboSpan" id="kobo.2018.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2019.1">-12</span></span><span class="koboSpan" id="kobo.2020.1">}}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2021.1">Here, we define a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2022.1">c</span></code><span class="koboSpan" id="kobo.2023.1"> variable that is composed of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2024.1">a</span></code><span class="koboSpan" id="kobo.2025.1"> structure and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2026.1">b</span></code><span class="koboSpan" id="kobo.2027.1"> structure.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2028.1">    iC.A.A()
    iC.B.A()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2029.1">Here, we access a method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2030.1">a</span></code><span class="koboSpan" id="kobo.2031.1"> structure (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2032.1">A.A()</span></code><span class="koboSpan" id="kobo.2033.1">) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2034.1">a</span></code><span class="koboSpan" id="kobo.2035.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2036.1">b</span></code><span class="koboSpan" id="kobo.2037.1"> structure (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2038.1">B.A()</span></code><span class="koboSpan" id="kobo.2039.1">).</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2040.1">// The following will not work</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2041.1">// iComp := compose{field1: 123, a{456, 789}}</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2042.1">// iComp := compose{field1: 123, XX: 456, YY: 789}</span></span><span class="koboSpan" id="kobo.2043.1">
    iComp := compose{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2044.1">123</span></span><span class="koboSpan" id="kobo.2045.1">, a{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2046.1">456</span></span><span class="koboSpan" id="kobo.2047.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2048.1">789</span></span><span class="koboSpan" id="kobo.2049.1">}}
    fmt.Println(iComp.XX, iComp.YY, iComp.field1)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2050.1">When using an </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.2051.1">anonymous</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.2052.1"> structure inside another structure, as we do with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2053.1">a{456, 789}</span></code><span class="koboSpan" id="kobo.2054.1">, you can access the fields of the anonymous structure, which is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2055.1">a{456, 789}</span></code><span class="koboSpan" id="kobo.2056.1"> structure, directly as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2057.1">iComp.XX</span></code><span class="koboSpan" id="kobo.2058.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2059.1">iComp.YY</span></code><span class="koboSpan" id="kobo.2060.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2061.1">    iC.bar()
    processA(iC)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2062.1">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.2063.1">processA()</span></code><span class="koboSpan" id="kobo.2064.1"> works with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2065.1">IntA</span></code><span class="koboSpan" id="kobo.2066.1"> variables, it can also work with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2067.1">IntC</span></code><span class="koboSpan" id="kobo.2068.1"> variables because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2069.1">IntC</span></code><span class="koboSpan" id="kobo.2070.1"> interface satisfies </span><code class="inlineCode"><span class="koboSpan" id="kobo.2071.1">IntA</span></code><span class="koboSpan" id="kobo.2072.1">!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2073.1">All the code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2074.1">objO.go</span></code><span class="koboSpan" id="kobo.2075.1"> is simplistic compared to the code of a real object-oriented programming language that supports abstract classes and inheritance. </span><span class="koboSpan" id="kobo.2075.2">However, it is more than adequate for generating types and elements with an internal structure, as well as for having different data types with the same method names.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2076.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2077.1">objO.go</span></code><span class="koboSpan" id="kobo.2078.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2079.1">$ </span></span><span class="koboSpan" id="kobo.2080.1">go run objO.go
Function A() for A
Function A() for B
456 789 123
Bar Processing {{120 12} {-12 -12}}
main.c
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2081.1">The first two lines of the output show that two different structures can have methods with the same name. </span><span class="koboSpan" id="kobo.2081.2">The third line proves that when using an anonymous structure inside one other structure, you can access the fields of the anonymous structure directly. </span><span class="koboSpan" id="kobo.2081.3">The fourth line is the output of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2082.1">iC.bar()</span></code><span class="koboSpan" id="kobo.2083.1"> call, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2084.1">iC</span></code><span class="koboSpan" id="kobo.2085.1"> is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2086.1">c</span></code><span class="koboSpan" id="kobo.2087.1"> variable accessing a method from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2088.1">IntB</span></code><span class="koboSpan" id="kobo.2089.1"> interface. </span><span class="koboSpan" id="kobo.2089.2">The last line is the output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2090.1">processA(iC)</span></code><span class="koboSpan" id="kobo.2091.1"> that requires an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2092.1">IntA</span></code><span class="koboSpan" id="kobo.2093.1"> parameter and prints the real data type of its parameter, which, in this case, is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2094.1">main.c</span></code><span class="koboSpan" id="kobo.2095.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2096.1">Evidently, although Go is not an object-oriented programming language, it can mimic some of the characteristics of object-oriented languages.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2097.1">The next section</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.2098.1"> discusses</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.2099.1"> the differences between using interfaces and generics to support multiple data types.</span></p>
<h1 class="heading-1" id="_idParaDest-142"><span class="koboSpan" id="kobo.2100.1">Interfaces versus generics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2101.1">This section</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.2102.1"> presents </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.2103.1">a program that increments a numeric value by one using interfaces and generics so that you can compare the implementation details.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2104.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2105.1">genericsInterfaces.go</span></code><span class="koboSpan" id="kobo.2106.1"> illustrates the two techniques and contains the next code.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2107.1">package</span></span><span class="koboSpan" id="kobo.2108.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2109.1">import</span></span><span class="koboSpan" id="kobo.2110.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2111.1">"fmt"</span></span><span class="koboSpan" id="kobo.2112.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2113.1">type</span></span><span class="koboSpan" id="kobo.2114.1"> Numeric </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2115.1">interface</span></span><span class="koboSpan" id="kobo.2116.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.2117.1">int</span></span><span class="koboSpan" id="kobo.2118.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.2119.1">int8</span></span><span class="koboSpan" id="kobo.2120.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.2121.1">int16</span></span><span class="koboSpan" id="kobo.2122.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.2123.1">int32</span></span><span class="koboSpan" id="kobo.2124.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.2125.1">int64</span></span><span class="koboSpan" id="kobo.2126.1"> | </span><span class="hljs-type"><span class="koboSpan" id="kobo.2127.1">float64</span></span><span class="koboSpan" id="kobo.2128.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2129.1">This is where we define a constraint named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2130.1">Numeric</span></code><span class="koboSpan" id="kobo.2131.1"> for limiting the permitted data types.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2132.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2133.1">Print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2134.1">(s </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2135.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2136.1">{})</span></span><span class="koboSpan" id="kobo.2137.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2138.1">// type switch</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2139.1">switch</span></span><span class="koboSpan" id="kobo.2140.1"> s.(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2141.1">type</span></span><span class="koboSpan" id="kobo.2142.1">) {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2143.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2144.1">Print()</span></code><span class="koboSpan" id="kobo.2145.1"> function uses the empty interface for getting input and a type switch to work with that input parameter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2146.1">Put simply, we are using a type switch to differentiate between the supported data types—in this case, the supported data types are just </span><code class="inlineCode"><span class="koboSpan" id="kobo.2147.1">int</span></code><span class="koboSpan" id="kobo.2148.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2149.1">float64</span></code><span class="koboSpan" id="kobo.2150.1">, which have to do with the implementation of the </span><em class="italic"><span class="koboSpan" id="kobo.2151.1">type switch</span></em><span class="koboSpan" id="kobo.2152.1">. </span><span class="koboSpan" id="kobo.2152.2">However, adding more data types requires code changes, which is not the most efficient solution when a large number of data types needs to be supported.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2153.1">case</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2154.1">int</span></span><span class="koboSpan" id="kobo.2155.1">:
        fmt.Println(s.(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2156.1">int</span></span><span class="koboSpan" id="kobo.2157.1">)+</span><span class="hljs-number"><span class="koboSpan" id="kobo.2158.1">1</span></span><span class="koboSpan" id="kobo.2159.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2160.1">This branch is </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.2161.1">how </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.2162.1">we handle the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2163.1">in</span></code><span class="koboSpan" id="kobo.2164.1">t case.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2165.1">case</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2166.1">float64</span></span><span class="koboSpan" id="kobo.2167.1">:
        fmt.Println(s.(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2168.1">float64</span></span><span class="koboSpan" id="kobo.2169.1">)+</span><span class="hljs-number"><span class="koboSpan" id="kobo.2170.1">1</span></span><span class="koboSpan" id="kobo.2171.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2172.1">This branch is how we handle the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2173.1">float64</span></code><span class="koboSpan" id="kobo.2174.1"> case.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2175.1">default</span></span><span class="koboSpan" id="kobo.2176.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2177.1">"Unknown data type!"</span></span><span class="koboSpan" id="kobo.2178.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2179.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2180.1">default</span></code><span class="koboSpan" id="kobo.2181.1"> branch is how we handle all unsupported data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2182.1">The biggest issue with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2183.1">Print()</span></code><span class="koboSpan" id="kobo.2184.1"> is that due to the use of the empty interface, it accepts all kinds of input. </span><span class="koboSpan" id="kobo.2184.2">As a result, the function signature does not help us limit the allowed data types. </span><span class="koboSpan" id="kobo.2184.3">The second issue with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2185.1">Print()</span></code><span class="koboSpan" id="kobo.2186.1"> is that we need to specifically handle each case—handling more cases means writing more code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2187.1">On the other hand, the compiler and the developer do not have to guess many things with that code, which is not the case with generics, where the compiler and the runtime have more work to do. </span><span class="koboSpan" id="kobo.2187.2">This kind of work introduces delays in the execution time.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2188.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2189.1">PrintGenerics</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2190.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2191.1">T</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2192.1">any</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2193.1">]</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2194.1">(s T)</span></span><span class="koboSpan" id="kobo.2195.1"> {
    fmt.Println(s)
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2196.1">PrintGenerics()</span></code><span class="koboSpan" id="kobo.2197.1"> is a generic function that can handle all available data types simply and elegantly.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2198.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2199.1">PrintNumeric</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2200.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2201.1">T</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2202.1">Numeric</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2203.1">]</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2204.1">(s T)</span></span><span class="koboSpan" id="kobo.2205.1"> {
    fmt.Println(s+</span><span class="hljs-number"><span class="koboSpan" id="kobo.2206.1">1</span></span><span class="koboSpan" id="kobo.2207.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2208.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2209.1">PrintNumeric()</span></code><span class="koboSpan" id="kobo.2210.1"> function supports all numeric data types with the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2211.1">Numeric</span></code><span class="koboSpan" id="kobo.2212.1"> constraint. </span><span class="koboSpan" id="kobo.2212.2">No need to specifically add code for supporting each distinct data type, as happens with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2213.1">Print()</span></code><span class="koboSpan" id="kobo.2214.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2215.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2216.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2217.1">()</span></span><span class="koboSpan" id="kobo.2218.1"> {
    Print(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2219.1">12</span></span><span class="koboSpan" id="kobo.2220.1">)
    Print(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2221.1">-1.23</span></span><span class="koboSpan" id="kobo.2222.1">)
    Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2223.1">"Hi!"</span></span><span class="koboSpan" id="kobo.2224.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2225.1">The first part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2226.1">main()</span></code><span class="koboSpan" id="kobo.2227.1"> uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.2228.1">Print()</span></code><span class="koboSpan" id="kobo.2229.1"> with various types of input: an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2230.1">int</span></code><span class="koboSpan" id="kobo.2231.1"> value, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2232.1">float64</span></code><span class="koboSpan" id="kobo.2233.1"> value, and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2234.1">string</span></code><span class="koboSpan" id="kobo.2235.1"> value, respectively.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2236.1">    PrintGenerics(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2237.1">1</span></span><span class="koboSpan" id="kobo.2238.1">)
    PrintGenerics(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2239.1">"a"</span></span><span class="koboSpan" id="kobo.2240.1">)
    PrintGenerics(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2241.1">-2.33</span></span><span class="koboSpan" id="kobo.2242.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2243.1">As stated</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.2244.1"> before, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2245.1">PrintGenerics()</span></code><span class="koboSpan" id="kobo.2246.1"> works </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.2247.1">with all data types, including </span><code class="inlineCode"><span class="koboSpan" id="kobo.2248.1">string</span></code><span class="koboSpan" id="kobo.2249.1"> values.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2250.1">    PrintNumeric(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2251.1">1</span></span><span class="koboSpan" id="kobo.2252.1">)
    PrintNumeric(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2253.1">-2.33</span></span><span class="koboSpan" id="kobo.2254.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2255.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2256.1">main()</span></code><span class="koboSpan" id="kobo.2257.1"> uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.2258.1">PrintNumeric()</span></code><span class="koboSpan" id="kobo.2259.1"> with numeric values only, due to the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2260.1">Numeric</span></code><span class="koboSpan" id="kobo.2261.1"> constraint.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2262.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2263.1">genericsInterfaces.go</span></code><span class="koboSpan" id="kobo.2264.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2265.1">13
-0.22999999999999998
Unknown data type!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2266.1">The preceding three lines of the output are from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2267.1">Print()</span></code><span class="koboSpan" id="kobo.2268.1"> function, which uses the empty interface.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2269.1">1
a
-2.33
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2270.1">The previous three lines of the output are from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2271.1">PrintGenerics()</span></code><span class="koboSpan" id="kobo.2272.1"> function, which uses generics and supports all available data types. </span><span class="koboSpan" id="kobo.2272.2">As a result, it should not blindly increase the value of its input because we do not know for sure that we are dealing with a numeric value. </span><span class="koboSpan" id="kobo.2272.3">Therefore, it just prints the given input.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2273.1">2
-1.33
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2274.1">The last two lines are generated by the two </span><code class="inlineCode"><span class="koboSpan" id="kobo.2275.1">PrintNumeric()</span></code><span class="koboSpan" id="kobo.2276.1"> calls, which operate using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2277.1">Numeric</span></code><span class="koboSpan" id="kobo.2278.1"> constraint.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2279.1">So, in practice, when you have to support multiple data types, the use of generics might be a better choice than using interfaces. </span><span class="koboSpan" id="kobo.2279.2">However, when we want to define and use a specific behavior, interfaces are better and more descriptive than generics. </span><span class="koboSpan" id="kobo.2279.3">Such cases include reading data with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2280.1">Reader</span></code><span class="koboSpan" id="kobo.2281.1"> interface or writing data with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2282.1">Writer</span></code><span class="koboSpan" id="kobo.2283.1"> interface.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2284.1">The next section </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.2285.1">discusses</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.2286.1"> the use of reflection as a way of bypassing the use of generics.</span></p>
<h1 class="heading-1" id="_idParaDest-143"><span class="koboSpan" id="kobo.2287.1">Reflection versus generics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2288.1">In this section, we </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.2289.1">develop a utility that prints the elements of a slice in two </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.2290.1">ways: first, using reflection, and second, using generics.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2291.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2292.1">genericsReflection.go</span></code><span class="koboSpan" id="kobo.2293.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2294.1">package</span></span><span class="koboSpan" id="kobo.2295.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2296.1">import</span></span><span class="koboSpan" id="kobo.2297.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2298.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2299.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2300.1">reflect"</span></span><span class="koboSpan" id="kobo.2301.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2302.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2303.1">PrintReflection</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2304.1">(s </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2305.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2306.1">{})</span></span><span class="koboSpan" id="kobo.2307.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2308.1">"** Reflection"</span></span><span class="koboSpan" id="kobo.2309.1">)
    val := reflect.ValueOf(s)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2310.1">if</span></span><span class="koboSpan" id="kobo.2311.1"> val.Kind() != reflect.Slice {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2312.1">return</span></span><span class="koboSpan" id="kobo.2313.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2314.1">for</span></span><span class="koboSpan" id="kobo.2315.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2316.1">0</span></span><span class="koboSpan" id="kobo.2317.1">; i &lt; val.Len(); i++ {
        fmt.Print(val.Index(i).Interface(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.2318.1">" "</span></span><span class="koboSpan" id="kobo.2319.1">)
    }
    fmt.Println()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2320.1">Internally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2321.1">PrintReflection()</span></code><span class="koboSpan" id="kobo.2322.1"> function works with slices only. </span><span class="koboSpan" id="kobo.2322.2">However, as we cannot express that in the function signature, we need to accept an empty interface parameter. </span><span class="koboSpan" id="kobo.2322.3">Put simply, instead of specifying all kinds of slices, it makes much more sense to use the empty interface. </span><span class="koboSpan" id="kobo.2322.4">Additionally, we have to write more code to get the desired output and prevent the function from crashing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2323.1">In more detail, first, we need to make sure that we are processing a slice (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2324.1">reflect.Slice</span></code><span class="koboSpan" id="kobo.2325.1">), and second, we have to print the slice elements using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2326.1">for</span></code><span class="koboSpan" id="kobo.2327.1"> loop, which is pretty ugly.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2328.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2329.1">PrintSlice</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2330.1">[</span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2331.1">T</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2332.1">any</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2333.1">]</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2334.1">(s []T)</span></span><span class="koboSpan" id="kobo.2335.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2336.1">"** Generics"</span></span><span class="koboSpan" id="kobo.2337.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2338.1">for</span></span><span class="koboSpan" id="kobo.2339.1"> _, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2340.1">range</span></span><span class="koboSpan" id="kobo.2341.1"> s {
        fmt.Print(v, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2342.1">" "</span></span><span class="koboSpan" id="kobo.2343.1">)
    }
    fmt.Println()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2344.1">Once again, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2345.1">the implementation of the generic function is simpler and therefore easier to understand</span></strong><span class="koboSpan" id="kobo.2346.1">. </span><span class="koboSpan" id="kobo.2346.2">Moreover, the </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.2347.1">function signature specifies that only slices are </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.2348.1">accepted as function parameters—we do not have to perform any additional checks for that as this is a job for the Go compiler. </span><span class="koboSpan" id="kobo.2348.2">Last, we use a simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.2349.1">for</span></code><span class="koboSpan" id="kobo.2350.1"> loop with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2351.1">range</span></code><span class="koboSpan" id="kobo.2352.1"> to print the slice elements.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2353.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2354.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2355.1">()</span></span><span class="koboSpan" id="kobo.2356.1"> {
    PrintSlice([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2357.1">int</span></span><span class="koboSpan" id="kobo.2358.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2359.1">1</span></span><span class="koboSpan" id="kobo.2360.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2361.1">2</span></span><span class="koboSpan" id="kobo.2362.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2363.1">3</span></span><span class="koboSpan" id="kobo.2364.1">})
    PrintSlice([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2365.1">string</span></span><span class="koboSpan" id="kobo.2366.1">{</span><span class="hljs-string"><span class="koboSpan" id="kobo.2367.1">"a"</span></span><span class="koboSpan" id="kobo.2368.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2369.1">"b"</span></span><span class="koboSpan" id="kobo.2370.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2371.1">"c"</span></span><span class="koboSpan" id="kobo.2372.1">})
    PrintSlice([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2373.1">float64</span></span><span class="koboSpan" id="kobo.2374.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2375.1">1.2</span></span><span class="koboSpan" id="kobo.2376.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2377.1">-2.33</span></span><span class="koboSpan" id="kobo.2378.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2379.1">4.55</span></span><span class="koboSpan" id="kobo.2380.1">})
    PrintReflection([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2381.1">int</span></span><span class="koboSpan" id="kobo.2382.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2383.1">1</span></span><span class="koboSpan" id="kobo.2384.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2385.1">2</span></span><span class="koboSpan" id="kobo.2386.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2387.1">3</span></span><span class="koboSpan" id="kobo.2388.1">})
    PrintReflection([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2389.1">string</span></span><span class="koboSpan" id="kobo.2390.1">{</span><span class="hljs-string"><span class="koboSpan" id="kobo.2391.1">"a"</span></span><span class="koboSpan" id="kobo.2392.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2393.1">"b"</span></span><span class="koboSpan" id="kobo.2394.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2395.1">"c"</span></span><span class="koboSpan" id="kobo.2396.1">})
    PrintReflection([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2397.1">float64</span></span><span class="koboSpan" id="kobo.2398.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.2399.1">1.2</span></span><span class="koboSpan" id="kobo.2400.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2401.1">-2.33</span></span><span class="koboSpan" id="kobo.2402.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2403.1">4.55</span></span><span class="koboSpan" id="kobo.2404.1">})
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2405.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2406.1">main()</span></code><span class="koboSpan" id="kobo.2407.1"> function calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.2408.1">PrintSlice()</span></code><span class="koboSpan" id="kobo.2409.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2410.1">PrintReflection()</span></code><span class="koboSpan" id="kobo.2411.1"> with various kinds of input to test their operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2412.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2413.1">genericsReflection.go</span></code><span class="koboSpan" id="kobo.2414.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2415.1">** Generics
1 2 3
** Generics
a b c
** Generics
1.2 -2.33 4.55
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2416.1">The first six lines are produced by taking advantage of generics and print the elements of a slice of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2417.1">int</span></code><span class="koboSpan" id="kobo.2418.1"> values, a slice of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2419.1">string</span></code><span class="koboSpan" id="kobo.2420.1"> values, and a slice of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2421.1">float64</span></code><span class="koboSpan" id="kobo.2422.1"> values.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2423.1">** Reflection
1 2 3
** Reflection
a b c
** Reflection
1.2 -2.33 4.55
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2424.1">The last six lines of the output produce the same output but, this time, using reflection. </span><span class="koboSpan" id="kobo.2424.2">There is no difference in the output—all differences are in the code found in the implementations of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2425.1">PrintReflection()</span></code><span class="koboSpan" id="kobo.2426.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2427.1">PrintSlice()</span></code><span class="koboSpan" id="kobo.2428.1"> for printing the output. </span><span class="koboSpan" id="kobo.2428.2">As expected, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2429.1">generics code is simpler and shorter than Go code that uses reflection</span></strong><span class="koboSpan" id="kobo.2430.1">, especially when you must support lots of different data types. </span><span class="koboSpan" id="kobo.2430.2">While generics in Go offer a powerful and type-safe way to write reusable code, there are scenarios where using reflection might be more suitable, including dynamic type handling, working with uncommon types, serialization and deserialization, and when implementing custom marshaling and unmarshaling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2431.1">Moving on, the </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.2432.1">last </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.2433.1">section of this chapter is about updating the statistics application by reading multiple files and sorting its output by a given statistical property.</span></p>
<h1 class="heading-1" id="_idParaDest-144"><span class="koboSpan" id="kobo.2434.1">Updating the statistics application</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2435.1">What we are going to</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.2436.1"> do in this section is sort different datasets based on their mean value. </span><span class="koboSpan" id="kobo.2436.2">As a result, the application is going to be able to read multiple files, which are going to be given as command line arguments to the utility—we are going to learn more about file I/O in </span><em class="chapterRef"><span class="koboSpan" id="kobo.2437.1">Chapter 7</span></em><span class="koboSpan" id="kobo.2438.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2439.1">Telling a UNIX System What to Do</span></em><span class="koboSpan" id="kobo.2440.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2441.1">We are going to create a structure that holds the statistical properties of each datafile, use a slice to store all such structures, and sort them based on the mean value of each dataset. </span><span class="koboSpan" id="kobo.2441.2">The last functionality is going to be implemented using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2442.1">sort.Interface</span></code><span class="koboSpan" id="kobo.2443.1">. </span><span class="koboSpan" id="kobo.2443.2">Using a structure for keeping the important information organized is a common practice. </span><span class="koboSpan" id="kobo.2443.3">Additionally, we are going to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2444.1">slices.Min()</span></code><span class="koboSpan" id="kobo.2445.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2446.1">slices.Max()</span></code><span class="koboSpan" id="kobo.2447.1"> functions for finding the minimum and the maximum value in a slice, respectively, which saves us from having to sort the slice.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2448.1">Although such utilities look naïve at first, they can be the foundation of complex machine learning systems. </span><span class="koboSpan" id="kobo.2448.2">In general, statistics is the foundation of machine learning.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2449.1">The definition </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.2450.1">of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2451.1">DataFile</span></code><span class="koboSpan" id="kobo.2452.1"> structure is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2453.1">type</span></span><span class="koboSpan" id="kobo.2454.1"> DataFile </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2455.1">struct</span></span><span class="koboSpan" id="kobo.2456.1"> {
    Filename </span><span class="hljs-type"><span class="koboSpan" id="kobo.2457.1">string</span></span><span class="koboSpan" id="kobo.2458.1">
    Len      </span><span class="hljs-type"><span class="koboSpan" id="kobo.2459.1">int</span></span><span class="koboSpan" id="kobo.2460.1">
    Minimum  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2461.1">float64</span></span><span class="koboSpan" id="kobo.2462.1">
    Maximum  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2463.1">float64</span></span><span class="koboSpan" id="kobo.2464.1">
    Mean     </span><span class="hljs-type"><span class="koboSpan" id="kobo.2465.1">float64</span></span><span class="koboSpan" id="kobo.2466.1">
    StdDev   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2467.1">float64</span></span><span class="koboSpan" id="kobo.2468.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2469.1">We also need to define a new data type for a slice of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2470.1">DataFile</span></code><span class="koboSpan" id="kobo.2471.1"> structures, which is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2472.1">type</span></span><span class="koboSpan" id="kobo.2473.1"> DFslice []DataFile
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2474.1">It is for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2475.1">DFslice</span></code><span class="koboSpan" id="kobo.2476.1"> that we are going to implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2477.1">sort.Interface</span></code><span class="koboSpan" id="kobo.2478.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2479.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.2480.1">(a DFslice)</span></span><span class="koboSpan" id="kobo.2481.1"> Len() </span><span class="hljs-type"><span class="koboSpan" id="kobo.2482.1">int</span></span><span class="koboSpan" id="kobo.2483.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2484.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2485.1">len</span></span><span class="koboSpan" id="kobo.2486.1">(a)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2487.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.2488.1">(a DFslice)</span></span><span class="koboSpan" id="kobo.2489.1"> Less(i, j </span><span class="hljs-type"><span class="koboSpan" id="kobo.2490.1">int</span></span><span class="koboSpan" id="kobo.2491.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.2492.1">bool</span></span><span class="koboSpan" id="kobo.2493.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2494.1">return</span></span><span class="koboSpan" id="kobo.2495.1"> a[i].Mean &lt; a[j].Mean
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2496.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.2497.1">(a DFslice)</span></span><span class="koboSpan" id="kobo.2498.1"> Swap(i, j </span><span class="hljs-type"><span class="koboSpan" id="kobo.2499.1">int</span></span><span class="koboSpan" id="kobo.2500.1">) {
    a[i], a[j] = a[j], a[i]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2501.1">The previous three methods satisfy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2502.1">sort.Interface</span></code><span class="koboSpan" id="kobo.2503.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2504.1">DFslice</span></code><span class="koboSpan" id="kobo.2505.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2506.1">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2507.1">main()</span></code><span class="koboSpan" id="kobo.2508.1"> function is presented in four parts, the first part being the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2509.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2510.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2511.1">()</span></span><span class="koboSpan" id="kobo.2512.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2513.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2514.1">len</span></span><span class="koboSpan" id="kobo.2515.1">(os.Args) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2516.1">1</span></span><span class="koboSpan" id="kobo.2517.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2518.1">"Need one or more file paths!"</span></span><span class="koboSpan" id="kobo.2519.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2520.1">return</span></span><span class="koboSpan" id="kobo.2521.1">
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2522.1">// Slice of DataFile structures</span></span><span class="koboSpan" id="kobo.2523.1">
    files := DFslice{}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2524.1">In this first part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2525.1">main()</span></code><span class="koboSpan" id="kobo.2526.1">, we make sure that we have at least one command line argument to </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.2527.1">process and we define a slice of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2528.1">DataFile</span></code><span class="koboSpan" id="kobo.2529.1"> structures variable for keeping the data of each file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2530.1">The second part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2531.1">main()</span></code><span class="koboSpan" id="kobo.2532.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2533.1">for</span></span><span class="koboSpan" id="kobo.2534.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2535.1">1</span></span><span class="koboSpan" id="kobo.2536.1">; i &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2537.1">len</span></span><span class="koboSpan" id="kobo.2538.1">(os.Args); i++ {
        file := os.Args[i]
        </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.2539.1">currentFile := DataFile{}</span></strong></span><span class="koboSpan" id="kobo.2540.1">
        currentFile.Filename = file
        values, err := readFile(file)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2541.1">if</span></span><span class="koboSpan" id="kobo.2542.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2543.1">nil</span></span><span class="koboSpan" id="kobo.2544.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2545.1">"Error reading:"</span></span><span class="koboSpan" id="kobo.2546.1">, file, err)
            os.Exit(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2547.1">0</span></span><span class="koboSpan" id="kobo.2548.1">)
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2549.1">The presented </span><code class="inlineCode"><span class="koboSpan" id="kobo.2550.1">for</span></code><span class="koboSpan" id="kobo.2551.1"> loop processes all input files unless there is an error. </span><span class="koboSpan" id="kobo.2551.2">In case of error, the utility exits with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2552.1">os.Exit(0)</span></code><span class="koboSpan" id="kobo.2553.1">. </span><span class="koboSpan" id="kobo.2553.2">A different approach would have been to skip the erroneous input file and continue with the next. </span><span class="koboSpan" id="kobo.2553.3">Additionally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2554.1">currentFile</span></code><span class="koboSpan" id="kobo.2555.1"> variable keeps the data of the current file in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2556.1">DataFile</span></code><span class="koboSpan" id="kobo.2557.1"> structure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2558.1">The third part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2559.1">main()</span></code><span class="koboSpan" id="kobo.2560.1"> contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2561.1">        currentFile.Len = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2562.1">len</span></span><span class="koboSpan" id="kobo.2563.1">(values)
        currentFile.Minimum = slices.Min(values)
        currentFile.Maximum = slices.Max(values)
        meanValue, standardDeviation := stdDev(values)
        currentFile.Mean = meanValue
        currentFile.StdDev = standardDeviation
        files = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2564.1">append</span></span><span class="koboSpan" id="kobo.2565.1">(files, currentFile)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2566.1">In the previous code, we compute all the required statistical properties and save them in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2567.1">currentFile</span></code><span class="koboSpan" id="kobo.2568.1"> variable. </span><span class="koboSpan" id="kobo.2568.2">Last, the current version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2569.1">currentFile</span></code><span class="koboSpan" id="kobo.2570.1"> variable is stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2571.1">files</span></code><span class="koboSpan" id="kobo.2572.1"> slice before continuing with the next file, if any.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2573.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2574.1">main()</span></code><span class="koboSpan" id="kobo.2575.1"> comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2576.1">    sort.Sort(files)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2577.1">for</span></span><span class="koboSpan" id="kobo.2578.1"> _, val := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2579.1">range</span></span><span class="koboSpan" id="kobo.2580.1"> files {
        f := val.Filename
        fmt.Println(f,</span><span class="hljs-string"><span class="koboSpan" id="kobo.2581.1">":"</span></span><span class="koboSpan" id="kobo.2582.1">,val.Len,val.Mean,val.Maximum,val.Minimum)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2583.1">The last part of the utility sorts the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2584.1">files</span></code><span class="koboSpan" id="kobo.2585.1"> slice and prints information about each one of the input files. </span><span class="koboSpan" id="kobo.2585.2">You can print any data you want from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2586.1">files</span></code><span class="koboSpan" id="kobo.2587.1"> slice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2588.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2589.1">stats.go</span></code><span class="koboSpan" id="kobo.2590.1"> using the simplistic data files found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2591.1">ch05</span></code><span class="koboSpan" id="kobo.2592.1"> directory produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2593.1">$ </span></span><span class="koboSpan" id="kobo.2594.1">go run stats.go d1.txt d2.txt d3.txt
Mean value: 3.00000
Mean value: 18.20000
Mean value: 0.75000
d3.txt : 4 0.75 102 -300
d1.txt : 5 3 5 1
d2.txt : 5 18.2 100 -4
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2595.1">As the mean </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.2596.1">value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2597.1">d3.txt</span></code><span class="koboSpan" id="kobo.2598.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2599.1">0.75</span></code><span class="koboSpan" id="kobo.2600.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2601.1">d3.txt</span></code><span class="koboSpan" id="kobo.2602.1"> is presented before </span><code class="inlineCode"><span class="koboSpan" id="kobo.2603.1">d1.txt</span></code><span class="koboSpan" id="kobo.2604.1">, which has a mean value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2605.1">3</span></code><span class="koboSpan" id="kobo.2606.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2607.1">d2.txt</span></code><span class="koboSpan" id="kobo.2608.1">, which has a mean value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2609.1">18.2</span></code><span class="koboSpan" id="kobo.2610.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-145"><span class="koboSpan" id="kobo.2611.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2612.1">In this chapter, we learned about interfaces, which are like contracts, and also about type methods, type assertion, and reflection. </span><span class="koboSpan" id="kobo.2612.2">Although reflection is a very powerful Go feature, it might slow down your Go programs because it adds a layer of complexity at runtime. </span><span class="koboSpan" id="kobo.2612.3">Furthermore, your Go programs could crash if you use reflection carelessly. </span><span class="koboSpan" id="kobo.2612.4">However, reflection is not usually needed unless you want to perform low-level tasks with Go variables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2613.1">Remember that interfaces specify behavior, specify what you can do, and not what a data type is. </span><span class="koboSpan" id="kobo.2613.2">Code that uses interfaces successfully is more readable, more extensible, and simpler to understand. </span><span class="koboSpan" id="kobo.2613.3">Last, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2614.1">keep in mind that interfaces are implemented implicitly once the required type methods are implemented</span></strong><span class="koboSpan" id="kobo.2615.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2616.1">This chapter also discussed writing Go code that follows the principles of object-oriented programming. </span><span class="koboSpan" id="kobo.2616.2">If you are going to remember just one thing from this chapter, it should be that Go is not an object-oriented programming language, but it can mimic some of the functionality offered by object-oriented programming languages, such as Java, Python, and C++. </span><span class="koboSpan" id="kobo.2616.3">In the last section, we updated the statistics application to support the sorting of multiple datasets based on the mean value of a dataset.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2617.1">The next chapter discusses semantic versioning, Go packages, functions, and workspaces.</span></p>
<h1 class="heading-1" id="_idParaDest-146"><span class="koboSpan" id="kobo.2618.1">Exercises</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2619.1">Try to do the following exercises:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2620.1">Create a slice of structures using a structure that you created and sort the elements of the slice using a field from the structure.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2621.1">Use the empty interface and a function that allows you to differentiate between two different structures that you have created.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-147"><span class="koboSpan" id="kobo.2622.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2623.1">The documentation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2624.1">reflect</span></code><span class="koboSpan" id="kobo.2625.1"> package: </span><a href="https://pkg.go.dev/reflect"><span class="url"><span class="koboSpan" id="kobo.2626.1">https://pkg.go.dev/reflect</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2627.1">The documentation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2628.1">sort</span></code><span class="koboSpan" id="kobo.2629.1"> package: </span><a href="https://pkg.go.dev/sort"><span class="url"><span class="koboSpan" id="kobo.2630.1">https://pkg.go.dev/sort</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2631.1">Working with errors in Go 1.13: </span><a href="https://blog.go.dev/go1.13-errors"><span class="url"><span class="koboSpan" id="kobo.2632.1">https://blog.go.dev/go1.13-errors</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2633.1">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2634.1">sort</span></code><span class="koboSpan" id="kobo.2635.1"> package: </span><a href="https://go.dev/src/sort/"><span class="url"><span class="koboSpan" id="kobo.2636.1">https://go.dev/src/sort/</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.2637.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2638.1">Join our community’s Discord space for discussions with the authors and other readers:</span></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.2639.1">https://discord.gg/FzuQbc8zd6</span></span></a></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.2640.1"><img alt="" role="presentation" src="../Images/QR_Code2286825896190168453.png"/></span></span></a></p>
</div>
</body></html>