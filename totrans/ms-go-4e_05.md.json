["```go\npackage main\nimport (\n    \"fmt\"\n\"reflect\"\n)\ntype Secret struct {\n    Username string\n    Password string\n}\ntype Record struct {\n    Field1 string\n    Field2 float64\n    Field3 Secret\n}\nfunc main() {\n    A := Record{\"String value\", -12.123, Secret{\"Mihalis\", \"Tsoukalos\"}} \n```", "```go\n r := reflect.ValueOf(A)\n    fmt.Println(\"String value:\", r.String()) \n```", "```go\n iType := r.Type() \n```", "```go\n fmt.Printf(\"i Type: %s\\n\", iType)\n    fmt.Printf(\"The %d fields of %s are\\n\", r.NumField(), iType)\n    for i := 0; i < r.NumField(); i++ { \n```", "```go\n fmt.Printf(\"\\t%s \", iType.Field(i).Name)\n        fmt.Printf(\"\\twith type: %s \", r.Field(i).Type())\n        fmt.Printf(\"\\tand value _%v_\\n\", r.Field(i).Interface()) \n```", "```go\n // Check whether there are other structures embedded in Record\n        k := reflect.TypeOf(r.Field(i).Interface()).Kind()\n        // Need to convert it to string in order to compare it\n        if k.String() == \"struct\" { \n```", "```go\n fmt.Println(r.Field(i).Type())\n        }\n        // Same as before but using the internal value\n        if k == reflect.Struct { \n```", "```go\n fmt.Println(r.Field(i).Type())\n        }\n    }\n} \n```", "```go\n$ go run reflection.go\nString value: <main.Record Value>\ni Type: main.Record\nThe 3 fields of main.Record are\n        Field1  with type: string       and value _String value_\n        Field2  with type: float64      and value _-12.123_\n        Field3  with type: main.Secret  and value _{Mihalis Tsoukalos}_\nmain.Secret\nmain.Secret \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"reflect\"\n)\ntype T struct {\n    F1 int\n    F2 string\n    F3 float64\n}\nfunc main() {\n    A := T{1, \"F2\", 3.0} \n```", "```go\n fmt.Println(\"A:\", A)\n    r := reflect.ValueOf(&A).Elem() \n```", "```go\n fmt.Println(\"String value:\", r.String())\n    typeOfA := r.Type()\n    for i := 0; i < r.NumField(); i++ {\n        f := r.Field(i)\n        tOfA := typeOfA.Field(i).Name\n        fmt.Printf(\"%d: %s %s = %v\\n\", i, tOfA, f.Type(), f.Interface())\n        k := reflect.TypeOf(r.Field(i).Interface()).Kind()\n        if k == reflect.Int {\n            r.Field(i).SetInt(-100)\n        } else if k == reflect.String {\n            r.Field(i).SetString(\"Changed!\")\n        }\n    } \n```", "```go\n fmt.Println(\"A:\", A)\n} \n```", "```go\n$ go run setValues.go\nA: {1 F2 3}\nString value: <main.T Value>\n0: F1 int = 1\n1: F2 string = F2\n2: F3 float64 = 3\nA: {-100 Changed! 3} \n```", "```go\nfunc (a ar2x2) FunctionName(parameters) <return values> {\n    ...\n} \n```", "```go\nfunc FunctionName(a ar2x2, parameters...) <return values> {\n    ...\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"strconv\"\n)\ntype ar2x2 [2][2]int\n// Traditional Add() function\nfunc Add(a, b ar2x2) ar2x2 {\n    c := ar2x2{}\n    for i := 0; i < 2; i++ {\n        for j := 0; j < 2; j++ {\n            c[i][j] = a[i][j] + b[i][j]\n        }\n    }\n    return c\n} \n```", "```go\n// Type method Add()\nfunc (a *ar2x2) Add(b ar2x2) {\n    for i := 0; i < 2; i++ {\n        for j := 0; j < 2; j++ {\n            a[i][j] = a[i][j] + b[i][j]\n        }\n    }\n} \n```", "```go\n// Type method Subtract()\nfunc (a *ar2x2) Subtract(b ar2x2) {\n    for i := 0; i < 2; i++ {\n        for j := 0; j < 2; j++ {\n            a[i][j] = a[i][j] - b[i][j]\n        }\n    }\n} \n```", "```go\n// Type method Multiply()\nfunc (a *ar2x2) Multiply(b ar2x2) {\n    a[0][0] = a[0][0]*b[0][0] + a[0][1]*b[1][0]\n    a[1][0] = a[1][0]*b[0][0] + a[1][1]*b[1][0]\n    a[0][1] = a[0][0]*b[0][1] + a[0][1]*b[1][1]\n    a[1][1] = a[1][0]*b[0][1] + a[1][1]*b[1][1]\n} \n```", "```go\nfunc main() {\n    if len(os.Args) != 9 {\n        fmt.Println(\"Need 8 integers\")\n        return\n    }\n    k := [8]int{}\n    for index, i := range os.Args[1:] {\n        v, err := strconv.Atoi(i)\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        k[index] = v\n    }\n    a := ar2x2{{k[0], k[1]}, {k[2], k[3]}}\n    b := ar2x2{{k[4], k[5]}, {k[6], k[7]}} \n```", "```go\n fmt.Println(\"Traditional a+b:\", Add(a, b))\n    a.Add(b)\n    fmt.Println(\"a+b:\", a)\n    a.Subtract(a)\n    fmt.Println(\"a-a:\", a)\n    a = ar2x2{{k[0], k[1]}, {k[2], k[3]}} \n```", "```go\n a.Multiply(b)\n    fmt.Println(\"a*b:\", a)\n    a = ar2x2{{k[0], k[1]}, {k[2], k[3]}}\n    b.Multiply(a)\n    fmt.Println(\"b*a:\", b)\n} \n```", "```go\n$ go run methods.go 1 2 0 0 2 1 1 1\nTraditional a+b: [[3 3] [1 1]]\na+b: [[3 3] [1 1]]\na-a: [[0 0] [0 0]]\na*b: [[4 6] [0 0]]\nb*a: [[2 4] [1 2]] \n```", "```go\ntype Interface interface {\n    // Len is the number of elements in the collection.\n    Len() int\n// Less reports whether the element with\n// index i should sort before the element with index j.\n    Less(i, j int) bool\n// Swap swaps the elements with indexes i and j.\n    Swap(i, j int)\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"sort\"\n)\ntype Size struct {\n    F1 int\n    F2 string\n    F3 int\n}\n// We want to sort Person records based on the value of Size.F1\n// Which is Size.F1 as F3 is an Size structure\ntype Person struct {\n    F1 int\n    F2 string\n    F3 Size\n} \n```", "```go\ntype Personslice []Person \n```", "```go\n// Implementing sort.Interface for Personslice\nfunc (a Personslice) Len() int {\n    return len(a)\n} \n```", "```go\n// What field to use when comparing\nfunc (a Personslice) Less(i, j int) bool {\n    return a[i].F3.F1 < a[j].F3.F1\n} \n```", "```go\nfunc (a Personslice) Swap(i, j int) {\n    a[i], a[j] = a[j], a[i]\n} \n```", "```go\nfunc main() {\n    data := []Person{\n        Person{1, \"One\", Size{1, \"Person_1\", 10}},\n        Person{2, \"Two\", Size{2, \"Person_2\", 20}},\n        Person{-1, \"Two\", Size{-1, \"Person_3\", -20}},\n    }\n\n    fmt.Println(\"Before:\", data)\n    sort.Sort(Personslice(data))\n    fmt.Println(\"After:\", data)\n    // Reverse sorting works automatically\n    sort.Sort(sort.Reverse(Personslice(data)))\n    fmt.Println(\"Reverse:\", data)\n} \n```", "```go\n$ go run sort.go\nBefore: [{1 One {1 Person_1 10}} {2 Two {2 Person_2 20}} {-1 Two {-1 Person_3 -20}}]\nAfter: [{-1 Two {-1 Person_3 -20}} {1 One {1 Person_1 10}} {2 Two {2 Person_2 20}}]\nReverse: [{2 Two {2 Person_2 20}} {1 One {1 Person_1 10}} {-1 Two {-1 Person_3 -20}}] \n```", "```go\npackage main\nimport \"fmt\"\ntype S1 struct {\n    F1 int\n    F2 string\n}\ntype S2 struct {\n    F1 int\n    F2 S1\n}\nfunc Print(s interface{}) {\n    fmt.Println(s)\n}\nfunc main() {\n    v1 := S1{10, \"Hello\"}\n    v2 := S2{F1: -1, F2: v1}\n    Print(v1)\n    Print(v2) \n```", "```go\n // Printing an integer\n    Print(123)\n    // Printing a string\n    Print(\"Go is the best!\")\n} \n```", "```go\n{10 Hello}\n{-1 {10 Hello}}\n123\nGo is the best! \n```", "```go\npackage main\nimport \"fmt\"\ntype Secret struct {\n    SecretValue string\n}\ntype Entry struct {\n    F1 int\n    F2 string\n    F3 Secret\n}\nfunc Teststruct(x interface{}) {\n    // type switch\nswitch T := x.(type) {\n    case Secret:\n        fmt.Println(\"Secret type\")\n    case Entry:\n        fmt.Println(\"Entry type\")\n    default:\n        fmt.Printf(\"Not supported type: %T\\n\", T)\n    }\n} \n```", "```go\nfunc Learn(x interface{}) {\n    switch T := x.(type) {\n    default:\n        fmt.Printf(\"Data type: %T\\n\", T)\n    }\n} \n```", "```go\nfunc main() {\n    A := Entry{100, \"F2\", Secret{\"myPassword\"}}\n    Teststruct(A)\n    Teststruct(A.F3)\n    Teststruct(\"A string\")\n    Learn(12.23)\n    Learn('â‚¬')\n} \n```", "```go\n$ go run typeSwitch.go\nEntry type\nSecret type\nNot supported type: string\nData type: float64\nData type: int32 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc returnNumber() interface{} {\n    return 12\n}\nfunc main() {\n    anInt := returnNumber() \n```", "```go\n Number, ok := anInt.(int)\n    if ok {\n        fmt.Println(\"Type assertion successful: \", number)\n    } else {\n        fmt.Println(\"Type assertion failed!\")\n    }\n    number++\n    fmt.Println(number) \n```", "```go\n // The next statement would fail because there\n// is no type assertion to get the value:\n// anInt++\n// The next statement fails but the failure is under \n// control because of the ok bool variable that tells\n// whether the type assertion is successful or not\n    value, ok := anInt.(int64)\n    if ok {\n        fmt.Println(\"Type assertion successful: \", value)\n    } else {\n        fmt.Println(\"Type assertion failed!\")\n    }\n    // The next statement is successful but \n// dangerous because it does not make sure that\n// the type assertion is successful.\n// It just happens to be successful\n    i := anInt.(int)\n    fmt.Println(\"i:\", i)\n    // The following will PANIC because anInt is not bool\n    _ = anInt.(bool)\n} \n```", "```go\n$ go run assertions.go\n13\nType assertion failed!\ni: 12\npanic: interface conversion: interface {} is int, not bool\ngoroutine 1 [running]:\nmain.main()\n    /Users/mtsouk/mGo4th/code/ch05/assertions.go:39 +0x130\nexit status 2 \n```", "```go\npackage main\nimport (\n    \"encoding/json\"\n\"fmt\"\n\"os\"\n)\nvar JSONrecord = `{\n    \"Flag\": true,\n    \"Array\": [\"a\",\"b\",\"c\"],\n    \"Entity\": {\n      \"a1\": \"b1\",\n      \"a2\": \"b2\",\n      \"Value\": -456,\n      \"Null\": null\n    },\n    \"Message\": \"Hello Go!\"\n  }` \n```", "```go\nfunc typeSwitch(m map[string]interface{}) {\n    for k, v := range m {\n        switch c := v.(type) {\n        case string:\n            fmt.Println(\"Is a string!\", k, c)\n        case float64:\n            fmt.Println(\"Is a float64!\", k, c)\n        case bool:\n            fmt.Println(\"Is a Boolean!\", k, c)\n        case map[string]interface{}:\n            fmt.Println(\"Is a map!\", k, c)\n            typeSwitch(v.(map[string]interface{}))\n        default:\n            fmt.Printf(\"...Is %v: %T!\\n\", k, c)\n        }\n    }\n    return\n} \n```", "```go\nfunc exploreMap(m map[string]interface{}) {\n    for k, v := range m {\n        embMap, ok := v.(map[string]interface{})\n        // If it is a map, explore deeper\nif ok {\n            fmt.Printf(\"{\\\"%v\\\": \\n\", k)\n            exploreMap(embMap)\n            fmt.Printf(\"}\\n\")\n        } else {\n            fmt.Printf(\"%v: %v\\n\", k, v)\n        }\n    }\n} \n```", "```go\nfunc main() {\n    if len(os.Args) == 1 {\n        fmt.Println(\"*** Using default JSON record.\")\n    } else {\n        JSONrecord = os.Args[1]\n    }\n    JSONMap := make(map[string]interface{})\n    err := json.Unmarshal([]byte(JSONrecord), &JSONMap) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n        return\n    }\n    exploreMap(JSONMap)\n    typeSwitch(JSONMap)\n} \n```", "```go\n$ go run mapEmpty.go \n*** Using default JSON record.\nFlag: true\nArray: [a b c]\n{\"Entity\":\na2: b2\nValue: -456\nNull: <nil>\na1: b1\n}\nMessage: Hello Go!\n...Is Array: []interface {}!\nIs a map! Entity map[Null:<nil> Value:-456 a1:b1 a2:b2]\nIs a float64! Value -456\n...Is Null: <nil>!\nIs a string! a1 b1\nIs a string! a2 b2\nIs a string! Message Hello Go!\nIs a Boolean! Flag true\n$ go run mapEmpty.go '{\"Array\": [3, 4], \"Null\": null, \"String\": \"Hello Go!\"}'\nArray: [3 4]\nNull: <nil>\nString: Hello Go!\n...Is Array: []interface {}!\n...Is Null: <nil>!\nIs a string! String Hello Go!\n$ go run mapEmpty.go '{\"Array\":\"Error\"' \nunexpected end of JSON input \n```", "```go\ntype error interface {\n    Error() string\n} \n```", "```go\ntype emptyFile struct {\n    Ended bool\n    Read  int\n} \n```", "```go\n// Implement error interface\nfunc (e emptyFile) Error() string {\n    return fmt.Sprintf(\"Ended with io.EOF (%t) but read (%d) bytes\", e.Ended, e.Read)\n} \n```", "```go\n// Check values\nfunc isFileEmpty(e error) bool {\n    // Type assertion\n    v, ok := e.(emptyFile) \n```", "```go\n if ok {\n        if v.Read == 0 && v.Ended == true {\n            return true\n        }\n    }\n    return false\n} \n```", "```go\nfunc readFile(file string) error {\n    var err error\n    fd, err := os.Open(file)\n    if err != nil {\n        return err\n    }\n    defer fd.Close()\n    reader := bufio.NewReader(fd)\n    n := 0\nfor {\n        line, err := reader.ReadString('\\n')\n        n += len(line) \n```", "```go\n if err == io.EOF {\n            // End of File: nothing more to read\nif n == 0 {\n                return emptyFile{true, n}\n            } \n```", "```go\n break\n        } else if err != nil {\n            return err\n        }\n    }\n    return nil\n}\nfunc main() {\n    flag.Parse()\n    if len(flag.Args()) == 0 {\n        fmt.Println(\"usage: errorInt <file1> [<file2> ...]\")\n        return\n    }\n    for _, file := range flag.Args() {\n        err := readFile(file)\n        if isFileEmpty(err) {\n            fmt.Println(file, err) \n```", "```go\n } else if err != nil {\n            fmt.Println(file, err)\n        } else {\n            fmt.Println(file, \"is OK.\")\n        }\n    }\n} \n```", "```go\n$ go run errorInt.go /etc/hosts /tmp/doesNotExist /tmp/empty /tmp /tmp/Empty.txt\n/etc/hosts is OK.\n/tmp/doesNotExist open /tmp/doesNotExist: no such file or directory\n/tmp/empty open /tmp/empty: permission denied\n/tmp read /tmp: is a directory\n/tmp/Empty.txt Ended with io.EOF (true) but read (0) bytes \n```", "```go\ntype Shape2D interface {\n    Perimeter() float64\n} \n```", "```go\ntype Shape2D interface {\n    Perimeter() float64\n} \n```", "```go\ntype circle struct {\n    R float64\n}\nfunc (c circle) Perimeter() float64 {\n    return 2 * math.Pi * c.R\n} \n```", "```go\nfunc main() {\n    a := circle{R: 1.5}\n    fmt.Printf(\"R %.2f -> Perimeter %.3f \\n\", a.R, a.Perimeter())\n    _, ok := interface{}(a).(Shape2D)\n    if ok {\n        fmt.Println(\"a is a Shape2D!\")\n    }\n    i := 12\n    _, ok = interface{}(i).(Shape2D)\n    if ok {\n        fmt.Println(\"i is a Shape2D!\")\n    }\n} \n```", "```go\nR 1.50 -> Perimeter 9.425 \na is a Shape2D! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\ntype IntA interface {\n    foo()\n}\ntype IntB interface {\n    bar()\n}\ntype IntC interface {\n    IntA\n    IntB\n} \n```", "```go\ntype a struct {\n    XX int\n    YY int\n}\ntype b struct {\n    AA string\n    XX int\n}\ntype c struct {\n    A a\n    B b\n} \n```", "```go\nfunc processA(s IntA) {\n    fmt.Printf(\"%T\\n\", s)\n} \n```", "```go\n// Satisfying IntA\nfunc (varC c) foo() {\n    fmt.Println(\"Foo Processing\", varC)\n} \n```", "```go\n// Satisfying IntB\nfunc (varC c) bar() {\n    fmt.Println(\"Bar Processing\", varC)\n} \n```", "```go\n// Structure compose gets the fields of structure a\ntype compose struct {\n    field1 int\n    a\n} \n```", "```go\n// Different structures can have methods with the same name\nfunc (A a) A() {\n    fmt.Println(\"Function A() for A\")\n}\nfunc (B b) A() {\n    fmt.Println(\"Function A() for B\")\n}\nfunc main() {\n    var iC c = c{a{120, 12}, b{\"-12\", -12}} \n```", "```go\n iC.A.A()\n    iC.B.A() \n```", "```go\n // The following will not work\n// iComp := compose{field1: 123, a{456, 789}}\n// iComp := compose{field1: 123, XX: 456, YY: 789}\n    iComp := compose{123, a{456, 789}}\n    fmt.Println(iComp.XX, iComp.YY, iComp.field1) \n```", "```go\n iC.bar()\n    processA(iC)\n} \n```", "```go\n$ go run objO.go\nFunction A() for A\nFunction A() for B\n456 789 123\nBar Processing {{120 12} {-12 -12}}\nmain.c \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\ntype Numeric interface {\n    int | int8 | int16 | int32 | int64 | float64\n} \n```", "```go\nfunc Print(s interface{}) {\n    // type switch\nswitch s.(type) { \n```", "```go\n case int:\n        fmt.Println(s.(int)+1) \n```", "```go\n case float64:\n        fmt.Println(s.(float64)+1) \n```", "```go\n default:\n        fmt.Println(\"Unknown data type!\")\n    }\n} \n```", "```go\nfunc PrintGenerics[T any](s T) {\n    fmt.Println(s)\n} \n```", "```go\nfunc PrintNumeric[T Numeric](s T) {\n    fmt.Println(s+1)\n} \n```", "```go\nfunc main() {\n    Print(12)\n    Print(-1.23)\n    Print(\"Hi!\") \n```", "```go\n PrintGenerics(1)\n    PrintGenerics(\"a\")\n    PrintGenerics(-2.33) \n```", "```go\n PrintNumeric(1)\n    PrintNumeric(-2.33)\n} \n```", "```go\n13\n-0.22999999999999998\nUnknown data type! \n```", "```go\n1\na\n-2.33 \n```", "```go\n2\n-1.33 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"reflect\"\n)\nfunc PrintReflection(s interface{}) {\n    fmt.Println(\"** Reflection\")\n    val := reflect.ValueOf(s)\n    if val.Kind() != reflect.Slice {\n        return\n    }\n    for i := 0; i < val.Len(); i++ {\n        fmt.Print(val.Index(i).Interface(), \" \")\n    }\n    fmt.Println()\n} \n```", "```go\nfunc PrintSlice[T any](s []T) {\n    fmt.Println(\"** Generics\")\n    for _, v := range s {\n        fmt.Print(v, \" \")\n    }\n    fmt.Println()\n} \n```", "```go\nfunc main() {\n    PrintSlice([]int{1, 2, 3})\n    PrintSlice([]string{\"a\", \"b\", \"c\"})\n    PrintSlice([]float64{1.2, -2.33, 4.55})\n    PrintReflection([]int{1, 2, 3})\n    PrintReflection([]string{\"a\", \"b\", \"c\"})\n    PrintReflection([]float64{1.2, -2.33, 4.55})\n} \n```", "```go\n** Generics\n1 2 3\n** Generics\na b c\n** Generics\n1.2 -2.33 4.55 \n```", "```go\n** Reflection\n1 2 3\n** Reflection\na b c\n** Reflection\n1.2 -2.33 4.55 \n```", "```go\ntype DataFile struct {\n    Filename string\n    Len      int\n    Minimum  float64\n    Maximum  float64\n    Mean     float64\n    StdDev   float64\n} \n```", "```go\ntype DFslice []DataFile \n```", "```go\nfunc (a DFslice) Len() int {\n    return len(a)\n}\nfunc (a DFslice) Less(i, j int) bool {\n    return a[i].Mean < a[j].Mean\n}\nfunc (a DFslice) Swap(i, j int) {\n    a[i], a[j] = a[j], a[i]\n} \n```", "```go\nfunc main() {\n    if len(os.Args) == 1 {\n        fmt.Println(\"Need one or more file paths!\")\n        return\n    }\n    // Slice of DataFile structures\n    files := DFslice{} \n```", "```go\nfor i := 1; i < len(os.Args); i++ {\n        file := os.Args[i]\n        **currentFile := DataFile{}**\n        currentFile.Filename = file\n        values, err := readFile(file)\n        if err != nil {\n            fmt.Println(\"Error reading:\", file, err)\n            os.Exit(0)\n        } \n```", "```go\n currentFile.Len = len(values)\n        currentFile.Minimum = slices.Min(values)\n        currentFile.Maximum = slices.Max(values)\n        meanValue, standardDeviation := stdDev(values)\n        currentFile.Mean = meanValue\n        currentFile.StdDev = standardDeviation\n        files = append(files, currentFile)\n    } \n```", "```go\n sort.Sort(files)\n    for _, val := range files {\n        f := val.Filename\n        fmt.Println(f,\":\",val.Len,val.Mean,val.Maximum,val.Minimum)\n    }\n} \n```", "```go\n$ go run stats.go d1.txt d2.txt d3.txt\nMean value: 3.00000\nMean value: 18.20000\nMean value: 0.75000\nd3.txt : 4 0.75 102 -300\nd1.txt : 5 3 5 1\nd2.txt : 5 18.2 100 -4 \n```"]