- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might wonder what happens if you want to sort user-defined data structures,
    such as phone records or numeric data, based on your own criteria, such as a surname
    or a statistical property such as the mean value of a dataset. What happens when
    you want to sort different datasets that share a common behavior without having
    to implement sorting from scratch for each one of the different data types using
    multiple functions? Also, imagine that you want to write a utility that sorts
    uncommon data. For example, imagine that you want to sort a slice that holds various
    kinds of 3D shapes based on their volume. Can this be performed easily and in
    a way that makes sense?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to all these questions and concerns is the use of interfaces. However,
    interfaces are not just about data manipulation and sorting. Interfaces are about
    expressing abstractions and identifying and defining behaviors that can be shared
    among different data types. Once you have implemented an interface for a data
    type, a new world of functionality becomes available for the variables and the
    values of that type, which can save you time and increase your productivity. Interfaces
    work with *methods on types* or *type methods*, which are like functions attached
    to given data types, which, in Go, are usually structures. In Go, interfaces are
    satisfied implicitly. This means that you do not explicitly declare that a type
    implements an interface. Instead, a type is considered to implement an interface
    if it provides implementations for all the methods declared by that interface.
    Now, let us talk about the *empty interface*, which is represented by `interface{}`.
    The empty interface specifies zero methods, meaning that any type satisfies the
    empty interface. This can be powerful but also requires caution because it essentially
    says “I can hold a value of any type.”
  prefs: []
  type: TYPE_NORMAL
- en: Another handy yet advanced Go feature is reflection, which allows you to examine
    the internal structure of a data type at execution time. However, as reflection
    is an advanced Go feature, you might not need to use it on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces versus generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection versus generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the statistics application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin this chapter with reflection, which is an advanced Go feature, not
    because it is an easy subject but because it is going to help you understand how
    Go works with different data types, including interfaces, and why it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how you can find out the names of the fields of a structure
    at execution time. In such cases, you need to use reflection. Apart from enabling
    you to print the fields and the values of a structure, reflection also allows
    you to explore and manipulate unknown structures like the ones created from decoding
    JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two main questions that I asked myself when I was introduced to reflection
    for the first time were the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is reflection included in Go?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should reflection be used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To answer the first question, reflection allows you to dynamically learn the
    type of an arbitrary object along with information about its structure. Go provides
    the `reflect` package for working with reflection. The `fmt.Println()` function
    is clever enough to understand the data types of its parameters and act accordingly
    because, behind the scenes, the `fmt` package uses reflection to do that.
  prefs: []
  type: TYPE_NORMAL
- en: As far as the second question is concerned, reflection allows you to handle
    and work with data types that do not exist at the time at which you write your
    code but might exist in the future, which is when we use an existing package with
    new user-defined data types—Go functions can accept unknown data types with the
    use of the empty interface. Additionally, reflection might come in handy when
    you have to work with data types that do not implement a common interface and
    therefore have an uncommon or unknown behavior—this does not mean that they have
    bad or erroneous behavior, just uncommon/unusual behavior such as user-defined
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are covered later in this chapter, so stay tuned for more!
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of generics in Go might make the use of reflection less frequent
    in some cases because, with generics, you can work with different data types more
    easily and without the need to know their exact data types in advance. However,
    nothing beats reflection for fully exploring the structure and the data types
    of a variable. We compare reflection with generics at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The most useful parts of the `reflect` package are two data types named `reflect.Value`
    and `reflect.Type`. `reflect.Value` is used for storing values of any type, whereas
    `reflect.Type` is used for representing Go types. There exist two functions named
    `reflect.TypeOf()` and `reflect.ValueOf()` that return `reflect.Type` and `reflect.Value`
    values, respectively. Note that `reflect.TypeOf()` returns the actual type of
    a variable—if we are examining a structure, it returns the name of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: As structures are really important in Go, the `reflect` package offers the `reflect.NumField()`
    method for listing the number of fields in a structure as well as the `Field()`
    method for getting the `reflect.Value` value of a specific field of a structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reflect` package also defines the `reflect.Kind` data type, which is used
    for representing the specific data type of a variable: `int`, `struct`, etc. The
    documentation of the `reflect` package lists all possible values of the `reflect.Kind`
    data type. The `Kind()` function returns the kind of a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Last, the `Int()` and `String()` methods return the integer and string value
    of `reflect.Value`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection code can look unpleasant and hard to read sometimes. Therefore, according
    to the Go philosophy, you should rarely use reflection unless it is necessary
    because, despite its cleverness, it does not create clean code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the internal structure of a Go structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next utility shows how to use reflection to discover the internal structure
    and fields of a Go structure variable. Type it and save it as `reflection.go`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We begin by defining a `Record` structure variable that contains another structure
    value (`Secret{"Mihalis", "Tsoukalos"}`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This returns the `reflect.Value` of the `A` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using `Type()` is how we get the data type of a variable—in this case, variable
    `A`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The previous `for` loop allows the visiting of all fields of a structure and
    the examination of their characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous `fmt.Printf()` statements return the name, the data type, and the
    value of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To check the data type of a variable with a string, we need to convert the data
    type into a `string` variable first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the internal representation of a data type during checking.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `reflection.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`main.Record` is the full unique name of the structure as defined by Go—`main`
    is the package name and `Record` is the `struct` name. This happens so that Go
    can differentiate between the elements of different packages.'
  prefs: []
  type: TYPE_NORMAL
- en: The presented code does not modify any values of the structure. If you were
    to make changes to the values of the structure fields, you would use the `Elem()`
    method and pass the structure as a pointer to `ValueOf()`—remember that pointers
    allow you to make changes to actual variables. There exist methods for modifying
    existing values. In our case, we are going to use `SetString()` to modify a `string`
    field and `SetInt()` to modify an `int` field.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is illustrated in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Changing structure values using reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learning about the internal structure of a Go structure is handy, but what is
    more practical is being able to change values in the Go structure, which is the
    subject of this subsection. However, keep in mind that this approach is an exception
    and that the vast majority of Go programs should not need to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: Type the following Go code and save it as `setValues.go`—it can also be found
    in the GitHub repository of the book inside the `ch05` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`A` is the variable that is being examined in this program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the use of `Elem()` and a pointer to variable `A`, variable `A` can be
    modified if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We are using `SetInt()` to modify an integer value (`reflect.Int`) and `SetString()`
    to modify a string value (`reflect.String`). Integer values are set to `-100`
    and string values are set to `Changed!`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `setValues.go` creates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first line of output shows the initial version of `A`, whereas the last
    line shows the final version of `A` with the modified fields. The main use of
    such code is for dynamically changing the values of the fields of a structure
    without knowing the internals of the structure in advance.
  prefs: []
  type: TYPE_NORMAL
- en: The three disadvantages of reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without a doubt, reflection is a powerful Go feature. However, as with all
    tools, reflection should be used sparingly for three main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The first reason is that extensive use of reflection will make your programs
    hard to read and maintain. A potential solution to this problem is good documentation,
    but developers are notorious for not having the time to write proper documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason is that the Go code that uses reflection makes your programs
    slower. Generally speaking, **Go code that works with a particular data type is
    always faster than Go code that uses reflection to dynamically work with any Go
    data type**. Additionally, such dynamic code makes it difficult for tools to refactor
    or analyze your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last reason is that reflection errors cannot be caught at build time and
    are reported at runtime as panics, which means that reflection errors can potentially
    crash your programs. This can happen months or even years after the development
    of a Go program! One solution to this problem is extensive testing before a dangerous
    function call. However, this adds even more Go code to your programs, which makes
    them even slower.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the disadvantages of reflection in mind, it is important to remember that
    reflection is needed for cases such as JSON and XML serialization, dynamic code
    generation, and dynamic mapping of Go structs to database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about reflection and what it can do for us, it is time to begin
    the discussion about type methods, which are necessary for understanding interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Type methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **type method** is a *function that is attached to a specific data type*.
    Although type methods (or methods on types) are functions, in reality, they are
    defined and used in a slightly different way.
  prefs: []
  type: TYPE_NORMAL
- en: The methods on types feature gives some object-oriented capabilities to Go,
    which is very handy, and it’s used extensively in Go. Additionally, interfaces
    require type methods to work.
  prefs: []
  type: TYPE_NORMAL
- en: Defining new type methods is as simple as creating new functions, provided that
    you follow certain rules that associate the function with a data type.
  prefs: []
  type: TYPE_NORMAL
- en: Creating type methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, imagine that you want to do calculations with 2x2 matrices. A very natural
    way of implementing that is by defining a new data type and defining type methods
    for adding, subtracting, and multiplying 2x2 matrices using that new data type.
    To make it even more interesting and generic, we are going to create a command
    line utility that accepts the elements of two 2x2 matrices as command line arguments,
    which are eight integer values in total, and performs all three calculations between
    them using the defined type methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'By having a data type called `ar2x2`, you can create a type method named `FunctionName`
    for it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `(a ar2x2)` part is what makes the `FunctionName()` function a type method
    because it associates `FunctionName()` with the `ar2x2` data type. No other data
    type can use that function. However, you are free to implement `FunctionName()`
    for other data types or as a regular function. If you have an `ar2x2` variable
    named `varAr`, you can invoke `FunctionName()` as `varAr.FunctionName(...)`, which
    looks like selecting the field of a structure variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are not obligated to develop type methods if you do not want to unless
    you are dealing with interfaces. Additionally, each type method can be rewritten
    as a regular function. Therefore, `FunctionName()` can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that, under the hood, the Go compiler does turn methods into regular
    function calls with the self-value as the first parameter. However, keep in mind
    that **interfaces require the use of type methods to work**.
  prefs: []
  type: TYPE_NORMAL
- en: The expressions used for selecting a field of a structure or a type method of
    a data type, which would replace the ellipsis after the variable name above, are
    called *selectors*.
  prefs: []
  type: TYPE_NORMAL
- en: Performing calculations between matrices of a given predefined size is one of
    the rare cases where using an array instead of a slice makes more sense because
    you do not have to modify the size of the matrices. Some people might argue that
    using a slice instead of an array pointer is a better practice—you are allowed
    to use what makes more sense to you and the problem at hand. As a rule of thumb,
    arrays should be preferred to slices when a fixed-size, contiguous block of memory
    is required or when performance is a critical concern. So, it is common to use
    slices for most dynamic collections and arrays for situations where a fixed-size,
    performance-critical structure is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the results of a type method are saved in the variable that
    invoked the type method—in order to implement that for the `ar2x2` data type,
    we pass a pointer to the array that invoked the type method, like `func (a *ar2x2)`.
  prefs: []
  type: TYPE_NORMAL
- en: Value and point receivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you already know, a method can be associated with a named type, and the receiver
    of the method can be either a value receiver or a pointer receiver. A value receiver
    is a receiver associated with a method that operates on a copy of the value rather
    than the actual value itself. A pointer receiver is a receiver associated with
    a method that operates directly on the value pointed to by the receiver, rather
    than on a copy of the value.
  prefs: []
  type: TYPE_NORMAL
- en: The choice between value and pointer receivers has implications for how the
    method behaves, particularly in terms of modifying the underlying value and performance
    considerations. In general, it is recommended to use a value receiver when the
    method does not need to modify the state of the receiver, when working with small,
    immutable types, or for methods that logically belong to the value itself, not
    a specific instance. On the other hand, you might prefer to use a pointer receiver
    when the method needs to modify the state of the receiver, when working with large
    data structures to avoid any copying overhead, or for methods that logically belong
    to a particular instance of the type.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection illustrates type methods in action.
  prefs: []
  type: TYPE_NORMAL
- en: Using type methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This subsection shows the use of type methods using the `ar2x2` data type as
    an example. The `Add()` function and the `Add()` method use the exact same algorithm
    for adding two matrices. The only difference between them is the way they are
    called and the fact that the function returns an array, whereas the method saves
    the result to the calling variable because of the use of a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Although adding and subtracting matrices is a straightforward process—you just
    add or subtract each element of the first matrix with the element of the second
    matrix that is located at the same position—matrix multiplication is a more complex
    process. This is the main reason that both addition and subtraction use `for`
    loops, which means that the code can also work with bigger matrices, whereas multiplication
    uses static code that cannot be applied to bigger matrices without major changes.
  prefs: []
  type: TYPE_NORMAL
- en: If you are defining type methods for a structure, you should make sure that
    the names of the type methods do not conflict with any field name of the structure
    because the Go compiler will reject such ambiguities.
  prefs: []
  type: TYPE_NORMAL
- en: Type the following code and save it as `methods.go`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a traditional function that adds two `ar2x2` variables and returns
    their result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a type method named `Add()` that is attached to the `ar2x2` data
    type. The result of the addition is not returned. What happens is that the `ar2x2`
    variable that called the `Add()` method is going to be modified and hold that
    result—this is the reason for using a pointer when defining the type method. If
    you do not want that behavior, you should modify the signature and the implementation
    of the type method to match your needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous method subtracts `ar2x2` `b` from `ar2x2` `a` and the result is
    saved in the `a` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we are working with small arrays, we do the multiplications without using
    any `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `main()` function gets the input and creates two 2x2 matrices. After that,
    it performs the desired calculations with these two matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate `a+b` using two different ways: using a regular function and using
    a type method. As both `a.Add(b)` and `a.Subtract(a)` change the value of `a`,
    we have to initialize `a` before using it again.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Last, we calculate `a*b` and `b*a` to show that they are different because the
    commutative property does not apply to matrix multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `methods.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The input here is two 2x2 matrices, `[[1 2] [0 0]]` and `[[2 1] [1 1]]`, and
    the output is their calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about type methods, it is time to begin exploring interfaces
    as interfaces cannot be implemented without type methods.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface is a Go mechanism for defining behavior that is implemented using
    a set of methods. Interfaces have a core role in Go and can simplify the code
    of your programs when they have to deal with multiple data types that perform
    the same task—recall that `fmt.Println()` works for almost all data types.
  prefs: []
  type: TYPE_NORMAL
- en: But remember, interfaces should not be unnecessarily complex. If you decide
    to create your own interfaces, then you should begin with a common behavior that
    you want to be used by multiple data types. Additionally, you should not design
    your programs by defining interfaces. You should start designing your program
    and wait for common behaviors to reveal themselves and then convert those common
    behaviors into interfaces. Last, if the use of interfaces does not make your code
    simpler, consider removing some or all of your interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces define none, a single, or multiple type methods that need to be implemented.
    **As you already know, once you implement the required type methods of an interface,
    that interface is satisfied implicitly**. In simpler terms, once you implement
    the methods of an interface for a given data type, that interface is satisfied
    automatically for that data type.
  prefs: []
  type: TYPE_NORMAL
- en: The empty interface is defined as just `interface{}`. As the empty interface
    has no methods, it means that it is already implemented by all data types. In
    Go generics terms, the empty interface is called `any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a more formal way, a Go interface type defines (or describes) the behavior
    of other types by specifying a set of methods that need to be implemented to support
    that behavior. For a data type to satisfy an interface, it needs to implement
    all the type methods required by that interface. Therefore, interfaces are abstract
    types that specify a set of methods that need to be implemented so that another
    type can be considered an instance of the interface. So, an interface is two things:
    a set of methods and a data type. Bear in mind that small and well-defined interfaces
    are usually the most popular ones because they can be used in a much larger variety
    of cases.'
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, only create a new interface when you want to share a common
    behavior between two or more concrete data types. This is basically duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage you get from interfaces is that, if needed, you can pass
    a variable of a data type that implements a particular interface to any function
    that expects a parameter of that specific interface, which saves you from having
    to write separate functions for each supported data type. However, Go offers an
    alternative to this with the recent addition of generics.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces can also be used to provide a kind of polymorphism in Go, which is
    an object-oriented concept. *Polymorphism* offers a way of accessing objects of
    different types in the same uniform way when they share a common behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Last, interfaces can be used for composition. In practice, this means that you
    can combine existing interfaces and create new ones that offer the combined behavior
    of the interfaces that were brought together. The next figure shows interface
    composition in a graphical way.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21003_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Interface composition'
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, the previous figure illustrates that because of its definition,
    satisfying interface `ABC` requires satisfying `InterfaceA`, `InterfaceB`, and
    `InterfaceC`. Additionally, any `ABC` variable can be used instead of an `InterfaceA`
    variable, an `InterfaceB` variable, or an `InterfaceC` variable because it supports
    all these three behaviors. Last, only `ABC` variables can be used where an `ABC`
    variable is expected. There is nothing prohibiting you from including additional
    methods in the definition of the `ABC` interface if the combination of existing
    interfaces does not describe the desired behavior accurately.
  prefs: []
  type: TYPE_NORMAL
- en: When you combine existing interfaces, it is better that the interfaces do not
    contain methods with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: What you should keep in mind is that there is no need for an interface to be
    impressive and require the implementation of a large number of methods. In fact,
    the fewer methods an interface has, the more generic and widely used it is going
    to be, which increases its usefulness and therefore its usage.
  prefs: []
  type: TYPE_NORMAL
- en: The subsection that follows illustrates the use of `sort.Interface`.
  prefs: []
  type: TYPE_NORMAL
- en: The sort.Interface interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `sort` package contains an interface named `sort.Interface` that allows
    you to sort slices according to your needs and your data, provided that you implement
    `sort.Interface` for the custom data types stored in your slices. The `sort` package
    defines the `sort.Interface` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can understand from the definition of `sort.Interface` is that in order
    to implement `sort.Interface`, we need to implement the following three type methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Len() int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Less(i, j int) bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Swap(i, j int)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Len()` method returns the length of the slice that will be sorted and helps
    the interface to process all slice elements, whereas the `Less()` method, which
    compares and sorts elements in pairs, defines how elements, are going to be compared
    and therefore sorted. The return value of `Less()` is `bool`, which means that
    `Less()` only cares about whether the element at index `i` is bigger or not than
    the element at index `j` in the way that the two elements are being compared.
    Last, the `Swap()` method is used for swapping two elements of the slice, which
    is required for the sorting algorithm to work.
  prefs: []
  type: TYPE_NORMAL
- en: The following code, which can be found in `sort.go`, illustrates the use of
    `sort.Interface`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `Person` structure includes a field named `F3` that is of the `Size` data
    type, which is also a structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You need to have a slice because all sorting operations work on slices. It is
    for this slice, which should be a new data type that in this case is called `Personslice`,
    that you are going to implement the three type methods of the `sort.Interface`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here is the implementation of `Len()` for the `Personslice` data type. It is
    usually that simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here is the implementation of `Less()` for the `Personslice` data type. This
    method defines the way elements get sorted. In this case, by using a field of
    the embedded data structure (`F3.F1`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is the implementation of the `Swap()` type method that defines the way
    to swap slice elements during sorting. It is usually that simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once you have implemented `sort.Interface`, you are going to see that `sort.Reverse()`,
    which is used for reverse sorting your slice, works automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `sort.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first line shows the elements of the slice as initially stored. The second
    line shows the sorted version, whereas the last line shows the reverse sorted
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now present the handy empty interface.
  prefs: []
  type: TYPE_NORMAL
- en: The empty interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, the empty interface is defined as just `interface{}` and
    is already implemented by all data types. Therefore, variables of any data type
    can be put in the place of a parameter of the empty interface data type.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a function with an `interface{}` parameter can accept variables of
    any data type in this place. However, if you intend to work with `interface{}`
    function parameters without examining their data type inside the function, you
    should process them with statements that work on all data types; otherwise, your
    code may crash or misbehave. Alternatively, you can use generics with proper constraints
    to avoid any undesired effects.
  prefs: []
  type: TYPE_NORMAL
- en: The program that follows defines two structures named `S1` and `S2` but just
    a single function named `Print()` for printing any of them. This is allowed because
    `Print()` requires an `interface{}` parameter that can accept both `S1` and `S2`
    variables. The `fmt.Println(s)` statement inside `Print()` can work with both
    `S1` and `S2`.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a function that accepts one or more `interface{}` parameters and
    you run a statement that can only be applied to a limited number of data types,
    things will not work out well. As an example, not all `interface{}` parameters
    can be multiplied by 5 or be used in `fmt.Printf()` with the `%d` control string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of `empty.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Although `v1` and `v2` are of different data types, `Print()` can work with
    both of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`Print()` can also work with integers and strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `empty.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using the empty interface is easy as soon as you realize that you can pass any
    type of variable in the place of an `interface{}` parameter and you can return
    any data type as an `interface{}` return value. However, with great power comes
    great responsibility—you should be very careful with `interface{}` parameters
    and their return values because, in order to use their real values, you have to
    be sure about their underlying data type. We are going to discuss this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Type assertions and type switches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *type assertion* is a mechanism for working with the underlying concrete value
    of an interface. This mainly happens because interfaces are virtual data types
    without their own values—interfaces just define behavior and do not hold data
    of their own. But what happens when you do not know the data type before attempting
    a type assertion? How can you differentiate between the supported data types and
    the unsupported ones? How can you choose a different action for each supported
    data type? The answer is by using type switches. Type switches use `switch` blocks
    for data types and allow you to differentiate between type assertion values, which
    are data types, and process each data type the way you want. Additionally, **to
    use the empty interface in type switches, you need to use type assertions**.
  prefs: []
  type: TYPE_NORMAL
- en: You can have type switches for all kinds of interfaces and data types in general.
    What is really important is to remember that the order of the `case` clauses in
    a `switch` statement is important as only the first match is going to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the real work begins once you enter the function because this is
    where you need to define the supported data types and the actions that take place
    for each supported data type.
  prefs: []
  type: TYPE_NORMAL
- en: Type assertions use the `x.(T)` notation, where `x` is an interface type and
    `T` is a type, and help you extract the value that is hidden behind the empty
    interface. For a type assertion to work, `x` should not be `nil` and the dynamic
    type of `x` should be identical to the `T` type.
  prefs: []
  type: TYPE_NORMAL
- en: The following code can be found in `typeSwitch.go`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is a type switch with direct support for the `Secret` and `Entry` data
    types only. The `default` case handles the remaining data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `Learn()` function prints the data type of its input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the code calls the desired functions to explore variable `A`.
    Running `typeSwitch.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have managed to execute different code based on the data
    type of the variable passed to `TestStruct()` and `Learn()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strictly speaking, type assertions allow you to perform two main tasks. The
    first task is checking whether an interface value keeps a particular type. When
    used this way, a type assertion returns two values: the underlying value and a
    `bool` value. The underlying value is what you might want to use. However, it
    is the value of the `bool` variable that tells you whether the type assertion
    was successful or not and, therefore, whether you can use the underlying value
    or not. For example, checking whether a variable named `aVar` is of the `int`
    type requires the use of the `aVar.(int)` notation, which returns two values.
    If successful, it returns the real `int` value of `aVar` and `true`. Otherwise,
    it returns `false` as the second value, which means that the type assertion was
    not successful and that the real value could not be extracted. And the second
    task is using the concrete value stored in an interface or assigning it to a new
    variable. This means that if there is a `float64` variable in an interface, a
    type assertion allows you to get that value.'
  prefs: []
  type: TYPE_NORMAL
- en: The functionality offered by the `reflect` package helps Go identify the underlying
    data type and the real value of an `interface{}` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen a variation of the first case where we extract the data
    type stored in an empty interface variable. Now, we are going to learn how to
    extract the real value stored in an empty interface variable. As already explained,
    trying to extract the concrete value from an interface using a type assertion
    can have one of the following two outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: If you use the correct concrete data type, you get the underlying value without
    any issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use an incorrect concrete data type, your program will panic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these are illustrated in `assertions.go`, which contains the next code as
    well as lots of code comments that explain the process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `returnNumber()` function returns an `int` value that is **wrapped in an
    empty interface**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we get the `int` value wrapped in an empty interface variable
    (`anInt`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The last statement panics the program because the `anInt` variable does not
    hold a `bool` value. Running `assertions.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for the panic is written onscreen: `panic: interface conversion:
    interface {} is int, not bool`. What else can the Go compiler do to help you?'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss the `map[string]interface{}` map and its use.
  prefs: []
  type: TYPE_NORMAL
- en: The map[string]interface{} map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a utility that processes its command line arguments; if everything
    goes as expected, then you get the supported types of command line arguments and
    everything goes smoothly. But what happens when something unexpected occurs? In
    that case, the `map[string]interface{}` map is here to help, and this subsection
    shows how! This is just one of the cases where the handy `map[string]interface{}`
    map can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the biggest advantage you get from using a `map[string]interface{}`
    map, or any map that stores an `interface{}` value in general, is that you still
    have your data in its original state and data type. If you use `map[string]string`
    instead, or anything similar, then any data you have is going to be converted
    into a string, which means that you are going to lose information about the original
    data type and the structure of the data you are storing in the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, web services work by exchanging JSON records. If you get a JSON record
    in an anticipated format, then you can process it as expected and everything will
    be fine. However, there are times when you might get an erroneous record or a
    record in an unsupported JSON format. In these cases, using `map[string]interface{}`
    for storing these unknown JSON records (arbitrary data) is a good choice because
    `map[string]interface{}` is good at storing JSON records of unknown types. We
    are going to illustrate that using a utility named `mapEmpty.go` that processes
    arbitrary JSON records given as command line arguments. We process the input JSON
    record in two ways that are similar but not identical. There is no real difference
    between the `exploreMap()` and `typeSwitch()` functions apart from the fact that
    `typeSwitch()` generates a much richer output. The code of `mapEmpty.go` is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This global variable holds the default value of `JSONrecord`, in case there
    is no user input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `typeSwitch()` function uses a type switch for differentiating between the
    values in its input map. If a map is found, then we recursively call `typeSwitch()`
    on the new map in order to examine it even more. The `for` loop allows you to
    examine all the elements of the `map[string]interface{}` map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `exploreMap()` function inspects the contents of its input map. If a map
    is found, then we call `exploreMap()` on the new map recursively in order to examine
    it on its own.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you will learn in *Chapter 7*, *Telling a UNIX System What To Do*, `json.Unmarshal()`
    processes JSON data and converts it into a Go value. Although this value is usually
    a Go structure, in this case, we are using a map as specified by the `map[string]interface{}`
    variable. Strictly speaking, the second parameter of `json.Unmarshal()` is of
    the empty interface data type, which means that its data type can be anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`map[string]interface{}` is extremely handy for storing JSON records when you
    do not know their schema in advance. In other words, `map[string]interface{}`
    is good at **storing arbitrary JSON data of unknown schema**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `mapEmpty.go` produces the following output—bear in mind that you might
    see a different output since maps do not guarantee order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first run is without any command line parameters, which means that the utility
    uses the default value of `JSONrecord` and therefore outputs the hardcoded data.
    The other two executions use user-specified data. First, valid data, and then
    data that does not represent a valid JSON record. The error message in the third
    execution is generated by `json.Unmarshal()` as it cannot understand the schema
    of the erroneous JSON record.
  prefs: []
  type: TYPE_NORMAL
- en: The error data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As promised, we are revisiting the `error` data type because it is an interface
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, in order to satisfy the `error` interface, you just need to implement the
    `Error()` string type method. This does not change the way we use errors to find
    out whether the execution of a function or method was successful or not but shows
    how important interfaces are in Go as they are used transparently all the time.
    However, the crucial question is when you should implement the `error` interface
    on your own instead of using the default one. The answer to that question is when
    you want to give more context to an error condition.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us talk about the `error` interface in a more practical situation.
    When there is nothing more to read from a file, Go returns an `io.EOF` error,
    which, strictly speaking, is not an error condition but a logical part of reading
    a file. If a file is totally empty, you still get `io.EOF` when you try to read
    it for the first time. However, this might cause problems in some situations,
    and you might need to have a way of differentiating between a totally empty file
    and a file that has been read fully and there is nothing more to read. One way
    of dealing with that issue is with the help of the `error` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The code example that is presented here is connected to file I/O. Putting it
    here might generate some questions about reading files in Go—however, I feel that
    this is the appropriate place to put it because it is connected to errors and
    error handling more than it is connected to file reading in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `errorInt.go` without the package and `import` blocks is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`emptyFile` is a new data type that is used in the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is the implementation of the `error` interface for `emptyFile`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is a type assertion for getting an `emptyFile` structure from the `error`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a method for checking whether a file is empty or not. The `if` condition
    translates as: If you have read zero bytes (`v.Read == 0`) and you have reached
    the end of the file (`v.Ended == true`), then the file is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to deal with multiple `error` variables, you should add a type switch
    to the `isFileEmpty()` function after the type assertion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We read the input file line by line—you are going to learn more about file I/O
    in *Chapter 7*, *Telling a UNIX System What to Do*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If we have reached the end of a file (`io.EOF`) and we have read zero characters,
    then we are dealing with an empty file. This kind of context is added to the `emptyFile`
    structure and returned as an error value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is where we check the error message of the `readFile()` function. The order
    we do the checking in is important because only the first match is executed. **This
    means that we must go from more specific cases to more generic ones**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `errorInt.go` produces the following output—your output might differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The first file (`/etc/hosts`) was read without any issues, whereas the second
    file (`/tmp/doesNotExist`) could not be found. The third file (`/tmp/empty`) was
    there but we did not have the required file permissions to read it, whereas the
    fourth file (`/tmp`) was, in reality, a directory. The last file (`/tmp/Empty.txt`)
    was there but was empty, which is the error situation that we wanted to catch
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to write our own interfaces. Creating
    your own interfaces is easy. For reasons of simplicity, we include our own interface
    in the `main` package. However, this is rarely the case as we usually want to
    share our interfaces, which means that interfaces are usually included in Go packages
    other than `main`.
  prefs: []
  type: TYPE_NORMAL
- en: The following code excerpt defines a new interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It is called `Shape2D`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires the implementation of a single method named `Perimeter()` that returns
    a `float64` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from being user-defined, there is nothing special about that interface
    compared to the built-in Go interfaces—you can use it as you do all other existing
    interfaces. So, in order for a data type to satisfy the `Shape2D` interface, it
    needs to implement a type method named `Perimeter()` that returns a `float64`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Go interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code that follows presents the simplest way of using an interface, which
    is by calling its method directly, as if it were a function, to get a result.
    Although this is allowed, it is rarely the case as we usually create functions
    that accept interface parameters in order for these functions to be able to work
    with multiple data types.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses a handy technique for quickly finding out whether a given variable
    is of a given data type that was presented earlier in `assertions.go`. In this
    case, we examine whether a variable is of the `Shape2D` interface by using the
    `interface{}(a).(Shape2D)` notation, where `a` is the variable that is being examined
    and `Shape2D` is the data type against the variable being checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next program is called `Shape2D.go`—its most interesting parts are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is the definition of the `Shape2D` interface that requires the implementation
    of the `Perimeter()` type method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This is where the `circle` type implements the `Shape2D` interface with the
    implementation of the `Perimeter()` type method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As stated before, the `interface{}(a).(Shape2D)` notation checks whether the
    `a` variable satisfies the `Shape2D` interface without using its underlying value
    (`circle{R: 1.5}`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `Shape2D.go` creates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Object-oriented programming in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Go does not support all object-oriented features, it cannot replace an object-oriented
    programming language fully. However, it can mimic some object-oriented concepts.
  prefs: []
  type: TYPE_NORMAL
- en: First, a Go structure with its type methods is like an object with its methods.
    Second, interfaces are like abstract data types that define behaviors and objects
    of the same class, which is similar to polymorphism. Third, Go supports encapsulation,
    which means it supports hiding data and functions from the user by making them
    private to the structure and the current Go package. Last, combining interfaces
    and structures is like composition in object-oriented terminology.
  prefs: []
  type: TYPE_NORMAL
- en: If you really want to develop applications using the object-oriented methodology,
    then choosing Go might not be your best option. As I am not really into Java,
    I would suggest looking at C++ or Python instead. The general rule here is to
    choose the best tool for your job.
  prefs: []
  type: TYPE_NORMAL
- en: You have already seen some of these points earlier in this chapter—the next
    chapter discusses how to define private fields and functions. The example that
    follows, which is named `objO.go`, illustrates composition and polymorphism as
    well as embedding an anonymous structure into an existing one to get all its fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `IntC` interface combines interfaces `IntA` and `IntB`. If you implement
    `IntA` and `IntB` for a data type, then this data type implicitly satisfies `IntC`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This structure has two fields named `A` and `B` that are of the `a` and `b`
    data types, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This function works with data types that satisfy the `IntA` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Structure `c` satisfies `IntA` as it implements `foo()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Now, structure `c` satisfies `IntB`. As structure `c` satisfies both `IntA`
    and `IntB`, it implicitly satisfies `IntC`, which is a composition of the `IntA`
    and `IntB` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This new structure uses an anonymous structure (`a`), which means that it gets
    the fields of that anonymous structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a `c` variable that is composed of an `a` structure and a `b`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here, we access a method of the `a` structure (`A.A()`) and `a` method of the
    `b` structure (`B.A()`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: When using an anonymous structure inside another structure, as we do with `a{456,
    789}`, you can access the fields of the anonymous structure, which is the `a{456,
    789}` structure, directly as `iComp.XX` and `iComp.YY`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Although `processA()` works with `IntA` variables, it can also work with `IntC`
    variables because the `IntC` interface satisfies `IntA`!
  prefs: []
  type: TYPE_NORMAL
- en: All the code in `objO.go` is simplistic compared to the code of a real object-oriented
    programming language that supports abstract classes and inheritance. However,
    it is more than adequate for generating types and elements with an internal structure,
    as well as for having different data types with the same method names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `objO.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of the output show that two different structures can have
    methods with the same name. The third line proves that when using an anonymous
    structure inside one other structure, you can access the fields of the anonymous
    structure directly. The fourth line is the output of the `iC.bar()` call, where
    `iC` is a `c` variable accessing a method from the `IntB` interface. The last
    line is the output of `processA(iC)` that requires an `IntA` parameter and prints
    the real data type of its parameter, which, in this case, is `main.c`.
  prefs: []
  type: TYPE_NORMAL
- en: Evidently, although Go is not an object-oriented programming language, it can
    mimic some of the characteristics of object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses the differences between using interfaces and generics
    to support multiple data types.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces versus generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents a program that increments a numeric value by one using
    interfaces and generics so that you can compare the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: The code of `genericsInterfaces.go` illustrates the two techniques and contains
    the next code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This is where we define a constraint named `Numeric` for limiting the permitted
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `Print()` function uses the empty interface for getting input and a type
    switch to work with that input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, we are using a type switch to differentiate between the supported
    data types—in this case, the supported data types are just `int` and `float64`,
    which have to do with the implementation of the *type switch*. However, adding
    more data types requires code changes, which is not the most efficient solution
    when a large number of data types needs to be supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This branch is how we handle the `in`t case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This branch is how we handle the `float64` case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The `default` branch is how we handle all unsupported data types.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest issue with `Print()` is that due to the use of the empty interface,
    it accepts all kinds of input. As a result, the function signature does not help
    us limit the allowed data types. The second issue with `Print()` is that we need
    to specifically handle each case—handling more cases means writing more code.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the compiler and the developer do not have to guess many
    things with that code, which is not the case with generics, where the compiler
    and the runtime have more work to do. This kind of work introduces delays in the
    execution time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '`PrintGenerics()` is a generic function that can handle all available data
    types simply and elegantly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `PrintNumeric()` function supports all numeric data types with the use of
    the `Numeric` constraint. No need to specifically add code for supporting each
    distinct data type, as happens with `Print()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of `main()` uses `Print()` with various types of input: an `int`
    value, a `float64` value, and a `string` value, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As stated before, `PrintGenerics()` works with all data types, including `string`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The last part of `main()` uses `PrintNumeric()` with numeric values only, due
    to the use of the `Numeric` constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `genericsInterfaces.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The preceding three lines of the output are from the `Print()` function, which
    uses the empty interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The previous three lines of the output are from the `PrintGenerics()` function,
    which uses generics and supports all available data types. As a result, it should
    not blindly increase the value of its input because we do not know for sure that
    we are dealing with a numeric value. Therefore, it just prints the given input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The last two lines are generated by the two `PrintNumeric()` calls, which operate
    using the `Numeric` constraint.
  prefs: []
  type: TYPE_NORMAL
- en: So, in practice, when you have to support multiple data types, the use of generics
    might be a better choice than using interfaces. However, when we want to define
    and use a specific behavior, interfaces are better and more descriptive than generics.
    Such cases include reading data with the `Reader` interface or writing data with
    the `Writer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses the use of reflection as a way of bypassing the use
    of generics.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection versus generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we develop a utility that prints the elements of a slice in
    two ways: first, using reflection, and second, using generics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `genericsReflection.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Internally, the `PrintReflection()` function works with slices only. However,
    as we cannot express that in the function signature, we need to accept an empty
    interface parameter. Put simply, instead of specifying all kinds of slices, it
    makes much more sense to use the empty interface. Additionally, we have to write
    more code to get the desired output and prevent the function from crashing.
  prefs: []
  type: TYPE_NORMAL
- en: In more detail, first, we need to make sure that we are processing a slice (`reflect.Slice`),
    and second, we have to print the slice elements using a `for` loop, which is pretty
    ugly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Once again, **the implementation of the generic function is simpler and therefore
    easier to understand**. Moreover, the function signature specifies that only slices
    are accepted as function parameters—we do not have to perform any additional checks
    for that as this is a job for the Go compiler. Last, we use a simple `for` loop
    with `range` to print the slice elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `main()` function calls `PrintSlice()` and `PrintReflection()` with various
    kinds of input to test their operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `genericsReflection.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The first six lines are produced by taking advantage of generics and print the
    elements of a slice of `int` values, a slice of `string` values, and a slice of
    `float64` values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The last six lines of the output produce the same output but, this time, using
    reflection. There is no difference in the output—all differences are in the code
    found in the implementations of `PrintReflection()` and `PrintSlice()` for printing
    the output. As expected, **generics code is simpler and shorter than Go code that
    uses reflection**, especially when you must support lots of different data types.
    While generics in Go offer a powerful and type-safe way to write reusable code,
    there are scenarios where using reflection might be more suitable, including dynamic
    type handling, working with uncommon types, serialization and deserialization,
    and when implementing custom marshaling and unmarshaling.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, the last section of this chapter is about updating the statistics
    application by reading multiple files and sorting its output by a given statistical
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the statistics application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we are going to do in this section is sort different datasets based on
    their mean value. As a result, the application is going to be able to read multiple
    files, which are going to be given as command line arguments to the utility—we
    are going to learn more about file I/O in *Chapter 7*, *Telling a UNIX System
    What to Do*.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a structure that holds the statistical properties of
    each datafile, use a slice to store all such structures, and sort them based on
    the mean value of each dataset. The last functionality is going to be implemented
    using the `sort.Interface`. Using a structure for keeping the important information
    organized is a common practice. Additionally, we are going to use the `slices.Min()`
    and `slices.Max()` functions for finding the minimum and the maximum value in
    a slice, respectively, which saves us from having to sort the slice.
  prefs: []
  type: TYPE_NORMAL
- en: Although such utilities look naïve at first, they can be the foundation of complex
    machine learning systems. In general, statistics is the foundation of machine
    learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the `DataFile` structure is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define a new data type for a slice of `DataFile` structures,
    which is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: It is for `DFslice` that we are going to implement the `sort.Interface`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The previous three methods satisfy the `sort.Interface` for `DFslice`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `main()` function is presented in four parts, the
    first part being the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In this first part of `main()`, we make sure that we have at least one command
    line argument to process and we define a slice of `DataFile` structures variable
    for keeping the data of each file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `main()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The presented `for` loop processes all input files unless there is an error.
    In case of error, the utility exits with a call to `os.Exit(0)`. A different approach
    would have been to skip the erroneous input file and continue with the next. Additionally,
    the `currentFile` variable keeps the data of the current file in a `DataFile`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `main()` contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we compute all the required statistical properties and
    save them in the `currentFile` variable. Last, the current version of the `currentFile`
    variable is stored in the `files` slice before continuing with the next file,
    if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `main()` comes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the utility sorts the `files` slice and prints information
    about each one of the input files. You can print any data you want from the `files`
    slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `stats.go` using the simplistic data files found in the `ch05` directory
    produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: As the mean value of `d3.txt` is `0.75`, `d3.txt` is presented before `d1.txt`,
    which has a mean value of `3`, and `d2.txt`, which has a mean value of `18.2`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about interfaces, which are like contracts, and
    also about type methods, type assertion, and reflection. Although reflection is
    a very powerful Go feature, it might slow down your Go programs because it adds
    a layer of complexity at runtime. Furthermore, your Go programs could crash if
    you use reflection carelessly. However, reflection is not usually needed unless
    you want to perform low-level tasks with Go variables.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that interfaces specify behavior, specify what you can do, and not
    what a data type is. Code that uses interfaces successfully is more readable,
    more extensible, and simpler to understand. Last, **keep in mind that interfaces
    are implemented implicitly once the required type methods are implemented**.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also discussed writing Go code that follows the principles of object-oriented
    programming. If you are going to remember just one thing from this chapter, it
    should be that Go is not an object-oriented programming language, but it can mimic
    some of the functionality offered by object-oriented programming languages, such
    as Java, Python, and C++. In the last section, we updated the statistics application
    to support the sorting of multiple datasets based on the mean value of a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter discusses semantic versioning, Go packages, functions, and
    workspaces.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to do the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a slice of structures using a structure that you created and sort the
    elements of the slice using a field from the structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the empty interface and a function that allows you to differentiate between
    two different structures that you have created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The documentation of the `reflect` package: [https://pkg.go.dev/reflect](https://pkg.go.dev/reflect)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation of the `sort` package: [https://pkg.go.dev/sort](https://pkg.go.dev/sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with errors in Go 1.13: [https://blog.go.dev/go1.13-errors](https://blog.go.dev/go1.13-errors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of the `sort` package: [https://go.dev/src/sort/](https://go.dev/src/sort/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
