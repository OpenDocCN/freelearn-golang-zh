- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Go Packages and Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go包和函数
- en: The focus of this chapter is on Go packages, which are the Go way of organizing,
    delivering, and using code. Packages are used to organize related functionality
    in your code. As the package author, you design the package, including the public
    API consisting of exported constants, variables, types, and functions. Go also
    supports modules, which contain one or more packages. Modules are versioned following
    SemVer, allowing the module author to release updates and even breaking changes
    using a `major.minor.patch` versioning scheme. This chapter will also explain
    the operation of `defer`, which is typically used for cleaning up and releasing
    resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是Go包，这是Go组织、交付和使用代码的方式。包用于组织代码中的相关功能。作为包的作者，你设计包，包括由导出的常量、变量、类型和函数组成的公共API。Go还支持模块，模块包含一个或多个包。模块按照SemVer进行版本控制，允许模块作者使用`major.minor.patch`版本控制方案发布更新，甚至进行破坏性更改。本章还将解释`defer`的操作，它通常用于清理和释放资源。
- en: Regarding the visibility of package elements, Go follows a simple rule which
    states that functions, variables, data types, structure fields, and so forth that
    begin with an uppercase letter are public, whereas functions, variables, types,
    and so forth that begin with a lowercase letter are private. This is the reason
    why `fmt.Println()` is named `Println()` instead of just `println()`. The same
    rule applies not only to the name of a struct variable but to the fields of a
    struct variable—in practice, this means that you can have a struct variable with
    both private and public fields. However, this rule does not affect package names,
    which are allowed to begin with either uppercase or lowercase letters. In fact,
    the names of packages, including `main`, are in lowercase.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于包元素的可见性，Go遵循一个简单的规则，即以大写字母开头的函数、变量、数据类型、结构字段等是公共的，而以小写字母开头的函数、变量、类型等是私有的。这就是为什么`fmt.Println()`被命名为`Println()`而不是仅仅`println()`的原因。同样的规则不仅适用于结构变量的名称，也适用于结构变量的字段——在实践中，这意味着你可以有一个既有私有字段又有公共字段的结构变量。然而，这个规则不影响包名，包名可以以大写或小写字母开头。实际上，包括`main`在内的包名都是小写的。
- en: 'There is a simple guideline that governs Go: **Do not use any of its features
    prematurely**. This guideline applies to generics, interfaces, and packages. Put
    simply, do not create a package just because you can. Start developing your application
    in the `main` package and write your functions in the `main` package until you
    find out that the same code needs to be used from other Go applications or that
    you are writing too many functions that can be grouped in packages. In that case,
    grouping and putting related functionality in a separate package makes perfect
    sense. Other reasons for developing code in separate packages include the encapsulation,
    testing, and security of exposed functionality.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个简单的指导原则：**不要过早使用其任何功能**。这个原则适用于泛型、接口和包。简单来说，不要仅仅因为可以创建包就创建包。从`main`包开始开发你的应用程序，并在`main`包中编写你的函数，直到你发现相同的代码需要被其他Go应用程序使用，或者你正在编写太多可以分组到包中的函数。在这种情况下，将相关功能分组到单独的包中是非常有意义的。开发代码在单独包中的其他原因包括封装、测试和暴露功能的安全性。
- en: 'In summary, this chapter covers:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章涵盖了：
- en: Go packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go包
- en: Functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Big O complexity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Big O复杂度
- en: Developing your own packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发自己的包
- en: Using GitHub to store Go packages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub存储Go包
- en: Modules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Creating better packages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建更好的包
- en: Creating documentation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文档
- en: Workspaces
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作区
- en: Versioning utilities
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制工具
- en: Go packages
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go包
- en: Everything in Go is delivered in the form of packages. A Go package is a Go
    source file that begins with the `package` keyword, followed by the name of the
    package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的所有内容都是以包的形式提供的。Go包是一个以`package`关键字开始的Go源文件，后面跟着包的名字。
- en: Note that packages can have structure. For example, the `net` package has several
    subdirectories, named `http`, `mail`, `rpc`, `smtp`, `textproto`, and `url`, which
    should be imported as `net/http`, `net/mail`, `net/rpc`, `net/smtp`, `net/textproto`,
    and `net/url`, respectively.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，包可以有结构。例如，`net`包有几个子目录，分别命名为`http`、`mail`、`rpc`、`smtp`、`textproto`和`url`，分别应该导入为`net/http`、`net/mail`、`net/rpc`、`net/smtp`、`net/textproto`和`net/url`。
- en: Apart from the packages of the Go standard library, there are external packages
    that are imported using their full address and that should be downloaded on the
    local machine, before their first use. One such example is [https://github.com/spf13/cobra](https://github.com/spf13/cobra),
    which is stored in GitHub.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Go 标准库的软件包之外，还有使用它们的完整地址导入的外部软件包，在首次使用之前应在本地机器上下载。一个这样的例子是 [https://github.com/spf13/cobra](https://github.com/spf13/cobra)，它存储在
    GitHub 上。
- en: 'Packages are mainly used for grouping **related** functions, variables, and
    constants so that you can transfer them easily and use them in your own Go programs.
    Note that apart from the `main` package, Go packages are not autonomous programs
    and cannot be compiled into executable files on their own. As a result, if you
    try to execute a Go package as if it were an autonomous program, you are going
    to be disappointed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包主要用于将 **相关** 的函数、变量和常量分组，以便您可以轻松地传输它们并在自己的 Go 程序中使用它们。请注意，除了 `main` 软件包之外，Go
    软件包不是独立的程序，不能单独编译成可执行文件。因此，如果您尝试像独立程序一样执行 Go 软件包，您将会失望：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Instead, packages need to be called directly or indirectly from the `main` package
    in order to be used, as we have shown in previous chapters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，为了使用，软件包需要直接或间接地从 `main` 软件包中调用，正如我们在前面的章节中所展示的那样。
- en: About go get and go install
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 go get 和 go install
- en: 'In this subsection, you will learn how to download external Go packages using
    [https://github.com/spf13/cobra](https://github.com/spf13/cobra) as an example.
    The `go get` command for downloading the `cobra` package is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将学习如何使用 [https://github.com/spf13/cobra](https://github.com/spf13/cobra)
    作为示例下载外部 Go 软件包。下载 `cobra` 软件包的 `go get` 命令如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, as we are going to learn in a while, with all recent Go versions, the
    recommended way to download a package is with `go install`. You can learn more
    about that change at [https://go.dev/doc/go-get-install-deprecation](https://go.dev/doc/go-get-install-deprecation).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们很快将要学习的，在所有最近的 Go 版本中，推荐下载软件包的方式是使用 `go install`。您可以在 [https://go.dev/doc/go-get-install-deprecation](https://go.dev/doc/go-get-install-deprecation)
    上了解更多关于这个变化的信息。
- en: Note that you can download the package without using `https://` in its address.
    The results can be found inside the `~/go` directory—the full path is `~/go/src/github.com/spf13/cobra`.
    As the `cobra` package comes with a binary file that helps you structure and create
    command line utilities, you can find that binary file inside `~/go/bin` as `cobra`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以在地址中不使用 `https://` 的情况下下载该软件包。结果可以在 `~/go` 目录中找到——完整路径是 `~/go/src/github.com/spf13/cobra`。由于
    `cobra` 软件包附带一个帮助您构建和创建命令行工具的二进制文件，因此您可以在 `~/go/bin` 中找到该二进制文件，名为 `cobra`。
- en: 'The following output, which was created with the help of the `tree(1)` utility,
    shows a high-level view with 3 levels of detail of the structure of `~/go` on
    my machine:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是通过 `tree(1)` 工具创建的，它显示了我机器上 `~/go` 结构的高级视图，包含 3 个级别的细节：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `x` path, which is displayed near the end of the output, is used by the
    Go team for storing experiment packages that might become part of the standard
    Go library in the future.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出末尾附近显示的 `x` 路径被 Go 团队用于存储可能成为未来标准 Go 库一部分的实验性软件包。
- en: 'Basically, there are three main directories under `~/go`, with the following
    properties:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`~/go` 下有三个主要目录，具有以下属性：
- en: 'The `bin` directory: This is where binary tools are placed.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin` 目录：这是放置二进制工具的地方。'
- en: 'The `pkg` directory: This is where reusable packages are put. The `darwin_amd64`
    directory, which can be found on macOS machines only, contains compiled versions
    of the installed packages. On a Linux machine, you can find a `linux_amd64` directory
    instead of `darwin_amd64`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg` 目录：这是放置可重用软件包的地方。仅在 macOS 机器上可以找到的 `darwin_amd64` 目录包含已安装软件包的编译版本。在 Linux
    机器上，您将找到一个 `linux_amd64` 目录而不是 `darwin_amd64`。'
- en: 'The `src` directory: This is where the source code of the packages is located.
    The underlying structure is based on the URL of the package you are looking for.
    So, the URL for the `github.com/spf13/vipe`r package is `~/go/src/github.com/spf13/viper`.
    If a package is downloaded as a module, then it will be located under `~/go/pkg/mod`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src` 目录：这是软件包源代码所在的位置。其底层结构基于您要查找的软件包的 URL。因此，`github.com/spf13/viper` 软件包的
    URL 是 `~/go/src/github.com/spf13/viper`。如果软件包作为模块下载，则它将位于 `~/go/pkg/mod` 下。'
- en: Starting with Go 1.16, `go install` is the recommended way of building and installing
    packages in module mode and you should only use that way. The use of `go get`
    is deprecated, but this chapter uses `go get` because it is commonly used online
    and is worth knowing about. However, most of the chapters in this book use `go
    mod` `init` and `go mod tidy` for downloading external dependencies for your own
    source files, which is the recommended way.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从Go 1.16版本开始，`go install`是推荐在模块模式下构建和安装包的方式，你应该只使用这种方式。`go get`的使用已被弃用，但本章使用`go
    get`是因为它在网络上很常见，并且值得了解。然而，本书的大部分章节都使用`go mod init`和`go mod tidy`来下载外部依赖项，这是推荐的方式。
- en: 'If you want to upgrade an existing package, you should execute `go get` with
    the `-u` option. Additionally, if you want to see what is happening behind the
    scenes, add the `-v` option to the `go get` command—in this case, we are using
    the Viper package as an example, but we abbreviate the output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要升级现有的包，你应该使用带有`-u`选项的`go get`命令。另外，如果你想查看幕后发生的事情，可以将`-v`选项添加到`go get`命令中——在这个例子中，我们使用Viper包作为示例，但我们简化了输出：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What you can basically see in the output is the dependencies of the initial
    package being downloaded before the desired package—most of the time, you do not
    want to know that.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输出中基本上可以看到的是在下载所需包之前下载的初始包的依赖关系——大多数时候，你并不想了解这些。
- en: 'We will continue this chapter by looking at the most important package element:
    functions.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续本章，通过查看最重要的包元素：函数。
- en: Functions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: The main elements of packages are functions, which are the subject of this section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 包的主要元素是函数，这是本节的主题。
- en: Type methods and functions are implemented in the same way and, sometimes, the
    terms functions and type methods are used interchangeably.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类型方法和函数的实现方式相同，有时函数和类型方法的术语可以互换使用。
- en: 'A piece of advice: functions must be as independent of each other as possible
    and must do one job (and only one job) well. So, if you find yourself writing
    functions that do multiple things, you might want to consider replacing them with
    multiple functions instead.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一条建议：函数应该尽可能地相互独立，并且必须做好一项工作（而且只做一项工作）。所以，如果你发现自己正在编写做多项工作的函数，你可能想要考虑用多个函数来替换它们。
- en: You should already know that all function definitions begin with the `func`
    keyword, followed by the function’s signature and its implementation, and that
    functions accept none, one, or multiple arguments and return none, one, or multiple
    values back. The single most popular Go function is `main()`, which is used in
    every executable Go program—the `main()` function accepts no parameters and returns
    nothing, but it is the starting point of every Go program. Additionally, when
    the `main()` function ends along with the goroutine that executes it, the entire
    program ends as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经知道，所有的函数定义都是以`func`关键字开始的，后面跟着函数的签名和实现，函数可以接受零个、一个或多个参数，并返回零个、一个或多个值。最流行的Go函数是`main()`，它在每个可执行的Go程序中使用——`main()`函数不接受任何参数也不返回任何内容，但它是每个Go程序的起点。此外，当`main()`函数及其执行的goroutine结束时，整个程序也会随之结束。
- en: Anonymous functions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Anonymous functions can be defined inline without the need for a name, and they
    are usually used for implementing things that require a small amount of code.
    In Go, a function can return an anonymous function or take an anonymous function
    as one of its arguments. Additionally, anonymous functions can be attached to
    Go variables. Note that anonymous functions are called *lambdas* in functional
    programming terminology. Similarly, a *closure* is a specific type of anonymous
    function that carries or closes over variables that are in the same lexical scope
    as the anonymous function that was defined.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数可以内联定义，无需命名，通常用于实现需要少量代码的事情。在Go中，一个函数可以返回一个匿名函数，或者将匿名函数作为其参数之一。此外，匿名函数可以附加到Go变量上。请注意，在函数式编程术语中，匿名函数被称为*lambda*。同样，*闭包*是一种特定的匿名函数，它携带或封闭了与匿名函数定义相同的词法作用域中的变量。
- en: It is considered a good practice for anonymous functions to have a small implementation
    and a local focus. If an anonymous function does not have a local focus, then
    you might need to consider making it a regular function. When an anonymous function
    is suitable for a job, it is extremely convenient and makes your life easier;
    just do not use too many anonymous functions in your programs without having a
    good reason. We will look at anonymous functions in action in a while.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是一个好的实践，匿名函数应该有小的实现和局部焦点。如果一个匿名函数没有局部焦点，那么你可能需要考虑将其改为普通函数。当一个匿名函数适合一项工作时，它极其方便，可以使你的生活更轻松；只是不要在没有充分理由的情况下在你的程序中使用太多的匿名函数。我们将在稍后看看匿名函数的实际应用。
- en: Functions that return multiple values
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回多个值的函数
- en: 'As you already know from functions such as `strconv.Atoi()`, functions can
    return multiple distinct values, which saves you from having to create a dedicated
    structure for returning and receiving multiple values from a function. However,
    if you have a function that returns more than 3 values, you should reconsider
    that decision and maybe redesign it to use a single structure or slice for grouping
    and returning the desired values as a single entity—this makes handling the returned
    values simpler and easier. Functions, anonymous functions, and functions that
    return multiple values are all illustrated in `functions.go`, as shown in the
    following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从`strconv.Atoi()`等函数中已经知道，函数可以返回多个不同的值，这使您不必为从函数返回和接收多个值创建一个专门的结构。然而，如果您有一个返回值超过3个的函数，您应该重新考虑这个决定，也许重新设计它以使用单个结构或切片来分组并作为单个实体返回所需的值——这使得处理返回值更简单、更容易。函数、匿名函数以及返回多个值的函数都在`functions.go`中展示，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function returns two `int` values, without the need for having separate
    variables to keep them—the returned values are created on the fly. Note the compulsory
    use of parentheses when a function returns more than one value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回两个`int`类型的值，无需使用单独的变量来保存它们——返回值是即时创建的。注意，当一个函数返回多个值时，必须使用括号。
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding function returns two `int` values as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数也返回两个`int`类型的值。
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous statement reads the two return values of `doubleSquare()` and saves
    them in `d` and `s`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个语句读取了`doubleSquare()`的两个返回值，并将它们保存在`d`和`s`中。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `anF` variable holds an anonymous function that requires a single parameter
    as input and returns a single value. The only difference between an anonymous
    function and a regular one is that the name of the anonymous function is `func()`
    and that there is no `func` keyword.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`anF`变量持有一个需要单个参数作为输入并返回单个值的匿名函数。匿名函数与普通函数的唯一区别是匿名函数的名字是`func()`，并且没有`func`关键字。'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last two statements print the return values of `sortTwo()`. Running `functions.go`
    produces the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个语句打印了`sortTwo()`的返回值。运行`functions.go`将产生以下输出：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The subsection that follows illustrates functions that have named return values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将说明具有命名返回值的函数。
- en: The return values of a function can be named
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的返回值可以命名
- en: Unlike C, Go allows you to name the return values of a Go function. Additionally,
    when such a function has a `return` statement without any arguments, the function
    automatically returns the current value of each named return value, in the order
    in which they were declared in the function signature.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与C语言不同，Go语言允许你为Go函数的返回值命名。此外，当这样的函数有一个不带任何参数的`return`语句时，函数会自动返回每个命名返回值的当前值，其顺序与它们在函数签名中声明的顺序相同。
- en: 'The following function is included in `namedReturn.go`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数包含在`namedReturn.go`中：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `return` statement returns the values stored in the min and max variables—both
    `min` and `max` are defined in the function signature and not in the function
    body.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`return`语句返回了存储在`min`和`max`变量中的值——`min`和`max`都在函数签名中定义，而不是在函数体中。
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This `return` statement is equivalent to `return min, max`, which is based on
    the function signature and the use of named return values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`return`语句等同于`return min, max`，这是基于函数签名和命名返回值的使用。
- en: 'Running `namedReturn.go` produces the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`namedReturn.go`将产生以下输出：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Functions that accept other functions as parameters
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受其他函数作为参数的函数
- en: 'Functions can accept other functions as parameters. The best example of a function
    that accepts another function as an argument can be found in the `sort` package.
    You can provide the `sort.Slice()` function with another function as an argument
    that specifies the way sorting is implemented. The signature of `sort.Slice()`
    is `func Slice(slice interface{}, less func(i, j int) bool)`. This means the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受其他函数作为参数。在`sort`包中可以找到接受另一个函数作为参数的最佳示例。你可以向`sort.Slice()`函数提供一个函数作为参数，该参数指定了排序的实现方式。`sort.Slice()`的签名是`func
    Slice(slice interface{}, less func(i, j int) bool)`。这意味着以下内容：
- en: The `sort.Slice()` function does not return any data.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort.Slice()`函数不返回任何数据。'
- en: The `sort.Slice()` function requires two arguments, a slice of type `interface{}`
    and another function—the slice variable is modified inside `sort.Slice()`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort.Slice()`函数需要两个参数，一个类型为`interface{}`的切片和另一个函数——切片变量在`sort.Slice()`内部被修改。'
- en: The function parameter of `sort.Slice()` is named `less` and should have the
    `func(i, j int) bool` signature—there is no need for you to name the anonymous
    function. The name `less` is required because all function parameters should have
    a name.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort.Slice()`的函数参数名为`less`，应该具有`func(i, j int) bool`签名——你不需要为匿名函数命名。`less`这个名字是必需的，因为所有函数参数都应该有一个名字。'
- en: The `i` and `j` parameters of `less` are indexes of the slice parameter.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`less`的`i`和`j`参数是切片参数的索引。'
- en: Similarly, there is another function in the sort package named `sort.SliceIsSorted()`
    that is defined as `func SliceIsSorted(slice interface{}, less func(i, j int)
    bool) bool`. `sort.SliceIsSorted()` returns a `bool` value and checks whether
    the slice parameter is sorted according to the rules of the second parameter,
    which is a function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在`sort`包中还有一个名为`sort.SliceIsSorted()`的函数，定义为`func SliceIsSorted(slice interface{},
    less func(i, j int) bool) bool`。`sort.SliceIsSorted()`返回一个`bool`值，并检查切片参数是否根据第二个参数（一个函数）的规则排序。
- en: You are not obliged to use an anonymous function in either `sort.Slice()` or
    `sort.SliceIsSorted()`. You can define a regular function with the required signature
    and use that. However, using an anonymous function is more convenient.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`sort.Slice()`或`sort.SliceIsSorted()`中并不强制使用匿名函数。你可以定义一个具有所需签名的常规函数并使用它。然而，使用匿名函数更为方便。
- en: 'The use of both `sort.Slice()` and `sort.SliceIsSorted()` is illustrated in
    the Go program that follows—the name of the source file is `sorting.go`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Go程序展示了`sort.Slice()`和`sort.SliceIsSorted()`的使用——源文件的名称是`sorting.go`：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `if else` block that follows checks the `bool` value of `sort.SliceIsSorted()`
    to determine whether the slice was sorted or not:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`if else`块检查`sort.SliceIsSorted()`的`bool`值以确定切片是否已排序：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The call to `sort.Slice()` sorts the data according to the anonymous function
    that is passed as the second argument to `sort.Slice()`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对`sort.Slice()`的调用根据作为`sort.Slice()`第二个参数传递的匿名函数对数据进行排序。
- en: 'Running `sorting.go` produces the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`sorting.go`会产生以下输出：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Functions can return other functions
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数可以返回其他函数。
- en: 'Apart from accepting functions as arguments, functions can also return anonymous
    functions, which can be handy when the returned function is not always the same
    but depends on the function’s input or other external parameters. This is illustrated
    in `returnFunction.go`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接受函数作为参数外，函数还可以返回匿名函数，这在返回的函数不总是相同而是依赖于函数的输入或其他外部参数时非常有用。这可以在`returnFunction.go`中看到：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The signature of `funRet()` declares that the function returns another function
    with the `func(int) int` signature. The implementation of the function is unknown,
    but it is going to be defined at runtime. Functions are returned using the `return`
    keyword. The developer should take care and save the returned function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`funRet()`函数签名的声明表明该函数返回一个具有`func(int) int`签名的另一个函数。函数的实现是未知的，但它将在运行时定义。函数是通过`return`关键字返回的。开发者应该小心并保存返回的函数。'
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `n` and `-4` are only used for determining the anonymous functions
    that are going to be returned from `funRet()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`n`和`-4`仅用于确定从`funRet()`返回的匿名函数。
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first statement prints the signature of the function whereas the second
    statement prints the function signature and its memory address. The last statement
    also returns the memory address of `j`, because `j` is a pointer to the anonymous
    function and the value of `j(-5)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句打印函数的签名，而第二条语句打印函数签名及其内存地址。最后一条语句还返回 `j` 的内存地址，因为 `j` 是匿名函数的指针以及 `j(-5)`
    的值。
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although both `i` and `j` are called with the same input (`10`), they are going
    to return different values because they store different anonymous functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `i` 和 `j` 都使用相同的输入（`10`）调用，但它们将返回不同的值，因为它们存储了不同的匿名函数。
- en: 'Running `returnFunction.go` generates the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `returnFunction.go` 生成以下输出：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first line of the output shows the data type of the `i` variable that holds
    the return value of `funRet(n)`, which is `func(int) int` as it holds a function.
    The second line of output shows the data type of `j`, as well as the memory address
    where the anonymous function is stored. The third line shows the memory address
    of the anonymous function stored in the `j` variable, as well as the return value
    of `j(-5)`. The last two lines are the return values of `i(10)` and `j(10)`, respectively.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行显示了保存 `funRet(n)` 返回值的 `i` 变量的数据类型，它是 `func(int) int`，因为它保存了一个函数。输出的第二行显示了
    `j` 的数据类型，以及存储匿名函数的内存地址。第三行显示了存储在 `j` 变量中的匿名函数的内存地址，以及 `j(-5)` 的返回值。最后两行分别是 `i(10)`
    和 `j(10)` 的返回值。
- en: So, in this subsection, we learned about functions returning functions. This
    allows Go to benefit from the functional programming paradigm and makes Go functions
    first-class citizens.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本小节中，我们学习了返回函数的函数。这使 Go 语言能够从函数式编程范式中受益，并使 Go 函数成为一等公民。
- en: We are now going to examine variadic functions, which are functions with a variable
    number of parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查可变参数函数，这些函数具有可变数量的参数。
- en: Variadic functions
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数函数
- en: Variadic functions are functions that can accept a variable number of parameters—you
    already know about `fmt.Println()` and `append()`, which are both variadic functions
    that are widely used. In fact, most functions found in the `fmt` package are variadic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数是可以接受可变数量参数的函数——你已经知道 `fmt.Println()` 和 `append()`，它们都是广泛使用的可变参数函数。事实上，`fmt`
    包中的大多数函数都是可变参数函数。
- en: 'The general ideas and rules behind variadic functions are the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数背后的通用思想和规则如下：
- en: Variadic functions use the pack operator, which consists of a `...`, followed
    by a data type. So, for a variadic function to accept a variable number of `int`
    values, the pack operator should be `...int`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变参数函数使用打包操作符，它由一个 `...` 后跟一个数据类型组成。因此，为了使可变参数函数接受可变数量的 `int` 值，打包操作符应该是 `...int`。
- en: The pack operator can only be used once in any given function.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包操作符在任何给定的函数中只能使用一次。
- en: The variable that holds the pack operation is a slice and, therefore, is accessed
    as a slice inside the variadic function.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存打包操作的变量是一个切片，因此，在可变参数函数内部作为切片来访问。
- en: The variable name that is related to the pack operator is always last in the
    list of function parameters.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与打包操作符相关的变量名总是位于函数参数列表的末尾。
- en: When calling a variadic function, you should put a list of values separated
    by `,` in the place of the variable with the pack operator or a slice with the
    unpack operator.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用可变参数函数时，你应该在打包操作符变量或解包操作符切片的位置放置一个由逗号分隔的值列表。
- en: The pack operator can also be used with an empty interface. In fact, most functions
    in the `fmt` package use `...interface{}` to accept a variable number of arguments
    of all data types. You can find the source code of the latest implementation of
    `fmt` at [https://go.dev/src/fmt/](https://go.dev/src/fmt/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打包操作符也可以与空接口一起使用。事实上，`fmt` 包中的大多数函数都使用 `...interface{}` 来接受所有数据类型的可变数量的参数。你可以在
    [https://go.dev/src/fmt/](https://go.dev/src/fmt/) 找到 `fmt` 的最新实现源代码。
- en: However, there is a situation that needs special care here—I made that mistake
    when I was learning Go and I was wondering about the error message I was getting.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个需要特别注意的情况——我在学习 Go 语言时犯了这个错误，我在想我得到的错误信息是什么。
- en: If you try to pass `os.Args`, which is a slice of strings (`[]string`), as `...interface{}`
    to a variadic function, your code will not compile and will generate an error
    message similar to `cannot use os.Args (type []string) as type []interface {}
    in argument to <function_name>`. This happens because the two data types (`[]string`
    and `[]interface{}`) do not have the same representations in memory—this applies
    to all data types. In practice, this means that you cannot write `os.Args...`
    to pass each individual value of the `os.Args` slice to a variadic function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将 `os.Args`（一个字符串切片 `[]string`）作为 `...interface{}` 传递给一个可变参数函数，你的代码将无法编译，并生成类似于
    `cannot use os.Args (type []string) as type []interface {} in argument to <function_name>`
    的错误信息。这是因为这两种数据类型（`[]string` 和 `[]interface{}`）在内存中的表示不同——这适用于所有数据类型。在实践中，这意味着你不能将
    `os.Args...` 写入以将 `os.Args` 切片的每个单独值传递给一个可变参数函数。
- en: On the other hand, if you just use `os.Args`, it will work, but this passes
    the entire slice as a single entity instead of its individual values! This means
    that the `everything(os.Args, os.Args)` statement works but does not do what you
    want.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你只是使用 `os.Args`，它将工作，但这样会将整个切片作为一个单一实体传递，而不是其单独的值！这意味着 `everything(os.Args,
    os.Args)` 语句可以工作，但并不做你想要的事情。
- en: 'The solution to this problem is converting the slice of strings—or any other
    slice—into a slice of `interface{}`. One way to do that is by using the code that
    follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将字符串切片（或任何其他切片）转换为 `interface{}` 切片。实现这一目标的一种方法是通过以下代码：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, you are allowed to use `empty...` as an argument to the variadic function.
    This is the only subtle point related to variadic functions and the pack operator.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `empty...` 作为可变参数函数的参数。这是与可变参数函数和解包操作符相关的唯一微妙之处。
- en: This approach is an exception and should only be used if the user must provide
    the entire `os.Args` slice as a parameter to something like `fmt.Println()`. The
    main reason is that this removes some of the compiler guarantees.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是一个例外，并且只有在用户必须将整个 `os.Args` 切片作为参数传递给类似 `fmt.Println()` 的函数时才应使用。主要原因是因为这消除了编译器的一些保证。
- en: As there is no standard library function to perform that conversion for you,
    you have to write your own code. Note that the conversion takes time as the code
    must visit all slice elements. The more elements the slice has, the more time
    the conversion will take. This topic is also discussed at [https://github.com/golang/go/wiki/InterfaceSlice](https://github.com/golang/go/wiki/InterfaceSlice).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有标准库函数为你执行这种转换，你必须编写自己的代码。请注意，转换需要时间，因为代码必须访问所有切片元素。切片中的元素越多，转换所需的时间就越长。这个话题也在
    [https://github.com/golang/go/wiki/InterfaceSlice](https://github.com/golang/go/wiki/InterfaceSlice)
    中进行了讨论。
- en: 'We are now ready to see variadic functions in action. Type the following Go
    code using your favorite text editor and save it as `variadic.go`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查看可变参数函数的实际应用。使用你喜欢的文本编辑器输入以下 Go 代码，并将其保存为 `variadic.go`：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As variadic functions are built into the grammar of the language, you do not
    need anything extra to support variadic functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可变参数函数是内置于语言语法中的，因此你不需要任何额外的东西来支持可变参数函数。
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a variadic function that accepts a string and an unknown number of `float64`
    values. It prints the string variable and calculates the sum of the `float64`
    values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受一个字符串和未知数量的 `float64` 值的可变参数函数。它打印字符串变量并计算 `float64` 值的总和。
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This `for` loop accesses the pack operator as a slice, so there is nothing special
    here.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `for` 循环将打包操作符作为切片访问，所以这里没有什么特别之处。
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can also access individual elements of the `s` slice.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以访问 `s` 切片的单个元素。
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is another variadic function that accepts an unknown number of `interface{}`
    values.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受未知数量 `interface{}` 值的可变参数函数。
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can put the arguments of a variadic function inline.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将可变参数函数的参数内联。
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But you usually use a slice variable with the unpack operator:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但你通常使用带有解包操作符的切片变量：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous code works because the content of `s` is not unpacked.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码之所以能工作，是因为 `s` 的内容没有被解包。
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can convert `[]string` into `[]interface{}` in order to use the unpack operator.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `[]string` 转换为 `[]interface{}` 以使用解包操作符。
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And now, we can unpack the contents of `empty`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以解包 `empty` 的内容。
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a slightly different way of converting `[]string` into `[]interface{}`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种将 `[]string` 转换为 `[]interface{}` 的稍微不同方法。
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The previous statement works because you are passing the entire `str` variable
    three times—not its contents. So, the slice contains three elements—each element
    is equal to the contents of the `str` variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个语句之所以有效，是因为你传递了整个 `str` 变量三次——而不是它的内容。因此，切片包含三个元素——每个元素等于 `str` 变量的内容。
- en: 'Running `variadic.go` produces the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `variadic.go` 产生以下输出：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The last line of the output shows that we have passed the `str` variable three
    times to the `everything()` function as three separate entities.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一行显示，我们已经将 `str` 变量三次传递给 `everything()` 函数作为三个不同的实体。
- en: Variadic functions really come in handy when you want to have an unknown number
    of parameters in a function. The next subsection discusses the use of `defer`,
    which we have already used multiple times.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数在你想要在函数中有一个未知数量的参数时非常有用。下一小节将讨论 `defer` 的使用，我们已经多次使用过了。
- en: The defer keyword
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`defer` 关键字'
- en: So far, we have seen defer in `ch03/csvData.go`. But what does `defer` do? The
    `defer` keyword postpones the execution of a function until the surrounding function
    returns.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在 `ch03/csvData.go` 中看到了 `defer`。但 `defer` 究竟做了什么？`defer` 关键字将函数的执行推迟到周围函数返回时。
- en: Usually, `defer` is used in file I/O operations to keep the function call that
    closes an opened file close to the call that opened it, so that you do not have
    to remember to close a file that you have opened just before the function exits.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`defer` 在文件 I/O 操作中使用，以便将关闭已打开文件的函数调用与打开它的调用保持接近，这样你就不必记得在函数退出前关闭你刚刚打开的文件。
- en: It is very important to remember that deferred functions are executed in **Last
    In, First Out** (**LIFO**) order after the surrounding function has been returned.
    Putting it simply, this means that if you defer function `f1()` first, function
    `f2()` second, and function `f3()` third in the same surrounding function, then
    when the surrounding function is about to return, function `f3()` will be executed
    first, function `f2()` will be executed second, and function `f1()` will be the
    last one to get executed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点非常重要，即延迟执行的函数在周围函数返回后按 **后进先出**（**LIFO**）顺序执行。简单来说，这意味着如果你在同一个周围函数中首先 `defer`
    函数 `f1()`，然后 `f2()`，最后 `f3()`，那么当周围函数即将返回时，`f3()` 将首先执行，`f2()` 将其次执行，而 `f1()`
    将是最后一个被执行的。
- en: 'In this section, we will discuss the dangers of careless use of `defer` using
    a simple program. The code for `defer.go` is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个简单的程序讨论粗心使用 `defer` 的危险。`defer.go` 的代码如下：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In `d1()`, `defer` is executed inside the function body with just a `fmt.Print()`
    call. Remember that these calls to `fmt.Print()` are executed just before function
    `d1()` returns.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `d1()` 中，`defer` 在函数体内通过一个 `fmt.Print()` 调用来执行。记住，这些对 `fmt.Print()` 的调用是在函数
    `d1()` 返回之前执行的。
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In `d2()`, `defer` is attached to an anonymous function that does not accept
    any parameters. In practice, this means that the anonymous function should get
    the value of `i` on its own—this is dangerous because the current value of `i`
    depends on when the anonymous function is executed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `d2()` 中，`defer` 被附加到一个不接受任何参数的匿名函数上。在实践中，这意味着匿名函数应该自己获取 `i` 的值——这是危险的，因为
    `i` 的当前值取决于匿名函数的执行时间。
- en: The anonymous function is a *closure*, and that is why it has access to variables
    that would normally be out of scope.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是一个 *闭包*，这就是为什么它可以访问通常超出作用域的变量。
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, the current value of `i` is passed to the anonymous function as
    a parameter that initializes the `n` function parameter. This means that there
    are no ambiguities about the value that `i` has.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当前 `i` 的值作为参数传递给匿名函数，以初始化 `n` 函数参数。这意味着关于 `i` 的值没有歧义。
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The task of `main()` is to call `d1()`, `d2()`, and `d3()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 的任务是调用 `d1()`、`d2()` 和 `d3()`。'
- en: 'Running `defer.go` produces the following output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `defer.go` 产生以下输出：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You will most likely find the generated output complicated and challenging to
    understand, which proves that the operation and the results of the use of `defer`
    can be tricky if your code is not clear and unambiguous. Let me explain the results
    so that you get a better idea of how tricky `defer` can be if you do not pay close
    attention to your code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能会发现生成的输出很复杂，难以理解，这证明了如果代码不清晰且不明确，`defer` 的操作和结果可能会很棘手。让我解释一下结果，以便你更好地了解如果不仔细注意你的代码，`defer`
    可能有多棘手。
- en: Let us start with the first line of the output (`1 2 3`) that is generated by
    the `d1()` function. The values of `i` in `d1()` are `3`, `2`, and `1` in that
    order. The function that is deferred in `s` is the `fmt.Print()` statement; as
    a result, when the `d1()` function is about to return, you get the three values
    of the `i` variable of the `for` loop in reverse order. This is because **deferred
    functions are executed in LIFO order**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从由`d1()`函数生成的输出（`1 2 3`）的第一行开始。`d1()`中的`i`值按顺序是`3`、`2`和`1`。在`s`中延迟的函数是`fmt.Print()`语句；因此，当`d1()`函数即将返回时，你会得到`for`循环中`i`变量的三个值的逆序。这是因为**延迟函数是按照后进先出（LIFO）顺序执行的**。
- en: Now, let me explain the second line of the output that is produced by the `d2()`
    function. It is really strange that we got three zeros instead of `1 2 3` in the
    output; however, there is a reason for that – note that this is not an issue with
    `defer` but with closures. After the `for` loop ends, the value of `i` is `0`,
    because it is that value of `i` that made the `for` loop terminate. However, the
    tricky point here is that the deferred anonymous function is evaluated after the
    `for` loop ends because it has no parameters, which means that it is evaluated
    three times for an `i` value of `0`, hence the generated output. This kind of
    confusing code is what might lead to the creation of nasty bugs in your projects,
    so try to avoid it. Go version 1.22 corrects this kind of errors.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我解释由`d2()`函数生成的输出的第二行。我们得到了三个零而不是`1 2 3`，这真的很奇怪；然而，这有一个原因——请注意，这不是`defer`的问题，而是闭包的问题。在`for`循环结束后，`i`的值是`0`，因为正是这个`i`的值使得`for`循环终止。然而，这里的难点在于延迟的匿名函数是在`for`循环结束后评估的，因为它没有参数，这意味着它被评估了三次，对于`i`的值为`0`，因此生成了输出。这种令人困惑的代码可能会导致你的项目中出现讨厌的bug，所以尽量避开它。Go版本1.22纠正了这类错误。
- en: Finally, we will talk about the third line of the output, which is generated
    by the `d3()` function. Due to the parameter of the anonymous function, each time
    the anonymous function is deferred, it gets and therefore uses the current value
    of `i`. As a result, each execution of the anonymous function has a different
    value to process without any ambiguities, hence the generated output.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论由`d3()`函数生成的输出的第三行。由于匿名函数的参数，每次匿名函数被延迟时，它都会获取并因此使用`i`的当前值。因此，每次匿名函数的执行都有一个不同的值要处理，没有任何歧义，因此生成了输出。
- en: 'After that, it should be clear that the best approach to using `defer` is the
    third one, which is exhibited in the `d3()` function, because you intentionally
    pass the desired variable in the anonymous function in an easy-to-read way. Now
    that we have learned about `defer`, it is time to discuss something completely
    different: the Big O notation.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，应该很清楚，使用`defer`的最佳方法就是第三种，这在`d3()`函数中得到了体现，因为你在匿名函数中故意以易于阅读的方式传递所需的变量。现在我们已经了解了`defer`，是时候讨论一些完全不同的事情了：大O符号。
- en: Big O complexity
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大O复杂度
- en: The computational complexity of an algorithm is usually denoted using the popular
    Big O notation. The Big O notation is used for expressing the worst-case scenario
    for the order of growth of an algorithm. It shows how the performance of an algorithm
    changes as the size of the data it processes grows.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的计算复杂度通常使用流行的大O符号表示。大O符号用于表达算法增长顺序的最坏情况。它显示了随着处理的数据规模的增长，算法性能如何变化。
- en: '`O(1)` means constant time complexity, which does not depend on the amount
    of data at hand. `O(n)` means that the execution time is proportional to `n` (linear
    time)—you cannot process data without accessing it, so `O(n)` is considered good.
    `O(n`²`)` (quadratic time) means that the execution time is proportional to `n`².
    `O(n!)` (factorial time) means that the execution time of the algorithm is directly
    proportional to the factorial of `n`. Simply put, if you have to process 100 values
    of some kind, then the `O(n)` algorithm will do about 100 operations, `O(n`²`)`
    is going to perform about 10,000 operations, and the algorithm with the `O(n!)`
    complexity `10`^(158) operations!'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(1)`表示常数时间复杂度，它不依赖于手头的数据量。`O(n)`表示执行时间与`n`成正比（线性时间）——你无法处理未访问的数据，因此`O(n)`被认为是好的。`O(n²)`（二次时间）表示执行时间与`n²`成正比。`O(n!)`（阶乘时间）表示算法的执行时间与`n`的阶乘成正比。简单来说，如果你必须处理100个某种类型的值，那么`O(n)`算法将执行大约100次操作，`O(n²)`将执行大约10,000次操作，而具有`O(n!)`复杂度的算法将执行`10`^(158)次操作！'
- en: Now that we have learned about the Big O notation, it is time to discuss developing
    your own packages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了 Big O 表示法，是时候讨论开发自己的包了。
- en: Developing your own packages
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发自己的包
- en: At some point, you are going to need to develop your own packages to organize
    your code and distribute it if needed. As stated at the beginning of this chapter,
    everything that begins with an uppercase letter is considered public and can be
    accessed from outside its package, whereas all other elements are considered private.
    The only exception to this Go rule is package names—it is a best practice to use
    lowercase package names, even though uppercase package names are allowed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你需要开发自己的包来组织你的代码，并在需要时分发它们。正如本章开头所述，所有以大写字母开头的内容都被认为是公共的，可以从其包外部访问，而所有其他元素都被认为是私有的。Go
    规则的唯一例外是包名——使用小写包名是一种最佳实践，尽管允许使用大写包名。
- en: Compiling a Go package can be done manually, if the package exists on the local
    machine, but it is also done automatically after you download the package from
    the internet, so there is no need to worry about that. Additionally, if the package
    you are downloading contains any errors, you will learn about them when you try
    to download it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包存在于本地机器上，可以手动编译 Go 包，但下载包后也会自动编译，因此无需担心。另外，如果你下载的包中包含任何错误，你将在尝试下载时了解到它们。
- en: 'However, if you want to compile a package that has been saved in the `sqlite06.go`
    file (a combination of SQLite and Chapter 06) on your own, you can use the following
    command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想自己编译保存在 `sqlite06.go` 文件（SQLite 和第 06 章的组合）中的包，可以使用以下命令：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'So, the previous command compiles the `sqlite06.go` file and saves its output
    in the `sqlite06.a` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，之前的命令编译了 `sqlite06.go` 文件，并将输出保存到 `sqlite06.a` 文件中：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The main reason for compiling Go packages on your own is to check for syntax
    or other kinds of errors in your code without actually using them. Additionally,
    you can build Go packages as plugins ([https://pkg.go.dev/plugin](https://pkg.go.dev/plugin))
    or shared libraries. Discussing more about these is beyond the scope of this book.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己编译 Go 包的主要原因是为了检查代码中的语法或其他类型的错误，而不实际使用它们。此外，你可以将 Go 包作为插件 ([https://pkg.go.dev/plugin](https://pkg.go.dev/plugin))
    或共享库来构建。关于这些的更多讨论超出了本书的范围。
- en: The init() function
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: init() 函数
- en: 'Each Go package can optionally have a private function named `init()` that
    is automatically executed at the beginning of execution time—`init()` runs when
    the package is initialized at the beginning of program execution. The `init()`
    function has the following characteristics:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Go 包可以有一个名为 `init()` 的私有函数，它在程序执行开始时自动执行——`init()` 在包初始化时运行。`init()` 函数具有以下特性：
- en: '`init()` takes no arguments.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()` 不接受任何参数。'
- en: '`init()` returns no values.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()` 不返回任何值。'
- en: The `init()` function is optional.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()` 函数是可选的。'
- en: The `init()` function is called implicitly by Go.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()` 函数由 Go 隐式调用。'
- en: You can have an `init()` function in the `main` package. In that case, `init()`
    is executed before the `main()` function. In fact, all `init()` functions are
    always executed prior to the `main()` function.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 `main` 包中有一个 `init()` 函数。在这种情况下，`init()` 在 `main()` 函数之前执行。实际上，所有 `init()`
    函数总是在 `main()` 函数之前执行。
- en: A source file can contain multiple `init()` functions—these are executed in
    the order of declaration.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件可以包含多个 `init()` 函数——这些函数按声明顺序执行。
- en: The `init()` function or functions of a package are executed **only once**,
    even if the package is imported multiple times.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()` 函数或包中的函数仅执行 **一次**，即使包被导入多次。'
- en: Go packages can contain multiple files. Each source file can contain one or
    more `init()` functions.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 包可以包含多个文件。每个源文件可以包含一个或多个 `init()` 函数。
- en: The fact that the `init()` function is a private function by design means that
    it cannot be called from outside the package in which it is contained. Additionally,
    as the user of a package has no control over the `init()` function, you should
    think carefully before using an `init()` function in public packages or changing
    any global state in `init()`.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()` 函数被设计为私有函数的事实意味着它不能从包含它的包外部调用。此外，由于包的使用者无法控制 `init()` 函数，因此在公共包中使用
    `init()` 函数或更改 `init()` 中的任何全局状态之前，你应该仔细思考。'
- en: 'There are some exceptions where the use of `init()` makes sense:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些例外情况，使用 `init()` 是有意义的：
- en: For initializing network connections that might take time prior to the execution
    of package functions or methods.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于初始化在包函数或方法执行之前可能需要花费时间的网络连接。
- en: For initializing connections to one or more servers prior to the execution of
    package functions or methods.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在执行包函数或方法之前初始化连接到一个或多个服务器。
- en: For creating required files and directories.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建所需的文件和目录。
- en: For checking whether required resources are available or not.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于检查所需资源是否可用。
- en: As the order of execution can be perplexing sometimes, in the next subsection,
    we will explain the order of execution in more detail.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行顺序有时可能会令人困惑，在下一小节中，我们将更详细地解释执行顺序。
- en: Order of execution
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行顺序
- en: 'This subsection illustrates how Go code is executed. As an example, if a `main`
    package imports package `A` and package `A` depends on package `B`, then the following
    will take place:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节说明了 Go 代码是如何执行的。例如，如果 `main` 包导入了包 `A`，而包 `A` 依赖于包 `B`，那么以下情况将会发生：
- en: The process starts with the `main` package.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程从 `main` 包开始。
- en: The `main` package imports package `A`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 包导入包 `A`。'
- en: Package `A` imports package `B`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包 `A` 导入包 `B`。
- en: The global variables, if any, in package `B` are initialized.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有，包 `B` 中的全局变量被初始化。
- en: The `init()` function or functions of package `B`, if they exist, run. This
    is the first `init()` function that gets executed.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，包 `B` 的 `init()` 函数或函数将会运行。这是第一个被执行的 `init()` 函数。
- en: The global variables, if any, in package `A` are initialized.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有，包 `A` 中的全局变量被初始化。
- en: The `init()` function or functions of package `A`, if there are any, run.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有，包 `A` 的 `init()` 函数或函数将会运行。
- en: The global variables in the `main` package are initialized.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 包中的全局变量被初始化。'
- en: The `init()` function or functions of the `main` package, if they exist, run.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`init()` 函数或 `main` 包中的函数（如果存在），将会运行。'
- en: The `main()` function of the `main` package begins its execution.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 包的 `main()` 函数开始执行。'
- en: Notice that if the `main` package imports package `B` on its own, nothing is
    going to happen because everything related to package `B` is triggered by package
    `A`. This is because package `A` imported package `B` first.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 `main` 包单独导入包 `B`，则不会发生任何事，因为与包 `B` 相关的所有内容都是由包 `A` 触发的。这是因为包 `A` 首先导入了包
    `B`。
- en: 'The following diagram shows what is happening behind the scenes regarding the
    order of execution of Go code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了关于 Go 代码执行顺序幕后发生的事情：
- en: '![](img/B21003_06_01.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21003_06_01.png)'
- en: 'Figure 6.1: Go order of code execution'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：Go 代码执行顺序
- en: You can learn more about the order of execution by reading the Go Language Specification
    document at [https://go.dev/ref/spec#Order_of_evaluation](https://go.dev/ref/spec#Order_of_evaluation)
    and about the package initialization process by reading [https://go.dev/ref/spec#Package_initialization](https://go.dev/ref/spec#Package_initialization).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读 [https://go.dev/ref/spec#Order_of_evaluation](https://go.dev/ref/spec#Order_of_evaluation)
    中的 Go 语言规范文档来了解更多关于执行顺序的信息，以及通过阅读 [https://go.dev/ref/spec#Package_initialization](https://go.dev/ref/spec#Package_initialization)
    来了解包初始化过程。
- en: Using GitHub to store Go packages
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub 存储Go包
- en: This section will teach you how to create a GitHub repository where you can
    keep your Go package and make it available to the world.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教你如何创建一个 GitHub 仓库，你可以在这里存放你的 Go 包并将其提供给全世界。
- en: First, you need to create the GitHub repository on your own. The easiest way
    to create a new GitHub repository is by visiting the GitHub website and going
    to the **Repositories** tab, where you can see your existing repositories and
    create new ones. Click the **New** button and type in the necessary information
    for creating a new GitHub repository. If you made your repository public, everyone
    will be able to see it—if it is a private repository, only the people you choose
    are going to be able to look into it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要自己创建 GitHub 仓库。创建新 GitHub 仓库最简单的方法是访问 GitHub 网站，然后转到 **Repositories**
    标签，在那里你可以看到你的现有仓库并创建新的仓库。点击 **New** 按钮，并输入创建新 GitHub 仓库所需的信息。如果你将你的仓库设置为公开，每个人都可以看到它——如果它是一个私有仓库，只有你选择的人才能查看。
- en: Having a clear `README.md` file in your GitHub repository that explains the
    way the Go package works is considered a very good practice.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 GitHub 仓库中有一个清晰的 `README.md` 文件，解释 Go 包的工作方式，这是一个非常好的实践。
- en: 'Next, you need to clone the repository on your local computer. I usually clone
    it using the `git(1)` utility. If the name of the repository is `sqlite06` and
    the GitHub username is `mactsouk`, the `git clone` command is going to look as
    follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要在您的本地计算机上克隆仓库。我通常使用`git(1)`实用程序来克隆它。如果仓库的名称是`sqlite06`，GitHub用户名是`mactsouk`，那么`git
    clone`命令将如下所示：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After that, type `cd sqlite06` and you are done! At this point, you just have
    to write the code of the Go package and remember to `git commit` and `git push`
    the changes to the GitHub repository.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入`cd sqlite06`，您就完成了！在这个时候，您只需编写Go包的代码，并记得将更改`git commit`和`git push`到GitHub仓库。
- en: The best place to host, inspect, develop, or use a Go package is in the `~/go/src`
    directory. Put simply, the purpose of `~/go/src` is to store the source code of
    the packages you create or use.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将Go包托管、检查、开发或使用的最佳位置是`~/go/src`目录。简单来说，`~/go/src`的目的就是存储您创建或使用的包的源代码。
- en: 'The look of such a repository can be seen in *Figure 6.2*—you are going to
    learn more about the `sqlite06` repository in a while:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种仓库的外观可以在*图6.2*中看到——您将在稍后了解更多关于`sqlite06`仓库的信息：
- en: '![A screenshot of a computer  Description automatically generated](img/B21003_06_02.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B21003_06_02.png)'
- en: 'Figure 6.2: A GitHub repository with a Go package'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：一个包含Go包的GitHub仓库
- en: Using GitLab instead of GitHub for hosting your code does not require any changes
    to the way you work.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitLab而不是GitHub来托管您的代码，不需要改变您的工作方式。
- en: If you want to use that package, you just need to `go get` the package using
    its URL and include it in your `import` block—we will see this when we actually
    use it in a program. **The previous process is about developing a Go package,
    not using a Go package**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用该包，只需使用其URL通过`go get`获取该包，并将其包含在您的`import`块中——我们将在实际使用程序时看到这一点。**前面的过程是关于开发Go包，而不是使用Go包**。
- en: The next section presents a Go package that allows you to work with a database.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍一个Go包，允许您与数据库交互。
- en: A package for working with SQLite
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于与SQLite一起工作的包
- en: This section will develop a Go package for working with a given database schema
    stored on an SQLite database, with the end goal of demonstrating how to develop,
    store, and use a package. When interacting with specific schemas and tables in
    your application, you usually create separate packages with all the database-related
    functions—this also applies to NoSQL databases.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将开发一个Go包，用于与存储在SQLite数据库上的给定数据库模式交互，最终目标是展示如何开发、存储和使用包。当与您的应用程序中的特定模式和表交互时，您通常创建包含所有数据库相关函数的单独包——这也适用于NoSQL数据库。
- en: Go offers a generic package ([https://pkg.go.dev/database/sql](https://pkg.go.dev/database/sql))
    for working with databases. However, each database requires a specific package
    that acts as the driver and allows Go to connect and work with that specific database.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个通用的包([https://pkg.go.dev/database/sql](https://pkg.go.dev/database/sql))，用于与数据库交互。然而，每个数据库都需要一个特定的包，作为驱动程序，允许Go连接并使用该特定数据库。
- en: 'The steps for creating the desired Go package are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所需Go包的步骤如下：
- en: Downloading the necessary external Go packages for working with SQLite.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载用于与SQLite一起工作的必要外部Go包。
- en: Creating package files.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包文件。
- en: Developing the required functions.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发所需的功能。
- en: Using the Go package for developing utilities and testing its functionality.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go包来开发实用程序并测试其功能。
- en: Using CI/CD tools for automation (this is optional).
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CI/CD工具进行自动化（这是可选的）。
- en: 'You might be wondering why we would create such a package for working with
    a database and not write the actual commands in our programs when needed. The
    reasons for this include the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么我们会创建这样一个用于与数据库工作的包，而不是在需要时在程序中编写实际的命令。原因包括以下几点：
- en: A Go package can be shared by all team members who work with the application.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go包可以被所有与该应用程序一起工作的团队成员共享。
- en: A Go package allows people to use the database in ways that are documented.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go包允许人们以文档化的方式使用数据库。
- en: The specialized functions you put in your Go package fit your needs a lot better.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在Go包中放入的专业函数非常适合您的需求。
- en: People do not need full access to the database—they just use the package functions
    and the functionality they offer.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们不需要完全访问数据库——他们只需使用包函数和它们提供的功能。
- en: If you ever make changes to the database, people do not need to know about them,
    as long as the functions of the Go package remain the same.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对数据库进行了更改，人们不需要知道这些更改，只要 Go 包的功能保持不变即可。
- en: Put simply, the functions you create can interact with a specific database schema,
    along with its tables and data—it would be almost impossible to work with an unknown
    database schema without knowing how the tables are connected to each other.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你创建的函数可以与特定的数据库模式、表和数据交互——如果不了解表是如何相互连接的，几乎不可能与未知的数据库模式一起工作。
- en: Apart from all these technical reasons, it is really fun to create Go packages
    that are shared among multiple developers!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些技术原因之外，创建供多个开发者共享的 Go 包真的很有趣！
- en: Let us now continue by learning more about the SQLite database.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习更多关于 SQLite 数据库的知识。
- en: Working with SQLite3 and Go
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SQLite3 和 Go
- en: You need to download an additional package for working with a database, such
    as Postgres, SQLite, MySQL, or MongoDB. In this case, we are using SQLite and
    therefore need to download a Go package that allows us to communicate with SQLite.
    The most popular Go package for working with SQLite3 is called `go-sqlite3` and
    can be found at [https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要下载一个额外的包来处理数据库，例如 Postgres、SQLite、MySQL 或 MongoDB。在这种情况下，我们使用 SQLite，因此需要下载一个允许我们与
    SQLite 通信的 Go 包。用于处理 SQLite3 的最流行的 Go 包称为 `go-sqlite3`，可以在 [https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)
    找到。
- en: SQLite databases are single files that are accessed locally and, therefore,
    they do not need any TCP/IP services or other server processes running.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库是单个文件，本地访问，因此不需要任何 TCP/IP 服务或其他服务器进程运行。
- en: You can download that package by running `go get github.com/mattn/go-sqlite3`.
    However, this command no longer works outside of a module. The new way of installing
    the package is by running `go install github.com/mattn/go-sqlite3@latest`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行 `go get github.com/mattn/go-sqlite3` 来下载该包。然而，这个命令在模块外部不再有效。安装包的新方法是运行
    `go install github.com/mattn/go-sqlite3@latest`。
- en: Bear in mind that this package uses cgo, which requires the gcc compiler installed
    on your computer. For more details, visit [https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个包使用 cgo，这需要在你的计算机上安装 gcc 编译器。有关更多详细信息，请访问 [https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)。
- en: 'After the successful execution of the previous command, **the latest version
    of the package** is going to be downloaded. In my case, the source code of the
    `go-sqlite3` package can be found at `~/go/pkg/mod/github.com/mattn`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行前面的命令后，**包的最新版本**将被下载。在我的情况下，`go-sqlite3` 包的源代码可以在 `~/go/pkg/mod/github.com/mattn`
    找到：
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Therefore, the version of the downloaded `go-sqlite3` package is `1.14.22`.
    Alternatively, you can let the `go mod init` and `go mod tidy` commands do the
    job for you.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下载的 `go-sqlite3` 包的版本是 `1.14.22`。或者，你可以让 `go mod init` 和 `go mod tidy` 命令为你完成工作。
- en: Before doing any actual work with SQLite3, we are going to present a simple
    utility that just connects to a database and prints the version of SQLite3\. Such
    utilities are really handy while troubleshooting as they perform simple yet critical
    tasks. As `testSQLite.go` uses an external package, it should be placed under
    `~/go/src` during development and follow the `go mod init` and `go mod tidy` process.
    In my case, `testSQLite.go` is placed in the `~/go/src/github.com/mactsouk/mGo4th/ch06/testSQLite`
    directory.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 SQLite3 进行任何实际工作之前，我们将展示一个简单的实用工具，它只是连接到数据库并打印 SQLite3 的版本。在故障排除时，这些实用工具执行简单但关键的任务，因此非常有用。由于
    `testSQLite.go` 使用外部包，在开发期间应将其放置在 `~/go/src` 下，并遵循 `go mod init` 和 `go mod tidy`
    过程。在我的情况下，`testSQLite.go` 放在 `~/go/src/github.com/mactsouk/mGo4th/ch06/testSQLite`
    目录中。
- en: 'The code of `testSQLite.go` is presented in two parts. The first part is the
    following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`testSQLite.go` 的代码分为两部分。第一部分如下：'
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As the package communicates with SQLite3, we import the `github.com/mattn/go-sqlite3`
    package and we use `_` in front of the package path. This happens because the
    imported package is **registering itself as the database handler** for the `sql`
    package, but it is not being directly used in the code. It is only being used
    through the `sql` package.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该包与 SQLite3 进行通信，我们导入 `github.com/mattn/go-sqlite3` 包，并在包路径前使用 `_`。这是因为导入的包正在**将自己注册为
    `sql` 包的数据库处理器**，但在代码中并未直接使用。它仅通过 `sql` 包来使用。
- en: With the previous code, we use `sql.Open()` to connect to an SQLite3 database,
    which is called `test.db`. If the `test.db` file does not exist, it will be created.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们使用 `sql.Open()` 连接到一个名为 `test.db` 的 SQLite3 数据库。如果 `test.db` 文件不存在，它将被创建。
- en: 'The second part comes with the following Go code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下 Go 代码：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the second part, we query the SQLite database using `db.QueryRow()` in order
    to get information about its version number. `QueryRow()` is handy for executing
    queries that are expected to return at most one row, as in our case. The return
    value of the query is read using `Scan()` and saved in the variable that is the
    parameter of `Scan()` using a pointer. The `os.Remove()` statement deletes the
    `test.db` file—in general, this is not a good practice but it works in this particular
    case.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们使用 `db.QueryRow()` 查询 SQLite 数据库以获取其版本号信息。`QueryRow()` 对于执行预期最多返回一行数据的查询很有用，就像在我们的例子中一样。查询的返回值通过
    `Scan()` 读取，并使用 `Scan()` 的参数指针保存到变量中。`os.Remove()` 语句删除 `test.db` 文件——一般来说，这不是一个好的做法，但在这个特定情况下它是有效的。
- en: Do not forget to execute `go mod init` and `go mod tidy` before you execute
    `testSQLite.go` for the first time.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次执行 `testSQLite.go` 之前，不要忘记执行 `go mod init` 和 `go mod tidy`。
- en: 'Running `testSQLite.go` produces the following output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `testSQLite.go` 产生以下输出：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, let us develop something more advanced. The `connectSQLite3.go` utility
    verifies that you can create an SQLite3 database along with some tables, get a
    list of the available tables, insert and update data in a table, select data from
    a table, delete data, and get the number of records. As the utility uses an external
    package, it should be placed under `~/go/src` and follow the `go mod init` and
    `go mod tidy` process. In my case, `connectSQLite3.go` is placed in `~/go/src/github.com/mactsouk/mGo4th/ch06/connectSQLite3`
    but you can put it anywhere you want as long as it is under `~/go/src`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发一些更高级的内容。`connectSQLite3.go` 工具可以验证你能否创建一个 SQLite3 数据库和一些表，获取可用表的列表，在表中插入和更新数据，从表中选择数据，删除数据，以及获取记录数。由于该工具使用外部包，它应该放在
    `~/go/src` 下，并遵循 `go mod init` 和 `go mod tidy` 的过程。在我的情况下，`connectSQLite3.go`
    放在 `~/go/src/github.com/mactsouk/mGo4th/ch06/connectSQLite3`，但你可以在任何你想放置的地方，只要它位于
    `~/go/src` 之下。
- en: 'The code of `connectSQLite3.go` is going to be presented in six parts, the
    first part being the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectSQLite3.go` 的代码将被分成六个部分，第一部分如下：'
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `insertData()` function is used for inserting data into the database and
    is called by the `main()` function. We first use `db.Prepare()` to construct the
    `INSERT` SQL statement with the desired parameters and then we execute `Exec()`
    to actually insert the data. It is a common practice to use one or more `?` while
    preparing an SQL statement and replace those question marks with the actual values
    when calling `Exec()`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertData()` 函数用于将数据插入到数据库中，并由 `main()` 函数调用。我们首先使用 `db.Prepare()` 构建带有所需参数的
    `INSERT` SQL 语句，然后执行 `Exec()` 实际插入数据。在准备 SQL 语句时使用一个或多个 `?` 是一种常见的做法，并在调用 `Exec()`
    时用实际值替换这些问号。'
- en: 'The second part of `connectSQLite3.go` comes with the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectSQLite3.go` 的第二部分包含以下代码：'
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this second part, we show how to query SQLite3 data and read multiple rows.
    We use `db.Query()` to construct the `SELECT` SQL query, which returns a `*sql.Rows`
    variable. We then read the rows by calling `Next()` multiple times using a `for`
    loop, which automatically terminates when there is no more data to read. As the
    time is stored as text in SQLite, we need to convert it into a proper variable
    using `time.Parse()`. The `selectData()` function prints the data on its own instead
    of returning it to the calling function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第二部分，我们展示了如何查询 SQLite3 数据并读取多行。我们使用 `db.Query()` 构建一个 `SELECT` SQL 查询，它返回一个
    `*sql.Rows` 变量。然后我们通过多次调用 `Next()` 并使用一个 `for` 循环来读取行，当没有更多数据可读时，循环会自动终止。由于时间在
    SQLite 中以文本形式存储，我们需要使用 `time.Parse()` 将其转换为适当的变量。`selectData()` 函数会自行打印数据，而不是将其返回给调用函数。
- en: The `db.Query()` statement does not require `Exec()` to get executed. Therefore,
    we replace `?` with the actual values in the same statement.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.Query()` 语句不需要 `Exec()` 来执行。因此，我们在同一语句中将 `?` 替换为实际值。'
- en: 'The third part is the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分如下：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this part, we connect to the SQLite3 database and create a table named `book`.
    The table has three fields, named `id`, `time`, and `description`. The `db.Exec()`
    statement is used for executing the `CREATE TABLE` SQL command.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们连接到SQLite3数据库并创建一个名为`book`的表。该表有三个字段，分别命名为`id`、`time`和`description`。使用`db.Exec()`语句来执行`CREATE
    TABLE` SQL命令。
- en: 'The fourth part of `connectSQLite3.go` contains the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectSQLite3.go`的第四部分包含以下代码：'
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The previous code inserts ten rows into the `book` table using the `insertData()`
    function and a `for` loop. After that, the `selectData()` function is called for
    selecting data from the `book` table.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用`insertData()`函数和`for`循环将十行插入到`book`表中。之后，调用`selectData()`函数从`book`表中选择数据。
- en: 'The fifth part of `connectSQLite3.go` comes with the following Go code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectSQLite3.go`的第五部分包含以下Go代码：'
- en: '[PRE51]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this part, we present the implementation of the `UPDATE` SQL statement, which
    is based on `db.Exec()`—once again, the values of the `UPDATE` SQL statement are
    passed to `db.Exec()`. After that, we call `selectData()` to see the changes we
    have made. Last, we use `db.Prepare()` to construct a `DELETE` statement, which
    is executed using `Exec()`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们展示了基于`db.Exec()`的`UPDATE` SQL语句的实现——再次强调，`UPDATE` SQL语句的值传递给`db.Exec()`。之后，我们调用`selectData()`来查看我们所做的更改。最后，我们使用`db.Prepare()`构建一个`DELETE`语句，该语句通过`Exec()`执行。
- en: 'The last part of `connectSQLite3.go` is the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectSQLite3.go`的最后部分如下：'
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the last part of the utility, we use `db.Query()` to get the number of rows
    in the `book` table and print the results.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具的最后部分，我们使用`db.Query()`获取`book`表中的行数并打印结果。
- en: 'As expected, before you execute `connectSQLite3.go`, you should execute the
    following commands first:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在执行`connectSQLite3.go`之前，你应该首先执行以下命令：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The last line of the output tells us that the `github.com/mattn/go-sqlite3`
    package was found in our Go installation and therefore it was not downloaded—this
    is a result of the `go get github.com/mattn/go-sqlite3` command we executed earlier.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一行告诉我们，`github.com/mattn/go-sqlite3`包在我们的Go安装中已找到，因此它没有被下载——这是由于我们之前执行的`go
    get github.com/mattn/go-sqlite3`命令的结果。
- en: 'Running `connectSQLite3.go` generates the following kind of output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`connectSQLite3.go`会生成以下类型的输出：
- en: '[PRE54]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The main advantage of the `connectSQLite3.go` utility is that it illustrates
    how to perform a large number of tasks on an SQLite database—most of the presented
    code is going to be reused in the Go package that we are going to create in a
    while.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectSQLite3.go`工具的主要优势是它说明了如何在SQLite数据库上执行大量任务——大部分展示的代码将在我们即将创建的Go包中重用。'
- en: Now that we know how to access and query an SQLite3 database using Go, the next
    task should be to implement the Go package we want to develop.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用Go访问和查询SQLite3数据库，下一个任务应该是实现我们想要开发的Go包。
- en: Storing the Go package
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储Go包
- en: As mentioned earlier, for reasons of simplicity, we will use a public Go repository
    for the Go module, which is named `sqilite06` and can be found at [https://github.com/mactsouk/sqlite06](https://github.com/mactsouk/sqlite06).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，出于简单起见，我们将使用名为`sqilite06`的公共Go仓库作为Go模块，它可以在[https://github.com/mactsouk/sqlite06](https://github.com/mactsouk/sqlite06)找到。
- en: To use that package on your machines, you should `go get` it first, either manually
    or with the help of `go mod init` and `go mod tidy`. However, during development,
    you should begin with `git clone git@github.com:mactsouk/sqlite06.git` to get
    the contents of the GitHub repository and make changes to it until its functionality
    is finalized and there are no bugs. This implies that you have ssh set up with
    GitHub, which is what I usually use. I am doing the development of the `sqilite06`
    package in `~/go/src/github.com/mactsouk/sqlite06`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的机器上使用该包，您应该首先使用`go get`获取它，无论是手动还是通过`go mod init`和`go mod tidy`的帮助。然而，在开发过程中，您应该从`git
    clone git@github.com:mactsouk/sqlite06.git`开始，以获取GitHub仓库的内容并对其进行修改，直到其功能最终确定且没有错误。这意味着您已经设置了与GitHub的ssh连接，这是我通常使用的。我在`~/go/src/github.com/mactsouk/sqlite06`中开发`sqilite06`包。
- en: The design of the Go package
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go包的设计
- en: '*Figure 6.3* shows the database schema that the Go package works on. Remember
    that when working with a specific database and schema, you need to *include* the
    schema information in your Go code. Put simply, the Go code should know about
    the schema it works on:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.3*显示了Go包所工作的数据库模式。记住，当与特定的数据库和模式一起工作时，您需要在您的Go代码中*包含*模式信息。简单来说，Go代码应该知道它所工作的模式：'
- en: '![](img/B21003_06_03.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21003_06_03.png)'
- en: 'Figure 6.3: The two database tables the Go package works on'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：Go包工作的两个数据库表
- en: This is a simple schema that allows us to keep user data and update it. Apart
    from the `Users` table, there is also a table named `Userdata` that holds more
    detailed information about a user. What connects the two tables is the user ID,
    which should be unique. Additionally, the `Username` field on the `Users` table
    should also be unique as two or more users cannot share the same username. Once
    a record is entered in the `Users` table, it cannot be changed, it can only be
    deleted. What can change, however, is the data stored in the `Userdata` table.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的模式，允许我们保存用户数据并更新它。除了`Users`表之外，还有一个名为`Userdata`的表，它包含有关用户的更详细信息。连接两个表的是用户ID，它应该是唯一的。此外，`Users`表上的`Username`字段也应该唯一，因为两个或更多用户不能共享相同的用户名。一旦在`Users`表中输入了记录，就不能更改它，只能删除它。然而，可以更改的是存储在`Userdata`表中的数据。
- en: These two tables should already exist in SQLite, which means that the Go code
    assumes that the relevant tables are in the right place.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个表应该已经在SQLite中存在，这意味着Go代码假设相关的表在正确的位置。
- en: 'The tasks that the Go package should perform to make our lives easier are as
    follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Go包应该执行以使我们的生活更轻松的任务如下：
- en: Create a new user.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新用户。
- en: Delete an existing user.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除现有用户。
- en: Update an existing user.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有用户。
- en: List all users.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有用户。
- en: 'Each of these tasks should have one or more Go functions or methods to support
    it, which is what we are going to implement in the Go package:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务中的每一个都应该有一个或多个Go函数或方法来支持它，这正是我们将在Go包中实现的：
- en: A function to initiate the SQLite3 connection. The helper function to initiate
    the connection is going to be private.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始化SQLite3连接的函数。用于初始化连接的辅助函数将是私有的。
- en: A function that checks whether a given username exists—this is a helper function
    that is also going to be private.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个检查给定用户名是否存在的函数——这是一个也将是私有的辅助函数。
- en: A function that inserts a new user into the database.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将新用户插入数据库的函数。
- en: A function that deletes an existing user from the database.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从数据库中删除现有用户的函数。
- en: A function for updating an existing user.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更新现有用户的函数。
- en: A function for listing all users.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个列出所有用户的函数。
- en: Now that we know the overall structure and functionality of the Go package,
    we should begin implementing it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了Go包的整体结构和功能，我们应该开始实现它。
- en: The implementation of the Go package
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go包的实现
- en: In this subsection, we will implement the Go package for working with the SQLite
    database and the given database schema. We will present each function separately—if
    you combine all these functions, then you have the functionality of the entire
    package.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将实现用于与SQLite数据库和给定数据库模式一起工作的Go包。我们将分别展示每个函数——如果你将这些函数组合起来，那么你就有了整个包的功能。
- en: During package development, you should regularly commit your changes to the
    GitHub or GitLab repository as a backup strategy.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在包开发过程中，你应该定期将你的更改提交到GitHub或GitLab仓库，作为备份策略。
- en: 'All the code of the package is found in a Go source file named `sqlite06.go`.
    The preamble of the package is as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 包的所有代码都位于一个名为`sqlite06.go`的Go源文件中。包的前言如下：
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Filename` variable holds the name of the database file—this is set by the
    applications that use `sqlite06`. For the first time in this book, you will see
    a package name different than `main`, which in this case is `sqlite06`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filename`变量保存数据库文件的名称——这是由使用`sqlite06`的应用程序设置的。在这本书的第一次，你将看到与`main`不同的包名，在这种情况下是`sqlite06`。'
- en: 'The next element that you need in your Go package is one or more structures
    that can hold the data from the database tables. Most of the time, you need as
    many structures as there are database tables—we will begin with that and see how
    it goes. Therefore, we will define the following structures:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你在Go包中需要的下一个元素是能够保存数据库表数据的结构或多个结构。大多数时候，你需要与数据库表一样多的结构——我们将从这里开始，看看效果如何。因此，我们将定义以下结构：
- en: '[PRE56]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you think about this, you should see that there is no point in creating
    two separate Go structures in our case. This is because the `User` structure holds
    no real data, and there is no point in passing multiple structures to the functions
    that process data for the `Users` and `Userdata` SQLite tables. Therefore, we
    can create a single Go structure for holding all the data that has been defined,
    as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你思考这个问题，你应该会看到在我们的情况下创建两个单独的Go结构体是没有意义的。这是因为`User`结构体不包含真实数据，而且没有理由将多个结构体传递给处理`Users`和`Userdata`
    SQLite表的函数。因此，我们可以创建一个单独的Go结构体来保存所有已定义的数据，如下所示：
- en: '[PRE57]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: I have decided to name the structure after the database table for simplicity—however,
    in this case, this is not completely accurate as the `Userdata` structure has
    more fields than the `Userdata` database table.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定为了简单起见，将结构体命名为数据库表名——然而，在这种情况下，这并不完全准确，因为`Userdata`结构体比`Userdata`数据库表有更多的字段。
- en: 'Let us now begin presenting the functions of the package. The `openConnection()`
    function, which is private and only accessed within the scope of the package,
    is defined as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始介绍包的功能。`openConnection()`函数是私有的，并且仅在包的作用域内访问，定义如下：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: SQLite3 does not require a username or a password and does not operate over
    a TCP/IP network. Therefore, `sql.Open()` requires just a single parameter, which
    is the filename of the database.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite3不需要用户名或密码，并且不在TCP/IP网络上操作。因此，`sql.Open()`只需要一个参数，即数据库的文件名。
- en: 'Now, let us consider the `exists()` function, which is also private as it is
    a helper function:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑`exists()`函数，它也是一个私有函数，因为它是一个辅助函数：
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is where we define the query that shows whether the provided username exists
    in the database or not. As all our data is kept in the database, we need to interact
    with the database all the time.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义查询以显示提供的用户名是否存在于数据库中的地方。由于我们所有的数据都保存在数据库中，我们需要始终与数据库交互。
- en: This is one of the rare cases where returning an indication value from a function
    makes more sense as it makes the code less complex than returning an `error` value.
    However, returning an `error` value is still more robust and closer to the Go
    philosophy.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在函数中返回指示值比返回`error`值更有意义的一些罕见情况之一，因为它使代码比返回`error`值更简单。然而，返回`error`值仍然更健壮，更接近Go哲学。
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If the `rows.Scan(&id)` call is executed without any errors, then we know that
    a result has been returned, which is the desired user ID.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`rows.Scan(&id)`调用没有错误执行，那么我们知道已经返回了一个结果，这就是期望的用户ID。
- en: '[PRE61]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The last part of `exists()` frees resources and returns the ID value of the
    username that was given as a parameter to `exists()`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`exists()`函数的最后部分释放资源并返回作为参数传递给`exists()`的用户的ID值。'
- en: 'Here is the implementation of the `AddUser()` function:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`AddUser()`函数的实现：
- en: '[PRE62]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: All usernames are converted into lowercase using `strings.ToLower()` to avoid
    duplicates. This is a design decision.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用户名都使用`strings.ToLower()`转换为小写，以避免重复。这是一个设计决策。
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is how we construct an `INSERT` statement that accepts parameters. The
    presented statement requires one value as there is a single `?`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们构建接受参数的`INSERT`语句的方法。所呈现的语句需要一个值，因为只有一个`?`。
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With `db.Exec()` we pass the value of the parameter, which is kept as `d.Username`,
    into the `insertStatement` variable.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`db.Exec()`，我们将参数的值，即保持为`d.Username`，传递到`insertStatement`变量中。
- en: '[PRE65]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After inserting a new user into the `Users` table, we make sure that everything
    went fine with the help of the `exists()` function, which also returns the user
    ID of the new user. That user ID is used for inserting the relevant data into
    the `Userdata` table.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在将新用户插入`Users`表后，我们使用`exists()`函数确保一切顺利，该函数还返回新用户的ID。这个用户ID用于将相关数据插入`Userdata`表。
- en: '[PRE66]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The presented query needs four values that are signified by four `?` characters.
    As we need to pass four variables to `insertStatement`, we will put four values
    in the `db.Exec()` call. This is the end of the function that adds a new user
    to the database.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现的查询需要四个值，这由四个`?`字符表示。由于我们需要向`insertStatement`传递四个变量，我们将在`db.Exec()`调用中放入四个值。这是添加新用户到数据库的函数的结束。
- en: The implementation of the `DeleteUser()` function is as follows.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteUser()`函数的实现如下。'
- en: '[PRE67]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we double-check whether the given user ID exists or not in the `Users`
    table before trying to delete it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在尝试删除之前，会双重检查给定的用户ID是否存在于`Users`表中。
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If the previously returned username exists and has the same user ID as the
    parameter to `DeleteUser()`, then we can continue the deletion process, which
    contains two steps: First, deleting the relevant user data from the `Userdata`
    table, and, second, deleting the data from the `Users` table.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前返回的用户名存在并且具有与`DeleteUser()`参数相同的用户ID，那么我们可以继续删除过程，这包含两个步骤：首先，从`Userdata`表中删除相关的用户数据，其次，从`Users`表中删除数据。
- en: During development, I included many `fmt.Println()` statements in the package
    code for debugging purposes. However, I have removed most of them in the final
    version of the Go package and replaced them with `error` values. These `error`
    values are passed to the program that uses the functionality of the package, which
    is responsible for deciding what to do with the error messages and error conditions.
    You can also use logging for this—the output can go to standard output or even
    `/dev/null` when not needed.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我在包代码中包含了大量的`fmt.Println()`语句用于调试目的。然而，我在Go包的最终版本中去掉了大部分这些语句，并用`error`值替换了它们。这些`error`值被传递给使用包功能程序的程序，该程序负责决定如何处理错误消息和错误条件。你也可以使用日志记录来做到这一点——输出可以发送到标准输出，甚至在不需要时发送到`/dev/null`。
- en: Now, let us examine the implementation of the `ListUsers()` function.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查`ListUsers()`函数的实现。
- en: '[PRE69]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Once again, we need to open a connection to the database before executing any
    database queries.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在执行任何数据库查询之前，我们需要打开到数据库的连接。
- en: '[PRE70]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is the query that reads all data from the two tables. After that, we use
    the `rows` variable to get the results of the query:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查询从两个表中读取所有数据的查询。之后，我们使用`rows`变量来获取查询的结果：
- en: '[PRE71]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'At this point, we will store the data we have received from the `SELECT` query
    in a `Userdata` structure. This is added to the slice that is going to be returned
    from the `ListUsers()` function. This process continues until there is nothing
    left to read:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将从`SELECT`查询中接收到的数据存储在`Userdata`结构体中。这被添加到将要从`ListUsers()`函数返回的切片中。这个过程会一直持续到没有更多内容可以读取：
- en: '[PRE72]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After updating the contents of the `Data` slice using `append()`, we end the
    query, and the function returns the list of available users, as stored in the
    `Data` variable.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`append()`更新`Data`切片的内容后，我们结束查询，函数返回存储在`Data`变量中的可用用户列表。
- en: 'Lastly, let us examine the `UpdateUser()` function:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来检查`UpdateUser()`函数：
- en: '[PRE73]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: First, we need to make sure that the given username exists in the database—the
    update process is based on the username.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保给定的用户名存在于数据库中——更新过程基于用户名。
- en: '[PRE74]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The update statement stored in `updateStatement` that is executed using the
    desired parameters with the help of `db.Exec()` updates the user data.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`updateStatement`中的更新语句，通过`db.Exec()`使用所需的参数执行，用于更新用户数据。
- en: 'After you finish writing your code, you should execute the following commands:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成编写代码后，你应该执行以下命令：
- en: '[PRE75]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The previous command tells Go that this is a package with external dependencies.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令告诉Go这是一个具有外部依赖的包。
- en: '[PRE76]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `go mod tidy` command downloads all required dependencies, if any.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`go mod tidy`命令下载所有必需的依赖项（如果有）。'
- en: Now that we know the details of how to implement each function in the `sqlite06`
    package, it is time to begin using that package!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在`sqlite06`包中实现每个函数的细节，现在是时候开始使用这个包了！
- en: Testing the Go package
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Go包
- en: In order to test the package, we must develop a command line utility called
    `sqliteGo.go`. As `sqliteGo.go` uses an external package, even if we have developed
    that package, we should not forget to put it somewhere inside `~/go/src`. If you
    download the GitHub repository of the book, you are going to find it in `ch06/usePackage`.
    As `sqliteGo.go` is used for testing purposes only, we hardcoded most of the data
    apart from the username of the user we put into the database. All usernames are
    randomly generated.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个包，我们必须开发一个名为`sqliteGo.go`的命令行工具。由于`sqliteGo.go`使用外部包，即使我们已经开发了那个包，我们也不应该忘记将其放在`~/go/src`的某个地方。如果你下载了这本书的GitHub仓库，你将在`ch06/usePackage`中找到它。由于`sqliteGo.go`仅用于测试目的，我们除了将用户名放入数据库之外，大多数数据都是硬编码的。所有用户名都是随机生成的。
- en: 'The code of `sqliteGo.go` is presented in six parts. The first part is the
    following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqliteGo.go`的代码分为六个部分。第一部分如下：'
- en: '[PRE77]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this first part, we import the necessary Go packages, including our own `sqlite06`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一部分，我们导入必要的Go包，包括我们自己的`sqlite06`。
- en: 'The second part of `sqliteGo.go` comes with the following code:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqliteGo.go`的第二部分包含以下代码：'
- en: '[PRE78]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The previous code generates random strings of a given length. These strings
    contain regular characters in uppercase.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成指定长度的随机字符串。这些字符串包含大写常规字符。
- en: 'The third part of `sqliteGo.go` contains the following code:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqliteGo.go` 的第三部分包含以下代码：'
- en: '[PRE79]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This is where the implementation of `main()` begins. The first statement is
    where we define the name of the SQLite3 database. Although we are using an external
    package, the database is going to be created in the directory that we execute
    `sqliteGo.go` in.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `main()` 实现的开始。第一条语句是我们定义 SQLite3 数据库名的地方。尽管我们使用外部包，但数据库将会在我们执行 `sqliteGo.go`
    的目录中创建。
- en: After that, we call `sqlite06.ListUsers()` to get the list of available users.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用 `sqlite06.ListUsers()` 来获取可用用户列表。
- en: 'The fourth part of `sqliteGo.go` is the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqliteGo.go` 的第四部分如下：'
- en: '[PRE80]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The previous code generates a random username, creates and populates a `Userdata`
    structure, and calls `sqlite06.AddUser()` to add a new user.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成一个随机用户名，创建并填充一个 `Userdata` 结构，然后调用 `sqlite06.AddUser()` 来添加新用户。
- en: 'The fifth part of `sqliteGo.go` contains the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqliteGo.go` 的第五部分包含以下代码：'
- en: '[PRE81]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the previous code, we try to delete the same user twice by calling `sqlite06.DeleteUser()`
    two times. In this case, we expect the second attempt to fail.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们尝试通过两次调用 `sqlite06.DeleteUser()` 来删除同一个用户两次。在这种情况下，我们预计第二次尝试会失败。
- en: 'The last part of `sqliteGo.go` is the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqliteGo.go` 的最后一部分如下：'
- en: '[PRE82]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this last part, we add another user with random data and then we update its
    description by calling `sqlite06.UpdateUser()`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分，我们使用随机数据添加另一个用户，然后通过调用 `sqlite06.UpdateUser()` 更新其描述。
- en: 'You should create the two tables in the SQLIte3 database before using `sqliteGo.go`.
    Additionally, the name of the SQLite3 database file should be `ch06.db`, unless
    you change it in `sqliteGo.go`. The easiest way to be ready is by running the
    following commands using the `sqlite3` utility:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `sqliteGo.go` 之前，你应该在 SQLite3 数据库中创建两个表。此外，SQLite3 数据库文件的名称应该是 `ch06.db`，除非你在
    `sqliteGo.go` 中更改它。准备的最简单方法是使用 `sqlite3` 工具运行以下命令：
- en: '[PRE83]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The first command creates the `ch06.db` database whereas the second command
    executes the code found in `createTables.sql`, which is included in the `usePackage`
    directory. The content of the `createTables.sql` file is the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令创建了 `ch06.db` 数据库，而第二个命令执行了 `createTables.sql` 文件中的代码，该文件包含在 `usePackage`
    目录中。`createTables.sql` 文件的内容如下：
- en: '[PRE84]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'After you execute the `createTables.sql` file, you can verify its results as
    follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `createTables.sql` 文件后，你可以按照以下方式验证其结果：
- en: '[PRE85]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `.tables` command just lists the available table names, whereas the `.schema`
    command also displays information about the available tables.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`.tables` 命令仅列出可用的表名，而 `.schema` 命令还会显示有关可用表的信息。'
- en: 'Now that we have the necessary infrastructure up and running, we can execute
    `sqliteGo.go`. But before that, we need to enable modules and download any package
    dependencies:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经搭建了必要的基础设施并使其运行，我们可以执行 `sqliteGo.go`。但在那之前，我们需要启用模块并下载任何包依赖项：
- en: '[PRE86]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Working with `sqliteGo.go` creates the following kind of output:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sqliteGo.go` 工作会生成以下类型的输出：
- en: '[PRE87]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The more times you execute it, the more data you are going to add to the relevant
    tables. Additionally, the previous output confirms that `sqliteGo.go` works as
    expected as it can connect to the database, add a new user, update a user, and
    delete an existing one. This also means that the `sqlite06` package works as expected.
    Now that we know how to create Go packages, let us briefly discuss Go modules.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你执行它的次数越多，你将向相关表添加更多的数据。此外，之前的输出确认 `sqliteGo.go` 正如预期那样工作，因为它可以连接到数据库，添加新用户，更新用户，并删除现有用户。这也意味着
    `sqlite06` 包按预期工作。现在我们知道了如何创建 Go 包，让我们简要讨论一下 Go 模块。
- en: Modules
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: A Go module is like a Go package with a version—however, Go modules can consist
    of multiple packages. Go uses semantic versioning for versioning modules. This
    means that versions begin with the letter `v`, followed by the `major.minor.patch`
    version numbers. Therefore, you can have versions such as `v1.0.0`, `v1.0.5`,
    and `v2.0.2`. The `v1`, `v2`, and `v3` parts signify the major version of a Go
    package that is usually not backward compatible. This means that if your Go program
    works with `v1`, it will not necessarily work with `v2` or `v3`—it might work,
    but you cannot count on it. The second number in a version is about features.
    Usually, `v1.1.0` has more features than `v1.0.2` or `v1.0.0`, while being compatible
    with all older versions. Lastly, the third number is just about bug fixes without
    having any new features. Note that semantic versioning is also used for Go versions.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块类似于带有版本的Go包——然而，Go模块可以由多个包组成。Go使用语义版本对模块进行版本控制。这意味着版本以字母`v`开头，后面跟着`major.minor.patch`版本号。因此，你可以有`v1.0.0`、`v1.0.5`和`v2.0.2`这样的版本。`v1`、`v2`和`v3`部分表示Go包的主版本，通常不向后兼容。这意味着如果你的Go程序与`v1`兼容，它不一定与`v2`或`v3`兼容——它可能兼容，但你不能指望它。版本中的第二个数字是关于特性的。通常，`v1.1.0`比`v1.0.2`或`v1.0.0`有更多的特性，同时与所有旧版本兼容。最后，第三个数字只是关于错误修复，没有添加任何新特性。请注意，语义版本控制也用于Go版本。
- en: Go modules were introduced in Go v1.11 but were finalized in Go v1.13.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块在Go v1.11中引入，但在Go v1.13中最终确定。
- en: If you want to learn more about modules, visit and read [https://go.dev/blog/using-go-modules](https://go.dev/blog/using-go-modules),
    which has five parts, as well as [https://go.dev/doc/modules/developing](https://go.dev/doc/modules/developing).
    Just remember that a Go module is similar but not identical to a regular Go package
    with a version, and that a module can consist of multiple packages.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于模块的信息，请访问并阅读[https://go.dev/blog/using-go-modules](https://go.dev/blog/using-go-modules)，它分为五个部分，以及[https://go.dev/doc/modules/developing](https://go.dev/doc/modules/developing)。只需记住，Go模块与带有版本的常规Go包相似但并不相同，并且一个模块可以由多个包组成。
- en: Creating better packages
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更好的包
- en: 'This section provides handy advice that can help you develop better Go packages.
    Here are several good rules to follow to create high-class Go packages:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一些实用的建议，可以帮助你开发更好的Go包。以下是一些遵循以创建高质量Go包的好规则：
- en: The first unofficial rule of a successful package is that its **elements must
    be connected in some way**. Thus, you can create a package for supporting cars,
    but it would not be a good idea to create a single package for supporting cars,
    bicycles, and airplanes. Put simply, it is better to split the functionality of
    a package unnecessarily into multiple packages than to add too much functionality
    to a single Go package.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功包的第一条非正式规则是，其**元素必须以某种方式连接在一起**。因此，你可以创建一个支持汽车的包，但为汽车、自行车和飞机创建一个单独的包并不是一个好主意。简单来说，将包的功能不必要地拆分成多个包比在单个Go包中添加过多的功能要好。
- en: A second practical rule is that you should use your own packages first for a
    reasonable amount of time before making them public. This helps you discover bugs
    and make sure that your packages operate as expected. After that, give them to
    some fellow developers for additional testing before making them publicly available.
    Additionally, you should always write tests for any package you intend to be used
    by others.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个实用的规则是，在将包公开之前，你应该先用一段时间使用自己的包。这有助于你发现错误并确保你的包按预期运行。之后，在将它们公开之前，给一些同行开发者进行额外的测试。此外，你应该始终为任何打算供他人使用的包编写测试。
- en: Next, make sure your package has a clear and useful API so that any consumer
    can be productive with it quickly.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，确保你的包有一个清晰且有用的API，以便任何消费者都可以快速地使用它。
- en: Try and limit the public API of your packages to only what is necessary. Additionally,
    give your functions descriptive but not very long names.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量限制你包的公共API只包含必要的部分。此外，给你的函数起描述性但不要太长的名字。
- en: Interfaces and generics can improve the usefulness of your functions, so when
    you think it is appropriate, use an interface or a generic data type instead of
    a single type as a function parameter or return type.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口和泛型可以提高函数的有用性，所以当你认为合适的时候，使用接口或泛型数据类型而不是单一类型作为函数的参数或返回类型。
- en: When updating one of your packages, try not to break things and create incompatibilities
    with older versions unless it is absolutely necessary.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当更新你的一个包时，尽量不要破坏东西并创建与旧版本不兼容的情况，除非这是绝对必要的。
- en: When developing a new Go package, try to use multiple files in order to group
    similar tasks or concepts.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发新的 Go 包时，尽量使用多个文件来分组相似的任务或概念。
- en: Do not create a package that already exists from scratch. Make changes to the
    existing package and maybe create your own version of it.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要从头开始创建一个已经存在的包。修改现有包，也许可以创建你自己的版本。
- en: Nobody wants a Go package that prints logging information on the screen. It
    would be more professional to have a flag for turning on logging when needed.
    The Go code of your packages should be in harmony with the Go code of your programs.
    This means that if you look at a program that uses your packages and your function
    names stand out in the code in a bad way, it would be better to change the names
    of your functions. As the name of a package is used almost everywhere, try to
    use concise and expressive package names.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有人想要一个在屏幕上打印日志信息的 Go 包。如果需要，有一个用于开启日志的标志会更专业。你的包中的 Go 代码应该与你的程序中的 Go 代码保持一致。这意味着如果你查看使用你的包的程序，并且你的函数名在代码中以不好的方式突出，那么更改你函数的名称会更好。由于包名几乎在所有地方都会被使用，尽量使用简洁且具有表达力的包名。
- en: It is more convenient if you put new Go type definitions near where they are
    used the first time because nobody, including yourself, wants to search huge source
    files for definitions of new data types.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将新的 Go 类型定义放在它们首次使用的地方附近会更方便，因为没有人，包括你自己，愿意在庞大的源文件中搜索新数据类型的定义。
- en: Try to create test files for your packages, because packages with test files
    are considered more professional than ones without them; small details make all
    the difference and give people confidence that you are a serious developer! Notice
    that writing tests for your packages is not optional and that you should avoid
    using packages that do not include tests. You will learn more about testing in
    *Chapter 12*, *Code Testing and Profiling*.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量为你的包创建测试文件，因为包含测试文件的包被认为比没有测试文件的包更专业；细节决定一切，并给人留下你是一个认真开发者的信心！请注意，为你的包编写测试不是可选的，你应该避免使用不包含测试的包。你将在第
    12 章，*代码测试和性能分析*中了解更多关于测试的内容。
- en: Always remember that apart from the fact that the actual Go code in a package
    should be bug-free, the next most important element of a successful package is
    its documentation, as well as some code examples that clarify its use and showcase
    the idiosyncrasies of the functions of the package. The next section discusses
    creating documentation in Go.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 总要记住，除了包中的实际 Go 代码应该是无错误的之外，一个成功包的下一个最重要的元素是其文档，以及一些澄清其使用并展示包函数特性的代码示例。下一节将讨论在
    Go 中创建文档。
- en: Generating documentation
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成文档
- en: This section discusses how to create documentation for your Go code using the
    code of the `sqlite06` package as an example. The new package is renamed and is
    now called `document`—you can find it in `ch06/document` in the GitHub repository
    of the book.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了如何使用 `sqlite06` 包的代码作为示例来创建 Go 代码的文档。新包已被重命名，现在称为 `document`——你可以在本书的 GitHub
    仓库的 `ch06/document` 中找到它。
- en: 'Go follows a simple rule regarding documentation: in order to document a function,
    a method, a variable, or even the package itself, you can write comments, as usual,
    that should be located directly before the element you want to document, without
    any empty lines in between. You can use one or more single-line comments, which
    are lines beginning with `//`, or block comments, which begin with `/*` and end
    with `*/`—everything in between is considered a comment.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Go 在文档方面遵循一个简单的规则：为了文档化一个函数、方法、变量，甚至整个包，你可以像往常一样写注释，这些注释应该直接位于你想要文档化的元素之前，之间没有空行。你可以使用一个或多个单行注释，这些注释以
    `//` 开头，或者块注释，这些注释以 `/*` 开头并以 `*/` 结尾——两者之间的所有内容都被视为注释。
- en: It is highly recommended that each Go package you create has a block comment
    preceding the package declaration that introduces developers to the package, and
    also explains what the package does.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你创建的每个 Go 包在包声明之前都有一个块注释，该注释向开发者介绍包，并解释包的功能。
- en: 'Instead of presenting the entire code of the `sqlite06` package, which has
    been renamed `document`, we will only present the important parts, which means
    that function implementations are going to be empty here (the actual file contains
    the full version). The new version of `sqlite06.go` is called `document.go` and
    comes with the following code and comments:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会展示`sqlite06`包的整个代码，该包已被重命名为`document`，我们只会展示重要的部分，这意味着这里的函数实现将是空的（实际的文件包含完整版本）。`sqlite06.go`的新版本称为`document.go`，并包含以下代码和注释：
- en: '[PRE88]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is the first block of documentation that is located right before the name
    of the package. This is the appropriate place to document the functionality of
    the package, as well as other essential information. In this case, we are presenting
    the SQL `CREATE TABLE` commands that fully describe the database tables we are
    going to work on. Another important element is specifying the database server
    this package interacts with. Other information that you can put at the beginning
    of a package is the author, the license, and the version of the package.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这是位于包名称之前的第一块文档。这是记录包功能以及其他重要信息的适当位置。在这种情况下，我们展示了SQL的`CREATE TABLE`命令，这些命令完全描述了我们将要工作的数据库表。另一个重要元素是指定该包交互的数据库服务器。你还可以在包的开始处放置的其他信息包括作者、许可证和包的版本。
- en: If a line in a block comment begins with a tab, then it is rendered differently
    in the graphical output, which is good for differentiating between various kinds
    of information in the documentation.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果块注释中的一行以制表符开头，那么在图形输出中会以不同的方式渲染，这对于在文档中区分各种信息是有好处的。
- en: 'The `BUG` keyword is special when writing documentation. Go knows that bugs
    are part of the code and therefore should be documented as well. You can write
    any message you want after a `BUG` keyword, and you can place them anywhere you
    want—preferably close to the bugs they describe:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写文档时，`BUG`关键字是特殊的。Go知道错误是代码的一部分，因此也应该进行文档化。你可以在`BUG`关键字之后写上任何你想说的话，并且你可以将它们放在任何你想放的地方——最好是靠近它们所描述的错误：
- en: '[PRE89]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Next, we present the implementation details of the package.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示该包的实现细节。
- en: '[PRE90]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This is the `import` block of the package—nothing special here.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包的`import`块——这里没有什么特别之处。
- en: 'The following code shows a way of documenting a global variable—this also works
    for multiple variables:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何对全局变量进行文档化——这也适用于多个变量：
- en: '[PRE91]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The good thing with this way is that you do not have to put a comment before
    each global variable and make the code less readable. The only downside of this
    method is that you should remember to update the comments, should you wish to
    make any changes to the code. However, documenting multiple variables at once
    might not end up rendering correctly in web-based `godoc` pages. For that reason,
    you might want to document each field independently.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，你不必在每个全局变量前都放置注释，这样可以使得代码更易于阅读。然而，这种方法的一个缺点是，如果你想要对代码进行任何修改，你应该记得更新注释。然而，一次性对多个变量进行文档化可能不会在基于网页的`godoc`页面上正确显示。因此，你可能想要独立地对每个字段进行文档化。
- en: 'The next excerpt shows how to document a Go structure—this is especially useful
    when you have lots of structures in a source file and you want to have a quick
    look at them:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的摘录展示了如何对Go结构进行文档化——这在源文件中有许多结构时特别有用，你想要快速查看它们：
- en: '[PRE92]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: When documenting a function, it is good to begin the first line of the comments
    with the function name. Apart from that, you can write any information that you
    consider important in the comments.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数文档时，最好在注释的第一行开始就写上函数名。除此之外，你可以在注释中写上你认为重要的任何信息。
- en: '[PRE93]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Next, we explain the return values of the `exists()` function as they have a
    special meaning.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们解释`exists()`函数的返回值，因为它们具有特殊含义。
- en: '[PRE94]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You can use block comments anywhere you want, not only at the beginning of
    a package, as in the following excerpt:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何你想的地方使用块注释，而不仅仅是包的开始处，如下面的摘录所示：
- en: '[PRE95]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: When you request the documentation of the `Userdata` structure, Go automatically
    presents the functions that use `Userdata`, as happens with `ListUsers()`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 当你请求`Userdata`结构的文档时，Go会自动展示使用`Userdata`的函数，就像`ListUsers()`那样发生。
- en: '[PRE96]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Similar to what we have seen so far is the documentation of the `UpdateUser()`
    function.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的一样，这是`UpdateUser()`函数的文档。
- en: '[PRE97]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We are not done yet because we need to see the documentation somehow. There
    are two ways to see the documentation of the package. The first one involves using
    `go get`, which also means creating a GitHub repository of the package, as we
    did with `sqlite06`. However, as this is for testing purposes, we are going to
    do things the easy way using the second way: as the package is already located
    under `~/go/src`, we can access it from there—I am doing my development from `~/go/src/github.com/mactsouk/mGo4th/ch06/document`.
    Therefore, the `go doc` command is going to work just fine with the `document`
    package.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成，因为我们需要以某种方式查看文档。查看包文档有两种方法。第一种方法涉及使用 `go get`，这也意味着创建一个与 `sqlite06`
    相同的 GitHub 仓库。然而，由于这是测试目的，我们将使用第二种简单的方法：由于包已经位于 `~/go/src` 下，我们可以从那里访问它——我在 `~/go/src/github.com/mactsouk/mGo4th/ch06/document`
    进行开发。因此，`go doc` 命令将与 `document` 包一起正常工作。
- en: '[PRE98]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Please keep in mind that **only the documentation of public elements is displayed**.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**只显示公共元素的文档**。
- en: 'If you want to see information about a specific function, you should use `go
    doc`, as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看特定函数的信息，你应该使用 `go doc`，如下所示：
- en: '[PRE99]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Workspaces
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作空间
- en: Workspaces is a relatively new Go feature. When you are working in workspace
    mode, you are allowed to work on multiple modules simultaneously. A Go Workspace
    contains both **source files and compiled binaries**. As usual, **you are not
    obliged to use workspaces if you do not want to**.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 工作空间是 Go 的一个相对较新的特性。当你以工作空间模式工作时，你可以同时处理多个模块。Go 工作空间包含 **源文件和编译后的二进制文件**。通常，**如果你不想使用工作空间，你不必强制使用**。
- en: Fortunately, Go is flexible and allows the developer to make their own decisions.
    However, knowing the features of Go is important, even if you do not want to use
    them all the time. Not all Go features are for everyone.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go 很灵活，允许开发者做出自己的决定。然而，了解 Go 的特性很重要，即使你并不总是想使用它们。并非所有的 Go 特性都适合每个人。
- en: When using Go workspaces, you control all dependencies using a file named `go.work`,
    which is located in the root directory of the workspace. Inside `go.work`, there
    exist `use` and `replace` directives that override the information found in the
    `go.mod` files of the directories of the workspace—this saves you from having
    to manually edit `go.mod` files.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Go 工作空间时，你通过一个名为 `go.work` 的文件来控制所有依赖项，该文件位于工作空间的根目录中。在 `go.work` 中存在 `use`
    和 `replace` 指令，它们覆盖了工作空间目录中 `go.mod` 文件中找到的信息——这让你免去了手动编辑 `go.mod` 文件的麻烦。
- en: Let us now look at an example of the use of workspaces. Imagine that we want
    to further develop the `sqlite06` package while having the stable version present
    in our system. One way to do that is with the help of a workspace where we are
    going to keep a local copy of the `sqlite06` package that we are going to modify
    and test. For reasons of simplicity, we are going to work with a single function
    only. More specifically, we are going to make the `openConnection()` function
    public, which means that we are going to rename it to `OpenConnection()`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个使用工作空间的例子。假设我们想在系统中的稳定版本存在的情况下进一步开发 `sqlite06` 包。实现这一目标的一种方法是通过工作空间，我们将保留一个本地副本的
    `sqlite06` 包，我们将对其进行修改和测试。出于简单起见，我们只将与一个函数一起工作。更具体地说，我们将使 `openConnection()` 函数公开，这意味着我们将将其重命名为
    `OpenConnection()`。
- en: 'First, we execute the following commands from the `ch06` directory:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 `ch06` 目录执行以下命令：
- en: '[PRE100]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The previous commands are for creating a local copy of the `sqlite06` module.
    The version you are going to find inside `ws` is pretty minimal.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令是为了创建 `sqlite06` 模块的一个本地副本。你将在 `ws` 中找到的版本相当简单。
- en: '[PRE101]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The previous command is for copying the command line utility we have created
    for testing the `sqlite06` module. As we are going to use a single function from
    `sqlite06`, we are also going to modify `sqliteGo.go` in order to call that function
    only.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令是为了复制我们为测试 `sqlite06` 模块而创建的命令行工具。由于我们只打算使用 `sqlite06` 中的一个函数，因此我们还将修改
    `sqliteGo.go` 以仅调用该函数。
- en: The `go work init .` command creates the workspace.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`go work init .` 命令创建工作空间。'
- en: '[PRE102]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The previous command says that we want to create a workspace for the modules
    in the `./util` directory.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令表示我们想要为 `./util` 目录中的模块创建一个工作空间。
- en: '[PRE103]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The previous command says that we want to use the local copies. There is another
    command missing from `go.work`, which is the following:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令表示我们想要使用本地副本。`go.work` 中缺少另一个命令，如下所示：
- en: '[PRE104]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This last command tells Go that **we want to replace** `github.com/mactsouk/sqlite06`
    with the version of the module found in the `./sqlite06` directory, **which is
    the copy that we are actually changing**. This is the most important command of
    the process.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条命令告诉Go，**我们想要替换** `github.com/mactsouk/sqlite06` 为在`./sqlite06`目录中找到的模块版本，**这是我们实际正在更改的副本**。这是整个过程中最重要的命令。
- en: After that, we are ready to try running the modified version of `./util/sqliteGo.go`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们就准备好尝试运行修改过的`./util/sqliteGo.go`版本。
- en: '[PRE105]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The output verifies that we executed the local and modified version of the `sqlite06`
    module! This means that we can keep developing and changing the `sqlite06` module
    and when we are done, we can replace the original one with the newer version!
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 输出验证了我们已经执行了本地和修改过的`sqlite06`模块版本！这意味着我们可以继续开发和修改`sqlite06`模块，当我们完成时，我们可以用新版本替换原始版本！
- en: If you want to learn about all the options of the `go work` command, type `go
    help work`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解`go work`命令的所有选项，请输入`go help work`。
- en: The last section of this chapter is about versioning utilities and defining
    unique version strings.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分是关于版本化实用程序和定义唯一的版本字符串。
- en: Versioning utilities
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本化实用程序
- en: One of the most difficult tasks is to automatically and uniquely version command
    line utilities, especially when using a CI/CD system. This section presents a
    technique that uses a GitHub value to version a command line utility on your local
    machine. You can apply the same technique to GitLab—just search for the available
    GitLab variables and values and choose one that fits your needs.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 最困难的任务之一是自动且唯一地版本化命令行工具，尤其是在使用CI/CD系统时。本节介绍了一种使用GitHub值在本地机器上对命令行工具进行版本化的技术。您可以将相同的技巧应用于GitLab——只需搜索可用的GitLab变量和值，并选择一个适合您需求的值。
- en: 'This technique is used by both the `docker` and `kubectl` utilities, among
    others:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被`docker`和`kubectl`等实用程序以及其他工具所使用：
- en: '[PRE106]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The previous output shows that `docker` uses the Git commit value for versioning—we
    are going to use a slightly different value that is longer than the one used by
    `docker`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示`docker`使用Git提交值进行版本控制——我们将使用一个比`docker`使用的更长的值。
- en: 'The utility that is used, which is saved as `gitVersion.go`, is implemented
    as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的实用程序，保存为`gitVersion.go`，实现如下：
- en: '[PRE107]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`VERSION` is the variable that is going to be set at runtime using the Go linker.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`VERSION`是将在运行时使用Go链接器设置的变量。'
- en: '[PRE108]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The previous code says that if there is a command line argument and its value
    is `version`, print the version message with the help of the `VERSION` variable.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码表明，如果存在命令行参数且其值为`version`，则使用`VERSION`变量打印版本信息。
- en: What we need to do is tell the Go linker that we are going to define the value
    of the `VERSION` variable. This happens with the help of the `-ldflags` flag,
    which stands for linker flags—this passes values to the `cmd/link` package, which
    allows us to change values in imported packages at build time. The `-X` value
    that is used requires a key/value pair, where the key is a variable name, and
    the value is the value that we want to set for that key. In our case, the key
    has the `main.Variable` form because we change the value of a variable in the
    main package. As the name of the variable in `gitVersion.go` is `VERSION`, the
    key is `main.VERSION`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是告诉Go链接器我们将要定义`VERSION`变量的值。这通过`-ldflags`标志来实现，它代表链接器标志——这会将值传递给`cmd/link`包，允许我们在构建时更改导入包中的值。使用的`-X`值需要一个键/值对，其中键是变量名，值是我们想要为该键设置的值。在我们的情况下，键具有`main.Variable`的形式，因为我们更改了主包中变量的值。由于`gitVersion.go`中变量的名称是`VERSION`，因此键是`main.VERSION`。
- en: But first, we need to decide on the GitHub value that we are going to use as
    the version string. The `git rev-list HEAD` command returns a full list of commits
    for the current repository from the latest to the oldest. We only need the last
    one—the most recent—which we can get using `git rev-list -1 HEAD` or `git rev-list
    HEAD | head -1`. So, we need to assign that value to an environment variable and
    pass that environment variable to the Go compiler. As this value changes each
    time you make a commit and you always want to have the latest value, you should
    reevaluate it each time you execute go build—this will be shown in a while.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要决定将用作版本字符串的 GitHub 值。`git rev-list HEAD` 命令返回当前仓库从最新到最旧的完整提交列表。我们只需要最后一个——最新的，我们可以使用
    `git rev-list -1 HEAD` 或 `git rev-list HEAD | head -1` 来获取它。因此，我们需要将这个值分配给一个环境变量，并将这个环境变量传递给
    Go 编译器。由于这个值每次提交都会改变，并且你总是希望拥有最新的值，你应该在每次执行 go build 时重新评估它——这将在稍后展示。
- en: 'In order to provide `gitVersion.go` with the value of the desired environment
    variable, we should execute it as follows:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向 `gitVersion.go` 提供所需环境变量的值，我们应该按照以下方式执行它：
- en: '[PRE109]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This works on both `bash` and `zsh` shells. If you are using a different shell,
    you should make sure that you are defining an environment variable the right way.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `bash` 和 `zsh` shell 上都有效。如果你使用的是不同的 shell，你应该确保你正在正确地定义环境变量。
- en: 'If you want to execute the two commands at the same time, you can do the following:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要同时执行这两个命令，你可以这样做：
- en: '[PRE110]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Running the generated executable, which is called `gitVersion`, produces the
    following output:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 运行生成的可执行文件，称为 `gitVersion`，会产生以下输出：
- en: '[PRE111]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Your output is going to be different because your GitHub repository is going
    to be different. As GitHub generates random and unique values, you will not have
    the same version number twice!
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将会不同，因为你的 GitHub 仓库将会不同。由于 GitHub 生成随机且唯一的值，你不会两次拥有相同的版本号！
- en: Summary
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter presented two primary topics: functions and packages. Functions
    are first-class citizens in Go, which makes them powerful and handy. Remember
    that everything that begins with an uppercase letter is public. The only exception
    to this rule is package names. Private variables, functions, data type names,
    and structure fields can be strictly used and called internally in a package,
    whereas public ones are available to everyone. Additionally, we learned more about
    the `defer` keyword. Also, remember that Go packages are not like Java classes—a
    Go package can be as big as it needs to be. Regarding Go modules, keep in mind
    that a Go module is multiple packages with a version.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两个主要主题：函数和包。函数是 Go 的一等公民，这使得它们强大且方便。记住，所有以大写字母开头的东西都是公开的。唯一的例外是包名。私有变量、函数、数据类型名称和结构字段可以在包内部严格使用和调用，而公共的则对每个人可用。此外，我们还了解了更多关于
    `defer` 关键字的内容。此外，记住 Go 包不像 Java 类——Go 包可以大如所需。关于 Go 模块，请记住，Go 模块是多个带有版本的包。
- en: Finally, this chapter discussed creating documentation, which is an important
    part of development, workspaces, and versioning command line utilities.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这一章讨论了创建文档，这是开发、工作空间和版本控制命令行工具的重要部分。
- en: The next chapter discusses systems programming as well as file I/O in more detail.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更详细地讨论系统编程以及文件 I/O。
- en: Exercises
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Can you write a function that sorts three int values? Try to write two versions
    of the function: one with named returned values and another without named return
    values. Which one do you think is better?'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能编写一个对三个 int 值进行排序的函数吗？尝试编写两个版本的函数：一个带有命名返回值，另一个没有命名返回值。你认为哪一个更好？
- en: The `sqlite06` package does not support searching by username. Can you implement
    that?
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite06` 包不支持按用户名搜索。你能实现这个功能吗？'
- en: Rewrite the `sqlite06` package so that it works with MySQL databases.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新编写 `sqlite06` 包，使其能够与 MySQL 数据库一起工作。
- en: Additional resources
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'How do you structure your Go apps? Talk by Kat Zien from GopherCon UK 2018:
    [https://www.youtube.com/watch?v=1rxDzs0zgcE](https://www.youtube.com/watch?v=1rxDzs0zgcE)'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是如何构建你的 Go 应用的？来自 GopherCon UK 2018 的 Kat Zien 的演讲：[https://www.youtube.com/watch?v=1rxDzs0zgcE](https://www.youtube.com/watch?v=1rxDzs0zgcE)
- en: 'Get familiar with workspaces: [https://go.dev/blog/get-familiar-with-workspaces](https://go.dev/blog/get-familiar-with-workspaces)'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉工作空间：[https://go.dev/blog/get-familiar-with-workspaces](https://go.dev/blog/get-familiar-with-workspaces)
- en: 'Tutorial: Getting started with multi-module workspaces: [https://go.dev/doc/tutorial/workspaces](https://go.dev/doc/tutorial/workspaces)'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程：开始使用多模块工作空间：[https://go.dev/doc/tutorial/workspaces](https://go.dev/doc/tutorial/workspaces)
- en: 'Experimenting with project templates: [https://go.dev/blog/gonew](https://go.dev/blog/gonew)'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试项目模板：[https://go.dev/blog/gonew](https://go.dev/blog/gonew)
- en: 'SQLite: [https://www.sqlite.org/index.html](https://www.sqlite.org/index.html)'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite：[https://www.sqlite.org/index.html](https://www.sqlite.org/index.html)
- en: 'Go SQLite package: [https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go SQLite 包：[https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)
- en: 'The documentation of `database/sql`: [https://pkg.go.dev/database/sql](https://pkg.go.dev/database/sql)'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database/sql` 的文档：[https://pkg.go.dev/database/sql](https://pkg.go.dev/database/sql)'
- en: 'The documentation of the `cmd/link` package: [https://pkg.go.dev/cmd/link](https://pkg.go.dev/cmd/link)'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd/link` 包的文档：[https://pkg.go.dev/cmd/link](https://pkg.go.dev/cmd/link)'
- en: '[golang.org](https://golang.org) moving to [go.dev](https://go.dev): [https://go.dev/blog/tidy-web](https://go.dev/blog/tidy-web)'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[golang.org](https://golang.org) 正在迁移到 [go.dev](https://go.dev)：[https://go.dev/blog/tidy-web](https://go.dev/blog/tidy-web)'
- en: Join our community on Discord
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6)'
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6)'
