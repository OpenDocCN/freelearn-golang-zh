- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go Packages and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this chapter is on Go packages, which are the Go way of organizing,
    delivering, and using code. Packages are used to organize related functionality
    in your code. As the package author, you design the package, including the public
    API consisting of exported constants, variables, types, and functions. Go also
    supports modules, which contain one or more packages. Modules are versioned following
    SemVer, allowing the module author to release updates and even breaking changes
    using a `major.minor.patch` versioning scheme. This chapter will also explain
    the operation of `defer`, which is typically used for cleaning up and releasing
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the visibility of package elements, Go follows a simple rule which
    states that functions, variables, data types, structure fields, and so forth that
    begin with an uppercase letter are public, whereas functions, variables, types,
    and so forth that begin with a lowercase letter are private. This is the reason
    why `fmt.Println()` is named `Println()` instead of just `println()`. The same
    rule applies not only to the name of a struct variable but to the fields of a
    struct variable—in practice, this means that you can have a struct variable with
    both private and public fields. However, this rule does not affect package names,
    which are allowed to begin with either uppercase or lowercase letters. In fact,
    the names of packages, including `main`, are in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a simple guideline that governs Go: **Do not use any of its features
    prematurely**. This guideline applies to generics, interfaces, and packages. Put
    simply, do not create a package just because you can. Start developing your application
    in the `main` package and write your functions in the `main` package until you
    find out that the same code needs to be used from other Go applications or that
    you are writing too many functions that can be grouped in packages. In that case,
    grouping and putting related functionality in a separate package makes perfect
    sense. Other reasons for developing code in separate packages include the encapsulation,
    testing, and security of exposed functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, this chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: Go packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big O complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing your own packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GitHub to store Go packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating better packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workspaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything in Go is delivered in the form of packages. A Go package is a Go
    source file that begins with the `package` keyword, followed by the name of the
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Note that packages can have structure. For example, the `net` package has several
    subdirectories, named `http`, `mail`, `rpc`, `smtp`, `textproto`, and `url`, which
    should be imported as `net/http`, `net/mail`, `net/rpc`, `net/smtp`, `net/textproto`,
    and `net/url`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the packages of the Go standard library, there are external packages
    that are imported using their full address and that should be downloaded on the
    local machine, before their first use. One such example is [https://github.com/spf13/cobra](https://github.com/spf13/cobra),
    which is stored in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Packages are mainly used for grouping **related** functions, variables, and
    constants so that you can transfer them easily and use them in your own Go programs.
    Note that apart from the `main` package, Go packages are not autonomous programs
    and cannot be compiled into executable files on their own. As a result, if you
    try to execute a Go package as if it were an autonomous program, you are going
    to be disappointed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Instead, packages need to be called directly or indirectly from the `main` package
    in order to be used, as we have shown in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: About go get and go install
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, you will learn how to download external Go packages using
    [https://github.com/spf13/cobra](https://github.com/spf13/cobra) as an example.
    The `go get` command for downloading the `cobra` package is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, as we are going to learn in a while, with all recent Go versions, the
    recommended way to download a package is with `go install`. You can learn more
    about that change at [https://go.dev/doc/go-get-install-deprecation](https://go.dev/doc/go-get-install-deprecation).
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can download the package without using `https://` in its address.
    The results can be found inside the `~/go` directory—the full path is `~/go/src/github.com/spf13/cobra`.
    As the `cobra` package comes with a binary file that helps you structure and create
    command line utilities, you can find that binary file inside `~/go/bin` as `cobra`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output, which was created with the help of the `tree(1)` utility,
    shows a high-level view with 3 levels of detail of the structure of `~/go` on
    my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `x` path, which is displayed near the end of the output, is used by the
    Go team for storing experiment packages that might become part of the standard
    Go library in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, there are three main directories under `~/go`, with the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bin` directory: This is where binary tools are placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `pkg` directory: This is where reusable packages are put. The `darwin_amd64`
    directory, which can be found on macOS machines only, contains compiled versions
    of the installed packages. On a Linux machine, you can find a `linux_amd64` directory
    instead of `darwin_amd64`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `src` directory: This is where the source code of the packages is located.
    The underlying structure is based on the URL of the package you are looking for.
    So, the URL for the `github.com/spf13/vipe`r package is `~/go/src/github.com/spf13/viper`.
    If a package is downloaded as a module, then it will be located under `~/go/pkg/mod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with Go 1.16, `go install` is the recommended way of building and installing
    packages in module mode and you should only use that way. The use of `go get`
    is deprecated, but this chapter uses `go get` because it is commonly used online
    and is worth knowing about. However, most of the chapters in this book use `go
    mod` `init` and `go mod tidy` for downloading external dependencies for your own
    source files, which is the recommended way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to upgrade an existing package, you should execute `go get` with
    the `-u` option. Additionally, if you want to see what is happening behind the
    scenes, add the `-v` option to the `go get` command—in this case, we are using
    the Viper package as an example, but we abbreviate the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What you can basically see in the output is the dependencies of the initial
    package being downloaded before the desired package—most of the time, you do not
    want to know that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will continue this chapter by looking at the most important package element:
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main elements of packages are functions, which are the subject of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Type methods and functions are implemented in the same way and, sometimes, the
    terms functions and type methods are used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'A piece of advice: functions must be as independent of each other as possible
    and must do one job (and only one job) well. So, if you find yourself writing
    functions that do multiple things, you might want to consider replacing them with
    multiple functions instead.'
  prefs: []
  type: TYPE_NORMAL
- en: You should already know that all function definitions begin with the `func`
    keyword, followed by the function’s signature and its implementation, and that
    functions accept none, one, or multiple arguments and return none, one, or multiple
    values back. The single most popular Go function is `main()`, which is used in
    every executable Go program—the `main()` function accepts no parameters and returns
    nothing, but it is the starting point of every Go program. Additionally, when
    the `main()` function ends along with the goroutine that executes it, the entire
    program ends as well.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anonymous functions can be defined inline without the need for a name, and they
    are usually used for implementing things that require a small amount of code.
    In Go, a function can return an anonymous function or take an anonymous function
    as one of its arguments. Additionally, anonymous functions can be attached to
    Go variables. Note that anonymous functions are called *lambdas* in functional
    programming terminology. Similarly, a *closure* is a specific type of anonymous
    function that carries or closes over variables that are in the same lexical scope
    as the anonymous function that was defined.
  prefs: []
  type: TYPE_NORMAL
- en: It is considered a good practice for anonymous functions to have a small implementation
    and a local focus. If an anonymous function does not have a local focus, then
    you might need to consider making it a regular function. When an anonymous function
    is suitable for a job, it is extremely convenient and makes your life easier;
    just do not use too many anonymous functions in your programs without having a
    good reason. We will look at anonymous functions in action in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that return multiple values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you already know from functions such as `strconv.Atoi()`, functions can
    return multiple distinct values, which saves you from having to create a dedicated
    structure for returning and receiving multiple values from a function. However,
    if you have a function that returns more than 3 values, you should reconsider
    that decision and maybe redesign it to use a single structure or slice for grouping
    and returning the desired values as a single entity—this makes handling the returned
    values simpler and easier. Functions, anonymous functions, and functions that
    return multiple values are all illustrated in `functions.go`, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function returns two `int` values, without the need for having separate
    variables to keep them—the returned values are created on the fly. Note the compulsory
    use of parentheses when a function returns more than one value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function returns two `int` values as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous statement reads the two return values of `doubleSquare()` and saves
    them in `d` and `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `anF` variable holds an anonymous function that requires a single parameter
    as input and returns a single value. The only difference between an anonymous
    function and a regular one is that the name of the anonymous function is `func()`
    and that there is no `func` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two statements print the return values of `sortTwo()`. Running `functions.go`
    produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The subsection that follows illustrates functions that have named return values.
  prefs: []
  type: TYPE_NORMAL
- en: The return values of a function can be named
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike C, Go allows you to name the return values of a Go function. Additionally,
    when such a function has a `return` statement without any arguments, the function
    automatically returns the current value of each named return value, in the order
    in which they were declared in the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function is included in `namedReturn.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This `return` statement returns the values stored in the min and max variables—both
    `min` and `max` are defined in the function signature and not in the function
    body.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This `return` statement is equivalent to `return min, max`, which is based on
    the function signature and the use of named return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `namedReturn.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Functions that accept other functions as parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions can accept other functions as parameters. The best example of a function
    that accepts another function as an argument can be found in the `sort` package.
    You can provide the `sort.Slice()` function with another function as an argument
    that specifies the way sorting is implemented. The signature of `sort.Slice()`
    is `func Slice(slice interface{}, less func(i, j int) bool)`. This means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `sort.Slice()` function does not return any data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sort.Slice()` function requires two arguments, a slice of type `interface{}`
    and another function—the slice variable is modified inside `sort.Slice()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function parameter of `sort.Slice()` is named `less` and should have the
    `func(i, j int) bool` signature—there is no need for you to name the anonymous
    function. The name `less` is required because all function parameters should have
    a name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `i` and `j` parameters of `less` are indexes of the slice parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, there is another function in the sort package named `sort.SliceIsSorted()`
    that is defined as `func SliceIsSorted(slice interface{}, less func(i, j int)
    bool) bool`. `sort.SliceIsSorted()` returns a `bool` value and checks whether
    the slice parameter is sorted according to the rules of the second parameter,
    which is a function.
  prefs: []
  type: TYPE_NORMAL
- en: You are not obliged to use an anonymous function in either `sort.Slice()` or
    `sort.SliceIsSorted()`. You can define a regular function with the required signature
    and use that. However, using an anonymous function is more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of both `sort.Slice()` and `sort.SliceIsSorted()` is illustrated in
    the Go program that follows—the name of the source file is `sorting.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if else` block that follows checks the `bool` value of `sort.SliceIsSorted()`
    to determine whether the slice was sorted or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The call to `sort.Slice()` sorts the data according to the anonymous function
    that is passed as the second argument to `sort.Slice()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `sorting.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Functions can return other functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from accepting functions as arguments, functions can also return anonymous
    functions, which can be handy when the returned function is not always the same
    but depends on the function’s input or other external parameters. This is illustrated
    in `returnFunction.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The signature of `funRet()` declares that the function returns another function
    with the `func(int) int` signature. The implementation of the function is unknown,
    but it is going to be defined at runtime. Functions are returned using the `return`
    keyword. The developer should take care and save the returned function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that `n` and `-4` are only used for determining the anonymous functions
    that are going to be returned from `funRet()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first statement prints the signature of the function whereas the second
    statement prints the function signature and its memory address. The last statement
    also returns the memory address of `j`, because `j` is a pointer to the anonymous
    function and the value of `j(-5)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although both `i` and `j` are called with the same input (`10`), they are going
    to return different values because they store different anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `returnFunction.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the output shows the data type of the `i` variable that holds
    the return value of `funRet(n)`, which is `func(int) int` as it holds a function.
    The second line of output shows the data type of `j`, as well as the memory address
    where the anonymous function is stored. The third line shows the memory address
    of the anonymous function stored in the `j` variable, as well as the return value
    of `j(-5)`. The last two lines are the return values of `i(10)` and `j(10)`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this subsection, we learned about functions returning functions. This
    allows Go to benefit from the functional programming paradigm and makes Go functions
    first-class citizens.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to examine variadic functions, which are functions with a variable
    number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variadic functions are functions that can accept a variable number of parameters—you
    already know about `fmt.Println()` and `append()`, which are both variadic functions
    that are widely used. In fact, most functions found in the `fmt` package are variadic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general ideas and rules behind variadic functions are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Variadic functions use the pack operator, which consists of a `...`, followed
    by a data type. So, for a variadic function to accept a variable number of `int`
    values, the pack operator should be `...int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pack operator can only be used once in any given function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable that holds the pack operation is a slice and, therefore, is accessed
    as a slice inside the variadic function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable name that is related to the pack operator is always last in the
    list of function parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When calling a variadic function, you should put a list of values separated
    by `,` in the place of the variable with the pack operator or a slice with the
    unpack operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pack operator can also be used with an empty interface. In fact, most functions
    in the `fmt` package use `...interface{}` to accept a variable number of arguments
    of all data types. You can find the source code of the latest implementation of
    `fmt` at [https://go.dev/src/fmt/](https://go.dev/src/fmt/).
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a situation that needs special care here—I made that mistake
    when I was learning Go and I was wondering about the error message I was getting.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to pass `os.Args`, which is a slice of strings (`[]string`), as `...interface{}`
    to a variadic function, your code will not compile and will generate an error
    message similar to `cannot use os.Args (type []string) as type []interface {}
    in argument to <function_name>`. This happens because the two data types (`[]string`
    and `[]interface{}`) do not have the same representations in memory—this applies
    to all data types. In practice, this means that you cannot write `os.Args...`
    to pass each individual value of the `os.Args` slice to a variadic function.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you just use `os.Args`, it will work, but this passes
    the entire slice as a single entity instead of its individual values! This means
    that the `everything(os.Args, os.Args)` statement works but does not do what you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is converting the slice of strings—or any other
    slice—into a slice of `interface{}`. One way to do that is by using the code that
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, you are allowed to use `empty...` as an argument to the variadic function.
    This is the only subtle point related to variadic functions and the pack operator.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is an exception and should only be used if the user must provide
    the entire `os.Args` slice as a parameter to something like `fmt.Println()`. The
    main reason is that this removes some of the compiler guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: As there is no standard library function to perform that conversion for you,
    you have to write your own code. Note that the conversion takes time as the code
    must visit all slice elements. The more elements the slice has, the more time
    the conversion will take. This topic is also discussed at [https://github.com/golang/go/wiki/InterfaceSlice](https://github.com/golang/go/wiki/InterfaceSlice).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to see variadic functions in action. Type the following Go
    code using your favorite text editor and save it as `variadic.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As variadic functions are built into the grammar of the language, you do not
    need anything extra to support variadic functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is a variadic function that accepts a string and an unknown number of `float64`
    values. It prints the string variable and calculates the sum of the `float64`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This `for` loop accesses the pack operator as a slice, so there is nothing special
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can also access individual elements of the `s` slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is another variadic function that accepts an unknown number of `interface{}`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can put the arguments of a variadic function inline.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But you usually use a slice variable with the unpack operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The previous code works because the content of `s` is not unpacked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can convert `[]string` into `[]interface{}` in order to use the unpack operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: And now, we can unpack the contents of `empty`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a slightly different way of converting `[]string` into `[]interface{}`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The previous statement works because you are passing the entire `str` variable
    three times—not its contents. So, the slice contains three elements—each element
    is equal to the contents of the `str` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `variadic.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the output shows that we have passed the `str` variable three
    times to the `everything()` function as three separate entities.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic functions really come in handy when you want to have an unknown number
    of parameters in a function. The next subsection discusses the use of `defer`,
    which we have already used multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: The defer keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen defer in `ch03/csvData.go`. But what does `defer` do? The
    `defer` keyword postpones the execution of a function until the surrounding function
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, `defer` is used in file I/O operations to keep the function call that
    closes an opened file close to the call that opened it, so that you do not have
    to remember to close a file that you have opened just before the function exits.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to remember that deferred functions are executed in **Last
    In, First Out** (**LIFO**) order after the surrounding function has been returned.
    Putting it simply, this means that if you defer function `f1()` first, function
    `f2()` second, and function `f3()` third in the same surrounding function, then
    when the surrounding function is about to return, function `f3()` will be executed
    first, function `f2()` will be executed second, and function `f1()` will be the
    last one to get executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the dangers of careless use of `defer` using
    a simple program. The code for `defer.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In `d1()`, `defer` is executed inside the function body with just a `fmt.Print()`
    call. Remember that these calls to `fmt.Print()` are executed just before function
    `d1()` returns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In `d2()`, `defer` is attached to an anonymous function that does not accept
    any parameters. In practice, this means that the anonymous function should get
    the value of `i` on its own—this is dangerous because the current value of `i`
    depends on when the anonymous function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The anonymous function is a *closure*, and that is why it has access to variables
    that would normally be out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the current value of `i` is passed to the anonymous function as
    a parameter that initializes the `n` function parameter. This means that there
    are no ambiguities about the value that `i` has.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The task of `main()` is to call `d1()`, `d2()`, and `d3()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `defer.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You will most likely find the generated output complicated and challenging to
    understand, which proves that the operation and the results of the use of `defer`
    can be tricky if your code is not clear and unambiguous. Let me explain the results
    so that you get a better idea of how tricky `defer` can be if you do not pay close
    attention to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start with the first line of the output (`1 2 3`) that is generated by
    the `d1()` function. The values of `i` in `d1()` are `3`, `2`, and `1` in that
    order. The function that is deferred in `s` is the `fmt.Print()` statement; as
    a result, when the `d1()` function is about to return, you get the three values
    of the `i` variable of the `for` loop in reverse order. This is because **deferred
    functions are executed in LIFO order**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let me explain the second line of the output that is produced by the `d2()`
    function. It is really strange that we got three zeros instead of `1 2 3` in the
    output; however, there is a reason for that – note that this is not an issue with
    `defer` but with closures. After the `for` loop ends, the value of `i` is `0`,
    because it is that value of `i` that made the `for` loop terminate. However, the
    tricky point here is that the deferred anonymous function is evaluated after the
    `for` loop ends because it has no parameters, which means that it is evaluated
    three times for an `i` value of `0`, hence the generated output. This kind of
    confusing code is what might lead to the creation of nasty bugs in your projects,
    so try to avoid it. Go version 1.22 corrects this kind of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will talk about the third line of the output, which is generated
    by the `d3()` function. Due to the parameter of the anonymous function, each time
    the anonymous function is deferred, it gets and therefore uses the current value
    of `i`. As a result, each execution of the anonymous function has a different
    value to process without any ambiguities, hence the generated output.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, it should be clear that the best approach to using `defer` is the
    third one, which is exhibited in the `d3()` function, because you intentionally
    pass the desired variable in the anonymous function in an easy-to-read way. Now
    that we have learned about `defer`, it is time to discuss something completely
    different: the Big O notation.'
  prefs: []
  type: TYPE_NORMAL
- en: Big O complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The computational complexity of an algorithm is usually denoted using the popular
    Big O notation. The Big O notation is used for expressing the worst-case scenario
    for the order of growth of an algorithm. It shows how the performance of an algorithm
    changes as the size of the data it processes grows.
  prefs: []
  type: TYPE_NORMAL
- en: '`O(1)` means constant time complexity, which does not depend on the amount
    of data at hand. `O(n)` means that the execution time is proportional to `n` (linear
    time)—you cannot process data without accessing it, so `O(n)` is considered good.
    `O(n`²`)` (quadratic time) means that the execution time is proportional to `n`².
    `O(n!)` (factorial time) means that the execution time of the algorithm is directly
    proportional to the factorial of `n`. Simply put, if you have to process 100 values
    of some kind, then the `O(n)` algorithm will do about 100 operations, `O(n`²`)`
    is going to perform about 10,000 operations, and the algorithm with the `O(n!)`
    complexity `10`^(158) operations!'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the Big O notation, it is time to discuss developing
    your own packages.
  prefs: []
  type: TYPE_NORMAL
- en: Developing your own packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, you are going to need to develop your own packages to organize
    your code and distribute it if needed. As stated at the beginning of this chapter,
    everything that begins with an uppercase letter is considered public and can be
    accessed from outside its package, whereas all other elements are considered private.
    The only exception to this Go rule is package names—it is a best practice to use
    lowercase package names, even though uppercase package names are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a Go package can be done manually, if the package exists on the local
    machine, but it is also done automatically after you download the package from
    the internet, so there is no need to worry about that. Additionally, if the package
    you are downloading contains any errors, you will learn about them when you try
    to download it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you want to compile a package that has been saved in the `sqlite06.go`
    file (a combination of SQLite and Chapter 06) on your own, you can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the previous command compiles the `sqlite06.go` file and saves its output
    in the `sqlite06.a` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The main reason for compiling Go packages on your own is to check for syntax
    or other kinds of errors in your code without actually using them. Additionally,
    you can build Go packages as plugins ([https://pkg.go.dev/plugin](https://pkg.go.dev/plugin))
    or shared libraries. Discussing more about these is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The init() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each Go package can optionally have a private function named `init()` that
    is automatically executed at the beginning of execution time—`init()` runs when
    the package is initialized at the beginning of program execution. The `init()`
    function has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init()` takes no arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init()` returns no values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `init()` function is optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `init()` function is called implicitly by Go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have an `init()` function in the `main` package. In that case, `init()`
    is executed before the `main()` function. In fact, all `init()` functions are
    always executed prior to the `main()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A source file can contain multiple `init()` functions—these are executed in
    the order of declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `init()` function or functions of a package are executed **only once**,
    even if the package is imported multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go packages can contain multiple files. Each source file can contain one or
    more `init()` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that the `init()` function is a private function by design means that
    it cannot be called from outside the package in which it is contained. Additionally,
    as the user of a package has no control over the `init()` function, you should
    think carefully before using an `init()` function in public packages or changing
    any global state in `init()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some exceptions where the use of `init()` makes sense:'
  prefs: []
  type: TYPE_NORMAL
- en: For initializing network connections that might take time prior to the execution
    of package functions or methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For initializing connections to one or more servers prior to the execution of
    package functions or methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For creating required files and directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For checking whether required resources are available or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the order of execution can be perplexing sometimes, in the next subsection,
    we will explain the order of execution in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Order of execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection illustrates how Go code is executed. As an example, if a `main`
    package imports package `A` and package `A` depends on package `B`, then the following
    will take place:'
  prefs: []
  type: TYPE_NORMAL
- en: The process starts with the `main` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `main` package imports package `A`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package `A` imports package `B`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The global variables, if any, in package `B` are initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `init()` function or functions of package `B`, if they exist, run. This
    is the first `init()` function that gets executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The global variables, if any, in package `A` are initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `init()` function or functions of package `A`, if there are any, run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The global variables in the `main` package are initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `init()` function or functions of the `main` package, if they exist, run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `main()` function of the `main` package begins its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that if the `main` package imports package `B` on its own, nothing is
    going to happen because everything related to package `B` is triggered by package
    `A`. This is because package `A` imported package `B` first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what is happening behind the scenes regarding the
    order of execution of Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21003_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Go order of code execution'
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the order of execution by reading the Go Language Specification
    document at [https://go.dev/ref/spec#Order_of_evaluation](https://go.dev/ref/spec#Order_of_evaluation)
    and about the package initialization process by reading [https://go.dev/ref/spec#Package_initialization](https://go.dev/ref/spec#Package_initialization).
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub to store Go packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will teach you how to create a GitHub repository where you can
    keep your Go package and make it available to the world.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create the GitHub repository on your own. The easiest way
    to create a new GitHub repository is by visiting the GitHub website and going
    to the **Repositories** tab, where you can see your existing repositories and
    create new ones. Click the **New** button and type in the necessary information
    for creating a new GitHub repository. If you made your repository public, everyone
    will be able to see it—if it is a private repository, only the people you choose
    are going to be able to look into it.
  prefs: []
  type: TYPE_NORMAL
- en: Having a clear `README.md` file in your GitHub repository that explains the
    way the Go package works is considered a very good practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to clone the repository on your local computer. I usually clone
    it using the `git(1)` utility. If the name of the repository is `sqlite06` and
    the GitHub username is `mactsouk`, the `git clone` command is going to look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: After that, type `cd sqlite06` and you are done! At this point, you just have
    to write the code of the Go package and remember to `git commit` and `git push`
    the changes to the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: The best place to host, inspect, develop, or use a Go package is in the `~/go/src`
    directory. Put simply, the purpose of `~/go/src` is to store the source code of
    the packages you create or use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The look of such a repository can be seen in *Figure 6.2*—you are going to
    learn more about the `sqlite06` repository in a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21003_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: A GitHub repository with a Go package'
  prefs: []
  type: TYPE_NORMAL
- en: Using GitLab instead of GitHub for hosting your code does not require any changes
    to the way you work.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use that package, you just need to `go get` the package using
    its URL and include it in your `import` block—we will see this when we actually
    use it in a program. **The previous process is about developing a Go package,
    not using a Go package**.
  prefs: []
  type: TYPE_NORMAL
- en: The next section presents a Go package that allows you to work with a database.
  prefs: []
  type: TYPE_NORMAL
- en: A package for working with SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will develop a Go package for working with a given database schema
    stored on an SQLite database, with the end goal of demonstrating how to develop,
    store, and use a package. When interacting with specific schemas and tables in
    your application, you usually create separate packages with all the database-related
    functions—this also applies to NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Go offers a generic package ([https://pkg.go.dev/database/sql](https://pkg.go.dev/database/sql))
    for working with databases. However, each database requires a specific package
    that acts as the driver and allows Go to connect and work with that specific database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for creating the desired Go package are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the necessary external Go packages for working with SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating package files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the required functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Go package for developing utilities and testing its functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CI/CD tools for automation (this is optional).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might be wondering why we would create such a package for working with
    a database and not write the actual commands in our programs when needed. The
    reasons for this include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Go package can be shared by all team members who work with the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Go package allows people to use the database in ways that are documented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specialized functions you put in your Go package fit your needs a lot better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People do not need full access to the database—they just use the package functions
    and the functionality they offer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you ever make changes to the database, people do not need to know about them,
    as long as the functions of the Go package remain the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put simply, the functions you create can interact with a specific database schema,
    along with its tables and data—it would be almost impossible to work with an unknown
    database schema without knowing how the tables are connected to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from all these technical reasons, it is really fun to create Go packages
    that are shared among multiple developers!
  prefs: []
  type: TYPE_NORMAL
- en: Let us now continue by learning more about the SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SQLite3 and Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to download an additional package for working with a database, such
    as Postgres, SQLite, MySQL, or MongoDB. In this case, we are using SQLite and
    therefore need to download a Go package that allows us to communicate with SQLite.
    The most popular Go package for working with SQLite3 is called `go-sqlite3` and
    can be found at [https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3).
  prefs: []
  type: TYPE_NORMAL
- en: SQLite databases are single files that are accessed locally and, therefore,
    they do not need any TCP/IP services or other server processes running.
  prefs: []
  type: TYPE_NORMAL
- en: You can download that package by running `go get github.com/mattn/go-sqlite3`.
    However, this command no longer works outside of a module. The new way of installing
    the package is by running `go install github.com/mattn/go-sqlite3@latest`.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that this package uses cgo, which requires the gcc compiler installed
    on your computer. For more details, visit [https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the successful execution of the previous command, **the latest version
    of the package** is going to be downloaded. In my case, the source code of the
    `go-sqlite3` package can be found at `~/go/pkg/mod/github.com/mattn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, the version of the downloaded `go-sqlite3` package is `1.14.22`.
    Alternatively, you can let the `go mod init` and `go mod tidy` commands do the
    job for you.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing any actual work with SQLite3, we are going to present a simple
    utility that just connects to a database and prints the version of SQLite3\. Such
    utilities are really handy while troubleshooting as they perform simple yet critical
    tasks. As `testSQLite.go` uses an external package, it should be placed under
    `~/go/src` during development and follow the `go mod init` and `go mod tidy` process.
    In my case, `testSQLite.go` is placed in the `~/go/src/github.com/mactsouk/mGo4th/ch06/testSQLite`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `testSQLite.go` is presented in two parts. The first part is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As the package communicates with SQLite3, we import the `github.com/mattn/go-sqlite3`
    package and we use `_` in front of the package path. This happens because the
    imported package is **registering itself as the database handler** for the `sql`
    package, but it is not being directly used in the code. It is only being used
    through the `sql` package.
  prefs: []
  type: TYPE_NORMAL
- en: With the previous code, we use `sql.Open()` to connect to an SQLite3 database,
    which is called `test.db`. If the `test.db` file does not exist, it will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part comes with the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the second part, we query the SQLite database using `db.QueryRow()` in order
    to get information about its version number. `QueryRow()` is handy for executing
    queries that are expected to return at most one row, as in our case. The return
    value of the query is read using `Scan()` and saved in the variable that is the
    parameter of `Scan()` using a pointer. The `os.Remove()` statement deletes the
    `test.db` file—in general, this is not a good practice but it works in this particular
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to execute `go mod init` and `go mod tidy` before you execute
    `testSQLite.go` for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `testSQLite.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us develop something more advanced. The `connectSQLite3.go` utility
    verifies that you can create an SQLite3 database along with some tables, get a
    list of the available tables, insert and update data in a table, select data from
    a table, delete data, and get the number of records. As the utility uses an external
    package, it should be placed under `~/go/src` and follow the `go mod init` and
    `go mod tidy` process. In my case, `connectSQLite3.go` is placed in `~/go/src/github.com/mactsouk/mGo4th/ch06/connectSQLite3`
    but you can put it anywhere you want as long as it is under `~/go/src`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `connectSQLite3.go` is going to be presented in six parts, the
    first part being the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `insertData()` function is used for inserting data into the database and
    is called by the `main()` function. We first use `db.Prepare()` to construct the
    `INSERT` SQL statement with the desired parameters and then we execute `Exec()`
    to actually insert the data. It is a common practice to use one or more `?` while
    preparing an SQL statement and replace those question marks with the actual values
    when calling `Exec()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `connectSQLite3.go` comes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this second part, we show how to query SQLite3 data and read multiple rows.
    We use `db.Query()` to construct the `SELECT` SQL query, which returns a `*sql.Rows`
    variable. We then read the rows by calling `Next()` multiple times using a `for`
    loop, which automatically terminates when there is no more data to read. As the
    time is stored as text in SQLite, we need to convert it into a proper variable
    using `time.Parse()`. The `selectData()` function prints the data on its own instead
    of returning it to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: The `db.Query()` statement does not require `Exec()` to get executed. Therefore,
    we replace `?` with the actual values in the same statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this part, we connect to the SQLite3 database and create a table named `book`.
    The table has three fields, named `id`, `time`, and `description`. The `db.Exec()`
    statement is used for executing the `CREATE TABLE` SQL command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of `connectSQLite3.go` contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The previous code inserts ten rows into the `book` table using the `insertData()`
    function and a `for` loop. After that, the `selectData()` function is called for
    selecting data from the `book` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fifth part of `connectSQLite3.go` comes with the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this part, we present the implementation of the `UPDATE` SQL statement, which
    is based on `db.Exec()`—once again, the values of the `UPDATE` SQL statement are
    passed to `db.Exec()`. After that, we call `selectData()` to see the changes we
    have made. Last, we use `db.Prepare()` to construct a `DELETE` statement, which
    is executed using `Exec()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `connectSQLite3.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the last part of the utility, we use `db.Query()` to get the number of rows
    in the `book` table and print the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, before you execute `connectSQLite3.go`, you should execute the
    following commands first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the output tells us that the `github.com/mattn/go-sqlite3`
    package was found in our Go installation and therefore it was not downloaded—this
    is a result of the `go get github.com/mattn/go-sqlite3` command we executed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `connectSQLite3.go` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The main advantage of the `connectSQLite3.go` utility is that it illustrates
    how to perform a large number of tasks on an SQLite database—most of the presented
    code is going to be reused in the Go package that we are going to create in a
    while.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to access and query an SQLite3 database using Go, the next
    task should be to implement the Go package we want to develop.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the Go package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, for reasons of simplicity, we will use a public Go repository
    for the Go module, which is named `sqilite06` and can be found at [https://github.com/mactsouk/sqlite06](https://github.com/mactsouk/sqlite06).
  prefs: []
  type: TYPE_NORMAL
- en: To use that package on your machines, you should `go get` it first, either manually
    or with the help of `go mod init` and `go mod tidy`. However, during development,
    you should begin with `git clone git@github.com:mactsouk/sqlite06.git` to get
    the contents of the GitHub repository and make changes to it until its functionality
    is finalized and there are no bugs. This implies that you have ssh set up with
    GitHub, which is what I usually use. I am doing the development of the `sqilite06`
    package in `~/go/src/github.com/mactsouk/sqlite06`.
  prefs: []
  type: TYPE_NORMAL
- en: The design of the Go package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 6.3* shows the database schema that the Go package works on. Remember
    that when working with a specific database and schema, you need to *include* the
    schema information in your Go code. Put simply, the Go code should know about
    the schema it works on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21003_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The two database tables the Go package works on'
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple schema that allows us to keep user data and update it. Apart
    from the `Users` table, there is also a table named `Userdata` that holds more
    detailed information about a user. What connects the two tables is the user ID,
    which should be unique. Additionally, the `Username` field on the `Users` table
    should also be unique as two or more users cannot share the same username. Once
    a record is entered in the `Users` table, it cannot be changed, it can only be
    deleted. What can change, however, is the data stored in the `Userdata` table.
  prefs: []
  type: TYPE_NORMAL
- en: These two tables should already exist in SQLite, which means that the Go code
    assumes that the relevant tables are in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tasks that the Go package should perform to make our lives easier are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete an existing user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update an existing user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these tasks should have one or more Go functions or methods to support
    it, which is what we are going to implement in the Go package:'
  prefs: []
  type: TYPE_NORMAL
- en: A function to initiate the SQLite3 connection. The helper function to initiate
    the connection is going to be private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that checks whether a given username exists—this is a helper function
    that is also going to be private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that inserts a new user into the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that deletes an existing user from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function for updating an existing user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function for listing all users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know the overall structure and functionality of the Go package,
    we should begin implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the Go package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will implement the Go package for working with the SQLite
    database and the given database schema. We will present each function separately—if
    you combine all these functions, then you have the functionality of the entire
    package.
  prefs: []
  type: TYPE_NORMAL
- en: During package development, you should regularly commit your changes to the
    GitHub or GitLab repository as a backup strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code of the package is found in a Go source file named `sqlite06.go`.
    The preamble of the package is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `Filename` variable holds the name of the database file—this is set by the
    applications that use `sqlite06`. For the first time in this book, you will see
    a package name different than `main`, which in this case is `sqlite06`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next element that you need in your Go package is one or more structures
    that can hold the data from the database tables. Most of the time, you need as
    many structures as there are database tables—we will begin with that and see how
    it goes. Therefore, we will define the following structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you think about this, you should see that there is no point in creating
    two separate Go structures in our case. This is because the `User` structure holds
    no real data, and there is no point in passing multiple structures to the functions
    that process data for the `Users` and `Userdata` SQLite tables. Therefore, we
    can create a single Go structure for holding all the data that has been defined,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: I have decided to name the structure after the database table for simplicity—however,
    in this case, this is not completely accurate as the `Userdata` structure has
    more fields than the `Userdata` database table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now begin presenting the functions of the package. The `openConnection()`
    function, which is private and only accessed within the scope of the package,
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: SQLite3 does not require a username or a password and does not operate over
    a TCP/IP network. Therefore, `sql.Open()` requires just a single parameter, which
    is the filename of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us consider the `exists()` function, which is also private as it is
    a helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This is where we define the query that shows whether the provided username exists
    in the database or not. As all our data is kept in the database, we need to interact
    with the database all the time.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the rare cases where returning an indication value from a function
    makes more sense as it makes the code less complex than returning an `error` value.
    However, returning an `error` value is still more robust and closer to the Go
    philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If the `rows.Scan(&id)` call is executed without any errors, then we know that
    a result has been returned, which is the desired user ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The last part of `exists()` frees resources and returns the ID value of the
    username that was given as a parameter to `exists()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `AddUser()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: All usernames are converted into lowercase using `strings.ToLower()` to avoid
    duplicates. This is a design decision.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This is how we construct an `INSERT` statement that accepts parameters. The
    presented statement requires one value as there is a single `?`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: With `db.Exec()` we pass the value of the parameter, which is kept as `d.Username`,
    into the `insertStatement` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: After inserting a new user into the `Users` table, we make sure that everything
    went fine with the help of the `exists()` function, which also returns the user
    ID of the new user. That user ID is used for inserting the relevant data into
    the `Userdata` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The presented query needs four values that are signified by four `?` characters.
    As we need to pass four variables to `insertStatement`, we will put four values
    in the `db.Exec()` call. This is the end of the function that adds a new user
    to the database.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the `DeleteUser()` function is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, we double-check whether the given user ID exists or not in the `Users`
    table before trying to delete it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If the previously returned username exists and has the same user ID as the
    parameter to `DeleteUser()`, then we can continue the deletion process, which
    contains two steps: First, deleting the relevant user data from the `Userdata`
    table, and, second, deleting the data from the `Users` table.'
  prefs: []
  type: TYPE_NORMAL
- en: During development, I included many `fmt.Println()` statements in the package
    code for debugging purposes. However, I have removed most of them in the final
    version of the Go package and replaced them with `error` values. These `error`
    values are passed to the program that uses the functionality of the package, which
    is responsible for deciding what to do with the error messages and error conditions.
    You can also use logging for this—the output can go to standard output or even
    `/dev/null` when not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us examine the implementation of the `ListUsers()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we need to open a connection to the database before executing any
    database queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the query that reads all data from the two tables. After that, we use
    the `rows` variable to get the results of the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we will store the data we have received from the `SELECT` query
    in a `Userdata` structure. This is added to the slice that is going to be returned
    from the `ListUsers()` function. This process continues until there is nothing
    left to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: After updating the contents of the `Data` slice using `append()`, we end the
    query, and the function returns the list of available users, as stored in the
    `Data` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let us examine the `UpdateUser()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to make sure that the given username exists in the database—the
    update process is based on the username.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The update statement stored in `updateStatement` that is executed using the
    desired parameters with the help of `db.Exec()` updates the user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you finish writing your code, you should execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The previous command tells Go that this is a package with external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `go mod tidy` command downloads all required dependencies, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the details of how to implement each function in the `sqlite06`
    package, it is time to begin using that package!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Go package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to test the package, we must develop a command line utility called
    `sqliteGo.go`. As `sqliteGo.go` uses an external package, even if we have developed
    that package, we should not forget to put it somewhere inside `~/go/src`. If you
    download the GitHub repository of the book, you are going to find it in `ch06/usePackage`.
    As `sqliteGo.go` is used for testing purposes only, we hardcoded most of the data
    apart from the username of the user we put into the database. All usernames are
    randomly generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `sqliteGo.go` is presented in six parts. The first part is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In this first part, we import the necessary Go packages, including our own `sqlite06`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `sqliteGo.go` comes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The previous code generates random strings of a given length. These strings
    contain regular characters in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `sqliteGo.go` contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This is where the implementation of `main()` begins. The first statement is
    where we define the name of the SQLite3 database. Although we are using an external
    package, the database is going to be created in the directory that we execute
    `sqliteGo.go` in.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we call `sqlite06.ListUsers()` to get the list of available users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of `sqliteGo.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The previous code generates a random username, creates and populates a `Userdata`
    structure, and calls `sqlite06.AddUser()` to add a new user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fifth part of `sqliteGo.go` contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we try to delete the same user twice by calling `sqlite06.DeleteUser()`
    two times. In this case, we expect the second attempt to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `sqliteGo.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In this last part, we add another user with random data and then we update its
    description by calling `sqlite06.UpdateUser()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should create the two tables in the SQLIte3 database before using `sqliteGo.go`.
    Additionally, the name of the SQLite3 database file should be `ch06.db`, unless
    you change it in `sqliteGo.go`. The easiest way to be ready is by running the
    following commands using the `sqlite3` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command creates the `ch06.db` database whereas the second command
    executes the code found in `createTables.sql`, which is included in the `usePackage`
    directory. The content of the `createTables.sql` file is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'After you execute the `createTables.sql` file, you can verify its results as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `.tables` command just lists the available table names, whereas the `.schema`
    command also displays information about the available tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the necessary infrastructure up and running, we can execute
    `sqliteGo.go`. But before that, we need to enable modules and download any package
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Working with `sqliteGo.go` creates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The more times you execute it, the more data you are going to add to the relevant
    tables. Additionally, the previous output confirms that `sqliteGo.go` works as
    expected as it can connect to the database, add a new user, update a user, and
    delete an existing one. This also means that the `sqlite06` package works as expected.
    Now that we know how to create Go packages, let us briefly discuss Go modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Go module is like a Go package with a version—however, Go modules can consist
    of multiple packages. Go uses semantic versioning for versioning modules. This
    means that versions begin with the letter `v`, followed by the `major.minor.patch`
    version numbers. Therefore, you can have versions such as `v1.0.0`, `v1.0.5`,
    and `v2.0.2`. The `v1`, `v2`, and `v3` parts signify the major version of a Go
    package that is usually not backward compatible. This means that if your Go program
    works with `v1`, it will not necessarily work with `v2` or `v3`—it might work,
    but you cannot count on it. The second number in a version is about features.
    Usually, `v1.1.0` has more features than `v1.0.2` or `v1.0.0`, while being compatible
    with all older versions. Lastly, the third number is just about bug fixes without
    having any new features. Note that semantic versioning is also used for Go versions.
  prefs: []
  type: TYPE_NORMAL
- en: Go modules were introduced in Go v1.11 but were finalized in Go v1.13.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about modules, visit and read [https://go.dev/blog/using-go-modules](https://go.dev/blog/using-go-modules),
    which has five parts, as well as [https://go.dev/doc/modules/developing](https://go.dev/doc/modules/developing).
    Just remember that a Go module is similar but not identical to a regular Go package
    with a version, and that a module can consist of multiple packages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating better packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section provides handy advice that can help you develop better Go packages.
    Here are several good rules to follow to create high-class Go packages:'
  prefs: []
  type: TYPE_NORMAL
- en: The first unofficial rule of a successful package is that its **elements must
    be connected in some way**. Thus, you can create a package for supporting cars,
    but it would not be a good idea to create a single package for supporting cars,
    bicycles, and airplanes. Put simply, it is better to split the functionality of
    a package unnecessarily into multiple packages than to add too much functionality
    to a single Go package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second practical rule is that you should use your own packages first for a
    reasonable amount of time before making them public. This helps you discover bugs
    and make sure that your packages operate as expected. After that, give them to
    some fellow developers for additional testing before making them publicly available.
    Additionally, you should always write tests for any package you intend to be used
    by others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, make sure your package has a clear and useful API so that any consumer
    can be productive with it quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try and limit the public API of your packages to only what is necessary. Additionally,
    give your functions descriptive but not very long names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces and generics can improve the usefulness of your functions, so when
    you think it is appropriate, use an interface or a generic data type instead of
    a single type as a function parameter or return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When updating one of your packages, try not to break things and create incompatibilities
    with older versions unless it is absolutely necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When developing a new Go package, try to use multiple files in order to group
    similar tasks or concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not create a package that already exists from scratch. Make changes to the
    existing package and maybe create your own version of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nobody wants a Go package that prints logging information on the screen. It
    would be more professional to have a flag for turning on logging when needed.
    The Go code of your packages should be in harmony with the Go code of your programs.
    This means that if you look at a program that uses your packages and your function
    names stand out in the code in a bad way, it would be better to change the names
    of your functions. As the name of a package is used almost everywhere, try to
    use concise and expressive package names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is more convenient if you put new Go type definitions near where they are
    used the first time because nobody, including yourself, wants to search huge source
    files for definitions of new data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to create test files for your packages, because packages with test files
    are considered more professional than ones without them; small details make all
    the difference and give people confidence that you are a serious developer! Notice
    that writing tests for your packages is not optional and that you should avoid
    using packages that do not include tests. You will learn more about testing in
    *Chapter 12*, *Code Testing and Profiling*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always remember that apart from the fact that the actual Go code in a package
    should be bug-free, the next most important element of a successful package is
    its documentation, as well as some code examples that clarify its use and showcase
    the idiosyncrasies of the functions of the package. The next section discusses
    creating documentation in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Generating documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses how to create documentation for your Go code using the
    code of the `sqlite06` package as an example. The new package is renamed and is
    now called `document`—you can find it in `ch06/document` in the GitHub repository
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go follows a simple rule regarding documentation: in order to document a function,
    a method, a variable, or even the package itself, you can write comments, as usual,
    that should be located directly before the element you want to document, without
    any empty lines in between. You can use one or more single-line comments, which
    are lines beginning with `//`, or block comments, which begin with `/*` and end
    with `*/`—everything in between is considered a comment.'
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended that each Go package you create has a block comment
    preceding the package declaration that introduces developers to the package, and
    also explains what the package does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of presenting the entire code of the `sqlite06` package, which has
    been renamed `document`, we will only present the important parts, which means
    that function implementations are going to be empty here (the actual file contains
    the full version). The new version of `sqlite06.go` is called `document.go` and
    comes with the following code and comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This is the first block of documentation that is located right before the name
    of the package. This is the appropriate place to document the functionality of
    the package, as well as other essential information. In this case, we are presenting
    the SQL `CREATE TABLE` commands that fully describe the database tables we are
    going to work on. Another important element is specifying the database server
    this package interacts with. Other information that you can put at the beginning
    of a package is the author, the license, and the version of the package.
  prefs: []
  type: TYPE_NORMAL
- en: If a line in a block comment begins with a tab, then it is rendered differently
    in the graphical output, which is good for differentiating between various kinds
    of information in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BUG` keyword is special when writing documentation. Go knows that bugs
    are part of the code and therefore should be documented as well. You can write
    any message you want after a `BUG` keyword, and you can place them anywhere you
    want—preferably close to the bugs they describe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Next, we present the implementation details of the package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This is the `import` block of the package—nothing special here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows a way of documenting a global variable—this also works
    for multiple variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The good thing with this way is that you do not have to put a comment before
    each global variable and make the code less readable. The only downside of this
    method is that you should remember to update the comments, should you wish to
    make any changes to the code. However, documenting multiple variables at once
    might not end up rendering correctly in web-based `godoc` pages. For that reason,
    you might want to document each field independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next excerpt shows how to document a Go structure—this is especially useful
    when you have lots of structures in a source file and you want to have a quick
    look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: When documenting a function, it is good to begin the first line of the comments
    with the function name. Apart from that, you can write any information that you
    consider important in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Next, we explain the return values of the `exists()` function as they have a
    special meaning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use block comments anywhere you want, not only at the beginning of
    a package, as in the following excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: When you request the documentation of the `Userdata` structure, Go automatically
    presents the functions that use `Userdata`, as happens with `ListUsers()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Similar to what we have seen so far is the documentation of the `UpdateUser()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not done yet because we need to see the documentation somehow. There
    are two ways to see the documentation of the package. The first one involves using
    `go get`, which also means creating a GitHub repository of the package, as we
    did with `sqlite06`. However, as this is for testing purposes, we are going to
    do things the easy way using the second way: as the package is already located
    under `~/go/src`, we can access it from there—I am doing my development from `~/go/src/github.com/mactsouk/mGo4th/ch06/document`.
    Therefore, the `go doc` command is going to work just fine with the `document`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Please keep in mind that **only the documentation of public elements is displayed**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see information about a specific function, you should use `go
    doc`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Workspaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Workspaces is a relatively new Go feature. When you are working in workspace
    mode, you are allowed to work on multiple modules simultaneously. A Go Workspace
    contains both **source files and compiled binaries**. As usual, **you are not
    obliged to use workspaces if you do not want to**.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Go is flexible and allows the developer to make their own decisions.
    However, knowing the features of Go is important, even if you do not want to use
    them all the time. Not all Go features are for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: When using Go workspaces, you control all dependencies using a file named `go.work`,
    which is located in the root directory of the workspace. Inside `go.work`, there
    exist `use` and `replace` directives that override the information found in the
    `go.mod` files of the directories of the workspace—this saves you from having
    to manually edit `go.mod` files.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at an example of the use of workspaces. Imagine that we want
    to further develop the `sqlite06` package while having the stable version present
    in our system. One way to do that is with the help of a workspace where we are
    going to keep a local copy of the `sqlite06` package that we are going to modify
    and test. For reasons of simplicity, we are going to work with a single function
    only. More specifically, we are going to make the `openConnection()` function
    public, which means that we are going to rename it to `OpenConnection()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we execute the following commands from the `ch06` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands are for creating a local copy of the `sqlite06` module.
    The version you are going to find inside `ws` is pretty minimal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The previous command is for copying the command line utility we have created
    for testing the `sqlite06` module. As we are going to use a single function from
    `sqlite06`, we are also going to modify `sqliteGo.go` in order to call that function
    only.
  prefs: []
  type: TYPE_NORMAL
- en: The `go work init .` command creates the workspace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The previous command says that we want to create a workspace for the modules
    in the `./util` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command says that we want to use the local copies. There is another
    command missing from `go.work`, which is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This last command tells Go that **we want to replace** `github.com/mactsouk/sqlite06`
    with the version of the module found in the `./sqlite06` directory, **which is
    the copy that we are actually changing**. This is the most important command of
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we are ready to try running the modified version of `./util/sqliteGo.go`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The output verifies that we executed the local and modified version of the `sqlite06`
    module! This means that we can keep developing and changing the `sqlite06` module
    and when we are done, we can replace the original one with the newer version!
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn about all the options of the `go work` command, type `go
    help work`.
  prefs: []
  type: TYPE_NORMAL
- en: The last section of this chapter is about versioning utilities and defining
    unique version strings.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most difficult tasks is to automatically and uniquely version command
    line utilities, especially when using a CI/CD system. This section presents a
    technique that uses a GitHub value to version a command line utility on your local
    machine. You can apply the same technique to GitLab—just search for the available
    GitLab variables and values and choose one that fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is used by both the `docker` and `kubectl` utilities, among
    others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows that `docker` uses the Git commit value for versioning—we
    are going to use a slightly different value that is longer than the one used by
    `docker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The utility that is used, which is saved as `gitVersion.go`, is implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '`VERSION` is the variable that is going to be set at runtime using the Go linker.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The previous code says that if there is a command line argument and its value
    is `version`, print the version message with the help of the `VERSION` variable.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is tell the Go linker that we are going to define the value
    of the `VERSION` variable. This happens with the help of the `-ldflags` flag,
    which stands for linker flags—this passes values to the `cmd/link` package, which
    allows us to change values in imported packages at build time. The `-X` value
    that is used requires a key/value pair, where the key is a variable name, and
    the value is the value that we want to set for that key. In our case, the key
    has the `main.Variable` form because we change the value of a variable in the
    main package. As the name of the variable in `gitVersion.go` is `VERSION`, the
    key is `main.VERSION`.
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to decide on the GitHub value that we are going to use as
    the version string. The `git rev-list HEAD` command returns a full list of commits
    for the current repository from the latest to the oldest. We only need the last
    one—the most recent—which we can get using `git rev-list -1 HEAD` or `git rev-list
    HEAD | head -1`. So, we need to assign that value to an environment variable and
    pass that environment variable to the Go compiler. As this value changes each
    time you make a commit and you always want to have the latest value, you should
    reevaluate it each time you execute go build—this will be shown in a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to provide `gitVersion.go` with the value of the desired environment
    variable, we should execute it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This works on both `bash` and `zsh` shells. If you are using a different shell,
    you should make sure that you are defining an environment variable the right way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to execute the two commands at the same time, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the generated executable, which is called `gitVersion`, produces the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Your output is going to be different because your GitHub repository is going
    to be different. As GitHub generates random and unique values, you will not have
    the same version number twice!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter presented two primary topics: functions and packages. Functions
    are first-class citizens in Go, which makes them powerful and handy. Remember
    that everything that begins with an uppercase letter is public. The only exception
    to this rule is package names. Private variables, functions, data type names,
    and structure fields can be strictly used and called internally in a package,
    whereas public ones are available to everyone. Additionally, we learned more about
    the `defer` keyword. Also, remember that Go packages are not like Java classes—a
    Go package can be as big as it needs to be. Regarding Go modules, keep in mind
    that a Go module is multiple packages with a version.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this chapter discussed creating documentation, which is an important
    part of development, workspaces, and versioning command line utilities.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter discusses systems programming as well as file I/O in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Can you write a function that sorts three int values? Try to write two versions
    of the function: one with named returned values and another without named return
    values. Which one do you think is better?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sqlite06` package does not support searching by username. Can you implement
    that?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrite the `sqlite06` package so that it works with MySQL databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do you structure your Go apps? Talk by Kat Zien from GopherCon UK 2018:
    [https://www.youtube.com/watch?v=1rxDzs0zgcE](https://www.youtube.com/watch?v=1rxDzs0zgcE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get familiar with workspaces: [https://go.dev/blog/get-familiar-with-workspaces](https://go.dev/blog/get-familiar-with-workspaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tutorial: Getting started with multi-module workspaces: [https://go.dev/doc/tutorial/workspaces](https://go.dev/doc/tutorial/workspaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Experimenting with project templates: [https://go.dev/blog/gonew](https://go.dev/blog/gonew)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLite: [https://www.sqlite.org/index.html](https://www.sqlite.org/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go SQLite package: [https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation of `database/sql`: [https://pkg.go.dev/database/sql](https://pkg.go.dev/database/sql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation of the `cmd/link` package: [https://pkg.go.dev/cmd/link](https://pkg.go.dev/cmd/link)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[golang.org](https://golang.org) moving to [go.dev](https://go.dev): [https://go.dev/blog/tidy-web](https://go.dev/blog/tidy-web)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
