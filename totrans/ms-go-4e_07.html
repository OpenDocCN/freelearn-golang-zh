<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer125">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 class="chapterTitle" id="_idParaDest-178"><span class="koboSpan" id="kobo.2.1">Telling a UNIX System What to Do</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">This chapter is about systems programming in Go. </span><span class="koboSpan" id="kobo.3.2">Systems programming involves working with files and directories, process control, signal handling, network programming, system files, configuration files, and file </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">input and output</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">I/O</span></strong><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">If you recall from </span><em class="chapterRef"><span class="koboSpan" id="kobo.8.1">Chapter 1</span></em><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">A Quick Introduction to Go</span></em><span class="koboSpan" id="kobo.11.1">, the reason for writing system utilities with Linux in mind is that, often, Go software is executed in a Docker environment—Docker images use the Linux operating system, which means that you might need to develop your utilities with the Linux operating system in mind. </span><span class="koboSpan" id="kobo.11.2">However, as Go code is portable, most system utilities work on Windows machines without any changes or with minor modifications. </span><span class="koboSpan" id="kobo.11.3">The key idea to remember is that Go makes systems programming more portable. </span><span class="koboSpan" id="kobo.11.4">Additionally, in this chapter, we are going to improve the statistics application with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.12.1">cobra</span></code><span class="koboSpan" id="kobo.13.1"> package.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.14.1">As already mentioned, starting with Go 1.16, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.15.1">GO111MODULE</span></code><span class="koboSpan" id="kobo.16.1"> environment variable defaults to </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">on</span></code><span class="koboSpan" id="kobo.18.1">—this affects the use of Go packages that do not belong to the Go standard library. </span><span class="koboSpan" id="kobo.18.2">In practice, this means that you must put your code under </span><code class="inlineCode"><span class="koboSpan" id="kobo.19.1">~/go/src</span></code><span class="koboSpan" id="kobo.20.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.21.1">This chapter covers:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.22.1">stdin</span></code><span class="koboSpan" id="kobo.23.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.24.1">stdout</span></code><span class="koboSpan" id="kobo.25.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.26.1">stderr</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">UNIX processes</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.28.1">File I/O</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.29.1">Reading plain text files</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.30.1">Writing to a file</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">Working with JSON</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">viper</span></code><span class="koboSpan" id="kobo.34.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.35.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.36.1">cobra</span></code><span class="koboSpan" id="kobo.37.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.38.1">Important Go features</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.39.1">Updating the statistics application</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-179"><span class="koboSpan" id="kobo.40.1">stdin, stdout, and stderr</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.41.1">Every UNIX operating system has three files open </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.42.1">all the time for its processes. </span><span class="koboSpan" id="kobo.42.2">Remember that UNIX considers</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.43.1"> everything, even a printer or a mouse, as a file. </span><span class="koboSpan" id="kobo.43.2">UNIX uses file descriptors, which are positive integer values, as an internal representation to access </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.44.1">open files, which is much prettier than using long paths. </span><span class="koboSpan" id="kobo.44.2">So, by default, all UNIX systems support three special and standard filenames: </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">/dev/stdin</span></code><span class="koboSpan" id="kobo.46.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">/dev/stdout</span></code><span class="koboSpan" id="kobo.48.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.49.1">/dev/stderr</span></code><span class="koboSpan" id="kobo.50.1">, which can also be accessed using the file descriptors </span><code class="inlineCode"><span class="koboSpan" id="kobo.51.1">0</span></code><span class="koboSpan" id="kobo.52.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.53.1">1</span></code><span class="koboSpan" id="kobo.54.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">2</span></code><span class="koboSpan" id="kobo.56.1">, respectively. </span><span class="koboSpan" id="kobo.56.2">These three file descriptors are also called standard input, standard output, and standard error, respectively. </span><span class="koboSpan" id="kobo.56.3">Additionally, the file descriptor </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">0</span></code><span class="koboSpan" id="kobo.58.1"> can be accessed as </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">/dev/fd/0</span></code><span class="koboSpan" id="kobo.60.1"> on a macOS machine and as both </span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">/dev/fd/0</span></code><span class="koboSpan" id="kobo.62.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">/dev/pts/0</span></code><span class="koboSpan" id="kobo.64.1"> on a Debian Linux machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.65.1">Go uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.66.1">os.Stdin</span></code><span class="koboSpan" id="kobo.67.1"> to access standard input, </span><code class="inlineCode"><span class="koboSpan" id="kobo.68.1">os.Stdout</span></code><span class="koboSpan" id="kobo.69.1"> to access standard output, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">os.Stderr</span></code><span class="koboSpan" id="kobo.71.1"> to access standard error. </span><span class="koboSpan" id="kobo.71.2">Although you can still use </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">/dev/stdin</span></code><span class="koboSpan" id="kobo.73.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">/dev/stdout</span></code><span class="koboSpan" id="kobo.75.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">/dev/stderr</span></code><span class="koboSpan" id="kobo.77.1"> or the related file descriptor values to access the same devices, it is better, safer, and more portable to stick with </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">os.Stdin</span></code><span class="koboSpan" id="kobo.79.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">os.Stdout</span></code><span class="koboSpan" id="kobo.81.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">os.Stderr</span></code><span class="koboSpan" id="kobo.83.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-180"><span class="koboSpan" id="kobo.84.1">UNIX processes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.85.1">As Go servers, utilities, and Docker images </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.86.1">are mainly executed on Linux, it is good to know about Linux processes and threads.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.87.1">Strictly speaking, a process is an execution environment that contains instructions, user data and system data parts, and other types of resources that are obtained during runtime. </span><span class="koboSpan" id="kobo.87.2">On the other hand, a program is a binary file that contains instructions and data that are used to initialize the instruction and user data parts of a process. </span><span class="koboSpan" id="kobo.87.3">Each running UNIX process is uniquely identified by an unsigned integer, which is called the process ID of the process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.88.1">There are three process categories: user processes, daemon processes, and kernel processes. </span><span class="koboSpan" id="kobo.88.2">User processes run in user space and usually have no special access rights. </span><span class="koboSpan" id="kobo.88.3">Daemon processes are programs that can be found in the user space and run in the background without the need for a terminal. </span><span class="koboSpan" id="kobo.88.4">Kernel processes are executed in kernel space only and can fully access all kernel data structures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.89.1">The C way of creating new processes involves the calling of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">fork(2)</span></code><span class="koboSpan" id="kobo.91.1"> system call. </span><span class="koboSpan" id="kobo.91.2">The return value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.92.1">fork(2)</span></code><span class="koboSpan" id="kobo.93.1"> allows the programmer to differentiate between a parent and a child process. </span><span class="koboSpan" id="kobo.93.2">Although you can fork a new process in Go using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.94.1">exec</span></code><span class="koboSpan" id="kobo.95.1"> package, Go does not allow you to control</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.96.1"> threads—Go offers goroutines, which the user can create on top of threads that are created and handled by the Go runtime, which is partially controlled by the operating system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.97.1">Now, we need to learn how to read and write files in Go.</span></p>
<h1 class="heading-1" id="_idParaDest-181"><span class="koboSpan" id="kobo.98.1">File I/O</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.99.1">This section discusses file I/O in Go, which</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.100.1"> includes the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.101.1">io.Reader</span></code><span class="koboSpan" id="kobo.102.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">io.Writer</span></code><span class="koboSpan" id="kobo.104.1"> interfaces, buffered and unbuffered I/O, as well as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">bufio</span></code><span class="koboSpan" id="kobo.106.1"> package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.107.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">io/ioutil</span></code><span class="koboSpan" id="kobo.109.1"> package (</span><a href="https://pkg.go.dev/io/ioutil"><span class="url"><span class="koboSpan" id="kobo.110.1">https://pkg.go.dev/io/ioutil</span></span></a><span class="koboSpan" id="kobo.111.1">) has been </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.112.1">deprecated since Go version 1.16. </span><span class="koboSpan" id="kobo.112.2">Existing Go code that uses the functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.113.1">io/ioutil</span></code><span class="koboSpan" id="kobo.114.1"> will continue to work, but it is better to stop using that package.</span></p>
<h2 class="heading-2" id="_idParaDest-182"><span class="koboSpan" id="kobo.115.1">The io.Reader and io.Writer interfaces</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.116.1">This subsection presents the definitions of the popular </span><code class="inlineCode"><span class="koboSpan" id="kobo.117.1">io.Reader</span></code><span class="koboSpan" id="kobo.118.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.119.1">io.Writer</span></code><span class="koboSpan" id="kobo.120.1"> interfaces because these two</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.121.1"> interfaces are the basis of file I/O in Go—the former allows you to</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.122.1"> read from a file, whereas the latter allows you to write to a file. </span><span class="koboSpan" id="kobo.122.2">The definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">io.Reader</span></code><span class="koboSpan" id="kobo.124.1"> interface is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.125.1">type</span></span><span class="koboSpan" id="kobo.126.1"> Reader </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.127.1">interface</span></span><span class="koboSpan" id="kobo.128.1"> {
    Read(p []</span><span class="hljs-type"><span class="koboSpan" id="kobo.129.1">byte</span></span><span class="koboSpan" id="kobo.130.1">) (n </span><span class="hljs-type"><span class="koboSpan" id="kobo.131.1">int</span></span><span class="koboSpan" id="kobo.132.1">, err </span><span class="hljs-type"><span class="koboSpan" id="kobo.133.1">error</span></span><span class="koboSpan" id="kobo.134.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.135.1">This definition, which should be revisited when we want one of our data types to satisfy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">io.Reader</span></code><span class="koboSpan" id="kobo.137.1"> interface, tells us the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.138.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.139.1">Reader</span></code><span class="koboSpan" id="kobo.140.1"> interface requires the implementation of a single method.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.141.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">Read()</span></code><span class="koboSpan" id="kobo.143.1"> method takes a byte slice as input, which will be filled with data up to its length.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.144.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.145.1">Read()</span></code><span class="koboSpan" id="kobo.146.1"> method returns the</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.147.1"> number of bytes read as well as an </span><code class="inlineCode"><span class="koboSpan" id="kobo.148.1">error</span></code><span class="koboSpan" id="kobo.149.1"> variable.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.150.1">The definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.151.1">io.Writer</span></code><span class="koboSpan" id="kobo.152.1"> interface is</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.153.1"> the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.154.1">type</span></span><span class="koboSpan" id="kobo.155.1"> Writer </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.156.1">interface</span></span><span class="koboSpan" id="kobo.157.1"> {
    Write(p []</span><span class="hljs-type"><span class="koboSpan" id="kobo.158.1">byte</span></span><span class="koboSpan" id="kobo.159.1">) (n </span><span class="hljs-type"><span class="koboSpan" id="kobo.160.1">int</span></span><span class="koboSpan" id="kobo.161.1">, err </span><span class="hljs-type"><span class="koboSpan" id="kobo.162.1">error</span></span><span class="koboSpan" id="kobo.163.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.164.1">The previous definition, which should be revisited when we want one of our data types to satisfy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">io.Writer</span></code><span class="koboSpan" id="kobo.166.1"> interface and write to a file, reveals the following information:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.167.1">The interface requires the implementation of a single method.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.168.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">Write()</span></code><span class="koboSpan" id="kobo.170.1"> method takes a byte slice, which contains the data that you want to write, as input.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.171.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">Write()</span></code><span class="koboSpan" id="kobo.173.1"> method returns the number of bytes written and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.174.1">error</span></code><span class="koboSpan" id="kobo.175.1"> variable.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-183"><span class="koboSpan" id="kobo.176.1">Using and misusing io.Reader and io.Writer</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.177.1">The code that follows</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.178.1"> showcases the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">io.Reader</span></code><span class="koboSpan" id="kobo.180.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">io.Writer</span></code><span class="koboSpan" id="kobo.182.1"> for </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.183.1">custom data types</span></strong><span class="koboSpan" id="kobo.184.1">, which, in </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.185.1">this case, are two Go structures named </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">S1</span></code><span class="koboSpan" id="kobo.187.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">S2</span></code><span class="koboSpan" id="kobo.189.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.190.1">For the </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">S1</span></code><span class="koboSpan" id="kobo.192.1"> structure, the presented code</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.193.1"> implements both interfaces in order to read user data from the terminal and print data to the terminal, respectively. </span><span class="koboSpan" id="kobo.193.2">Although this is redundant, as we already have </span><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">fmt.Scanln()</span></code><span class="koboSpan" id="kobo.195.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.197.1">, it is a good exercise that shows how versatile and flexible both interfaces are. </span><span class="koboSpan" id="kobo.197.2">In a different situation, you could have used </span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">io.Writer</span></code><span class="koboSpan" id="kobo.199.1"> for writing to a log service, keeping a second backup copy of the written data, or anything else that fits your needs. </span><span class="koboSpan" id="kobo.199.2">However, this is also an example of interfaces allowing you to do crazy or, if you prefer, unusual things. </span><span class="koboSpan" id="kobo.199.3">It is up to the developer to create the desired functionality using the appropriate Go concepts and features!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.200.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">Read()</span></code><span class="koboSpan" id="kobo.202.1"> method uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">fmt.Scanln()</span></code><span class="koboSpan" id="kobo.204.1"> to get user input from the terminal, whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.205.1">Write()</span></code><span class="koboSpan" id="kobo.206.1"> method prints the contents of its buffer parameter as many times as the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">F1</span></code><span class="koboSpan" id="kobo.208.1"> field of the structure, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.210.1">!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.211.1">For the </span><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">S2</span></code><span class="koboSpan" id="kobo.213.1"> struct, the presented </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.214.1">code implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">io.Reader</span></code><span class="koboSpan" id="kobo.216.1"> interface only, in the</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.217.1"> traditional way. </span><span class="koboSpan" id="kobo.217.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.218.1">Read()</span></code><span class="koboSpan" id="kobo.219.1"> method reads the text field of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.220.1">S2</span></code><span class="koboSpan" id="kobo.221.1"> structure, which is a byte slice. </span><span class="koboSpan" id="kobo.221.2">When there is nothing left to read, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">Read()</span></code><span class="koboSpan" id="kobo.223.1"> method returns the expected </span><code class="inlineCode"><span class="koboSpan" id="kobo.224.1">io.EOF</span></code><span class="koboSpan" id="kobo.225.1"> error, which in reality is not an error but an expected situation. </span><span class="koboSpan" id="kobo.225.2">Along with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.226.1">Read()</span></code><span class="koboSpan" id="kobo.227.1"> method, there exist two helper methods, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.228.1">eof()</span></code><span class="koboSpan" id="kobo.229.1">, which declares that there is nothing more to read, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.230.1">readByte()</span></code><span class="koboSpan" id="kobo.231.1">, which reads the text field of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.232.1">S2</span></code><span class="koboSpan" id="kobo.233.1"> structure byte by byte. </span><span class="koboSpan" id="kobo.233.2">After the </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">Read()</span></code><span class="koboSpan" id="kobo.235.1"> method is done, the text field of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">S2</span></code><span class="koboSpan" id="kobo.237.1"> structure, which is used as a buffer, is emptied.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.238.1">With this implementation, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.239.1">io.Reader</span></code><span class="koboSpan" id="kobo.240.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">S2</span></code><span class="koboSpan" id="kobo.242.1"> can be used for reading in a traditional way, which, in this case, is with </span><code class="inlineCode"><span class="koboSpan" id="kobo.243.1">bufio.NewReader()</span></code><span class="koboSpan" id="kobo.244.1"> and multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">Read()</span></code><span class="koboSpan" id="kobo.246.1"> calls—the number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">Read()</span></code><span class="koboSpan" id="kobo.248.1"> calls depends on the size of the buffer that is used, which, in this case, is a byte slice with two places for data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.249.1">Type the following code and save it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">ioInterface.go</span></code><span class="koboSpan" id="kobo.251.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.252.1">package</span></span><span class="koboSpan" id="kobo.253.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.254.1">import</span></span><span class="koboSpan" id="kobo.255.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.256.1">"bufio"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.257.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.258.1">"io"</span></span><span class="koboSpan" id="kobo.259.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.260.1">The previous part shows that we are using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">io</span></code><span class="koboSpan" id="kobo.262.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">bufio</span></code><span class="koboSpan" id="kobo.264.1"> packages to work with files.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.265.1">type</span></span><span class="koboSpan" id="kobo.266.1"> S1 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.267.1">struct</span></span><span class="koboSpan" id="kobo.268.1"> {
    F1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.269.1">int</span></span><span class="koboSpan" id="kobo.270.1">
    F2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.271.1">string</span></span><span class="koboSpan" id="kobo.272.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.273.1">type</span></span><span class="koboSpan" id="kobo.274.1"> S2 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.275.1">struct</span></span><span class="koboSpan" id="kobo.276.1"> {
    F1   S1
    text []</span><span class="hljs-type"><span class="koboSpan" id="kobo.277.1">byte</span></span><span class="koboSpan" id="kobo.278.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.279.1">These are the two structures we are going to work with.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.280.1">// Using pointer to S1 for changes to be persistent</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.281.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.282.1">(s *S1)</span></span><span class="koboSpan" id="kobo.283.1"> Read(p []</span><span class="hljs-type"><span class="koboSpan" id="kobo.284.1">byte</span></span><span class="koboSpan" id="kobo.285.1">) (n </span><span class="hljs-type"><span class="koboSpan" id="kobo.286.1">int</span></span><span class="koboSpan" id="kobo.287.1">, err </span><span class="hljs-type"><span class="koboSpan" id="kobo.288.1">error</span></span><span class="koboSpan" id="kobo.289.1">) {
    fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.290.1">"Give me your name: "</span></span><span class="koboSpan" id="kobo.291.1">)
    fmt.Scanln(&amp;p)
    s.F2 = </span><span class="hljs-type"><span class="koboSpan" id="kobo.292.1">string</span></span><span class="koboSpan" id="kobo.293.1">(p)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.294.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.295.1">len</span></span><span class="koboSpan" id="kobo.296.1">(p), </span><span class="hljs-literal"><span class="koboSpan" id="kobo.297.1">nil</span></span><span class="koboSpan" id="kobo.298.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.299.1">In the preceding code, we</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.300.1"> implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">io.Reader</span></code><span class="koboSpan" id="kobo.302.1"> interface for </span><code class="inlineCode"><span class="koboSpan" id="kobo.303.1">S1</span></code><span class="koboSpan" id="kobo.304.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.305.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.306.1">(s *S1)</span></span><span class="koboSpan" id="kobo.307.1"> Write(p []</span><span class="hljs-type"><span class="koboSpan" id="kobo.308.1">byte</span></span><span class="koboSpan" id="kobo.309.1">) (n </span><span class="hljs-type"><span class="koboSpan" id="kobo.310.1">int</span></span><span class="koboSpan" id="kobo.311.1">, err </span><span class="hljs-type"><span class="koboSpan" id="kobo.312.1">error</span></span><span class="koboSpan" id="kobo.313.1">) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.314.1">if</span></span><span class="koboSpan" id="kobo.315.1"> s.F1 &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.316.1">0</span></span><span class="koboSpan" id="kobo.317.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.318.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.319.1">-1</span></span><span class="koboSpan" id="kobo.320.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.321.1">nil</span></span><span class="koboSpan" id="kobo.322.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.323.1">for</span></span><span class="koboSpan" id="kobo.324.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.325.1">0</span></span><span class="koboSpan" id="kobo.326.1">; i &lt; s.F1; i++ {
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.327.1">"%s "</span></span><span class="koboSpan" id="kobo.328.1">, p)
    }
    fmt.Println()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.329.1">return</span></span><span class="koboSpan" id="kobo.330.1"> s.F1, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.331.1">nil</span></span><span class="koboSpan" id="kobo.332.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.333.1">The previous method</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.334.1"> implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.335.1">io.Writer</span></code><span class="koboSpan" id="kobo.336.1"> interface for </span><code class="inlineCode"><span class="koboSpan" id="kobo.337.1">S1</span></code><span class="koboSpan" id="kobo.338.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.339.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.340.1">(s S2)</span></span><span class="koboSpan" id="kobo.341.1"> eof() </span><span class="hljs-type"><span class="koboSpan" id="kobo.342.1">bool</span></span><span class="koboSpan" id="kobo.343.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.344.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.345.1">len</span></span><span class="koboSpan" id="kobo.346.1">(s.text) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.347.1">0</span></span><span class="koboSpan" id="kobo.348.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.349.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.350.1">(s *S2)</span></span><span class="koboSpan" id="kobo.351.1"> readByte() </span><span class="hljs-type"><span class="koboSpan" id="kobo.352.1">byte</span></span><span class="koboSpan" id="kobo.353.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.354.1">// this function assumes that eof() check was done before</span></span><span class="koboSpan" id="kobo.355.1">
    temp := s.text[</span><span class="hljs-number"><span class="koboSpan" id="kobo.356.1">0</span></span><span class="koboSpan" id="kobo.357.1">]
    s.text = s.text[</span><span class="hljs-number"><span class="koboSpan" id="kobo.358.1">1</span></span><span class="koboSpan" id="kobo.359.1">:]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.360.1">return</span></span><span class="koboSpan" id="kobo.361.1"> temp
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.362.1">The previous function is an implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">bytes.Buffer.ReadByte</span></code><span class="koboSpan" id="kobo.364.1"> from the standard library.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.365.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.366.1">(s *S2)</span></span><span class="koboSpan" id="kobo.367.1"> Read(p []</span><span class="hljs-type"><span class="koboSpan" id="kobo.368.1">byte</span></span><span class="koboSpan" id="kobo.369.1">) (n </span><span class="hljs-type"><span class="koboSpan" id="kobo.370.1">int</span></span><span class="koboSpan" id="kobo.371.1">, err </span><span class="hljs-type"><span class="koboSpan" id="kobo.372.1">error</span></span><span class="koboSpan" id="kobo.373.1">) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.374.1">if</span></span><span class="koboSpan" id="kobo.375.1"> s.eof() {
        err = io.EOF
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.376.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.377.1">0</span></span><span class="koboSpan" id="kobo.378.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.379.1">err</span></span><span class="koboSpan" id="kobo.380.1">
    }
    l := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.381.1">len</span></span><span class="koboSpan" id="kobo.382.1">(p)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.383.1">if</span></span><span class="koboSpan" id="kobo.384.1"> l &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.385.1">0</span></span><span class="koboSpan" id="kobo.386.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.387.1">for</span></span><span class="koboSpan" id="kobo.388.1"> n &lt; l {
            p[n] = s.readByte()
            n++
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.389.1">if</span></span><span class="koboSpan" id="kobo.390.1"> s.eof() {
                s.text = s.text[</span><span class="hljs-number"><span class="koboSpan" id="kobo.391.1">0</span></span><span class="koboSpan" id="kobo.392.1">:</span><span class="hljs-number"><span class="koboSpan" id="kobo.393.1">0</span></span><span class="koboSpan" id="kobo.394.1">]
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.395.1">break</span></span><span class="koboSpan" id="kobo.396.1">
            }
        }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.397.1">return</span></span><span class="koboSpan" id="kobo.398.1"> n, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.399.1">nil</span></span><span class="koboSpan" id="kobo.400.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.401.1">The previous code reads from the given </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.402.1">buffer until it is empty. </span><span class="koboSpan" id="kobo.402.2">When all data is read, the relevant structure field is</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.403.1"> emptied. </span><span class="koboSpan" id="kobo.403.2">The previous method implements </span><code class="inlineCode"><span class="koboSpan" id="kobo.404.1">io.Reader</span></code><span class="koboSpan" id="kobo.405.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.406.1">S2</span></code><span class="koboSpan" id="kobo.407.1">. </span><span class="koboSpan" id="kobo.407.2">However, the operation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">Read()</span></code><span class="koboSpan" id="kobo.409.1"> is supported by </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">eof()</span></code><span class="koboSpan" id="kobo.411.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">readByte()</span></code><span class="koboSpan" id="kobo.413.1">, which are also user-defined.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.414.1">Recall that Go allows you to name the return values of a function; in that case, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">return</span></code><span class="koboSpan" id="kobo.416.1"> statement without any additional arguments automatically returns the current value of each named return variable in the order they appear in the function signature. </span><span class="koboSpan" id="kobo.416.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">Read()</span></code><span class="koboSpan" id="kobo.418.1"> method could have used that feature, but in general, naked returns are considered bad practice.</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.419.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.420.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.421.1">()</span></span><span class="koboSpan" id="kobo.422.1"> {
    s1var := S1{</span><span class="hljs-number"><span class="koboSpan" id="kobo.423.1">4</span></span><span class="koboSpan" id="kobo.424.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.425.1">"Hello"</span></span><span class="koboSpan" id="kobo.426.1">}
    fmt.Println(s1var)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.427.1">We initialize an </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">S1</span></code><span class="koboSpan" id="kobo.429.1"> variable that is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">s1var</span></code><span class="koboSpan" id="kobo.431.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.432.1">    buf := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.433.1">make</span></span><span class="koboSpan" id="kobo.434.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.435.1">byte</span></span><span class="koboSpan" id="kobo.436.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.437.1">2</span></span><span class="koboSpan" id="kobo.438.1">)
    _, err := s1var.Read(buf)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.439.1">The previous line reads for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">s1var</span></code><span class="koboSpan" id="kobo.441.1"> variable using a buffer of two bytes. </span><span class="koboSpan" id="kobo.441.2">The block does not do what is expected because the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">Read()</span></code><span class="koboSpan" id="kobo.443.1"> method gets the value from the terminal—we are misusing Go interfaces here!</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.444.1">if</span></span><span class="koboSpan" id="kobo.445.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.446.1">nil</span></span><span class="koboSpan" id="kobo.447.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.448.1">return</span></span><span class="koboSpan" id="kobo.449.1">
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.450.1">"Read:"</span></span><span class="koboSpan" id="kobo.451.1">, s1var.F2)
    _, _ = s1var.Write([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.452.1">byte</span></span><span class="koboSpan" id="kobo.453.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.454.1">"Hello There!"</span></span><span class="koboSpan" id="kobo.455.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.456.1">In the previous line, we </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.457.1">call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">Write()</span></code><span class="koboSpan" id="kobo.459.1"> method for </span><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">s1var</span></code><span class="koboSpan" id="kobo.461.1"> in order to write the contents of a byte slice.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.462.1">    s2var := S2{F1: s1var, text: []</span><span class="hljs-type"><span class="koboSpan" id="kobo.463.1">byte</span></span><span class="koboSpan" id="kobo.464.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.465.1">"Hello world!!"</span></span><span class="koboSpan" id="kobo.466.1">)}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.467.1">In the previous code, we initialize an </span><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">S2</span></code><span class="koboSpan" id="kobo.469.1"> variable</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.470.1"> that is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">s2var</span></code><span class="koboSpan" id="kobo.472.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.473.1">// Read s2var.text</span></span><span class="koboSpan" id="kobo.474.1">
    r := bufio.NewReader(&amp;s2var)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.475.1">We now create a reader for </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">s2var</span></code><span class="koboSpan" id="kobo.477.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.478.1">for</span></span><span class="koboSpan" id="kobo.479.1"> {
        n, err := r.Read(buf)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.480.1">if</span></span><span class="koboSpan" id="kobo.481.1"> err == io.EOF {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">break</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.483.1">We keep reading from </span><code class="inlineCode"><span class="koboSpan" id="kobo.484.1">s2var</span></code><span class="koboSpan" id="kobo.485.1"> until there is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.486.1">io.EOF</span></code><span class="koboSpan" id="kobo.487.1"> condition.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.488.1">        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.489.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.490.1">if</span></span><span class="koboSpan" id="kobo.491.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.492.1">nil</span></span><span class="koboSpan" id="kobo.493.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.494.1">"*"</span></span><span class="koboSpan" id="kobo.495.1">, err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.496.1">break</span></span><span class="koboSpan" id="kobo.497.1">
        }
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.498.1">"**"</span></span><span class="koboSpan" id="kobo.499.1">, n, </span><span class="hljs-type"><span class="koboSpan" id="kobo.500.1">string</span></span><span class="koboSpan" id="kobo.501.1">(buf[:n]))
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.502.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.503.1">ioInterface.go</span></code><span class="koboSpan" id="kobo.504.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.505.1">$ </span></span><span class="koboSpan" id="kobo.506.1">go run ioInterface.go
{4 Hello}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.507.1">The first line of the output shows the contents of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">s1var</span></code><span class="koboSpan" id="kobo.509.1"> variable.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.510.1">Give me your name: Mike
Calling the Read() method of the s1var variable.
</span><span class="koboSpan" id="kobo.510.2">Read: Mike
Hello There! </span><span class="koboSpan" id="kobo.510.3">Hello There! </span><span class="koboSpan" id="kobo.510.4">Hello There! </span><span class="koboSpan" id="kobo.510.5">Hello There!
</span><span class="koboSpan" id="kobo.510.6">The previous line is the output of s1var.Write([]byte("Hello There!")).
</span><span class="koboSpan" id="kobo.510.7">** 2 He
** 2 ll
** 2 o 
** 2 wo
** 2 rl
** 2 d!
</span><span class="koboSpan" id="kobo.510.8">** 1 !
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.511.1">The last part of the output illustrates</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.512.1"> the reading process, using a buffer with a size of two. </span><span class="koboSpan" id="kobo.512.2">The next section discusses</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.513.1"> buffered and unbuffered operations.</span></p>
<h2 class="heading-2" id="_idParaDest-184"><span class="koboSpan" id="kobo.514.1">Buffered and unbuffered file I/O</span></h2>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.515.1">Buffered file I/O</span></em><span class="koboSpan" id="kobo.516.1"> happens when there is a </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.517.1">buffer to temporarily store data before reading </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.518.1">data or writing data. </span><span class="koboSpan" id="kobo.518.2">Thus, instead of reading a file byte by byte, you read many bytes at once. </span><span class="koboSpan" id="kobo.518.3">You put the data in a buffer and wait for</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.519.1"> someone to read it in the desired way.</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.520.1">Unbuffered file I/O</span></em><span class="koboSpan" id="kobo.521.1"> happens when there is </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.522.1">no buffer to temporarily store data before reading or writing it—this can affect the performance of your programs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.523.1">The next question that you might ask is how to decide when to use buffered and when to use unbuffered file I/O. </span><span class="koboSpan" id="kobo.523.2">When dealing with critical data, unbuffered file I/O is generally a better choice because buffered reads might result in out-of-date data, and buffered writes might result in data loss when the power of your computer is interrupted. </span><span class="koboSpan" id="kobo.523.3">However, most of the time, there is no definitive answer to that question. </span><span class="koboSpan" id="kobo.523.4">This means that you can use whatever makes your tasks easier to implement. </span><span class="koboSpan" id="kobo.523.5">However, keep in mind that buffered readers can also improve performance by reducing the number of system calls needed to read from a file or socket, so there can be a real performance impact on what the programmer decides to use.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.524.1">There is also the </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">bufio</span></code><span class="koboSpan" id="kobo.526.1"> package. </span><span class="koboSpan" id="kobo.526.2">As the name suggests, </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">bufio</span></code><span class="koboSpan" id="kobo.528.1"> is about buffered I/O. </span><span class="koboSpan" id="kobo.528.2">Internally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">bufio</span></code><span class="koboSpan" id="kobo.530.1"> package implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">io.Reader</span></code><span class="koboSpan" id="kobo.532.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">io.Writer</span></code><span class="koboSpan" id="kobo.534.1"> interfaces, which it wraps in order to create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">bufio.Reader</span></code><span class="koboSpan" id="kobo.536.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">bufio.Writer</span></code><span class="koboSpan" id="kobo.538.1"> types, respectively. </span><span class="koboSpan" id="kobo.538.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">bufio</span></code><span class="koboSpan" id="kobo.540.1"> package is very popular for working with plain text files, and you are going to see it in action in the next section.</span></p>
<h1 class="heading-1" id="_idParaDest-185"><span class="koboSpan" id="kobo.541.1">Reading text files</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.542.1">In this section, you will learn how to read plain text files, as well as use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.543.1">/dev/random</span></code><span class="koboSpan" id="kobo.544.1"> UNIX device, which offers you a</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.545.1"> way of getting random numbers.</span></p>
<h2 class="heading-2" id="_idParaDest-186"><span class="koboSpan" id="kobo.546.1">Reading a text file line by line</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.547.1">The function to read a file line by line is found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.548.1">byLine.go</span></code><span class="koboSpan" id="kobo.549.1"> and is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.550.1">lineByLine()</span></code><span class="koboSpan" id="kobo.551.1">. </span><span class="koboSpan" id="kobo.551.2">The technique for reading a text file line by line is also used when reading a plain text file word by word, as well as when reading a plain text file character by character because you usually process</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.552.1"> plain text files line by line. </span><span class="koboSpan" id="kobo.552.2">The presented utility prints every line that it reads, which makes it a simplified version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.553.1">cat(1)</span></code><span class="koboSpan" id="kobo.554.1"> utility.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.555.1">First, you create a new reader for the desired file using a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.556.1">bufio.NewReader()</span></code><span class="koboSpan" id="kobo.557.1">. </span><span class="koboSpan" id="kobo.557.2">Then, you use that reader with </span><code class="inlineCode"><span class="koboSpan" id="kobo.558.1">bufio.ReadString()</span></code><span class="koboSpan" id="kobo.559.1"> in order to read the input file line by line. </span><span class="koboSpan" id="kobo.559.2">The trick is done by the parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.560.1">bufio.ReadString()</span></code><span class="koboSpan" id="kobo.561.1">, which is a character that tells </span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">bufio.ReadString()</span></code><span class="koboSpan" id="kobo.563.1"> to keep reading until that character is found. </span><span class="koboSpan" id="kobo.563.2">Constantly calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.564.1">bufio.ReadString()</span></code><span class="koboSpan" id="kobo.565.1"> when that parameter is the newline character (</span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">\n</span></code><span class="koboSpan" id="kobo.567.1">) results in reading the input file line by line.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.568.1">The implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.569.1">lineByLine()</span></code><span class="koboSpan" id="kobo.570.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.571.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.572.1">lineByLine</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.573.1">(file </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.574.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.575.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.576.1">error</span></span><span class="koboSpan" id="kobo.577.1"> {
    f, err := os.Open(file)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.578.1">if</span></span><span class="koboSpan" id="kobo.579.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.580.1">nil</span></span><span class="koboSpan" id="kobo.581.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.582.1">return</span></span><span class="koboSpan" id="kobo.583.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.584.1">defer</span></span><span class="koboSpan" id="kobo.585.1"> f.Close()
    r := bufio.NewReader(f)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.586.1">After making sure that you can open the given file for reading (</span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">os.Open()</span></code><span class="koboSpan" id="kobo.588.1">), you create a new reader using </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">bufio.NewReader()</span></code><span class="koboSpan" id="kobo.590.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.591.1">for</span></span><span class="koboSpan" id="kobo.592.1"> {
        line, err := r.ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.593.1">'\n'</span></span><span class="koboSpan" id="kobo.594.1">)
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">bufio.ReadString()</span></code><span class="koboSpan" id="kobo.596.1"> returns two values: the string that was read and an error variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.597.1">if</span></span><span class="koboSpan" id="kobo.598.1"> err == io.EOF {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.599.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.600.1">len</span></span><span class="koboSpan" id="kobo.601.1">(line) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.602.1">0</span></span><span class="koboSpan" id="kobo.603.1"> {
                    fmt.Println(line)
            }
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.604.1">break</span></span><span class="koboSpan" id="kobo.605.1">
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.606.1">if</span></span><span class="koboSpan" id="kobo.607.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.608.1">nil</span></span><span class="koboSpan" id="kobo.609.1"> {
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.610.1">"error reading file %s"</span></span><span class="koboSpan" id="kobo.611.1">, err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.612.1">return</span></span><span class="koboSpan" id="kobo.613.1"> err
        }
        fmt.Print(line)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.614.1">The use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.615.1">fmt.Print()</span></code><span class="koboSpan" id="kobo.616.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.617.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.618.1"> to print the input line shows that the newline character is included in each</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.619.1"> input line.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.620.1">    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.621.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.622.1">nil</span></span><span class="koboSpan" id="kobo.623.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.624.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.625.1">byLine.go</span></code><span class="koboSpan" id="kobo.626.1"> generates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.627.1">$ </span></span><span class="koboSpan" id="kobo.628.1">go run byLine.go ~/csv.data
Dimitris,Tsoukalos,2101112223,1600665563
Mihalis,Tsoukalos,2109416471,1600665563
Jane,Doe,0800123456,1608559903
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.629.1">The previous output shows the contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.630.1">~/csv.data</span></code><span class="koboSpan" id="kobo.631.1"> (use your own plain text file) presented line by line with the help of </span><code class="inlineCode"><span class="koboSpan" id="kobo.632.1">byLine.go</span></code><span class="koboSpan" id="kobo.633.1">. </span><span class="koboSpan" id="kobo.633.2">The next subsection shows how to read a plain text file word by word.</span></p>
<h2 class="heading-2" id="_idParaDest-187"><span class="koboSpan" id="kobo.634.1">Reading a text file word by word</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.635.1">Reading a plain text file word by word is </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.636.1">one of the most useful functions that you want to perform on a file because you usually want to process a file on a per-word basis—it is illustrated in this subsection, using the code found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">byWord.go</span></code><span class="koboSpan" id="kobo.638.1">. </span><span class="koboSpan" id="kobo.638.2">The desired functionality is implemented in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.639.1">wordByWord()</span></code><span class="koboSpan" id="kobo.640.1"> function. </span><span class="koboSpan" id="kobo.640.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.641.1">wordByWord()</span></code><span class="koboSpan" id="kobo.642.1"> function uses </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.643.1">regular expressions </span></strong><span class="koboSpan" id="kobo.644.1">to separate the words found in each line of the input file. </span><span class="koboSpan" id="kobo.644.2">The regular expression defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">regexp.MustCompile("[^\\s]+")</span></code><span class="koboSpan" id="kobo.646.1"> statement states that we use whitespace characters to separate one word from another.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.647.1">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.648.1">wordByWord()</span></code><span class="koboSpan" id="kobo.649.1"> function is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.650.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.651.1">wordByWord</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.652.1">(file </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.653.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.654.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.655.1">error</span></span><span class="koboSpan" id="kobo.656.1"> {
    f, err := os.Open(file)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.657.1">if</span></span><span class="koboSpan" id="kobo.658.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.659.1">nil</span></span><span class="koboSpan" id="kobo.660.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.661.1">return</span></span><span class="koboSpan" id="kobo.662.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.663.1">defer</span></span><span class="koboSpan" id="kobo.664.1"> f.Close()
    r := bufio.NewReader(f)
    re := regexp.MustCompile(</span><span class="hljs-string"><span class="koboSpan" id="kobo.665.1">"[^\\s]+"</span></span><span class="koboSpan" id="kobo.666.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.667.1">for</span></span><span class="koboSpan" id="kobo.668.1"> {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.669.1">This is where we define the</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.670.1"> regular expression for splitting lines into words.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.671.1">        line, err := r.ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.672.1">'\n'</span></span><span class="koboSpan" id="kobo.673.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.674.1">if</span></span><span class="koboSpan" id="kobo.675.1"> err == io.EOF {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.676.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.677.1">len</span></span><span class="koboSpan" id="kobo.678.1">(line) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.679.1">0</span></span><span class="koboSpan" id="kobo.680.1"> {
                words := re.FindAllString(line, </span><span class="hljs-number"><span class="koboSpan" id="kobo.681.1">-1</span></span><span class="koboSpan" id="kobo.682.1">)
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.683.1">for</span></span><span class="koboSpan" id="kobo.684.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.685.1">0</span></span><span class="koboSpan" id="kobo.686.1">; i &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.687.1">len</span></span><span class="koboSpan" id="kobo.688.1">(words); i++ {
                    fmt.Println(words[i])
                }
            }
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.689.1">break</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.690.1">This is the tricky part of the program. </span><span class="koboSpan" id="kobo.690.2">If we reach the end of a file having a line that does not end with a newline character, we must also process it, but after that, we must exit the </span><code class="inlineCode"><span class="koboSpan" id="kobo.691.1">for</span></code><span class="koboSpan" id="kobo.692.1"> loop, as there is nothing more to read from that file. </span><span class="koboSpan" id="kobo.692.2">The previous code takes care of it.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.693.1">        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.694.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.695.1">if</span></span><span class="koboSpan" id="kobo.696.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.697.1">nil</span></span><span class="koboSpan" id="kobo.698.1"> {
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.699.1">"error reading file %s"</span></span><span class="koboSpan" id="kobo.700.1">, err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.701.1">return</span></span><span class="koboSpan" id="kobo.702.1"> err
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.703.1">In this part of the program, we deal with potential error conditions that might come up and prevent us from reading the file.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.704.1">        words := re.FindAllString(line, </span><span class="hljs-number"><span class="koboSpan" id="kobo.705.1">-1</span></span><span class="koboSpan" id="kobo.706.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.707.1">This is the place where we apply the regular expression to split the </span><code class="inlineCode"><span class="koboSpan" id="kobo.708.1">line</span></code><span class="koboSpan" id="kobo.709.1"> variable into fields when the line that we have read ends with newline character.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.710.1">for</span></span><span class="koboSpan" id="kobo.711.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.712.1">0</span></span><span class="koboSpan" id="kobo.713.1">; i &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.714.1">len</span></span><span class="koboSpan" id="kobo.715.1">(words); i++ {
            fmt.Println(words[i])
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.716.1">This </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">for</span></code><span class="koboSpan" id="kobo.718.1"> loop just prints the fields of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">words</span></code><span class="koboSpan" id="kobo.720.1"> slice. </span><span class="koboSpan" id="kobo.720.2">If you want to know the number of words found in the input line, you </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.721.1">can just find the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">len(words)</span></code><span class="koboSpan" id="kobo.723.1"> call.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.724.1">    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.725.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.726.1">nil</span></span><span class="koboSpan" id="kobo.727.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.728.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.729.1">byWord.go</span></code><span class="koboSpan" id="kobo.730.1"> produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.731.1">$ </span></span><span class="koboSpan" id="kobo.732.1">go run byWord.go ~/csv.data
Dimitris,Tsoukalos,2101112223,1600665563
Mihalis,Tsoukalos,2109416471,1600665563
Jane,Doe,0800123456,1608559903
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.733.1">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">~/csv.data</span></code><span class="koboSpan" id="kobo.735.1"> does not contain any whitespace characters, each line is considered a single word!</span></p>
<h2 class="heading-2" id="_idParaDest-188"><span class="koboSpan" id="kobo.736.1">Reading a text file character by character</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.737.1">In this subsection, you will learn how to read a</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.738.1"> text file character by character, which is a rare requirement unless you want to develop a text editor. </span><span class="koboSpan" id="kobo.738.2">You take each line that you read and split it using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.739.1">for</span></code><span class="koboSpan" id="kobo.740.1"> loop with a range, which returns two values. </span><span class="koboSpan" id="kobo.740.2">You discard the first, which is the location of the current character in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.741.1">line</span></code><span class="koboSpan" id="kobo.742.1"> variable, and you use the second. </span><span class="koboSpan" id="kobo.742.2">However, that value is a rune, which means that you have to convert it into a character using </span><code class="inlineCode"><span class="koboSpan" id="kobo.743.1">string()</span></code><span class="koboSpan" id="kobo.744.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.745.1">The implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">charByChar()</span></code><span class="koboSpan" id="kobo.747.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.748.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.749.1">charByChar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.750.1">(file </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.751.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.752.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.753.1">error</span></span><span class="koboSpan" id="kobo.754.1"> {
  f, err := os.Open(file)
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.755.1">if</span></span><span class="koboSpan" id="kobo.756.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.757.1">nil</span></span><span class="koboSpan" id="kobo.758.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.759.1">return</span></span><span class="koboSpan" id="kobo.760.1"> err
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.761.1">defer</span></span><span class="koboSpan" id="kobo.762.1"> f.Close()
  r := bufio.NewReader(f)
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.763.1">for</span></span><span class="koboSpan" id="kobo.764.1"> {
    line, err := r.ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.765.1">'\n'</span></span><span class="koboSpan" id="kobo.766.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.767.1">if</span></span><span class="koboSpan" id="kobo.768.1"> err == io.EOF {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.769.1">if</span></span> <span class="code-highlight"><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.770.1">len</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.771.1">(line) != </span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.772.1">0</span></strong></span><span class="koboSpan" id="kobo.773.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.774.1">for</span></span><span class="koboSpan" id="kobo.775.1"> _, x := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.776.1">range</span></span><span class="koboSpan" id="kobo.777.1"> line {
          fmt.Println(</span><span class="hljs-type"><span class="koboSpan" id="kobo.778.1">string</span></span><span class="koboSpan" id="kobo.779.1">(x))
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.780.1">Once again, we should take extra care with lines that end without a newline character. </span><span class="koboSpan" id="kobo.780.2">The conditions for catching such lines are that we have reached the end of the file that we are reading and that we still have text to process.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.781.1">      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.782.1">break</span></span><span class="koboSpan" id="kobo.783.1">
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.784.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.785.1">if</span></span><span class="koboSpan" id="kobo.786.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.787.1">nil</span></span><span class="koboSpan" id="kobo.788.1"> {
      fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.789.1">"error reading file %s"</span></span><span class="koboSpan" id="kobo.790.1">, err)
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.791.1">return</span></span><span class="koboSpan" id="kobo.792.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.793.1">for</span></span><span class="koboSpan" id="kobo.794.1"> _, x := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.795.1">range</span></span><span class="koboSpan" id="kobo.796.1"> line {
      fmt.Println(</span><span class="hljs-type"><span class="koboSpan" id="kobo.797.1">string</span></span><span class="koboSpan" id="kobo.798.1">(x))
    }
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.799.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.800.1">nil</span></span><span class="koboSpan" id="kobo.801.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.802.1">Note that, due to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.803.1">fmt.Println(string(x))</span></code><span class="koboSpan" id="kobo.804.1"> statement, each character is printed in a distinct line, which means</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.805.1"> that the output of the program is going to be large. </span><span class="koboSpan" id="kobo.805.2">If you want a more compressed output, you should use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.806.1">fmt.Print()</span></code><span class="koboSpan" id="kobo.807.1"> function instead.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.808.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.809.1">byCharacter.go</span></code><span class="koboSpan" id="kobo.810.1"> and filtering it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.811.1">head(1)</span></code><span class="koboSpan" id="kobo.812.1">, without any parameters, produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.813.1">$ </span></span><span class="koboSpan" id="kobo.814.1">go run byCharacter.go ~/csv.data | </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.815.1">head</span></span><span class="koboSpan" id="kobo.816.1">
D
...
</span><span class="koboSpan" id="kobo.816.2">,
T
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.817.1">The use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.818.1">head(1)</span></code><span class="koboSpan" id="kobo.819.1"> utility without any parameters limits the output to just 10 lines. </span><span class="koboSpan" id="kobo.819.2">Type </span><code class="inlineCode"><span class="koboSpan" id="kobo.820.1">man head</span></code><span class="koboSpan" id="kobo.821.1"> to learn more about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.822.1">head(1)</span></code><span class="koboSpan" id="kobo.823.1"> utility.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.824.1">The next section is about reading from </span><code class="inlineCode"><span class="koboSpan" id="kobo.825.1">/dev/random</span></code><span class="koboSpan" id="kobo.826.1">, which is a UNIX system file.</span></p>
<h2 class="heading-2" id="_idParaDest-189"><span class="koboSpan" id="kobo.827.1">Reading from /dev/random</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.828.1">In this subsection, you will learn how to read from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.829.1">/dev/random</span></code><span class="koboSpan" id="kobo.830.1"> system device. </span><span class="koboSpan" id="kobo.830.2">The purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.831.1">/dev/random</span></code><span class="koboSpan" id="kobo.832.1"> system </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.833.1">device is to generate random data, which you might use to test your programs or, in this case, as the seed for a random number generator. </span><span class="koboSpan" id="kobo.833.2">Getting data from </span><code class="inlineCode"><span class="koboSpan" id="kobo.834.1">/dev/random</span></code><span class="koboSpan" id="kobo.835.1"> can be a little bit tricky, and this is the main reason for specifically discussing it here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.836.1">The code for </span><code class="inlineCode"><span class="koboSpan" id="kobo.837.1">devRandom.go</span></code><span class="koboSpan" id="kobo.838.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.839.1">package</span></span><span class="koboSpan" id="kobo.840.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.841.1">import</span></span><span class="koboSpan" id="kobo.842.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.843.1">"encoding/binary"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.844.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.845.1">"os"</span></span><span class="koboSpan" id="kobo.846.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.847.1">You need </span><code class="inlineCode"><span class="koboSpan" id="kobo.848.1">encoding/binary</span></code><span class="koboSpan" id="kobo.849.1"> because you read binary data from </span><code class="inlineCode"><span class="koboSpan" id="kobo.850.1">/dev/random</span></code><span class="koboSpan" id="kobo.851.1"> that you convert into integer values.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.852.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.853.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.854.1">()</span></span><span class="koboSpan" id="kobo.855.1"> {
    f, err := os.Open(</span><span class="hljs-string"><span class="koboSpan" id="kobo.856.1">"/dev/random"</span></span><span class="koboSpan" id="kobo.857.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.858.1">defer</span></span><span class="koboSpan" id="kobo.859.1"> f.Close()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.860.1">if</span></span><span class="koboSpan" id="kobo.861.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.862.1">nil</span></span><span class="koboSpan" id="kobo.863.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.864.1">return</span></span><span class="koboSpan" id="kobo.865.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.866.1">var</span></span><span class="koboSpan" id="kobo.867.1"> seed </span><span class="hljs-type"><span class="koboSpan" id="kobo.868.1">int64</span></span><span class="koboSpan" id="kobo.869.1">
    binary.Read(f, binary.LittleEndian, &amp;seed)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.870.1">"Seed:"</span></span><span class="koboSpan" id="kobo.871.1">, seed)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.872.1">There are two representations named </span><em class="italic"><span class="koboSpan" id="kobo.873.1">little endian</span></em><span class="koboSpan" id="kobo.874.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.875.1">big endian</span></em><span class="koboSpan" id="kobo.876.1"> that relate to the byte order in the internal representation. </span><span class="koboSpan" id="kobo.876.2">In our case, we are using little endian. </span><span class="koboSpan" id="kobo.876.3">The endian-ness relates to the way different computing systems order multiple bytes of information.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.877.1">A real-world example of endian-ness is how different languages read text in different ways: European languages tend to be read from left to right, whereas Arabic texts are read from right to left.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.878.1">In a big endian representation, bytes are read from left to right, while little endian reads bytes from right to left. </span><span class="koboSpan" id="kobo.878.2">For the </span><code class="inlineCode"><span class="koboSpan" id="kobo.879.1">0x01234567</span></code><span class="koboSpan" id="kobo.880.1"> value, which requires 4 bytes for storing, the big endian </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.881.1">representation is </span><code class="inlineCode"><span class="koboSpan" id="kobo.882.1">01 | 23 | 45 | 67</span></code><span class="koboSpan" id="kobo.883.1">, whereas the little endian representation is </span><code class="inlineCode"><span class="koboSpan" id="kobo.884.1">67 | 45 | 23 | 01</span></code><span class="koboSpan" id="kobo.885.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.886.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.887.1">devRandom.go</span></code><span class="koboSpan" id="kobo.888.1"> creates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.889.1">$ </span></span><span class="koboSpan" id="kobo.890.1">go run devRandom.go
Seed: 422907465220227415
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.891.1">This means that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.892.1">/dev/random</span></code><span class="koboSpan" id="kobo.893.1"> device is a good place to get random data, including a seed value for your random number generator.</span></p>
<h2 class="heading-2" id="_idParaDest-190"><span class="koboSpan" id="kobo.894.1">Reading a specific amount of data from a file</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.895.1">This subsection teaches you how to</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.896.1"> read a specific amount of data from a file. </span><span class="koboSpan" id="kobo.896.2">The presented utility can come in handy when you want to see a small part of a file. </span><span class="koboSpan" id="kobo.896.3">The numeric value that is given as a command line argument specifies the size of the buffer that is going to be used for reading. </span><span class="koboSpan" id="kobo.896.4">The most important code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.897.1">readSize.go</span></code><span class="koboSpan" id="kobo.898.1"> is the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.899.1">readSize()</span></code><span class="koboSpan" id="kobo.900.1"> function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.901.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.902.1">readSize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.903.1">(f *os.File, size </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.904.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.905.1">)</span></span><span class="koboSpan" id="kobo.906.1"> []</span><span class="hljs-type"><span class="koboSpan" id="kobo.907.1">byte</span></span><span class="koboSpan" id="kobo.908.1"> {
    buffer := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.909.1">make</span></span><span class="koboSpan" id="kobo.910.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.911.1">byte</span></span><span class="koboSpan" id="kobo.912.1">, size)
    n, err := f.Read(buffer)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.913.1">All the magic happens in the definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">buffer</span></code><span class="koboSpan" id="kobo.915.1"> variable, because this is where we define the maximum amount of data that it can hold. </span><span class="koboSpan" id="kobo.915.2">Therefore, each time we invoke </span><code class="inlineCode"><span class="koboSpan" id="kobo.916.1">readSize()</span></code><span class="koboSpan" id="kobo.917.1">, the function is going to read from </span><code class="inlineCode"><span class="koboSpan" id="kobo.918.1">f</span></code><span class="koboSpan" id="kobo.919.1"> at most </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">size</span></code><span class="koboSpan" id="kobo.921.1"> characters.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.922.1">// io.EOF is a special case and is treated as such</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.923.1">if</span></span><span class="koboSpan" id="kobo.924.1"> err == io.EOF {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.925.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.926.1">nil</span></span><span class="koboSpan" id="kobo.927.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.928.1">if</span></span><span class="koboSpan" id="kobo.929.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.930.1">nil</span></span><span class="koboSpan" id="kobo.931.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.932.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.933.1">nil</span></span><span class="koboSpan" id="kobo.934.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.935.1">return</span></span><span class="koboSpan" id="kobo.936.1"> buffer[</span><span class="hljs-number"><span class="koboSpan" id="kobo.937.1">0</span></span><span class="koboSpan" id="kobo.938.1">:n]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.939.1">The remaining code is about error conditions; </span><code class="inlineCode"><span class="koboSpan" id="kobo.940.1">io.EOF</span></code><span class="koboSpan" id="kobo.941.1"> is a special and expected condition that should be treated separately and return the read characters as a byte slice to the caller function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.942.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.943.1">readSize.go</span></code><span class="koboSpan" id="kobo.944.1"> produces</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.945.1"> the following kind of output.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.946.1">$ </span></span><span class="koboSpan" id="kobo.947.1">go run readSize.go 12 readSize.go
package main
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.948.1">In this case, we read 12 characters from </span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">readSize.go</span></code><span class="koboSpan" id="kobo.950.1"> itself because of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.951.1">12</span></code><span class="koboSpan" id="kobo.952.1"> parameter. </span><span class="koboSpan" id="kobo.952.2">Now that we know how to read files, it is time to learn how to write to files.</span></p>
<h1 class="heading-1" id="_idParaDest-191"><span class="koboSpan" id="kobo.953.1">Writing to a file</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.954.1">So far, we have seen ways to</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.955.1"> read files. </span><span class="koboSpan" id="kobo.955.2">This subsection shows how to write data to files in four different ways and how to append data to an existing file. </span><span class="koboSpan" id="kobo.955.3">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.956.1">writeFile.go</span></code><span class="koboSpan" id="kobo.957.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.958.1">package</span></span><span class="koboSpan" id="kobo.959.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.960.1">import</span></span><span class="koboSpan" id="kobo.961.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.962.1">"bufio"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.963.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.964.1">"io"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.965.1">"os"</span></span><span class="koboSpan" id="kobo.966.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.967.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.968.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.969.1">()</span></span><span class="koboSpan" id="kobo.970.1"> {
    buffer := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.971.1">byte</span></span><span class="koboSpan" id="kobo.972.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.973.1">"Data to write\n"</span></span><span class="koboSpan" id="kobo.974.1">)
    f1, err := os.Create(</span><span class="hljs-string"><span class="koboSpan" id="kobo.975.1">"/tmp/f1.txt"</span></span><span class="koboSpan" id="kobo.976.1">)
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.977.1">os.Create()</span></code><span class="koboSpan" id="kobo.978.1"> returns an </span><code class="inlineCode"><span class="koboSpan" id="kobo.979.1">*os.File</span></code><span class="koboSpan" id="kobo.980.1"> value associated with the file path that is passed as a parameter. </span><span class="koboSpan" id="kobo.980.2">Note that if the file already exists, </span><code class="inlineCode"><span class="koboSpan" id="kobo.981.1">os.Create()</span></code><span class="koboSpan" id="kobo.982.1"> truncates it.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.983.1">if</span></span><span class="koboSpan" id="kobo.984.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.985.1">nil</span></span><span class="koboSpan" id="kobo.986.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.987.1">"Cannot create file"</span></span><span class="koboSpan" id="kobo.988.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.989.1">return</span></span><span class="koboSpan" id="kobo.990.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.991.1">defer</span></span><span class="koboSpan" id="kobo.992.1"> f1.Close()
    fmt.Fprintf(f1, </span><span class="hljs-type"><span class="koboSpan" id="kobo.993.1">string</span></span><span class="koboSpan" id="kobo.994.1">(buffer))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.995.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.996.1">fmt.Fprintf()</span></code><span class="koboSpan" id="kobo.997.1"> function, which requires a </span><code class="inlineCode"><span class="koboSpan" id="kobo.998.1">string</span></code><span class="koboSpan" id="kobo.999.1"> variable, helps you write data to your own files using the format you want. </span><span class="koboSpan" id="kobo.999.2">The only requirement is having an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1000.1">io.Writer</span></code><span class="koboSpan" id="kobo.1001.1"> to write to. </span><span class="koboSpan" id="kobo.1001.2">In this case, a valid </span><code class="inlineCode"><span class="koboSpan" id="kobo.1002.1">*os.File</span></code><span class="koboSpan" id="kobo.1003.1"> variable, which satisfies the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1004.1">io.Writer</span></code><span class="koboSpan" id="kobo.1005.1"> interface, does the job.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1006.1">    f2, err := os.Create(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1007.1">"/tmp/f2.txt"</span></span><span class="koboSpan" id="kobo.1008.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1009.1">if</span></span><span class="koboSpan" id="kobo.1010.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1011.1">nil</span></span><span class="koboSpan" id="kobo.1012.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1013.1">"Cannot create file"</span></span><span class="koboSpan" id="kobo.1014.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1015.1">return</span></span><span class="koboSpan" id="kobo.1016.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1017.1">defer</span></span><span class="koboSpan" id="kobo.1018.1"> f2.Close()
    n, err := f2.WriteString(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1019.1">string</span></span><span class="koboSpan" id="kobo.1020.1">(buffer))
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1021.1">WriteString()</span></code><span class="koboSpan" id="kobo.1022.1"> writes the contents </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.1023.1">of a string to a valid </span><code class="inlineCode"><span class="koboSpan" id="kobo.1024.1">*os.File</span></code><span class="koboSpan" id="kobo.1025.1"> variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1026.1">    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1027.1">"wrote %d bytes\n"</span></span><span class="koboSpan" id="kobo.1028.1">, n)
    f3, err := os.Create(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1029.1">"/tmp/f3.txt"</span></span><span class="koboSpan" id="kobo.1030.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1031.1">Here, we create a temporary file on our own. </span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1032.1">Go also offers </span><code class="inlineCode"><span class="koboSpan" id="kobo.1033.1">os.CreateTemp()</span></code><span class="koboSpan" id="kobo.1034.1"> to create temporary files. </span><span class="koboSpan" id="kobo.1034.2">Type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1035.1">go doc os.CreateTemp</span></code><span class="koboSpan" id="kobo.1036.1"> to learn more about it.</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1037.1">if</span></span><span class="koboSpan" id="kobo.1038.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1039.1">nil</span></span><span class="koboSpan" id="kobo.1040.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1041.1">return</span></span><span class="koboSpan" id="kobo.1042.1">
    }
    w := bufio.NewWriter(f3)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1043.1">This function returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1044.1">bufio.Writer</span></code><span class="koboSpan" id="kobo.1045.1">, which satisfies the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1046.1">io.Writer</span></code><span class="koboSpan" id="kobo.1047.1"> interface.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1048.1">    n, err = w.WriteString(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1049.1">string</span></span><span class="koboSpan" id="kobo.1050.1">(buffer))
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1051.1">"wrote %d bytes\n"</span></span><span class="koboSpan" id="kobo.1052.1">, n)
    w.Flush()
    f := </span><span class="hljs-string"><span class="koboSpan" id="kobo.1053.1">"/tmp/f4.txt"</span></span><span class="koboSpan" id="kobo.1054.1">
    f4, err := os.Create(f)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1055.1">if</span></span><span class="koboSpan" id="kobo.1056.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1057.1">nil</span></span><span class="koboSpan" id="kobo.1058.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1059.1">return</span></span><span class="koboSpan" id="kobo.1060.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1061.1">defer</span></span><span class="koboSpan" id="kobo.1062.1"> f4.Close()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1063.1">for</span></span><span class="koboSpan" id="kobo.1064.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1065.1">0</span></span><span class="koboSpan" id="kobo.1066.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1067.1">5</span></span><span class="koboSpan" id="kobo.1068.1">; i++ {
        n, err = io.WriteString(f4, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1069.1">string</span></span><span class="koboSpan" id="kobo.1070.1">(buffer))
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1071.1">if</span></span><span class="koboSpan" id="kobo.1072.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1073.1">nil</span></span><span class="koboSpan" id="kobo.1074.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1075.1">return</span></span><span class="koboSpan" id="kobo.1076.1">
        }
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1077.1">"wrote %d bytes\n"</span></span><span class="koboSpan" id="kobo.1078.1">, n)
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1079.1">// Append to a file</span></span><span class="koboSpan" id="kobo.1080.1">
    f4, err = os.OpenFile(f, os.O_APPEND|os.O_CREATE|os.O_WRONLY, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1081.1">0644</span></span><span class="koboSpan" id="kobo.1082.1">)
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1083.1">os.OpenFile()</span></code><span class="koboSpan" id="kobo.1084.1"> provides a better way to create or open a file for writing. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1085.1">os.O_APPEND</span></code><span class="koboSpan" id="kobo.1086.1"> says that if the file already exists, you should append to it instead of truncating it. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1087.1">os.O_CREATE</span></code><span class="koboSpan" id="kobo.1088.1"> states that if the file </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.1089.1">does not already exist, it should be created. </span><span class="koboSpan" id="kobo.1089.2">Last, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1090.1">os.O_WRONLY</span></code><span class="koboSpan" id="kobo.1091.1"> says that the program should open the file for writing only.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1092.1">if</span></span><span class="koboSpan" id="kobo.1093.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1094.1">nil</span></span><span class="koboSpan" id="kobo.1095.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1096.1">return</span></span><span class="koboSpan" id="kobo.1097.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1098.1">defer</span></span><span class="koboSpan" id="kobo.1099.1"> f4.Close()
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1100.1">// Write() needs a byte slice</span></span><span class="koboSpan" id="kobo.1101.1">
    n, err = f4.Write([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1102.1">byte</span></span><span class="koboSpan" id="kobo.1103.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1104.1">"Put some more data at the end.\n"</span></span><span class="koboSpan" id="kobo.1105.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1106.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1107.1">Write()</span></code><span class="koboSpan" id="kobo.1108.1"> method gets its input from a byte slice, which is the Go way of writing. </span><span class="koboSpan" id="kobo.1108.2">All previous techniques used strings, which is not the best way, especially when working with binary data. </span><span class="koboSpan" id="kobo.1108.3">However, using strings instead of byte slices is more practical as it is more convenient to manipulate </span><code class="inlineCode"><span class="koboSpan" id="kobo.1109.1">string</span></code><span class="koboSpan" id="kobo.1110.1"> values than the elements of a byte slice, especially when working with Unicode characters. </span><span class="koboSpan" id="kobo.1110.2">On the other hand, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1111.1">string</span></code><span class="koboSpan" id="kobo.1112.1"> values increases allocation and can cause a lot of garbage collection pressure.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1113.1">if</span></span><span class="koboSpan" id="kobo.1114.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1115.1">nil</span></span><span class="koboSpan" id="kobo.1116.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1117.1">return</span></span><span class="koboSpan" id="kobo.1118.1">
    }
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1119.1">"wrote %d bytes\n"</span></span><span class="koboSpan" id="kobo.1120.1">, n)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1121.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1122.1">writeFile.go</span></code><span class="koboSpan" id="kobo.1123.1"> generates some information output about the bytes written on disk. </span><span class="koboSpan" id="kobo.1123.2">What is interesting is seeing the files created in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1124.1">/tmp</span></code><span class="koboSpan" id="kobo.1125.1"> folder:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1126.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1127.1">ls</span></span><span class="koboSpan" id="kobo.1128.1"> -l /tmp/f?.txt
-rw-r--r--@ 1 mtsouk  wheel   14 Aug  5 11:30 /tmp/f1.txt
-rw-r--r--@ 1 mtsouk  wheel   14 Aug  5 11:30 /tmp/f2.txt
-rw-r--r--@ 1 mtsouk  wheel   14 Aug  5 11:30 /tmp/f3.txt
-rw-r--r--@ 1 mtsouk  wheel  101 Aug  5 11:30 /tmp/f4.txt
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1129.1">The previous output shows that the same amount of information (14 bytes) has been written in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1130.1">f1.txt</span></code><span class="koboSpan" id="kobo.1131.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1132.1">f2.txt</span></code><span class="koboSpan" id="kobo.1133.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1134.1">f3.txt</span></code><span class="koboSpan" id="kobo.1135.1">, which means that the presented writing techniques are equivalent.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1136.1">The next section shows </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.1137.1">how to work with JSON data in Go.</span></p>
<h1 class="heading-1" id="_idParaDest-192"><span class="koboSpan" id="kobo.1138.1">Working with JSON</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1139.1">The Go standard library</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.1140.1"> includes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1141.1">encoding/json</span></code><span class="koboSpan" id="kobo.1142.1">, which is for working with JSON data. </span><span class="koboSpan" id="kobo.1142.2">Additionally, Go allows you to add support for JSON fields in Go structures using tags, which is the subject of the Structures and JSON subsection. </span><span class="koboSpan" id="kobo.1142.3">Tags control the encoding and decoding of JSON records to and from Go structures. </span><span class="koboSpan" id="kobo.1142.4">But first, we should talk about the </span><em class="italic"><span class="koboSpan" id="kobo.1143.1">marshaling</span></em><span class="koboSpan" id="kobo.1144.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1145.1">unmarshaling</span></em><span class="koboSpan" id="kobo.1146.1"> of JSON records.</span></p>
<h2 class="heading-2" id="_idParaDest-193"><span class="koboSpan" id="kobo.1147.1">Using Marshal() and Unmarshal()</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1148.1">Both the marshaling and unmarshaling of JSON data are important procedures for working with JSON data using Go</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.1149.1"> structures. </span><span class="koboSpan" id="kobo.1149.2">Marshaling is the process of converting a Go structure into a JSON record. </span><span class="koboSpan" id="kobo.1149.3">You usually want that for transferring JSON data via computer</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.1150.1"> networks or for saving it on disk. </span><span class="koboSpan" id="kobo.1150.2">Unmarshaling is the process of converting a JSON record given as a byte slice into a Go structure. </span><span class="koboSpan" id="kobo.1150.3">You usually want that when receiving JSON data via computer networks or when loading JSON data from disk files.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1151.1">The number one bug when converting JSON records into Go structures, and vice versa, is not making the required fields of your Go structures exported, that is having their first letter in uppercase. </span><span class="koboSpan" id="kobo.1151.2">When you have issues with marshaling and unmarshaling, begin your debugging process from there.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1152.1">The code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1153.1">encodeDecode.go</span></code><span class="koboSpan" id="kobo.1154.1"> illustrates both the marshaling and unmarshaling of JSON records using hardcoded data for simplicity:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1155.1">package</span></span><span class="koboSpan" id="kobo.1156.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1157.1">import</span></span><span class="koboSpan" id="kobo.1158.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1159.1">"encoding/json"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1160.1">"fmt"</span></span><span class="koboSpan" id="kobo.1161.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1162.1">type</span></span><span class="koboSpan" id="kobo.1163.1"> UseAll </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1164.1">struct</span></span><span class="koboSpan" id="kobo.1165.1"> {
    Name    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1166.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1167.1">`json:"username"`</span></span><span class="koboSpan" id="kobo.1168.1">
    Surname </span><span class="hljs-type"><span class="koboSpan" id="kobo.1169.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1170.1">`</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1171.1">json:"surname"`</span></span><span class="koboSpan" id="kobo.1172.1">
    Year    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1173.1">int</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1174.1">`json:"created"`</span></span><span class="koboSpan" id="kobo.1175.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1176.1">What the previous metadata tells us is that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1177.1">Name</span></code><span class="koboSpan" id="kobo.1178.1"> field of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1179.1">UseAll</span></code><span class="koboSpan" id="kobo.1180.1"> structure is translated to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1181.1">username</span></code><span class="koboSpan" id="kobo.1182.1"> in the JSON record, and vice versa; the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1183.1">Surname</span></code><span class="koboSpan" id="kobo.1184.1"> field is translated to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1185.1">surname</span></code><span class="koboSpan" id="kobo.1186.1">, and vice versa; and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1187.1">Year</span></code><span class="koboSpan" id="kobo.1188.1"> structure</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.1189.1"> field is translated to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1190.1">created</span></code><span class="koboSpan" id="kobo.1191.1"> in the JSON record, and vice versa. </span><span class="koboSpan" id="kobo.1191.2">This</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.1192.1"> information has to do with the marshaling and unmarshaling of JSON data. </span><span class="koboSpan" id="kobo.1192.2">Other than this, you treat and use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1193.1">UseAll</span></code><span class="koboSpan" id="kobo.1194.1"> as a regular Go structure.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1195.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1196.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1197.1">()</span></span><span class="koboSpan" id="kobo.1198.1"> {
    useall := UseAll{Name: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1199.1">"Mike"</span></span><span class="koboSpan" id="kobo.1200.1">, Surname: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1201.1">"Tsoukalos"</span></span><span class="koboSpan" id="kobo.1202.1">, Year: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1203.1">2023</span></span><span class="koboSpan" id="kobo.1204.1">}
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1205.1">// Encoding JSON data: Convert Structure to JSON record with fields</span></span><span class="koboSpan" id="kobo.1206.1">
    t, err := json.Marshal(&amp;useall)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1207.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1208.1">json.Marshal()</span></code><span class="koboSpan" id="kobo.1209.1"> function requires a pointer to a structure variable—its real data type is an empty interface variable—and returns a byte slice with the encoded information and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1210.1">error</span></code><span class="koboSpan" id="kobo.1211.1"> variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1212.1">if</span></span><span class="koboSpan" id="kobo.1213.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1214.1">nil</span></span><span class="koboSpan" id="kobo.1215.1"> {
        fmt.Println(err)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1216.1">else</span></span><span class="koboSpan" id="kobo.1217.1"> {
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1218.1">"Value %s\n"</span></span><span class="koboSpan" id="kobo.1219.1">, t)
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1220.1">// Decoding JSON data given as a string</span></span><span class="koboSpan" id="kobo.1221.1">
    str := </span><span class="hljs-string"><span class="koboSpan" id="kobo.1222.1">`{"username": "M.", "surname": "Ts", "created":2024}`</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1223.1">JSON data usually comes as a string.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1224.1">// Convert string into a byte slice</span></span><span class="koboSpan" id="kobo.1225.1">
    jsonRecord := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1226.1">byte</span></span><span class="koboSpan" id="kobo.1227.1">(str)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1228.1">However, as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1229.1">json.Unmarshal()</span></code><span class="koboSpan" id="kobo.1230.1"> requires a byte slice, you need to convert that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1231.1">string</span></code><span class="koboSpan" id="kobo.1232.1"> into a byte slice before passing it to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1233.1">json.Unmarshal()</span></code><span class="koboSpan" id="kobo.1234.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1235.1">// Create a structure variable to store the result</span></span><span class="koboSpan" id="kobo.1236.1">
    temp := UseAll{}
    err = json.Unmarshal(jsonRecord, &amp;temp)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1237.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1238.1">json.Unmarshal()</span></code><span class="koboSpan" id="kobo.1239.1"> function requires the byte slice with the JSON record and a pointer to the Go structure </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.1240.1">variable that will store the JSON record, returning an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1241.1">error</span></code><span class="koboSpan" id="kobo.1242.1"> variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1243.1">if</span></span><span class="koboSpan" id="kobo.1244.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1245.1">nil</span></span><span class="koboSpan" id="kobo.1246.1"> {
        fmt.Println(err)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1247.1">else</span></span><span class="koboSpan" id="kobo.1248.1"> {
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1249.1">"Data type: %T with value %v\n"</span></span><span class="koboSpan" id="kobo.1250.1">, temp, temp)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1251.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1252.1">encodeDecode.go</span></code><span class="koboSpan" id="kobo.1253.1"> produces</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.1254.1"> the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1255.1">$ </span></span><span class="koboSpan" id="kobo.1256.1">go run encodeDecode.go
Value {"username":"Mike","surname":"Tsoukalos","created":2023}
Data type: main.UseAll with value {M. </span><span class="koboSpan" id="kobo.1256.2">Ts 2024}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1257.1">The next subsection illustrates how to define the JSON tags in a Go structure in more detail.</span></p>
<h2 class="heading-2" id="_idParaDest-194"><span class="koboSpan" id="kobo.1258.1">Structures and JSON</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1259.1">Imagine that you have a Go</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.1260.1"> structure that you want to convert into a JSON record without including any empty fields—the following code illustrates how to perform that task with the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1261.1">omitempty</span></code><span class="koboSpan" id="kobo.1262.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1263.1">// Ignoring empty fields in JSON</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1264.1">type</span></span><span class="koboSpan" id="kobo.1265.1"> NoEmpty </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1266.1">struct</span></span><span class="koboSpan" id="kobo.1267.1"> {
    Name    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1268.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1269.1">`json:"username"`</span></span><span class="koboSpan" id="kobo.1270.1">
    Surname </span><span class="hljs-type"><span class="koboSpan" id="kobo.1271.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1272.1">`json:"surname"`</span></span><span class="koboSpan" id="kobo.1273.1">
    Year    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1274.1">int</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1275.1">`json:"creationyear,omitempty"`</span></span><span class="koboSpan" id="kobo.1276.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1277.1">Now, imagine that you have some sensitive data on some of the fields of a Go structure that you do not want to include in the JSON records. </span><span class="koboSpan" id="kobo.1277.2">You can do that by including the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1278.1">–</span></code><span class="koboSpan" id="kobo.1279.1"> special value in the desired </span><code class="inlineCode"><span class="koboSpan" id="kobo.1280.1">json:</span></code><span class="koboSpan" id="kobo.1281.1"> structure tags. </span><span class="koboSpan" id="kobo.1281.2">This is shown in the following code excerpt:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1282.1">// Removing private fields and ignoring empty fields</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1283.1">type</span></span><span class="koboSpan" id="kobo.1284.1"> Password </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1285.1">struct</span></span><span class="koboSpan" id="kobo.1286.1"> {
    Name     </span><span class="hljs-type"><span class="koboSpan" id="kobo.1287.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1288.1">`json:"username"`</span></span><span class="koboSpan" id="kobo.1289.1">
    Surname  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1290.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1291.1">`json:"surname,omitempty"`</span></span><span class="koboSpan" id="kobo.1292.1">
    Year     </span><span class="hljs-type"><span class="koboSpan" id="kobo.1293.1">int</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1294.1">`json:"creationyear,omitempty"`</span></span><span class="koboSpan" id="kobo.1295.1">
    Pass     </span><span class="hljs-type"><span class="koboSpan" id="kobo.1296.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1297.1">`json:"-"`</span></span><span class="koboSpan" id="kobo.1298.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1299.1">So the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1300.1">Pass</span></code><span class="koboSpan" id="kobo.1301.1"> field is going to be ignored when converting a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1302.1">Password</span></code><span class="koboSpan" id="kobo.1303.1"> structure into a JSON record using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1304.1">json.Marshal()</span></code><span class="koboSpan" id="kobo.1305.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1306.1">These two techniques are</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.1307.1"> illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1308.1">tagsJSON.go</span></code><span class="koboSpan" id="kobo.1309.1">. </span><span class="koboSpan" id="kobo.1309.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1310.1">tagsJSON.go</span></code><span class="koboSpan" id="kobo.1311.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1312.1">$ </span></span><span class="koboSpan" id="kobo.1313.1">go run tagsJSON.go
noEmptyVar decoded with value {username":"Mihalis","surname":""}
password decoded with value {"username":"Mihalis"}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1314.1">For the first line of output, we have the following: the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1315.1">noEmpty</span></code><span class="koboSpan" id="kobo.1316.1">, which is converted into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1317.1">NoEmpty</span></code><span class="koboSpan" id="kobo.1318.1"> structure variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1319.1">noEmptyVar</span></code><span class="koboSpan" id="kobo.1320.1">, is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1321.1">NoEmpty{Name: "Mihalis"}</span></code><span class="koboSpan" id="kobo.1322.1">. </span><span class="koboSpan" id="kobo.1322.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1323.1">noEmpty</span></code><span class="koboSpan" id="kobo.1324.1"> structure has the default values for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1325.1">Surname</span></code><span class="koboSpan" id="kobo.1326.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1327.1">Year</span></code><span class="koboSpan" id="kobo.1328.1"> fields. </span><span class="koboSpan" id="kobo.1328.2">However, as they are not specifically defined, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1329.1">json.Marshal()</span></code><span class="koboSpan" id="kobo.1330.1"> ignores the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1331.1">Year</span></code><span class="koboSpan" id="kobo.1332.1"> field because it has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1333.1">omitempty</span></code><span class="koboSpan" id="kobo.1334.1"> tag but does not ignore the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1335.1">Surname</span></code><span class="koboSpan" id="kobo.1336.1"> field, which has the empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.1337.1">string</span></code><span class="koboSpan" id="kobo.1338.1"> value but not the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1339.1">omitempty</span></code><span class="koboSpan" id="kobo.1340.1"> tag.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1341.1">For the second line of output, the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1342.1">password</span></code><span class="koboSpan" id="kobo.1343.1"> variable is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1344.1">Password{Name: "Mihalis", Pass: "myPassword"}</span></code><span class="koboSpan" id="kobo.1345.1">. </span><span class="koboSpan" id="kobo.1345.2">When the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1346.1">password</span></code><span class="koboSpan" id="kobo.1347.1"> variable is converted into a JSON record, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1348.1">Pass</span></code><span class="koboSpan" id="kobo.1349.1"> field is not included in the output. </span><span class="koboSpan" id="kobo.1349.2">The remaining two fields of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1350.1">Password</span></code><span class="koboSpan" id="kobo.1351.1"> structure, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1352.1">Surname</span></code><span class="koboSpan" id="kobo.1353.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1354.1">Year</span></code><span class="koboSpan" id="kobo.1355.1">, are omitted because of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1356.1">omitempty</span></code><span class="koboSpan" id="kobo.1357.1"> tag. </span><span class="koboSpan" id="kobo.1357.2">So, what is left is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1358.1">username</span></code><span class="koboSpan" id="kobo.1359.1"> field along with its value.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1360.1">So far, we have seen working with single JSON records. </span><span class="koboSpan" id="kobo.1360.2">But what happens when we have multiple records to process? </span><span class="koboSpan" id="kobo.1360.3">Do we have to process them one by one? </span><span class="koboSpan" id="kobo.1360.4">The next subsection answers these questions and many more!</span></p>
<h2 class="heading-2" id="_idParaDest-195"><span class="koboSpan" id="kobo.1361.1">Reading and writing JSON data as streams</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1362.1">Imagine that you have a slice of Go structures that represent JSON records that you want to process. </span><span class="koboSpan" id="kobo.1362.2">Should you</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.1363.1"> process the records one by one? </span><span class="koboSpan" id="kobo.1363.2">It can be done but does it look efficient? </span><span class="koboSpan" id="kobo.1363.3">The good thing is that Go supports the processing of multiple JSON records as streams instead of individual records. </span><span class="koboSpan" id="kobo.1363.4">This subsection teaches how to perform that using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1364.1">JSONstreams.go</span></code><span class="koboSpan" id="kobo.1365.1"> utility, which contains the following two functions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1366.1">// DeSerialize decodes a serialized slice with JSON records</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1367.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1368.1">DeSerialize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1369.1">(e *json.Decoder, slice </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1370.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1371.1">{})</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1372.1">error</span></span><span class="koboSpan" id="kobo.1373.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1374.1">return</span></span><span class="koboSpan" id="kobo.1375.1"> e.Decode(slice)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1376.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1377.1">DeSerialize()</span></code><span class="koboSpan" id="kobo.1378.1"> function is used for reading input in the form of JSON records, decoding it, and putting it into a slice. </span><span class="koboSpan" id="kobo.1378.2">The function writes the slice, which is of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1379.1">interface{}</span></code><span class="koboSpan" id="kobo.1380.1"> data type and is given </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.1381.1">as a parameter, and gets its input from the buffer of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1382.1">*json.Decoder</span></code><span class="koboSpan" id="kobo.1383.1"> parameter. </span><span class="koboSpan" id="kobo.1383.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1384.1">*json.Decoder</span></code><span class="koboSpan" id="kobo.1385.1"> parameter, along with its buffer, is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1386.1">main()</span></code><span class="koboSpan" id="kobo.1387.1"> function in order to avoid allocating it all the time, and therefore, losing the performance gains and efficiency of using this type. </span><span class="koboSpan" id="kobo.1387.2">The same applies to the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1388.1">*json.Encoder</span></code><span class="koboSpan" id="kobo.1389.1"> that follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1390.1">// Serialize serializes a slice with JSON records</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1391.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1392.1">Serialize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1393.1">(e *json.Encoder, slice </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1394.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1395.1">{})</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1396.1">error</span></span><span class="koboSpan" id="kobo.1397.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1398.1">return</span></span><span class="koboSpan" id="kobo.1399.1"> e.Encode(slice)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1400.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1401.1">Serialize()</span></code><span class="koboSpan" id="kobo.1402.1"> function accepts two parameters, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">*json.Encoder</span></code><span class="koboSpan" id="kobo.1404.1"> and a slice of any data type, hence the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1405.1">interface{}</span></code><span class="koboSpan" id="kobo.1406.1">. </span><span class="koboSpan" id="kobo.1406.2">The function processes the slice and writes the output to the buffer of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1407.1">json.Encoder</span></code><span class="koboSpan" id="kobo.1408.1">—this buffer is passed as a parameter to the encoder at the time of its creation.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1409.1">Both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1410.1">Serialize()</span></code><span class="koboSpan" id="kobo.1411.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1412.1">DeSerialize()</span></code><span class="koboSpan" id="kobo.1413.1"> functions can work with any type of JSON record due to the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1414.1">interface{}</span></code><span class="koboSpan" id="kobo.1415.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1416.1">You can replace both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1417.1">Serialize()</span></code><span class="koboSpan" id="kobo.1418.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1419.1">DeSerialize()</span></code><span class="koboSpan" id="kobo.1420.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1421.1">err := json.NewEncoder(buf).Encode(DataRecords)</span></code><span class="koboSpan" id="kobo.1422.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1423.1">err := json.NewEncoder(buf).Encode(DataRecords)</span></code><span class="koboSpan" id="kobo.1424.1"> calls, respectively. </span><span class="koboSpan" id="kobo.1424.2">Personally, I prefer using separate functions, but your taste might differ.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1425.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1426.1">JSONstreams.go</span></code><span class="koboSpan" id="kobo.1427.1"> utility generates random data. </span><span class="koboSpan" id="kobo.1427.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1428.1">JSONstreams.go</span></code><span class="koboSpan" id="kobo.1429.1"> creates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1430.1">$ </span></span><span class="koboSpan" id="kobo.1431.1">go run JSONstreams.go
After Serialize:[{"key":"RESZD","value":63},{"key":"XUEYA","value":13}]
After DeSerialize:
0 {RESZD 63}
1 {XUEYA 13}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1432.1">The input slice of structures, which is generated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1433.1">main()</span></code><span class="koboSpan" id="kobo.1434.1">, is serialized, as seen in the first line of the output. </span><span class="koboSpan" id="kobo.1434.2">After</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.1435.1"> that, it is deserialized into the original slice of structures.</span></p>
<h2 class="heading-2" id="_idParaDest-196"><span class="koboSpan" id="kobo.1436.1">Pretty printing JSON records</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1437.1">This subsection illustrates how to pretty print JSON records, which means printing JSON records in a pleasant and readable </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.1438.1">format without knowing the internals of the Go structure that holds the JSON records. </span><span class="koboSpan" id="kobo.1438.2">As there exist two ways to read JSON records, individually and as a stream, there exist two ways to pretty print JSON data: as single JSON records and as a stream. </span><span class="koboSpan" id="kobo.1438.3">Therefore, we are going to implement two separate functions named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1439.1">prettyPrint()</span></code><span class="koboSpan" id="kobo.1440.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1441.1">JSONstream()</span></code><span class="koboSpan" id="kobo.1442.1">, respectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1443.1">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1444.1">prettyPrint()</span></code><span class="koboSpan" id="kobo.1445.1"> function is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1446.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1447.1">PrettyPrint</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1448.1">(v </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1449.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1450.1">{})</span></span><span class="koboSpan" id="kobo.1451.1"> (err </span><span class="hljs-type"><span class="koboSpan" id="kobo.1452.1">error</span></span><span class="koboSpan" id="kobo.1453.1">) {
    b, err := json.MarshalIndent(v, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1454.1">""</span></span><span class="koboSpan" id="kobo.1455.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1456.1">"\t"</span></span><span class="koboSpan" id="kobo.1457.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1458.1">if</span></span><span class="koboSpan" id="kobo.1459.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1460.1">nil</span></span><span class="koboSpan" id="kobo.1461.1"> {
        fmt.Println(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1462.1">string</span></span><span class="koboSpan" id="kobo.1463.1">(b))
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1464.1">return</span></span><span class="koboSpan" id="kobo.1465.1"> err
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1466.1">All the work is done by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1467.1">json.MarshalIndent()</span></code><span class="koboSpan" id="kobo.1468.1">, which applies indentation to format the output.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1469.1">Although both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1470.1">json.MarshalIndent()</span></code><span class="koboSpan" id="kobo.1471.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1472.1">json.Marshal()</span></code><span class="koboSpan" id="kobo.1473.1"> produce a JSON text result (byte slice), only </span><code class="inlineCode"><span class="koboSpan" id="kobo.1474.1">json.MarshalIndent()</span></code><span class="koboSpan" id="kobo.1475.1"> allows applying customizable indentation, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.1476.1">json.Marshal()</span></code><span class="koboSpan" id="kobo.1477.1"> generates a more compact output.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1478.1">For pretty printing streams of JSON data, you should use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1479.1">JSONstream()</span></code><span class="koboSpan" id="kobo.1480.1"> function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1481.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1482.1">JSONstream</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1483.1">(data </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1484.1">interface</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1485.1">{})</span></span><span class="koboSpan" id="kobo.1486.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.1487.1">string</span></span><span class="koboSpan" id="kobo.1488.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1489.1">error</span></span><span class="koboSpan" id="kobo.1490.1">) {
  buffer := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1491.1">new</span></span><span class="koboSpan" id="kobo.1492.1">(bytes.Buffer)
  encoder := json.NewEncoder(buffer)
  encoder.SetIndent(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1493.1">""</span></span><span class="koboSpan" id="kobo.1494.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1495.1">"\t"</span></span><span class="koboSpan" id="kobo.1496.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1497.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1498.1">json.NewEncoder()</span></code><span class="koboSpan" id="kobo.1499.1"> function returns a new encoder that writes to a writer that is passed as a parameter to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1500.1">json.NewEncoder()</span></code><span class="koboSpan" id="kobo.1501.1">. </span><span class="koboSpan" id="kobo.1501.2">An encoder writes JSON values to an output stream. </span><span class="koboSpan" id="kobo.1501.3">Similarly to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1502.1">json.MarshalIndent()</span></code><span class="koboSpan" id="kobo.1503.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1504.1">SetIndent()</span></code><span class="koboSpan" id="kobo.1505.1"> method allows you to apply a customizable indent to a stream.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1506.1">  err := encoder.Encode(data)
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1507.1">if</span></span><span class="koboSpan" id="kobo.1508.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1509.1">nil</span></span><span class="koboSpan" id="kobo.1510.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1511.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1512.1">""</span></span><span class="koboSpan" id="kobo.1513.1">, err
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1514.1">return</span></span><span class="koboSpan" id="kobo.1515.1"> buffer.String(), </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1516.1">nil</span></span><span class="koboSpan" id="kobo.1517.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1518.1">After we are done configuring</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.1519.1"> the encoder, we are free to process the JSON stream using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1520.1">Encode()</span></code><span class="koboSpan" id="kobo.1521.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1522.1">These two functions are illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1523.1">prettyPrint.go</span></code><span class="koboSpan" id="kobo.1524.1">, which generates JSON records using random data. </span><span class="koboSpan" id="kobo.1524.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1525.1">prettyPrint.go</span></code><span class="koboSpan" id="kobo.1526.1"> produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1527.1">Last record: {YJOML 63}
{
    "key": "YJOML",
    "value": 63
}
[
    {
        "key": "HXNIG",
        "value": 79
    },
    {
        "key": "YJOML",
        "value": 63
    }
]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1528.1">The previous output shows the beautified output of a single JSON record followed by the beautified output of a slice with two JSON records—all JSON records are represented as Go structures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1529.1">And now, we are going to deal with something completely different, which is the development of a powerful command line utility—Go is really good at it.</span></p>
<h1 class="heading-1" id="_idParaDest-197"><span class="koboSpan" id="kobo.1530.1">The viper package</span></h1>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.1531.1">Flags</span></em><span class="koboSpan" id="kobo.1532.1"> are specially formatted strings that are passed into a program to control its behavior. </span><span class="koboSpan" id="kobo.1532.2">Dealing with flags on your </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.1533.1">own might become very frustrating if you want to support multiple flags and options. </span><span class="koboSpan" id="kobo.1533.2">Go offers the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1534.1">flag</span></code><span class="koboSpan" id="kobo.1535.1"> package to work with command line options, parameters, and flags. </span><span class="koboSpan" id="kobo.1535.2">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.1536.1">flag</span></code><span class="koboSpan" id="kobo.1537.1"> can do many things, it is not as capable as other external Go packages. </span><span class="koboSpan" id="kobo.1537.2">Thus, if you are developing simple UNIX system command line utilities, you might find the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1538.1">flag</span></code><span class="koboSpan" id="kobo.1539.1"> package very interesting and useful. </span><span class="koboSpan" id="kobo.1539.2">But you are not reading this book to create simple command line utilities! </span><span class="koboSpan" id="kobo.1539.3">Therefore, I am going to skip the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1540.1">flag</span></code><span class="koboSpan" id="kobo.1541.1"> package and introduce you to an external package named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1542.1">viper</span></code><span class="koboSpan" id="kobo.1543.1">, which is a powerful Go package that supports a plethora of options. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1544.1">viper</span></code><span class="koboSpan" id="kobo.1545.1"> uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1546.1">pflag</span></code><span class="koboSpan" id="kobo.1547.1"> package instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1548.1">flag</span></code><span class="koboSpan" id="kobo.1549.1">, which is also illustrated in the code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1550.1">All </span><code class="inlineCode"><span class="koboSpan" id="kobo.1551.1">viper</span></code><span class="koboSpan" id="kobo.1552.1"> projects follow a pattern. </span><span class="koboSpan" id="kobo.1552.2">First, you initialize </span><code class="inlineCode"><span class="koboSpan" id="kobo.1553.1">viper</span></code><span class="koboSpan" id="kobo.1554.1"> and then you define the elements that interest you. </span><span class="koboSpan" id="kobo.1554.2">After that, you get these elements and read their values in order to use them. </span><span class="koboSpan" id="kobo.1554.3">The desired values can be taken either directly, which happens when you use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1555.1">flag</span></code><span class="koboSpan" id="kobo.1556.1"> package from the standard Go library, or indirectly using configuration files. </span><span class="koboSpan" id="kobo.1556.2">When using formatted configuration files in the JSON, YAML, TOML, HCL, or Java properties format, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1557.1">viper</span></code><span class="koboSpan" id="kobo.1558.1"> does all the parsing for you, which saves you from having to write and debug lots of Go code. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1559.1">viper</span></code><span class="koboSpan" id="kobo.1560.1"> also allows you to extract and save values in Go structures. </span><span class="koboSpan" id="kobo.1560.2">However, this requires that the fields of the Go structure match the keys of the configuration file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1561.1">The home page of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1562.1">viper</span></code><span class="koboSpan" id="kobo.1563.1"> is on GitHub (</span><a href="https://github.com/spf13/viper"><span class="url"><span class="koboSpan" id="kobo.1564.1">https://github.com/spf13/viper</span></span></a><span class="koboSpan" id="kobo.1565.1">). </span><span class="koboSpan" id="kobo.1565.2">Please note that you are not obliged to use every capability of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1566.1">viper</span></code><span class="koboSpan" id="kobo.1567.1"> in your tools, just the features that you want. </span><span class="koboSpan" id="kobo.1567.2">However, if your command line utility requires too many command line parameters and flags, then it would be better to use a configuration file instead.</span></p>
<h2 class="heading-2" id="_idParaDest-198"><span class="koboSpan" id="kobo.1568.1">Using command line flags</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1569.1">The first example shows how to </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.1570.1">write a simple utility that accepts two values as command line parameters and prints them on screen for verification. </span><span class="koboSpan" id="kobo.1570.2">This means that we are going to need two command line flags for these two parameters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1571.1">The relevant code is in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1572.1">~/go/src/github.com/mactsouk/mGo4th/ch07/useViper</span></code><span class="koboSpan" id="kobo.1573.1">. </span><span class="koboSpan" id="kobo.1573.2">You should replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.1574.1">mGo4th</span></code><span class="koboSpan" id="kobo.1575.1"> with the name of the actual GitHub repository of the book, or rename it </span><code class="inlineCode"><span class="koboSpan" id="kobo.1576.1">mGo4th</span></code><span class="koboSpan" id="kobo.1577.1">. </span><span class="koboSpan" id="kobo.1577.2">Generally speaking, short directory names are more convenient.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1578.1">After that, you must go to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1579.1">~/go/src/github.com/mactsouk/mGo4th/ch07/useViper</span></code><span class="koboSpan" id="kobo.1580.1"> directory and run the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1581.1">$ </span></span><span class="koboSpan" id="kobo.1582.1">go mod init
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1583.1">$ </span></span><span class="koboSpan" id="kobo.1584.1">go mod tidy
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1585.1">Keep in mind that the previous two commands should be executed when </span><code class="inlineCode"><span class="koboSpan" id="kobo.1586.1">useViper.go</span></code><span class="koboSpan" id="kobo.1587.1"> is ready and include all the required external packages. </span><span class="koboSpan" id="kobo.1587.2">The GitHub repository of the book contains the final versions of all programs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1588.1">The implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1589.1">useViper.go</span></code><span class="koboSpan" id="kobo.1590.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1591.1">package</span></span><span class="koboSpan" id="kobo.1592.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1593.1">import</span></span><span class="koboSpan" id="kobo.1594.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1595.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1596.1">"github.com/spf13/pflag"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1597.1">"github.com/spf13/viper"</span></span><span class="koboSpan" id="kobo.1598.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1599.1">We need to import both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1600.1">pflag</span></code><span class="koboSpan" id="kobo.1601.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1602.1">viper</span></code><span class="koboSpan" id="kobo.1603.1"> packages, as we are going to use their functionality.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1604.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1605.1">aliasNormalizeFunc</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1606.1">(f *pflag.FlagSet, n </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1607.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1608.1">)</span></span><span class="koboSpan" id="kobo.1609.1"> pflag.NormalizedName {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1610.1">switch</span></span><span class="koboSpan" id="kobo.1611.1"> n {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1612.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1613.1">"pass"</span></span><span class="koboSpan" id="kobo.1614.1">:
        n = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1615.1">"password"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1616.1">break</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1617.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1618.1">"ps"</span></span><span class="koboSpan" id="kobo.1619.1">:
        n = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1620.1">"password"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1621.1">break</span></span><span class="koboSpan" id="kobo.1622.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1623.1">return</span></span><span class="koboSpan" id="kobo.1624.1"> pflag.NormalizedName(n)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1625.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1626.1">aliasNormalizeFunc()</span></code><span class="koboSpan" id="kobo.1627.1"> function is used to create additional aliases for a flag, in this case, an alias for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1628.1">--password</span></code><span class="koboSpan" id="kobo.1629.1"> flag. </span><span class="koboSpan" id="kobo.1629.2">According to</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.1630.1"> the existing code, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1631.1">--password</span></code><span class="koboSpan" id="kobo.1632.1"> flag can be accessed as either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1633.1">--pass</span></code><span class="koboSpan" id="kobo.1634.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1635.1">–ps</span></code><span class="koboSpan" id="kobo.1636.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1637.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1638.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1639.1">()</span></span><span class="koboSpan" id="kobo.1640.1"> {
    pflag.StringP(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1641.1">"name"</span></span><span class="koboSpan" id="kobo.1642.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1643.1">"n"</span></span><span class="koboSpan" id="kobo.1644.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1645.1">"Mike"</span></span><span class="koboSpan" id="kobo.1646.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1647.1">"Name parameter"</span></span><span class="koboSpan" id="kobo.1648.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1649.1">In the preceding code, we create a new flag called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1650.1">name</span></code><span class="koboSpan" id="kobo.1651.1"> that can also be accessed as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1652.1">-n</span></code><span class="koboSpan" id="kobo.1653.1">. </span><span class="koboSpan" id="kobo.1653.2">Its default value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1654.1">Mike</span></code><span class="koboSpan" id="kobo.1655.1">, and its description, which appears in the usage of the utility, is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1656.1">Name parameter</span></code><span class="koboSpan" id="kobo.1657.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1658.1">    pflag.StringP(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1659.1">"password"</span></span><span class="koboSpan" id="kobo.1660.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1661.1">"p"</span></span><span class="koboSpan" id="kobo.1662.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1663.1">"hardToGuess"</span></span><span class="koboSpan" id="kobo.1664.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1665.1">"Password"</span></span><span class="koboSpan" id="kobo.1666.1">)
    pflag.CommandLine.SetNormalizeFunc(aliasNormalizeFunc)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1667.1">We create another flag named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1668.1">password</span></code><span class="koboSpan" id="kobo.1669.1"> that can also be accessed as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1670.1">-p</span></code><span class="koboSpan" id="kobo.1671.1"> and has a default value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1672.1">hardToGuess</span></code><span class="koboSpan" id="kobo.1673.1"> and a description. </span><span class="koboSpan" id="kobo.1673.2">Additionally, we register a normalization function to generate aliases for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1674.1">password</span></code><span class="koboSpan" id="kobo.1675.1"> flag.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1676.1">    pflag.Parse()
    viper.BindPFlags(pflag.CommandLine)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1677.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1678.1">pflag.Parse()</span></code><span class="koboSpan" id="kobo.1679.1"> call should be used after all command line flags are defined. </span><span class="koboSpan" id="kobo.1679.2">Its purpose is to parse the command line flags into the predefined flags.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1680.1">Additionally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1681.1">viper.BindPFlags()</span></code><span class="koboSpan" id="kobo.1682.1"> call makes all flags available to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1683.1">viper</span></code><span class="koboSpan" id="kobo.1684.1"> package. </span><span class="koboSpan" id="kobo.1684.2">Strictly speaking, we say that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1685.1">viper.BindPFlags()</span></code><span class="koboSpan" id="kobo.1686.1"> call binds an existing set of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1687.1">pflag</span></code><span class="koboSpan" id="kobo.1688.1"> flags (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1689.1">pflag.FlagSet</span></code><span class="koboSpan" id="kobo.1690.1">) to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1691.1">viper</span></code><span class="koboSpan" id="kobo.1692.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1693.1">    name := viper.GetString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1694.1">"name"</span></span><span class="koboSpan" id="kobo.1695.1">)
    password := viper.GetString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1696.1">"password"</span></span><span class="koboSpan" id="kobo.1697.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1698.1">The previous commands show that you can read the values of two </span><code class="inlineCode"><span class="koboSpan" id="kobo.1699.1">string</span></code><span class="koboSpan" id="kobo.1700.1"> command line flags using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1701.1">viper.GetString()</span></code><span class="koboSpan" id="kobo.1702.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1703.1">    fmt.Println(name, password)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1704.1">// Reading an Environment variable</span></span><span class="koboSpan" id="kobo.1705.1">
    viper.BindEnv(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1706.1">"GOMAXPROCS"</span></span><span class="koboSpan" id="kobo.1707.1">)
    val := viper.Get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1708.1">"GOMAXPROCS"</span></span><span class="koboSpan" id="kobo.1709.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1710.1">if</span></span><span class="koboSpan" id="kobo.1711.1"> val != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1712.1">nil</span></span><span class="koboSpan" id="kobo.1713.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1714.1">"GOMAXPROCS:"</span></span><span class="koboSpan" id="kobo.1715.1">, val)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1716.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1717.1">viper</span></code><span class="koboSpan" id="kobo.1718.1"> package can also work with environment variables. </span><span class="koboSpan" id="kobo.1718.2">We first need to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1719.1">viper.BindEnv()</span></code><span class="koboSpan" id="kobo.1720.1"> to tell </span><code class="inlineCode"><span class="koboSpan" id="kobo.1721.1">viper</span></code><span class="koboSpan" id="kobo.1722.1"> which </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.1723.1">environment variable interests us, and then we can read its value by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.1724.1">viper.Get()</span></code><span class="koboSpan" id="kobo.1725.1">. </span><span class="koboSpan" id="kobo.1725.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.1726.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.1727.1"> is not already set, which means that its value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1728.1">nil</span></code><span class="koboSpan" id="kobo.1729.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1730.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.1731.1"> call will not get executed.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.1732.1">// Setting an Environment variable</span></span><span class="koboSpan" id="kobo.1733.1">
    viper.Set(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1734.1">"GOMAXPROCS"</span></span><span class="koboSpan" id="kobo.1735.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1736.1">16</span></span><span class="koboSpan" id="kobo.1737.1">)
    val = viper.Get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1738.1">"GOMAXPROCS"</span></span><span class="koboSpan" id="kobo.1739.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1740.1">"GOMAXPROCS:"</span></span><span class="koboSpan" id="kobo.1741.1">, val)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1742.1">Similarly, we can change the </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.1743.1">value of an environment variable with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1744.1">viper.Set()</span></code><span class="koboSpan" id="kobo.1745.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1746.1">The good thing is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1747.1">viper</span></code><span class="koboSpan" id="kobo.1748.1"> automatically provides usage information:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1749.1">$ </span></span><span class="koboSpan" id="kobo.1750.1">go build useViper.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1751.1">$ </span></span><span class="koboSpan" id="kobo.1752.1">./useViper.go --</span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1753.1">help</span></span><span class="koboSpan" id="kobo.1754.1">
Usage of ./useViper:
  -n, --name string       Name parameter (default "Mike")
  -p, --password string   Password (default "hardToGuess")
pflag: help requested
exit status 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1755.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1756.1">useViper.go</span></code><span class="koboSpan" id="kobo.1757.1"> without any command line arguments produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1758.1">$ </span></span><span class="koboSpan" id="kobo.1759.1">go run useViper.go
Mike hardToGuess
GOMAXPROCS: 16
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1760.1">However, if we provide values for the command line flags, the output is going to be slightly different.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1761.1">$ </span></span><span class="koboSpan" id="kobo.1762.1">go run useViper.go -n mtsouk -p d1ff1cultPAssw0rd
mtsouk d1ff1cultPAssw0rd
GOMAXPROCS: 16
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1763.1">In this second case, we used the shortcuts for the command line flags because it is faster to do so.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1764.1">The next subsection discusses the use of JSON files to store configuration information in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1765.1">viper</span></code><span class="koboSpan" id="kobo.1766.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-199"><span class="koboSpan" id="kobo.1767.1">Reading JSON configuration files</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1768.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1769.1">viper</span></code><span class="koboSpan" id="kobo.1770.1"> package can read JSON files to get its configuration, and this subsection illustrates how. </span><span class="koboSpan" id="kobo.1770.2">Using text files to</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.1771.1"> store configuration details can be very helpful when writing complex applications that require lots of data and setup. </span><span class="koboSpan" id="kobo.1771.2">This is illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1772.1">jsonViper.go</span></code><span class="koboSpan" id="kobo.1773.1">. </span><span class="koboSpan" id="kobo.1773.2">Once again, we need to have </span><code class="inlineCode"><span class="koboSpan" id="kobo.1774.1">jsonViper.go</span></code><span class="koboSpan" id="kobo.1775.1"> inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.1776.1">~/go/src</span></code><span class="koboSpan" id="kobo.1777.1"> as we did before: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1778.1">~/go/src/github.com/mactsouk/mGo4th/ch07/jsonViper</span></code><span class="koboSpan" id="kobo.1779.1">. </span><span class="koboSpan" id="kobo.1779.2">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1780.1">jsonViper.go</span></code><span class="koboSpan" id="kobo.1781.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1782.1">package</span></span><span class="koboSpan" id="kobo.1783.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1784.1">import</span></span><span class="koboSpan" id="kobo.1785.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1786.1">"encoding/json"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1787.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1788.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1789.1">"github.com/spf13/viper"</span></span><span class="koboSpan" id="kobo.1790.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1791.1">type</span></span><span class="koboSpan" id="kobo.1792.1"> ConfigStructure </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1793.1">struct</span></span><span class="koboSpan" id="kobo.1794.1"> {
    MacPass     </span><span class="hljs-type"><span class="koboSpan" id="kobo.1795.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1796.1">`mapstructure:"macos"`</span></span><span class="koboSpan" id="kobo.1797.1">
    LinuxPass   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1798.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1799.1">`mapstructure:"linux"`</span></span><span class="koboSpan" id="kobo.1800.1">
    WindowsPass </span><span class="hljs-type"><span class="koboSpan" id="kobo.1801.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1802.1">`mapstructure:"windows"`</span></span><span class="koboSpan" id="kobo.1803.1">
    PostHost    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1804.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1805.1">`mapstructure:"postgres"`</span></span><span class="koboSpan" id="kobo.1806.1">
    MySQLHost   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1807.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1808.1">`mapstructure:"mysql"`</span></span><span class="koboSpan" id="kobo.1809.1">
    MongoHost   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1810.1">string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1811.1">`mapstructure:"mongodb"`</span></span><span class="koboSpan" id="kobo.1812.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1813.1">There is an important point here: although we are using a JSON file to store the configuration, the Go structure uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.1814.1">mapstructure</span></code><span class="koboSpan" id="kobo.1815.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1816.1">json</span></code><span class="koboSpan" id="kobo.1817.1"> for the fields of the JSON configuration file.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1818.1">var</span></span> <span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.1819.1">CONFIG</span></strong></span><span class="koboSpan" id="kobo.1820.1"> = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1821.1">".config.json"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1822.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1823.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1824.1">()</span></span><span class="koboSpan" id="kobo.1825.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1826.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1827.1">len</span></span><span class="koboSpan" id="kobo.1828.1">(os.Args) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1829.1">1</span></span><span class="koboSpan" id="kobo.1830.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1831.1">"Using default file"</span></span><span class="koboSpan" id="kobo.1832.1">, CONFIG)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1833.1">else</span></span><span class="koboSpan" id="kobo.1834.1"> {
        CONFIG = os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1835.1">1</span></span><span class="koboSpan" id="kobo.1836.1">]
    }
    viper.SetConfigType(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1837.1">"json"</span></span><span class="koboSpan" id="kobo.1838.1">)
    viper.SetConfigFile(CONFIG)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1839.1">"Using config: %s\n"</span></span><span class="koboSpan" id="kobo.1840.1">, viper.ConfigFileUsed())
    viper.ReadInConfig()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1841.1">The previous four statements declare that we are using a JSON file, let </span><code class="inlineCode"><span class="koboSpan" id="kobo.1842.1">viper</span></code><span class="koboSpan" id="kobo.1843.1"> know the path to the default configuration file, print the configuration file used, and read and parse that configuration file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1844.1">Keep in mind that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1845.1">viper</span></code><span class="koboSpan" id="kobo.1846.1"> does not check whether the configuration file actually exists and is readable. </span><span class="koboSpan" id="kobo.1846.2">If the file cannot</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.1847.1"> be found or read, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1848.1">viper.ReadInConfig()</span></code><span class="koboSpan" id="kobo.1849.1"> acts like it is processing an empty configuration file.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1850.1">if</span></span><span class="koboSpan" id="kobo.1851.1"> viper.IsSet(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1852.1">"macos"</span></span><span class="koboSpan" id="kobo.1853.1">) {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1854.1">"macos:"</span></span><span class="koboSpan" id="kobo.1855.1">, viper.Get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1856.1">"macos"</span></span><span class="koboSpan" id="kobo.1857.1">))
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1858.1">else</span></span><span class="koboSpan" id="kobo.1859.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1860.1">"macos not set!"</span></span><span class="koboSpan" id="kobo.1861.1">)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1862.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1863.1">viper.IsSet()</span></code><span class="koboSpan" id="kobo.1864.1"> call checks whether a key named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1865.1">macos</span></code><span class="koboSpan" id="kobo.1866.1"> can be found in the configuration. </span><span class="koboSpan" id="kobo.1866.2">If it is set, it</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.1867.1"> reads its value using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1868.1">viper.Get("macos")</span></code><span class="koboSpan" id="kobo.1869.1"> and prints it on screen.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1870.1">if</span></span><span class="koboSpan" id="kobo.1871.1"> viper.IsSet(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1872.1">"active"</span></span><span class="koboSpan" id="kobo.1873.1">) {
        value := viper.GetBool(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1874.1">"active"</span></span><span class="koboSpan" id="kobo.1875.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1876.1">if</span></span><span class="koboSpan" id="kobo.1877.1"> value {
            postgres := viper.Get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1878.1">"postgres"</span></span><span class="koboSpan" id="kobo.1879.1">)
            mysql := viper.Get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1880.1">"mysql"</span></span><span class="koboSpan" id="kobo.1881.1">)
            mongo := viper.Get(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1882.1">"mongodb"</span></span><span class="koboSpan" id="kobo.1883.1">)
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1884.1">"P:"</span></span><span class="koboSpan" id="kobo.1885.1">, postgres, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1886.1">"My:"</span></span><span class="koboSpan" id="kobo.1887.1">, mysql, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1888.1">"Mo:"</span></span><span class="koboSpan" id="kobo.1889.1">, mongo)
        }
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1890.1">else</span></span><span class="koboSpan" id="kobo.1891.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1892.1">"active is not set!"</span></span><span class="koboSpan" id="kobo.1893.1">)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1894.1">In the aforementioned code, we check whether the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1895.1">active</span></code><span class="koboSpan" id="kobo.1896.1"> key can be found before reading its value. </span><span class="koboSpan" id="kobo.1896.2">If its value is equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1897.1">true</span></code><span class="koboSpan" id="kobo.1898.1">, then we read the values from three more keys, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1899.1">postgres</span></code><span class="koboSpan" id="kobo.1900.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1901.1">mysql</span></code><span class="koboSpan" id="kobo.1902.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1903.1">mongodb</span></code><span class="koboSpan" id="kobo.1904.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1905.1">As the active key should hold a Boolean value, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1906.1">viper.GetBool()</span></code><span class="koboSpan" id="kobo.1907.1"> to read it.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1908.1">if</span></span><span class="koboSpan" id="kobo.1909.1"> !viper.IsSet(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1910.1">"DoesNotExist"</span></span><span class="koboSpan" id="kobo.1911.1">) {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1912.1">"DoesNotExist is not set!"</span></span><span class="koboSpan" id="kobo.1913.1">)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1914.1">As expected, trying to read a key that does not exist fails.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1915.1">var</span></span><span class="koboSpan" id="kobo.1916.1"> t ConfigStructure
    err := viper.Unmarshal(&amp;t)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1917.1">if</span></span><span class="koboSpan" id="kobo.1918.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1919.1">nil</span></span><span class="koboSpan" id="kobo.1920.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1921.1">return</span></span><span class="koboSpan" id="kobo.1922.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1923.1">The call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1924.1">viper.Unmarshal()</span></code><span class="koboSpan" id="kobo.1925.1"> allows you to put the information from the JSON configuration file into a properly </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.1926.1">defined Go structure—this is optional but handy.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1927.1">    PrettyPrint(t)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1928.1">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1929.1">PrettyPrint()</span></code><span class="koboSpan" id="kobo.1930.1"> function was presented in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1931.1">prettyPrint.go</span></code><span class="koboSpan" id="kobo.1932.1"> earlier on in this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1933.1">Now, you need to download the dependencies of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1934.1">jsonViper.go</span></code><span class="koboSpan" id="kobo.1935.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1936.1">$ </span></span><span class="koboSpan" id="kobo.1937.1">go mod init
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1938.1">$ </span></span><span class="koboSpan" id="kobo.1939.1">go mod tidy
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1940.1">The contents of the current directory are as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1941.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1942.1">ls</span></span><span class="koboSpan" id="kobo.1943.1"> -l
total 120
-rw-r--r--@ 1 mtsouk  staff    745 Aug 21 18:21 go.mod
-rw-r--r--@ 1 mtsouk  staff  48357 Aug 21 18:21 go.sum
-rw-r--r--@ 1 mtsouk  staff   1418 Aug  3 07:51 jsonViper.go
-rw-r--r--@ 1 mtsouk  staff    188 Aug 21 18:20 myConfig.json
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1944.1">The contents of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1945.1">myConfig.json</span></code><span class="koboSpan" id="kobo.1946.1"> file used for testing are as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1947.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1948.1">"macos"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1949.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1950.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1951.1">pass_macos"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1952.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1953.1">"linux"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1954.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1955.1">"pass_linux"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1956.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1957.1">"windows"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1958.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1959.1">"pass_windows"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1960.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1961.1">"active"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1962.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1963.1">true</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1964.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1965.1">"postgres"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1966.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1967.1">"machine1"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1968.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1969.1">"mysql"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1970.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1971.1">"machine2"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1972.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1973.1">"mongodb"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.1974.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1975.1">"machine3"</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.1976.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1977.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1978.1">jsonViper.go</span></code><span class="koboSpan" id="kobo.1979.1"> on the preceding JSON file produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1980.1">$ </span></span><span class="koboSpan" id="kobo.1981.1">go run jsonViper.go myConfig.json
Using config: myConfig.json
macos: pass_macos
P: machine1 My: machine2 Mo: machine3
DoesNotExist is not set!
</span><span class="koboSpan" id="kobo.1981.2">{
  "MacPass": "pass_macos",
  "LinuxPass": "pass_linux",
  "WindowsPass": "pass_windows",
  "PostHost": "machine1",
  "MySQLHost": "machine2",
  "MongoHost": "machine3"
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1982.1">The previous output is generated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1983.1">jsonViper.go</span></code><span class="koboSpan" id="kobo.1984.1"> when parsing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1985.1">myConfig.json</span></code><span class="koboSpan" id="kobo.1986.1"> and trying to find the desired information.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1987.1">The next section discusses a </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.1988.1">Go package for creating powerful and professional command line utilities, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1989.1">docker</span></code><span class="koboSpan" id="kobo.1990.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1991.1">kubectl</span></code><span class="koboSpan" id="kobo.1992.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-200"><span class="koboSpan" id="kobo.1993.1">The cobra package</span></h1>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1994.1">cobra</span></code><span class="koboSpan" id="kobo.1995.1"> is a very handy and popular Go </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.1996.1">package that allows you to develop command line utilities with commands, subcommands, and aliases. </span><span class="koboSpan" id="kobo.1996.2">If you have ever used </span><code class="inlineCode"><span class="koboSpan" id="kobo.1997.1">hugo</span></code><span class="koboSpan" id="kobo.1998.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1999.1">docker</span></code><span class="koboSpan" id="kobo.2000.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2001.1">kubectl</span></code><span class="koboSpan" id="kobo.2002.1">, you are going to realize immediately what the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2003.1">cobra</span></code><span class="koboSpan" id="kobo.2004.1"> package does, as all these tools are developed using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2005.1">cobra</span></code><span class="koboSpan" id="kobo.2006.1">. </span><span class="koboSpan" id="kobo.2006.2">Commands can have one or more aliases, which is very handy when you want to please both amateur and experienced users. </span><code class="inlineCode"><span class="koboSpan" id="kobo.2007.1">cobra</span></code><span class="koboSpan" id="kobo.2008.1"> also supports persistent flags and local flags, which are flags that are available to all commands and flags that are available to given commands only, respectively. </span><span class="koboSpan" id="kobo.2008.2">Also, by default, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2009.1">cobra</span></code><span class="koboSpan" id="kobo.2010.1"> uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.2011.1">viper</span></code><span class="koboSpan" id="kobo.2012.1"> for parsing its command line arguments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2013.1">All Cobra projects follow the same development pattern. </span><span class="koboSpan" id="kobo.2013.2">You use the Cobra command line utility, you create commands, and then you make the desired changes to the generated Go source code files in order to implement the desired functionality. </span><span class="koboSpan" id="kobo.2013.3">Depending on the complexity of your utility, you might need to make lots of changes to the created files. </span><span class="koboSpan" id="kobo.2013.4">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.2014.1">cobra</span></code><span class="koboSpan" id="kobo.2015.1"> saves you lots of time, you still have to write the code that implements the desired functionality for each command.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2016.1">You need to take some extra steps in order to download the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2017.1">cobra</span></code><span class="koboSpan" id="kobo.2018.1"> binary the right way:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2019.1">$ </span></span><span class="koboSpan" id="kobo.2020.1">GO111MODULE=on go install github.com/spf13/cobra-cli@latest
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2021.1">The previous command downloads the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2022.1">cobra-cli</span></code><span class="koboSpan" id="kobo.2023.1"> binary—this is the new name for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2024.1">cobra</span></code><span class="koboSpan" id="kobo.2025.1"> binary executable. </span><span class="koboSpan" id="kobo.2025.2">It is not necessary to know about all of the supported environment variables such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2026.1">GO111MODULE</span></code><span class="koboSpan" id="kobo.2027.1"> but, sometimes, they can help you resolve tricky problems with your Go </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.2028.1">installation. </span><span class="koboSpan" id="kobo.2028.2">So if you want to learn about your current Go environment, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2029.1">go env</span></code><span class="koboSpan" id="kobo.2030.1"> command.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2031.1">As I prefer to work using shorter utility names, I renamed </span><code class="inlineCode"><span class="koboSpan" id="kobo.2032.1">cobra-cli</span></code><span class="koboSpan" id="kobo.2033.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2034.1">cobra</span></code><span class="koboSpan" id="kobo.2035.1">. </span><span class="koboSpan" id="kobo.2035.2">If you do not know how to do that or if you prefer to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2036.1">cobra-cli</span></code><span class="koboSpan" id="kobo.2037.1">, replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.2038.1">~/go/bin/cobra</span></code><span class="koboSpan" id="kobo.2039.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2040.1">~/go/bin/cobra-cli</span></code><span class="koboSpan" id="kobo.2041.1"> in all commands.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2042.1">For the purposes of this section, we are going to need a separate directory under </span><code class="inlineCode"><span class="koboSpan" id="kobo.2043.1">ch07</span></code><span class="koboSpan" id="kobo.2044.1">. </span><span class="koboSpan" id="kobo.2044.2">As mentioned multiple times in this book, everything is going to be much easier if you put your code somewhere inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.2045.1">~/go/src</span></code><span class="koboSpan" id="kobo.2046.1">; the exact place depends on you, but it would be ideal if you use something like </span><code class="inlineCode"><span class="koboSpan" id="kobo.2047.1">~/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra</span></code><span class="koboSpan" id="kobo.2048.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2049.1">mGo4th</span></code><span class="koboSpan" id="kobo.2050.1"> is the name of the directory in which you keep the source code files from this book. </span><span class="koboSpan" id="kobo.2050.2">Provided that you are going to use the aforementioned directory, you are going to need to execute the next commands (</span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2051.1">if you have downloaded the source code of the book, you do not need to do anything, as everything is going to be there</span></strong><span class="koboSpan" id="kobo.2052.1">):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2053.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2054.1">cd</span></span><span class="koboSpan" id="kobo.2055.1"> ~/go/src/github.com/mactsouk/mGo4th/ch07/
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2056.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2057.1">mkdir</span></span><span class="koboSpan" id="kobo.2058.1"> go-cobra </span><span class="hljs-con-comment"><span class="koboSpan" id="kobo.2059.1"># only required if the directory is not there</span></span>
<span class="hljs-con-meta"><span class="koboSpan" id="kobo.2060.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2061.1">cd</span></span><span class="koboSpan" id="kobo.2062.1"> go-cobra
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2063.1">$ </span></span><span class="koboSpan" id="kobo.2064.1">go mod init
go: creating new go.mod: module github.com/mactsouk/mGo4th/ch07/go-cobra
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2065.1">$ </span></span><span class="koboSpan" id="kobo.2066.1">~/go/bin/cobra init
Using config file: /Users/mtsouk/.cobra.yaml
Your Cobra application is ready at
/Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2067.1">$ </span></span><span class="koboSpan" id="kobo.2068.1">go mod tidy
go: finding module for package github.com/spf13/viper
go: finding module for package github.com/spf13/cobra
go: downloading github.com/spf13/cobra v1.7.0
...
</span><span class="koboSpan" id="kobo.2068.2">go: downloading github.com/rogpeppe/go-internal v1.9.0
go: downloading github.com/kr/text v0.2.0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2069.1">All output lines beginning with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2070.1">go:</span></code><span class="koboSpan" id="kobo.2071.1"> relate to Go modules and will appear only once. </span><span class="koboSpan" id="kobo.2071.2">If you try to execute the utility, which is </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.2072.1">currently empty, you are going to get the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2073.1">$ </span></span><span class="koboSpan" id="kobo.2074.1">go run main.go
A longer description that spans multiple lines and likely contains
examples and usage of using your application. </span><span class="koboSpan" id="kobo.2074.2">For example:
Cobra is a CLI library for Go that empowers applications.
</span><span class="koboSpan" id="kobo.2074.3">This application is a tool to generate the needed files
to quickly create a Cobra application.
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2075.1">The last lines are the default message of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2076.1">cobra</span></code><span class="koboSpan" id="kobo.2077.1"> project. </span><span class="koboSpan" id="kobo.2077.2">We are going to modify that message later on. </span><span class="koboSpan" id="kobo.2077.3">You are now ready to begin working with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2078.1">cobra</span></code><span class="koboSpan" id="kobo.2079.1"> tool and add commands to the command line utility we are developing.</span></p>
<h2 class="heading-2" id="_idParaDest-201"><span class="koboSpan" id="kobo.2080.1">A utility with three commands</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2081.1">This subsection illustrates the</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.2082.1"> use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2083.1">cobra add</span></code><span class="koboSpan" id="kobo.2084.1"> command, which is used to add new commands to an existing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2085.1">cobra</span></code><span class="koboSpan" id="kobo.2086.1"> project. </span><span class="koboSpan" id="kobo.2086.2">The names of the commands are </span><code class="inlineCode"><span class="koboSpan" id="kobo.2087.1">one</span></code><span class="koboSpan" id="kobo.2088.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2089.1">two</span></code><span class="koboSpan" id="kobo.2090.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2091.1">three</span></code><span class="koboSpan" id="kobo.2092.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2093.1">$ </span></span><span class="koboSpan" id="kobo.2094.1">~/go/bin/cobra add one
Using config file: /Users/mtsouk/.cobra.yaml
one created at /Users/mtsouk/go/src/github.com/mactsouk/go-cobra
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2095.1">$ </span></span><span class="koboSpan" id="kobo.2096.1">~/go/bin/cobra add two 
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2097.1">$ </span></span><span class="koboSpan" id="kobo.2098.1">~/go/bin/cobra add three
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2099.1">The previous commands create three new files in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2100.1">cmd</span></code><span class="koboSpan" id="kobo.2101.1"> folder, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2102.1">one.go</span></code><span class="koboSpan" id="kobo.2103.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2104.1">two.go</span></code><span class="koboSpan" id="kobo.2105.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2106.1">three.go</span></code><span class="koboSpan" id="kobo.2107.1">, which are the initial naïve implementations of the three commands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2108.1">The first thing you should usually do is delete any unwanted code from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2109.1">root.go</span></code><span class="koboSpan" id="kobo.2110.1"> and change the messages of the utility and each command, as described in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2111.1">Short</span></code><span class="koboSpan" id="kobo.2112.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2113.1">Long</span></code><span class="koboSpan" id="kobo.2114.1"> fields. </span><span class="koboSpan" id="kobo.2114.2">However, if you want, you can leave the source files unchanged.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2115.1">The next subsection enriches the utility by adding command line flags to the commands.</span></p>
<h2 class="heading-2" id="_idParaDest-202"><span class="koboSpan" id="kobo.2116.1">Adding command line flags</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2117.1">We are going to create two global command line flags and one command line flag that is attached to a given command (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2118.1">two</span></code><span class="koboSpan" id="kobo.2119.1">) and not </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.2120.1">supported by the other two commands. </span><span class="koboSpan" id="kobo.2120.2">Global command line flags are defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2121.1">./cmd/root.go</span></code><span class="koboSpan" id="kobo.2122.1"> file. </span><span class="koboSpan" id="kobo.2122.2">We are going to define two global flags, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2123.1">directory</span></code><span class="koboSpan" id="kobo.2124.1">, which is a string, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2125.1">depth</span></code><span class="koboSpan" id="kobo.2126.1">, which is an unsigned integer. </span><span class="koboSpan" id="kobo.2126.2">Both global flags are defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2127.1">init()</span></code><span class="koboSpan" id="kobo.2128.1"> function of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2129.1">./cmd/root.go</span></code><span class="koboSpan" id="kobo.2130.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2131.1">rootCmd.PersistentFlags().StringP(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2132.1">"directory"</span></span><span class="koboSpan" id="kobo.2133.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2134.1">"d"</span></span><span class="koboSpan" id="kobo.2135.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2136.1">"/tmp"</span></span><span class="koboSpan" id="kobo.2137.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2138.1">"Path"</span></span><span class="koboSpan" id="kobo.2139.1">)
rootCmd.PersistentFlags().Uint(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2140.1">"depth"</span></span><span class="koboSpan" id="kobo.2141.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2142.1">2</span></span><span class="koboSpan" id="kobo.2143.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2144.1">"Depth of search"</span></span><span class="koboSpan" id="kobo.2145.1">)
viper.BindPFlag(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2146.1">"directory"</span></span><span class="koboSpan" id="kobo.2147.1">, rootCmd.PersistentFlags().Lookup(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2148.1">"directory"</span></span><span class="koboSpan" id="kobo.2149.1">))
viper.BindPFlag(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2150.1">"depth"</span></span><span class="koboSpan" id="kobo.2151.1">, rootCmd.PersistentFlags().Lookup(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2152.1">"depth"</span></span><span class="koboSpan" id="kobo.2153.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2154.1">We use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2155.1">rootCmd.PersistentFlags()</span></code><span class="koboSpan" id="kobo.2156.1"> to define global flags, followed by the data type of the flag. </span><span class="koboSpan" id="kobo.2156.2">The name of the first flag is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2157.1">directory</span></code><span class="koboSpan" id="kobo.2158.1"> and its shortcut is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2159.1">d</span></code><span class="koboSpan" id="kobo.2160.1">, whereas the name of the second flag is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2161.1">depth</span></code><span class="koboSpan" id="kobo.2162.1"> and has no shortcut—if you want to add a shortcut to it, you should use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2163.1">UintP()</span></code><span class="koboSpan" id="kobo.2164.1"> method, as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2165.1">depth</span></code><span class="koboSpan" id="kobo.2166.1"> parameter is an unsigned integer. </span><span class="koboSpan" id="kobo.2166.2">After defining the two flags, we pass their control to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2167.1">viper</span></code><span class="koboSpan" id="kobo.2168.1"> by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.2169.1">viper.BindPFlag()</span></code><span class="koboSpan" id="kobo.2170.1">. </span><span class="koboSpan" id="kobo.2170.2">The first flag is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2171.1">string</span></code><span class="koboSpan" id="kobo.2172.1">, whereas the second one is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2173.1">uint</span></code><span class="koboSpan" id="kobo.2174.1"> value. </span><span class="koboSpan" id="kobo.2174.2">As both of them are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2175.1">cobra</span></code><span class="koboSpan" id="kobo.2176.1"> project, we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.2177.1">viper.GetString("directory")</span></code><span class="koboSpan" id="kobo.2178.1"> to get the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2179.1">directory</span></code><span class="koboSpan" id="kobo.2180.1"> flag and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2181.1">viper.GetUint("depth")</span></code><span class="koboSpan" id="kobo.2182.1"> to get the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2183.1">depth</span></code><span class="koboSpan" id="kobo.2184.1"> flag. </span><span class="koboSpan" id="kobo.2184.2">This is not the only way to read the value of a flag and use it. </span><span class="koboSpan" id="kobo.2184.3">You are going to see an alternative way when we update the</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.2185.1"> statistics application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2186.1">Last, we add a command line flag that is only available to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2187.1">two</span></code><span class="koboSpan" id="kobo.2188.1"> command by adding the next line to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2189.1">init()</span></code><span class="koboSpan" id="kobo.2190.1"> function of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2191.1">./cmd/two.go</span></code><span class="koboSpan" id="kobo.2192.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2193.1">twoCmd.Flags().StringP(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2194.1">"username"</span></span><span class="koboSpan" id="kobo.2195.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2196.1">"u"</span></span><span class="koboSpan" id="kobo.2197.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2198.1">"Mike"</span></span><span class="koboSpan" id="kobo.2199.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2200.1">"Username"</span></span><span class="koboSpan" id="kobo.2201.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2202.1">The name of the flag is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2203.1">username</span></code><span class="koboSpan" id="kobo.2204.1">, and its shortcut is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2205.1">u</span></code><span class="koboSpan" id="kobo.2206.1">. </span><span class="koboSpan" id="kobo.2206.2">As this is a local flag available to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2207.1">two</span></code><span class="koboSpan" id="kobo.2208.1"> command only, we can get its value by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.2209.1">cmd.Flags().GetString("username")</span></code><span class="koboSpan" id="kobo.2210.1"> inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2211.1">./cmd/two.go</span></code><span class="koboSpan" id="kobo.2212.1"> file only.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2213.1">The next subsection creates command aliases for the existing commands.</span></p>
<h2 class="heading-2" id="_idParaDest-203"><span class="koboSpan" id="kobo.2214.1">Creating command aliases</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2215.1">In this subsection, we continue building on the code from the previous subsection by creating aliases for existing </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.2216.1">commands. </span><span class="koboSpan" id="kobo.2216.2">This means that the commands </span><code class="inlineCode"><span class="koboSpan" id="kobo.2217.1">one</span></code><span class="koboSpan" id="kobo.2218.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2219.1">two</span></code><span class="koboSpan" id="kobo.2220.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2221.1">three</span></code><span class="koboSpan" id="kobo.2222.1"> will also be accessible as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2223.1">cmd1</span></code><span class="koboSpan" id="kobo.2224.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2225.1">cmd2</span></code><span class="koboSpan" id="kobo.2226.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2227.1">cmd3</span></code><span class="koboSpan" id="kobo.2228.1">, respectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2229.1">In order to do that, you need to add an extra field named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2230.1">Aliases</span></code><span class="koboSpan" id="kobo.2231.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2232.1">cobra.Command</span></code><span class="koboSpan" id="kobo.2233.1"> structure of each command. </span><span class="koboSpan" id="kobo.2233.2">The data type of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2234.1">Aliases</span></code><span class="koboSpan" id="kobo.2235.1"> field is </span><em class="italic"><span class="koboSpan" id="kobo.2236.1">string slice</span></em><span class="koboSpan" id="kobo.2237.1">. </span><span class="koboSpan" id="kobo.2237.2">So, for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2238.1">one</span></code><span class="koboSpan" id="kobo.2239.1"> command, the beginning </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.2240.1">of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2241.1">cobra.Command</span></code><span class="koboSpan" id="kobo.2242.1"> structure in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2243.1">./cmd/one.go</span></code><span class="koboSpan" id="kobo.2244.1"> will look as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2245.1">var</span></span><span class="koboSpan" id="kobo.2246.1"> oneCmd = &amp;cobra.Command{
    Use:     </span><span class="hljs-string"><span class="koboSpan" id="kobo.2247.1">"one"</span></span><span class="koboSpan" id="kobo.2248.1">,
    Aliases: []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2249.1">string</span></span><span class="koboSpan" id="kobo.2250.1">{</span><span class="hljs-string"><span class="koboSpan" id="kobo.2251.1">"cmd1"</span></span><span class="koboSpan" id="kobo.2252.1">},
    Short:   </span><span class="hljs-string"><span class="koboSpan" id="kobo.2253.1">"Command one"</span></span><span class="koboSpan" id="kobo.2254.1">,
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2255.1">You should make similar changes to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2256.1">./cmd/two.go</span></code><span class="koboSpan" id="kobo.2257.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2258.1">./cmd/three.go</span></code><span class="koboSpan" id="kobo.2259.1">. </span><span class="koboSpan" id="kobo.2259.2">Please keep in mind that the </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2260.1">internal name</span></strong><span class="koboSpan" id="kobo.2261.1"> of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2262.1">one</span></code><span class="koboSpan" id="kobo.2263.1"> command is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2264.1">oneCmd</span></code><span class="koboSpan" id="kobo.2265.1"> and continues to be—the other commands have analogous internal names.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2266.1">If you accidentally put the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2267.1">cmd1</span></code><span class="koboSpan" id="kobo.2268.1"> alias, or any other alias, in multiple commands, the Go compiler will not complain. </span><span class="koboSpan" id="kobo.2268.2">However, only its first occurrence gets executed.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2269.1">The next subsection enriches the utility by adding subcommands for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2270.1">one</span></code><span class="koboSpan" id="kobo.2271.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2272.1">two</span></code><span class="koboSpan" id="kobo.2273.1"> commands.</span></p>
<h2 class="heading-2" id="_idParaDest-204"><span class="koboSpan" id="kobo.2274.1">Creating subcommands</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2275.1">This subsection illustrates how to create two </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.2276.1">subcommands for the command named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2277.1">three</span></code><span class="koboSpan" id="kobo.2278.1">. </span><span class="koboSpan" id="kobo.2278.2">The names of the two subcommands will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.2279.1">list</span></code><span class="koboSpan" id="kobo.2280.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2281.1">delete</span></code><span class="koboSpan" id="kobo.2282.1">. </span><span class="koboSpan" id="kobo.2282.2">The way to create them using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2283.1">cobra</span></code><span class="koboSpan" id="kobo.2284.1"> utility is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2285.1">$ </span></span><span class="koboSpan" id="kobo.2286.1">~/go/bin/cobra add list -p </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.2287.1">'threeCmd'</span></span><span class="koboSpan" id="kobo.2288.1">
Using config file: /Users/mtsouk/.cobra.yaml
list created at /Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2289.1">$ </span></span><span class="koboSpan" id="kobo.2290.1">~/go/bin/cobra add delete -p </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.2291.1">'threeCmd'</span></span><span class="koboSpan" id="kobo.2292.1">
Using config file: /Users/mtsouk/.cobra.yaml
delete created at /Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2293.1">The previous commands create two new files inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.2294.1">./cmd</span></code><span class="koboSpan" id="kobo.2295.1">, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2296.1">delete.go</span></code><span class="koboSpan" id="kobo.2297.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2298.1">list.go</span></code><span class="koboSpan" id="kobo.2299.1">. </span><span class="koboSpan" id="kobo.2299.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2300.1">-p</span></code><span class="koboSpan" id="kobo.2301.1"> flag is followed by the internal name of the command you want to associate the subcommands with. </span><span class="koboSpan" id="kobo.2301.2">The internal name of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2302.1">three</span></code><span class="koboSpan" id="kobo.2303.1"> command is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2304.1">threeCmd</span></code><span class="koboSpan" id="kobo.2305.1">. </span><span class="koboSpan" id="kobo.2305.2">You can verify that these </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.2306.1">two commands are associated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2307.1">three</span></code><span class="koboSpan" id="kobo.2308.1"> command as follows (the default message of each command is displayed):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2309.1">$ </span></span><span class="koboSpan" id="kobo.2310.1">go run main.go three delete
delete called
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2311.1">$ </span></span><span class="koboSpan" id="kobo.2312.1">go run main.go three list
list called
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2313.1">If you run </span><code class="inlineCode"><span class="koboSpan" id="kobo.2314.1">go run main.go two list</span></code><span class="koboSpan" id="kobo.2315.1">, Go considers list as a command line argument of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2316.1">two</span></code><span class="koboSpan" id="kobo.2317.1">, and it will not execute the code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2318.1">./cmd/list.go</span></code><span class="koboSpan" id="kobo.2319.1">. </span><span class="koboSpan" id="kobo.2319.2">The final version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2320.1">go-cobra</span></code><span class="koboSpan" id="kobo.2321.1"> project has the following structure and contains the following files, as generated by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2322.1">tree(1)</span></code><span class="koboSpan" id="kobo.2323.1"> utility:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2324.1">$ </span></span><span class="koboSpan" id="kobo.2325.1">tree
.
</span><span class="koboSpan" id="kobo.2325.2">├── LICENSE
├── cmd
│   ├── delete.go
│   ├── list.go
│   ├── one.go
│   ├── root.go
│   ├── three.go
│   └── two.go
├── go.mod
├── go.sum
└── main.go
2 directories, 10 files
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2326.1">At this point, you might wonder what happens when you want to create two subcommands with the same name for two different commands. </span><span class="koboSpan" id="kobo.2326.2">In that case, you create the first subcommand and rename its file before creating the second one.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2327.1">The use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2328.1">cobra</span></code><span class="koboSpan" id="kobo.2329.1"> package is also illustrated in the final section, where we radically update the statistics application. </span><span class="koboSpan" id="kobo.2329.2">The next section discusses some important additions that came with Go version 1.16.</span></p>
<h1 class="heading-1" id="_idParaDest-205"><span class="koboSpan" id="kobo.2330.1">Important Go features</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2331.1">Go 1.16 came with some new features, including embedding files in Go binaries as well as the introduction of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2332.1">os.ReadDir()</span></code><span class="koboSpan" id="kobo.2333.1"> function, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2334.1">os.DirEntry</span></code><span class="koboSpan" id="kobo.2335.1"> type, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2336.1">io/fs</span></code><span class="koboSpan" id="kobo.2337.1"> package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2338.1">As these features are related to systems programming, they are included and explored in the current chapter. </span><span class="koboSpan" id="kobo.2338.2">We begin by presenting the embedding of files into Go binary executables.</span></p>
<h2 class="heading-2" id="_idParaDest-206"><span class="koboSpan" id="kobo.2339.1">Embedding files</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2340.1">This section presents a</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.2341.1"> feature that allows you to </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2342.1">embed static assets into Go binaries</span></strong><span class="koboSpan" id="kobo.2343.1">. </span><span class="koboSpan" id="kobo.2343.2">The allowed data types to keep an embedded file are </span><code class="inlineCode"><span class="koboSpan" id="kobo.2344.1">string</span></code><span class="koboSpan" id="kobo.2345.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2346.1">[]byte</span></code><span class="koboSpan" id="kobo.2347.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2348.1">embed.FS</span></code><span class="koboSpan" id="kobo.2349.1">. </span><span class="koboSpan" id="kobo.2349.2">This means that a Go binary may contain a file that you do not have to manually download when you execute the Go binary! </span><span class="koboSpan" id="kobo.2349.3">The presented utility embeds two different files that it can retrieve based on the given command line argument.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2350.1">The code that follows, which is saved as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2351.1">embedFiles.go</span></code><span class="koboSpan" id="kobo.2352.1">, illustrates this new Go feature:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2353.1">package</span></span><span class="koboSpan" id="kobo.2354.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2355.1">import</span></span><span class="koboSpan" id="kobo.2356.1"> (
    _ </span><span class="hljs-string"><span class="koboSpan" id="kobo.2357.1">"embed"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2358.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2359.1">fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2360.1">"os"</span></span><span class="koboSpan" id="kobo.2361.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2362.1">You need the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2363.1">embed</span></code><span class="koboSpan" id="kobo.2364.1"> package in order to embed any files in your Go binaries. </span><span class="koboSpan" id="kobo.2364.2">As the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2365.1">embed</span></code><span class="koboSpan" id="kobo.2366.1"> package is not used directly, you need to put </span><code class="inlineCode"><span class="koboSpan" id="kobo.2367.1">_</span></code><span class="koboSpan" id="kobo.2368.1"> in front of it so that the Go compiler will not complain.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2369.1">//go:embed static/image.png</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2370.1">var</span></span><span class="koboSpan" id="kobo.2371.1"> f1 []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2372.1">byte</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2373.1">You need to begin a line with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2374.1">//go:embed</span></code><span class="koboSpan" id="kobo.2375.1">, which denotes a Go comment but is treated in a special way, followed by the path to the file you want to embed. </span><span class="koboSpan" id="kobo.2375.2">In this case, we embed </span><code class="inlineCode"><span class="koboSpan" id="kobo.2376.1">static/image.png</span></code><span class="koboSpan" id="kobo.2377.1">, which is a binary file. </span><span class="koboSpan" id="kobo.2377.2">The next line should define the variable that is going to hold the data of the embedded file, which, in this case, is a byte slice named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2378.1">f1</span></code><span class="koboSpan" id="kobo.2379.1">. </span><span class="koboSpan" id="kobo.2379.2">Using a byte slice is recommended for binary files because we are going to directly use that byte slice to save that binary file.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2380.1">//go:embed static/textfile</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2381.1">var</span></span><span class="koboSpan" id="kobo.2382.1"> f2 </span><span class="hljs-type"><span class="koboSpan" id="kobo.2383.1">string</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2384.1">In this case, we save the </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.2385.1">contents of a plain text file, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2386.1">static/textfile</span></code><span class="koboSpan" id="kobo.2387.1">, in a string variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2388.1">f2</span></code><span class="koboSpan" id="kobo.2389.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2390.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2391.1">writeToFile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2392.1">(s []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2393.1">byte</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2394.1">, path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2395.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2396.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2397.1">error</span></span><span class="koboSpan" id="kobo.2398.1"> {
    fd, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2399.1">0644</span></span><span class="koboSpan" id="kobo.2400.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2401.1">if</span></span><span class="koboSpan" id="kobo.2402.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2403.1">nil</span></span><span class="koboSpan" id="kobo.2404.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2405.1">return</span></span><span class="koboSpan" id="kobo.2406.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2407.1">defer</span></span><span class="koboSpan" id="kobo.2408.1"> fd.Close()
    n, err := fd.Write(s)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2409.1">if</span></span><span class="koboSpan" id="kobo.2410.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2411.1">nil</span></span><span class="koboSpan" id="kobo.2412.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2413.1">return</span></span><span class="koboSpan" id="kobo.2414.1"> err
    }
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2415.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2416.1">wrote %d bytes\n"</span></span><span class="koboSpan" id="kobo.2417.1">, n)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2418.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2419.1">nil</span></span><span class="koboSpan" id="kobo.2420.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2421.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2422.1">writeToFile()</span></code><span class="koboSpan" id="kobo.2423.1"> function is used to store a byte slice in a file and is a helper function that can be used in other cases as well.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2424.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2425.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2426.1">()</span></span><span class="koboSpan" id="kobo.2427.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2428.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2429.1">len</span></span><span class="koboSpan" id="kobo.2430.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2431.1">1</span></span><span class="koboSpan" id="kobo.2432.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2433.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2434.1">Print select 1|2"</span></span><span class="koboSpan" id="kobo.2435.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2436.1">return</span></span><span class="koboSpan" id="kobo.2437.1">
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2438.1">"f1:"</span></span><span class="koboSpan" id="kobo.2439.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2440.1">len</span></span><span class="koboSpan" id="kobo.2441.1">(f1), </span><span class="hljs-string"><span class="koboSpan" id="kobo.2442.1">"f2:"</span></span><span class="koboSpan" id="kobo.2443.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2444.1">len</span></span><span class="koboSpan" id="kobo.2445.1">(f2))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2446.1">This statement prints the lengths of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2447.1">f1</span></code><span class="koboSpan" id="kobo.2448.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2449.1">f2</span></code><span class="koboSpan" id="kobo.2450.1"> variables to make sure that they represent the size of the embedded files.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2451.1">switch</span></span><span class="koboSpan" id="kobo.2452.1"> arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2453.1">1</span></span><span class="koboSpan" id="kobo.2454.1">] {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2455.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2456.1">"1"</span></span><span class="koboSpan" id="kobo.2457.1">:
        filename := </span><span class="hljs-string"><span class="koboSpan" id="kobo.2458.1">"/tmp/temporary.png"</span></span><span class="koboSpan" id="kobo.2459.1">
        err := writeToFile(f1, filename)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2460.1">if</span></span><span class="koboSpan" id="kobo.2461.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2462.1">nil</span></span><span class="koboSpan" id="kobo.2463.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2464.1">return</span></span><span class="koboSpan" id="kobo.2465.1">
        }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2466.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2467.1">"2"</span></span><span class="koboSpan" id="kobo.2468.1">:
        fmt.Print(f2)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2469.1">default</span></span><span class="koboSpan" id="kobo.2470.1">:
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2471.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2472.1">Not a valid option!"</span></span><span class="koboSpan" id="kobo.2473.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2474.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2475.1">switch</span></code><span class="koboSpan" id="kobo.2476.1"> block is responsible for returning the desired file to the user—in the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2477.1">static/textfile</span></code><span class="koboSpan" id="kobo.2478.1">, the file contents are printed on screen. </span><span class="koboSpan" id="kobo.2478.2">For the binary file, we decided to store it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2479.1">/tmp/temporary.png</span></code><span class="koboSpan" id="kobo.2480.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2481.1">This time, we are going to compile </span><code class="inlineCode"><span class="koboSpan" id="kobo.2482.1">embedFiles.go</span></code><span class="koboSpan" id="kobo.2483.1"> to make things more realistic, as it is the executable binary file that </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.2484.1">holds the embedded files. </span><span class="koboSpan" id="kobo.2484.2">We build the binary file using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2485.1">go build embedFiles.go</span></code><span class="koboSpan" id="kobo.2486.1">. </span><span class="koboSpan" id="kobo.2486.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2487.1">embedFiles</span></code><span class="koboSpan" id="kobo.2488.1"> produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2489.1">$ </span></span><span class="koboSpan" id="kobo.2490.1">./embedFiles 2
f1: 75072 f2: 14
Data to write
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2491.1">$ </span></span><span class="koboSpan" id="kobo.2492.1">./embedFiles 1
f1: 75072 f2: 14
wrote 75072 bytes
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2493.1">The following output verifies that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2494.1">temporary.png</span></code><span class="koboSpan" id="kobo.2495.1"> is located at the right path (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2496.1">/tmp/temporary.png</span></code><span class="koboSpan" id="kobo.2497.1">):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2498.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2499.1">ls</span></span><span class="koboSpan" id="kobo.2500.1"> -l /tmp/temporary.png 
-rw-r--r--  1 mtsouk  wheel  75072 Feb 25 15:20 /tmp/temporary.png
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2501.1">Using the embedding functionality, we can create a utility that embeds its own source code and prints it on screen when it gets executed! </span><span class="koboSpan" id="kobo.2501.2">This is a fun way of using embedded files. </span><span class="koboSpan" id="kobo.2501.3">The source code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2502.1">printSource.go</span></code><span class="koboSpan" id="kobo.2503.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2504.1">package</span></span><span class="koboSpan" id="kobo.2505.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2506.1">import</span></span><span class="koboSpan" id="kobo.2507.1"> (
    _ </span><span class="hljs-string"><span class="koboSpan" id="kobo.2508.1">"embed"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2509.1">"fmt"</span></span><span class="koboSpan" id="kobo.2510.1">
)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2511.1">//go:embed printSource.go</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2512.1">var</span></span><span class="koboSpan" id="kobo.2513.1"> src </span><span class="hljs-type"><span class="koboSpan" id="kobo.2514.1">string</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2515.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2516.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2517.1">()</span></span><span class="koboSpan" id="kobo.2518.1"> {
    fmt.Print(src)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2519.1">As before, the file that is being embedded is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2520.1">//go:embed</span></code><span class="koboSpan" id="kobo.2521.1"> line. </span><span class="koboSpan" id="kobo.2521.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2522.1">printSource.go</span></code><span class="koboSpan" id="kobo.2523.1"> prints the aforementioned code on screen.</span></p>
<h2 class="heading-2" id="_idParaDest-207"><span class="koboSpan" id="kobo.2524.1">ReadDir and DirEntry</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2525.1">This section discusses </span><code class="inlineCode"><span class="koboSpan" id="kobo.2526.1">os.ReadDir()</span></code><span class="koboSpan" id="kobo.2527.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2528.1">os.DirEntry</span></code><span class="koboSpan" id="kobo.2529.1">. </span><span class="koboSpan" id="kobo.2529.2">However, it begins by discussing the deprecation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2530.1">io/ioutil</span></code><span class="koboSpan" id="kobo.2531.1"> package—the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2532.1">io/ioutil</span></code><span class="koboSpan" id="kobo.2533.1"> package has been transferred to other </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.2534.1">packages. </span><span class="koboSpan" id="kobo.2534.2">So, we have the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2535.1">os.ReadDir()</span></code><span class="koboSpan" id="kobo.2536.1">, which is a </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.2537.1">new function, returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.2538.1">[]DirEntry</span></code><span class="koboSpan" id="kobo.2539.1">. </span><span class="koboSpan" id="kobo.2539.2">This means that it cannot directly replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.2540.1">ioutil.ReadDir()</span></code><span class="koboSpan" id="kobo.2541.1">, which returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.2542.1">[]FileInfo</span></code><span class="koboSpan" id="kobo.2543.1">. </span><span class="koboSpan" id="kobo.2543.2">Although neither </span><code class="inlineCode"><span class="koboSpan" id="kobo.2544.1">os.ReadDir()</span></code><span class="koboSpan" id="kobo.2545.1"> nor </span><code class="inlineCode"><span class="koboSpan" id="kobo.2546.1">os.DirEntry</span></code><span class="koboSpan" id="kobo.2547.1"> offer any new functionality, they make things faster and simpler, which is important.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2548.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2549.1">os.ReadFile()</span></code><span class="koboSpan" id="kobo.2550.1"> function directly replaces </span><code class="inlineCode"><span class="koboSpan" id="kobo.2551.1">ioutil.ReadFile()</span></code><span class="koboSpan" id="kobo.2552.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2553.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2554.1">os.WriteFile()</span></code><span class="koboSpan" id="kobo.2555.1"> function can directly replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.2556.1">ioutil.WriteFile()</span></code><span class="koboSpan" id="kobo.2557.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2558.1">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2559.1">os.MkdirTemp()</span></code><span class="koboSpan" id="kobo.2560.1"> can replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.2561.1">ioutil.TempDir()</span></code><span class="koboSpan" id="kobo.2562.1"> without any changes. </span><span class="koboSpan" id="kobo.2562.2">However, as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2563.1">os.TempDir()</span></code><span class="koboSpan" id="kobo.2564.1"> name was already taken, the new function name is different.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2565.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2566.1">os.CreateTemp()</span></code><span class="koboSpan" id="kobo.2567.1"> function is the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2568.1">ioutil.TempFile()</span></code><span class="koboSpan" id="kobo.2569.1">. </span><span class="koboSpan" id="kobo.2569.2">Although the name </span><code class="inlineCode"><span class="koboSpan" id="kobo.2570.1">os.TempFile()</span></code><span class="koboSpan" id="kobo.2571.1"> was not taken, the Go people decided to name it </span><code class="inlineCode"><span class="koboSpan" id="kobo.2572.1">os.CreateTemp()</span></code><span class="koboSpan" id="kobo.2573.1"> in order to be on a par with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2574.1">os.MkdirTemp()</span></code><span class="koboSpan" id="kobo.2575.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2576.1">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2577.1">os.ReadDir()</span></code><span class="koboSpan" id="kobo.2578.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2579.1">os.DirEntry</span></code><span class="koboSpan" id="kobo.2580.1"> can be found as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2581.1">fs.ReadDir()</span></code><span class="koboSpan" id="kobo.2582.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2583.1">fs.DirEntry</span></code><span class="koboSpan" id="kobo.2584.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2585.1">io/fs</span></code><span class="koboSpan" id="kobo.2586.1"> package to work with the file system interface found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2587.1">io/fs</span></code><span class="koboSpan" id="kobo.2588.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2589.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2590.1">ReadDirEntry.go</span></code><span class="koboSpan" id="kobo.2591.1"> utility illustrates the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2592.1">os.ReadDir()</span></code><span class="koboSpan" id="kobo.2593.1">. </span><span class="koboSpan" id="kobo.2593.2">Additionally, we are going to see </span><code class="inlineCode"><span class="koboSpan" id="kobo.2594.1">fs.DirEntry</span></code><span class="koboSpan" id="kobo.2595.1"> in combination with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2596.1">fs.WalkDir()</span></code><span class="koboSpan" id="kobo.2597.1"> in action in the next section—</span><code class="inlineCode"><span class="koboSpan" id="kobo.2598.1">io/fs</span></code><span class="koboSpan" id="kobo.2599.1"> only supports </span><code class="inlineCode"><span class="koboSpan" id="kobo.2600.1">WalkDir()</span></code><span class="koboSpan" id="kobo.2601.1">, which uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.2602.1">DirEntry</span></code><span class="koboSpan" id="kobo.2603.1"> by default. </span><span class="koboSpan" id="kobo.2603.2">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2604.1">fs.WalkDir()</span></code><span class="koboSpan" id="kobo.2605.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2606.1">filepath.WalkDir()</span></code><span class="koboSpan" id="kobo.2607.1"> use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2608.1">DirEntry</span></code><span class="koboSpan" id="kobo.2609.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2610.1">FileInfo</span></code><span class="koboSpan" id="kobo.2611.1">. </span><span class="koboSpan" id="kobo.2611.2">This means that in order to see any performance improvements when walking directory trees, you need to change </span><code class="inlineCode"><span class="koboSpan" id="kobo.2612.1">filepath.Walk()</span></code><span class="koboSpan" id="kobo.2613.1"> calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2614.1">filepath.WalkDir()</span></code><span class="koboSpan" id="kobo.2615.1"> calls.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2616.1">The presented utility calculates the size of a directory tree using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2617.1">os.ReadDir()</span></code><span class="koboSpan" id="kobo.2618.1">, with the help of the following function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2619.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2620.1">GetSize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2621.1">(path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2622.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2623.1">)</span></span><span class="koboSpan" id="kobo.2624.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2625.1">int64</span></span><span class="koboSpan" id="kobo.2626.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2627.1">error</span></span><span class="koboSpan" id="kobo.2628.1">) {
    contents, err := os.ReadDir(path)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2629.1">if</span></span><span class="koboSpan" id="kobo.2630.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2631.1">nil</span></span><span class="koboSpan" id="kobo.2632.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2633.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2634.1">-1</span></span><span class="koboSpan" id="kobo.2635.1">, err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2636.1">var</span></span><span class="koboSpan" id="kobo.2637.1"> total </span><span class="hljs-type"><span class="koboSpan" id="kobo.2638.1">int64</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2639.1">for</span></span><span class="koboSpan" id="kobo.2640.1"> _, entry := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2641.1">range</span></span><span class="koboSpan" id="kobo.2642.1"> contents {
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2643.1">// Visit directory entries</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2644.1">if</span></span><span class="koboSpan" id="kobo.2645.1"> entry.IsDir() {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2646.1">If the return value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2647.1">entry.IsDir()</span></code><span class="koboSpan" id="kobo.2648.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2649.1">true</span></code><span class="koboSpan" id="kobo.2650.1">, then </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.2651.1">we process a directory, which means</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.2652.1"> that we need to keep digging.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2653.1">            temp, err := GetSize(filepath.Join(path, entry.Name()))
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2654.1">if</span></span><span class="koboSpan" id="kobo.2655.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2656.1">nil</span></span><span class="koboSpan" id="kobo.2657.1"> {
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2658.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2659.1">-1</span></span><span class="koboSpan" id="kobo.2660.1">, err
            }
            total += temp
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2661.1">// Get size of each non-directory entry</span></span><span class="koboSpan" id="kobo.2662.1">
        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2663.1">else</span></span><span class="koboSpan" id="kobo.2664.1"> {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2665.1">If we process a file, then we just need to get its size. </span><span class="koboSpan" id="kobo.2665.2">This involves calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.2666.1">Info()</span></code><span class="koboSpan" id="kobo.2667.1"> to get general information about the file and then </span><code class="inlineCode"><span class="koboSpan" id="kobo.2668.1">Size()</span></code><span class="koboSpan" id="kobo.2669.1"> to get its size:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2670.1">            info, err := entry.Info()
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2671.1">if</span></span><span class="koboSpan" id="kobo.2672.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2673.1">nil</span></span><span class="koboSpan" id="kobo.2674.1"> {
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2675.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2676.1">-1</span></span><span class="koboSpan" id="kobo.2677.1">, err
            }
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2678.1">// Returns an int64 value</span></span><span class="koboSpan" id="kobo.2679.1">
            total += info.Size()
        }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2680.1">return</span></span><span class="koboSpan" id="kobo.2681.1"> total, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2682.1">nil</span></span><span class="koboSpan" id="kobo.2683.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2684.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2685.1">ReadDirEntry.go</span></code><span class="koboSpan" id="kobo.2686.1"> produces the next output, which indicates that the utility works as expected:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2687.1">$ </span></span><span class="koboSpan" id="kobo.2688.1">go run ReadDirEntry.go /usr/bin
Total Size: 240527817
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2689.1">Last, keep in mind that both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2690.1">ReadDir</span></code><span class="koboSpan" id="kobo.2691.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2692.1">DirEntry</span></code><span class="koboSpan" id="kobo.2693.1"> are copied from the Python programming language.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2694.1">The next section introduces us to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2695.1">io/fs</span></code><span class="koboSpan" id="kobo.2696.1"> package.</span></p>
<h2 class="heading-2" id="_idParaDest-208"><span class="koboSpan" id="kobo.2697.1">The io/fs package</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2698.1">This section illustrates the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2699.1">io/fs</span></code><span class="koboSpan" id="kobo.2700.1"> package, which was also introduced in Go 1.16. </span><span class="koboSpan" id="kobo.2700.2">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.2701.1">io/fs</span></code><span class="koboSpan" id="kobo.2702.1"> offers a </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.2703.1">unique kind of functionality, we begin this section by explaining what it can do. </span><span class="koboSpan" id="kobo.2703.2">Put simply, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2704.1">io/fs</span></code><span class="koboSpan" id="kobo.2705.1"> offers a read-only file system interface named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2706.1">FS</span></code><span class="koboSpan" id="kobo.2707.1">. </span><span class="koboSpan" id="kobo.2707.2">Note that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2708.1">embed.FS</span></code><span class="koboSpan" id="kobo.2709.1"> implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2710.1">fs.FS</span></code><span class="koboSpan" id="kobo.2711.1"> interface, which means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2712.1">embed.FS</span></code><span class="koboSpan" id="kobo.2713.1"> can take advantage of some of the functionality offered by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2714.1">io/fs</span></code><span class="koboSpan" id="kobo.2715.1"> package. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2716.1">This means that your applications can create their own internal file systems and work with their files</span></strong><span class="koboSpan" id="kobo.2717.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2718.1">The code example that follows, which is saved as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2719.1">ioFS.go</span></code><span class="koboSpan" id="kobo.2720.1">, creates a file system using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2721.1">embed</span></code><span class="koboSpan" id="kobo.2722.1"> by putting all the files of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2723.1">./static</span></code><span class="koboSpan" id="kobo.2724.1"> folder in there. </span><code class="inlineCode"><span class="koboSpan" id="kobo.2725.1">ioFS.go</span></code><span class="koboSpan" id="kobo.2726.1"> supports the following functionality: list all files, search for a filename, and extract a file using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2727.1">list()</span></code><span class="koboSpan" id="kobo.2728.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2729.1">search()</span></code><span class="koboSpan" id="kobo.2730.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2731.1">extract()</span></code><span class="koboSpan" id="kobo.2732.1">, respectively. </span><span class="koboSpan" id="kobo.2732.2">We begin by presenting the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2733.1">list()</span></code><span class="koboSpan" id="kobo.2734.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2735.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2736.1">list</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2737.1">(f embed.FS)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2738.1">error</span></span><span class="koboSpan" id="kobo.2739.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2740.1">return</span></span><span class="koboSpan" id="kobo.2741.1"> fs.WalkDir(f, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2742.1">"."</span></span><span class="koboSpan" id="kobo.2743.1">, walkFunction)
}
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2744.1">Keep in mind that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2745.1">fs.WalkDir()</span></code><span class="koboSpan" id="kobo.2746.1"> works with regular file systems as well as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2747.1">embed.FS</span></code><span class="koboSpan" id="kobo.2748.1"> file systems. </span><span class="koboSpan" id="kobo.2748.2">You can learn more about the signature of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2749.1">walkFunction()</span></code><span class="koboSpan" id="kobo.2750.1"> by running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2751.1">go doc fs.WalkDirFunc</span></code><span class="koboSpan" id="kobo.2752.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2753.1">Here, we begin with the given directory of a file system and visit its contents. </span><span class="koboSpan" id="kobo.2753.2">The file system is stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2754.1">f</span></code><span class="koboSpan" id="kobo.2755.1"> and the root directory is defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2756.1">"."</span></code><span class="koboSpan" id="kobo.2757.1">. </span><span class="koboSpan" id="kobo.2757.2">After that, all the magic happens in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2758.1">walkFunction()</span></code><span class="koboSpan" id="kobo.2759.1"> function, which is implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2760.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2761.1">walkFunction</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2762.1">(path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2763.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2764.1">, d fs.DirEntry, err </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2765.1">error</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2766.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2767.1">error</span></span><span class="koboSpan" id="kobo.2768.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2769.1">if</span></span><span class="koboSpan" id="kobo.2770.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2771.1">nil</span></span><span class="koboSpan" id="kobo.2772.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2773.1">return</span></span><span class="koboSpan" id="kobo.2774.1"> err
    }
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2775.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2776.1">Path=%q, isDir=%v\n"</span></span><span class="koboSpan" id="kobo.2777.1">, path, d.IsDir())
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2778.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2779.1">nil</span></span><span class="koboSpan" id="kobo.2780.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2781.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2782.1">walkFunction()</span></code><span class="koboSpan" id="kobo.2783.1"> function processes every entry in the given root directory in the desired way. </span><span class="koboSpan" id="kobo.2783.2">Keep in mind that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2784.1">walkFunc()</span></code><span class="koboSpan" id="kobo.2785.1"> is </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2786.1">automatically called</span></strong><span class="koboSpan" id="kobo.2787.1"> by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2788.1">fs.WalkDir()</span></code><span class="koboSpan" id="kobo.2789.1"> to visit each file or directory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2790.1">Then, we present the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2791.1">extract()</span></code><span class="koboSpan" id="kobo.2792.1"> function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2793.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2794.1">extract</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2795.1">(f embed.FS, filepath </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2796.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2797.1">)</span></span><span class="koboSpan" id="kobo.2798.1"> ([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2799.1">byte</span></span><span class="koboSpan" id="kobo.2800.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2801.1">error</span></span><span class="koboSpan" id="kobo.2802.1">) {
    s, err := fs.ReadFile(f, filepath)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2803.1">if</span></span><span class="koboSpan" id="kobo.2804.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2805.1">nil</span></span><span class="koboSpan" id="kobo.2806.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2807.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2808.1">nil</span></span><span class="koboSpan" id="kobo.2809.1">, err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2810.1">return</span></span><span class="koboSpan" id="kobo.2811.1"> s, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2812.1">nil</span></span><span class="koboSpan" id="kobo.2813.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2814.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2815.1">ReadFile()</span></code><span class="koboSpan" id="kobo.2816.1"> function is used to retrieve a file, which is identified by its file path, from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2817.1">embed.FS</span></code><span class="koboSpan" id="kobo.2818.1"> file system as a</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.2819.1"> byte slice, which is returned from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2820.1">extract()</span></code><span class="koboSpan" id="kobo.2821.1"> function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2822.1">Last, we have the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2823.1">search()</span></code><span class="koboSpan" id="kobo.2824.1"> function, which is based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.2825.1">walkSearch()</span></code><span class="koboSpan" id="kobo.2826.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2827.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2828.1">walkSearch</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2829.1">(path </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2830.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2831.1">, d fs.DirEntry, err </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2832.1">error</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2833.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2834.1">error</span></span><span class="koboSpan" id="kobo.2835.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2836.1">if</span></span><span class="koboSpan" id="kobo.2837.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2838.1">nil</span></span><span class="koboSpan" id="kobo.2839.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2840.1">return</span></span><span class="koboSpan" id="kobo.2841.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2842.1">if</span></span><span class="koboSpan" id="kobo.2843.1"> d.Name() == searchString {
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2844.1">searchString</span></code><span class="koboSpan" id="kobo.2845.1"> is a global variable that holds the search string. </span><span class="koboSpan" id="kobo.2845.2">When a match is found, the matching path is printed on screen.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2846.1">        fileInfo, err := fs.Stat(f, path)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2847.1">if</span></span><span class="koboSpan" id="kobo.2848.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2849.1">nil</span></span><span class="koboSpan" id="kobo.2850.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2851.1">return</span></span><span class="koboSpan" id="kobo.2852.1"> err
        }
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2853.1">"Found"</span></span><span class="koboSpan" id="kobo.2854.1">, path, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2855.1">"with size"</span></span><span class="koboSpan" id="kobo.2856.1">, fileInfo.Size())
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2857.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2858.1">nil</span></span><span class="koboSpan" id="kobo.2859.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2860.1">Before printing a match, we make a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2861.1">fs.Stat()</span></code><span class="koboSpan" id="kobo.2862.1"> to get more details about it:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2863.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2864.1">nil</span></span><span class="koboSpan" id="kobo.2865.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2866.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2867.1">main()</span></code><span class="koboSpan" id="kobo.2868.1"> function specifically calls these three functions. </span><span class="koboSpan" id="kobo.2868.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2869.1">ioFS.go</span></code><span class="koboSpan" id="kobo.2870.1"> produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2871.1">$ </span></span><span class="koboSpan" id="kobo.2872.1">go run ioFS.go
Path=".", isDir=true
Path="static", isDir=true
Path="static/file.txt", isDir=false
Path="static/image.png", isDir=false
Path="static/textfile", isDir=false
Found static/file.txt with size 14
wrote 14 bytes
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2873.1">Initially, the utility lists all files in the file system (lines beginning with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2874.1">Path</span></code><span class="koboSpan" id="kobo.2875.1">). </span><span class="koboSpan" id="kobo.2875.2">Then, it verifies that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2876.1">static/file.txt</span></code><span class="koboSpan" id="kobo.2877.1"> can </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.2878.1">be found in the file system. </span><span class="koboSpan" id="kobo.2878.2">Last, it verifies that the writing of 14 bytes into a new file was successful, as all 14 bytes have been written.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2879.1">So it turns out that Go version 1.16 introduced important functionality.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2880.1">In the next section, we are going to improve the statistics application.</span></p>
<h1 class="heading-1" id="_idParaDest-209"><span class="koboSpan" id="kobo.2881.1">Updating the statistics application</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2882.1">In this section, we will change the</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.2883.1"> format that the statistics application uses to store its data. </span><span class="koboSpan" id="kobo.2883.2">This time, the statistics application is going to use the JSON format. </span><span class="koboSpan" id="kobo.2883.3">Additionally, it uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2884.1">cobra</span></code><span class="koboSpan" id="kobo.2885.1"> package to implement the supported commands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2886.1">However, before continuing with the statistics application, we are going to learn more about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2887.1">slog</span></code><span class="koboSpan" id="kobo.2888.1"> package.</span></p>
<h2 class="heading-2" id="_idParaDest-210"><span class="koboSpan" id="kobo.2889.1">The slog package</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2890.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2891.1">log/slog</span></code><span class="koboSpan" id="kobo.2892.1"> package was added to the</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.2893.1"> standard Go library with Go 1.21 in order to improve the original </span><code class="inlineCode"><span class="koboSpan" id="kobo.2894.1">log</span></code><span class="koboSpan" id="kobo.2895.1"> package. </span><span class="koboSpan" id="kobo.2895.2">You can find more information about it at </span><a href="https://pkg.go.dev/log/slog"><span class="url"><span class="koboSpan" id="kobo.2896.1">https://pkg.go.dev/log/slog</span></span></a><span class="koboSpan" id="kobo.2897.1">. </span><span class="koboSpan" id="kobo.2897.2">The main reason for including it in this chapter is that it can </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.2898.1">create log entries in the JSON format, which is handy when you want to further process log entries.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2899.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2900.1">useSLog.go</span></code><span class="koboSpan" id="kobo.2901.1"> that illustrates the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2902.1">log/slog</span></code><span class="koboSpan" id="kobo.2903.1"> package is going to be presented in three parts. </span><span class="koboSpan" id="kobo.2903.2">The first part is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2904.1">package</span></span><span class="koboSpan" id="kobo.2905.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2906.1">import</span></span><span class="koboSpan" id="kobo.2907.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2908.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2909.1">"log/slog"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2910.1">"os"</span></span><span class="koboSpan" id="kobo.2911.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2912.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2913.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2914.1">()</span></span><span class="koboSpan" id="kobo.2915.1"> {
    slog.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2916.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2917.1">This is an ERROR message"</span></span><span class="koboSpan" id="kobo.2918.1">)
    slog.Debug(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2919.1">"This is a DEBUG message"</span></span><span class="koboSpan" id="kobo.2920.1">)
    slog.Info(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2921.1">"This ia an INFO message"</span></span><span class="koboSpan" id="kobo.2922.1">)
    slog.Warn(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2923.1">"This is a WARNING message"</span></span><span class="koboSpan" id="kobo.2924.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2925.1">First, we need to import </span><code class="inlineCode"><span class="koboSpan" id="kobo.2926.1">log/slog</span></code><span class="koboSpan" id="kobo.2927.1"> for using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2928.1">slog</span></code><span class="koboSpan" id="kobo.2929.1"> package of the Go standard library. </span><span class="koboSpan" id="kobo.2929.2">When using the default logger, we can send messages using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2930.1">Error()</span></code><span class="koboSpan" id="kobo.2931.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2932.1">Debug()</span></code><span class="koboSpan" id="kobo.2933.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2934.1">Info()</span></code><span class="koboSpan" id="kobo.2935.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2936.1">Warn()</span></code><span class="koboSpan" id="kobo.2937.1">, which is the simplest way of </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.2938.1">using the functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2939.1">slog</span></code><span class="koboSpan" id="kobo.2940.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2941.1">The second part contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2942.1">    logLevel := &amp;slog.LevelVar{}
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2943.1">"Log level:"</span></span><span class="koboSpan" id="kobo.2944.1">, logLevel)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2945.1">// Text Handler</span></span><span class="koboSpan" id="kobo.2946.1">
    opts := &amp;slog.HandlerOptions{
        Level: logLevel,
    }
    handler := slog.NewTextHandler(os.Stdout, opts)
    logger := slog.New(handler)
    logLevel.Set(slog.LevelDebug)
    logger.Debug(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2947.1">"This is a DEBUG message"</span></span><span class="koboSpan" id="kobo.2948.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2949.1">In this part of the program, we get the current log level using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2950.1">&amp;slog.LevelVar{}</span></code><span class="koboSpan" id="kobo.2951.1"> and change it to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2952.1">Debug</span></code><span class="koboSpan" id="kobo.2953.1"> level in order to also get the log entries issued with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2954.1">logger.Debug()</span></code><span class="koboSpan" id="kobo.2955.1">. </span><span class="koboSpan" id="kobo.2955.2">This is implemented with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2956.1">logLevel.Set(slog.LevelDebug)</span></code><span class="koboSpan" id="kobo.2957.1"> statement.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2958.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2959.1">useSLog.go</span></code><span class="koboSpan" id="kobo.2960.1"> comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2961.1">// JSON Handler</span></span><span class="koboSpan" id="kobo.2962.1">
    logJSON := slog.New(slog.NewJSONHandler(os.Stdout, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2963.1">nil</span></span><span class="koboSpan" id="kobo.2964.1">))
    logJSON.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2965.1">"ERROR message in JSON"</span></span><span class="koboSpan" id="kobo.2966.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2967.1">The presented code creates a logger that writes JSON records.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2968.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2969.1">useSLog.go</span></code><span class="koboSpan" id="kobo.2970.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2971.1">$ </span></span><span class="koboSpan" id="kobo.2972.1">go run useSLog.go
2023/08/22 21:49:18 ERROR This is an ERROR message
2023/08/22 21:49:18 INFO This ia an INFO message
2023/08/22 21:49:18 WARN This is a WARNING message
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2973.1">The previous output is from the first four statements of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2974.1">main()</span></code><span class="koboSpan" id="kobo.2975.1">. </span><span class="koboSpan" id="kobo.2975.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2976.1">slog.Debug()</span></code><span class="koboSpan" id="kobo.2977.1"> statement generated no output because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2978.1">DEBUG</span></code><span class="koboSpan" id="kobo.2979.1"> level does not get printed by default.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2980.1">Log level: LevelVar(INFO)
time=2023-08-22T21:49:18.474+03:00 level=DEBUG msg="This is a DEBUG message"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2981.1">The previous output shows that if we increase the logging level, we can get </span><code class="inlineCode"><span class="koboSpan" id="kobo.2982.1">DEBUG</span></code><span class="koboSpan" id="kobo.2983.1"> messages printed—the default logging level was </span><code class="inlineCode"><span class="koboSpan" id="kobo.2984.1">INFO</span></code><span class="koboSpan" id="kobo.2985.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2986.1">{"time":"2023-08-22T21:49:18.474392+03:00","level":"ERROR","msg":"ERROR message in JSON"}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2987.1">The last line of the output shows</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.2988.1"> logging information in the JSON format. </span><span class="koboSpan" id="kobo.2988.2">This can be very handy if we want to store log entries in a regular or a time series database for further processing, visualization, or data analysis.</span></p>
<h2 class="heading-2" id="_idParaDest-211"><span class="koboSpan" id="kobo.2989.1">Sending logs to io.Discard</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2990.1">This subsection presents a trick that involves</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.2991.1"> the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2992.1">io.Discard</span></code><span class="koboSpan" id="kobo.2993.1"> for sending log entries—</span><code class="inlineCode"><span class="koboSpan" id="kobo.2994.1">io.Discard</span></code><span class="koboSpan" id="kobo.2995.1"> discards all </span><code class="inlineCode"><span class="koboSpan" id="kobo.2996.1">Write()</span></code><span class="koboSpan" id="kobo.2997.1"> calls without doing anything! </span><span class="koboSpan" id="kobo.2997.2">Although we are going to apply the trick to log files, it can also be used in other cases where writing data is involved. </span><span class="koboSpan" id="kobo.2997.3">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2998.1">main()</span></code><span class="koboSpan" id="kobo.2999.1"> function in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3000.1">discard.go</span></code><span class="koboSpan" id="kobo.3001.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3002.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3003.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3004.1">()</span></span><span class="koboSpan" id="kobo.3005.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3006.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3007.1">len</span></span><span class="koboSpan" id="kobo.3008.1">(os.Args) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3009.1">1</span></span><span class="koboSpan" id="kobo.3010.1"> {
        log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3011.1">"Enabling logging!"</span></span><span class="koboSpan" id="kobo.3012.1">)
        log.SetOutput(os.Stderr)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3013.1">else</span></span><span class="koboSpan" id="kobo.3014.1"> {
        log.SetOutput(os.Stderr)
        log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3015.1">"Disabling logging!"</span></span><span class="koboSpan" id="kobo.3016.1">)
        </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.3017.1">log.SetOutput(io.Discard)</span></strong></span><span class="koboSpan" id="kobo.3018.1">
        log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3019.1">"NOT GOING TO GET THAT!"</span></span><span class="koboSpan" id="kobo.3020.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3021.1">The condition that enables or disables writing is simplistic: when there is a single command line argument, logging is enabled; otherwise, it is disabled. </span><span class="koboSpan" id="kobo.3021.2">The statement that disables logging is </span><code class="inlineCode"><span class="koboSpan" id="kobo.3022.1">log.SetOutput(io.Discard)</span></code><span class="koboSpan" id="kobo.3023.1">. </span><span class="koboSpan" id="kobo.3023.2">However, before logging is disabled, we print a log entry stating so.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3024.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.3025.1">discard.go</span></code><span class="koboSpan" id="kobo.3026.1"> generates </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.3027.1">the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3028.1">$ </span></span><span class="koboSpan" id="kobo.3029.1">go run discard.go
2023/08/22 21:35:17 Enabling logging!
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3030.1">$ </span></span><span class="koboSpan" id="kobo.3031.1">go run discard.go 1
2023/08/22 21:35:21 Disabling logging!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3032.1">In the second program execution, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3033.1">log.Println("NOT GOING TO GET THAT!")</span></code><span class="koboSpan" id="kobo.3034.1"> statement generates no output, as it went to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3035.1">io.Discard</span></code><span class="koboSpan" id="kobo.3036.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3037.1">With all this information in mind, let us continue with the implementation of the statistics application with the help of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3038.1">cobra</span></code><span class="koboSpan" id="kobo.3039.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-212"><span class="koboSpan" id="kobo.3040.1">Using cobra</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3041.1">First, we need to create a place to </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.3042.1">host the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3043.1">cobra</span></code><span class="koboSpan" id="kobo.3044.1"> version of the statistics application. </span><span class="koboSpan" id="kobo.3044.2">At this point, you have two options: either create a separate GitHub repository or put the necessary files in a directory under </span><code class="inlineCode"><span class="koboSpan" id="kobo.3045.1">~/go/src</span></code><span class="koboSpan" id="kobo.3046.1">. </span><span class="koboSpan" id="kobo.3046.2">This subsection is going to follow the latter option. </span><span class="koboSpan" id="kobo.3046.3">As a result, all relevant code is going to reside at </span><code class="inlineCode"><span class="koboSpan" id="kobo.3047.1">~/go/src/github.com/mactsouk/mGo4th/ch07/stats</span></code><span class="koboSpan" id="kobo.3048.1">. </span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3049.1">The project is already present in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3050.1">stats</span></code><span class="koboSpan" id="kobo.3051.1"> directory. </span><span class="koboSpan" id="kobo.3051.2">The presented steps make sense if you want to create it on your own.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3052.1">First, we need to create and go to the relevant directory:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3053.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.3054.1">cd</span></span><span class="koboSpan" id="kobo.3055.1"> ~/go/src/github.com/mactsouk/mGo4th/ch07/stats
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3056.1">After that, we should declare that we want to use Go modules:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3057.1">$ </span></span><span class="koboSpan" id="kobo.3058.1">go mod init
go: creating new go.mod: module github.com/mactsouk/mGo4th/ch07/stats
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3059.1">After that, we need to run the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3060.1">cobra init</span></code><span class="koboSpan" id="kobo.3061.1"> command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3062.1">$ </span></span><span class="koboSpan" id="kobo.3063.1">~/go/bin/cobra init
Using config file: /Users/mtsouk/.cobra.yaml
Your Cobra application is ready at
/Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch07/stats
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3064.1">Then, we can execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.3065.1">go mod tidy</span></code><span class="koboSpan" id="kobo.3066.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3067.1">$ </span></span><span class="koboSpan" id="kobo.3068.1">go mod tidy
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3069.1">Then, we should create the </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.3070.1">structure of the application using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3071.1">cobra</span></code><span class="koboSpan" id="kobo.3072.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3073.1">cobra-cli</span></code><span class="koboSpan" id="kobo.3074.1">) binary. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.3075.1">Once we have the structure, it is easy to know what we have to implement</span></strong><span class="koboSpan" id="kobo.3076.1">. </span><span class="koboSpan" id="kobo.3076.2">The structure of the application is based on the supported commands and functionality:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3077.1">$ </span></span><span class="koboSpan" id="kobo.3078.1">~/go/bin/cobra add list
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3079.1">$ </span></span><span class="koboSpan" id="kobo.3080.1">~/go/bin/cobra add delete
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3081.1">$ </span></span><span class="koboSpan" id="kobo.3082.1">~/go/bin/cobra add insert
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3083.1">$ </span></span><span class="koboSpan" id="kobo.3084.1">~/go/bin/cobra add search
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3085.1">At this point, executing </span><code class="inlineCode"><span class="koboSpan" id="kobo.3086.1">go run main.go</span></code><span class="koboSpan" id="kobo.3087.1"> is going to download any missing packages and generate the default </span><code class="inlineCode"><span class="koboSpan" id="kobo.3088.1">cobra</span></code><span class="koboSpan" id="kobo.3089.1"> output.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3090.1">We need to create a command line flag to enable and disable logging. </span><span class="koboSpan" id="kobo.3090.2">We are going to be using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3091.1">log/slog</span></code><span class="koboSpan" id="kobo.3092.1"> package. </span><span class="koboSpan" id="kobo.3092.2">The flag is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3093.1">--log</span></code><span class="koboSpan" id="kobo.3094.1"> and is going to be a Boolean variable. </span><span class="koboSpan" id="kobo.3094.2">The relevant statement, which is located in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3095.1">root.go</span></code><span class="koboSpan" id="kobo.3096.1">, is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3097.1">rootCmd.PersistentFlags().BoolVarP(&amp;disableLogging, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3098.1">"log"</span></span><span class="koboSpan" id="kobo.3099.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3100.1">"l"</span></span><span class="koboSpan" id="kobo.3101.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3102.1">false</span></span><span class="koboSpan" id="kobo.3103.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3104.1">"Logging information"</span></span><span class="koboSpan" id="kobo.3105.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3106.1">The previous statement is supported by a global variable, which is defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3107.1">var</span></span><span class="koboSpan" id="kobo.3108.1"> disableLogging </span><span class="hljs-type"><span class="koboSpan" id="kobo.3109.1">bool</span></span>
</code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3110.1">This is a different approach regarding the use of the command line flags than what we did in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3111.1">go-cobra</span></code><span class="koboSpan" id="kobo.3112.1"> project presented earlier.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3113.1">So, the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3114.1">disableLogging</span></code><span class="koboSpan" id="kobo.3115.1"> global variable holds the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3116.1">--log</span></code><span class="koboSpan" id="kobo.3117.1"> flag. </span><span class="koboSpan" id="kobo.3117.2">Although the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3118.1">disableLogging</span></code><span class="koboSpan" id="kobo.3119.1"> variable is global, you have to define </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.3120.1">a separate logger variable in each one of the commands</span></strong><span class="koboSpan" id="kobo.3121.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3122.1">The next subsection discusses the storing and loading of JSON data.</span></p>
<h2 class="heading-2" id="_idParaDest-213"><span class="koboSpan" id="kobo.3123.1">Storing and loading JSON data</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3124.1">This functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3125.1">saveJSONFile()</span></code><span class="koboSpan" id="kobo.3126.1"> helper </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.3127.1">function is implemented in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3128.1">./cmd/root.go</span></code><span class="koboSpan" id="kobo.3129.1">, using the</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.3130.1"> following function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3131.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3132.1">saveJSONFile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3133.1">(filepath </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3134.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3135.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3136.1">error</span></span><span class="koboSpan" id="kobo.3137.1"> {
    f, err := os.Create(filepath)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3138.1">if</span></span><span class="koboSpan" id="kobo.3139.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3140.1">nil</span></span><span class="koboSpan" id="kobo.3141.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3142.1">return</span></span><span class="koboSpan" id="kobo.3143.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3144.1">defer</span></span><span class="koboSpan" id="kobo.3145.1"> f.Close()
    err = Serialize(&amp;data, f)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3146.1">return</span></span><span class="koboSpan" id="kobo.3147.1"> err
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3148.1">Basically, all we have to do is serialize the slice of structures using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3149.1">Serialize()</span></code><span class="koboSpan" id="kobo.3150.1"> and save the result in a file. </span><span class="koboSpan" id="kobo.3150.2">Next, we need to be able to load the JSON data from that file. </span><span class="koboSpan" id="kobo.3150.3">The loading functionality is also implemented in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3151.1">./cmd/root.go</span></code><span class="koboSpan" id="kobo.3152.1">, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3153.1">readJSONFile()</span></code><span class="koboSpan" id="kobo.3154.1"> helper function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3155.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3156.1">readJSONFile</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3157.1">(filepath </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3158.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3159.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3160.1">error</span></span><span class="koboSpan" id="kobo.3161.1"> {
    _, err := os.Stat(filepath)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3162.1">if</span></span><span class="koboSpan" id="kobo.3163.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3164.1">nil</span></span><span class="koboSpan" id="kobo.3165.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3166.1">return</span></span><span class="koboSpan" id="kobo.3167.1"> err
    }
    f, err := os.Open(filepath)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3168.1">if</span></span><span class="koboSpan" id="kobo.3169.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3170.1">nil</span></span><span class="koboSpan" id="kobo.3171.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3172.1">return</span></span><span class="koboSpan" id="kobo.3173.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3174.1">defer</span></span><span class="koboSpan" id="kobo.3175.1"> f.Close()
    err = DeSerialize(&amp;data, f)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3176.1">if</span></span><span class="koboSpan" id="kobo.3177.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3178.1">nil</span></span><span class="koboSpan" id="kobo.3179.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3180.1">return</span></span><span class="koboSpan" id="kobo.3181.1"> err
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3182.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.3183.1">nil</span></span><span class="koboSpan" id="kobo.3184.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3185.1">All we have to do is read the data file with the JSON data and put that data into a slice of structures by deserializing it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3186.1">Now, we are going to</span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.3187.1"> discuss the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3188.1">list</span></code><span class="koboSpan" id="kobo.3189.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3190.1">insert</span></code><span class="koboSpan" id="kobo.3191.1"> commands. </span><span class="koboSpan" id="kobo.3191.2">The other two commands (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3192.1">delete</span></code><span class="koboSpan" id="kobo.3193.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3194.1">search</span></code><span class="koboSpan" id="kobo.3195.1">) have </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.3196.1">similar implementations.</span></p>
<h2 class="heading-2" id="_idParaDest-214"><span class="koboSpan" id="kobo.3197.1">Implementing the list command</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3198.1">The important code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3199.1">./cmd/list.go</span></code><span class="koboSpan" id="kobo.3200.1"> is in the</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.3201.1"> implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3202.1">list()</span></code><span class="koboSpan" id="kobo.3203.1"> function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3204.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3205.1">list</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3206.1">()</span></span><span class="koboSpan" id="kobo.3207.1"> {
    sort.Sort(DFslice(data))
    text, err := PrettyPrintJSONstream(data)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3208.1">if</span></span><span class="koboSpan" id="kobo.3209.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3210.1">nil</span></span><span class="koboSpan" id="kobo.3211.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3212.1">return</span></span><span class="koboSpan" id="kobo.3213.1">
    }
    fmt.Println(text)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3214.1">The core functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3215.1">list</span></code><span class="koboSpan" id="kobo.3216.1"> is included in the previous code, which sorts the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3217.1">data</span></code><span class="koboSpan" id="kobo.3218.1"> slice and pretty prints the JSON records using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3219.1">PrettyPrintJSONstream(data)</span></code><span class="koboSpan" id="kobo.3220.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3221.1">    logger = slog.New(slog.NewJSONHandler(os.Stderr, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3222.1">nil</span></span><span class="koboSpan" id="kobo.3223.1">))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3224.1">if</span></span><span class="koboSpan" id="kobo.3225.1"> disableLogging == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3226.1">false</span></span><span class="koboSpan" id="kobo.3227.1"> {
        logger = slog.New(slog.NewJSONHandler(io.Discard, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3228.1">nil</span></span><span class="koboSpan" id="kobo.3229.1">))
    }
    slog.SetDefault(logger)
    s := fmt.Sprintf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3230.1">"%d records in total."</span></span><span class="koboSpan" id="kobo.3231.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3232.1">len</span></span><span class="koboSpan" id="kobo.3233.1">(data))
    logger.Info(s)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3234.1">The previous code deals with logging based on the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3235.1">disableLogging</span></code><span class="koboSpan" id="kobo.3236.1">, which is based on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3237.1">--log</span></code><span class="koboSpan" id="kobo.3238.1"> flag.</span></p>
<h2 class="heading-2" id="_idParaDest-215"><span class="koboSpan" id="kobo.3239.1">Implementing the insert command</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3240.1">The</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.3241.1"> implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3242.1">insert</span></code><span class="koboSpan" id="kobo.3243.1"> command is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3244.1">var</span></span><span class="koboSpan" id="kobo.3245.1"> insertCmd = &amp;cobra.Command{
    Use:   </span><span class="hljs-string"><span class="koboSpan" id="kobo.3246.1">"insert"</span></span><span class="koboSpan" id="kobo.3247.1">,
    Short: </span><span class="hljs-string"><span class="koboSpan" id="kobo.3248.1">"Insert command"</span></span><span class="koboSpan" id="kobo.3249.1">,
    Long: </span><span class="hljs-string"><span class="koboSpan" id="kobo.3250.1">`The insert command reads a datafile and stores</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3251.1">    its data into the application in JSON format.`</span></span><span class="koboSpan" id="kobo.3252.1">,
    Run: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3253.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3254.1">(cmd *cobra.Command, args []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3255.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3256.1">)</span></span><span class="koboSpan" id="kobo.3257.1"> {
        logger = slog.New(slog.NewJSONHandler(os.Stderr, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3258.1">nil</span></span><span class="koboSpan" id="kobo.3259.1">))
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3260.1">// Work with logger</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3261.1">if</span></span><span class="koboSpan" id="kobo.3262.1"> disableLogging == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3263.1">false</span></span><span class="koboSpan" id="kobo.3264.1"> {
            logger = slog.New(slog.NewJSONHandler(io.Discard, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3265.1">nil</span></span><span class="koboSpan" id="kobo.3266.1">))
        }
        slog.SetDefault(logger)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3267.1">First, we define a separate logger for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3268.1">insert</span></code><span class="koboSpan" id="kobo.3269.1"> command</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.3270.1"> based on the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3271.1">disableLogging</span></code><span class="koboSpan" id="kobo.3272.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3273.1">if</span></span><span class="koboSpan" id="kobo.3274.1"> file == </span><span class="hljs-string"><span class="koboSpan" id="kobo.3275.1">""</span></span><span class="koboSpan" id="kobo.3276.1"> {
            logger.Info(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3277.1">"Need a file to read!"</span></span><span class="koboSpan" id="kobo.3278.1">)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3279.1">return</span></span><span class="koboSpan" id="kobo.3280.1">
        }
        _, ok := index[file]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3281.1">if</span></span><span class="koboSpan" id="kobo.3282.1"> ok {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3283.1">"Found key:"</span></span><span class="koboSpan" id="kobo.3284.1">, file)
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3285.1">delete</span></span><span class="koboSpan" id="kobo.3286.1">(index, file)
        }
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3287.1">// Now, delete it from data</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3288.1">if</span></span><span class="koboSpan" id="kobo.3289.1"> ok {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3290.1">for</span></span><span class="koboSpan" id="kobo.3291.1"> i, k := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3292.1">range</span></span><span class="koboSpan" id="kobo.3293.1"> data {
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3294.1">if</span></span><span class="koboSpan" id="kobo.3295.1"> k.Filename == file {
                    data = slices.Delete(data, i, i+</span><span class="hljs-number"><span class="koboSpan" id="kobo.3296.1">1</span></span><span class="koboSpan" id="kobo.3297.1">)
                    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3298.1">break</span></span><span class="koboSpan" id="kobo.3299.1">
                }
            }
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3300.1">Then, the previous code makes sure that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3301.1">file</span></code><span class="koboSpan" id="kobo.3302.1"> variable, which is the path to the file that contains the data, is not empty. </span><span class="koboSpan" id="kobo.3302.2">Additionally, if </span><code class="inlineCode"><span class="koboSpan" id="kobo.3303.1">file</span></code><span class="koboSpan" id="kobo.3304.1"> is a key of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3305.1">index</span></code><span class="koboSpan" id="kobo.3306.1"> map, it means that we have processed that file previously—</span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.3307.1">we assume that no two datasets have the same filename, as for us, the filename is what uniquely identifies the datasets</span></strong><span class="koboSpan" id="kobo.3308.1">. </span><span class="koboSpan" id="kobo.3308.2">In that case, we delete it from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3309.1">data</span></code><span class="koboSpan" id="kobo.3310.1"> slice and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3311.1">index</span></code><span class="koboSpan" id="kobo.3312.1"> map, and we process it again. </span><span class="koboSpan" id="kobo.3312.2">This is similar to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3313.1">update</span></code><span class="koboSpan" id="kobo.3314.1"> functionality, which is not directly supported by the application.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3315.1">        err := ProcessFile(file)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3316.1">if</span></span><span class="koboSpan" id="kobo.3317.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3318.1">nil</span></span><span class="koboSpan" id="kobo.3319.1"> {
            s := fmt.Sprintf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3320.1">"Error processing: %s"</span></span><span class="koboSpan" id="kobo.3321.1">, err)
            logger.Warn(s)
        }
        err = saveJSONFile(JSONFILE)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3322.1">if</span></span><span class="koboSpan" id="kobo.3323.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3324.1">nil</span></span><span class="koboSpan" id="kobo.3325.1"> {
            s := fmt.Sprintf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3326.1">"Error saving data: %s"</span></span><span class="koboSpan" id="kobo.3327.1">, err)
            logger.Info(s)
        }
    },
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3328.1">The last part of the implementation</span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.3329.1"> of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3330.1">insert</span></code><span class="koboSpan" id="kobo.3331.1"> command is about processing the given file, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3332.1">ProcessFile()</span></code><span class="koboSpan" id="kobo.3333.1">, and saving the updated version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3334.1">data</span></code><span class="koboSpan" id="kobo.3335.1"> slice, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3336.1">saveJSONFile()</span></code><span class="koboSpan" id="kobo.3337.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-216"><span class="koboSpan" id="kobo.3338.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3339.1">This chapter was about working with environment variables, command line arguments, reading and writing plain text files, traversing file systems, working with JSON data, and creating powerful command line utilities using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3340.1">cobra</span></code><span class="koboSpan" id="kobo.3341.1">. </span><span class="koboSpan" id="kobo.3341.2">This is one of the most important chapters of this book because you cannot create any real-world utility without interacting with the operating system as well as the file system, and without reading and saving data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3342.1">The next chapter is about concurrency in Go, with the main subjects being goroutines, channels, and data sharing with safety. </span><span class="koboSpan" id="kobo.3342.2">We are also going to talk about UNIX signal handling, as Go uses channels and goroutines for this purpose.</span></p>
<h1 class="heading-1" id="_idParaDest-217"><span class="koboSpan" id="kobo.3343.1">Exercises</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3344.1">Use the functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3345.1">byCharacter.go</span></code><span class="koboSpan" id="kobo.3346.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3347.1">byLine.go</span></code><span class="koboSpan" id="kobo.3348.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3349.1">byWord.go</span></code><span class="koboSpan" id="kobo.3350.1"> in order to create a simplified version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3351.1">wc(1)</span></code><span class="koboSpan" id="kobo.3352.1"> UNIX utility.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3353.1">Create a full version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3354.1">wc(1)</span></code><span class="koboSpan" id="kobo.3355.1"> UNIX utility, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3356.1">viper</span></code><span class="koboSpan" id="kobo.3357.1"> package to process command line options.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3358.1">Create a full version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3359.1">wc(1)</span></code><span class="koboSpan" id="kobo.3360.1"> UNIX utility, using commands instead of command line options, with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3361.1">cobra</span></code><span class="koboSpan" id="kobo.3362.1"> package.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3363.1">Go offers </span><code class="inlineCode"><span class="koboSpan" id="kobo.3364.1">bufio.Scanner</span></code><span class="koboSpan" id="kobo.3365.1"> to read files line by line. </span><span class="koboSpan" id="kobo.3365.2">Try to rewrite </span><code class="inlineCode"><span class="koboSpan" id="kobo.3366.1">byLine.go</span></code><span class="koboSpan" id="kobo.3367.1"> using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3368.1">bufio.Scanner</span></code><span class="koboSpan" id="kobo.3369.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3370.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3371.1">bufio.Scanner</span></code><span class="koboSpan" id="kobo.3372.1"> in Go is designed to read input line by line, splitting it into tokens. </span><span class="koboSpan" id="kobo.3372.2">If you need to read a file character by character, a common approach is to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3373.1">bufio.NewReader</span></code><span class="koboSpan" id="kobo.3374.1"> in conjunction with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3375.1">Read()</span></code><span class="koboSpan" id="kobo.3376.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3377.1">ReadRune()</span></code><span class="koboSpan" id="kobo.3378.1">. </span><span class="koboSpan" id="kobo.3378.2">Implement the functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3379.1">byCharacter.go</span></code><span class="koboSpan" id="kobo.3380.1"> this way.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3381.1">Make </span><code class="inlineCode"><span class="koboSpan" id="kobo.3382.1">ioFS.go</span></code><span class="koboSpan" id="kobo.3383.1"> a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3384.1">cobra</span></code><span class="koboSpan" id="kobo.3385.1"> project.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3386.1">Update the statistics application </span><code class="inlineCode"><span class="koboSpan" id="kobo.3387.1">cobra</span></code><span class="koboSpan" id="kobo.3388.1"> project in order to also store the normalized version of the dataset in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3389.1">data.json</span></code><span class="koboSpan" id="kobo.3390.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3391.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3392.1">byLine.go</span></code><span class="koboSpan" id="kobo.3393.1"> utility uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.3394.1">ReadString('\n')</span></code><span class="koboSpan" id="kobo.3395.1"> to read the input file. </span><span class="koboSpan" id="kobo.3395.2">Modify the code to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3396.1">Scanner</span></code><span class="koboSpan" id="kobo.3397.1"> (</span><a href="https://pkg.go.dev/bufio#Scanner"><span class="url"><span class="koboSpan" id="kobo.3398.1">https://pkg.go.dev/bufio#Scanner</span></span></a><span class="koboSpan" id="kobo.3399.1">) for reading.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3400.1">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3401.1">byWord.go</span></code><span class="koboSpan" id="kobo.3402.1"> uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.3403.1">ReadString('\n')</span></code><span class="koboSpan" id="kobo.3404.1"> to read the input file. </span><span class="koboSpan" id="kobo.3404.2">Modify the code to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3405.1">Scanner</span></code><span class="koboSpan" id="kobo.3406.1"> instead.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-218"><span class="koboSpan" id="kobo.3407.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3408.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3409.1">viper</span></code><span class="koboSpan" id="kobo.3410.1"> package: </span><a href="https://github.com/spf13/viper"><span class="url"><span class="koboSpan" id="kobo.3411.1">https://github.com/spf13/viper</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3412.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3413.1">cobra</span></code><span class="koboSpan" id="kobo.3414.1"> package: </span><a href="https://github.com/spf13/cobra"><span class="url"><span class="koboSpan" id="kobo.3415.1">https://github.com/spf13/cobra</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3416.1">The documentation for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3417.1">encoding/json</span></code><span class="koboSpan" id="kobo.3418.1">: </span><a href="https://pkg.go.dev/encoding/json"><span class="url"><span class="koboSpan" id="kobo.3419.1">https://pkg.go.dev/encoding/json</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3420.1">The documentation for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3421.1">io/fs</span></code><span class="koboSpan" id="kobo.3422.1">: </span><a href="https://pkg.go.dev/io/fs"><span class="url"><span class="koboSpan" id="kobo.3423.1">https://pkg.go.dev/io/fs</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3424.1">Go </span><code class="inlineCode"><span class="koboSpan" id="kobo.3425.1">slog</span></code><span class="koboSpan" id="kobo.3426.1"> package: </span><a href="http://gopherguides.com/articles/golang-slog-package"><span class="url"><span class="koboSpan" id="kobo.3427.1">http://gopherguides.com/articles/golang-slog-package</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3428.1">A comprehensive guide to logging in Go with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3429.1">slog</span></code><span class="koboSpan" id="kobo.3430.1">: </span><a href="https://betterstack.com/community/guides/logging/logging-in-go/"><span class="url"><span class="koboSpan" id="kobo.3431.1">https://betterstack.com/community/guides/logging/logging-in-go/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3432.1">Endian-ness: </span><a href="https://en.wikipedia.org/wiki/Endianness "><span class="url"><span class="koboSpan" id="kobo.3433.1">https://en.wikipedia.org/wiki/Endianness</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.3434.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3435.1">Join our community’s Discord space for discussions with the authors and other readers:</span></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.3436.1">https://discord.gg/FzuQbc8zd6</span></span></a></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.3437.1"><img alt="" role="presentation" src="../Images/QR_Code2286825896190168453.png"/></span></span></a></p>
</div>
</body></html>