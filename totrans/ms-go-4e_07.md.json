["```go\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n} \n```", "```go\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n} \n```", "```go\npackage main\nimport (\n    \"bufio\"\n\"fmt\"\n\"io\"\n) \n```", "```go\ntype S1 struct {\n    F1 int\n    F2 string\n}\ntype S2 struct {\n    F1   S1\n    text []byte\n} \n```", "```go\n// Using pointer to S1 for changes to be persistent\nfunc (s *S1) Read(p []byte) (n int, err error) {\n    fmt.Print(\"Give me your name: \")\n    fmt.Scanln(&p)\n    s.F2 = string(p)\n    return len(p), nil\n} \n```", "```go\nfunc (s *S1) Write(p []byte) (n int, err error) {\n    if s.F1 < 0 {\n        return -1, nil\n    }\n    for i := 0; i < s.F1; i++ {\n        fmt.Printf(\"%s \", p)\n    }\n    fmt.Println()\n    return s.F1, nil\n} \n```", "```go\nfunc (s S2) eof() bool {\n    return len(s.text) == 0\n}\nfunc (s *S2) readByte() byte {\n    // this function assumes that eof() check was done before\n    temp := s.text[0]\n    s.text = s.text[1:]\n    return temp\n} \n```", "```go\nfunc (s *S2) Read(p []byte) (n int, err error) {\n    if s.eof() {\n        err = io.EOF\n        return 0, err\n    }\n    l := len(p)\n    if l > 0 {\n        for n < l {\n            p[n] = s.readByte()\n            n++\n            if s.eof() {\n                s.text = s.text[0:0]\n                break\n            }\n        }\n    }\n    return n, nil\n} \n```", "```go\nfunc main() {\n    s1var := S1{4, \"Hello\"}\n    fmt.Println(s1var) \n```", "```go\n buf := make([]byte, 2)\n    _, err := s1var.Read(buf) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"Read:\", s1var.F2)\n    _, _ = s1var.Write([]byte(\"Hello There!\")) \n```", "```go\n s2var := S2{F1: s1var, text: []byte(\"Hello world!!\")} \n```", "```go\n // Read s2var.text\n    r := bufio.NewReader(&s2var) \n```", "```go\n for {\n        n, err := r.Read(buf)\n        if err == io.EOF {\n            break \n```", "```go\n } else if err != nil {\n            fmt.Println(\"*\", err)\n            break\n        }\n        fmt.Println(\"**\", n, string(buf[:n]))\n    }\n} \n```", "```go\n$ go run ioInterface.go\n{4 Hello} \n```", "```go\nGive me your name: Mike\nCalling the Read() method of the s1var variable.\nRead: Mike\nHello There! Hello There! Hello There! Hello There!\nThe previous line is the output of s1var.Write([]byte(\"Hello There!\")).\n** 2 He\n** 2 ll\n** 2 o \n** 2 wo\n** 2 rl\n** 2 d!\n** 1 ! \n```", "```go\nfunc lineByLine(file string) error {\n    f, err := os.Open(file)\n    if err != nil {\n        return err\n    }\n    defer f.Close()\n    r := bufio.NewReader(f) \n```", "```go\n for {\n        line, err := r.ReadString('\\n') \n```", "```go\n if err == io.EOF {\n            if len(line) != 0 {\n                    fmt.Println(line)\n            }\n            break\n        }\n        if err != nil {\n            fmt.Printf(\"error reading file %s\", err)\n            return err\n        }\n        fmt.Print(line) \n```", "```go\n }\n    return nil\n} \n```", "```go\n$ go run byLine.go ~/csv.data\nDimitris,Tsoukalos,2101112223,1600665563\nMihalis,Tsoukalos,2109416471,1600665563\nJane,Doe,0800123456,1608559903 \n```", "```go\nfunc wordByWord(file string) error {\n    f, err := os.Open(file)\n    if err != nil {\n        return err\n    }\n    defer f.Close()\n    r := bufio.NewReader(f)\n    re := regexp.MustCompile(\"[^\\\\s]+\")\n    for { \n```", "```go\n line, err := r.ReadString('\\n')\n        if err == io.EOF {\n            if len(line) != 0 {\n                words := re.FindAllString(line, -1)\n                for i := 0; i < len(words); i++ {\n                    fmt.Println(words[i])\n                }\n            }\n            break \n```", "```go\n } else if err != nil {\n            fmt.Printf(\"error reading file %s\", err)\n            return err\n        } \n```", "```go\n words := re.FindAllString(line, -1) \n```", "```go\n for i := 0; i < len(words); i++ {\n            fmt.Println(words[i])\n        } \n```", "```go\n }\n    return nil\n} \n```", "```go\n$ go run byWord.go ~/csv.data\nDimitris,Tsoukalos,2101112223,1600665563\nMihalis,Tsoukalos,2109416471,1600665563\nJane,Doe,0800123456,1608559903 \n```", "```go\nfunc charByChar(file string) error {\n  f, err := os.Open(file)\n  if err != nil {\n    return err\n  }\n  defer f.Close()\n  r := bufio.NewReader(f)\n  for {\n    line, err := r.ReadString('\\n')\n    if err == io.EOF {\n      if **len****(line) !=** **0** {\n        for _, x := range line {\n          fmt.Println(string(x))\n        } \n```", "```go\n }\n      break\n    } else if err != nil {\n      fmt.Printf(\"error reading file %s\", err)\n      return err\n    }\n    for _, x := range line {\n      fmt.Println(string(x))\n    }\n  }\n  return nil\n} \n```", "```go\n$ go run byCharacter.go ~/csv.data | head\nD\n...\n,\nT \n```", "```go\npackage main\nimport (\n    \"encoding/binary\"\n\"fmt\"\n\"os\"\n) \n```", "```go\nfunc main() {\n    f, err := os.Open(\"/dev/random\")\n    defer f.Close()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    var seed int64\n    binary.Read(f, binary.LittleEndian, &seed)\n    fmt.Println(\"Seed:\", seed)\n} \n```", "```go\n$ go run devRandom.go\nSeed: 422907465220227415 \n```", "```go\nfunc readSize(f *os.File, size int) []byte {\n    buffer := make([]byte, size)\n    n, err := f.Read(buffer) \n```", "```go\n // io.EOF is a special case and is treated as such\nif err == io.EOF {\n        return nil\n    }\n    if err != nil {\n        fmt.Println(err)\n        return nil\n    }\n    return buffer[0:n]\n} \n```", "```go\n$ go run readSize.go 12 readSize.go\npackage main \n```", "```go\npackage main\nimport (\n    \"bufio\"\n\"fmt\"\n\"io\"\n\"os\"\n)\nfunc main() {\n    buffer := []byte(\"Data to write\\n\")\n    f1, err := os.Create(\"/tmp/f1.txt\") \n```", "```go\n if err != nil {\n        fmt.Println(\"Cannot create file\", err)\n        return\n    }\n    defer f1.Close()\n    fmt.Fprintf(f1, string(buffer)) \n```", "```go\n f2, err := os.Create(\"/tmp/f2.txt\")\n    if err != nil {\n        fmt.Println(\"Cannot create file\", err)\n        return\n    }\n    defer f2.Close()\n    n, err := f2.WriteString(string(buffer)) \n```", "```go\n fmt.Printf(\"wrote %d bytes\\n\", n)\n    f3, err := os.Create(\"/tmp/f3.txt\") \n```", "```go\n if err != nil {\n        fmt.Println(err)\n        return\n    }\n    w := bufio.NewWriter(f3) \n```", "```go\n n, err = w.WriteString(string(buffer))\n    fmt.Printf(\"wrote %d bytes\\n\", n)\n    w.Flush()\n    f := \"/tmp/f4.txt\"\n    f4, err := os.Create(f)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer f4.Close()\n    for i := 0; i < 5; i++ {\n        n, err = io.WriteString(f4, string(buffer))\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        fmt.Printf(\"wrote %d bytes\\n\", n)\n    }\n    // Append to a file\n    f4, err = os.OpenFile(f, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer f4.Close()\n    // Write() needs a byte slice\n    n, err = f4.Write([]byte(\"Put some more data at the end.\\n\")) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Printf(\"wrote %d bytes\\n\", n)\n} \n```", "```go\n$ ls -l /tmp/f?.txt\n-rw-r--r--@ 1 mtsouk  wheel   14 Aug  5 11:30 /tmp/f1.txt\n-rw-r--r--@ 1 mtsouk  wheel   14 Aug  5 11:30 /tmp/f2.txt\n-rw-r--r--@ 1 mtsouk  wheel   14 Aug  5 11:30 /tmp/f3.txt\n-rw-r--r--@ 1 mtsouk  wheel  101 Aug  5 11:30 /tmp/f4.txt \n```", "```go\npackage main\nimport (\n    \"encoding/json\"\n\"fmt\"\n)\ntype UseAll struct {\n    Name    string `json:\"username\"`\n    Surname string `json:\"surname\"`\n    Year    int `json:\"created\"`\n} \n```", "```go\nfunc main() {\n    useall := UseAll{Name: \"Mike\", Surname: \"Tsoukalos\", Year: 2023}\n    // Encoding JSON data: Convert Structure to JSON record with fields\n    t, err := json.Marshal(&useall) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Printf(\"Value %s\\n\", t)\n    }\n    // Decoding JSON data given as a string\n    str := `{\"username\": \"M.\", \"surname\": \"Ts\", \"created\":2024}` \n```", "```go\n // Convert string into a byte slice\n    jsonRecord := []byte(str) \n```", "```go\n // Create a structure variable to store the result\n    temp := UseAll{}\n    err = json.Unmarshal(jsonRecord, &temp) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Printf(\"Data type: %T with value %v\\n\", temp, temp)\n    }\n} \n```", "```go\n$ go run encodeDecode.go\nValue {\"username\":\"Mike\",\"surname\":\"Tsoukalos\",\"created\":2023}\nData type: main.UseAll with value {M. Ts 2024} \n```", "```go\n// Ignoring empty fields in JSON\ntype NoEmpty struct {\n    Name    string `json:\"username\"`\n    Surname string `json:\"surname\"`\n    Year    int `json:\"creationyear,omitempty\"`\n} \n```", "```go\n// Removing private fields and ignoring empty fields\ntype Password struct {\n    Name     string `json:\"username\"`\n    Surname  string `json:\"surname,omitempty\"`\n    Year     int `json:\"creationyear,omitempty\"`\n    Pass     string `json:\"-\"`\n} \n```", "```go\n$ go run tagsJSON.go\nnoEmptyVar decoded with value {username\":\"Mihalis\",\"surname\":\"\"}\npassword decoded with value {\"username\":\"Mihalis\"} \n```", "```go\n// DeSerialize decodes a serialized slice with JSON records\nfunc DeSerialize(e *json.Decoder, slice interface{}) error {\n    return e.Decode(slice)\n} \n```", "```go\n// Serialize serializes a slice with JSON records\nfunc Serialize(e *json.Encoder, slice interface{}) error {\n    return e.Encode(slice)\n} \n```", "```go\n$ go run JSONstreams.go\nAfter Serialize:[{\"key\":\"RESZD\",\"value\":63},{\"key\":\"XUEYA\",\"value\":13}]\nAfter DeSerialize:\n0 {RESZD 63}\n1 {XUEYA 13} \n```", "```go\nfunc PrettyPrint(v interface{}) (err error) {\n    b, err := json.MarshalIndent(v, \"\", \"\\t\")\n    if err == nil {\n        fmt.Println(string(b))\n    }\n    return err\n} \n```", "```go\nfunc JSONstream(data interface{}) (string, error) {\n  buffer := new(bytes.Buffer)\n  encoder := json.NewEncoder(buffer)\n  encoder.SetIndent(\"\", \"\\t\") \n```", "```go\n err := encoder.Encode(data)\n  if err != nil {\n    return \"\", err\n  }\n  return buffer.String(), nil\n} \n```", "```go\nLast record: {YJOML 63}\n{\n    \"key\": \"YJOML\",\n    \"value\": 63\n}\n[\n    {\n        \"key\": \"HXNIG\",\n        \"value\": 79\n    },\n    {\n        \"key\": \"YJOML\",\n        \"value\": 63\n    }\n] \n```", "```go\n$ go mod init\n$ go mod tidy \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"github.com/spf13/pflag\"\n\"github.com/spf13/viper\"\n) \n```", "```go\nfunc aliasNormalizeFunc(f *pflag.FlagSet, n string) pflag.NormalizedName {\n    switch n {\n    case \"pass\":\n        n = \"password\"\nbreak\ncase \"ps\":\n        n = \"password\"\nbreak\n    }\n    return pflag.NormalizedName(n)\n} \n```", "```go\nfunc main() {\n    pflag.StringP(\"name\", \"n\", \"Mike\", \"Name parameter\") \n```", "```go\n pflag.StringP(\"password\", \"p\", \"hardToGuess\", \"Password\")\n    pflag.CommandLine.SetNormalizeFunc(aliasNormalizeFunc) \n```", "```go\n pflag.Parse()\n    viper.BindPFlags(pflag.CommandLine) \n```", "```go\n name := viper.GetString(\"name\")\n    password := viper.GetString(\"password\") \n```", "```go\n fmt.Println(name, password)\n    // Reading an Environment variable\n    viper.BindEnv(\"GOMAXPROCS\")\n    val := viper.Get(\"GOMAXPROCS\")\n    if val != nil {\n        fmt.Println(\"GOMAXPROCS:\", val)\n    } \n```", "```go\n // Setting an Environment variable\n    viper.Set(\"GOMAXPROCS\", 16)\n    val = viper.Get(\"GOMAXPROCS\")\n    fmt.Println(\"GOMAXPROCS:\", val)\n} \n```", "```go\n$ go build useViper.go\n$ ./useViper.go --help\nUsage of ./useViper:\n  -n, --name string       Name parameter (default \"Mike\")\n  -p, --password string   Password (default \"hardToGuess\")\npflag: help requested\nexit status 2 \n```", "```go\n$ go run useViper.go\nMike hardToGuess\nGOMAXPROCS: 16 \n```", "```go\n$ go run useViper.go -n mtsouk -p d1ff1cultPAssw0rd\nmtsouk d1ff1cultPAssw0rd\nGOMAXPROCS: 16 \n```", "```go\npackage main\nimport (\n    \"encoding/json\"\n\"fmt\"\n\"os\"\n\"github.com/spf13/viper\"\n)\ntype ConfigStructure struct {\n    MacPass     string `mapstructure:\"macos\"`\n    LinuxPass   string `mapstructure:\"linux\"`\n    WindowsPass string `mapstructure:\"windows\"`\n    PostHost    string `mapstructure:\"postgres\"`\n    MySQLHost   string `mapstructure:\"mysql\"`\n    MongoHost   string `mapstructure:\"mongodb\"`\n} \n```", "```go\nvar **CONFIG** = \".config.json\"\nfunc main() {\n    if len(os.Args) == 1 {\n        fmt.Println(\"Using default file\", CONFIG)\n    } else {\n        CONFIG = os.Args[1]\n    }\n    viper.SetConfigType(\"json\")\n    viper.SetConfigFile(CONFIG)\n    fmt.Printf(\"Using config: %s\\n\", viper.ConfigFileUsed())\n    viper.ReadInConfig() \n```", "```go\n if viper.IsSet(\"macos\") {\n        fmt.Println(\"macos:\", viper.Get(\"macos\"))\n    } else {\n        fmt.Println(\"macos not set!\")\n    } \n```", "```go\n if viper.IsSet(\"active\") {\n        value := viper.GetBool(\"active\")\n        if value {\n            postgres := viper.Get(\"postgres\")\n            mysql := viper.Get(\"mysql\")\n            mongo := viper.Get(\"mongodb\")\n            fmt.Println(\"P:\", postgres, \"My:\", mysql, \"Mo:\", mongo)\n        }\n    } else {\n        fmt.Println(\"active is not set!\")\n    } \n```", "```go\n if !viper.IsSet(\"DoesNotExist\") {\n        fmt.Println(\"DoesNotExist is not set!\")\n    } \n```", "```go\n var t ConfigStructure\n    err := viper.Unmarshal(&t)\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n PrettyPrint(t)\n} \n```", "```go\n$ go mod init\n$ go mod tidy \n```", "```go\n$ ls -l\ntotal 120\n-rw-r--r--@ 1 mtsouk  staff    745 Aug 21 18:21 go.mod\n-rw-r--r--@ 1 mtsouk  staff  48357 Aug 21 18:21 go.sum\n-rw-r--r--@ 1 mtsouk  staff   1418 Aug  3 07:51 jsonViper.go\n-rw-r--r--@ 1 mtsouk  staff    188 Aug 21 18:20 myConfig.json \n```", "```go\n{\n\"macos\": \"pass_macos\",\n\"linux\": \"pass_linux\",\n\"windows\": \"pass_windows\",\n\"active\": true,\n\"postgres\": \"machine1\",\n\"mysql\": \"machine2\",\n\"mongodb\": \"machine3\"\n} \n```", "```go\n$ go run jsonViper.go myConfig.json\nUsing config: myConfig.json\nmacos: pass_macos\nP: machine1 My: machine2 Mo: machine3\nDoesNotExist is not set!\n{\n  \"MacPass\": \"pass_macos\",\n  \"LinuxPass\": \"pass_linux\",\n  \"WindowsPass\": \"pass_windows\",\n  \"PostHost\": \"machine1\",\n  \"MySQLHost\": \"machine2\",\n  \"MongoHost\": \"machine3\"\n} \n```", "```go\n$ GO111MODULE=on go install github.com/spf13/cobra-cli@latest \n```", "```go\n$ cd ~/go/src/github.com/mactsouk/mGo4th/ch07/\n$ mkdir go-cobra # only required if the directory is not there\n$ cd go-cobra\n$ go mod init\ngo: creating new go.mod: module github.com/mactsouk/mGo4th/ch07/go-cobra\n$ ~/go/bin/cobra init\nUsing config file: /Users/mtsouk/.cobra.yaml\nYour Cobra application is ready at\n/Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra\n$ go mod tidy\ngo: finding module for package github.com/spf13/viper\ngo: finding module for package github.com/spf13/cobra\ngo: downloading github.com/spf13/cobra v1.7.0\n...\ngo: downloading github.com/rogpeppe/go-internal v1.9.0\ngo: downloading github.com/kr/text v0.2.0 \n```", "```go\n$ go run main.go\nA longer description that spans multiple lines and likely contains\nexamples and usage of using your application. For example:\nCobra is a CLI library for Go that empowers applications.\nThis application is a tool to generate the needed files\nto quickly create a Cobra application. \n```", "```go\n$ ~/go/bin/cobra add one\nUsing config file: /Users/mtsouk/.cobra.yaml\none created at /Users/mtsouk/go/src/github.com/mactsouk/go-cobra\n$ ~/go/bin/cobra add two \n$ ~/go/bin/cobra add three \n```", "```go\nrootCmd.PersistentFlags().StringP(\"directory\", \"d\", \"/tmp\", \"Path\")\nrootCmd.PersistentFlags().Uint(\"depth\", 2, \"Depth of search\")\nviper.BindPFlag(\"directory\", rootCmd.PersistentFlags().Lookup(\"directory\"))\nviper.BindPFlag(\"depth\", rootCmd.PersistentFlags().Lookup(\"depth\")) \n```", "```go\ntwoCmd.Flags().StringP(\"username\", \"u\", \"Mike\", \"Username\") \n```", "```go\nvar oneCmd = &cobra.Command{\n    Use:     \"one\",\n    Aliases: []string{\"cmd1\"},\n    Short:   \"Command one\", \n```", "```go\n$ ~/go/bin/cobra add list -p 'threeCmd'\nUsing config file: /Users/mtsouk/.cobra.yaml\nlist created at /Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra\n$ ~/go/bin/cobra add delete -p 'threeCmd'\nUsing config file: /Users/mtsouk/.cobra.yaml\ndelete created at /Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra \n```", "```go\n$ go run main.go three delete\ndelete called\n$ go run main.go three list\nlist called \n```", "```go\n$ tree\n.\n├── LICENSE\n├── cmd\n│   ├── delete.go\n│   ├── list.go\n│   ├── one.go\n│   ├── root.go\n│   ├── three.go\n│   └── two.go\n├── go.mod\n├── go.sum\n└── main.go\n2 directories, 10 files \n```", "```go\npackage main\nimport (\n    _ \"embed\"\n\"fmt\"\n\"os\"\n) \n```", "```go\n//go:embed static/image.png\nvar f1 []byte \n```", "```go\n//go:embed static/textfile\nvar f2 string \n```", "```go\nfunc writeToFile(s []byte, path string) error {\n    fd, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY, 0644)\n    if err != nil {\n        return err\n    }\n    defer fd.Close()\n    n, err := fd.Write(s)\n    if err != nil {\n        return err\n    }\n    fmt.Printf(\"wrote %d bytes\\n\", n)\n    return nil\n} \n```", "```go\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Print select 1|2\")\n        return\n    }\n    fmt.Println(\"f1:\", len(f1), \"f2:\", len(f2)) \n```", "```go\n switch arguments[1] {\n    case \"1\":\n        filename := \"/tmp/temporary.png\"\n        err := writeToFile(f1, filename)\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n    case \"2\":\n        fmt.Print(f2)\n    default:\n        fmt.Println(\"Not a valid option!\")\n    }\n} \n```", "```go\n$ ./embedFiles 2\nf1: 75072 f2: 14\nData to write\n$ ./embedFiles 1\nf1: 75072 f2: 14\nwrote 75072 bytes \n```", "```go\n$ ls -l /tmp/temporary.png \n-rw-r--r--  1 mtsouk  wheel  75072 Feb 25 15:20 /tmp/temporary.png \n```", "```go\npackage main\nimport (\n    _ \"embed\"\n\"fmt\"\n)\n//go:embed printSource.go\nvar src string\nfunc main() {\n    fmt.Print(src)\n} \n```", "```go\nfunc GetSize(path string) (int64, error) {\n    contents, err := os.ReadDir(path)\n    if err != nil {\n        return -1, err\n    }\n    var total int64\nfor _, entry := range contents {\n        // Visit directory entries\nif entry.IsDir() { \n```", "```go\n temp, err := GetSize(filepath.Join(path, entry.Name()))\n            if err != nil {\n                return -1, err\n            }\n            total += temp\n            // Get size of each non-directory entry\n        } else { \n```", "```go\n info, err := entry.Info()\n            if err != nil {\n                return -1, err\n            }\n            // Returns an int64 value\n            total += info.Size()\n        }\n    }\n    return total, nil\n} \n```", "```go\n$ go run ReadDirEntry.go /usr/bin\nTotal Size: 240527817 \n```", "```go\nfunc list(f embed.FS) error {\n    return fs.WalkDir(f, \".\", walkFunction)\n} \n```", "```go\nfunc walkFunction(path string, d fs.DirEntry, err error) error {\n    if err != nil {\n        return err\n    }\n    fmt.Printf(\"Path=%q, isDir=%v\\n\", path, d.IsDir())\n    return nil\n} \n```", "```go\nfunc extract(f embed.FS, filepath string) ([]byte, error) {\n    s, err := fs.ReadFile(f, filepath)\n    if err != nil {\n        return nil, err\n    }\n    return s, nil\n} \n```", "```go\nfunc walkSearch(path string, d fs.DirEntry, err error) error {\n    if err != nil {\n        return err\n    }\n    if d.Name() == searchString { \n```", "```go\n fileInfo, err := fs.Stat(f, path)\n        if err != nil {\n            return err\n        }\n        fmt.Println(\"Found\", path, \"with size\", fileInfo.Size())\n        return nil\n    } \n```", "```go\n return nil\n} \n```", "```go\n$ go run ioFS.go\nPath=\".\", isDir=true\nPath=\"static\", isDir=true\nPath=\"static/file.txt\", isDir=false\nPath=\"static/image.png\", isDir=false\nPath=\"static/textfile\", isDir=false\nFound static/file.txt with size 14\nwrote 14 bytes \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"log/slog\"\n\"os\"\n)\nfunc main() {\n    slog.Error(\"This is an ERROR message\")\n    slog.Debug(\"This is a DEBUG message\")\n    slog.Info(\"This ia an INFO message\")\n    slog.Warn(\"This is a WARNING message\") \n```", "```go\n logLevel := &slog.LevelVar{}\n    fmt.Println(\"Log level:\", logLevel)\n    // Text Handler\n    opts := &slog.HandlerOptions{\n        Level: logLevel,\n    }\n    handler := slog.NewTextHandler(os.Stdout, opts)\n    logger := slog.New(handler)\n    logLevel.Set(slog.LevelDebug)\n    logger.Debug(\"This is a DEBUG message\") \n```", "```go\n // JSON Handler\n    logJSON := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logJSON.Error(\"ERROR message in JSON\")\n} \n```", "```go\n$ go run useSLog.go\n2023/08/22 21:49:18 ERROR This is an ERROR message\n2023/08/22 21:49:18 INFO This ia an INFO message\n2023/08/22 21:49:18 WARN This is a WARNING message \n```", "```go\nLog level: LevelVar(INFO)\ntime=2023-08-22T21:49:18.474+03:00 level=DEBUG msg=\"This is a DEBUG message\" \n```", "```go\n{\"time\":\"2023-08-22T21:49:18.474392+03:00\",\"level\":\"ERROR\",\"msg\":\"ERROR message in JSON\"} \n```", "```go\nfunc main() {\n    if len(os.Args) == 1 {\n        log.Println(\"Enabling logging!\")\n        log.SetOutput(os.Stderr)\n    } else {\n        log.SetOutput(os.Stderr)\n        log.Println(\"Disabling logging!\")\n        **log.SetOutput(io.Discard)**\n        log.Println(\"NOT GOING TO GET THAT!\")\n    }\n} \n```", "```go\n$ go run discard.go\n2023/08/22 21:35:17 Enabling logging!\n$ go run discard.go 1\n2023/08/22 21:35:21 Disabling logging! \n```", "```go\n$ cd ~/go/src/github.com/mactsouk/mGo4th/ch07/stats \n```", "```go\n$ go mod init\ngo: creating new go.mod: module github.com/mactsouk/mGo4th/ch07/stats \n```", "```go\n$ ~/go/bin/cobra init\nUsing config file: /Users/mtsouk/.cobra.yaml\nYour Cobra application is ready at\n/Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch07/stats \n```", "```go\n$ go mod tidy \n```", "```go\n$ ~/go/bin/cobra add list\n$ ~/go/bin/cobra add delete\n$ ~/go/bin/cobra add insert\n$ ~/go/bin/cobra add search \n```", "```go\nrootCmd.PersistentFlags().BoolVarP(&disableLogging, \"log\", \"l\", false, \"Logging information\") \n```", "```go\nvar disableLogging bool \n```", "```go\nfunc saveJSONFile(filepath string) error {\n    f, err := os.Create(filepath)\n    if err != nil {\n        return err\n    }\n    defer f.Close()\n    err = Serialize(&data, f)\n    return err\n} \n```", "```go\nfunc readJSONFile(filepath string) error {\n    _, err := os.Stat(filepath)\n    if err != nil {\n        return err\n    }\n    f, err := os.Open(filepath)\n    if err != nil {\n        return err\n    }\n    defer f.Close()\n    err = DeSerialize(&data, f)\n    if err != nil {\n        return err\n    }\n    return nil\n} \n```", "```go\nfunc list() {\n    sort.Sort(DFslice(data))\n    text, err := PrettyPrintJSONstream(data)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(text) \n```", "```go\n logger = slog.New(slog.NewJSONHandler(os.Stderr, nil))\n    if disableLogging == false {\n        logger = slog.New(slog.NewJSONHandler(io.Discard, nil))\n    }\n    slog.SetDefault(logger)\n    s := fmt.Sprintf(\"%d records in total.\", len(data))\n    logger.Info(s)\n} \n```", "```go\nvar insertCmd = &cobra.Command{\n    Use:   \"insert\",\n    Short: \"Insert command\",\n    Long: `The insert command reads a datafile and stores\n    its data into the application in JSON format.`,\n    Run: func(cmd *cobra.Command, args []string) {\n        logger = slog.New(slog.NewJSONHandler(os.Stderr, nil))\n        // Work with logger\nif disableLogging == false {\n            logger = slog.New(slog.NewJSONHandler(io.Discard, nil))\n        }\n        slog.SetDefault(logger) \n```", "```go\n if file == \"\" {\n            logger.Info(\"Need a file to read!\")\n            return\n        }\n        _, ok := index[file]\n        if ok {\n            fmt.Println(\"Found key:\", file)\n            delete(index, file)\n        }\n        // Now, delete it from data\nif ok {\n            for i, k := range data {\n                if k.Filename == file {\n                    data = slices.Delete(data, i, i+1)\n                    break\n                }\n            }\n        } \n```", "```go\n err := ProcessFile(file)\n        if err != nil {\n            s := fmt.Sprintf(\"Error processing: %s\", err)\n            logger.Warn(s)\n        }\n        err = saveJSONFile(JSONFILE)\n        if err != nil {\n            s := fmt.Sprintf(\"Error saving data: %s\", err)\n            logger.Info(s)\n        }\n    },\n} \n```"]