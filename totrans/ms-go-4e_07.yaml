- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Telling a UNIX System What to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about systems programming in Go. Systems programming involves
    working with files and directories, process control, signal handling, network
    programming, system files, configuration files, and file **input and output**
    (**I/O**). If you recall from *Chapter 1*, *A Quick Introduction to Go*, the reason
    for writing system utilities with Linux in mind is that, often, Go software is
    executed in a Docker environment—Docker images use the Linux operating system,
    which means that you might need to develop your utilities with the Linux operating
    system in mind. However, as Go code is portable, most system utilities work on
    Windows machines without any changes or with minor modifications. The key idea
    to remember is that Go makes systems programming more portable. Additionally,
    in this chapter, we are going to improve the statistics application with the help
    of the `cobra` package.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, starting with Go 1.16, the `GO111MODULE` environment variable
    defaults to `on`—this affects the use of Go packages that do not belong to the
    Go standard library. In practice, this means that you must put your code under
    `~/go/src`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stdin`, `stdout`, and `stderr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UNIX processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading plain text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `viper` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cobra` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Go features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the statistics application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stdin, stdout, and stderr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every UNIX operating system has three files open all the time for its processes.
    Remember that UNIX considers everything, even a printer or a mouse, as a file.
    UNIX uses file descriptors, which are positive integer values, as an internal
    representation to access open files, which is much prettier than using long paths.
    So, by default, all UNIX systems support three special and standard filenames:
    `/dev/stdin`, `/dev/stdout`, and `/dev/stderr`, which can also be accessed using
    the file descriptors `0`, `1`, and `2`, respectively. These three file descriptors
    are also called standard input, standard output, and standard error, respectively.
    Additionally, the file descriptor `0` can be accessed as `/dev/fd/0` on a macOS
    machine and as both `/dev/fd/0` and `/dev/pts/0` on a Debian Linux machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Go uses `os.Stdin` to access standard input, `os.Stdout` to access standard
    output, and `os.Stderr` to access standard error. Although you can still use `/dev/stdin`,
    `/dev/stdout`, and `/dev/stderr` or the related file descriptor values to access
    the same devices, it is better, safer, and more portable to stick with `os.Stdin`,
    `os.Stdout`, and `os.Stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: UNIX processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Go servers, utilities, and Docker images are mainly executed on Linux, it
    is good to know about Linux processes and threads.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, a process is an execution environment that contains instructions,
    user data and system data parts, and other types of resources that are obtained
    during runtime. On the other hand, a program is a binary file that contains instructions
    and data that are used to initialize the instruction and user data parts of a
    process. Each running UNIX process is uniquely identified by an unsigned integer,
    which is called the process ID of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three process categories: user processes, daemon processes, and kernel
    processes. User processes run in user space and usually have no special access
    rights. Daemon processes are programs that can be found in the user space and
    run in the background without the need for a terminal. Kernel processes are executed
    in kernel space only and can fully access all kernel data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: The C way of creating new processes involves the calling of the `fork(2)` system
    call. The return value of `fork(2)` allows the programmer to differentiate between
    a parent and a child process. Although you can fork a new process in Go using
    the `exec` package, Go does not allow you to control threads—Go offers goroutines,
    which the user can create on top of threads that are created and handled by the
    Go runtime, which is partially controlled by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to learn how to read and write files in Go.
  prefs: []
  type: TYPE_NORMAL
- en: File I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses file I/O in Go, which includes the use of the `io.Reader`
    and `io.Writer` interfaces, buffered and unbuffered I/O, as well as the `bufio`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The `io/ioutil` package ([https://pkg.go.dev/io/ioutil](https://pkg.go.dev/io/ioutil))
    has been deprecated since Go version 1.16\. Existing Go code that uses the functionality
    of `io/ioutil` will continue to work, but it is better to stop using that package.
  prefs: []
  type: TYPE_NORMAL
- en: The io.Reader and io.Writer interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection presents the definitions of the popular `io.Reader` and `io.Writer`
    interfaces because these two interfaces are the basis of file I/O in Go—the former
    allows you to read from a file, whereas the latter allows you to write to a file.
    The definition of the `io.Reader` interface is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition, which should be revisited when we want one of our data types
    to satisfy the `io.Reader` interface, tells us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Reader` interface requires the implementation of a single method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Read()` method takes a byte slice as input, which will be filled with data
    up to its length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Read()` method returns the number of bytes read as well as an `error` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The definition of the `io.Writer` interface is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous definition, which should be revisited when we want one of our
    data types to satisfy the `io.Writer` interface and write to a file, reveals the
    following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The interface requires the implementation of a single method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Write()` method takes a byte slice, which contains the data that you want
    to write, as input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Write()` method returns the number of bytes written and an `error` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using and misusing io.Reader and io.Writer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code that follows showcases the use of `io.Reader` and `io.Writer` for **custom
    data types**, which, in this case, are two Go structures named `S1` and `S2`.
  prefs: []
  type: TYPE_NORMAL
- en: For the `S1` structure, the presented code implements both interfaces in order
    to read user data from the terminal and print data to the terminal, respectively.
    Although this is redundant, as we already have `fmt.Scanln()` and `fmt.Printf()`,
    it is a good exercise that shows how versatile and flexible both interfaces are.
    In a different situation, you could have used `io.Writer` for writing to a log
    service, keeping a second backup copy of the written data, or anything else that
    fits your needs. However, this is also an example of interfaces allowing you to
    do crazy or, if you prefer, unusual things. It is up to the developer to create
    the desired functionality using the appropriate Go concepts and features!
  prefs: []
  type: TYPE_NORMAL
- en: The `Read()` method uses `fmt.Scanln()` to get user input from the terminal,
    whereas the `Write()` method prints the contents of its buffer parameter as many
    times as the value of the `F1` field of the structure, using `fmt.Printf()`!
  prefs: []
  type: TYPE_NORMAL
- en: For the `S2` struct, the presented code implements the `io.Reader` interface
    only, in the traditional way. The `Read()` method reads the text field of the
    `S2` structure, which is a byte slice. When there is nothing left to read, the
    `Read()` method returns the expected `io.EOF` error, which in reality is not an
    error but an expected situation. Along with the `Read()` method, there exist two
    helper methods, named `eof()`, which declares that there is nothing more to read,
    and `readByte()`, which reads the text field of the `S2` structure byte by byte.
    After the `Read()` method is done, the text field of the `S2` structure, which
    is used as a buffer, is emptied.
  prefs: []
  type: TYPE_NORMAL
- en: With this implementation, the `io.Reader` for `S2` can be used for reading in
    a traditional way, which, in this case, is with `bufio.NewReader()` and multiple
    `Read()` calls—the number of `Read()` calls depends on the size of the buffer
    that is used, which, in this case, is a byte slice with two places for data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code and save it as `ioInterface.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous part shows that we are using the `io` and `bufio` packages to work
    with files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These are the two structures we are going to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we implement the `io.Reader` interface for `S1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous method implements the `io.Writer` interface for `S1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous function is an implementation of `bytes.Buffer.ReadByte` from the
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous code reads from the given buffer until it is empty. When all data
    is read, the relevant structure field is emptied. The previous method implements
    `io.Reader` for `S2`. However, the operation of `Read()` is supported by `eof()`
    and `readByte()`, which are also user-defined.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that Go allows you to name the return values of a function; in that case,
    a `return` statement without any additional arguments automatically returns the
    current value of each named return variable in the order they appear in the function
    signature. The `Read()` method could have used that feature, but in general, naked
    returns are considered bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We initialize an `S1` variable that is named `s1var`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The previous line reads for the `s1var` variable using a buffer of two bytes.
    The block does not do what is expected because the implementation of the `Read()`
    method gets the value from the terminal—we are misusing Go interfaces here!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous line, we call the `Write()` method for `s1var` in order to write
    the contents of a byte slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we initialize an `S2` variable that is named `s2var`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We now create a reader for `s2var`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We keep reading from `s2var` until there is an `io.EOF` condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `ioInterface.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the output shows the contents of the `s1var` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the output illustrates the reading process, using a buffer
    with a size of two. The next section discusses buffered and unbuffered operations.
  prefs: []
  type: TYPE_NORMAL
- en: Buffered and unbuffered file I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Buffered file I/O* happens when there is a buffer to temporarily store data
    before reading data or writing data. Thus, instead of reading a file byte by byte,
    you read many bytes at once. You put the data in a buffer and wait for someone
    to read it in the desired way.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unbuffered file I/O* happens when there is no buffer to temporarily store
    data before reading or writing it—this can affect the performance of your programs.'
  prefs: []
  type: TYPE_NORMAL
- en: The next question that you might ask is how to decide when to use buffered and
    when to use unbuffered file I/O. When dealing with critical data, unbuffered file
    I/O is generally a better choice because buffered reads might result in out-of-date
    data, and buffered writes might result in data loss when the power of your computer
    is interrupted. However, most of the time, there is no definitive answer to that
    question. This means that you can use whatever makes your tasks easier to implement.
    However, keep in mind that buffered readers can also improve performance by reducing
    the number of system calls needed to read from a file or socket, so there can
    be a real performance impact on what the programmer decides to use.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `bufio` package. As the name suggests, `bufio` is about buffered
    I/O. Internally, the `bufio` package implements the `io.Reader` and `io.Writer`
    interfaces, which it wraps in order to create the `bufio.Reader` and `bufio.Writer`
    types, respectively. The `bufio` package is very popular for working with plain
    text files, and you are going to see it in action in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reading text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to read plain text files, as well as use
    the `/dev/random` UNIX device, which offers you a way of getting random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a text file line by line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The function to read a file line by line is found in `byLine.go` and is named
    `lineByLine()`. The technique for reading a text file line by line is also used
    when reading a plain text file word by word, as well as when reading a plain text
    file character by character because you usually process plain text files line
    by line. The presented utility prints every line that it reads, which makes it
    a simplified version of the `cat(1)` utility.
  prefs: []
  type: TYPE_NORMAL
- en: First, you create a new reader for the desired file using a call to `bufio.NewReader()`.
    Then, you use that reader with `bufio.ReadString()` in order to read the input
    file line by line. The trick is done by the parameter of `bufio.ReadString()`,
    which is a character that tells `bufio.ReadString()` to keep reading until that
    character is found. Constantly calling `bufio.ReadString()` when that parameter
    is the newline character (`\n`) results in reading the input file line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `lineByLine()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After making sure that you can open the given file for reading (`os.Open()`),
    you create a new reader using `bufio.NewReader()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`bufio.ReadString()` returns two values: the string that was read and an error
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The use of `fmt.Print()` instead of `fmt.Println()` to print the input line
    shows that the newline character is included in each input line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `byLine.go` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows the contents of `~/csv.data` (use your own plain text
    file) presented line by line with the help of `byLine.go`. The next subsection
    shows how to read a plain text file word by word.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a text file word by word
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading a plain text file word by word is one of the most useful functions that
    you want to perform on a file because you usually want to process a file on a
    per-word basis—it is illustrated in this subsection, using the code found in `byWord.go`.
    The desired functionality is implemented in the `wordByWord()` function. The `wordByWord()`
    function uses **regular expressions** to separate the words found in each line
    of the input file. The regular expression defined in the `regexp.MustCompile("[^\\s]+")`
    statement states that we use whitespace characters to separate one word from another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `wordByWord()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is where we define the regular expression for splitting lines into words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is the tricky part of the program. If we reach the end of a file having
    a line that does not end with a newline character, we must also process it, but
    after that, we must exit the `for` loop, as there is nothing more to read from
    that file. The previous code takes care of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this part of the program, we deal with potential error conditions that might
    come up and prevent us from reading the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the place where we apply the regular expression to split the `line`
    variable into fields when the line that we have read ends with newline character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This `for` loop just prints the fields of the `words` slice. If you want to
    know the number of words found in the input line, you can just find the value
    of the `len(words)` call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `byWord.go` produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As `~/csv.data` does not contain any whitespace characters, each line is considered
    a single word!
  prefs: []
  type: TYPE_NORMAL
- en: Reading a text file character by character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you will learn how to read a text file character by character,
    which is a rare requirement unless you want to develop a text editor. You take
    each line that you read and split it using a `for` loop with a range, which returns
    two values. You discard the first, which is the location of the current character
    in the `line` variable, and you use the second. However, that value is a rune,
    which means that you have to convert it into a character using `string()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `charByChar()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we should take extra care with lines that end without a newline
    character. The conditions for catching such lines are that we have reached the
    end of the file that we are reading and that we still have text to process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that, due to the `fmt.Println(string(x))` statement, each character is
    printed in a distinct line, which means that the output of the program is going
    to be large. If you want a more compressed output, you should use the `fmt.Print()`
    function instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `byCharacter.go` and filtering it with `head(1)`, without any parameters,
    produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The use of the `head(1)` utility without any parameters limits the output to
    just 10 lines. Type `man head` to learn more about the `head(1)` utility.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is about reading from `/dev/random`, which is a UNIX system
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from /dev/random
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you will learn how to read from the `/dev/random` system
    device. The purpose of the `/dev/random` system device is to generate random data,
    which you might use to test your programs or, in this case, as the seed for a
    random number generator. Getting data from `/dev/random` can be a little bit tricky,
    and this is the main reason for specifically discussing it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `devRandom.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You need `encoding/binary` because you read binary data from `/dev/random` that
    you convert into integer values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are two representations named *little endian* and *big endian* that relate
    to the byte order in the internal representation. In our case, we are using little
    endian. The endian-ness relates to the way different computing systems order multiple
    bytes of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'A real-world example of endian-ness is how different languages read text in
    different ways: European languages tend to be read from left to right, whereas
    Arabic texts are read from right to left.'
  prefs: []
  type: TYPE_NORMAL
- en: In a big endian representation, bytes are read from left to right, while little
    endian reads bytes from right to left. For the `0x01234567` value, which requires
    4 bytes for storing, the big endian representation is `01 | 23 | 45 | 67`, whereas
    the little endian representation is `67 | 45 | 23 | 01`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `devRandom.go` creates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This means that the `/dev/random` device is a good place to get random data,
    including a seed value for your random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a specific amount of data from a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection teaches you how to read a specific amount of data from a file.
    The presented utility can come in handy when you want to see a small part of a
    file. The numeric value that is given as a command line argument specifies the
    size of the buffer that is going to be used for reading. The most important code
    of `readSize.go` is the implementation of the `readSize()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All the magic happens in the definition of the `buffer` variable, because this
    is where we define the maximum amount of data that it can hold. Therefore, each
    time we invoke `readSize()`, the function is going to read from `f` at most `size`
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The remaining code is about error conditions; `io.EOF` is a special and expected
    condition that should be treated separately and return the read characters as
    a byte slice to the caller function.
  prefs: []
  type: TYPE_NORMAL
- en: Running `readSize.go` produces the following kind of output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we read 12 characters from `readSize.go` itself because of the
    `12` parameter. Now that we know how to read files, it is time to learn how to
    write to files.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen ways to read files. This subsection shows how to write
    data to files in four different ways and how to append data to an existing file.
    The code of `writeFile.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`os.Create()` returns an `*os.File` value associated with the file path that
    is passed as a parameter. Note that if the file already exists, `os.Create()`
    truncates it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `fmt.Fprintf()` function, which requires a `string` variable, helps you
    write data to your own files using the format you want. The only requirement is
    having an `io.Writer` to write to. In this case, a valid `*os.File` variable,
    which satisfies the `io.Writer` interface, does the job.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`WriteString()` writes the contents of a string to a valid `*os.File` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a temporary file on our own.
  prefs: []
  type: TYPE_NORMAL
- en: Go also offers `os.CreateTemp()` to create temporary files. Type `go doc os.CreateTemp`
    to learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a `bufio.Writer`, which satisfies the `io.Writer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`os.OpenFile()` provides a better way to create or open a file for writing.
    `os.O_APPEND` says that if the file already exists, you should append to it instead
    of truncating it. `os.O_CREATE` states that if the file does not already exist,
    it should be created. Last, `os.O_WRONLY` says that the program should open the
    file for writing only.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `Write()` method gets its input from a byte slice, which is the Go way of
    writing. All previous techniques used strings, which is not the best way, especially
    when working with binary data. However, using strings instead of byte slices is
    more practical as it is more convenient to manipulate `string` values than the
    elements of a byte slice, especially when working with Unicode characters. On
    the other hand, using `string` values increases allocation and can cause a lot
    of garbage collection pressure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `writeFile.go` generates some information output about the bytes written
    on disk. What is interesting is seeing the files created in the `/tmp` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows that the same amount of information (14 bytes) has
    been written in `f1.txt`, `f2.txt`, and `f3.txt`, which means that the presented
    writing techniques are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to work with JSON data in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library includes `encoding/json`, which is for working with
    JSON data. Additionally, Go allows you to add support for JSON fields in Go structures
    using tags, which is the subject of the Structures and JSON subsection. Tags control
    the encoding and decoding of JSON records to and from Go structures. But first,
    we should talk about the *marshaling* and *unmarshaling* of JSON records.
  prefs: []
  type: TYPE_NORMAL
- en: Using Marshal() and Unmarshal()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the marshaling and unmarshaling of JSON data are important procedures for
    working with JSON data using Go structures. Marshaling is the process of converting
    a Go structure into a JSON record. You usually want that for transferring JSON
    data via computer networks or for saving it on disk. Unmarshaling is the process
    of converting a JSON record given as a byte slice into a Go structure. You usually
    want that when receiving JSON data via computer networks or when loading JSON
    data from disk files.
  prefs: []
  type: TYPE_NORMAL
- en: The number one bug when converting JSON records into Go structures, and vice
    versa, is not making the required fields of your Go structures exported, that
    is having their first letter in uppercase. When you have issues with marshaling
    and unmarshaling, begin your debugging process from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in `encodeDecode.go` illustrates both the marshaling and unmarshaling
    of JSON records using hardcoded data for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: What the previous metadata tells us is that the `Name` field of the `UseAll`
    structure is translated to `username` in the JSON record, and vice versa; the
    `Surname` field is translated to `surname`, and vice versa; and the `Year` structure
    field is translated to `created` in the JSON record, and vice versa. This information
    has to do with the marshaling and unmarshaling of JSON data. Other than this,
    you treat and use `UseAll` as a regular Go structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `json.Marshal()` function requires a pointer to a structure variable—its
    real data type is an empty interface variable—and returns a byte slice with the
    encoded information and an `error` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: JSON data usually comes as a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: However, as `json.Unmarshal()` requires a byte slice, you need to convert that
    `string` into a byte slice before passing it to `json.Unmarshal()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `json.Unmarshal()` function requires the byte slice with the JSON record
    and a pointer to the Go structure variable that will store the JSON record, returning
    an `error` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `encodeDecode.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection illustrates how to define the JSON tags in a Go structure
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Structures and JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you have a Go structure that you want to convert into a JSON record
    without including any empty fields—the following code illustrates how to perform
    that task with the use of `omitempty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine that you have some sensitive data on some of the fields of a Go
    structure that you do not want to include in the JSON records. You can do that
    by including the `–` special value in the desired `json:` structure tags. This
    is shown in the following code excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: So the `Pass` field is going to be ignored when converting a `Password` structure
    into a JSON record using `json.Marshal()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two techniques are illustrated in `tagsJSON.go`. Running `tagsJSON.go`
    produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first line of output, we have the following: the value of `noEmpty`,
    which is converted into a `NoEmpty` structure variable named `noEmptyVar`, is
    `NoEmpty{Name: "Mihalis"}`. The `noEmpty` structure has the default values for
    the `Surname` and `Year` fields. However, as they are not specifically defined,
    `json.Marshal()` ignores the `Year` field because it has the `omitempty` tag but
    does not ignore the `Surname` field, which has the empty `string` value but not
    the `omitempty` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second line of output, the value of the `password` variable is `Password{Name:
    "Mihalis", Pass: "myPassword"}`. When the `password` variable is converted into
    a JSON record, the `Pass` field is not included in the output. The remaining two
    fields of the `Password` structure, `Surname` and `Year`, are omitted because
    of the `omitempty` tag. So, what is left is the `username` field along with its
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen working with single JSON records. But what happens when
    we have multiple records to process? Do we have to process them one by one? The
    next subsection answers these questions and many more!
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing JSON data as streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you have a slice of Go structures that represent JSON records
    that you want to process. Should you process the records one by one? It can be
    done but does it look efficient? The good thing is that Go supports the processing
    of multiple JSON records as streams instead of individual records. This subsection
    teaches how to perform that using the `JSONstreams.go` utility, which contains
    the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DeSerialize()` function is used for reading input in the form of JSON
    records, decoding it, and putting it into a slice. The function writes the slice,
    which is of the `interface{}` data type and is given as a parameter, and gets
    its input from the buffer of the `*json.Decoder` parameter. The `*json.Decoder`
    parameter, along with its buffer, is defined in the `main()` function in order
    to avoid allocating it all the time, and therefore, losing the performance gains
    and efficiency of using this type. The same applies to the use of `*json.Encoder`
    that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `Serialize()` function accepts two parameters, a `*json.Encoder` and a slice
    of any data type, hence the use of `interface{}`. The function processes the slice
    and writes the output to the buffer of the `json.Encoder`—this buffer is passed
    as a parameter to the encoder at the time of its creation.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `Serialize()` and `DeSerialize()` functions can work with any type
    of JSON record due to the use of `interface{}`.
  prefs: []
  type: TYPE_NORMAL
- en: You can replace both `Serialize()` and `DeSerialize()` with the `err := json.NewEncoder(buf).Encode(DataRecords)`
    and `err := json.NewEncoder(buf).Encode(DataRecords)` calls, respectively. Personally,
    I prefer using separate functions, but your taste might differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JSONstreams.go` utility generates random data. Running `JSONstreams.go`
    creates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The input slice of structures, which is generated in `main()`, is serialized,
    as seen in the first line of the output. After that, it is deserialized into the
    original slice of structures.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty printing JSON records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection illustrates how to pretty print JSON records, which means printing
    JSON records in a pleasant and readable format without knowing the internals of
    the Go structure that holds the JSON records. As there exist two ways to read
    JSON records, individually and as a stream, there exist two ways to pretty print
    JSON data: as single JSON records and as a stream. Therefore, we are going to
    implement two separate functions named `prettyPrint()` and `JSONstream()`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `prettyPrint()` function is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: All the work is done by `json.MarshalIndent()`, which applies indentation to
    format the output.
  prefs: []
  type: TYPE_NORMAL
- en: Although both `json.MarshalIndent()` and `json.Marshal()` produce a JSON text
    result (byte slice), only `json.MarshalIndent()` allows applying customizable
    indentation, whereas `json.Marshal()` generates a more compact output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For pretty printing streams of JSON data, you should use the `JSONstream()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `json.NewEncoder()` function returns a new encoder that writes to a writer
    that is passed as a parameter to `json.NewEncoder()`. An encoder writes JSON values
    to an output stream. Similarly to `json.MarshalIndent()`, the `SetIndent()` method
    allows you to apply a customizable indent to a stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: After we are done configuring the encoder, we are free to process the JSON stream
    using `Encode()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two functions are illustrated in `prettyPrint.go`, which generates JSON
    records using random data. Running `prettyPrint.go` produces the following kind
    of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows the beautified output of a single JSON record followed
    by the beautified output of a slice with two JSON records—all JSON records are
    represented as Go structures.
  prefs: []
  type: TYPE_NORMAL
- en: And now, we are going to deal with something completely different, which is
    the development of a powerful command line utility—Go is really good at it.
  prefs: []
  type: TYPE_NORMAL
- en: The viper package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Flags* are specially formatted strings that are passed into a program to control
    its behavior. Dealing with flags on your own might become very frustrating if
    you want to support multiple flags and options. Go offers the `flag` package to
    work with command line options, parameters, and flags. Although `flag` can do
    many things, it is not as capable as other external Go packages. Thus, if you
    are developing simple UNIX system command line utilities, you might find the `flag`
    package very interesting and useful. But you are not reading this book to create
    simple command line utilities! Therefore, I am going to skip the `flag` package
    and introduce you to an external package named `viper`, which is a powerful Go
    package that supports a plethora of options. `viper` uses the `pflag` package
    instead of `flag`, which is also illustrated in the code.'
  prefs: []
  type: TYPE_NORMAL
- en: All `viper` projects follow a pattern. First, you initialize `viper` and then
    you define the elements that interest you. After that, you get these elements
    and read their values in order to use them. The desired values can be taken either
    directly, which happens when you use the `flag` package from the standard Go library,
    or indirectly using configuration files. When using formatted configuration files
    in the JSON, YAML, TOML, HCL, or Java properties format, `viper` does all the
    parsing for you, which saves you from having to write and debug lots of Go code.
    `viper` also allows you to extract and save values in Go structures. However,
    this requires that the fields of the Go structure match the keys of the configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The home page of `viper` is on GitHub ([https://github.com/spf13/viper](https://github.com/spf13/viper)).
    Please note that you are not obliged to use every capability of `viper` in your
    tools, just the features that you want. However, if your command line utility
    requires too many command line parameters and flags, then it would be better to
    use a configuration file instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using command line flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first example shows how to write a simple utility that accepts two values
    as command line parameters and prints them on screen for verification. This means
    that we are going to need two command line flags for these two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The relevant code is in `~/go/src/github.com/mactsouk/mGo4th/ch07/useViper`.
    You should replace `mGo4th` with the name of the actual GitHub repository of the
    book, or rename it `mGo4th`. Generally speaking, short directory names are more
    convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you must go to the `~/go/src/github.com/mactsouk/mGo4th/ch07/useViper`
    directory and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the previous two commands should be executed when `useViper.go`
    is ready and include all the required external packages. The GitHub repository
    of the book contains the final versions of all programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `useViper.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We need to import both the `pflag` and `viper` packages, as we are going to
    use their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `aliasNormalizeFunc()` function is used to create additional aliases for
    a flag, in this case, an alias for the `--password` flag. According to the existing
    code, the `--password` flag can be accessed as either `--pass` or `–ps`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create a new flag called `name` that can also be accessed
    as `-n`. Its default value is `Mike`, and its description, which appears in the
    usage of the utility, is `Name parameter`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We create another flag named `password` that can also be accessed as `-p` and
    has a default value of `hardToGuess` and a description. Additionally, we register
    a normalization function to generate aliases for the `password` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `pflag.Parse()` call should be used after all command line flags are defined.
    Its purpose is to parse the command line flags into the predefined flags.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `viper.BindPFlags()` call makes all flags available to the
    `viper` package. Strictly speaking, we say that the `viper.BindPFlags()` call
    binds an existing set of `pflag` flags (`pflag.FlagSet`) to `viper`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands show that you can read the values of two `string` command
    line flags using `viper.GetString()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `viper` package can also work with environment variables. We first need
    to call `viper.BindEnv()` to tell `viper` which environment variable interests
    us, and then we can read its value by calling `viper.Get()`. If `GOMAXPROCS` is
    not already set, which means that its value is `nil`, the `fmt.Println()` call
    will not get executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can change the value of an environment variable with `viper.Set()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing is that `viper` automatically provides usage information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `useViper.go` without any command line arguments produces the following
    kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: However, if we provide values for the command line flags, the output is going
    to be slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In this second case, we used the shortcuts for the command line flags because
    it is faster to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection discusses the use of JSON files to store configuration information
    in `viper`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading JSON configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `viper` package can read JSON files to get its configuration, and this
    subsection illustrates how. Using text files to store configuration details can
    be very helpful when writing complex applications that require lots of data and
    setup. This is illustrated in `jsonViper.go`. Once again, we need to have `jsonViper.go`
    inside `~/go/src` as we did before: `~/go/src/github.com/mactsouk/mGo4th/ch07/jsonViper`.
    The code of `jsonViper.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an important point here: although we are using a JSON file to store
    the configuration, the Go structure uses `mapstructure` instead of `json` for
    the fields of the JSON configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The previous four statements declare that we are using a JSON file, let `viper`
    know the path to the default configuration file, print the configuration file
    used, and read and parse that configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that `viper` does not check whether the configuration file actually
    exists and is readable. If the file cannot be found or read, `viper.ReadInConfig()`
    acts like it is processing an empty configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `viper.IsSet()` call checks whether a key named `macos` can be found in
    the configuration. If it is set, it reads its value using `viper.Get("macos")`
    and prints it on screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code, we check whether the `active` key can be found before
    reading its value. If its value is equal to `true`, then we read the values from
    three more keys, named `postgres`, `mysql`, and `mongodb`.
  prefs: []
  type: TYPE_NORMAL
- en: As the active key should hold a Boolean value, we use `viper.GetBool()` to read
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As expected, trying to read a key that does not exist fails.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The call to `viper.Unmarshal()` allows you to put the information from the JSON
    configuration file into a properly defined Go structure—this is optional but handy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the `PrettyPrint()` function was presented in `prettyPrint.go`
    earlier on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to download the dependencies of `jsonViper.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the current directory are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the `myConfig.json` file used for testing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `jsonViper.go` on the preceding JSON file produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The previous output is generated by `jsonViper.go` when parsing `myConfig.json`
    and trying to find the desired information.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses a Go package for creating powerful and professional
    command line utilities, such as `docker` and `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: The cobra package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`cobra` is a very handy and popular Go package that allows you to develop command
    line utilities with commands, subcommands, and aliases. If you have ever used
    `hugo`, `docker`, or `kubectl`, you are going to realize immediately what the
    `cobra` package does, as all these tools are developed using `cobra`. Commands
    can have one or more aliases, which is very handy when you want to please both
    amateur and experienced users. `cobra` also supports persistent flags and local
    flags, which are flags that are available to all commands and flags that are available
    to given commands only, respectively. Also, by default, `cobra` uses `viper` for
    parsing its command line arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: All Cobra projects follow the same development pattern. You use the Cobra command
    line utility, you create commands, and then you make the desired changes to the
    generated Go source code files in order to implement the desired functionality.
    Depending on the complexity of your utility, you might need to make lots of changes
    to the created files. Although `cobra` saves you lots of time, you still have
    to write the code that implements the desired functionality for each command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to take some extra steps in order to download the `cobra` binary the
    right way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The previous command downloads the `cobra-cli` binary—this is the new name for
    the `cobra` binary executable. It is not necessary to know about all of the supported
    environment variables such as `GO111MODULE` but, sometimes, they can help you
    resolve tricky problems with your Go installation. So if you want to learn about
    your current Go environment, you can use the `go env` command.
  prefs: []
  type: TYPE_NORMAL
- en: As I prefer to work using shorter utility names, I renamed `cobra-cli` to `cobra`.
    If you do not know how to do that or if you prefer to use `cobra-cli`, replace
    `~/go/bin/cobra` with `~/go/bin/cobra-cli` in all commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of this section, we are going to need a separate directory
    under `ch07`. As mentioned multiple times in this book, everything is going to
    be much easier if you put your code somewhere inside `~/go/src`; the exact place
    depends on you, but it would be ideal if you use something like `~/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra`,
    where `mGo4th` is the name of the directory in which you keep the source code
    files from this book. Provided that you are going to use the aforementioned directory,
    you are going to need to execute the next commands (**if you have downloaded the
    source code of the book, you do not need to do anything, as everything is going
    to be there**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'All output lines beginning with `go:` relate to Go modules and will appear
    only once. If you try to execute the utility, which is currently empty, you are
    going to get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The last lines are the default message of a `cobra` project. We are going to
    modify that message later on. You are now ready to begin working with the `cobra`
    tool and add commands to the command line utility we are developing.
  prefs: []
  type: TYPE_NORMAL
- en: A utility with three commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection illustrates the use of the `cobra add` command, which is used
    to add new commands to an existing `cobra` project. The names of the commands
    are `one`, `two`, and `three`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands create three new files in the `cmd` folder, named `one.go`,
    `two.go`, and `three.go`, which are the initial naïve implementations of the three
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you should usually do is delete any unwanted code from `root.go`
    and change the messages of the utility and each command, as described in the `Short`
    and `Long` fields. However, if you want, you can leave the source files unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection enriches the utility by adding command line flags to the
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Adding command line flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to create two global command line flags and one command line flag
    that is attached to a given command (`two`) and not supported by the other two
    commands. Global command line flags are defined in the `./cmd/root.go` file. We
    are going to define two global flags, named `directory`, which is a string, and
    `depth`, which is an unsigned integer. Both global flags are defined in the `init()`
    function of `./cmd/root.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We use `rootCmd.PersistentFlags()` to define global flags, followed by the data
    type of the flag. The name of the first flag is `directory` and its shortcut is
    `d`, whereas the name of the second flag is `depth` and has no shortcut—if you
    want to add a shortcut to it, you should use the `UintP()` method, as the `depth`
    parameter is an unsigned integer. After defining the two flags, we pass their
    control to `viper` by calling `viper.BindPFlag()`. The first flag is a `string`,
    whereas the second one is a `uint` value. As both of them are available in the
    `cobra` project, we call `viper.GetString("directory")` to get the value of the
    `directory` flag and `viper.GetUint("depth")` to get the value of the `depth`
    flag. This is not the only way to read the value of a flag and use it. You are
    going to see an alternative way when we update the statistics application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, we add a command line flag that is only available to the `two` command
    by adding the next line to the `init()` function of the `./cmd/two.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The name of the flag is `username`, and its shortcut is `u`. As this is a local
    flag available to the `two` command only, we can get its value by calling `cmd.Flags().GetString("username")`
    inside the `./cmd/two.go` file only.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection creates command aliases for the existing commands.
  prefs: []
  type: TYPE_NORMAL
- en: Creating command aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we continue building on the code from the previous subsection
    by creating aliases for existing commands. This means that the commands `one`,
    `two`, and `three` will also be accessible as `cmd1`, `cmd2`, and `cmd3`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do that, you need to add an extra field named `Aliases` to the
    `cobra.Command` structure of each command. The data type of the `Aliases` field
    is *string slice*. So, for the `one` command, the beginning of the `cobra.Command`
    structure in `./cmd/one.go` will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You should make similar changes to `./cmd/two.go` and `./cmd/three.go`. Please
    keep in mind that the **internal name** of the `one` command is `oneCmd` and continues
    to be—the other commands have analogous internal names.
  prefs: []
  type: TYPE_NORMAL
- en: If you accidentally put the `cmd1` alias, or any other alias, in multiple commands,
    the Go compiler will not complain. However, only its first occurrence gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection enriches the utility by adding subcommands for the `one`
    and `two` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Creating subcommands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection illustrates how to create two subcommands for the command named
    `three`. The names of the two subcommands will be `list` and `delete`. The way
    to create them using the `cobra` utility is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands create two new files inside `./cmd`, named `delete.go`
    and `list.go`. The `-p` flag is followed by the internal name of the command you
    want to associate the subcommands with. The internal name of the `three` command
    is `threeCmd`. You can verify that these two commands are associated with the
    `three` command as follows (the default message of each command is displayed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run `go run main.go two list`, Go considers list as a command line argument
    of `two`, and it will not execute the code in `./cmd/list.go`. The final version
    of the `go-cobra` project has the following structure and contains the following
    files, as generated by the `tree(1)` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you might wonder what happens when you want to create two subcommands
    with the same name for two different commands. In that case, you create the first
    subcommand and rename its file before creating the second one.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `cobra` package is also illustrated in the final section, where
    we radically update the statistics application. The next section discusses some
    important additions that came with Go version 1.16.
  prefs: []
  type: TYPE_NORMAL
- en: Important Go features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go 1.16 came with some new features, including embedding files in Go binaries
    as well as the introduction of the `os.ReadDir()` function, the `os.DirEntry`
    type, and the `io/fs` package.
  prefs: []
  type: TYPE_NORMAL
- en: As these features are related to systems programming, they are included and
    explored in the current chapter. We begin by presenting the embedding of files
    into Go binary executables.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section presents a feature that allows you to **embed static assets into
    Go binaries**. The allowed data types to keep an embedded file are `string`, `[]byte`,
    and `embed.FS`. This means that a Go binary may contain a file that you do not
    have to manually download when you execute the Go binary! The presented utility
    embeds two different files that it can retrieve based on the given command line
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that follows, which is saved as `embedFiles.go`, illustrates this
    new Go feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: You need the `embed` package in order to embed any files in your Go binaries.
    As the `embed` package is not used directly, you need to put `_` in front of it
    so that the Go compiler will not complain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: You need to begin a line with `//go:embed`, which denotes a Go comment but is
    treated in a special way, followed by the path to the file you want to embed.
    In this case, we embed `static/image.png`, which is a binary file. The next line
    should define the variable that is going to hold the data of the embedded file,
    which, in this case, is a byte slice named `f1`. Using a byte slice is recommended
    for binary files because we are going to directly use that byte slice to save
    that binary file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we save the contents of a plain text file, which is `static/textfile`,
    in a string variable named `f2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The `writeToFile()` function is used to store a byte slice in a file and is
    a helper function that can be used in other cases as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This statement prints the lengths of the `f1` and `f2` variables to make sure
    that they represent the size of the embedded files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The `switch` block is responsible for returning the desired file to the user—in
    the case of `static/textfile`, the file contents are printed on screen. For the
    binary file, we decided to store it as `/tmp/temporary.png`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we are going to compile `embedFiles.go` to make things more realistic,
    as it is the executable binary file that holds the embedded files. We build the
    binary file using `go build embedFiles.go`. Running `embedFiles` produces the
    following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output verifies that `temporary.png` is located at the right
    path (`/tmp/temporary.png`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the embedding functionality, we can create a utility that embeds its
    own source code and prints it on screen when it gets executed! This is a fun way
    of using embedded files. The source code of `printSource.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: As before, the file that is being embedded is defined in the `//go:embed` line.
    Running `printSource.go` prints the aforementioned code on screen.
  prefs: []
  type: TYPE_NORMAL
- en: ReadDir and DirEntry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section discusses `os.ReadDir()` and `os.DirEntry`. However, it begins
    by discussing the deprecation of the `io/ioutil` package—the functionality of
    the `io/ioutil` package has been transferred to other packages. So, we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.ReadDir()`, which is a new function, returns `[]DirEntry`. This means that
    it cannot directly replace `ioutil.ReadDir()`, which returns `[]FileInfo`. Although
    neither `os.ReadDir()` nor `os.DirEntry` offer any new functionality, they make
    things faster and simpler, which is important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `os.ReadFile()` function directly replaces `ioutil.ReadFile()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `os.WriteFile()` function can directly replace `ioutil.WriteFile()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, `os.MkdirTemp()` can replace `ioutil.TempDir()` without any changes.
    However, as the `os.TempDir()` name was already taken, the new function name is
    different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `os.CreateTemp()` function is the same as `ioutil.TempFile()`. Although
    the name `os.TempFile()` was not taken, the Go people decided to name it `os.CreateTemp()`
    in order to be on a par with `os.MkdirTemp()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `os.ReadDir()` and `os.DirEntry` can be found as `fs.ReadDir()` and `fs.DirEntry`
    in the `io/fs` package to work with the file system interface found in `io/fs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ReadDirEntry.go` utility illustrates the use of `os.ReadDir()`. Additionally,
    we are going to see `fs.DirEntry` in combination with `fs.WalkDir()` in action
    in the next section—`io/fs` only supports `WalkDir()`, which uses `DirEntry` by
    default. Both `fs.WalkDir()` and `filepath.WalkDir()` use `DirEntry` instead of
    `FileInfo`. This means that in order to see any performance improvements when
    walking directory trees, you need to change `filepath.Walk()` calls to `filepath.WalkDir()`
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presented utility calculates the size of a directory tree using `os.ReadDir()`,
    with the help of the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: If the return value of `entry.IsDir()` is `true`, then we process a directory,
    which means that we need to keep digging.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'If we process a file, then we just need to get its size. This involves calling
    `Info()` to get general information about the file and then `Size()` to get its
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `ReadDirEntry.go` produces the next output, which indicates that the
    utility works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Last, keep in mind that both `ReadDir` and `DirEntry` are copied from the Python
    programming language.
  prefs: []
  type: TYPE_NORMAL
- en: The next section introduces us to the `io/fs` package.
  prefs: []
  type: TYPE_NORMAL
- en: The io/fs package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section illustrates the functionality of the `io/fs` package, which was
    also introduced in Go 1.16\. As `io/fs` offers a unique kind of functionality,
    we begin this section by explaining what it can do. Put simply, `io/fs` offers
    a read-only file system interface named `FS`. Note that `embed.FS` implements
    the `fs.FS` interface, which means that `embed.FS` can take advantage of some
    of the functionality offered by the `io/fs` package. **This means that your applications
    can create their own internal file systems and work with their files**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code example that follows, which is saved as `ioFS.go`, creates a file
    system using `embed` by putting all the files of the `./static` folder in there.
    `ioFS.go` supports the following functionality: list all files, search for a filename,
    and extract a file using `list()`, `search()`, and `extract()`, respectively.
    We begin by presenting the implementation of `list()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that `fs.WalkDir()` works with regular file systems as well as
    `embed.FS` file systems. You can learn more about the signature of `walkFunction()`
    by running `go doc fs.WalkDirFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we begin with the given directory of a file system and visit its contents.
    The file system is stored in `f` and the root directory is defined as `"."`. After
    that, all the magic happens in the `walkFunction()` function, which is implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The `walkFunction()` function processes every entry in the given root directory
    in the desired way. Keep in mind that the `walkFunc()` is **automatically called**
    by `fs.WalkDir()` to visit each file or directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we present the implementation of the `extract()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The `ReadFile()` function is used to retrieve a file, which is identified by
    its file path, from the `embed.FS` file system as a byte slice, which is returned
    from the `extract()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, we have the implementation of the `search()` function, which is based
    on `walkSearch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '`searchString` is a global variable that holds the search string. When a match
    is found, the matching path is printed on screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Before printing a match, we make a call to `fs.Stat()` to get more details
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function specifically calls these three functions. Running `ioFS.go`
    produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Initially, the utility lists all files in the file system (lines beginning with
    `Path`). Then, it verifies that `static/file.txt` can be found in the file system.
    Last, it verifies that the writing of 14 bytes into a new file was successful,
    as all 14 bytes have been written.
  prefs: []
  type: TYPE_NORMAL
- en: So it turns out that Go version 1.16 introduced important functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to improve the statistics application.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the statistics application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will change the format that the statistics application uses
    to store its data. This time, the statistics application is going to use the JSON
    format. Additionally, it uses the `cobra` package to implement the supported commands.
  prefs: []
  type: TYPE_NORMAL
- en: However, before continuing with the statistics application, we are going to
    learn more about the `slog` package.
  prefs: []
  type: TYPE_NORMAL
- en: The slog package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `log/slog` package was added to the standard Go library with Go 1.21 in
    order to improve the original `log` package. You can find more information about
    it at [https://pkg.go.dev/log/slog](https://pkg.go.dev/log/slog). The main reason
    for including it in this chapter is that it can create log entries in the JSON
    format, which is handy when you want to further process log entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `useSLog.go` that illustrates the use of the `log/slog` package
    is going to be presented in three parts. The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to import `log/slog` for using the `slog` package of the Go standard
    library. When using the default logger, we can send messages using `Error()`,
    `Debug()`, `Info()`, and `Warn()`, which is the simplest way of using the functionality
    of `slog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: In this part of the program, we get the current log level using `&slog.LevelVar{}`
    and change it to the `Debug` level in order to also get the log entries issued
    with `logger.Debug()`. This is implemented with the `logLevel.Set(slog.LevelDebug)`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `useSLog.go` comes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The presented code creates a logger that writes JSON records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `useSLog.go` produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The previous output is from the first four statements of `main()`. The `slog.Debug()`
    statement generated no output because the `DEBUG` level does not get printed by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows that if we increase the logging level, we can get
    `DEBUG` messages printed—the default logging level was `INFO`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the output shows logging information in the JSON format. This
    can be very handy if we want to store log entries in a regular or a time series
    database for further processing, visualization, or data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Sending logs to io.Discard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection presents a trick that involves the use of `io.Discard` for
    sending log entries—`io.Discard` discards all `Write()` calls without doing anything!
    Although we are going to apply the trick to log files, it can also be used in
    other cases where writing data is involved. The implementation of the `main()`
    function in `discard.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition that enables or disables writing is simplistic: when there is
    a single command line argument, logging is enabled; otherwise, it is disabled.
    The statement that disables logging is `log.SetOutput(io.Discard)`. However, before
    logging is disabled, we print a log entry stating so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `discard.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: In the second program execution, the `log.Println("NOT GOING TO GET THAT!")`
    statement generates no output, as it went to `io.Discard`.
  prefs: []
  type: TYPE_NORMAL
- en: With all this information in mind, let us continue with the implementation of
    the statistics application with the help of `cobra`.
  prefs: []
  type: TYPE_NORMAL
- en: Using cobra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to create a place to host the `cobra` version of the statistics
    application. At this point, you have two options: either create a separate GitHub
    repository or put the necessary files in a directory under `~/go/src`. This subsection
    is going to follow the latter option. As a result, all relevant code is going
    to reside at `~/go/src/github.com/mactsouk/mGo4th/ch07/stats`.'
  prefs: []
  type: TYPE_NORMAL
- en: The project is already present in the `stats` directory. The presented steps
    make sense if you want to create it on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create and go to the relevant directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we should declare that we want to use Go modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to run the `cobra init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can execute `go mod tidy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should create the structure of the application using the `cobra` (or
    `cobra-cli`) binary. **Once we have the structure, it is easy to know what we
    have to implement**. The structure of the application is based on the supported
    commands and functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: At this point, executing `go run main.go` is going to download any missing packages
    and generate the default `cobra` output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a command line flag to enable and disable logging. We are
    going to be using the `log/slog` package. The flag is called `--log` and is going
    to be a Boolean variable. The relevant statement, which is located in `root.go`,
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous statement is supported by a global variable, which is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This is a different approach regarding the use of the command line flags than
    what we did in the `go-cobra` project presented earlier.
  prefs: []
  type: TYPE_NORMAL
- en: So, the value of the `disableLogging` global variable holds the value of the
    `--log` flag. Although the `disableLogging` variable is global, you have to define
    **a separate logger variable in each one of the commands**.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection discusses the storing and loading of JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and loading JSON data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This functionality of the `saveJSONFile()` helper function is implemented in
    `./cmd/root.go`, using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, all we have to do is serialize the slice of structures using `Serialize()`
    and save the result in a file. Next, we need to be able to load the JSON data
    from that file. The loading functionality is also implemented in `./cmd/root.go`,
    using the `readJSONFile()` helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: All we have to do is read the data file with the JSON data and put that data
    into a slice of structures by deserializing it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to discuss the implementation of the `list` and `insert` commands.
    The other two commands (`delete` and `search`) have similar implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the list command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The important code of `./cmd/list.go` is in the implementation of the `list()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The core functionality of `list` is included in the previous code, which sorts
    the `data` slice and pretty prints the JSON records using `PrettyPrintJSONstream(data)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The previous code deals with logging based on the value of `disableLogging`,
    which is based on the `--log` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the insert command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of the `insert` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a separate logger for the `insert` command based on the value
    of `disableLogging`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Then, the previous code makes sure that the `file` variable, which is the path
    to the file that contains the data, is not empty. Additionally, if `file` is a
    key of the `index` map, it means that we have processed that file previously—**we
    assume that no two datasets have the same filename, as for us, the filename is
    what uniquely identifies the datasets**. In that case, we delete it from the `data`
    slice and the `index` map, and we process it again. This is similar to the `update`
    functionality, which is not directly supported by the application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the implementation of the `insert` command is about processing
    the given file, using `ProcessFile()`, and saving the updated version of the `data`
    slice, using `saveJSONFile()`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was about working with environment variables, command line arguments,
    reading and writing plain text files, traversing file systems, working with JSON
    data, and creating powerful command line utilities using `cobra`. This is one
    of the most important chapters of this book because you cannot create any real-world
    utility without interacting with the operating system as well as the file system,
    and without reading and saving data.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about concurrency in Go, with the main subjects being goroutines,
    channels, and data sharing with safety. We are also going to talk about UNIX signal
    handling, as Go uses channels and goroutines for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use the functionality of `byCharacter.go`, `byLine.go`, and `byWord.go` in order
    to create a simplified version of the `wc(1)` UNIX utility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a full version of the `wc(1)` UNIX utility, using the `viper` package
    to process command line options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a full version of the `wc(1)` UNIX utility, using commands instead of
    command line options, with the help of the `cobra` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go offers `bufio.Scanner` to read files line by line. Try to rewrite `byLine.go`
    using `bufio.Scanner`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bufio.Scanner` in Go is designed to read input line by line, splitting
    it into tokens. If you need to read a file character by character, a common approach
    is to use `bufio.NewReader` in conjunction with `Read()` or `ReadRune()`. Implement
    the functionality of `byCharacter.go` this way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make `ioFS.go` a `cobra` project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the statistics application `cobra` project in order to also store the
    normalized version of the dataset in `data.json`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `byLine.go` utility uses `ReadString('\n')` to read the input file. Modify
    the code to use `Scanner` ([https://pkg.go.dev/bufio#Scanner](https://pkg.go.dev/bufio#Scanner))
    for reading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, `byWord.go` uses `ReadString('\n')` to read the input file. Modify
    the code to use `Scanner` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `viper` package: [https://github.com/spf13/viper](https://github.com/spf13/viper)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `cobra` package: [https://github.com/spf13/cobra](https://github.com/spf13/cobra)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for `encoding/json`: [https://pkg.go.dev/encoding/json](https://pkg.go.dev/encoding/json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for `io/fs`: [https://pkg.go.dev/io/fs](https://pkg.go.dev/io/fs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go `slog` package: [http://gopherguides.com/articles/golang-slog-package](http://gopherguides.com/articles/golang-slog-package)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A comprehensive guide to logging in Go with `slog`: [https://betterstack.com/community/guides/logging/logging-in-go/](https://betterstack.com/community/guides/logging/logging-in-go/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Endian-ness: [https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
