- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Telling a UNIX System What to Do
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉UNIX系统做什么
- en: This chapter is about systems programming in Go. Systems programming involves
    working with files and directories, process control, signal handling, network
    programming, system files, configuration files, and file **input and output**
    (**I/O**). If you recall from *Chapter 1*, *A Quick Introduction to Go*, the reason
    for writing system utilities with Linux in mind is that, often, Go software is
    executed in a Docker environment—Docker images use the Linux operating system,
    which means that you might need to develop your utilities with the Linux operating
    system in mind. However, as Go code is portable, most system utilities work on
    Windows machines without any changes or with minor modifications. The key idea
    to remember is that Go makes systems programming more portable. Additionally,
    in this chapter, we are going to improve the statistics application with the help
    of the `cobra` package.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于Go语言系统编程的。系统编程涉及与文件和目录、进程控制、信号处理、网络编程、系统文件、配置文件以及文件**输入和输出**（**I/O**）的工作。如果你还记得*第一章*，*Go语言快速入门*，使用Linux系统编写系统工具的原因是，通常，Go软件是在Docker环境中执行的——Docker镜像使用Linux操作系统，这意味着你可能需要考虑Linux操作系统来开发你的工具。然而，由于Go代码的可移植性，大多数系统工具在Windows机器上无需任何更改或仅做少量修改即可工作。要记住的关键思想是Go使得系统编程更加可移植。此外，在本章中，我们将借助`cobra`包来改进统计应用程序。
- en: As already mentioned, starting with Go 1.16, the `GO111MODULE` environment variable
    defaults to `on`—this affects the use of Go packages that do not belong to the
    Go standard library. In practice, this means that you must put your code under
    `~/go/src`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，从Go 1.16版本开始，`GO111MODULE`环境变量默认设置为`on`——这影响了不属于Go标准库的Go包的使用。在实践中，这意味着你必须将你的代码放在`~/go/src`下。
- en: 'This chapter covers:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: '`stdin`, `stdout`, and `stderr`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdin`, `stdout`, 和 `stderr`'
- en: UNIX processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNIX进程
- en: File I/O
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件I/O
- en: Reading plain text files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取纯文本文件
- en: Writing to a file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向文件写入
- en: Working with JSON
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与JSON一起工作
- en: The `viper` package
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viper`包'
- en: The `cobra` package
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cobra`包'
- en: Important Go features
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的Go特性
- en: Updating the statistics application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新统计应用程序
- en: stdin, stdout, and stderr
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: stdin, stdout, 和 stderr
- en: 'Every UNIX operating system has three files open all the time for its processes.
    Remember that UNIX considers everything, even a printer or a mouse, as a file.
    UNIX uses file descriptors, which are positive integer values, as an internal
    representation to access open files, which is much prettier than using long paths.
    So, by default, all UNIX systems support three special and standard filenames:
    `/dev/stdin`, `/dev/stdout`, and `/dev/stderr`, which can also be accessed using
    the file descriptors `0`, `1`, and `2`, respectively. These three file descriptors
    are also called standard input, standard output, and standard error, respectively.
    Additionally, the file descriptor `0` can be accessed as `/dev/fd/0` on a macOS
    machine and as both `/dev/fd/0` and `/dev/pts/0` on a Debian Linux machine.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个UNIX操作系统都会为它的进程始终打开三个文件。记住，UNIX将一切视为文件，即使是打印机或鼠标。UNIX使用文件描述符，即正整数值，作为访问打开文件的内部表示，这比使用长路径要美观得多。因此，默认情况下，所有UNIX系统都支持三个特殊的标准文件名：`/dev/stdin`、`/dev/stdout`和`/dev/stderr`，它们也可以分别使用文件描述符`0`、`1`和`2`来访问。这三个文件描述符也分别被称为标准输入、标准输出和标准错误。此外，文件描述符`0`在macOS机器上可以访问为`/dev/fd/0`，在Debian
    Linux机器上可以访问为`/dev/fd/0`和`/dev/pts/0`。
- en: Go uses `os.Stdin` to access standard input, `os.Stdout` to access standard
    output, and `os.Stderr` to access standard error. Although you can still use `/dev/stdin`,
    `/dev/stdout`, and `/dev/stderr` or the related file descriptor values to access
    the same devices, it is better, safer, and more portable to stick with `os.Stdin`,
    `os.Stdout`, and `os.Stderr`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用`os.Stdin`来访问标准输入，`os.Stdout`来访问标准输出，以及`os.Stderr`来访问标准错误。虽然你仍然可以使用`/dev/stdin`、`/dev/stdout`和`/dev/stderr`或相关的文件描述符值来访问相同的设备，但坚持使用`os.Stdin`、`os.Stdout`和`os.Stderr`会更佳、更安全、更可移植。
- en: UNIX processes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UNIX进程
- en: As Go servers, utilities, and Docker images are mainly executed on Linux, it
    is good to know about Linux processes and threads.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go服务器、工具和Docker镜像主要在Linux上执行，了解Linux进程和线程是有好处的。
- en: Strictly speaking, a process is an execution environment that contains instructions,
    user data and system data parts, and other types of resources that are obtained
    during runtime. On the other hand, a program is a binary file that contains instructions
    and data that are used to initialize the instruction and user data parts of a
    process. Each running UNIX process is uniquely identified by an unsigned integer,
    which is called the process ID of the process.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，进程是一个包含指令、用户数据和系统数据部分以及其他在运行时获得的资源类型的执行环境。另一方面，程序是一个包含指令和数据二进制文件，这些指令和数据用于初始化进程的指令和数据部分。每个运行的
    UNIX 进程都有一个唯一的无符号整数标识符，称为进程 ID。
- en: 'There are three process categories: user processes, daemon processes, and kernel
    processes. User processes run in user space and usually have no special access
    rights. Daemon processes are programs that can be found in the user space and
    run in the background without the need for a terminal. Kernel processes are executed
    in kernel space only and can fully access all kernel data structures.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 存在三种进程类别：用户进程、守护进程和内核进程。用户进程在用户空间运行，通常没有特殊访问权限。守护进程是可以在用户空间找到的程序，可以在后台运行而不需要终端。内核进程仅在内核空间执行，可以完全访问所有内核数据结构。
- en: The C way of creating new processes involves the calling of the `fork(2)` system
    call. The return value of `fork(2)` allows the programmer to differentiate between
    a parent and a child process. Although you can fork a new process in Go using
    the `exec` package, Go does not allow you to control threads—Go offers goroutines,
    which the user can create on top of threads that are created and handled by the
    Go runtime, which is partially controlled by the operating system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C 语言创建新进程的方式涉及调用 `fork(2)` 系统调用。`fork(2)` 的返回值允许程序员区分父进程和子进程。虽然你可以使用 `exec`
    包在 Go 中创建新的进程，但 Go 不允许你控制线程——Go 提供了 goroutines，用户可以在由 Go 运行时创建和处理的线程之上创建 goroutines，这部分由操作系统控制。
- en: Now, we need to learn how to read and write files in Go.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要学习如何在 Go 中读取和写入文件。
- en: File I/O
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件 I/O
- en: This section discusses file I/O in Go, which includes the use of the `io.Reader`
    and `io.Writer` interfaces, buffered and unbuffered I/O, as well as the `bufio`
    package.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论 Go 中的文件 I/O，包括使用 `io.Reader` 和 `io.Writer` 接口、缓冲和非缓冲 I/O，以及 `bufio` 包。
- en: The `io/ioutil` package ([https://pkg.go.dev/io/ioutil](https://pkg.go.dev/io/ioutil))
    has been deprecated since Go version 1.16\. Existing Go code that uses the functionality
    of `io/ioutil` will continue to work, but it is better to stop using that package.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`io/ioutil` 包（[https://pkg.go.dev/io/ioutil](https://pkg.go.dev/io/ioutil)）自
    Go 版本 1.16 起已被弃用。使用 `io/ioutil` 功能的现有 Go 代码将继续工作，但最好停止使用该包。'
- en: The io.Reader and io.Writer interfaces
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: io.Reader 和 io.Writer 接口
- en: 'This subsection presents the definitions of the popular `io.Reader` and `io.Writer`
    interfaces because these two interfaces are the basis of file I/O in Go—the former
    allows you to read from a file, whereas the latter allows you to write to a file.
    The definition of the `io.Reader` interface is the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节介绍了流行的 `io.Reader` 和 `io.Writer` 接口的定义，因为这两个接口是 Go 中文件 I/O 的基础——前者允许你从文件中读取，而后者允许你向文件写入。`io.Reader`
    接口的定义如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This definition, which should be revisited when we want one of our data types
    to satisfy the `io.Reader` interface, tells us the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要使我们的数据类型满足 `io.Reader` 接口时应该重新审视的此定义，告诉我们以下信息：
- en: The `Reader` interface requires the implementation of a single method.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reader` 接口需要实现一个方法。'
- en: The `Read()` method takes a byte slice as input, which will be filled with data
    up to its length.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read()` 方法接收一个字节切片作为输入，该切片将被填充至其长度。'
- en: The `Read()` method returns the number of bytes read as well as an `error` variable.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read()` 方法返回读取的字节数以及一个 `error` 变量。'
- en: 'The definition of the `io.Writer` interface is the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Writer` 接口的定义如下：'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous definition, which should be revisited when we want one of our
    data types to satisfy the `io.Writer` interface and write to a file, reveals the
    following information:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的定义，当我们要使我们的数据类型满足 `io.Writer` 接口并将数据写入文件时应该重新审视，揭示了以下信息：
- en: The interface requires the implementation of a single method.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该接口需要实现一个方法。
- en: The `Write()` method takes a byte slice, which contains the data that you want
    to write, as input.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write()` 方法接收一个字节切片，其中包含要写入的数据。'
- en: The `Write()` method returns the number of bytes written and an `error` variable.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write()` 方法返回写入的字节数和一个 `error` 变量。'
- en: Using and misusing io.Reader and io.Writer
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用和误用 io.Reader 和 io.Writer
- en: The code that follows showcases the use of `io.Reader` and `io.Writer` for **custom
    data types**, which, in this case, are two Go structures named `S1` and `S2`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了如何使用 `io.Reader` 和 `io.Writer` 来处理 **自定义数据类型**，在这个例子中，是两个名为 `S1` 和 `S2`
    的 Go 结构体。
- en: For the `S1` structure, the presented code implements both interfaces in order
    to read user data from the terminal and print data to the terminal, respectively.
    Although this is redundant, as we already have `fmt.Scanln()` and `fmt.Printf()`,
    it is a good exercise that shows how versatile and flexible both interfaces are.
    In a different situation, you could have used `io.Writer` for writing to a log
    service, keeping a second backup copy of the written data, or anything else that
    fits your needs. However, this is also an example of interfaces allowing you to
    do crazy or, if you prefer, unusual things. It is up to the developer to create
    the desired functionality using the appropriate Go concepts and features!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `S1` 结构体，展示的代码实现了两个接口，分别用于从终端读取用户数据以及将数据打印到终端。尽管这有些冗余，因为我们已经有了 `fmt.Scanln()`
    和 `fmt.Printf()`，但这是一个很好的练习，展示了这两个接口的多样性和灵活性。在不同的情境下，你可以使用 `io.Writer` 来写入日志服务，保留第二个数据备份，或者满足你需求的任何其他东西。然而，这也是接口允许你做疯狂或，如果你愿意，不寻常的事情的一个例子。开发者需要使用适当的
    Go 概念和特性来创建所需的功能！
- en: The `Read()` method uses `fmt.Scanln()` to get user input from the terminal,
    whereas the `Write()` method prints the contents of its buffer parameter as many
    times as the value of the `F1` field of the structure, using `fmt.Printf()`!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read()` 方法使用 `fmt.Scanln()` 从终端获取用户输入，而 `Write()` 方法使用 `fmt.Printf()` 将其缓冲区参数的内容打印出结构体
    `F1` 字段值的次数！'
- en: For the `S2` struct, the presented code implements the `io.Reader` interface
    only, in the traditional way. The `Read()` method reads the text field of the
    `S2` structure, which is a byte slice. When there is nothing left to read, the
    `Read()` method returns the expected `io.EOF` error, which in reality is not an
    error but an expected situation. Along with the `Read()` method, there exist two
    helper methods, named `eof()`, which declares that there is nothing more to read,
    and `readByte()`, which reads the text field of the `S2` structure byte by byte.
    After the `Read()` method is done, the text field of the `S2` structure, which
    is used as a buffer, is emptied.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `S2` 结构体，展示的代码仅实现了 `io.Reader` 接口，以传统方式。`Read()` 方法读取 `S2` 结构体的文本字段，它是一个字节切片。当没有更多内容可读取时，`Read()`
    方法返回预期的 `io.EOF` 错误，实际上这并不是一个错误，而是一个预期的状态。除了 `Read()` 方法外，还存在两个辅助方法，名为 `eof()`，它声明没有更多内容可读取，以及
    `readByte()`，它逐字节读取 `S2` 结构体的文本字段。`Read()` 方法完成后，用作缓冲区的 `S2` 结构体的文本字段将被清空。
- en: With this implementation, the `io.Reader` for `S2` can be used for reading in
    a traditional way, which, in this case, is with `bufio.NewReader()` and multiple
    `Read()` calls—the number of `Read()` calls depends on the size of the buffer
    that is used, which, in this case, is a byte slice with two places for data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个实现，`S2` 的 `io.Reader` 可以以传统方式读取，在这种情况下，是使用 `bufio.NewReader()` 和多次 `Read()`
    调用——`Read()` 调用的次数取决于使用的缓冲区大小，在这个例子中，是一个有两个数据位置的字节切片。
- en: 'Type the following code and save it as `ioInterface.go`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码并将其保存为 `ioInterface.go`：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous part shows that we are using the `io` and `bufio` packages to work
    with files.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的部分展示了我们正在使用 `io` 和 `bufio` 包来处理文件。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These are the two structures we are going to work with.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要工作的两个结构体。
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we implement the `io.Reader` interface for `S1`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了 `S1` 的 `io.Reader` 接口。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous method implements the `io.Writer` interface for `S1`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法实现了 `S1` 的 `io.Writer` 接口。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous function is an implementation of `bytes.Buffer.ReadByte` from the
    standard library.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能是标准库中 `bytes.Buffer.ReadByte` 的实现。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous code reads from the given buffer until it is empty. When all data
    is read, the relevant structure field is emptied. The previous method implements
    `io.Reader` for `S2`. However, the operation of `Read()` is supported by `eof()`
    and `readByte()`, which are also user-defined.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码从给定的缓冲区读取，直到它为空。当所有数据都被读取后，相关的结构体字段将被清空。之前的方法实现了 `S2` 的 `io.Reader`。然而，`Read()`
    操作是由 `eof()` 和 `readByte()` 支持的，这两个也是用户自定义的。
- en: Recall that Go allows you to name the return values of a function; in that case,
    a `return` statement without any additional arguments automatically returns the
    current value of each named return variable in the order they appear in the function
    signature. The `Read()` method could have used that feature, but in general, naked
    returns are considered bad practice.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Go允许你给函数的返回值命名；在这种情况下，没有额外参数的`return`语句会自动返回函数签名中按顺序出现的每个命名返回变量的当前值。`Read()`方法可以使用该功能，但通常，裸返回被认为是不良实践。
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We initialize an `S1` variable that is named `s1var`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化一个名为`s1var`的`S1`变量。
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous line reads for the `s1var` variable using a buffer of two bytes.
    The block does not do what is expected because the implementation of the `Read()`
    method gets the value from the terminal—we are misusing Go interfaces here!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上行代码使用两个字节的缓冲区读取`s1var`变量。但是，该代码块并没有达到预期的效果，因为`Read()`方法的实现是从终端获取值——在这里我们误用了Go接口！
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous line, we call the `Write()` method for `s1var` in order to write
    the contents of a byte slice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中，我们调用`s1var`的`Write()`方法来写入字节数组的内容。
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous code, we initialize an `S2` variable that is named `s2var`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们初始化了一个名为`s2var`的`S2`变量。
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now create a reader for `s2var`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为`s2var`创建一个读取器。
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We keep reading from `s2var` until there is an `io.EOF` condition.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会一直从`s2var`读取，直到出现`io.EOF`条件。
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running `ioInterface.go` produces the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`ioInterface.go`会产生以下输出：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first line of the output shows the contents of the `s1var` variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行显示了`s1var`变量的内容。
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last part of the output illustrates the reading process, using a buffer
    with a size of two. The next section discusses buffered and unbuffered operations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后部分展示了使用大小为二的缓冲区的读取过程。下一节将讨论带缓冲和不带缓冲的操作。
- en: Buffered and unbuffered file I/O
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带缓冲和不带缓冲的文件I/O
- en: '*Buffered file I/O* happens when there is a buffer to temporarily store data
    before reading data or writing data. Thus, instead of reading a file byte by byte,
    you read many bytes at once. You put the data in a buffer and wait for someone
    to read it in the desired way.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*带缓冲的文件I/O* 发生在有缓冲区临时存储数据，在读取数据或写入数据之前。因此，你不会逐字节读取文件，而是可以一次性读取多个字节。你将数据放入缓冲区，并等待有人以期望的方式读取它。'
- en: '*Unbuffered file I/O* happens when there is no buffer to temporarily store
    data before reading or writing it—this can affect the performance of your programs.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*不带缓冲的文件I/O* 发生在没有缓冲区在读取或写入之前临时存储数据的情况——这可能会影响程序的性能。'
- en: The next question that you might ask is how to decide when to use buffered and
    when to use unbuffered file I/O. When dealing with critical data, unbuffered file
    I/O is generally a better choice because buffered reads might result in out-of-date
    data, and buffered writes might result in data loss when the power of your computer
    is interrupted. However, most of the time, there is no definitive answer to that
    question. This means that you can use whatever makes your tasks easier to implement.
    However, keep in mind that buffered readers can also improve performance by reducing
    the number of system calls needed to read from a file or socket, so there can
    be a real performance impact on what the programmer decides to use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能接下来会问，如何决定何时使用带缓冲的文件I/O和何时使用不带缓冲的文件I/O。当处理关键数据时，不带缓冲的文件I/O通常是一个更好的选择，因为带缓冲的读取可能会导致数据过时，而带缓冲的写入可能在计算机电源中断时导致数据丢失。然而，大多数情况下，这个问题没有明确的答案。这意味着你可以使用任何使你的任务更容易实现的方法。然而，请记住，带缓冲的读取器也可以通过减少从文件或套接字读取所需的系统调用来提高性能，因此程序员的选择可能会对性能产生实际影响。
- en: There is also the `bufio` package. As the name suggests, `bufio` is about buffered
    I/O. Internally, the `bufio` package implements the `io.Reader` and `io.Writer`
    interfaces, which it wraps in order to create the `bufio.Reader` and `bufio.Writer`
    types, respectively. The `bufio` package is very popular for working with plain
    text files, and you are going to see it in action in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`bufio`包。正如其名所示，`bufio`是关于带缓冲的I/O。内部，`bufio`包实现了`io.Reader`和`io.Writer`接口，它将它们包装起来以创建`bufio.Reader`和`bufio.Writer`类型。`bufio`包在处理纯文本文件时非常流行，你将在下一节中看到它的实际应用。
- en: Reading text files
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文本文件
- en: In this section, you will learn how to read plain text files, as well as use
    the `/dev/random` UNIX device, which offers you a way of getting random numbers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何读取纯文本文件，以及如何使用提供获取随机数方式的`/dev/random` UNIX设备。
- en: Reading a text file line by line
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐行读取文本文件
- en: The function to read a file line by line is found in `byLine.go` and is named
    `lineByLine()`. The technique for reading a text file line by line is also used
    when reading a plain text file word by word, as well as when reading a plain text
    file character by character because you usually process plain text files line
    by line. The presented utility prints every line that it reads, which makes it
    a simplified version of the `cat(1)` utility.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 逐行读取文件的函数位于`byLine.go`中，并命名为`lineByLine()`。逐行读取文本文件的技巧也用于逐字读取纯文本文件，以及逐字符读取纯文本文件，因为通常你按行处理纯文本文件。所提供的实用程序打印它所读取的每一行，这使得它成为`cat(1)`实用程序的简化版本。
- en: First, you create a new reader for the desired file using a call to `bufio.NewReader()`.
    Then, you use that reader with `bufio.ReadString()` in order to read the input
    file line by line. The trick is done by the parameter of `bufio.ReadString()`,
    which is a character that tells `bufio.ReadString()` to keep reading until that
    character is found. Constantly calling `bufio.ReadString()` when that parameter
    is the newline character (`\n`) results in reading the input file line by line.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用`bufio.NewReader()`调用为所需的文件创建一个新的读取器。然后，你使用该读取器与`bufio.ReadString()`一起按行读取输入文件。技巧是通过`bufio.ReadString()`的参数实现的，该参数告诉`bufio.ReadString()`在找到该字符之前继续读取。当该参数是换行符（`\n`）时，不断调用`bufio.ReadString()`会导致按行读取输入文件。
- en: 'The implementation of `lineByLine()` is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`lineByLine()`的实现如下：'
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After making sure that you can open the given file for reading (`os.Open()`),
    you create a new reader using `bufio.NewReader()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保你可以使用`os.Open()`打开给定的文件进行读取后，你使用`bufio.NewReader()`创建一个新的读取器。
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`bufio.ReadString()` returns two values: the string that was read and an error
    variable.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio.ReadString()`返回两个值：读取的字符串和一个错误变量。'
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The use of `fmt.Print()` instead of `fmt.Println()` to print the input line
    shows that the newline character is included in each input line.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fmt.Print()`而不是`fmt.Println()`来打印输入行表明换行符包含在每个输入行中。
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running `byLine.go` generates the following kind of output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`byLine.go`会生成以下类型的输出：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous output shows the contents of `~/csv.data` (use your own plain text
    file) presented line by line with the help of `byLine.go`. The next subsection
    shows how to read a plain text file word by word.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示了使用`byLine.go`逐行显示的`~/csv.data`（使用你自己的纯文本文件）的内容。下一小节将展示如何逐字读取纯文本文件。
- en: Reading a text file word by word
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐字读取文本文件
- en: Reading a plain text file word by word is one of the most useful functions that
    you want to perform on a file because you usually want to process a file on a
    per-word basis—it is illustrated in this subsection, using the code found in `byWord.go`.
    The desired functionality is implemented in the `wordByWord()` function. The `wordByWord()`
    function uses **regular expressions** to separate the words found in each line
    of the input file. The regular expression defined in the `regexp.MustCompile("[^\\s]+")`
    statement states that we use whitespace characters to separate one word from another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 逐字读取纯文本文件是你在文件上想要执行的最有用的函数之一，因为你通常希望按单词处理文件——这在本小节中通过`byWord.go`中的代码进行说明。所需的功能在`wordByWord()`函数中实现。`wordByWord()`函数使用**正则表达式**来分隔输入文件每一行中找到的单词。`regexp.MustCompile("[^\\s]+")`语句中定义的正则表达式表示我们使用空白字符来分隔一个单词与另一个单词。
- en: 'The implementation of the `wordByWord()` function is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`wordByWord()`函数的实现如下：'
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is where we define the regular expression for splitting lines into words.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义用于将行拆分为单词的正则表达式的地方。
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the tricky part of the program. If we reach the end of a file having
    a line that does not end with a newline character, we must also process it, but
    after that, we must exit the `for` loop, as there is nothing more to read from
    that file. The previous code takes care of it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的难点部分。如果我们遇到一个不以换行符结束的行的文件末尾，我们也必须处理它，但之后，我们必须退出`for`循环，因为从该文件中再也没有什么可读的内容了。之前的代码处理了这一点。
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this part of the program, we deal with potential error conditions that might
    come up and prevent us from reading the file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序部分，我们处理可能出现的潜在错误条件，这些条件可能会阻止我们读取文件。
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the place where we apply the regular expression to split the `line`
    variable into fields when the line that we have read ends with newline character.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将正则表达式应用于`line`变量以将其拆分为字段的地方，当读取的行以换行符结束。
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This `for` loop just prints the fields of the `words` slice. If you want to
    know the number of words found in the input line, you can just find the value
    of the `len(words)` call.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`for`循环只是打印`words`切片的字段。如果你想知道输入行中找到的单词数量，你只需找到`len(words)`调用的值。
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Running `byWord.go` produces the following kind of output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`byWord.go`会产生以下类型的输出：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As `~/csv.data` does not contain any whitespace characters, each line is considered
    a single word!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`~/csv.data`不包含任何空白字符，每一行都被视为一个单独的单词！
- en: Reading a text file character by character
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐字符读取文本文件
- en: In this subsection, you will learn how to read a text file character by character,
    which is a rare requirement unless you want to develop a text editor. You take
    each line that you read and split it using a `for` loop with a range, which returns
    two values. You discard the first, which is the location of the current character
    in the `line` variable, and you use the second. However, that value is a rune,
    which means that you have to convert it into a character using `string()`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，你将学习如何逐字符读取文本文件，除非你想开发一个文本编辑器，否则这是一个罕见的需求。你读取每一行，并使用带有范围的`for`循环将其分割，这会返回两个值。你丢弃第一个值，它是`line`变量中当前字符的位置，而使用第二个值。然而，这个值是一个rune，这意味着你必须使用`string()`将其转换为字符。
- en: 'The implementation of `charByChar()` is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`charByChar()`的实现如下：'
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once again, we should take extra care with lines that end without a newline
    character. The conditions for catching such lines are that we have reached the
    end of the file that we are reading and that we still have text to process.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们应该特别注意那些不以换行符结尾的行。捕获此类行的条件是，我们已经到达了正在读取的文件的末尾，并且我们仍然有文本需要处理。
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that, due to the `fmt.Println(string(x))` statement, each character is
    printed in a distinct line, which means that the output of the program is going
    to be large. If you want a more compressed output, you should use the `fmt.Print()`
    function instead.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`fmt.Println(string(x))`语句，每个字符都会打印在一行上，这意味着程序的输出将会很大。如果你想要更紧凑的输出，你应该使用`fmt.Print()`函数。
- en: 'Running `byCharacter.go` and filtering it with `head(1)`, without any parameters,
    produces the following kind of output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`byCharacter.go`并使用`head(1)`进行过滤，不带任何参数，会产生以下类型的输出：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The use of the `head(1)` utility without any parameters limits the output to
    just 10 lines. Type `man head` to learn more about the `head(1)` utility.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不带任何参数使用`head(1)`实用程序将输出限制为仅10行。输入`man head`以了解更多关于`head(1)`实用程序的信息。
- en: The next section is about reading from `/dev/random`, which is a UNIX system
    file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是关于从`/dev/random`读取的内容，它是一个UNIX系统文件。
- en: Reading from /dev/random
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从`/dev/random`读取
- en: In this subsection, you will learn how to read from the `/dev/random` system
    device. The purpose of the `/dev/random` system device is to generate random data,
    which you might use to test your programs or, in this case, as the seed for a
    random number generator. Getting data from `/dev/random` can be a little bit tricky,
    and this is the main reason for specifically discussing it here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，你将学习如何从`/dev/random`系统设备读取。`/dev/random`系统设备的目的生成随机数据，你可能用它来测试你的程序，或者在这种情况下，作为随机数生成器的种子。从`/dev/random`获取数据可能有点棘手，这也是我们在这里特别讨论的主要原因。
- en: 'The code for `devRandom.go` is the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`devRandom.go`的代码如下：'
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You need `encoding/binary` because you read binary data from `/dev/random` that
    you convert into integer values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要`encoding/binary`，因为你从`/dev/random`读取二进制数据，并将其转换为整数值。
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are two representations named *little endian* and *big endian* that relate
    to the byte order in the internal representation. In our case, we are using little
    endian. The endian-ness relates to the way different computing systems order multiple
    bytes of information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种表示形式称为*小端*和*大端*，它们与内部表示的字节序相关。在我们的情况下，我们使用小端。端序与不同计算系统如何排序多个信息字节的方式有关。
- en: 'A real-world example of endian-ness is how different languages read text in
    different ways: European languages tend to be read from left to right, whereas
    Arabic texts are read from right to left.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于字节序的实际情况的例子是不同语言以不同方式读取文本：欧洲语言通常是从左到右读取，而阿拉伯文本是从右到左读取的。
- en: In a big endian representation, bytes are read from left to right, while little
    endian reads bytes from right to left. For the `0x01234567` value, which requires
    4 bytes for storing, the big endian representation is `01 | 23 | 45 | 67`, whereas
    the little endian representation is `67 | 45 | 23 | 01`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在大端表示法中，字节是从左到右读取的，而小端表示法是从右到左读取字节。对于需要 4 个字节来存储的 `0x01234567` 值，大端表示法是 `01
    | 23 | 45 | 67`，而小端表示法是 `67 | 45 | 23 | 01`。
- en: 'Running `devRandom.go` creates the following kind of output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `devRandom.go` 会产生以下类型的输出：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This means that the `/dev/random` device is a good place to get random data,
    including a seed value for your random number generator.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `/dev/random` 设备是一个获取随机数据的好地方，包括随机数生成器的种子值。
- en: Reading a specific amount of data from a file
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取特定数量的数据
- en: 'This subsection teaches you how to read a specific amount of data from a file.
    The presented utility can come in handy when you want to see a small part of a
    file. The numeric value that is given as a command line argument specifies the
    size of the buffer that is going to be used for reading. The most important code
    of `readSize.go` is the implementation of the `readSize()` function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节教你如何从文件中读取特定数量的数据。当你想查看文件的一小部分时，这个实用程序会很有用。作为命令行参数给出的数值指定了将要用于读取的缓冲区的大小。`readSize.go`
    中的最重要的代码是 `readSize()` 函数的实现：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All the magic happens in the definition of the `buffer` variable, because this
    is where we define the maximum amount of data that it can hold. Therefore, each
    time we invoke `readSize()`, the function is going to read from `f` at most `size`
    characters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的魔法都在 `buffer` 变量的定义中发生，因为这是我们定义它可以保存的最大数据量的地方。因此，每次我们调用 `readSize()`，该函数将从
    `f` 中最多读取 `size` 个字符。
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The remaining code is about error conditions; `io.EOF` is a special and expected
    condition that should be treated separately and return the read characters as
    a byte slice to the caller function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码是关于错误条件；`io.EOF` 是一个特殊且预期的条件，应该单独处理，并将读取的字符作为字节切片返回给调用函数。
- en: Running `readSize.go` produces the following kind of output.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `readSize.go` 会产生以下类型的输出。
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, we read 12 characters from `readSize.go` itself because of the
    `12` parameter. Now that we know how to read files, it is time to learn how to
    write to files.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们由于 `12` 参数而从 `readSize.go` 本身读取了 12 个字符。现在我们已经知道如何读取文件，是时候学习如何向文件写入数据了。
- en: Writing to a file
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向文件写入
- en: 'So far, we have seen ways to read files. This subsection shows how to write
    data to files in four different ways and how to append data to an existing file.
    The code of `writeFile.go` is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了读取文件的方法。本小节展示了如何以四种不同的方式将数据写入文件，以及如何向现有文件追加数据。`writeFile.go` 的代码如下：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`os.Create()` returns an `*os.File` value associated with the file path that
    is passed as a parameter. Note that if the file already exists, `os.Create()`
    truncates it.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Create()` 返回一个与文件路径关联的 `*os.File` 值。请注意，如果文件已经存在，`os.Create()` 将截断它。'
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `fmt.Fprintf()` function, which requires a `string` variable, helps you
    write data to your own files using the format you want. The only requirement is
    having an `io.Writer` to write to. In this case, a valid `*os.File` variable,
    which satisfies the `io.Writer` interface, does the job.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Fprintf()` 函数需要一个 `string` 变量，它可以帮助你使用你想要的格式将数据写入自己的文件。唯一的要求是拥有一个 `io.Writer`
    来写入。在这种情况下，一个有效的 `*os.File` 变量，它满足 `io.Writer` 接口，就可以完成这项工作。'
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`WriteString()` writes the contents of a string to a valid `*os.File` variable.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteString()` 将字符串的内容写入一个有效的 `*os.File` 变量。'
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we create a temporary file on our own.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个临时文件。
- en: Go also offers `os.CreateTemp()` to create temporary files. Type `go doc os.CreateTemp`
    to learn more about it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还提供了 `os.CreateTemp()` 来创建临时文件。输入 `go doc os.CreateTemp` 来了解更多信息。
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This function returns a `bufio.Writer`, which satisfies the `io.Writer` interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个 `bufio.Writer`，它满足 `io.Writer` 接口。
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`os.OpenFile()` provides a better way to create or open a file for writing.
    `os.O_APPEND` says that if the file already exists, you should append to it instead
    of truncating it. `os.O_CREATE` states that if the file does not already exist,
    it should be created. Last, `os.O_WRONLY` says that the program should open the
    file for writing only.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.OpenFile()` 提供了一种更好的方式来创建或打开文件进行写入。`os.O_APPEND` 表示如果文件已经存在，你应该向其追加而不是截断它。`os.O_CREATE`
    表示如果文件不存在，应该创建它。最后，`os.O_WRONLY` 表示程序应该只为写入打开文件。'
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Write()` method gets its input from a byte slice, which is the Go way of
    writing. All previous techniques used strings, which is not the best way, especially
    when working with binary data. However, using strings instead of byte slices is
    more practical as it is more convenient to manipulate `string` values than the
    elements of a byte slice, especially when working with Unicode characters. On
    the other hand, using `string` values increases allocation and can cause a lot
    of garbage collection pressure.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write()` 方法从字节切片获取输入，这是 Go 的写入方式。所有之前的技术都使用了字符串，这不是最佳方式，尤其是在处理二进制数据时。然而，使用字符串而不是字节切片更为实用，因为操纵
    `string` 值比操纵字节切片的元素更方便，尤其是在处理 Unicode 字符时。另一方面，使用 `string` 值会增加分配，并可能导致大量的垃圾回收压力。'
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Running `writeFile.go` generates some information output about the bytes written
    on disk. What is interesting is seeing the files created in the `/tmp` folder:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `writeFile.go` 会在磁盘上生成一些关于写入字节的输出信息。有趣的是查看在 `/tmp` 文件夹中创建的文件：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The previous output shows that the same amount of information (14 bytes) has
    been written in `f1.txt`, `f2.txt`, and `f3.txt`, which means that the presented
    writing techniques are equivalent.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示，在 `f1.txt`、`f2.txt` 和 `f3.txt` 中写入了相同数量的信息（14 字节），这意味着所展示的写入技术是等效的。
- en: The next section shows how to work with JSON data in Go.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示如何在 Go 中处理 JSON 数据。
- en: Working with JSON
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 JSON
- en: The Go standard library includes `encoding/json`, which is for working with
    JSON data. Additionally, Go allows you to add support for JSON fields in Go structures
    using tags, which is the subject of the Structures and JSON subsection. Tags control
    the encoding and decoding of JSON records to and from Go structures. But first,
    we should talk about the *marshaling* and *unmarshaling* of JSON records.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库包括 `encoding/json`，用于处理 JSON 数据。此外，Go 允许你通过标签在 Go 结构中添加对 JSON 字段的支持，这是结构和
    JSON 子节点的主题。标签控制 JSON 记录与 Go 结构之间的编码和解码。但首先，我们应该谈谈 JSON 记录的 *序列化* 和 *反序列化*。
- en: Using Marshal() and Unmarshal()
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Marshal() 和 Unmarshal()
- en: Both the marshaling and unmarshaling of JSON data are important procedures for
    working with JSON data using Go structures. Marshaling is the process of converting
    a Go structure into a JSON record. You usually want that for transferring JSON
    data via computer networks or for saving it on disk. Unmarshaling is the process
    of converting a JSON record given as a byte slice into a Go structure. You usually
    want that when receiving JSON data via computer networks or when loading JSON
    data from disk files.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 结构处理 JSON 数据时，序列化和反序列化是重要的步骤。序列化是将 Go 结构转换为 JSON 记录的过程。你通常希望这样做，以便通过计算机网络传输
    JSON 数据或将其保存到磁盘上。反序列化是将作为字节切片给出的 JSON 记录转换为 Go 结构的过程。你通常希望在通过计算机网络接收 JSON 数据或从磁盘文件加载
    JSON 数据时这样做。
- en: The number one bug when converting JSON records into Go structures, and vice
    versa, is not making the required fields of your Go structures exported, that
    is having their first letter in uppercase. When you have issues with marshaling
    and unmarshaling, begin your debugging process from there.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 记录转换为 Go 结构，反之亦然时最常见的错误是没有将 Go 结构的必需字段导出，也就是说，它们的首字母大写。当你遇到序列化和反序列化问题时，应从那里开始调试过程。
- en: 'The code in `encodeDecode.go` illustrates both the marshaling and unmarshaling
    of JSON records using hardcoded data for simplicity:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeDecode.go` 中的代码展示了使用硬编码数据简化过程的 JSON 记录的序列化和反序列化：'
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What the previous metadata tells us is that the `Name` field of the `UseAll`
    structure is translated to `username` in the JSON record, and vice versa; the
    `Surname` field is translated to `surname`, and vice versa; and the `Year` structure
    field is translated to `created` in the JSON record, and vice versa. This information
    has to do with the marshaling and unmarshaling of JSON data. Other than this,
    you treat and use `UseAll` as a regular Go structure.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前元数据告诉我们，`UseAll` 结构的 `Name` 字段在 JSON 记录中翻译为 `username`，反之亦然；`Surname` 字段翻译为
    `surname`，反之亦然；`Year` 结构字段在 JSON 记录中翻译为 `created`，反之亦然。这些信息与 JSON 数据的序列化和反序列化有关。除此之外，你可以像使用常规
    Go 结构一样处理和使用 `UseAll`。
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `json.Marshal()` function requires a pointer to a structure variable—its
    real data type is an empty interface variable—and returns a byte slice with the
    encoded information and an `error` variable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.Marshal()` 函数需要一个指向结构变量的指针——其实际数据类型是一个空接口变量——并返回一个包含编码信息的字节切片和一个 `error`
    变量。'
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: JSON data usually comes as a string.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 数据通常以字符串的形式出现。
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: However, as `json.Unmarshal()` requires a byte slice, you need to convert that
    `string` into a byte slice before passing it to `json.Unmarshal()`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`json.Unmarshal()`需要一个字节切片，你需要在将其传递给`json.Unmarshal()`之前将那个`string`转换为字节切片。
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `json.Unmarshal()` function requires the byte slice with the JSON record
    and a pointer to the Go structure variable that will store the JSON record, returning
    an `error` variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.Unmarshal()`函数需要一个包含JSON记录的字节切片和一个指向将存储JSON记录的Go结构体变量的指针，返回一个`error`变量。'
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Running `encodeDecode.go` produces the following output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`encodeDecode.go`会产生以下输出：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The next subsection illustrates how to define the JSON tags in a Go structure
    in more detail.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将更详细地说明如何在Go结构体中定义JSON标签。
- en: Structures and JSON
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体和JSON
- en: 'Imagine that you have a Go structure that you want to convert into a JSON record
    without including any empty fields—the following code illustrates how to perform
    that task with the use of `omitempty`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个Go结构体，你想将其转换为JSON记录而不包括任何空字段——以下代码展示了如何使用`omitempty`来执行此任务：
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, imagine that you have some sensitive data on some of the fields of a Go
    structure that you do not want to include in the JSON records. You can do that
    by including the `–` special value in the desired `json:` structure tags. This
    is shown in the following code excerpt:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你有一些敏感数据存储在Go结构体的某些字段中，你不想将其包含在JSON记录中。你可以通过在所需的`json:`结构体标签中包含特殊值`-`来实现这一点。以下代码片段展示了如何做到这一点：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So the `Pass` field is going to be ignored when converting a `Password` structure
    into a JSON record using `json.Marshal()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在将`Password`结构体转换为JSON记录时使用`json.Marshal()`函数时，`Pass`字段将被忽略。
- en: 'These two techniques are illustrated in `tagsJSON.go`. Running `tagsJSON.go`
    produces the following output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术已在`tagsJSON.go`中展示。运行`tagsJSON.go`会产生以下输出：
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For the first line of output, we have the following: the value of `noEmpty`,
    which is converted into a `NoEmpty` structure variable named `noEmptyVar`, is
    `NoEmpty{Name: "Mihalis"}`. The `noEmpty` structure has the default values for
    the `Surname` and `Year` fields. However, as they are not specifically defined,
    `json.Marshal()` ignores the `Year` field because it has the `omitempty` tag but
    does not ignore the `Surname` field, which has the empty `string` value but not
    the `omitempty` tag.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '对于输出结果的第一行，我们有以下内容：将`noEmpty`值转换为名为`noEmptyVar`的`NoEmpty`结构体变量的值是`NoEmpty{Name:
    "Mihalis"}`。`noEmpty`结构体对于`Surname`和`Year`字段具有默认值。然而，由于它们没有被特别定义，`json.Marshal()`忽略了带有`omitempty`标签的`Year`字段，但没有忽略具有空`string`值但没有`omitempty`标签的`Surname`字段。'
- en: 'For the second line of output, the value of the `password` variable is `Password{Name:
    "Mihalis", Pass: "myPassword"}`. When the `password` variable is converted into
    a JSON record, the `Pass` field is not included in the output. The remaining two
    fields of the `Password` structure, `Surname` and `Year`, are omitted because
    of the `omitempty` tag. So, what is left is the `username` field along with its
    value.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '对于输出结果的第二行，`password`变量的值为`Password{Name: "Mihalis", Pass: "myPassword"}`。当`password`变量被转换为JSON记录时，`Pass`字段不包括在输出中。由于`omitempty`标签，`Password`结构体的剩余两个字段`Surname`和`Year`被省略。所以，剩下的就是`username`字段及其值。'
- en: So far, we have seen working with single JSON records. But what happens when
    we have multiple records to process? Do we have to process them one by one? The
    next subsection answers these questions and many more!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何处理单个JSON记录。但是当我们有多个记录需要处理时会发生什么？我们是否必须逐个处理它们？下一小节将回答这些问题以及更多问题！
- en: Reading and writing JSON data as streams
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以流的形式读取和写入JSON数据
- en: 'Imagine that you have a slice of Go structures that represent JSON records
    that you want to process. Should you process the records one by one? It can be
    done but does it look efficient? The good thing is that Go supports the processing
    of multiple JSON records as streams instead of individual records. This subsection
    teaches how to perform that using the `JSONstreams.go` utility, which contains
    the following two functions:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个代表JSON记录的Go结构体切片，你想处理这些记录。你应该逐个处理记录吗？虽然可以这样做，但这看起来效率如何？好消息是Go支持以流的形式处理多个JSON记录而不是单个记录。本小节将教授如何使用包含以下两个函数的`JSONstreams.go`实用程序来完成这项任务：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `DeSerialize()` function is used for reading input in the form of JSON
    records, decoding it, and putting it into a slice. The function writes the slice,
    which is of the `interface{}` data type and is given as a parameter, and gets
    its input from the buffer of the `*json.Decoder` parameter. The `*json.Decoder`
    parameter, along with its buffer, is defined in the `main()` function in order
    to avoid allocating it all the time, and therefore, losing the performance gains
    and efficiency of using this type. The same applies to the use of `*json.Encoder`
    that follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeSerialize()` 函数用于读取以 JSON 记录形式输入的数据，对其进行解码，并将其放入切片中。该函数将切片写入，该切片为 `interface{}`
    数据类型，并作为参数给出，并从 `*json.Decoder` 参数的缓冲区获取输入。`*json.Decoder` 参数及其缓冲区在 `main()` 函数中定义，以避免每次都分配它，从而失去使用此类型带来的性能提升和效率。同样适用于以下
    `*json.Encoder` 的使用：'
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `Serialize()` function accepts two parameters, a `*json.Encoder` and a slice
    of any data type, hence the use of `interface{}`. The function processes the slice
    and writes the output to the buffer of the `json.Encoder`—this buffer is passed
    as a parameter to the encoder at the time of its creation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Serialize()` 函数接受两个参数，一个 `*json.Encoder` 和任何数据类型的切片，因此使用了 `interface{}`。该函数处理切片并将输出写入
    `json.Encoder` 的缓冲区——这个缓冲区在创建编码器时作为参数传递。'
- en: Both the `Serialize()` and `DeSerialize()` functions can work with any type
    of JSON record due to the use of `interface{}`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了 `interface{}`，`Serialize()` 和 `DeSerialize()` 函数都可以与任何类型的 JSON 记录一起工作。
- en: You can replace both `Serialize()` and `DeSerialize()` with the `err := json.NewEncoder(buf).Encode(DataRecords)`
    and `err := json.NewEncoder(buf).Encode(DataRecords)` calls, respectively. Personally,
    I prefer using separate functions, but your taste might differ.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `err := json.NewEncoder(buf).Encode(DataRecords)` 和 `err := json.NewEncoder(buf).Encode(DataRecords)`
    调用分别替换 `Serialize()` 和 `DeSerialize()`。我个人更喜欢使用单独的函数，但你的口味可能不同。
- en: 'The `JSONstreams.go` utility generates random data. Running `JSONstreams.go`
    creates the following output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONstreams.go` 工具生成随机数据。运行 `JSONstreams.go` 会生成以下输出：'
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The input slice of structures, which is generated in `main()`, is serialized,
    as seen in the first line of the output. After that, it is deserialized into the
    original slice of structures.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 中生成的结构体输入切片被序列化，如输出第一行所示。之后，它被反序列化为原始的结构体切片。
- en: Pretty printing JSON records
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 美化打印 JSON 记录
- en: 'This subsection illustrates how to pretty print JSON records, which means printing
    JSON records in a pleasant and readable format without knowing the internals of
    the Go structure that holds the JSON records. As there exist two ways to read
    JSON records, individually and as a stream, there exist two ways to pretty print
    JSON data: as single JSON records and as a stream. Therefore, we are going to
    implement two separate functions named `prettyPrint()` and `JSONstream()`, respectively.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节说明了如何美化打印 JSON 记录，这意味着以令人愉快和可读的格式打印 JSON 记录，而无需了解持有 JSON 记录的 Go 结构的内部结构。由于存在两种读取
    JSON 记录的方式，分别是个别读取和流式读取，因此存在两种美化打印 JSON 数据的方式：作为单个 JSON 记录和作为流。因此，我们将实现两个单独的函数，分别命名为
    `prettyPrint()` 和 `JSONstream()`。
- en: 'The implementation of the `prettyPrint()` function is the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`prettyPrint()` 函数的实现如下：'
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: All the work is done by `json.MarshalIndent()`, which applies indentation to
    format the output.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作都是由 `json.MarshalIndent()` 完成的，它应用缩进来格式化输出。
- en: Although both `json.MarshalIndent()` and `json.Marshal()` produce a JSON text
    result (byte slice), only `json.MarshalIndent()` allows applying customizable
    indentation, whereas `json.Marshal()` generates a more compact output.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `json.MarshalIndent()` 和 `json.Marshal()` 都产生 JSON 文本结果（字节切片），但只有 `json.MarshalIndent()`
    允许应用可定制的缩进，而 `json.Marshal()` 生成更紧凑的输出。
- en: 'For pretty printing streams of JSON data, you should use the `JSONstream()`
    function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于美化打印 JSON 数据流，你应该使用 `JSONstream()` 函数：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `json.NewEncoder()` function returns a new encoder that writes to a writer
    that is passed as a parameter to `json.NewEncoder()`. An encoder writes JSON values
    to an output stream. Similarly to `json.MarshalIndent()`, the `SetIndent()` method
    allows you to apply a customizable indent to a stream.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.NewEncoder()` 函数返回一个新的编码器，该编码器将写入作为 `json.NewEncoder()` 参数传递的写入器。编码器将
    JSON 值写入输出流。类似于 `json.MarshalIndent()`，`SetIndent()` 方法允许你将可定制的缩进应用于流。'
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: After we are done configuring the encoder, we are free to process the JSON stream
    using `Encode()`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成配置编码器后，我们可以自由地使用 `Encode()` 处理 JSON 流。
- en: 'These two functions are illustrated in `prettyPrint.go`, which generates JSON
    records using random data. Running `prettyPrint.go` produces the following kind
    of output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数在 `prettyPrint.go` 中得到了说明，它使用随机数据生成 JSON 记录。运行 `prettyPrint.go` 会产生以下类型的输出：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The previous output shows the beautified output of a single JSON record followed
    by the beautified output of a slice with two JSON records—all JSON records are
    represented as Go structures.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示了单个 JSON 记录的格式化输出，然后是包含两个 JSON 记录的切片的格式化输出——所有 JSON 记录都表示为 Go 结构。
- en: And now, we are going to deal with something completely different, which is
    the development of a powerful command line utility—Go is really good at it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理一些完全不同的事情，那就是开发一个强大的命令行工具——Go 在这方面真的很擅长。
- en: The viper package
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`viper` 包'
- en: '*Flags* are specially formatted strings that are passed into a program to control
    its behavior. Dealing with flags on your own might become very frustrating if
    you want to support multiple flags and options. Go offers the `flag` package to
    work with command line options, parameters, and flags. Although `flag` can do
    many things, it is not as capable as other external Go packages. Thus, if you
    are developing simple UNIX system command line utilities, you might find the `flag`
    package very interesting and useful. But you are not reading this book to create
    simple command line utilities! Therefore, I am going to skip the `flag` package
    and introduce you to an external package named `viper`, which is a powerful Go
    package that supports a plethora of options. `viper` uses the `pflag` package
    instead of `flag`, which is also illustrated in the code.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*标志* 是特殊格式的字符串，它们被传递到程序中以控制其行为。如果您想支持多个标志和选项，自己处理标志可能会变得非常令人沮丧。Go 提供了 `flag`
    包来处理命令行选项、参数和标志。尽管 `flag` 可以做很多事情，但它并不像其他外部 Go 包那样强大。因此，如果您正在开发简单的 UNIX 系统命令行工具，您可能会发现
    `flag` 包非常有趣和有用。但您不是在阅读这本书来创建简单的命令行工具！因此，我将跳过 `flag` 包，向您介绍一个名为 `viper` 的外部包，它是一个功能强大的
    Go 包，支持大量选项。`viper` 使用 `pflag` 包而不是 `flag`，这在代码中也有所说明。'
- en: All `viper` projects follow a pattern. First, you initialize `viper` and then
    you define the elements that interest you. After that, you get these elements
    and read their values in order to use them. The desired values can be taken either
    directly, which happens when you use the `flag` package from the standard Go library,
    or indirectly using configuration files. When using formatted configuration files
    in the JSON, YAML, TOML, HCL, or Java properties format, `viper` does all the
    parsing for you, which saves you from having to write and debug lots of Go code.
    `viper` also allows you to extract and save values in Go structures. However,
    this requires that the fields of the Go structure match the keys of the configuration
    file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `viper` 项目都遵循一个模式。首先，您初始化 `viper`，然后定义您感兴趣的部分。之后，您获取这些元素并按顺序读取它们的值以使用它们。所需的值可以直接获取，这发生在您使用标准
    Go 库中的 `flag` 包时，或者间接使用配置文件。当使用 JSON、YAML、TOML、HCL 或 Java 属性格式的格式化配置文件时，`viper`
    会为您解析所有内容，这可以节省您编写和调试大量 Go 代码的时间。`viper` 还允许您从 Go 结构中提取和保存值。然而，这要求 Go 结构的字段与配置文件的键匹配。
- en: The home page of `viper` is on GitHub ([https://github.com/spf13/viper](https://github.com/spf13/viper)).
    Please note that you are not obliged to use every capability of `viper` in your
    tools, just the features that you want. However, if your command line utility
    requires too many command line parameters and flags, then it would be better to
    use a configuration file instead.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`viper` 的主页位于 GitHub 上 ([https://github.com/spf13/viper](https://github.com/spf13/viper)).
    请注意，您并不需要在使用工具时强制使用 `viper` 的所有功能，只需使用您需要的功能即可。然而，如果您的命令行工具需要太多的命令行参数和标志，那么使用配置文件会更好。'
- en: Using command line flags
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行标志
- en: The first example shows how to write a simple utility that accepts two values
    as command line parameters and prints them on screen for verification. This means
    that we are going to need two command line flags for these two parameters.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例展示了如何编写一个简单的工具，该工具接受两个作为命令行参数的值，并在屏幕上打印它们以供验证。这意味着我们需要为这两个参数准备两个命令行标志。
- en: The relevant code is in `~/go/src/github.com/mactsouk/mGo4th/ch07/useViper`.
    You should replace `mGo4th` with the name of the actual GitHub repository of the
    book, or rename it `mGo4th`. Generally speaking, short directory names are more
    convenient.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 相关代码在 `~/go/src/github.com/mactsouk/mGo4th/ch07/useViper` 中。你应该将 `mGo4th` 替换为本书实际的
    GitHub 仓库名称，或者将其重命名为 `mGo4th`。一般来说，短目录名更方便。
- en: 'After that, you must go to the `~/go/src/github.com/mactsouk/mGo4th/ch07/useViper`
    directory and run the following commands:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你必须转到 `~/go/src/github.com/mactsouk/mGo4th/ch07/useViper` 目录并运行以下命令：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Keep in mind that the previous two commands should be executed when `useViper.go`
    is ready and include all the required external packages. The GitHub repository
    of the book contains the final versions of all programs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 `useViper.go` 准备好并包含所有必需的外部包时，应执行前面的两个命令。本书的 GitHub 仓库包含所有程序的最终版本。
- en: 'The implementation of `useViper.go` is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`useViper.go` 的实现如下：'
- en: '[PRE65]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We need to import both the `pflag` and `viper` packages, as we are going to
    use their functionality.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入 `pflag` 和 `viper` 包，因为我们将要使用它们的功能。
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `aliasNormalizeFunc()` function is used to create additional aliases for
    a flag, in this case, an alias for the `--password` flag. According to the existing
    code, the `--password` flag can be accessed as either `--pass` or `–ps`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`aliasNormalizeFunc()` 函数用于为标志创建额外的别名，在这种情况下，为 `--password` 标志创建别名。根据现有代码，`--password`
    标志可以通过 `--pass` 或 `–ps` 访问。'
- en: '[PRE67]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding code, we create a new flag called `name` that can also be accessed
    as `-n`. Its default value is `Mike`, and its description, which appears in the
    usage of the utility, is `Name parameter`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `name` 的新标志，也可以通过 `-n` 访问。它的默认值是 `Mike`，其描述，在实用程序的用法中显示，是
    `Name 参数`。
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We create another flag named `password` that can also be accessed as `-p` and
    has a default value of `hardToGuess` and a description. Additionally, we register
    a normalization function to generate aliases for the `password` flag.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `password` 的另一个标志，也可以通过 `-p` 访问，默认值为 `hardToGuess` 并带有描述。此外，我们注册了一个规范化函数来生成
    `password` 标志的别名。
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `pflag.Parse()` call should be used after all command line flags are defined.
    Its purpose is to parse the command line flags into the predefined flags.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义所有命令行标志之后，应使用 `pflag.Parse()` 调用。它的目的是将命令行标志解析到预定义的标志中。
- en: Additionally, the `viper.BindPFlags()` call makes all flags available to the
    `viper` package. Strictly speaking, we say that the `viper.BindPFlags()` call
    binds an existing set of `pflag` flags (`pflag.FlagSet`) to `viper`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`viper.BindPFlags()` 调用使所有标志对 `viper` 包可用。严格来说，我们说 `viper.BindPFlags()` 调用将现有的
    `pflag` 标志集（`pflag.FlagSet`）绑定到 `viper`。
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The previous commands show that you can read the values of two `string` command
    line flags using `viper.GetString()`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令显示你可以使用 `viper.GetString()` 读取两个 `string` 命令行标志的值。
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `viper` package can also work with environment variables. We first need
    to call `viper.BindEnv()` to tell `viper` which environment variable interests
    us, and then we can read its value by calling `viper.Get()`. If `GOMAXPROCS` is
    not already set, which means that its value is `nil`, the `fmt.Println()` call
    will not get executed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`viper` 包也可以与环境变量一起工作。我们首先需要调用 `viper.BindEnv()` 来告诉 `viper` 我们对哪个环境变量感兴趣，然后我们可以通过调用
    `viper.Get()` 来读取它的值。如果 `GOMAXPROCS` 还未设置，这意味着它的值是 `nil`，则 `fmt.Println()` 调用将不会执行。'
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Similarly, we can change the value of an environment variable with `viper.Set()`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `viper.Set()` 改变环境变量的值。
- en: 'The good thing is that `viper` automatically provides usage information:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 好事是 `viper` 自动提供用法信息：
- en: '[PRE73]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Using `useViper.go` without any command line arguments produces the following
    kind of output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 不带任何命令行参数使用 `useViper.go` 会产生以下类型的输出：
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: However, if we provide values for the command line flags, the output is going
    to be slightly different.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们为命令行标志提供值，输出将会略有不同。
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this second case, we used the shortcuts for the command line flags because
    it is faster to do so.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们使用了命令行标志的快捷方式，因为这样做更快。
- en: The next subsection discusses the use of JSON files to store configuration information
    in `viper`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论了在 `viper` 中使用 JSON 文件存储配置信息。
- en: Reading JSON configuration files
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取 JSON 配置文件
- en: 'The `viper` package can read JSON files to get its configuration, and this
    subsection illustrates how. Using text files to store configuration details can
    be very helpful when writing complex applications that require lots of data and
    setup. This is illustrated in `jsonViper.go`. Once again, we need to have `jsonViper.go`
    inside `~/go/src` as we did before: `~/go/src/github.com/mactsouk/mGo4th/ch07/jsonViper`.
    The code of `jsonViper.go` is as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`viper` 包可以读取 JSON 文件以获取其配置，本小节将说明如何操作。使用文本文件来存储配置细节在编写需要大量数据和设置的复杂应用程序时非常有帮助。这可以在
    `jsonViper.go` 中看到。再次强调，我们需要将 `jsonViper.go` 放在 `~/go/src` 目录下，就像之前做的那样：`~/go/src/github.com/mactsouk/mGo4th/ch07/jsonViper`。`jsonViper.go`
    的代码如下：'
- en: '[PRE76]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'There is an important point here: although we are using a JSON file to store
    the configuration, the Go structure uses `mapstructure` instead of `json` for
    the fields of the JSON configuration file.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的观点：尽管我们使用 JSON 文件来存储配置，但 Go 结构使用 `mapstructure` 而不是 `json` 作为 JSON 配置文件字段的类型。
- en: '[PRE77]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The previous four statements declare that we are using a JSON file, let `viper`
    know the path to the default configuration file, print the configuration file
    used, and read and parse that configuration file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的四个语句声明我们正在使用一个 JSON 文件，让 `viper` 知道默认配置文件的路径，打印所使用的配置文件，并读取和解析该配置文件。
- en: Keep in mind that `viper` does not check whether the configuration file actually
    exists and is readable. If the file cannot be found or read, `viper.ReadInConfig()`
    acts like it is processing an empty configuration file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`viper` 并不会检查配置文件实际上是否存在且可读。如果文件找不到或无法读取，`viper.ReadInConfig()` 就像它正在处理一个空配置文件一样处理。
- en: '[PRE78]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `viper.IsSet()` call checks whether a key named `macos` can be found in
    the configuration. If it is set, it reads its value using `viper.Get("macos")`
    and prints it on screen.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`viper.IsSet()` 调用检查配置中是否存在名为 `macos` 的键。如果已设置，它将使用 `viper.Get("macos")` 读取其值并在屏幕上打印。'
- en: '[PRE79]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the aforementioned code, we check whether the `active` key can be found before
    reading its value. If its value is equal to `true`, then we read the values from
    three more keys, named `postgres`, `mysql`, and `mongodb`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在读取值之前检查 `active` 键是否存在。如果其值等于 `true`，则从另外三个键（名为 `postgres`、`mysql`
    和 `mongodb`）中读取值。
- en: As the active key should hold a Boolean value, we use `viper.GetBool()` to read
    it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于活动键应该持有布尔值，我们使用 `viper.GetBool()` 来读取它。
- en: '[PRE80]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As expected, trying to read a key that does not exist fails.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，尝试读取一个不存在的键会失败。
- en: '[PRE81]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The call to `viper.Unmarshal()` allows you to put the information from the JSON
    configuration file into a properly defined Go structure—this is optional but handy.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`viper.Unmarshal()` 调用允许您将 JSON 配置文件中的信息放入正确定义的 Go 结构中——这是可选的但很方便。'
- en: '[PRE82]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The implementation of the `PrettyPrint()` function was presented in `prettyPrint.go`
    earlier on in this chapter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面已经介绍了 `PrettyPrint()` 函数的实现。
- en: 'Now, you need to download the dependencies of `jsonViper.go`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要下载 `jsonViper.go` 的依赖项：
- en: '[PRE83]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The contents of the current directory are as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当前目录的内容如下：
- en: '[PRE84]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The contents of the `myConfig.json` file used for testing are as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试的 `myConfig.json` 文件内容如下：
- en: '[PRE85]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Running `jsonViper.go` on the preceding JSON file produces the following output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 JSON 文件上运行 `jsonViper.go` 产生以下输出：
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The previous output is generated by `jsonViper.go` when parsing `myConfig.json`
    and trying to find the desired information.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出是由 `jsonViper.go` 在解析 `myConfig.json` 并尝试查找所需信息时生成的。
- en: The next section discusses a Go package for creating powerful and professional
    command line utilities, such as `docker` and `kubectl`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论一个用于创建强大和专业命令行工具的 Go 包，例如 `docker` 和 `kubectl`。
- en: The cobra package
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cobra 包
- en: '`cobra` is a very handy and popular Go package that allows you to develop command
    line utilities with commands, subcommands, and aliases. If you have ever used
    `hugo`, `docker`, or `kubectl`, you are going to realize immediately what the
    `cobra` package does, as all these tools are developed using `cobra`. Commands
    can have one or more aliases, which is very handy when you want to please both
    amateur and experienced users. `cobra` also supports persistent flags and local
    flags, which are flags that are available to all commands and flags that are available
    to given commands only, respectively. Also, by default, `cobra` uses `viper` for
    parsing its command line arguments.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`cobra` 是一个非常实用且流行的 Go 包，它允许您使用命令、子命令和别名来开发命令行实用程序。如果您曾经使用过 `hugo`、`docker`
    或 `kubectl`，您将立即意识到 `cobra` 包的作用，因为这些工具都是使用 `cobra` 开发的。命令可以有一个或多个别名，这在您想取悦业余和经验丰富的用户时非常有用。`cobra`
    还支持持久标志和局部标志，分别是适用于所有命令的标志和仅适用于给定命令的标志。此外，默认情况下，`cobra` 使用 `viper` 来解析其命令行参数。'
- en: All Cobra projects follow the same development pattern. You use the Cobra command
    line utility, you create commands, and then you make the desired changes to the
    generated Go source code files in order to implement the desired functionality.
    Depending on the complexity of your utility, you might need to make lots of changes
    to the created files. Although `cobra` saves you lots of time, you still have
    to write the code that implements the desired functionality for each command.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Cobra 项目都遵循相同的发展模式。您使用 Cobra 命令行工具，创建命令，然后对生成的 Go 源代码文件进行所需的更改以实现所需的功能。根据您工具的复杂度，您可能需要对创建的文件进行大量更改。尽管
    `cobra` 节省了您大量时间，但您仍然需要编写实现每个命令所需功能的代码。
- en: 'You need to take some extra steps in order to download the `cobra` binary the
    right way:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确下载 `cobra` 二进制文件，您需要采取一些额外的步骤：
- en: '[PRE87]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The previous command downloads the `cobra-cli` binary—this is the new name for
    the `cobra` binary executable. It is not necessary to know about all of the supported
    environment variables such as `GO111MODULE` but, sometimes, they can help you
    resolve tricky problems with your Go installation. So if you want to learn about
    your current Go environment, you can use the `go env` command.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令下载了 `cobra-cli` 二进制文件——这是 `cobra` 可执行二进制文件的新名称。您不需要了解所有支持的环境变量，例如 `GO111MODULE`，但有时它们可以帮助您解决与
    Go 安装相关的复杂问题。因此，如果您想了解您当前的 Go 环境，您可以使用 `go env` 命令。
- en: As I prefer to work using shorter utility names, I renamed `cobra-cli` to `cobra`.
    If you do not know how to do that or if you prefer to use `cobra-cli`, replace
    `~/go/bin/cobra` with `~/go/bin/cobra-cli` in all commands.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我更喜欢使用较短的实用程序名称，我将 `cobra-cli` 重命名为 `cobra`。如果您不知道如何做到这一点或者您更喜欢使用 `cobra-cli`，请在所有命令中将
    `~/go/bin/cobra` 替换为 `~/go/bin/cobra-cli`。
- en: 'For the purposes of this section, we are going to need a separate directory
    under `ch07`. As mentioned multiple times in this book, everything is going to
    be much easier if you put your code somewhere inside `~/go/src`; the exact place
    depends on you, but it would be ideal if you use something like `~/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra`,
    where `mGo4th` is the name of the directory in which you keep the source code
    files from this book. Provided that you are going to use the aforementioned directory,
    you are going to need to execute the next commands (**if you have downloaded the
    source code of the book, you do not need to do anything, as everything is going
    to be there**):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本节的目的，我们需要在 `ch07` 目录下创建一个单独的目录。正如本书多次提到的，如果您将代码放在 `~/go/src` 内的某个地方，一切都会变得容易得多；确切的位置取决于您，但使用类似
    `~/go/src/github.com/mactsouk/mGo4th/ch07/go-cobra` 这样的结构会更好，其中 `mGo4th` 是您保存本书源代码文件的目录名称。假设您将使用上述目录，您需要执行以下命令（**如果您已经下载了本书的源代码，您不需要做任何事情，因为所有内容都将在那里**）：
- en: '[PRE88]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'All output lines beginning with `go:` relate to Go modules and will appear
    only once. If you try to execute the utility, which is currently empty, you are
    going to get the following output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以 `go:` 开头的输出行都与 Go 模块相关，并且只会出现一次。如果您尝试执行当前为空的实用程序，您将得到以下输出：
- en: '[PRE89]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The last lines are the default message of a `cobra` project. We are going to
    modify that message later on. You are now ready to begin working with the `cobra`
    tool and add commands to the command line utility we are developing.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行是 `cobra` 项目的默认消息。我们稍后将对该消息进行修改。现在，您已经准备好开始使用 `cobra` 工具，并为我们正在开发的命令行实用程序添加命令。
- en: A utility with three commands
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个包含三个命令的工具
- en: 'This subsection illustrates the use of the `cobra add` command, which is used
    to add new commands to an existing `cobra` project. The names of the commands
    are `one`, `two`, and `three`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本节说明了 `cobra add` 命令的使用，该命令用于向现有的 `cobra` 项目添加新命令。命令的名称是 `one`、`two` 和 `three`：
- en: '[PRE90]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The previous commands create three new files in the `cmd` folder, named `one.go`,
    `two.go`, and `three.go`, which are the initial naïve implementations of the three
    commands.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令在 `cmd` 文件夹中创建了三个新文件，分别命名为 `one.go`、`two.go` 和 `three.go`，它们是三个命令的初始天真实现。
- en: The first thing you should usually do is delete any unwanted code from `root.go`
    and change the messages of the utility and each command, as described in the `Short`
    and `Long` fields. However, if you want, you can leave the source files unchanged.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常应该做的第一件事是从 `root.go` 中删除任何不需要的代码，并更改工具和每个命令的消息，如 `Short` 和 `Long` 字段中所述。然而，如果你想，你也可以保持源文件不变。
- en: The next subsection enriches the utility by adding command line flags to the
    commands.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节通过添加命令行标志到命令中丰富了工具的功能。
- en: Adding command line flags
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加命令行标志
- en: 'We are going to create two global command line flags and one command line flag
    that is attached to a given command (`two`) and not supported by the other two
    commands. Global command line flags are defined in the `./cmd/root.go` file. We
    are going to define two global flags, named `directory`, which is a string, and
    `depth`, which is an unsigned integer. Both global flags are defined in the `init()`
    function of `./cmd/root.go`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个全局命令行标志和一个附加到给定命令（`two`）但不受其他两个命令支持的命令行标志。全局命令行标志定义在 `./cmd/root.go`
    文件中。我们将定义两个名为 `directory` 的全局标志，它是一个字符串，以及名为 `depth` 的无符号整数。这两个全局标志都在 `./cmd/root.go`
    的 `init()` 函数中定义：
- en: '[PRE91]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We use `rootCmd.PersistentFlags()` to define global flags, followed by the data
    type of the flag. The name of the first flag is `directory` and its shortcut is
    `d`, whereas the name of the second flag is `depth` and has no shortcut—if you
    want to add a shortcut to it, you should use the `UintP()` method, as the `depth`
    parameter is an unsigned integer. After defining the two flags, we pass their
    control to `viper` by calling `viper.BindPFlag()`. The first flag is a `string`,
    whereas the second one is a `uint` value. As both of them are available in the
    `cobra` project, we call `viper.GetString("directory")` to get the value of the
    `directory` flag and `viper.GetUint("depth")` to get the value of the `depth`
    flag. This is not the only way to read the value of a flag and use it. You are
    going to see an alternative way when we update the statistics application.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `rootCmd.PersistentFlags()` 来定义全局标志，然后是标志的数据类型。第一个标志的名称是 `directory`，其快捷键是
    `d`，而第二个标志的名称是 `depth`，没有快捷键——如果你想为它添加快捷键，你应该使用 `UintP()` 方法，因为 `depth` 参数是一个无符号整数。定义了两个标志后，我们通过调用
    `viper.BindPFlag()` 将它们的控制权传递给 `viper`。第一个标志是 `string` 类型，而第二个是 `uint` 值。由于它们都在
    `cobra` 项目中可用，我们调用 `viper.GetString("directory")` 来获取 `directory` 标志的值，并调用 `viper.GetUint("depth")`
    来获取 `depth` 标志的值。这不是读取标志值并使用它的唯一方法。当我们在更新统计应用程序时，你将看到另一种方法。
- en: 'Last, we add a command line flag that is only available to the `two` command
    by adding the next line to the `init()` function of the `./cmd/two.go` file:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在 `./cmd/two.go` 文件的 `init()` 函数中添加下一行来添加一个仅对 `two` 命令可用的命令行标志：
- en: '[PRE92]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The name of the flag is `username`, and its shortcut is `u`. As this is a local
    flag available to the `two` command only, we can get its value by calling `cmd.Flags().GetString("username")`
    inside the `./cmd/two.go` file only.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 标志的名称是 `username`，其快捷键是 `u`。由于这是一个仅对 `two` 命令可用的本地标志，我们只能在 `./cmd/two.go` 文件中通过调用
    `cmd.Flags().GetString("username")` 来获取其值。
- en: The next subsection creates command aliases for the existing commands.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节为现有命令创建了命令别名。
- en: Creating command aliases
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命令别名
- en: In this subsection, we continue building on the code from the previous subsection
    by creating aliases for existing commands. This means that the commands `one`,
    `two`, and `three` will also be accessible as `cmd1`, `cmd2`, and `cmd3`, respectively.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过为现有命令创建别名来继续构建前一个子节中的代码。这意味着命令 `one`、`two` 和 `three` 分别也可以通过 `cmd1`、`cmd2`
    和 `cmd3` 访问。
- en: 'In order to do that, you need to add an extra field named `Aliases` to the
    `cobra.Command` structure of each command. The data type of the `Aliases` field
    is *string slice*. So, for the `one` command, the beginning of the `cobra.Command`
    structure in `./cmd/one.go` will look as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要为每个命令的 `cobra.Command` 结构添加一个名为 `Aliases` 的额外字段。`Aliases` 字段的类型是
    *字符串切片*。因此，对于 `one` 命令，`./cmd/one.go` 中 `cobra.Command` 结构的开始部分将如下所示：
- en: '[PRE93]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You should make similar changes to `./cmd/two.go` and `./cmd/three.go`. Please
    keep in mind that the **internal name** of the `one` command is `oneCmd` and continues
    to be—the other commands have analogous internal names.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对 `./cmd/two.go` 和 `./cmd/three.go` 进行类似的修改。请记住，`one` 命令的 **内部名称** 是 `oneCmd`，并且继续如此——其他命令有类似的对内部名称。
- en: If you accidentally put the `cmd1` alias, or any other alias, in multiple commands,
    the Go compiler will not complain. However, only its first occurrence gets executed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意外地将 `cmd1` 别名，或任何其他别名，放入多个命令中，Go 编译器不会抱怨。然而，只有它的第一次出现会被执行。
- en: The next subsection enriches the utility by adding subcommands for the `one`
    and `two` commands.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节通过为 `one` 和 `two` 命令添加子命令来丰富这个实用程序。
- en: Creating subcommands
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子命令
- en: 'This subsection illustrates how to create two subcommands for the command named
    `three`. The names of the two subcommands will be `list` and `delete`. The way
    to create them using the `cobra` utility is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节说明了如何为名为 `three` 的命令创建两个子命令。这两个子命令的名称将是 `list` 和 `delete`。使用 `cobra` 工具创建它们的方式如下：
- en: '[PRE94]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The previous commands create two new files inside `./cmd`, named `delete.go`
    and `list.go`. The `-p` flag is followed by the internal name of the command you
    want to associate the subcommands with. The internal name of the `three` command
    is `threeCmd`. You can verify that these two commands are associated with the
    `three` command as follows (the default message of each command is displayed):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令在 `./cmd` 中创建了两个新文件，分别命名为 `delete.go` 和 `list.go`。`-p` 标志后面跟着你想关联子命令的命令的内部名称。`three`
    命令的内部名称是 `threeCmd`。你可以验证这两个命令与 `three` 命令相关联，如下所示（显示每个命令的默认消息）：
- en: '[PRE95]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If you run `go run main.go two list`, Go considers list as a command line argument
    of `two`, and it will not execute the code in `./cmd/list.go`. The final version
    of the `go-cobra` project has the following structure and contains the following
    files, as generated by the `tree(1)` utility:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `go run main.go two list`，Go 会将 `list` 视为 `two` 的命令行参数，并且不会执行 `./cmd/list.go`
    中的代码。`go-cobra` 项目的最终版本具有以下结构和包含以下文件，这些文件是由 `tree(1)` 工具生成的：
- en: '[PRE96]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: At this point, you might wonder what happens when you want to create two subcommands
    with the same name for two different commands. In that case, you create the first
    subcommand and rename its file before creating the second one.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道当你想为两个不同的命令创建具有相同名称的两个子命令时会发生什么。在这种情况下，你首先创建第一个子命令，并在创建第二个子命令之前重命名其文件。
- en: The use of the `cobra` package is also illustrated in the final section, where
    we radically update the statistics application. The next section discusses some
    important additions that came with Go version 1.16.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中也展示了 `cobra` 包的使用，其中我们彻底更新了统计应用程序。下一节讨论了随着 Go 版本 1.16 带来的一些重要新增功能。
- en: Important Go features
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的 Go 功能
- en: Go 1.16 came with some new features, including embedding files in Go binaries
    as well as the introduction of the `os.ReadDir()` function, the `os.DirEntry`
    type, and the `io/fs` package.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.16 带来了一些新功能，包括在 Go 可执行文件中嵌入文件以及引入了 `os.ReadDir()` 函数、`os.DirEntry` 类型以及
    `io/fs` 包。
- en: As these features are related to systems programming, they are included and
    explored in the current chapter. We begin by presenting the embedding of files
    into Go binary executables.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些功能与系统编程相关，它们被包含并在本章中进行了探讨。我们首先介绍将文件嵌入到 Go 可执行文件中的方法。
- en: Embedding files
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入文件
- en: This section presents a feature that allows you to **embed static assets into
    Go binaries**. The allowed data types to keep an embedded file are `string`, `[]byte`,
    and `embed.FS`. This means that a Go binary may contain a file that you do not
    have to manually download when you execute the Go binary! The presented utility
    embeds two different files that it can retrieve based on the given command line
    argument.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一个功能，允许你 **将静态资源嵌入到 Go 可执行文件中**。允许保留嵌入文件的数据类型有 `string`、`[]byte` 和 `embed.FS`。这意味着一个
    Go 可执行文件可以包含一个你执行 Go 可执行文件时不需要手动下载的文件！所提供的实用程序嵌入了两份不同的文件，它可以根据给定的命令行参数检索它们。
- en: 'The code that follows, which is saved as `embedFiles.go`, illustrates this
    new Go feature:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码，保存为 `embedFiles.go`，说明了这个新的 Go 功能：
- en: '[PRE97]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You need the `embed` package in order to embed any files in your Go binaries.
    As the `embed` package is not used directly, you need to put `_` in front of it
    so that the Go compiler will not complain.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要 `embed` 包来在您的 Go 可执行文件中嵌入任何文件。由于 `embed` 包不是直接使用的，您需要在它前面放置 `_`，这样 Go 编译器就不会报错。
- en: '[PRE98]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: You need to begin a line with `//go:embed`, which denotes a Go comment but is
    treated in a special way, followed by the path to the file you want to embed.
    In this case, we embed `static/image.png`, which is a binary file. The next line
    should define the variable that is going to hold the data of the embedded file,
    which, in this case, is a byte slice named `f1`. Using a byte slice is recommended
    for binary files because we are going to directly use that byte slice to save
    that binary file.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在一行开头使用 `//go:embed`，这是一个 Go 注释但以特殊方式处理，后面跟要嵌入的文件路径。在这种情况下，我们嵌入 `static/image.png`，这是一个二进制文件。下一行应定义将要存储嵌入文件数据的变量，在这种情况下，是一个名为
    `f1` 的字节切片。使用字节切片推荐用于二进制文件，因为我们将直接使用该字节切片来保存该二进制文件。
- en: '[PRE99]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In this case, we save the contents of a plain text file, which is `static/textfile`,
    in a string variable named `f2`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将 `static/textfile` 的内容保存到名为 `f2` 的字符串变量中。
- en: '[PRE100]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The `writeToFile()` function is used to store a byte slice in a file and is
    a helper function that can be used in other cases as well.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeToFile()` 函数用于将字节切片存储到文件中，并且是一个可以在其他情况下使用的辅助函数。'
- en: '[PRE101]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This statement prints the lengths of the `f1` and `f2` variables to make sure
    that they represent the size of the embedded files.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句打印 `f1` 和 `f2` 变量的长度，以确保它们代表嵌入文件的尺寸。
- en: '[PRE102]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `switch` block is responsible for returning the desired file to the user—in
    the case of `static/textfile`, the file contents are printed on screen. For the
    binary file, we decided to store it as `/tmp/temporary.png`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 块负责向用户返回所需的文件——在 `static/textfile` 的情况下，文件内容被打印到屏幕上。对于二进制文件，我们决定将其存储为
    `/tmp/temporary.png`。'
- en: 'This time, we are going to compile `embedFiles.go` to make things more realistic,
    as it is the executable binary file that holds the embedded files. We build the
    binary file using `go build embedFiles.go`. Running `embedFiles` produces the
    following kind of output:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将编译 `embedFiles.go` 以使事情更现实，因为它是一个包含嵌入文件的可执行二进制文件。我们使用 `go build embedFiles.go`
    构建二进制文件。运行 `embedFiles` 产生以下类型的输出：
- en: '[PRE103]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The following output verifies that `temporary.png` is located at the right
    path (`/tmp/temporary.png`):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出验证了 `temporary.png` 位于正确的路径（`/tmp/temporary.png`）：
- en: '[PRE104]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Using the embedding functionality, we can create a utility that embeds its
    own source code and prints it on screen when it gets executed! This is a fun way
    of using embedded files. The source code of `printSource.go` is the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌入功能，我们可以创建一个嵌入其自身源代码并在执行时打印到屏幕上的实用程序！这是一种有趣的嵌入文件的方式。`printSource.go` 的源代码如下：
- en: '[PRE105]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: As before, the file that is being embedded is defined in the `//go:embed` line.
    Running `printSource.go` prints the aforementioned code on screen.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，被嵌入的文件在 `//go:embed` 行中定义。运行 `printSource.go` 将上述代码打印到屏幕上。
- en: ReadDir and DirEntry
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReadDir 和 DirEntry
- en: 'This section discusses `os.ReadDir()` and `os.DirEntry`. However, it begins
    by discussing the deprecation of the `io/ioutil` package—the functionality of
    the `io/ioutil` package has been transferred to other packages. So, we have the
    following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论 `os.ReadDir()` 和 `os.DirEntry`。然而，它首先讨论了 `io/ioutil` 包的弃用——`io/ioutil`
    包的功能已转移到其他包。因此，我们有以下内容：
- en: '`os.ReadDir()`, which is a new function, returns `[]DirEntry`. This means that
    it cannot directly replace `ioutil.ReadDir()`, which returns `[]FileInfo`. Although
    neither `os.ReadDir()` nor `os.DirEntry` offer any new functionality, they make
    things faster and simpler, which is important.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.ReadDir()` 是一个新函数，返回 `[]DirEntry`。这意味着它不能直接替换返回 `[]FileInfo` 的 `ioutil.ReadDir()`。尽管
    `os.ReadDir()` 和 `os.DirEntry` 都没有提供任何新功能，但它们使事情更快更简单，这很重要。'
- en: The `os.ReadFile()` function directly replaces `ioutil.ReadFile()`.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.ReadFile()` 函数直接替换了 `ioutil.ReadFile()`。'
- en: The `os.WriteFile()` function can directly replace `ioutil.WriteFile()`.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.WriteFile()` 函数可以直接替换 `ioutil.WriteFile()`。'
- en: Similarly, `os.MkdirTemp()` can replace `ioutil.TempDir()` without any changes.
    However, as the `os.TempDir()` name was already taken, the new function name is
    different.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，`os.MkdirTemp()`可以替换`ioutil.TempDir()`而不做任何更改。然而，由于`os.TempDir()`的名称已经被占用，新的函数名称不同。
- en: The `os.CreateTemp()` function is the same as `ioutil.TempFile()`. Although
    the name `os.TempFile()` was not taken, the Go people decided to name it `os.CreateTemp()`
    in order to be on a par with `os.MkdirTemp()`.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.CreateTemp()`函数与`ioutil.TempFile()`相同。尽管`os.TempFile()`的名称没有被占用，但Go团队决定将其命名为`os.CreateTemp()`，以便与`os.MkdirTemp()`保持一致。'
- en: Both `os.ReadDir()` and `os.DirEntry` can be found as `fs.ReadDir()` and `fs.DirEntry`
    in the `io/fs` package to work with the file system interface found in `io/fs`.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.ReadDir()`和`os.DirEntry`可以在`io/fs`包中找到，作为`fs.ReadDir()`和`fs.DirEntry`，以与`io/fs`中找到的文件系统接口一起工作。'
- en: The `ReadDirEntry.go` utility illustrates the use of `os.ReadDir()`. Additionally,
    we are going to see `fs.DirEntry` in combination with `fs.WalkDir()` in action
    in the next section—`io/fs` only supports `WalkDir()`, which uses `DirEntry` by
    default. Both `fs.WalkDir()` and `filepath.WalkDir()` use `DirEntry` instead of
    `FileInfo`. This means that in order to see any performance improvements when
    walking directory trees, you need to change `filepath.Walk()` calls to `filepath.WalkDir()`
    calls.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadDirEntry.go`实用程序展示了`os.ReadDir()`的使用。此外，我们将在下一节中看到`fs.DirEntry`与`fs.WalkDir()`结合使用的情况——`io/fs`只支持`WalkDir()`，它默认使用`DirEntry`。`fs.WalkDir()`和`filepath.WalkDir()`都使用`DirEntry`而不是`FileInfo`。这意味着，为了在遍历目录树时看到任何性能提升，您需要将`filepath.Walk()`调用更改为`filepath.WalkDir()`调用。'
- en: 'The presented utility calculates the size of a directory tree using `os.ReadDir()`,
    with the help of the following function:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所提供的实用程序使用`os.ReadDir()`来计算目录树的大小，并借助以下函数：
- en: '[PRE106]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: If the return value of `entry.IsDir()` is `true`, then we process a directory,
    which means that we need to keep digging.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`entry.IsDir()`的返回值是`true`，那么我们处理一个目录，这意味着我们需要继续深入挖掘。
- en: '[PRE107]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If we process a file, then we just need to get its size. This involves calling
    `Info()` to get general information about the file and then `Size()` to get its
    size:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理一个文件，我们只需要获取它的大小。这涉及到调用`Info()`来获取关于文件的一般信息，然后调用`Size()`来获取它的大小：
- en: '[PRE108]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Running `ReadDirEntry.go` produces the next output, which indicates that the
    utility works as expected:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`ReadDirEntry.go`会产生以下输出，这表明实用程序按预期工作：
- en: '[PRE109]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Last, keep in mind that both `ReadDir` and `DirEntry` are copied from the Python
    programming language.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，`ReadDir`和`DirEntry`都是从Python编程语言中复制的。
- en: The next section introduces us to the `io/fs` package.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节介绍了`io/fs`包。
- en: The io/fs package
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`io/fs`包'
- en: This section illustrates the functionality of the `io/fs` package, which was
    also introduced in Go 1.16\. As `io/fs` offers a unique kind of functionality,
    we begin this section by explaining what it can do. Put simply, `io/fs` offers
    a read-only file system interface named `FS`. Note that `embed.FS` implements
    the `fs.FS` interface, which means that `embed.FS` can take advantage of some
    of the functionality offered by the `io/fs` package. **This means that your applications
    can create their own internal file systems and work with their files**.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 本节说明了`io/fs`包的功能，该包也在Go 1.16中引入。由于`io/fs`提供了一种独特类型的函数，因此我们开始本节，解释它能够做什么。简单来说，`io/fs`提供了一个名为`FS`的只读文件系统接口。请注意，`embed.FS`实现了`fs.FS`接口，这意味着`embed.FS`可以利用`io/fs`包提供的一些功能。**这意味着您的应用程序可以创建自己的内部文件系统并处理其文件**。
- en: 'The code example that follows, which is saved as `ioFS.go`, creates a file
    system using `embed` by putting all the files of the `./static` folder in there.
    `ioFS.go` supports the following functionality: list all files, search for a filename,
    and extract a file using `list()`, `search()`, and `extract()`, respectively.
    We begin by presenting the implementation of `list()`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例，保存为`ioFS.go`，通过将`./static`文件夹中的所有文件放入其中来创建一个文件系统。`ioFS.go`支持以下功能：列出所有文件，搜索文件名，以及使用`list()`、`search()`和`extract()`分别提取文件。我们首先展示`list()`的实现：
- en: '[PRE110]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Keep in mind that `fs.WalkDir()` works with regular file systems as well as
    `embed.FS` file systems. You can learn more about the signature of `walkFunction()`
    by running `go doc fs.WalkDirFunc`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`fs.WalkDir()`与常规文件系统以及`embed.FS`文件系统一起工作。您可以通过运行`go doc fs.WalkDirFunc`来了解更多关于`walkFunction()`签名的信息。
- en: 'Here, we begin with the given directory of a file system and visit its contents.
    The file system is stored in `f` and the root directory is defined as `"."`. After
    that, all the magic happens in the `walkFunction()` function, which is implemented
    as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从文件系统的给定目录开始，访问其内容。文件系统存储在 `f` 中，根目录定义为 `"."`。之后，所有魔法都在 `walkFunction()`
    函数中发生，该函数的实现如下：
- en: '[PRE111]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `walkFunction()` function processes every entry in the given root directory
    in the desired way. Keep in mind that the `walkFunc()` is **automatically called**
    by `fs.WalkDir()` to visit each file or directory.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`walkFunction()` 函数以期望的方式处理给定根目录中的每个条目。请注意，`walkFunc()` 是由 `fs.WalkDir()` **自动调用**的，以访问每个文件或目录。'
- en: 'Then, we present the implementation of the `extract()` function:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们展示 `extract()` 函数的实现：
- en: '[PRE112]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The `ReadFile()` function is used to retrieve a file, which is identified by
    its file path, from the `embed.FS` file system as a byte slice, which is returned
    from the `extract()` function.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ReadFile()` 函数从 `embed.FS` 文件系统检索一个文件，该文件通过其文件路径标识，并以字节切片的形式返回，这是 `extract()`
    函数的返回值。
- en: 'Last, we have the implementation of the `search()` function, which is based
    on `walkSearch()`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `search()` 函数的实现，该函数基于 `walkSearch()`：
- en: '[PRE113]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '`searchString` is a global variable that holds the search string. When a match
    is found, the matching path is printed on screen.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchString` 是一个全局变量，用于存储搜索字符串。当找到匹配项时，匹配的路径会打印在屏幕上。'
- en: '[PRE114]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Before printing a match, we make a call to `fs.Stat()` to get more details
    about it:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印匹配项之前，我们调用 `fs.Stat()` 来获取更多关于它的详细信息：
- en: '[PRE115]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `main()` function specifically calls these three functions. Running `ioFS.go`
    produces the following kind of output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数特别调用这三个函数。运行 `ioFS.go` 产生以下类型的输出：'
- en: '[PRE116]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Initially, the utility lists all files in the file system (lines beginning with
    `Path`). Then, it verifies that `static/file.txt` can be found in the file system.
    Last, it verifies that the writing of 14 bytes into a new file was successful,
    as all 14 bytes have been written.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，实用程序列出文件系统中的所有文件（以 `Path` 开头的行）。然后，它验证 `static/file.txt` 是否可以在文件系统中找到。最后，它验证将
    14 个字节写入新文件是否成功，因为所有 14 个字节都已写入。
- en: So it turns out that Go version 1.16 introduced important functionality.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Go 版本 1.16 引入了重要的功能。
- en: In the next section, we are going to improve the statistics application.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将改进统计应用程序。
- en: Updating the statistics application
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新统计应用程序
- en: In this section, we will change the format that the statistics application uses
    to store its data. This time, the statistics application is going to use the JSON
    format. Additionally, it uses the `cobra` package to implement the supported commands.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更改统计应用程序存储其数据所使用的格式。这次，统计应用程序将使用 JSON 格式。此外，它使用 `cobra` 包来实现支持的命令。
- en: However, before continuing with the statistics application, we are going to
    learn more about the `slog` package.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续统计应用程序之前，我们将更多地了解 `slog` 包。
- en: The slog package
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The slog 包
- en: The `log/slog` package was added to the standard Go library with Go 1.21 in
    order to improve the original `log` package. You can find more information about
    it at [https://pkg.go.dev/log/slog](https://pkg.go.dev/log/slog). The main reason
    for including it in this chapter is that it can create log entries in the JSON
    format, which is handy when you want to further process log entries.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.21 中将 `log/slog` 包添加到标准库中，以改进原始的 `log` 包。您可以在 [https://pkg.go.dev/log/slog](https://pkg.go.dev/log/slog)
    找到更多关于它的信息。将其包含在本章中的主要原因是它能够以 JSON 格式创建日志条目，这在您想要进一步处理日志条目时非常有用。
- en: 'The code of `useSLog.go` that illustrates the use of the `log/slog` package
    is going to be presented in three parts. The first part is the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 将展示 `useSLog.go` 代码，该代码说明了 `log/slog` 包的使用，分为三个部分。第一部分如下：
- en: '[PRE117]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: First, we need to import `log/slog` for using the `slog` package of the Go standard
    library. When using the default logger, we can send messages using `Error()`,
    `Debug()`, `Info()`, and `Warn()`, which is the simplest way of using the functionality
    of `slog`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入 `log/slog` 以使用 Go 标准库中的 `slog` 包。当使用默认日志记录器时，我们可以使用 `Error()`、`Debug()`、`Info()`
    和 `Warn()` 发送消息，这是使用该功能的最简单方式。
- en: 'The second part contains the following code:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下代码：
- en: '[PRE118]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In this part of the program, we get the current log level using `&slog.LevelVar{}`
    and change it to the `Debug` level in order to also get the log entries issued
    with `logger.Debug()`. This is implemented with the `logLevel.Set(slog.LevelDebug)`
    statement.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序的部分，我们使用 `&slog.LevelVar{}` 获取当前的日志级别，并将其更改为 `Debug` 级别，以便也能获取使用 `logger.Debug()`
    发布的日志条目。这是通过 `logLevel.Set(slog.LevelDebug)` 语句实现的。
- en: 'The last part of `useSLog.go` comes with the following code:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSLog.go` 的最后一部分包含以下代码：'
- en: '[PRE119]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The presented code creates a logger that writes JSON records.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的代码创建了一个写入 JSON 记录的日志记录器。
- en: 'Running `useSLog.go` produces the following output:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `useSLog.go` 产生以下输出：
- en: '[PRE120]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The previous output is from the first four statements of `main()`. The `slog.Debug()`
    statement generated no output because the `DEBUG` level does not get printed by
    default.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出来自 `main()` 的前四个语句。`slog.Debug()` 语句没有生成输出，因为默认情况下不会打印 `DEBUG` 级别。
- en: '[PRE121]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The previous output shows that if we increase the logging level, we can get
    `DEBUG` messages printed—the default logging level was `INFO`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示，如果我们提高日志级别，我们可以打印出 `DEBUG` 消息——默认的日志级别是 `INFO`。
- en: '[PRE122]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The last line of the output shows logging information in the JSON format. This
    can be very handy if we want to store log entries in a regular or a time series
    database for further processing, visualization, or data analysis.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一行显示了以 JSON 格式的日志信息。如果我们想将日志条目存储在常规数据库或时间序列数据库中以便进一步处理、可视化或数据分析，这将非常有用。
- en: Sending logs to io.Discard
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日志发送到 io.Discard
- en: 'This subsection presents a trick that involves the use of `io.Discard` for
    sending log entries—`io.Discard` discards all `Write()` calls without doing anything!
    Although we are going to apply the trick to log files, it can also be used in
    other cases where writing data is involved. The implementation of the `main()`
    function in `discard.go` is the following:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节介绍了一个涉及使用 `io.Discard` 发送日志条目的技巧——`io.Discard` 会丢弃所有 `Write()` 调用而不做任何操作！尽管我们将此技巧应用于日志文件，但它也可以用于涉及写入数据的其他情况。`discard.go`
    中 `main()` 函数的实现如下：
- en: '[PRE123]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The condition that enables or disables writing is simplistic: when there is
    a single command line argument, logging is enabled; otherwise, it is disabled.
    The statement that disables logging is `log.SetOutput(io.Discard)`. However, before
    logging is disabled, we print a log entry stating so.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 启用或禁用写入的条件很简单：当存在单个命令行参数时，启用日志记录；否则，禁用。禁用日志的语句是 `log.SetOutput(io.Discard)`。然而，在禁用日志之前，我们打印一条日志条目说明这一点。
- en: 'Running `discard.go` generates the following output:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `discard.go` 产生以下输出：
- en: '[PRE124]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: In the second program execution, the `log.Println("NOT GOING TO GET THAT!")`
    statement generates no output, as it went to `io.Discard`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次程序执行中，`log.Println("NOT GOING TO GET THAT!")` 语句没有产生输出，因为它被发送到了 `io.Discard`。
- en: With all this information in mind, let us continue with the implementation of
    the statistics application with the help of `cobra`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑所有这些信息后，让我们在 `cobra` 的帮助下继续实现统计应用程序。
- en: Using cobra
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 cobra
- en: 'First, we need to create a place to host the `cobra` version of the statistics
    application. At this point, you have two options: either create a separate GitHub
    repository or put the necessary files in a directory under `~/go/src`. This subsection
    is going to follow the latter option. As a result, all relevant code is going
    to reside at `~/go/src/github.com/mactsouk/mGo4th/ch07/stats`.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个地方来托管统计应用程序的 `cobra` 版本。在这个阶段，你有两个选择：要么创建一个单独的 GitHub 仓库，要么将必要的文件放在
    `~/go/src` 目录下。本小节将遵循后者。因此，所有相关的代码都将位于 `~/go/src/github.com/mactsouk/mGo4th/ch07/stats`。
- en: The project is already present in the `stats` directory. The presented steps
    make sense if you want to create it on your own.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 项目已经存在于 `stats` 目录中。如果你想要自己创建它，这些步骤是有意义的。
- en: 'First, we need to create and go to the relevant directory:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建并进入相关的目录：
- en: '[PRE125]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'After that, we should declare that we want to use Go modules:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们应该声明我们想要使用 Go 模块：
- en: '[PRE126]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'After that, we need to run the `cobra init` command:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要运行 `cobra init` 命令：
- en: '[PRE127]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Then, we can execute `go mod tidy`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行 `go mod tidy`：
- en: '[PRE128]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Then, we should create the structure of the application using the `cobra` (or
    `cobra-cli`) binary. **Once we have the structure, it is easy to know what we
    have to implement**. The structure of the application is based on the supported
    commands and functionality:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该使用 `cobra`（或 `cobra-cli`）二进制文件创建应用程序的结构。**一旦我们有了结构，就很容易知道我们需要实现什么**。应用程序的结构基于支持的命令和功能：
- en: '[PRE129]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: At this point, executing `go run main.go` is going to download any missing packages
    and generate the default `cobra` output.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，执行 `go run main.go` 将会下载任何缺失的包并生成默认的 `cobra` 输出。
- en: 'We need to create a command line flag to enable and disable logging. We are
    going to be using the `log/slog` package. The flag is called `--log` and is going
    to be a Boolean variable. The relevant statement, which is located in `root.go`,
    is the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个命令行标志来启用和禁用日志记录。我们将使用 `log/slog` 包。该标志名为 `--log`，它将是一个布尔变量。位于 `root.go`
    中的相关语句如下：
- en: '[PRE130]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The previous statement is supported by a global variable, which is defined
    as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明由一个全局变量支持，定义如下：
- en: '[PRE131]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This is a different approach regarding the use of the command line flags than
    what we did in the `go-cobra` project presented earlier.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用命令行标志方面与我们之前在 `go-cobra` 项目中所做的方法不同的一个方法。
- en: So, the value of the `disableLogging` global variable holds the value of the
    `--log` flag. Although the `disableLogging` variable is global, you have to define
    **a separate logger variable in each one of the commands**.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`disableLogging` 全局变量的值保存了 `--log` 标志的值。尽管 `disableLogging` 变量是全局的，但你必须在每个命令中定义**一个单独的日志变量**。
- en: The next subsection discusses the storing and loading of JSON data.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论了 JSON 数据的存储和加载。
- en: Storing and loading JSON data
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储和加载 JSON 数据
- en: 'This functionality of the `saveJSONFile()` helper function is implemented in
    `./cmd/root.go`, using the following function:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveJSONFile()` 辅助函数的这个功能在 `./cmd/root.go` 中实现，使用以下函数：'
- en: '[PRE132]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Basically, all we have to do is serialize the slice of structures using `Serialize()`
    and save the result in a file. Next, we need to be able to load the JSON data
    from that file. The loading functionality is also implemented in `./cmd/root.go`,
    using the `readJSONFile()` helper function:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们只需要使用 `Serialize()` 将结构体切片序列化，并将结果保存到文件中。接下来，我们需要能够从该文件中加载 JSON 数据。加载功能也在
    `./cmd/root.go` 中实现，使用 `readJSONFile()` 辅助函数：
- en: '[PRE133]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: All we have to do is read the data file with the JSON data and put that data
    into a slice of structures by deserializing it.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是读取包含 JSON 数据的数据文件，并通过反序列化将其数据放入结构体切片中。
- en: Now, we are going to discuss the implementation of the `list` and `insert` commands.
    The other two commands (`delete` and `search`) have similar implementations.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论 `list` 和 `insert` 命令的实现。其他两个命令（`delete` 和 `search`）有类似的实现。
- en: Implementing the list command
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现列表命令
- en: 'The important code of `./cmd/list.go` is in the implementation of the `list()`
    function:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`./cmd/list.go` 中的重要代码在 `list()` 函数的实现中：'
- en: '[PRE134]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The core functionality of `list` is included in the previous code, which sorts
    the `data` slice and pretty prints the JSON records using `PrettyPrintJSONstream(data)`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 的核心功能包含在上面的代码中，它使用 `PrettyPrintJSONstream(data)` 对 `data` 切片进行排序并格式化打印
    JSON 记录。'
- en: '[PRE135]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The previous code deals with logging based on the value of `disableLogging`,
    which is based on the `--log` flag.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码根据 `disableLogging` 的值处理日志，该值基于 `--log` 标志。
- en: Implementing the insert command
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现插入命令
- en: 'The implementation of the `insert` command is as follows:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 命令的实现如下：'
- en: '[PRE136]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: First, we define a separate logger for the `insert` command based on the value
    of `disableLogging`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据 `disableLogging` 的值为 `insert` 命令定义一个单独的日志记录器。
- en: '[PRE137]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Then, the previous code makes sure that the `file` variable, which is the path
    to the file that contains the data, is not empty. Additionally, if `file` is a
    key of the `index` map, it means that we have processed that file previously—**we
    assume that no two datasets have the same filename, as for us, the filename is
    what uniquely identifies the datasets**. In that case, we delete it from the `data`
    slice and the `index` map, and we process it again. This is similar to the `update`
    functionality, which is not directly supported by the application.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，前面的代码确保 `file` 变量（包含数据的文件路径）不为空。另外，如果 `file` 是 `index` 映射的一个键，这意味着我们之前已经处理过该文件——**我们假设没有两个数据集有相同的文件名，因为对我们来说，文件名是唯一标识数据集的东西**。在这种情况下，我们从
    `data` 切片和 `index` 映射中删除它，并再次处理它。这与 `update` 功能类似，该功能应用程序不支持。
- en: '[PRE138]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The last part of the implementation of the `insert` command is about processing
    the given file, using `ProcessFile()`, and saving the updated version of the `data`
    slice, using `saveJSONFile()`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 命令实现的最后部分是处理给定的文件，使用 `ProcessFile()`，并使用 `saveJSONFile()` 保存 `data`
    切片的更新版本。'
- en: Summary
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was about working with environment variables, command line arguments,
    reading and writing plain text files, traversing file systems, working with JSON
    data, and creating powerful command line utilities using `cobra`. This is one
    of the most important chapters of this book because you cannot create any real-world
    utility without interacting with the operating system as well as the file system,
    and without reading and saving data.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用环境变量、命令行参数、读取和写入纯文本文件、遍历文件系统、处理JSON数据以及使用`cobra`创建强大的命令行实用工具。这是本书最重要的章节之一，因为不与操作系统以及文件系统交互，不读取和保存数据，就无法创建任何真正的实用工具。
- en: The next chapter is about concurrency in Go, with the main subjects being goroutines,
    channels, and data sharing with safety. We are also going to talk about UNIX signal
    handling, as Go uses channels and goroutines for this purpose.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍Go语言中的并发，主要主题包括goroutines、channels以及安全的数据共享。我们还将讨论UNIX信号处理，因为Go使用channels和goroutines来完成这个目的。
- en: Exercises
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Use the functionality of `byCharacter.go`, `byLine.go`, and `byWord.go` in order
    to create a simplified version of the `wc(1)` UNIX utility.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`byCharacter.go`、`byLine.go`和`byWord.go`的功能，创建`wc(1)` UNIX实用工具的简化版本。
- en: Create a full version of the `wc(1)` UNIX utility, using the `viper` package
    to process command line options.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`viper`包处理命令行选项，创建`wc(1)` UNIX实用工具的完整版本。
- en: Create a full version of the `wc(1)` UNIX utility, using commands instead of
    command line options, with the help of the `cobra` package.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cobra`包，通过命令而不是命令行选项创建`wc(1)` UNIX实用工具的完整版本。
- en: Go offers `bufio.Scanner` to read files line by line. Try to rewrite `byLine.go`
    using `bufio.Scanner`.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go提供了`bufio.Scanner`来逐行读取文件。尝试使用`bufio.Scanner`重写`byLine.go`。
- en: The `bufio.Scanner` in Go is designed to read input line by line, splitting
    it into tokens. If you need to read a file character by character, a common approach
    is to use `bufio.NewReader` in conjunction with `Read()` or `ReadRune()`. Implement
    the functionality of `byCharacter.go` this way.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言中的`bufio.Scanner`设计为逐行读取输入，将其分割成标记。如果你需要逐字符读取文件，一个常见的方法是结合使用`bufio.NewReader`和`Read()`或`ReadRune()`。以这种方式实现`byCharacter.go`的功能。
- en: Make `ioFS.go` a `cobra` project.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ioFS.go`作为`cobra`项目。
- en: Update the statistics application `cobra` project in order to also store the
    normalized version of the dataset in `data.json`.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`cobra`项目中的统计应用程序，以便也将数据集的归一化版本存储在`data.json`中。
- en: The `byLine.go` utility uses `ReadString('\n')` to read the input file. Modify
    the code to use `Scanner` ([https://pkg.go.dev/bufio#Scanner](https://pkg.go.dev/bufio#Scanner))
    for reading.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byLine.go`实用工具使用`ReadString(''\n'')`读取输入文件。修改代码以使用`Scanner` ([https://pkg.go.dev/bufio#Scanner](https://pkg.go.dev/bufio#Scanner))进行读取。'
- en: Similarly, `byWord.go` uses `ReadString('\n')` to read the input file. Modify
    the code to use `Scanner` instead.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，`byWord.go`使用`ReadString('\n')`读取输入文件。修改代码以使用`Scanner`代替。
- en: Additional resources
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The `viper` package: [https://github.com/spf13/viper](https://github.com/spf13/viper)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viper`包：[https://github.com/spf13/viper](https://github.com/spf13/viper)'
- en: 'The `cobra` package: [https://github.com/spf13/cobra](https://github.com/spf13/cobra)'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cobra`包：[https://github.com/spf13/cobra](https://github.com/spf13/cobra)'
- en: 'The documentation for `encoding/json`: [https://pkg.go.dev/encoding/json](https://pkg.go.dev/encoding/json)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding/json`的文档：[https://pkg.go.dev/encoding/json](https://pkg.go.dev/encoding/json)'
- en: 'The documentation for `io/fs`: [https://pkg.go.dev/io/fs](https://pkg.go.dev/io/fs)'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io/fs`的文档：[https://pkg.go.dev/io/fs](https://pkg.go.dev/io/fs)'
- en: 'Go `slog` package: [http://gopherguides.com/articles/golang-slog-package](http://gopherguides.com/articles/golang-slog-package)'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go `slog`包：[http://gopherguides.com/articles/golang-slog-package](http://gopherguides.com/articles/golang-slog-package)
- en: 'A comprehensive guide to logging in Go with `slog`: [https://betterstack.com/community/guides/logging/logging-in-go/](https://betterstack.com/community/guides/logging/logging-in-go/)'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`slog`在Go中进行日志记录的全面指南：[https://betterstack.com/community/guides/logging/logging-in-go/](https://betterstack.com/community/guides/logging/logging-in-go/)
- en: 'Endian-ness: [https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness
    )'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端序：[https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness)
- en: Join our community on Discord
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6)'
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6)'
