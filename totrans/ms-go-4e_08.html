<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer139">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 class="chapterTitle" id="_idParaDest-219"><span class="koboSpan" id="kobo.2.1">Go Concurrency</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">The key component of the Go concurrency</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.4.1"> model is the goroutine, which is the </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.5.1">minimum executable entity</span></strong><span class="koboSpan" id="kobo.6.1"> in Go. </span><span class="koboSpan" id="kobo.6.2">To create a new goroutine, we must use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.7.1">go</span></code><span class="koboSpan" id="kobo.8.1"> keyword followed by a function call or an anonymous function—the two methods are equivalent. </span><span class="koboSpan" id="kobo.8.2">For a goroutine or a function to terminate the entire Go application, it should call </span><code class="inlineCode"><span class="koboSpan" id="kobo.9.1">os.Exit()</span></code><span class="koboSpan" id="kobo.10.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.11.1">return</span></code><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">However, most of the time, we exit a goroutine or a function using </span><code class="inlineCode"><span class="koboSpan" id="kobo.13.1">return</span></code><span class="koboSpan" id="kobo.14.1"> because what we really want is to exit that specific goroutine or function and not stop the entire application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.15.1">Everything in Go is executed as a goroutine, either transparently or consciously. </span><span class="koboSpan" id="kobo.15.2">Each executable Go program has at least one goroutine, which is used for running the </span><code class="inlineCode"><span class="koboSpan" id="kobo.16.1">main()</span></code><span class="koboSpan" id="kobo.17.1"> function of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.18.1">main</span></code><span class="koboSpan" id="kobo.19.1"> package. </span><span class="koboSpan" id="kobo.19.2">Each goroutine is executed on a single OS thread according to the instructions of the Go scheduler, which is responsible for the execution of goroutines—the developer has no control over the amount of memory allocated to a goroutine. </span><span class="koboSpan" id="kobo.19.3">The OS scheduler does not dictate how many threads the Go runtime is going to create because the Go runtime will spawn enough threads to ensure that </span><code class="inlineCode"><span class="koboSpan" id="kobo.20.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.21.1"> threads are available to run the Go code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.22.1">However, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.23.1">goroutines cannot communicate with each other directly</span></strong><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">Data sharing in Go is implemented using either channels, local sockets, or shared memory. </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Channels</span></em><span class="koboSpan" id="kobo.26.1"> act as the glue that connects multiple goroutines. </span><span class="koboSpan" id="kobo.26.2">On the other hand, channels cannot process data or execute code but they can send data to and receive data from goroutines and have a special purpose like acting as signals or specifying the order of execution for goroutines.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.27.1">When I first learned about channels, I thought that they were a great idea, much better than shared memory, and I wanted to use channels everywhere! </span><span class="koboSpan" id="kobo.27.2">However, nowadays</span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.28.1"> I only use channels when I have no other alternative</span></strong><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">Look at the implementation of the concurrent statistical application at the end of the chapter to realize that there exist designs that do not require the use of channels. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.30.1">Although the use of channels to communicate and synchronize between goroutines is very typical and expected, channels might introduce deadlocks, overhead, and complexity to the design, as well as performance considerations, especially when low-latency communication is a priority.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.31.1">When you combine multiple channels and goroutines, you can create</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.32.1"> data flows, which, in Go terminology, are called pipelines. </span><span class="koboSpan" id="kobo.32.2">So, you might have a goroutine that reads data from a database and sends it to a channel and a second goroutine that reads from that channel, processes that data, and sends it to another channel to be read from another goroutine, before making modifications to the data and storing it in another database.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.33.1">This chapter covers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.34.1">Processes, threads, and goroutines</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.35.1">The Go scheduler</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.36.1">Goroutines</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.37.1">Channels</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.38.1">Race conditions are bad</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.39.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.40.1">select</span></code><span class="koboSpan" id="kobo.41.1"> keyword</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.42.1">Timing out a goroutine</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.43.1">Go channels revisited</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.44.1">Handling UNIX signals</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.45.1">Shared memory and shared variables</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.46.1">Closured variables and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">go</span></code><span class="koboSpan" id="kobo.48.1"> statement</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.49.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">context</span></code><span class="koboSpan" id="kobo.51.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.52.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.53.1">semaphore</span></code><span class="koboSpan" id="kobo.54.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.55.1">Making the statistics application concurrent</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-220"><span class="koboSpan" id="kobo.56.1">Processes, threads, and goroutines</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.57.1">A process is an OS representation</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.58.1"> of a running program, while a program is a binary file on a disk that contains all the information necessary for creating an OS process. </span><span class="koboSpan" id="kobo.58.2">The binary file is written in a specific format and contains all the instructions the CPU is going to run, as well as a plethora of other required sections. </span><span class="koboSpan" id="kobo.58.3">That program is loaded into memory and the instructions are executed, creating a running process. </span><span class="koboSpan" id="kobo.58.4">So, a process carries with it additional resources such as memory, opened file descriptions, and user data, as well as other</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.59.1"> types of resources that are obtained during runtime.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.60.1">A thread is a smaller</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.61.1"> and lighter entity than a process. </span><span class="koboSpan" id="kobo.61.2">Processes consist of one or more threads that have their own flow of control and stack. </span><span class="koboSpan" id="kobo.61.3">A quick and simplistic way to differentiate a thread from a process is to consider a process as the running binary file and a thread as a subset of a process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.62.1">A goroutine is the minimum </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.63.1">Go entity that can be executed concurrently. </span><span class="koboSpan" id="kobo.63.2">The use of the word </span><em class="italic"><span class="koboSpan" id="kobo.64.1">minimum</span></em><span class="koboSpan" id="kobo.65.1"> is very important here, as goroutines are not autonomous entities like UNIX processes—</span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.66.1">goroutines live in OS threads that live in OS processes</span></strong><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">The good thing is that goroutines are lighter than threads, which, in turn, are lighter than processes—running thousands or hundreds of thousands of goroutines on a single machine is not a problem. </span><span class="koboSpan" id="kobo.67.3">Among the reasons that goroutines are lighter than threads are that they have a smaller stack that can grow, they have a faster startup time, and they can communicate with each other through channels with low latency. </span><span class="koboSpan" id="kobo.67.4">In practice, this means that a process can have multiple threads and lots of goroutines, whereas a goroutine needs the environment of a process to exist. </span><span class="koboSpan" id="kobo.67.5">So, to create a goroutine, you need to have a process with at least one thread. </span><span class="koboSpan" id="kobo.67.6">The OS takes care of the process and thread scheduling, while Go creates the necessary threads and the developer creates the desired number of goroutines.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.68.1">Now that you know the basics of processes, programs, threads, and goroutines, let us talk a little bit about the Go scheduler.</span></p>
<h1 class="heading-1" id="_idParaDest-221"><span class="koboSpan" id="kobo.69.1">The Go scheduler</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.70.1">The OS kernel scheduler</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.71.1"> is responsible for the execution of the threads of a program. </span><span class="koboSpan" id="kobo.71.2">Similarly, the Go runtime has its own scheduler, which is responsible for the execution of the goroutines</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.72.1"> using a technique known as </span><em class="italic"><span class="koboSpan" id="kobo.73.1">m:n scheduling</span></em><span class="koboSpan" id="kobo.74.1">, where m goroutines are executed using n OS threads using multiplexing. </span><span class="koboSpan" id="kobo.74.2">The Go scheduler is the Go component responsible for the way and the order in which the goroutines of a Go program get executed. </span><span class="koboSpan" id="kobo.74.3">This makes the Go scheduler a really important part of the Go programming language. </span><span class="koboSpan" id="kobo.74.4">The Go scheduler is also executed as a goroutine.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.75.1">Be aware that as the Go scheduler only deals with the goroutines of a single program, its operation is much simpler, cheaper, and faster than the operation of the OS kernel scheduler.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.76.1">Go uses the fork-join concurrency model. </span><span class="koboSpan" id="kobo.76.2">The </span><em class="italic"><span class="koboSpan" id="kobo.77.1">fork part</span></em><span class="koboSpan" id="kobo.78.1"> of the model, which should not be confused with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.79.1">fork(2)</span></code><span class="koboSpan" id="kobo.80.1"> system call, states that a child branch can be created at any point of a program. </span><span class="koboSpan" id="kobo.80.2">Analogously, the </span><em class="italic"><span class="koboSpan" id="kobo.81.1">join part</span></em><span class="koboSpan" id="kobo.82.1"> of the Go concurrency model is where the child branch ends and joins with its parent. </span><span class="koboSpan" id="kobo.82.2">Keep in mind that both </span><code class="inlineCode"><span class="koboSpan" id="kobo.83.1">sync.Wait()</span></code><span class="koboSpan" id="kobo.84.1"> statements and channels that collect the results of goroutines are join points, whereas each new goroutine creates</span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.85.1"> a child branch.</span></p>
<p class="normal"><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.86.1">The fair scheduling strategy shares all load evenly among the available processors</span></strong><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">At first, this might look like the perfect strategy because it does not have to take many things into consideration while keeping all processors equally occupied. </span><span class="koboSpan" id="kobo.87.3">However, it turns out that this is not exactly the case because most distributed tasks usually depend on other tasks. </span><span class="koboSpan" id="kobo.87.4">Therefore, some processors are underutilized or, equivalently, some processors are utilized more than others.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.88.1">A goroutine is a task, whereas everything after the calling statement of a goroutine is a continuation. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.89.1">In the work-stealing strategy used by the Go scheduler, a (logical) processor that is underutilized looks for additional work from other processors.</span></strong><span class="koboSpan" id="kobo.90.1"> When it finds such jobs, it steals them from the other processor or processors, hence the name. </span><span class="koboSpan" id="kobo.90.2">Additionally, the work-stealing algorithm of Go queues and steals continuations. </span><span class="koboSpan" id="kobo.90.3">A stalling join, as is suggested by its name, is a point where a thread of execution stalls at a join and starts looking for other work to do.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.91.1">Although both task stealing and continuation stealing have stalling joins, continuations happen more often than tasks; therefore, the Go scheduling algorithm works with continuations rather than tasks. </span><span class="koboSpan" id="kobo.91.2">The main disadvantage of continuation stealing is that it requires extra work from the compiler of the programming language. </span><span class="koboSpan" id="kobo.91.3">Fortunately, Go provides that extra help and, therefore, uses continuation stealing in its work-stealing algorithm. </span><span class="koboSpan" id="kobo.91.4">One of the benefits of continuation stealing is that you get the same results when using function calls instead of goroutines or a single thread with multiple goroutines. </span><span class="koboSpan" id="kobo.91.5">This makes perfect sense, as only one thing is executed at any given point in both cases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.92.1">The Go scheduler works using three main kinds of entities: OS threads (M), which are related to the OS in use, goroutines (G), and logical processors (P). </span><span class="koboSpan" id="kobo.92.2">The number of processors that can be used by a Go program is specified by the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.93.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.94.1"> environment variable—at any given time, there are, at most, </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.96.1"> processors. </span><span class="koboSpan" id="kobo.96.2">Now, let us return to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.97.1">m:n</span></code><span class="koboSpan" id="kobo.98.1"> scheduling algorithm used in Go. </span><span class="koboSpan" id="kobo.98.2">Strictly speaking, at any time, you have </span><code class="inlineCode"><span class="koboSpan" id="kobo.99.1">m</span></code><span class="koboSpan" id="kobo.100.1"> goroutines that are executed and, therefore, scheduled to run, on </span><code class="inlineCode"><span class="koboSpan" id="kobo.101.1">n</span></code><span class="koboSpan" id="kobo.102.1"> OS threads using, at most, </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.104.1"> number of logical processors. </span><span class="koboSpan" id="kobo.104.2">You will learn more about </span><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.106.1"> shortly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.107.1">Each goroutine can be in one of the following three stages: </span><em class="italic"><span class="koboSpan" id="kobo.108.1">executing</span></em><span class="koboSpan" id="kobo.109.1">, </span><em class="italic"><span class="koboSpan" id="kobo.110.1">runnable</span></em><span class="koboSpan" id="kobo.111.1">, or </span><em class="italic"><span class="koboSpan" id="kobo.112.1">waiting</span></em><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">In the executing stage, the instructions of the goroutine are executed on an OS thread. </span><span class="koboSpan" id="kobo.113.3">In the runnable stage, the goroutine waits to be assigned to an OS thread for execution. </span><span class="koboSpan" id="kobo.113.4">Finally, in the waiting stage, the goroutine is blocked for some reason like waiting for a resource or a mutex to become available to go into one of the other two stages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.114.1">The following figure shows</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.115.1"> that there are two different kinds of queues—a global run queue and a local run queue—attached to each logical processor. </span><span class="koboSpan" id="kobo.115.2">Goroutines from the global queue are assigned to the queue of a logical processor in order to get executed at some point in the future.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.116.1"><img alt="" role="presentation" src="../Images/B21003_08_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.117.1">Figure 8.1: The operation of the Go scheduler</span></p>
<p class="normal"><span class="koboSpan" id="kobo.118.1">Each logical processor can have multiple threads, and the stealing occurs between the local queues of the available logical processors. </span><span class="koboSpan" id="kobo.118.2">Finally, keep in mind that the Go scheduler is allowed to create more OS threads when needed. </span><span class="koboSpan" id="kobo.118.3">OS threads are expensive in terms of resources and going from one status to another (</span><em class="italic"><span class="koboSpan" id="kobo.119.1">context switching</span></em><span class="koboSpan" id="kobo.120.1">), which means that dealing too much with OS threads</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.121.1"> might slow down your Go applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.122.1">Next, we discuss the meaning and the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.124.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-222"><span class="koboSpan" id="kobo.125.1">The GOMAXPROCS environment variable</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.126.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.128.1"> environment variable allows</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.129.1"> you to set the number of OS threads that can execute user-level Go code simultaneously; this does not limit the number of threads created but it does limit the number of threads that are actively running. </span><span class="koboSpan" id="kobo.129.2">Starting with Go version 1.5, the default value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.130.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.131.1"> should be the number of logical cores available in your machine. </span><span class="koboSpan" id="kobo.131.2">There is also the </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">runtime.GOMAXPROCS()</span></code><span class="koboSpan" id="kobo.133.1"> function, which allows you to set and get the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.135.1"> programmatically.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.136.1">If you decide to assign a value to </span><code class="inlineCode"><span class="koboSpan" id="kobo.137.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.138.1"> that is smaller than the number of cores in your machine, you might affect the performance of your program. </span><span class="koboSpan" id="kobo.138.2">However, using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.139.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.140.1"> value that is larger than the number of available cores does not necessarily make your Go programs run faster due to the context switching of threads.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.141.1">As mentioned earlier in this subsection, you can programmatically set and get the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.143.1"> environment variable—this is illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">maxprocs.go</span></code><span class="koboSpan" id="kobo.145.1">, which will also show additional capabilities of the runtime package. </span><span class="koboSpan" id="kobo.145.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.146.1">main()</span></code><span class="koboSpan" id="kobo.147.1"> function is implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.148.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.149.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.150.1">()</span></span><span class="koboSpan" id="kobo.151.1"> {
    fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.152.1">"You are using "</span></span><span class="koboSpan" id="kobo.153.1">, runtime.Compiler, </span><span class="hljs-string"><span class="koboSpan" id="kobo.154.1">" "</span></span><span class="koboSpan" id="kobo.155.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.156.1">"on a"</span></span><span class="koboSpan" id="kobo.157.1">, runtime.GOARCH, </span><span class="hljs-string"><span class="koboSpan" id="kobo.158.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.159.1">machine"</span></span><span class="koboSpan" id="kobo.160.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.161.1">"Using Go version"</span></span><span class="koboSpan" id="kobo.162.1">, runtime.Version())
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.163.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.164.1">runtime.Compiler</span></code><span class="koboSpan" id="kobo.165.1"> variable holds the compiler toolchain used for building the running binary. </span><span class="koboSpan" id="kobo.165.2">The two most well-known values are </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">gc</span></code><span class="koboSpan" id="kobo.167.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.168.1">gccgo</span></code><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">runtime.GOARCH</span></code><span class="koboSpan" id="kobo.171.1"> variable holds the current architecture and </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">runtime.Version()</span></code><span class="koboSpan" id="kobo.173.1"> returns the current version of the Go compiler. </span><span class="koboSpan" id="kobo.173.2">This information is not necessary for using </span><code class="inlineCode"><span class="koboSpan" id="kobo.174.1">runtime.GOMAXPROCS()</span></code><span class="koboSpan" id="kobo.175.1"> but it is good to have a better knowledge of your system.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.176.1">    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.177.1">"GOMAXPROCS: %d\n"</span></span><span class="koboSpan" id="kobo.178.1">, runtime.GOMAXPROCS(</span><span class="hljs-number"><span class="koboSpan" id="kobo.179.1">0</span></span><span class="koboSpan" id="kobo.180.1">))
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.181.1">What happens with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.182.1">runtime.GOMAXPROCS(0)</span></code><span class="koboSpan" id="kobo.183.1"> call? </span><span class="koboSpan" id="kobo.183.2">It always returns the previous value of the maximum number of CPUs that can be executed simultaneously. </span><span class="koboSpan" id="kobo.183.3">When the parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.184.1">runtime.GOMAXPROCS()</span></code><span class="koboSpan" id="kobo.185.1"> is equal to or bigger than </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">1</span></code><span class="koboSpan" id="kobo.187.1">, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">runtime.GOMAXPROCS()</span></code><span class="koboSpan" id="kobo.189.1"> also changes the current setting. </span><span class="koboSpan" id="kobo.189.2">As we are using </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">0</span></code><span class="koboSpan" id="kobo.191.1">, our call does not alter the current setting.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.192.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">maxprocs.go</span></code><span class="koboSpan" id="kobo.194.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.195.1">You are using gc on a arm64 machine
Using Go version go1.21.0
GOMAXPROCS: 10
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.196.1">You can change the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.198.1"> on the fly using the following technique:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.199.1">$ </span></span><span class="koboSpan" id="kobo.200.1">GOMAXPROCS=100; go run maxprocs.go
You are using gc on a amd64 machine
Using Go version go1.21.0
GOMAXPROCS: 100
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.201.1">The previous command temporarily changes the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.203.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">100</span></code><span class="koboSpan" id="kobo.205.1"> and runs </span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">maxprocs.go</span></code><span class="koboSpan" id="kobo.207.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.208.1">Apart from testing the performance</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.209.1"> of your code using fewer cores, you will most likely not need to change </span><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.211.1">. </span><span class="koboSpan" id="kobo.211.2">The next subsection will explain the similarities and differences between concurrency and parallelism.</span></p>
<h2 class="heading-2" id="_idParaDest-223"><span class="koboSpan" id="kobo.212.1">Concurrency and parallelism</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.213.1">It is a common misconception that concurrency</span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.214.1"> is the same thing as parallelism—this is not true! </span><span class="koboSpan" id="kobo.214.2">Parallelism</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.215.1"> is the simultaneous execution of multiple entities of some kind, whereas concurrency is a way of structuring your components so that they can be executed independently when possible. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.216.1">It is only when you build software components concurrently that you can safely execute them in parallel, when and if your OS and your hardware permit it. </span><span class="koboSpan" id="kobo.216.2">The Erlang programming language did this a long time ago—long before CPUs had multiple cores and computers had lots of RAM.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.217.1">In a valid concurrent design, adding concurrent entities makes the whole system run faster because more things can be executed in parallel. </span><span class="koboSpan" id="kobo.217.2">So, the desired parallelism comes from a better concurrent expression and implementation of the problem. </span><span class="koboSpan" id="kobo.217.3">The developer is responsible for taking concurrency into account during the design phase of a system and will benefit from a potential parallel execution of the components of the system. </span><span class="koboSpan" id="kobo.217.4">So, the developer should not think about parallelism but about breaking things into independent components that solve the initial problem when combined.</span></p>
<p class="normal"><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.218.1">Even if you cannot run your functions in parallel on your machine, a valid concurrent design still improves the design, data flow, and maintainability of your programs</span></strong><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">In other words, concurrency</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.220.1"> is better than</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.221.1"> parallelism! </span><span class="koboSpan" id="kobo.221.2">Let us now talk about goroutines before looking into channels, which are the main components of the Go concurrency model.</span></p>
<h1 class="heading-1" id="_idParaDest-224"><span class="koboSpan" id="kobo.222.1">Goroutines</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.223.1">You can define, create, and execute</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.224.1"> a new goroutine using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.225.1">go</span></code><span class="koboSpan" id="kobo.226.1"> keyword followed by a named function or an anonymous function call. </span><span class="koboSpan" id="kobo.226.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.227.1">go</span></code><span class="koboSpan" id="kobo.228.1"> keyword makes the function call return immediately, while the function starts running in the background as a goroutine and the rest of the program continues its execution. </span><span class="koboSpan" id="kobo.228.2">You cannot control or make any assumptions about the order in which your goroutines are going to be executed because that depends on the scheduler of the OS, the Go scheduler, and the load of the OS.</span></p>
<h2 class="heading-2" id="_idParaDest-225"><span class="koboSpan" id="kobo.229.1">Creating a goroutine</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.230.1">In this subsection, you will learn</span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.231.1"> how to create goroutines. </span><span class="koboSpan" id="kobo.231.2">The program that illustrates the technique is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.232.1">create.go</span></code><span class="koboSpan" id="kobo.233.1">. </span><span class="koboSpan" id="kobo.233.2">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">main()</span></code><span class="koboSpan" id="kobo.235.1"> function is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.236.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.237.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.238.1">()</span></span><span class="koboSpan" id="kobo.239.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.240.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.241.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.242.1">(x </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.243.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.244.1">)</span></span><span class="koboSpan" id="kobo.245.1"> {
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.246.1">"%d "</span></span><span class="koboSpan" id="kobo.247.1">, x)
    }(</span><span class="hljs-number"><span class="koboSpan" id="kobo.248.1">10</span></span><span class="koboSpan" id="kobo.249.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.250.1">This is how you run an anonymous function as a goroutine. </span><span class="koboSpan" id="kobo.250.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">(10)</span></code><span class="koboSpan" id="kobo.252.1"> at the end is how you pass a parameter to an anonymous function. </span><span class="koboSpan" id="kobo.252.2">The previous anonymous function just prints a value. </span><span class="koboSpan" id="kobo.252.3">In general, it is more readable to pass parameters explicitly than to have the function close over the variables it uses.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.253.1">go</span></span><span class="koboSpan" id="kobo.254.1"> printme(</span><span class="hljs-number"><span class="koboSpan" id="kobo.255.1">15</span></span><span class="koboSpan" id="kobo.256.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.257.1">This is how you execute a function as a goroutine. </span><span class="koboSpan" id="kobo.257.2">As a rule of thumb, the functions that you execute as goroutines should not return any values directly. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.258.1">Exchanging data with goroutines happens via the use of shared memory or channels or some other mechanism</span></strong><span class="koboSpan" id="kobo.259.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.260.1">    time.Sleep(time.Second)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.261.1">"Exiting..."</span></span><span class="koboSpan" id="kobo.262.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.263.1">As a Go program does not wait for its goroutines to end before exiting, we need to delay it manually, which is the purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.265.1"> call. </span><span class="koboSpan" id="kobo.265.2">We correct that shortly in order to wait for all goroutines to finish before exiting.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.266.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">create.go </span></code><span class="koboSpan" id="kobo.268.1">produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.269.1">$ </span></span><span class="koboSpan" id="kobo.270.1">go run create.go 
10 * 15
Exiting...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.271.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.272.1">10</span></code><span class="koboSpan" id="kobo.273.1"> part in the output is from the anonymous function, whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">* 15</span></code><span class="koboSpan" id="kobo.275.1"> part is from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.276.1">go printme(15)</span></code><span class="koboSpan" id="kobo.277.1"> statement. </span><span class="koboSpan" id="kobo.277.2">However, if you run </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">create.go</span></code><span class="koboSpan" id="kobo.279.1"> more than once, you might get a different output because the two goroutines are not always executed in the same order, as this depends </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.280.1">on the Go scheduler:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.281.1">$ </span></span><span class="koboSpan" id="kobo.282.1">go run create.go
* 15
10 Exiting...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.283.1">The next subsection shows how to run a variable number of goroutines.</span></p>
<h2 class="heading-2" id="_idParaDest-226"><span class="koboSpan" id="kobo.284.1">Creating multiple goroutines</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.285.1">In this subsection, you</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.286.1"> will learn</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.287.1"> how to create a variable number of goroutines. </span><span class="koboSpan" id="kobo.287.2">The program that illustrates the technique is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">multiple.go</span></code><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">The number of goroutines is given as a command line argument to the program. </span><span class="koboSpan" id="kobo.289.3">The important code from the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">main()</span></code><span class="koboSpan" id="kobo.291.1"> function is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.292.1">fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.293.1">"Going to create %d goroutines.\n"</span></span><span class="koboSpan" id="kobo.294.1">, count)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.295.1">for</span></span><span class="koboSpan" id="kobo.296.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.297.1">0</span></span><span class="koboSpan" id="kobo.298.1">; i &lt; count; i++ {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.299.1">There is nothing prohibiting you from using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">for</span></code><span class="koboSpan" id="kobo.301.1"> loop to create multiple goroutines, especially when you want to create lots of them.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.302.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.303.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.304.1">(x </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.305.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.306.1">)</span></span><span class="koboSpan" id="kobo.307.1"> {
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.308.1">"%d "</span></span><span class="koboSpan" id="kobo.309.1">, x)
    }(i)
}
time.Sleep(time.Second)
fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.310.1">"\nExiting..."</span></span><span class="koboSpan" id="kobo.311.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.312.1">Once again, </span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.314.1"> prevents the </span><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">main()</span></code><span class="koboSpan" id="kobo.316.1"> function from exiting immediately.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.317.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">multiple.go</span></code><span class="koboSpan" id="kobo.319.1"> generates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.320.1">$ </span></span><span class="koboSpan" id="kobo.321.1">go run multiple.go 15
Going to create 15 goroutines.
</span><span class="koboSpan" id="kobo.321.2">3 0 8 4 5 6 7 11 9 12 14 13 1 2 10 
Exiting...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.322.1">If you run </span><code class="inlineCode"><span class="koboSpan" id="kobo.323.1">multiple.go</span></code><span class="koboSpan" id="kobo.324.1"> many times, you</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.325.1"> are going to get different outputs. </span><span class="koboSpan" id="kobo.325.2">So, there</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.326.1"> is still room for improvement. </span><span class="koboSpan" id="kobo.326.2">The next subsection shows how to remove the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.328.1"> and make your programs wait for the goroutines to finish.</span></p>
<h2 class="heading-2" id="_idParaDest-227"><span class="koboSpan" id="kobo.329.1">Waiting for all goroutines to finish</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.330.1">It is not enough to create multiple</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.331.1"> goroutines—you also need to wait for them to finish before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">main()</span></code><span class="koboSpan" id="kobo.333.1"> function ends. </span><span class="koboSpan" id="kobo.333.2">Therefore, this subsection shows a very popular technique that improves the code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.334.1">multiple.go</span></code><span class="koboSpan" id="kobo.335.1">—the improved version is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">varGoroutines.go</span></code><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">But first, we need to explain how this works.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.338.1">The synchronization process begins by defining a </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">sync.WaitGroup</span></code><span class="koboSpan" id="kobo.340.1"> variable and using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">Add()</span></code><span class="koboSpan" id="kobo.342.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">Done()</span></code><span class="koboSpan" id="kobo.344.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">Wait()</span></code><span class="koboSpan" id="kobo.346.1"> methods. </span><span class="koboSpan" id="kobo.346.2">If you look at the source code of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">sync</span></code><span class="koboSpan" id="kobo.348.1"> Go package, and more specifically at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">waitgroup.go</span></code><span class="koboSpan" id="kobo.350.1"> file, you see that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">sync.WaitGroup</span></code><span class="koboSpan" id="kobo.352.1"> type is nothing more than a structure with two fields:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.353.1">type</span></span><span class="koboSpan" id="kobo.354.1"> WaitGroup </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.355.1">struct</span></span><span class="koboSpan" id="kobo.356.1"> {
    noCopy noCopy
    state1 [</span><span class="hljs-number"><span class="koboSpan" id="kobo.357.1">3</span></span><span class="koboSpan" id="kobo.358.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.359.1">uint32</span></span><span class="koboSpan" id="kobo.360.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.361.1">Each call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">sync.Add()</span></code><span class="koboSpan" id="kobo.363.1"> increases</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.364.1"> a counter in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">state1</span></code><span class="koboSpan" id="kobo.366.1"> field, which is an array with three </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">uint32</span></code><span class="koboSpan" id="kobo.368.1"> elements. </span><span class="koboSpan" id="kobo.368.2">Notice that it is really important to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">sync.Add()</span></code><span class="koboSpan" id="kobo.370.1"> before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.371.1">go</span></code><span class="koboSpan" id="kobo.372.1"> statement in order to prevent any </span><em class="italic"><span class="koboSpan" id="kobo.373.1">race conditions</span></em><span class="koboSpan" id="kobo.374.1">—we will learn about race conditions in the </span><em class="italic"><span class="koboSpan" id="kobo.375.1">Race conditions are bad</span></em><span class="koboSpan" id="kobo.376.1"> section. </span><span class="koboSpan" id="kobo.376.2">When each goroutine finishes its job, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">sync.Done()</span></code><span class="koboSpan" id="kobo.378.1"> function should be executed in order to decrease the same counter by one. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.379.1">Behind the scenes, </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">sync.Done()</span></code><span class="koboSpan" id="kobo.381.1"> runs an </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">Add(-1)</span></code><span class="koboSpan" id="kobo.383.1"> call. </span><span class="koboSpan" id="kobo.383.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">Wait()</span></code><span class="koboSpan" id="kobo.385.1"> method waits until that counter becomes </span><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">0</span></code><span class="koboSpan" id="kobo.387.1"> in order to return. </span><span class="koboSpan" id="kobo.387.2">The return of </span><code class="inlineCode"><span class="koboSpan" id="kobo.388.1">Wait()</span></code><span class="koboSpan" id="kobo.389.1"> inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">main()</span></code><span class="koboSpan" id="kobo.391.1"> function means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">main()</span></code><span class="koboSpan" id="kobo.393.1"> is going to return and the program ends.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.394.1">You can call </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">Add()</span></code><span class="koboSpan" id="kobo.396.1"> with a positive integer value other than 1 in order to avoid calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">Add(1)</span></code><span class="koboSpan" id="kobo.398.1"> multiple times. </span><span class="koboSpan" id="kobo.398.2">This can be handy when you know the number of goroutines you are going to create in advance. </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">Done()</span></code><span class="koboSpan" id="kobo.400.1"> does not support that functionality.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.401.1">The important part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">varGoroutines.go</span></code><span class="koboSpan" id="kobo.403.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.404.1">var</span></span><span class="koboSpan" id="kobo.405.1"> waitGroup sync.WaitGroup
fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.406.1">"%#v\n"</span></span><span class="koboSpan" id="kobo.407.1">, waitGroup)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.408.1">This is where you create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.409.1">sync.WaitGroup</span></code><span class="koboSpan" id="kobo.410.1"> variable that you are going to use. </span><span class="koboSpan" id="kobo.410.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.412.1"> call prints the contents of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">sync.WaitGroup</span></code><span class="koboSpan" id="kobo.414.1"> structure—you do not usually do that but it is good for learning more about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">sync.WaitGroup</span></code><span class="koboSpan" id="kobo.416.1"> structure.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.417.1">for</span></span><span class="koboSpan" id="kobo.418.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.419.1">0</span></span><span class="koboSpan" id="kobo.420.1">; i &lt; count; i++ {
    waitGroup.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.421.1">1</span></span><span class="koboSpan" id="kobo.422.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.423.1">We call </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">Add(1)</span></code><span class="koboSpan" id="kobo.425.1"> just before we create the goroutine in order to avoid race conditions.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.426.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.427.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.428.1">(x </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.429.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.430.1">)</span></span><span class="koboSpan" id="kobo.431.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.432.1">defer</span></span><span class="koboSpan" id="kobo.433.1"> waitGroup.Done()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.434.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">Done()</span></code><span class="koboSpan" id="kobo.436.1"> call is going to be executed just before the anonymous function returns because of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.437.1">defer</span></code><span class="koboSpan" id="kobo.438.1"> keyword.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.439.1">        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.440.1">"%d "</span></span><span class="koboSpan" id="kobo.441.1">, x)
    }(i)
}
fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.442.1">"%#v\n"</span></span><span class="koboSpan" id="kobo.443.1">, waitGroup)
waitGroup.Wait()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.444.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">Wait()</span></code><span class="koboSpan" id="kobo.446.1"> function waits for the counter in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">waitGroup</span></code><span class="koboSpan" id="kobo.448.1"> variable to become </span><code class="inlineCode"><span class="koboSpan" id="kobo.449.1">0</span></code><span class="koboSpan" id="kobo.450.1"> before it returns, which is what we want to achieve.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.451.1">fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.452.1">"\nExiting..."</span></span><span class="koboSpan" id="kobo.453.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.454.1">When the </span><code class="inlineCode"><span class="koboSpan" id="kobo.455.1">Wait()</span></code><span class="koboSpan" id="kobo.456.1"> function returns, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.458.1"> statement is executed. </span><span class="koboSpan" id="kobo.458.2">No need to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.460.1"> any more!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.461.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">varGoroutines.go</span></code><span class="koboSpan" id="kobo.463.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.464.1">$ </span></span><span class="koboSpan" id="kobo.465.1">go run varGoroutines.go 15
Going to create 10 goroutines.
</span><span class="koboSpan" id="kobo.465.2">sync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x0}, sema:0x0}
sync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0xa00000000}, sema:0x0}
14 8 9 10 11 5 0 4 1 2 3 6 13 12 7 
Exiting...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.466.1">Remember that using more goroutines</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.467.1"> in a program is not a panacea for performance, as more goroutines, in addition to the various calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">sync.Add()</span></code><span class="koboSpan" id="kobo.469.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.470.1">sync.Wait()</span></code><span class="koboSpan" id="kobo.471.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">sync.Done()</span></code><span class="koboSpan" id="kobo.473.1">, might slow down your program due to the extra housekeeping that needs to be done by the Go scheduler and the Go garbage collector.</span></p>
<h2 class="heading-2" id="_idParaDest-228"><span class="koboSpan" id="kobo.474.1">What if the number of Add() and Done() calls differ?</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.475.1">When the number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">sync.Add()</span></code><span class="koboSpan" id="kobo.477.1"> calls</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.478.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.479.1">sync.Done()</span></code><span class="koboSpan" id="kobo.480.1"> calls are equal, everything is going to be fine in your programs. </span><span class="koboSpan" id="kobo.480.2">However, this subsection tells you what happens when these two numbers do not agree with each other.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.481.1">Without giving any command line parameters to </span><code class="inlineCode"><span class="koboSpan" id="kobo.482.1">addDone.go</span></code><span class="koboSpan" id="kobo.483.1">, the number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.484.1">Add()</span></code><span class="koboSpan" id="kobo.485.1"> calls is going to be smaller than the number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.486.1">Done()</span></code><span class="koboSpan" id="kobo.487.1"> calls. </span><span class="koboSpan" id="kobo.487.2">With at least one command line argument, the number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">Done()</span></code><span class="koboSpan" id="kobo.489.1"> calls is going to be smaller than the number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">Add()</span></code><span class="koboSpan" id="kobo.491.1"> calls. </span><span class="koboSpan" id="kobo.491.2">You can look at the Go code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">addDone.go</span></code><span class="koboSpan" id="kobo.493.1"> on your own. </span><span class="koboSpan" id="kobo.493.2">What is important is the output it generates. </span><span class="koboSpan" id="kobo.493.3">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.494.1">addDone.go</span></code><span class="koboSpan" id="kobo.495.1"> without any command line arguments produces the following error message:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.496.1">$ </span></span><span class="koboSpan" id="kobo.497.1">go run addDone.go
Going to create 20 goroutines.
</span><span class="koboSpan" id="kobo.497.2">sync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x0}, sema:0x0}
sync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x1300000000}, sema:0x0}
19 3 4 5 6 7 8 9 10 11 12 13 14 15 16 2 1 17 18 0
Exiting...
</span><span class="koboSpan" id="kobo.497.3">panic: sync: negative WaitGroup counter
goroutine 20 [running]:
sync.(*WaitGroup).Add(0x1?, 0x1?)
    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/waitgroup.go:62 +0x108
sync.(*WaitGroup).Done(0x0?)
    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/waitgroup.go:87 +0x20
main.main.func1(0x0?)
    ~/go/src/github.com/mactsouk/mGo4th/ch08/addDone.go:26 +0x9c
created by main.main in goroutine 1
    ~/go/src/github.com/mactsouk/mGo4th/ch08/addDone.go:23 +0xec
exit status 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.498.1">The cause of the error message</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.499.1"> can be found in the output: </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">panic: sync: negative WaitGroup counter</span></code><span class="koboSpan" id="kobo.501.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.502.1">Sometimes, </span><code class="inlineCode"><span class="koboSpan" id="kobo.503.1">addDone.go</span></code><span class="koboSpan" id="kobo.504.1"> does not produce</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.505.1"> any error messages and terminates just fine—</span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.506.1">this mainly happens when the system is already busy</span></strong><span class="koboSpan" id="kobo.507.1">. </span><span class="koboSpan" id="kobo.507.2">This is an issue with concurrent programs in general—they do not always crash or misbehave as the order of execution can change, which might change the behavior of the program. </span><span class="koboSpan" id="kobo.507.3">This makes the debugging of concurrent software even more difficult.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.508.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.509.1">addDone.go</span></code><span class="koboSpan" id="kobo.510.1"> with one command line argument produces the following error message:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.511.1">$ </span></span><span class="koboSpan" id="kobo.512.1">go run addDone.go 1
Going to create 20 goroutines.
</span><span class="koboSpan" id="kobo.512.2">sync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x0}, sema:0x0}
sync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x1500000000}, sema:0x0}
19 1 2 11 12 13 14 15 16 17 18 6 3 4 5 8 7 9 0 10 fatal error: all goroutines are asleep - deadlock!
</span><span class="koboSpan" id="kobo.512.3">goroutine 1 [semacquire]:
sync.runtime_Semacquire(0x0?)
    /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/sema.go:62 +0x2c
sync.(*WaitGroup).Wait(0x14000128030)
    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/waitgroup.go:116 +0x78
main.main()
    ~/go/src/github.com/mactsouk/mGo4th/code/ch08/addDone.go:38 +0x230
exit status 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.513.1">Once again, the reason for the crash</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.514.1"> is printed on the screen: </span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">fatal error: all goroutines are asleep - deadlock!</span></code><span class="koboSpan" id="kobo.516.1">. </span><span class="koboSpan" id="kobo.516.2">This means that the program should wait indefinitely for a goroutine to finish—that is, for a </span><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">Done()</span></code><span class="koboSpan" id="kobo.518.1"> call that is never going to happen.</span></p>
<h2 class="heading-2" id="_idParaDest-229"><span class="koboSpan" id="kobo.519.1">Creating multiple files with goroutines</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.520.1">As a practical example of the use</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.521.1"> of goroutines, this subsection presents</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.522.1"> a command line utility that creates multiple files populated with randomly generated data—such files can be used for testing file systems or generating data for testing. </span><span class="koboSpan" id="kobo.522.2">The crucial code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">randomFiles.go</span></code><span class="koboSpan" id="kobo.524.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.525.1">var</span></span><span class="koboSpan" id="kobo.526.1"> waitGroup sync.WaitGroup
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.527.1">for</span></span><span class="koboSpan" id="kobo.528.1"> i := start; i &lt;= end; i++ {
    waitGroup.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.529.1">1</span></span><span class="koboSpan" id="kobo.530.1">)
    
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.531.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.532.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.533.1">(n </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.534.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.535.1">)</span></span><span class="koboSpan" id="kobo.536.1"> {
        filepath := filepath.Join(path, fmt.Sprintf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.537.1">"%s%d"</span></span><span class="koboSpan" id="kobo.538.1">, filename, n))
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.539.1">defer</span></span><span class="koboSpan" id="kobo.540.1"> waitGroup.Done()
        createFile(filepath)
    }(i)
}
waitGroup.Wait()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.541.1">We first create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.542.1">sync.WaitGroup</span></code><span class="koboSpan" id="kobo.543.1"> variable in order to wait for all goroutines to finish in the right way. </span><span class="koboSpan" id="kobo.543.2">Each file is created by a single goroutine only. </span><span class="koboSpan" id="kobo.543.3">What is important here is that each file has a unique filename—this is implemented with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.544.1">filepath</span></code><span class="koboSpan" id="kobo.545.1"> variable that contains the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">for</span></code><span class="koboSpan" id="kobo.547.1"> loop counter. </span><span class="koboSpan" id="kobo.547.2">Multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.548.1">createFile()</span></code><span class="koboSpan" id="kobo.549.1"> functions executed as goroutines create the files. </span><span class="koboSpan" id="kobo.549.2">This is a simple yet very efficient way of creating multiple files. </span><span class="koboSpan" id="kobo.549.3">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.550.1">randomFiles.go</span></code><span class="koboSpan" id="kobo.551.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.552.1">$ </span></span><span class="koboSpan" id="kobo.553.1">go run randomFiles.go 
Usage: randomFiles firstInt lastInt filename directory
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.554.1">So, the utility requires four parameters, which are the first and last values of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.555.1">for</span></code><span class="koboSpan" id="kobo.556.1"> loop as well as the filename and the directory in which the files are going to be written. </span><span class="koboSpan" id="kobo.556.2">So, let us run the utility with the correct number of parameters:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.557.1">$ </span></span><span class="koboSpan" id="kobo.558.1">go run randomFiles.go 3 5 masterGo /tmp
/tmp/masterGo3 created!
</span><span class="koboSpan" id="kobo.558.2">/tmp/masterGo5 created!
</span><span class="koboSpan" id="kobo.558.3">/tmp/masterGo4 created!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.559.1">Everything looks fine, and four files</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.560.1"> have been created according</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.561.1"> to our instructions! </span><span class="koboSpan" id="kobo.561.2">Now that we know about goroutines, let us continue with channels.</span></p>
<h1 class="heading-1" id="_idParaDest-230"><span class="koboSpan" id="kobo.562.1">Channels</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.563.1">A channel is a communication</span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.564.1"> mechanism that, among other things, allows goroutines to exchange data. </span><span class="koboSpan" id="kobo.564.2">Firstly, each channel allows the exchange of a particular data type, which</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.565.1"> is also called the element type of the channel, and secondly, for a channel to operate properly, you need someone to receive what is sent via the channel. </span><span class="koboSpan" id="kobo.565.2">You should declare a new channel using </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">make()</span></code><span class="koboSpan" id="kobo.567.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.568.1">chan</span></code><span class="koboSpan" id="kobo.569.1"> keyword (</span><code class="inlineCode"><span class="koboSpan" id="kobo.570.1">make(chan int)</span></code><span class="koboSpan" id="kobo.571.1">), and you can close a channel using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.572.1">close()</span></code><span class="koboSpan" id="kobo.573.1"> function. </span><span class="koboSpan" id="kobo.573.2">You can declare the size of a channel by writing something similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.574.1">make(chan int, 1)</span></code><span class="koboSpan" id="kobo.575.1">. </span><span class="koboSpan" id="kobo.575.2">This statement creates a </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.576.1">buffered channel</span></strong><span class="koboSpan" id="kobo.577.1"> that has a different use—buffered</span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.578.1"> channels are explained later in this chapter.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.579.1">Just because we can use channels, it does not mean that we should. </span><span class="koboSpan" id="kobo.579.2">If a simpler solution exists that allows goroutines to get executed and save the generated information, we should also consider that. </span><span class="koboSpan" id="kobo.579.3">The purpose of every developer should be to create a simple design, not to use all the features of a programming language.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.580.1">A pipeline is a virtual method for connecting goroutines and channels so that the output of one goroutine becomes the input of another goroutine using channels to transfer your data. </span><span class="koboSpan" id="kobo.580.2">One of the benefits that you get from using pipelines is that there is a constant data flow in your program, as no goroutine or channel has to wait for everything to be completed in order to start their execution. </span><span class="koboSpan" id="kobo.580.3">Additionally, you use fewer variables and, therefore, less memory space because you do not have to save everything as a variable. </span><span class="koboSpan" id="kobo.580.4">Finally, the use of pipelines</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.581.1"> simplifies the design of the program and improves its maintainability.</span></p>
<h2 class="heading-2" id="_idParaDest-231"><span class="koboSpan" id="kobo.582.1">Writing to and reading from a channel</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.583.1">Writing a value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.584.1">val</span></code><span class="koboSpan" id="kobo.585.1">) to a</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.586.1"> channel (</span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">ch</span></code><span class="koboSpan" id="kobo.588.1">) is as easy</span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.589.1"> as writing </span><code class="inlineCode"><span class="koboSpan" id="kobo.590.1">ch &lt;- val</span></code><span class="koboSpan" id="kobo.591.1">. </span><span class="koboSpan" id="kobo.591.2">The arrow shows the direction of the value, and you will have no problem with this statement as long as both </span><code class="inlineCode"><span class="koboSpan" id="kobo.592.1">var</span></code><span class="koboSpan" id="kobo.593.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.594.1">ch</span></code><span class="koboSpan" id="kobo.595.1"> are of the same data type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.596.1">You can read a single value from a channel named </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">c</span></code><span class="koboSpan" id="kobo.598.1"> by executing </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">&lt;-c</span></code><span class="koboSpan" id="kobo.600.1">. </span><span class="koboSpan" id="kobo.600.2">In this case, the direction is from the channel to the outer world. </span><span class="koboSpan" id="kobo.600.3">You can save that value into a new variable using </span><code class="inlineCode"><span class="koboSpan" id="kobo.601.1">aVar := &lt;-c</span></code><span class="koboSpan" id="kobo.602.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.603.1">Both channel reading and writing are illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.604.1">channels.go</span></code><span class="koboSpan" id="kobo.605.1">, which comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.606.1">package</span></span><span class="koboSpan" id="kobo.607.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.608.1">import</span></span><span class="koboSpan" id="kobo.609.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.610.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.611.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.612.1">sync"</span></span><span class="koboSpan" id="kobo.613.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.614.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.615.1">writeToChannel</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.616.1">(c </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.617.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.618.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.619.1">, x </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.620.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.621.1">)</span></span><span class="koboSpan" id="kobo.622.1"> {
    c &lt;- x
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.623.1">close</span></span><span class="koboSpan" id="kobo.624.1">(c)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.625.1">This function just writes a value to the channel and immediately closes it.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.626.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.627.1">printer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.628.1">(ch </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.629.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.630.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.631.1">)</span></span><span class="koboSpan" id="kobo.632.1"> {
    ch &lt;- </span><span class="hljs-literal"><span class="koboSpan" id="kobo.633.1">true</span></span><span class="koboSpan" id="kobo.634.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.635.1">This function just sends the </span><code class="inlineCode"><span class="koboSpan" id="kobo.636.1">true</span></code><span class="koboSpan" id="kobo.637.1"> value to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.638.1">bool</span></code><span class="koboSpan" id="kobo.639.1"> channel.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.640.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.641.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.642.1">()</span></span><span class="koboSpan" id="kobo.643.1"> {
    c := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.644.1">make</span></span><span class="koboSpan" id="kobo.645.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.646.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.647.1">int</span></span><span class="koboSpan" id="kobo.648.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.649.1">1</span></span><span class="koboSpan" id="kobo.650.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.651.1">This channel is buffered </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.652.1">with a size of 1. </span><span class="koboSpan" id="kobo.652.2">This means that as soon as we fill</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.653.1"> that buffer, we can close the channel and the goroutine is going to continue its execution and return. </span><span class="koboSpan" id="kobo.653.2">A channel that is unbuffered has a different behavior: when you try to send a value to that channel, it blocks forever because it is waiting for someone to fetch that value. </span><span class="koboSpan" id="kobo.653.3">In this case, we definitely want a buffered channel in order to avoid any blocking.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.654.1">var</span></span><span class="koboSpan" id="kobo.655.1"> waitGroup sync.WaitGroup
    waitGroup.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.656.1">1</span></span><span class="koboSpan" id="kobo.657.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.658.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.659.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.660.1">(c </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.661.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.662.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.663.1">)</span></span><span class="koboSpan" id="kobo.664.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.665.1">defer</span></span><span class="koboSpan" id="kobo.666.1"> waitGroup.Done()
        writeToChannel(c, </span><span class="hljs-number"><span class="koboSpan" id="kobo.667.1">10</span></span><span class="koboSpan" id="kobo.668.1">)
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.669.1">"Exit."</span></span><span class="koboSpan" id="kobo.670.1">)
    }(c)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.671.1">"Read:"</span></span><span class="koboSpan" id="kobo.672.1">, &lt;-c)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.673.1">Here, we read from the channel and print the value without storing it in a separate variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.674.1">    _, ok := &lt;-c
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.675.1">if</span></span><span class="koboSpan" id="kobo.676.1"> ok {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.677.1">"Channel is open!"</span></span><span class="koboSpan" id="kobo.678.1">)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.679.1">else</span></span><span class="koboSpan" id="kobo.680.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.681.1">"Channel is closed!"</span></span><span class="koboSpan" id="kobo.682.1">)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.683.1">The previous code shows a technique for determining whether a channel is closed or not. </span><span class="koboSpan" id="kobo.683.2">In this case, we are ignoring the read value—if the channel was open, then the read value would be discarded.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.684.1">    waitGroup.Wait()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.685.1">var</span></span><span class="koboSpan" id="kobo.686.1"> ch </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.687.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.688.1">bool</span></span><span class="koboSpan" id="kobo.689.1"> = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.690.1">make</span></span><span class="koboSpan" id="kobo.691.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.692.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.693.1">bool</span></span><span class="koboSpan" id="kobo.694.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.695.1">for</span></span><span class="koboSpan" id="kobo.696.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.697.1">0</span></span><span class="koboSpan" id="kobo.698.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.699.1">5</span></span><span class="koboSpan" id="kobo.700.1">; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.701.1">go</span></span><span class="koboSpan" id="kobo.702.1"> printer(ch)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.703.1">Here, we make an unbuffered channel and create five goroutines without any synchronization as we do not use any </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">Add()</span></code><span class="koboSpan" id="kobo.705.1"> calls.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.706.1">// Range on channels</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.707.1">// IMPORTANT: As the channel ch is not closed,</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.708.1">// the range loop does not exit on its own.</span></span><span class="koboSpan" id="kobo.709.1">
    n := </span><span class="hljs-number"><span class="koboSpan" id="kobo.710.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.711.1">for</span></span><span class="koboSpan" id="kobo.712.1"> i := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.713.1">range</span></span><span class="koboSpan" id="kobo.714.1"> ch {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.715.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.716.1">range</span></code><span class="koboSpan" id="kobo.717.1"> keyword works</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.718.1"> with channels! </span><span class="koboSpan" id="kobo.718.2">However, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">range</span></code><span class="koboSpan" id="kobo.720.1"> loop on a channel only</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.721.1"> exits when the channel is closed or uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">break</span></code><span class="koboSpan" id="kobo.723.1"> keyword.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.724.1">        fmt.Println(i)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.725.1">if</span></span><span class="koboSpan" id="kobo.726.1"> i == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.727.1">true</span></span><span class="koboSpan" id="kobo.728.1"> {
            n++
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.729.1">if</span></span><span class="koboSpan" id="kobo.730.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.731.1">2</span></span><span class="koboSpan" id="kobo.732.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.733.1">"n:"</span></span><span class="koboSpan" id="kobo.734.1">, n)
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.735.1">close</span></span><span class="koboSpan" id="kobo.736.1">(ch)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.737.1">break</span></span><span class="koboSpan" id="kobo.738.1">
        }
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.739.1">We close the </span><code class="inlineCode"><span class="koboSpan" id="kobo.740.1">ch</span></code><span class="koboSpan" id="kobo.741.1"> channel when a condition is met and exit the </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">for</span></code><span class="koboSpan" id="kobo.743.1"> loop using </span><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">break</span></code><span class="koboSpan" id="kobo.745.1">. </span><span class="koboSpan" id="kobo.745.2">Note that it is never a good idea to close a channel on the receiving end—this is presented here for the sake of the example. </span><span class="koboSpan" id="kobo.745.3">You are going to see the consequences of this decision in a while.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.746.1">for</span></span><span class="koboSpan" id="kobo.747.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.748.1">0</span></span><span class="koboSpan" id="kobo.749.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.750.1">5</span></span><span class="koboSpan" id="kobo.751.1">; i++ {
        fmt.Println(&lt;-ch)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.752.1">When trying to read from a closed channel, we get the zero value of its data type, so this </span><code class="inlineCode"><span class="koboSpan" id="kobo.753.1">for</span></code><span class="koboSpan" id="kobo.754.1"> loop works just fine and does not cause any issues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.755.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">channels.go</span></code><span class="koboSpan" id="kobo.757.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.758.1">Exit.
</span><span class="koboSpan" id="kobo.758.2">Read: 10
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.759.1">After writing the value </span><code class="inlineCode"><span class="koboSpan" id="kobo.760.1">10</span></code><span class="koboSpan" id="kobo.761.1"> to the channel using </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">writeToChannel(c, 10)</span></code><span class="koboSpan" id="kobo.763.1">, we read that value back.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.764.1">Channel is closed!
</span><span class="koboSpan" id="kobo.764.2">true
true
true
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.765.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">for</span></code><span class="koboSpan" id="kobo.767.1"> loop with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.768.1">range</span></code><span class="koboSpan" id="kobo.769.1"> exits after three iterations—each iteration prints </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">true</span></code><span class="koboSpan" id="kobo.771.1"> on screen.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.772.1">n: 3
false
false
false
false
false
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.773.1">These five </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">false</span></code><span class="koboSpan" id="kobo.775.1"> values are printed by the last </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">for</span></code><span class="koboSpan" id="kobo.777.1"> loop of the program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.778.1">Although everything looks fine with </span><code class="inlineCode"><span class="koboSpan" id="kobo.779.1">channels.go</span></code><span class="koboSpan" id="kobo.780.1">, there is a logical issue with it, which we will explain and resolve in the </span><em class="italic"><span class="koboSpan" id="kobo.781.1">Race conditions are bad</span></em><span class="koboSpan" id="kobo.782.1"> section. </span><span class="koboSpan" id="kobo.782.2">Additionally, if we run </span><code class="inlineCode"><span class="koboSpan" id="kobo.783.1">channels.go</span></code><span class="koboSpan" id="kobo.784.1"> multiple</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.785.1"> times, it might</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.786.1"> crash. </span><span class="koboSpan" id="kobo.786.2">However, most of the time, it does not, which makes debugging even more challenging.</span></p>
<h2 class="heading-2" id="_idParaDest-232"><span class="koboSpan" id="kobo.787.1">Receiving from a closed channel</span></h2>
<p class="normal"><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.788.1">Reading from a closed channel returns the zero value of its data type</span></strong><span class="koboSpan" id="kobo.789.1">. </span><span class="koboSpan" id="kobo.789.2">However, if you try to write to a closed</span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.790.1"> channel, your program is going to crash in a bad way (panic). </span><span class="koboSpan" id="kobo.790.2">These two situations are explored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.791.1">readCloseCh.go</span></code><span class="koboSpan" id="kobo.792.1"> and, more specifically, in the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.793.1">main()</span></code><span class="koboSpan" id="kobo.794.1"> function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.795.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.796.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.797.1">()</span></span><span class="koboSpan" id="kobo.798.1"> {
    willClose := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.799.1">make</span></span><span class="koboSpan" id="kobo.800.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.801.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.802.1">complex64</span></span><span class="koboSpan" id="kobo.803.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.804.1">10</span></span><span class="koboSpan" id="kobo.805.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.806.1">If you make that an unbuffered channel, the program is going to crash.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.807.1">// Write some data to the channel</span></span><span class="koboSpan" id="kobo.808.1">
    willClose &lt;- </span><span class="hljs-number"><span class="koboSpan" id="kobo.809.1">-1</span></span><span class="koboSpan" id="kobo.810.1">
    willClose &lt;- </span><span class="hljs-number"><span class="koboSpan" id="kobo.811.1">1i</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.812.1">We write two values to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.813.1">willClose</span></code><span class="koboSpan" id="kobo.814.1"> channel.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.815.1">// Read data and empty channel</span></span><span class="koboSpan" id="kobo.816.1">
    &lt;-willClose
    &lt;-willClose
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.817.1">close</span></span><span class="koboSpan" id="kobo.818.1">(willClose)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.819.1">Then, we read and discard these two values and we close the channel.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.820.1">// Read again - this is a closed channel</span></span><span class="koboSpan" id="kobo.821.1">
    read := &lt;-willClose
    fmt.Println(read)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.822.1">The last value that we read from the channel is the zero value of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.823.1">complex64</span></code><span class="koboSpan" id="kobo.824.1"> data type. </span><span class="koboSpan" id="kobo.824.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.825.1">readCloseCh.go</span></code><span class="koboSpan" id="kobo.826.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.827.1">(0+0i)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.828.1">So, we got back the zero</span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.829.1"> value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.830.1">complex64</span></code><span class="koboSpan" id="kobo.831.1"> data type. </span><span class="koboSpan" id="kobo.831.2">Now let us continue and discuss how to work with functions that accept channels as parameters.</span></p>
<h2 class="heading-2" id="_idParaDest-233"><span class="koboSpan" id="kobo.832.1">Channels as function parameters</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.833.1">When using a channel</span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.834.1"> as a function</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.835.1"> parameter, you can specify its direction—that is, whether it is going to be used for sending or receiving data only. </span><span class="koboSpan" id="kobo.835.2">In my opinion, if you know the purpose of a channel in advance, you should use this capability because it makes your programs more robust. </span><span class="koboSpan" id="kobo.835.3">You will not be able to send data accidentally to a channel from which you should only receive data, or receive data from a channel to which you should only be sending data. </span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.836.1">If you declare that a channel function parameter is going to be used for reading only and you try to write to it, you are going to get a compile error message that will most likely save you from nasty bugs in the future. </span><span class="koboSpan" id="kobo.836.2">This is the major benefit of this approach!</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.837.1">All these are illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.838.1">channelFunc.go</span></code><span class="koboSpan" id="kobo.839.1">—the implementation of the functions that accept channel parameters are the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.840.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.841.1">printer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.842.1">(ch </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.843.1">chan</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.844.1">&lt;- </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.845.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.846.1">)</span></span><span class="koboSpan" id="kobo.847.1"> {
    ch &lt;- </span><span class="hljs-literal"><span class="koboSpan" id="kobo.848.1">true</span></span><span class="koboSpan" id="kobo.849.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.850.1">The above function accepts a channel parameter that is available for writing only.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.851.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.852.1">writeToChannel</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.853.1">(c </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.854.1">chan</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.855.1">&lt;- </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.856.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.857.1">, x </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.858.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.859.1">)</span></span><span class="koboSpan" id="kobo.860.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.861.1">"1"</span></span><span class="koboSpan" id="kobo.862.1">, x)
    c &lt;- x
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.863.1">"2"</span></span><span class="koboSpan" id="kobo.864.1">, x)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.865.1">The channel parameter of the above function is available for reading only.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.866.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.867.1">f2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.868.1">(out &lt;-</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.869.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.870.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.871.1">, in </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.872.1">chan</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.873.1">&lt;- </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.874.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.875.1">)</span></span><span class="koboSpan" id="kobo.876.1"> {
    x := &lt;-out
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.877.1">"Read (f2):"</span></span><span class="koboSpan" id="kobo.878.1">, x)
    in &lt;- x
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.879.1">return</span></span><span class="koboSpan" id="kobo.880.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.881.1">The last function accepts two channel parameters. </span><span class="koboSpan" id="kobo.881.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.882.1">out</span></code><span class="koboSpan" id="kobo.883.1"> is available for reading, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.884.1">in</span></code><span class="koboSpan" id="kobo.885.1"> is offered for writing. </span><span class="koboSpan" id="kobo.885.2">If you try to perform an operation on a channel parameter</span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.886.1"> that is not allowed, the Go compiler</span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.887.1"> is going to complain. </span><span class="koboSpan" id="kobo.887.2">This happens even if the function is not being used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.888.1">The subject of the next section is race conditions—read it carefully in order to avoid undefined behaviors and unpleasant situations when working with multiple goroutines.</span></p>
<h1 class="heading-1" id="_idParaDest-234"><span class="koboSpan" id="kobo.889.1">Race conditions are bad</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.890.1">A </span><em class="italic"><span class="koboSpan" id="kobo.891.1">data race condition</span></em><span class="koboSpan" id="kobo.892.1"> is a situation where</span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.893.1"> two or more running elements, such as threads and goroutines, try to take control of or modify a shared resource or shared variable of a program. </span><span class="koboSpan" id="kobo.893.2">Strictly speaking, a data race occurs when two or more instructions access the same memory address, where at least one of them performs a write (change) operation. </span><span class="koboSpan" id="kobo.893.3">If all operations are read operations, then there is no race condition. </span><span class="koboSpan" id="kobo.893.4">In practice, this means that you might get different output if you run your program multiple times, and that is a bad thing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.894.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">-race</span></code><span class="koboSpan" id="kobo.896.1"> flag when running or building Go source files executes the Go race detector, which makes the compiler create a modified version of a typical executable file. </span><span class="koboSpan" id="kobo.896.2">This modified version can record all accesses to shared variables as well as all synchronization events that take place, including calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.897.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.898.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.899.1">sync.WaitGroup</span></code><span class="koboSpan" id="kobo.900.1">, which are presented later on in this chapter. </span><span class="koboSpan" id="kobo.900.2">After analyzing the relevant events, the race detector prints a report that can help you identify potential problems so that you can</span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.901.1"> correct them.</span></p>
<h2 class="heading-2" id="_idParaDest-235"><span class="koboSpan" id="kobo.902.1">The Go race detector</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.903.1">You can run the race</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.904.1"> detector tool with </span><code class="inlineCode"><span class="koboSpan" id="kobo.905.1">go run -race</span></code><span class="koboSpan" id="kobo.906.1">. </span><span class="koboSpan" id="kobo.906.2">If we test </span><code class="inlineCode"><span class="koboSpan" id="kobo.907.1">channels.go</span></code><span class="koboSpan" id="kobo.908.1"> using </span><code class="inlineCode"><span class="koboSpan" id="kobo.909.1">go run -race</span></code><span class="koboSpan" id="kobo.910.1">, we are going to get the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.911.1">$ </span></span><span class="koboSpan" id="kobo.912.1">go run -race channels.go 
Exit.
</span><span class="koboSpan" id="kobo.912.2">Read: 10
Channel is closed!
</span><span class="koboSpan" id="kobo.912.3">true
true
true
n: 3
==================
WARNING: DATA RACE
Write at 0x00c000094010 by main goroutine:
  runtime.recvDirect()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/chan.go:348 +0x7c
  main.main()
      ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:54 +0x444
Previous read at 0x00c000094010 by goroutine 10:
  runtime.chansend1()
      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/chan.go:146 +0x2c
  main.printer()
      ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:14 +0x34
  main.main.func3()
      ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:40 +0x34
Goroutine 10 (running) created at:
  main.main()
      ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:40 +0x2b8
==================
false
false
false
false
false
panic: send on closed channel
goroutine 36 [running]:
main.printer(0x0?)
    ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:14 +0x38
created by main.main in goroutine 1
    ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:40 +0x2bc
exit status 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.913.1">Therefore, although </span><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">channels.go</span></code><span class="koboSpan" id="kobo.915.1"> looks fine at first, there is a race condition waiting to happen. </span><span class="koboSpan" id="kobo.915.2">Let us now discuss where the problem with </span><code class="inlineCode"><span class="koboSpan" id="kobo.916.1">channels.go</span></code><span class="koboSpan" id="kobo.917.1"> lies based on the previous output. </span><span class="koboSpan" id="kobo.917.2">There is a closing of a channel at </span><code class="inlineCode"><span class="koboSpan" id="kobo.918.1">channels.go</span></code><span class="koboSpan" id="kobo.919.1"> on line 54, and there is a write to the same channel on line 14 that looks to be the root of the race condition situation. </span><span class="koboSpan" id="kobo.919.2">Line 54 is </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">close(ch)</span></code><span class="koboSpan" id="kobo.921.1">, whereas line 14 is </span><code class="inlineCode"><span class="koboSpan" id="kobo.922.1">ch &lt;- true</span></code><span class="koboSpan" id="kobo.923.1">. </span><span class="koboSpan" id="kobo.923.2">The issue is that we cannot be sure about what is going to happen and in which order—this is the race condition. </span><span class="koboSpan" id="kobo.923.3">If you execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.924.1">channels.go</span></code><span class="koboSpan" id="kobo.925.1"> without the race detector, it might work, but if you try it multiple times, you might get a </span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">panic: send on closed channel</span></code><span class="koboSpan" id="kobo.927.1"> error message—this mainly has to do with the order in which the Go scheduler is going to run the goroutines of the program. </span><span class="koboSpan" id="kobo.927.2">So, if the closing of the channel happens first, then writing to that channel is going to fail—race condition!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.928.1">Fixing </span><code class="inlineCode"><span class="koboSpan" id="kobo.929.1">channels.go</span></code><span class="koboSpan" id="kobo.930.1"> requires changing</span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.931.1"> the code and, more specifically, the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">printer()</span></code><span class="koboSpan" id="kobo.933.1"> function. </span><span class="koboSpan" id="kobo.933.2">The corrected version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.934.1">channels.go</span></code><span class="koboSpan" id="kobo.935.1"> is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.936.1">chRace.go</span></code><span class="koboSpan" id="kobo.937.1"> and comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.938.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.939.1">printer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.940.1">(ch </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.941.1">chan</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.942.1">&lt;- </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.943.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.944.1">, times </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.945.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.946.1">)</span></span><span class="koboSpan" id="kobo.947.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.948.1">for</span></span><span class="koboSpan" id="kobo.949.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.950.1">0</span></span><span class="koboSpan" id="kobo.951.1">; i &lt; times; i++ {
        ch &lt;- </span><span class="hljs-literal"><span class="koboSpan" id="kobo.952.1">true</span></span><span class="koboSpan" id="kobo.953.1">
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.954.1">close</span></span><span class="koboSpan" id="kobo.955.1">(ch)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.956.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.957.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.958.1">()</span></span><span class="koboSpan" id="kobo.959.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.960.1">// This is an unbuffered channel</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.961.1">var</span></span><span class="koboSpan" id="kobo.962.1"> ch </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.963.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.964.1">bool</span></span><span class="koboSpan" id="kobo.965.1"> = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.966.1">make</span></span><span class="koboSpan" id="kobo.967.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.968.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.969.1">bool</span></span><span class="koboSpan" id="kobo.970.1">)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.971.1">// Write 5 values to channel with a single goroutine</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.972.1">go</span></span><span class="koboSpan" id="kobo.973.1"> printer(ch, </span><span class="hljs-number"><span class="koboSpan" id="kobo.974.1">5</span></span><span class="koboSpan" id="kobo.975.1">)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.976.1">// IMPORTANT: As the channel ch is closed,</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.977.1">// the range loop is going to exit on its own.</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.978.1">for</span></span><span class="koboSpan" id="kobo.979.1"> val := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.980.1">range</span></span><span class="koboSpan" id="kobo.981.1"> ch {
        fmt.Print(val, </span><span class="hljs-string"><span class="koboSpan" id="kobo.982.1">" "</span></span><span class="koboSpan" id="kobo.983.1">)
    }
    fmt.Println()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.984.1">for</span></span><span class="koboSpan" id="kobo.985.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.986.1">0</span></span><span class="koboSpan" id="kobo.987.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.988.1">15</span></span><span class="koboSpan" id="kobo.989.1">; i++ {
        fmt.Print(&lt;-ch, </span><span class="hljs-string"><span class="koboSpan" id="kobo.990.1">" "</span></span><span class="koboSpan" id="kobo.991.1">)
    }
    fmt.Println()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.992.1">The first thing to notice is that instead of using multiple goroutines for writing to the desired channel, we use</span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.993.1"> a single goroutine. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.994.1">A single goroutine writing to a channel followed by the closing of that channel cannot create any race conditions because things happen sequentially</span></strong><span class="koboSpan" id="kobo.995.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.996.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.997.1">go run -race chRace.go</span></code><span class="koboSpan" id="kobo.998.1"> produces</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.999.1"> the following output, which means that there is no longer a race condition:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1000.1">true true true true true 
false false false false false false false false false false false false false false false
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1001.1">The next section is about the important and powerful </span><code class="inlineCode"><span class="koboSpan" id="kobo.1002.1">select</span></code><span class="koboSpan" id="kobo.1003.1"> keyword.</span></p>
<h1 class="heading-1" id="_idParaDest-236"><span class="koboSpan" id="kobo.1004.1">The select keyword</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1005.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1006.1">select</span></code><span class="koboSpan" id="kobo.1007.1"> keyword is really important</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.1008.1"> because it allows you to </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1009.1">listen to multiple channels at the same time</span></strong><span class="koboSpan" id="kobo.1010.1">. </span><span class="koboSpan" id="kobo.1010.2">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.1011.1">select</span></code><span class="koboSpan" id="kobo.1012.1"> block can have multiple cases and an optional </span><code class="inlineCode"><span class="koboSpan" id="kobo.1013.1">default</span></code><span class="koboSpan" id="kobo.1014.1"> case, which mimics the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1015.1">switch</span></code><span class="koboSpan" id="kobo.1016.1"> statement. </span><span class="koboSpan" id="kobo.1016.2">It is good for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1017.1">select</span></code><span class="koboSpan" id="kobo.1018.1"> blocks to have a timeout option just in case. </span><span class="koboSpan" id="kobo.1018.2">Lastly, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1019.1">select</span></code><span class="koboSpan" id="kobo.1020.1"> without any cases (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1021.1">select{}</span></code><span class="koboSpan" id="kobo.1022.1">) waits forever.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1023.1">In practice, this means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1024.1">select</span></code><span class="koboSpan" id="kobo.1025.1"> allows a goroutine to wait on multiple communication operations. </span><span class="koboSpan" id="kobo.1025.2">So, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1026.1">select</span></code><span class="koboSpan" id="kobo.1027.1"> gives you the power to listen to multiple channels using a single select block. </span><span class="koboSpan" id="kobo.1027.2">Consequently, you can have non-blocking operations on channels, provided that you have implemented your </span><code class="inlineCode"><span class="koboSpan" id="kobo.1028.1">select</span></code><span class="koboSpan" id="kobo.1029.1"> blocks appropriately.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1030.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.1031.1">select</span></code><span class="koboSpan" id="kobo.1032.1"> statement is </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1033.1">not evaluated sequentially</span></strong><span class="koboSpan" id="kobo.1034.1">, as all of its channels are examined simultaneously. </span><span class="koboSpan" id="kobo.1034.2">If none of the channels in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1035.1">select</span></code><span class="koboSpan" id="kobo.1036.1"> statement are ready, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1037.1">select</span></code><span class="koboSpan" id="kobo.1038.1"> statement blocks (waits) until one of the channels is ready. </span><span class="koboSpan" id="kobo.1038.2">If multiple channels of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1039.1">select</span></code><span class="koboSpan" id="kobo.1040.1"> statement are ready, then the Go runtime </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1041.1">makes a random selection</span></strong><span class="koboSpan" id="kobo.1042.1"> from the set of these ready channels.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1043.1">The code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1044.1">select.go</span></code><span class="koboSpan" id="kobo.1045.1"> presents a simple</span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.1046.1"> use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1047.1">select</span></code><span class="koboSpan" id="kobo.1048.1"> running in a goroutine that has three cases. </span><span class="koboSpan" id="kobo.1048.2">But first, let us see how the goroutine that contains </span><code class="inlineCode"><span class="koboSpan" id="kobo.1049.1">select</span></code><span class="koboSpan" id="kobo.1050.1"> is executed:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1051.1">    wg.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1052.1">1</span></span><span class="koboSpan" id="kobo.1053.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1054.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1055.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1056.1">()</span></span><span class="koboSpan" id="kobo.1057.1"> {
        gen(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1058.1">0</span></span><span class="koboSpan" id="kobo.1059.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1060.1">2</span></span><span class="koboSpan" id="kobo.1061.1">*n, createNumber, end)
        wg.Done()
    }()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1062.1">The previous code tells us that for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1063.1">wg.Done()</span></code><span class="koboSpan" id="kobo.1064.1"> to get executed, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1065.1">gen()</span></code><span class="koboSpan" id="kobo.1066.1"> should return first. </span><span class="koboSpan" id="kobo.1066.2">So, let us see the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1067.1">gen()</span></code><span class="koboSpan" id="kobo.1068.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1069.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1070.1">gen</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1071.1">(min, max </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1072.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1073.1">, createNumber </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1074.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1075.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1076.1">, end </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1077.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1078.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1079.1">)</span></span><span class="koboSpan" id="kobo.1080.1"> {
    time.Sleep(time.Second)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1081.1">for</span></span><span class="koboSpan" id="kobo.1082.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1083.1">select</span></span><span class="koboSpan" id="kobo.1084.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1085.1">case</span></span><span class="koboSpan" id="kobo.1086.1"> createNumber &lt;- rand.Intn(max-min) + min:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1087.1">case</span></span><span class="koboSpan" id="kobo.1088.1"> &lt;-end:
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1089.1">"Ended!"</span></span><span class="koboSpan" id="kobo.1090.1">)
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1091.1">// return</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1092.1">The right thing to do here is to add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1093.1">return</span></code><span class="koboSpan" id="kobo.1094.1"> statement for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1095.1">gen()</span></code><span class="koboSpan" id="kobo.1096.1"> to finish. </span><span class="koboSpan" id="kobo.1096.2">Let us imagine that you have forgotten to add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1097.1">return</span></code><span class="koboSpan" id="kobo.1098.1"> statement. </span><span class="koboSpan" id="kobo.1098.2">This means that the function is not going to finish after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1099.1">select</span></code><span class="koboSpan" id="kobo.1100.1"> branch associated with the end channel parameter is executed—</span><code class="inlineCode"><span class="koboSpan" id="kobo.1101.1">createNumber</span></code><span class="koboSpan" id="kobo.1102.1"> is not going to end the function as it has no </span><code class="inlineCode"><span class="koboSpan" id="kobo.1103.1">return</span></code><span class="koboSpan" id="kobo.1104.1"> statement. </span><span class="koboSpan" id="kobo.1104.2">Therefore, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1105.1">select</span></code><span class="koboSpan" id="kobo.1106.1"> block keeps waiting for more. </span><span class="koboSpan" id="kobo.1106.2">The solution can be found in the code that follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1107.1">case</span></span><span class="koboSpan" id="kobo.1108.1"> &lt;-time.After(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1109.1">4</span></span><span class="koboSpan" id="kobo.1110.1"> * time.Second):
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1111.1">"time.After()!"</span></span><span class="koboSpan" id="kobo.1112.1">)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1113.1">return</span></span><span class="koboSpan" id="kobo.1114.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1115.1">So, what is really happening in the code of the entire select block? </span><span class="koboSpan" id="kobo.1115.2">This particular </span><code class="inlineCode"><span class="koboSpan" id="kobo.1116.1">select</span></code><span class="koboSpan" id="kobo.1117.1"> statement has three cases. </span><span class="koboSpan" id="kobo.1117.2">As stated earlier, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1118.1">select</span></code><span class="koboSpan" id="kobo.1119.1"> does not require a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1120.1">default</span></code><span class="koboSpan" id="kobo.1121.1"> branch. </span><span class="koboSpan" id="kobo.1121.2">You can consider the third branch of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1122.1">select</span></code><span class="koboSpan" id="kobo.1123.1"> statement as a clever </span><code class="inlineCode"><span class="koboSpan" id="kobo.1124.1">default</span></code><span class="koboSpan" id="kobo.1125.1"> branch. </span><span class="koboSpan" id="kobo.1125.2">This happens because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1126.1">time.After()</span></code><span class="koboSpan" id="kobo.1127.1"> waits for the specified duration (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1128.1">4 * time.Second</span></code><span class="koboSpan" id="kobo.1129.1">) to elapse and then prints a message and properly ends </span><code class="inlineCode"><span class="koboSpan" id="kobo.1130.1">gen()</span></code><span class="koboSpan" id="kobo.1131.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1132.1">return</span></code><span class="koboSpan" id="kobo.1133.1">. </span><span class="koboSpan" id="kobo.1133.2">This unblocks the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1134.1">select</span></code><span class="koboSpan" id="kobo.1135.1"> statement in case all of the other channels are blocked for some reason. </span><span class="koboSpan" id="kobo.1135.2">Although omitting </span><code class="inlineCode"><span class="koboSpan" id="kobo.1136.1">return</span></code><span class="koboSpan" id="kobo.1137.1"> from the second branch is a bug, this shows that having an exit strategy is always a good thing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1138.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1139.1">select.go</span></code><span class="koboSpan" id="kobo.1140.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1141.1">$ </span></span><span class="koboSpan" id="kobo.1142.1">go run select.go 10
Going to create 10 random numbers.
</span><span class="koboSpan" id="kobo.1142.2">13 0 2 8 12 4 13 15 14 19 Ended!
</span><span class="koboSpan" id="kobo.1142.3">time.After()!
</span><span class="koboSpan" id="kobo.1142.4">Exiting...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1143.1">We are going to see </span><code class="inlineCode"><span class="koboSpan" id="kobo.1144.1">select</span></code><span class="koboSpan" id="kobo.1145.1"> in action in the remainder </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.1146.1">of the chapter, starting from the next section, which discusses how to time out goroutines. </span><span class="koboSpan" id="kobo.1146.2">What you should remember is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1147.1">select</span></code><span class="koboSpan" id="kobo.1148.1"> allows us to </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1149.1">listen to multiple channels from a single point</span></strong><span class="koboSpan" id="kobo.1150.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-237"><span class="koboSpan" id="kobo.1151.1">Timing out a goroutine</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1152.1">There are times when goroutines</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.1153.1"> take more time than expected to finish—in such situations, we want to time out the goroutines so that we can unblock the program. </span><span class="koboSpan" id="kobo.1153.2">This section presents two such techniques.</span></p>
<h2 class="heading-2" id="_idParaDest-238"><span class="koboSpan" id="kobo.1154.1">Timing out a goroutine inside main()</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1155.1">This subsection presents</span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.1156.1"> a simple technique for timing out a goroutine. </span><span class="koboSpan" id="kobo.1156.2">The relevant code can be found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1157.1">main()</span></code><span class="koboSpan" id="kobo.1158.1"> function of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1159.1">timeOut1.go</span></code><span class="koboSpan" id="kobo.1160.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1161.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1162.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1163.1">()</span></span><span class="koboSpan" id="kobo.1164.1"> {
    c1 := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1165.1">make</span></span><span class="koboSpan" id="kobo.1166.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1167.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1168.1">string</span></span><span class="koboSpan" id="kobo.1169.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1170.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1171.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1172.1">()</span></span><span class="koboSpan" id="kobo.1173.1"> {
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1174.1">3</span></span><span class="koboSpan" id="kobo.1175.1"> * time.Second)
        c1 &lt;- </span><span class="hljs-string"><span class="koboSpan" id="kobo.1176.1">"c1 OK"</span></span><span class="koboSpan" id="kobo.1177.1">
    }()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1178.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1179.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.1180.1"> call is used for emulating the time it normally takes for a function to finish its operation. </span><span class="koboSpan" id="kobo.1180.2">In this case, the anonymous function that is executed as a goroutine takes about three seconds before writing a message to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1181.1">c1</span></code><span class="koboSpan" id="kobo.1182.1"> channel.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1183.1">select</span></span><span class="koboSpan" id="kobo.1184.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1185.1">case</span></span><span class="koboSpan" id="kobo.1186.1"> res := &lt;-c1:
        fmt.Println(res)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1187.1">case</span></span><span class="koboSpan" id="kobo.1188.1"> &lt;-time.After(time.Second):
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1189.1">"timeout c1"</span></span><span class="koboSpan" id="kobo.1190.1">)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1191.1">The purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1192.1">time.After()</span></code><span class="koboSpan" id="kobo.1193.1"> call is to wait for the desired time before being executed—if another branch is executed, the waiting time resets. </span><span class="koboSpan" id="kobo.1193.2">In this case, we are not interested in the actual value returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1194.1">time.After()</span></code><span class="koboSpan" id="kobo.1195.1"> but in the fact that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1196.1">time.After()</span></code><span class="koboSpan" id="kobo.1197.1"> branch was executed, which means that the waiting time has passed. </span><span class="koboSpan" id="kobo.1197.2">In this case, as the value passed to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1198.1">time.After()</span></code><span class="koboSpan" id="kobo.1199.1"> function is smaller than the value used in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1200.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.1201.1"> call that was executed previously, you will most likely get a timeout message. </span><span class="koboSpan" id="kobo.1201.2">The reason</span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.1202.1"> for saying “most likely” is that Linux is not a real-time OS and, sometimes, the OS scheduler plays strange games, especially when it has to deal with a high load and has to schedule lots of tasks—this means that you should not make any assumptions about the operation of the OS scheduler.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1203.1">    c2 := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1204.1">make</span></span><span class="koboSpan" id="kobo.1205.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1206.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1207.1">string</span></span><span class="koboSpan" id="kobo.1208.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1209.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1210.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1211.1">()</span></span><span class="koboSpan" id="kobo.1212.1"> {
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1213.1">3</span></span><span class="koboSpan" id="kobo.1214.1"> * time.Second)
        c2 &lt;- </span><span class="hljs-string"><span class="koboSpan" id="kobo.1215.1">"c2 OK"</span></span><span class="koboSpan" id="kobo.1216.1">
    }()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1217.1">select</span></span><span class="koboSpan" id="kobo.1218.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1219.1">case</span></span><span class="koboSpan" id="kobo.1220.1"> res := &lt;-c2:
        fmt.Println(res)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1221.1">case</span></span><span class="koboSpan" id="kobo.1222.1"> &lt;-time.After(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1223.1">4</span></span><span class="koboSpan" id="kobo.1224.1"> * time.Second):
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1225.1">"timeout c2"</span></span><span class="koboSpan" id="kobo.1226.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1227.1">The preceding code executes a goroutine that takes about three seconds to execute because of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1228.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.1229.1"> call and defines a timeout period of four seconds in select using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1230.1">time.After(4 * time.Second)</span></code><span class="koboSpan" id="kobo.1231.1">. </span><span class="koboSpan" id="kobo.1231.2">If the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1232.1">time.After(4 * time.Second)</span></code><span class="koboSpan" id="kobo.1233.1"> call returns after you get a value from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1234.1">c2</span></code><span class="koboSpan" id="kobo.1235.1"> channel found in the first case of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1236.1">select</span></code><span class="koboSpan" id="kobo.1237.1"> block, then there will be no timeout; otherwise, you will get a timeout. </span><span class="koboSpan" id="kobo.1237.2">However, in this case, the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1238.1">time.After()</span></code><span class="koboSpan" id="kobo.1239.1"> call provides enough time for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1240.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.1241.1"> call to return, so you will most likely not get a timeout message here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1242.1">Let us now verify our thoughts. </span><span class="koboSpan" id="kobo.1242.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1243.1">timeOut1.go</span></code><span class="koboSpan" id="kobo.1244.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1245.1">$ </span></span><span class="koboSpan" id="kobo.1246.1">go run timeOut1.go 
timeout c1
c2 OK
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1247.1">As expected, the first goroutine</span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.1248.1"> timed out, whereas the second one did not. </span><span class="koboSpan" id="kobo.1248.2">The subsection that follows presents another timeout technique.</span></p>
<h2 class="heading-2" id="_idParaDest-239"><span class="koboSpan" id="kobo.1249.1">Timing out a goroutine outside main()</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1250.1">This subsection illustrates another technique</span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.1251.1"> for timing out goroutines. </span><span class="koboSpan" id="kobo.1251.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1252.1">select</span></code><span class="koboSpan" id="kobo.1253.1"> statement can be found in a separate function. </span><span class="koboSpan" id="kobo.1253.2">Additionally, the timeout period is given as a command line argument.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1254.1">The interesting part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1255.1">timeOut2.go</span></code><span class="koboSpan" id="kobo.1256.1"> is the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1257.1">timeout()</span></code><span class="koboSpan" id="kobo.1258.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1259.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1260.1">timeout</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1261.1">(t time.Duration)</span></span><span class="koboSpan" id="kobo.1262.1"> {
    temp := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1263.1">make</span></span><span class="koboSpan" id="kobo.1264.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1265.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1266.1">int</span></span><span class="koboSpan" id="kobo.1267.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1268.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1269.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1270.1">()</span></span><span class="koboSpan" id="kobo.1271.1"> {
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1272.1">5</span></span><span class="koboSpan" id="kobo.1273.1"> * time.Second)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1274.1">defer</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1275.1">close</span></span><span class="koboSpan" id="kobo.1276.1">(temp)
    }()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1277.1">select</span></span><span class="koboSpan" id="kobo.1278.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1279.1">case</span></span><span class="koboSpan" id="kobo.1280.1"> &lt;-temp:
        result &lt;- </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1281.1">false</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1282.1">case</span></span><span class="koboSpan" id="kobo.1283.1"> &lt;-time.After(t):
        result &lt;- </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1284.1">true</span></span><span class="koboSpan" id="kobo.1285.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1286.1">In </span><code class="inlineCode"><span class="koboSpan" id="kobo.1287.1">timeout()</span></code><span class="koboSpan" id="kobo.1288.1">, the time duration that is used in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1289.1">time.After()</span></code><span class="koboSpan" id="kobo.1290.1"> call is a function parameter, which means that it can vary. </span><span class="koboSpan" id="kobo.1290.2">Once again, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1291.1">select</span></code><span class="koboSpan" id="kobo.1292.1"> block supports the logic of the timeout. </span><span class="koboSpan" id="kobo.1292.2">Any timeout period longer than 5 seconds will most likely give the goroutine enough time to finish. </span><span class="koboSpan" id="kobo.1292.3">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.1293.1">timeout()</span></code><span class="koboSpan" id="kobo.1294.1"> writes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1295.1">false</span></code><span class="koboSpan" id="kobo.1296.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1297.1">result</span></code><span class="koboSpan" id="kobo.1298.1"> channel, then there is no timeout, whereas if it writes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1299.1">true</span></code><span class="koboSpan" id="kobo.1300.1">, there is a timeout. </span><span class="koboSpan" id="kobo.1300.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1301.1">timeOut2.go</span></code><span class="koboSpan" id="kobo.1302.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1303.1">$ </span></span><span class="koboSpan" id="kobo.1304.1">go run timeOut2.go 100
Timeout period is 100ms
Time out!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1305.1">The timeout period is 100 milliseconds, which means that the goroutine did not have enough time to finish, hence the timeout message.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1306.1">$ </span></span><span class="koboSpan" id="kobo.1307.1">go run timeOut2.go 5500 
Timeout period is 5.5s
OK
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1308.1">This time, the timeout is 5,500 milliseconds, which</span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.1309.1"> means that the goroutine had enough time to finish.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1310.1">The next section revisits and presents advanced concepts related to channels.</span></p>
<h1 class="heading-1" id="_idParaDest-240"><span class="koboSpan" id="kobo.1311.1">Go channels revisited</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1312.1">So far, we have seen the basic usages of</span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.1313.1"> channels—this section presents the definition and the usage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1314.1">nil</span></code><span class="koboSpan" id="kobo.1315.1"> channels, signal channels, and buffered channels.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1316.1">Although channels seem like an interesting concept, they are not the answer to every concurrency problem as there exist times when they can be replaced by mutexes and shared memory. </span><span class="koboSpan" id="kobo.1316.2">So, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1317.1">do not force the use of channels</span></strong><span class="koboSpan" id="kobo.1318.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1319.1">It helps to remember that the zero value of the channel type is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1320.1">nil</span></code><span class="koboSpan" id="kobo.1321.1">, and if you send a message to a closed channel, the program panics. </span><span class="koboSpan" id="kobo.1321.2">However, if you try to read from a closed channel, you get the zero value of the type of that channel. </span><span class="koboSpan" id="kobo.1321.3">So, after closing a channel, you can no longer write to it but you can still read from it. </span><span class="koboSpan" id="kobo.1321.4">To be able to close a channel, the channel must not be receive-only.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1322.1">Additionally, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1323.1">nil</span></code><span class="koboSpan" id="kobo.1324.1"> channel always blocks, which means that both reading and writing from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1325.1">nil</span></code><span class="koboSpan" id="kobo.1326.1"> channels block. </span><span class="koboSpan" id="kobo.1326.2">This property of channels can be very useful when you want to disable a branch of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1327.1">select</span></code><span class="koboSpan" id="kobo.1328.1"> statement by assigning the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1329.1">nil</span></code><span class="koboSpan" id="kobo.1330.1"> value to a channel variable. </span><span class="koboSpan" id="kobo.1330.2">Finally, if you try to close a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1331.1">nil</span></code><span class="koboSpan" id="kobo.1332.1"> channel, your program is going to panic. </span><span class="koboSpan" id="kobo.1332.2">This is best illustrated in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1333.1">closeNil.go</span></code><span class="koboSpan" id="kobo.1334.1"> program:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1335.1">package</span></span><span class="koboSpan" id="kobo.1336.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1337.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1338.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1339.1">()</span></span><span class="koboSpan" id="kobo.1340.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1341.1">var</span></span><span class="koboSpan" id="kobo.1342.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1343.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1344.1">string</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1345.1">The previous statement defines a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1346.1">nil</span></code><span class="koboSpan" id="kobo.1347.1"> channel named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1348.1">c</span></code><span class="koboSpan" id="kobo.1349.1"> of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1350.1">string</span></code><span class="koboSpan" id="kobo.1351.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1352.1">close</span></span><span class="koboSpan" id="kobo.1353.1">(c)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1354.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1355.1">closeNil.go</span></code><span class="koboSpan" id="kobo.1356.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1357.1">panic: close of nil channel
goroutine 1 [running]:
main.main()
    ~/go/src/github.com/mactsouk/mGo4th/ch08/closeNil.go:5 +0x20
exit status 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1358.1">The previous output shows</span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.1359.1"> the message you are going to get if you try to close a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1360.1">nil</span></code><span class="koboSpan" id="kobo.1361.1"> channel. </span><span class="koboSpan" id="kobo.1361.2">Let us now discuss buffered channels.</span></p>
<h2 class="heading-2" id="_idParaDest-241"><span class="koboSpan" id="kobo.1362.1">Buffered channels</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1363.1">Unlike unbuffered</span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.1364.1"> channels, which have</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.1365.1"> a capacity of 0 and require a sender to have a corresponding receiver ready at the other end, buffered channels allow a certain number of values to be sent into the channel before a receiver is needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1366.1">These channels allow us to put jobs in a queue quickly to be able to deal with more requests and process requests later on. </span><span class="koboSpan" id="kobo.1366.2">Moreover, you can use buffered channels as semaphores to limit the throughput of your application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1367.1">The presented technique works as follows: all incoming requests are forwarded to a channel, which processes them one by one. </span><span class="koboSpan" id="kobo.1367.2">When the channel is done processing a request, it sends a message to the original caller saying that it is ready to process a new one. </span><span class="koboSpan" id="kobo.1367.3">So, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1368.1">the capacity of the buffer of the channel restricts the number of simultaneous requests that it can keep</span></strong><span class="koboSpan" id="kobo.1369.1">. </span><span class="koboSpan" id="kobo.1369.2">Bear in mind that it is not the channel that processes the requests or sends the messages. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1370.1">Also, bear in mind that a buffered channel keeps accepting data until it blocks due to its limited capacity. </span><span class="koboSpan" id="kobo.1370.2">However, in the presented example, the implementation is what cancels remaining requests after the channel buffer is full due to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1371.1">select</span></code><span class="koboSpan" id="kobo.1372.1"> statement, not the channel itself. </span><span class="koboSpan" id="kobo.1372.2">The source file that implements the technique is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1373.1">bufChannel.go</span></code><span class="koboSpan" id="kobo.1374.1"> and contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1375.1">package</span></span><span class="koboSpan" id="kobo.1376.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1377.1">import</span></span><span class="koboSpan" id="kobo.1378.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1379.1">"fmt"</span></span><span class="koboSpan" id="kobo.1380.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1381.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1382.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1383.1">()</span></span><span class="koboSpan" id="kobo.1384.1"> {
    numbers := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1385.1">make</span></span><span class="koboSpan" id="kobo.1386.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1387.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1388.1">int</span></span><span class="koboSpan" id="kobo.1389.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1390.1">5</span></span><span class="koboSpan" id="kobo.1391.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1392.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1393.1">numbers</span></code><span class="koboSpan" id="kobo.1394.1"> channel can store up to five integers because it is a buffer channel with a capacity of 5.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1395.1">    counter := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1396.1">10</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1397.1">for</span></span><span class="koboSpan" id="kobo.1398.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1399.1">0</span></span><span class="koboSpan" id="kobo.1400.1">; i &lt; counter; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1401.1">select</span></span><span class="koboSpan" id="kobo.1402.1"> {
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1403.1">// This is where the processing takes place</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1404.1">case</span></span><span class="koboSpan" id="kobo.1405.1"> numbers &lt;- i * i:
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1406.1">"About to process"</span></span><span class="koboSpan" id="kobo.1407.1">, i)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1408.1">default</span></span><span class="koboSpan" id="kobo.1409.1">:
            fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1410.1">"No space for "</span></span><span class="koboSpan" id="kobo.1411.1">, i, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1412.1">" "</span></span><span class="koboSpan" id="kobo.1413.1">)
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1414.1">We begin putting data into </span><code class="inlineCode"><span class="koboSpan" id="kobo.1415.1">numbers</span></code><span class="koboSpan" id="kobo.1416.1">—however, when</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.1417.1"> the channel is full, it is not going</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.1418.1"> to store more data and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1419.1">default</span></code><span class="koboSpan" id="kobo.1420.1"> branch is going to be executed. </span><span class="koboSpan" id="kobo.1420.2">This is not because of the way channels work but because of the specific implementation with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1421.1">select</span></code><span class="koboSpan" id="kobo.1422.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1423.1">    }
    fmt.Println()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1424.1">for</span></span><span class="koboSpan" id="kobo.1425.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1426.1">select</span></span><span class="koboSpan" id="kobo.1427.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1428.1">case</span></span><span class="koboSpan" id="kobo.1429.1"> num := &lt;-numbers:
            fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1430.1">"*"</span></span><span class="koboSpan" id="kobo.1431.1">, num, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1432.1">" "</span></span><span class="koboSpan" id="kobo.1433.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1434.1">default</span></span><span class="koboSpan" id="kobo.1435.1">:
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1436.1">"Nothing left to read!"</span></span><span class="koboSpan" id="kobo.1437.1">)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1438.1">return</span></span><span class="koboSpan" id="kobo.1439.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1440.1">Similarly, we try to read data from numbers using a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1441.1">for</span></code><span class="koboSpan" id="kobo.1442.1"> loop. </span><span class="koboSpan" id="kobo.1442.2">When all data from the channel is read, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1443.1">default</span></code><span class="koboSpan" id="kobo.1444.1"> branch is going to be executed and will terminate the program with its </span><code class="inlineCode"><span class="koboSpan" id="kobo.1445.1">return</span></code><span class="koboSpan" id="kobo.1446.1"> statement—when </span><code class="inlineCode"><span class="koboSpan" id="kobo.1447.1">main()</span></code><span class="koboSpan" id="kobo.1448.1"> returns, the entire program will be terminated.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1449.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1450.1">bufChannel.go</span></code><span class="koboSpan" id="kobo.1451.1"> produces </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.1452.1">the following</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.1453.1"> output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1454.1">$ </span></span><span class="koboSpan" id="kobo.1455.1">go run bufChannel.go 
About to process 0
. </span><span class="koboSpan" id="kobo.1455.2">. </span><span class="koboSpan" id="kobo.1455.3">.
</span><span class="koboSpan" id="kobo.1455.4">About to process 4
No space for 5 No space for 6 No space for 7 No space for 8 No space for 9 
*0 *1 *4 *9 *16 Nothing left to read!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1456.1">Let us now discuss </span><code class="inlineCode"><span class="koboSpan" id="kobo.1457.1">nil</span></code><span class="koboSpan" id="kobo.1458.1"> channels.</span></p>
<h2 class="heading-2" id="_idParaDest-242"><span class="koboSpan" id="kobo.1459.1">nil channels</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1460.1">nil</span></code><span class="koboSpan" id="kobo.1461.1"> channels </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1462.1">always block</span></strong><span class="koboSpan" id="kobo.1463.1">! </span><span class="koboSpan" id="kobo.1463.2">Therefore, you</span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.1464.1"> should use them when</span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.1465.1"> you want that behavior on purpose! </span><span class="koboSpan" id="kobo.1465.2">The code that follows illustrates </span><code class="inlineCode"><span class="koboSpan" id="kobo.1466.1">nil</span></code><span class="koboSpan" id="kobo.1467.1"> channels:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1468.1">package</span></span><span class="koboSpan" id="kobo.1469.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1470.1">import</span></span><span class="koboSpan" id="kobo.1471.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1472.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1473.1">"math/rand"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1474.1">"sync"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1475.1">"time"</span></span><span class="koboSpan" id="kobo.1476.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1477.1">var</span></span><span class="koboSpan" id="kobo.1478.1"> wg sync.WaitGroup
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1479.1">We are making </span><code class="inlineCode"><span class="koboSpan" id="kobo.1480.1">wg</span></code><span class="koboSpan" id="kobo.1481.1"> a global variable in order to be available from anywhere in the code and avoid passing it to every function that needs it as a parameter. </span><span class="koboSpan" id="kobo.1481.2">This is not idiomatic Go and some people might dislike that approach, despite its simpler implementation. </span><span class="koboSpan" id="kobo.1481.3">An alternative would be to declare </span><code class="inlineCode"><span class="koboSpan" id="kobo.1482.1">wg</span></code><span class="koboSpan" id="kobo.1483.1"> in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1484.1">main()</span></code><span class="koboSpan" id="kobo.1485.1"> and pass a pointer to each function that needs it—you can implement that as an exercise.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1486.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1487.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1488.1">(c </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1489.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1490.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1491.1">)</span></span><span class="koboSpan" id="kobo.1492.1"> {
    sum := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1493.1">0</span></span><span class="koboSpan" id="kobo.1494.1">
    t := time.NewTimer(time.Second)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1495.1">for</span></span><span class="koboSpan" id="kobo.1496.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1497.1">select</span></span><span class="koboSpan" id="kobo.1498.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1499.1">case</span></span><span class="koboSpan" id="kobo.1500.1"> input := &lt;-c:
            sum = sum + input
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1501.1">case</span></span><span class="koboSpan" id="kobo.1502.1"> &lt;-t.C:
            c = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1503.1">nil</span></span><span class="koboSpan" id="kobo.1504.1">
            fmt.Println(sum)
            wg.Done()
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1505.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1506.1">send()</span></code><span class="koboSpan" id="kobo.1507.1"> function keeps sending random numbers to channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1508.1">c</span></code><span class="koboSpan" id="kobo.1509.1">. </span><span class="koboSpan" id="kobo.1509.2">Do not confuse channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1510.1">c</span></code><span class="koboSpan" id="kobo.1511.1">, which is a (channel) function parameter, with channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1512.1">t.C</span></code><span class="koboSpan" id="kobo.1513.1">, which is part of timer </span><code class="inlineCode"><span class="koboSpan" id="kobo.1514.1">t</span></code><span class="koboSpan" id="kobo.1515.1">—you can change the name of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1516.1">c</span></code><span class="koboSpan" id="kobo.1517.1"> variable but not the name of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1518.1">C</span></code><span class="koboSpan" id="kobo.1519.1"> field of a timer. </span><span class="koboSpan" id="kobo.1519.2">When the time of timer </span><code class="inlineCode"><span class="koboSpan" id="kobo.1520.1">t</span></code><span class="koboSpan" id="kobo.1521.1"> expires, the timer sends a value to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1522.1">t.C</span></code><span class="koboSpan" id="kobo.1523.1"> channel.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1524.1">This triggers the execution of the relevant branch of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1525.1">select</span></code><span class="koboSpan" id="kobo.1526.1"> statement, which assigns the value </span><code class="inlineCode"><span class="koboSpan" id="kobo.1527.1">nil</span></code><span class="koboSpan" id="kobo.1528.1"> to channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1529.1">c</span></code><span class="koboSpan" id="kobo.1530.1"> and prints the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1531.1">sum</span></code><span class="koboSpan" id="kobo.1532.1"> variable, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1533.1">wg.Done()</span></code><span class="koboSpan" id="kobo.1534.1"> is executed, which is going to unblock </span><code class="inlineCode"><span class="koboSpan" id="kobo.1535.1">wg.Wait()</span></code><span class="koboSpan" id="kobo.1536.1"> found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1537.1">main()</span></code><span class="koboSpan" id="kobo.1538.1"> function. </span><span class="koboSpan" id="kobo.1538.2">Additionally, as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1539.1">c</span></code><span class="koboSpan" id="kobo.1540.1"> becomes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1541.1">nil</span></code><span class="koboSpan" id="kobo.1542.1">, it stops/blocks </span><code class="inlineCode"><span class="koboSpan" id="kobo.1543.1">send()</span></code><span class="koboSpan" id="kobo.1544.1"> from sending more data to it.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1545.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1546.1">send</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1547.1">(c </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1548.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1549.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1550.1">)</span></span><span class="koboSpan" id="kobo.1551.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1552.1">for</span></span><span class="koboSpan" id="kobo.1553.1"> {
        c &lt;- rand.Intn(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1554.1">10</span></span><span class="koboSpan" id="kobo.1555.1">)
    }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1556.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1557.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1558.1">()</span></span><span class="koboSpan" id="kobo.1559.1"> {
    c := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1560.1">make</span></span><span class="koboSpan" id="kobo.1561.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1562.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1563.1">int</span></span><span class="koboSpan" id="kobo.1564.1">)
    rand.Seed(time.Now().Unix())
    wg.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1565.1">1</span></span><span class="koboSpan" id="kobo.1566.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1567.1">go</span></span><span class="koboSpan" id="kobo.1568.1"> add(c)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1569.1">go</span></span><span class="koboSpan" id="kobo.1570.1"> send(c)
    wg.Wait()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1571.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1572.1">nilChannel.go</span></code><span class="koboSpan" id="kobo.1573.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1574.1">$ </span></span><span class="koboSpan" id="kobo.1575.1">go run nilChannel.go 
11168960
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1576.1">Since the number of times</span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.1577.1"> that the first branch of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1578.1">select</span></code><span class="koboSpan" id="kobo.1579.1"> statement in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1580.1">add()</span></code><span class="koboSpan" id="kobo.1581.1"> is going</span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.1582.1"> to be executed is not fixed, you get different results each time you execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.1583.1">nilChannel.go</span></code><span class="koboSpan" id="kobo.1584.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1585.1">The next subsection discusses worker pools.</span></p>
<h2 class="heading-2" id="_idParaDest-243"><span class="koboSpan" id="kobo.1586.1">Worker pools</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1587.1">A worker</span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.1588.1"> pool is a </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1589.1">set of threads that process jobs assigned to them</span></strong><span class="koboSpan" id="kobo.1590.1">. </span><span class="koboSpan" id="kobo.1590.2">The Apache</span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.1591.1"> web server and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1592.1">net/http</span></code><span class="koboSpan" id="kobo.1593.1"> package of Go more or less work this way: the main process accepts all incoming requests, which are forwarded to worker processes to get served. </span><span class="koboSpan" id="kobo.1593.2">Once a worker process has finished its job, it is ready to serve a new client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1594.1">As Go does not have threads, the presented implementation is going to use goroutines instead of threads. </span><span class="koboSpan" id="kobo.1594.2">Additionally, threads do not usually die after serving a request because the cost of ending a thread and creating a new one is too high, whereas goroutines do die after finishing their job. </span><span class="koboSpan" id="kobo.1594.3">Worker pools in Go are implemented with the help of buffered channels, as they allow you to limit the number of goroutines running at the same time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1595.1">The presented utility implements </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.1596.1">a simple task: it processes</span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.1597.1"> integers and prints their square values using a single goroutine for serving each request. </span><span class="koboSpan" id="kobo.1597.2">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1598.1">wPools.go</span></code><span class="koboSpan" id="kobo.1599.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1600.1">package</span></span><span class="koboSpan" id="kobo.1601.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1602.1">import</span></span><span class="koboSpan" id="kobo.1603.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1604.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1605.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1606.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1607.1">runtime"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1608.1">"strconv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1609.1">"sync"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1610.1">"time"</span></span><span class="koboSpan" id="kobo.1611.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1612.1">type</span></span><span class="koboSpan" id="kobo.1613.1"> Client </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1614.1">struct</span></span><span class="koboSpan" id="kobo.1615.1"> {
    id      </span><span class="hljs-type"><span class="koboSpan" id="kobo.1616.1">int</span></span><span class="koboSpan" id="kobo.1617.1">
    integer </span><span class="hljs-type"><span class="koboSpan" id="kobo.1618.1">int</span></span><span class="koboSpan" id="kobo.1619.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1620.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1621.1">Client</span></code><span class="koboSpan" id="kobo.1622.1"> structure is used for keeping track of the requests that the program is going to process.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1623.1">type</span></span><span class="koboSpan" id="kobo.1624.1"> Result </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1625.1">struct</span></span><span class="koboSpan" id="kobo.1626.1"> {
    job    Client
    square </span><span class="hljs-type"><span class="koboSpan" id="kobo.1627.1">int</span></span><span class="koboSpan" id="kobo.1628.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1629.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1630.1">Result</span></code><span class="koboSpan" id="kobo.1631.1"> structure is used for keeping the data of each </span><code class="inlineCode"><span class="koboSpan" id="kobo.1632.1">Client</span></code><span class="koboSpan" id="kobo.1633.1"> as well as the results generated by the client. </span><span class="koboSpan" id="kobo.1633.2">Put simply, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1634.1">Client</span></code><span class="koboSpan" id="kobo.1635.1"> structure holds the input data of each request, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.1636.1">Result</span></code><span class="koboSpan" id="kobo.1637.1"> holds the results of a request—if you want to process more complex data, you should modify these structures.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1638.1">var</span></span><span class="koboSpan" id="kobo.1639.1"> size = runtime.GOMAXPROCS(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1640.1">0</span></span><span class="koboSpan" id="kobo.1641.1">)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1642.1">var</span></span><span class="koboSpan" id="kobo.1643.1"> clients = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1644.1">make</span></span><span class="koboSpan" id="kobo.1645.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1646.1">chan</span></span><span class="koboSpan" id="kobo.1647.1"> Client, size)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1648.1">var</span></span><span class="koboSpan" id="kobo.1649.1"> data = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1650.1">make</span></span><span class="koboSpan" id="kobo.1651.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1652.1">chan</span></span><span class="koboSpan" id="kobo.1653.1"> Result, size)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1654.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1655.1">clients</span></code><span class="koboSpan" id="kobo.1656.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1657.1">data</span></code><span class="koboSpan" id="kobo.1658.1"> buffered channels are used to get new client requests and write the results, respectively. </span><span class="koboSpan" id="kobo.1658.2">If you want your program to run faster, you can increase the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1659.1">size</span></code><span class="koboSpan" id="kobo.1660.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1661.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1662.1">worker</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1663.1">(wg *sync.WaitGroup)</span></span><span class="koboSpan" id="kobo.1664.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1665.1">for</span></span><span class="koboSpan" id="kobo.1666.1"> c := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1667.1">range</span></span><span class="koboSpan" id="kobo.1668.1"> clients {
        square := c.integer * c.integer
        output := Result{c, square}
        data &lt;- output
        time.Sleep(time.Second)
    }
    wg.Done()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1669.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1670.1">worker()</span></code><span class="koboSpan" id="kobo.1671.1"> function processes </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.1672.1">requests by reading</span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.1673.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1674.1">clients</span></code><span class="koboSpan" id="kobo.1675.1"> channel. </span><span class="koboSpan" id="kobo.1675.2">Once the processing is complete, the result is written to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1676.1">data</span></code><span class="koboSpan" id="kobo.1677.1"> channel. </span><span class="koboSpan" id="kobo.1677.2">The delay that is introduced with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1678.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.1679.1"> is not necessary but it gives you a better sense of the way that the generated output is printed.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1680.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1681.1">create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1682.1">(n </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1683.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1684.1">)</span></span><span class="koboSpan" id="kobo.1685.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1686.1">for</span></span><span class="koboSpan" id="kobo.1687.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1688.1">0</span></span><span class="koboSpan" id="kobo.1689.1">; i &lt; n; i++ {
        c := Client{i, i}
        clients &lt;- c
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1690.1">close</span></span><span class="koboSpan" id="kobo.1691.1">(clients)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1692.1">The purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1693.1">create()</span></code><span class="koboSpan" id="kobo.1694.1"> function is to create all requests properly and then send them to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1695.1">clients</span></code><span class="koboSpan" id="kobo.1696.1"> buffered channel for processing. </span><span class="koboSpan" id="kobo.1696.2">Note that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1697.1">clients</span></code><span class="koboSpan" id="kobo.1698.1"> channel is read by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1699.1">worker()</span></code><span class="koboSpan" id="kobo.1700.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1701.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1702.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1703.1">()</span></span><span class="koboSpan" id="kobo.1704.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1705.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1706.1">len</span></span><span class="koboSpan" id="kobo.1707.1">(os.Args) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.1708.1">3</span></span><span class="koboSpan" id="kobo.1709.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1710.1">"Need #jobs and #workers!"</span></span><span class="koboSpan" id="kobo.1711.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1712.1">return</span></span><span class="koboSpan" id="kobo.1713.1">
    }
    nJobs, err := strconv.Atoi(os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1714.1">1</span></span><span class="koboSpan" id="kobo.1715.1">])
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1716.1">if</span></span><span class="koboSpan" id="kobo.1717.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1718.1">nil</span></span><span class="koboSpan" id="kobo.1719.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1720.1">return</span></span><span class="koboSpan" id="kobo.1721.1">
    }
    nWorkers, err := strconv.Atoi(os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1722.1">2</span></span><span class="koboSpan" id="kobo.1723.1">])
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1724.1">if</span></span><span class="koboSpan" id="kobo.1725.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1726.1">nil</span></span><span class="koboSpan" id="kobo.1727.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1728.1">return</span></span><span class="koboSpan" id="kobo.1729.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1730.1">In the preceding code, you read</span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.1731.1"> the command line</span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.1732.1"> parameters that define the number of jobs and workers. </span><span class="koboSpan" id="kobo.1732.2">If the number of jobs is greater than the number of workers, the jobs are served in smaller chunks.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1733.1">go</span></span><span class="koboSpan" id="kobo.1734.1"> create(nJobs)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1735.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1736.1">create()</span></code><span class="koboSpan" id="kobo.1737.1"> call mimics the client requests that you are going to process.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1738.1">    finished := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1739.1">make</span></span><span class="koboSpan" id="kobo.1740.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1741.1">chan</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1742.1">interface</span></span><span class="koboSpan" id="kobo.1743.1">{})
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1744.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1745.1">finished</span></code><span class="koboSpan" id="kobo.1746.1"> channel is used for blocking the program and, therefore, needs no particular data type.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1747.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1748.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1749.1">()</span></span><span class="koboSpan" id="kobo.1750.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1751.1">for</span></span><span class="koboSpan" id="kobo.1752.1"> d := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1753.1">range</span></span><span class="koboSpan" id="kobo.1754.1"> data {
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1755.1">"Client ID: %d\tint: "</span></span><span class="koboSpan" id="kobo.1756.1">, d.job.id)
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1757.1">"%d\tsquare: %d\n"</span></span><span class="koboSpan" id="kobo.1758.1">, d.job.integer, d.square)
        }
        finished &lt;- </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1759.1">true</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1760.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1761.1">finished &lt;- true</span></code><span class="koboSpan" id="kobo.1762.1"> statement is used for unblocking the program as soon as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1763.1">for</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1764.1">range</span></code><span class="koboSpan" id="kobo.1765.1"> loop ends. </span><span class="koboSpan" id="kobo.1765.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1766.1">for range</span></code><span class="koboSpan" id="kobo.1767.1"> loop ends when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1768.1">data</span></code><span class="koboSpan" id="kobo.1769.1"> channel is closed, which happens after </span><code class="inlineCode"><span class="koboSpan" id="kobo.1770.1">wg.Wait()</span></code><span class="koboSpan" id="kobo.1771.1">, which means after all workers have finished.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1772.1">    }()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1773.1">var</span></span><span class="koboSpan" id="kobo.1774.1"> wg sync.WaitGroup
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1775.1">for</span></span><span class="koboSpan" id="kobo.1776.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1777.1">0</span></span><span class="koboSpan" id="kobo.1778.1">; i &lt; nWorkers; i++ {
        wg.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1779.1">1</span></span><span class="koboSpan" id="kobo.1780.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1781.1">go</span></span><span class="koboSpan" id="kobo.1782.1"> worker(&amp;wg)
    }
    wg.Wait()
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1783.1">close</span></span><span class="koboSpan" id="kobo.1784.1">(data)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1785.1">The purpose of the previous </span><code class="inlineCode"><span class="koboSpan" id="kobo.1786.1">for</span></code><span class="koboSpan" id="kobo.1787.1"> loop is to generate the required number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1788.1">worker()</span></code><span class="koboSpan" id="kobo.1789.1"> goroutines to process all requests.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1790.1">    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1791.1">"Finished: %v\n"</span></span><span class="koboSpan" id="kobo.1792.1">, &lt;-finished)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1793.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1794.1">&lt;-finished</span></code><span class="koboSpan" id="kobo.1795.1"> statement in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1796.1">fmt.Printf()</span></code><span class="koboSpan" id="kobo.1797.1"> blocks until the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1798.1">finished</span></code><span class="koboSpan" id="kobo.1799.1"> channel is closed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1800.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1801.1">wPools.go</span></code><span class="koboSpan" id="kobo.1802.1"> creates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1803.1">$ </span></span><span class="koboSpan" id="kobo.1804.1">go run wPools.go 8 5
Client ID: 0    int: 0    square: 0
Client ID: 1    int: 1    square: 1
Client ID: 2    int: 2    square: 4
Client ID: 3    int: 3    square: 9
Client ID: 4    int: 4    square: 16
Client ID: 5    int: 5    square: 25
Client ID: 6    int: 6    square: 36
Finished: true
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1805.1">The previous output shows that all requests were processed. </span><span class="koboSpan" id="kobo.1805.2">This technique allows you to serve a given number of requests, which saves</span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.1806.1"> you from server overload. </span><span class="koboSpan" id="kobo.1806.2">The price you pay for that is having</span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.1807.1"> to write more code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1808.1">The next subsection introduces signal channels and shows a technique for using them to define the order of execution for a small number of goroutines.</span></p>
<h2 class="heading-2" id="_idParaDest-244"><span class="koboSpan" id="kobo.1809.1">Signal channels</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1810.1">A signal channel is</span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.1811.1"> one that is used</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.1812.1"> just for signaling. </span><span class="koboSpan" id="kobo.1812.2">Put simply, you can use a signal channel when you want to inform another goroutine about something. </span><span class="koboSpan" id="kobo.1812.3">Signal channels should not be used for data transferring. </span><span class="koboSpan" id="kobo.1812.4">You are going to see signal channels in action in the next subsection where we specify the order of execution of goroutines.</span></p>
<h2 class="heading-2" id="_idParaDest-245"><span class="koboSpan" id="kobo.1813.1">Specifying the order of execution for your goroutines</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1814.1">This subsection presents a technique</span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.1815.1"> for specifying the order</span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.1816.1"> of execution of goroutines using signal channels. </span><span class="koboSpan" id="kobo.1816.2">However, keep in mind that this technique works best when you are dealing with a small number of goroutines. </span><span class="koboSpan" id="kobo.1816.3">The presented code example has four goroutines that we want to execute in the desired order—first, the goroutine for function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1817.1">A()</span></code><span class="koboSpan" id="kobo.1818.1">, then function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1819.1">B()</span></code><span class="koboSpan" id="kobo.1820.1">, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.1821.1">C()</span></code><span class="koboSpan" id="kobo.1822.1">, and finally, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1823.1">D()</span></code><span class="koboSpan" id="kobo.1824.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1825.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1826.1">defineOrder.go</span></code><span class="koboSpan" id="kobo.1827.1"> without the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1828.1">package</span></code><span class="koboSpan" id="kobo.1829.1"> statement and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1830.1">import</span></code><span class="koboSpan" id="kobo.1831.1"> block is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1832.1">var</span></span><span class="koboSpan" id="kobo.1833.1"> wg sync.WaitGroup
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1834.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1835.1">A</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1836.1">(a, b </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1837.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1838.1">struct</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1839.1">{})</span></span><span class="koboSpan" id="kobo.1840.1"> {
    &lt;-a
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1841.1">"A()!"</span></span><span class="koboSpan" id="kobo.1842.1">)
    time.Sleep(time.Second)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1843.1">close</span></span><span class="koboSpan" id="kobo.1844.1">(b)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1845.1">Function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1846.1">A()</span></code><span class="koboSpan" id="kobo.1847.1"> is going to be blocked</span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.1848.1"> until channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1849.1">a</span></code><span class="koboSpan" id="kobo.1850.1">, which is passed</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.1851.1"> as a parameter, is closed. </span><span class="koboSpan" id="kobo.1851.2">Just before it ends, it closes channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1852.1">b</span></code><span class="koboSpan" id="kobo.1853.1">, which is passed as a parameter. </span><span class="koboSpan" id="kobo.1853.2">This is going to unblock the next goroutine, which is going to be function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1854.1">B()</span></code><span class="koboSpan" id="kobo.1855.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1856.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1857.1">B</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1858.1">(a, b </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1859.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1860.1">struct</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1861.1">{})</span></span><span class="koboSpan" id="kobo.1862.1"> {
    &lt;-a
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1863.1">"B()!"</span></span><span class="koboSpan" id="kobo.1864.1">)
    time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1865.1">3</span></span><span class="koboSpan" id="kobo.1866.1"> * time.Second)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1867.1">close</span></span><span class="koboSpan" id="kobo.1868.1">(b)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1869.1">Similarly, function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1870.1">B()</span></code><span class="koboSpan" id="kobo.1871.1"> is going to be blocked until channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1872.1">a</span></code><span class="koboSpan" id="kobo.1873.1">, which is passed as a parameter, is closed. </span><span class="koboSpan" id="kobo.1873.2">Just before </span><code class="inlineCode"><span class="koboSpan" id="kobo.1874.1">B()</span></code><span class="koboSpan" id="kobo.1875.1"> ends, it closes channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1876.1">b</span></code><span class="koboSpan" id="kobo.1877.1">, which is passed as a parameter. </span><span class="koboSpan" id="kobo.1877.2">As before, this is going to unblock the following function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1878.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1879.1">C</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1880.1">(a, b </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1881.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1882.1">struct</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1883.1">{})</span></span><span class="koboSpan" id="kobo.1884.1"> {
    &lt;-a
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1885.1">"C()!"</span></span><span class="koboSpan" id="kobo.1886.1">)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1887.1">close</span></span><span class="koboSpan" id="kobo.1888.1">(b)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1889.1">As it happened with functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.1890.1">A()</span></code><span class="koboSpan" id="kobo.1891.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1892.1">B()</span></code><span class="koboSpan" id="kobo.1893.1">, the execution of function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1894.1">C()</span></code><span class="koboSpan" id="kobo.1895.1"> is blocked by channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1896.1">a</span></code><span class="koboSpan" id="kobo.1897.1">. </span><span class="koboSpan" id="kobo.1897.2">Just before it ends, it closes channel </span><code class="inlineCode"><span class="koboSpan" id="kobo.1898.1">b</span></code><span class="koboSpan" id="kobo.1899.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1900.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1901.1">D</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1902.1">(a </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1903.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1904.1">struct</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1905.1">{})</span></span><span class="koboSpan" id="kobo.1906.1"> {
    &lt;-a
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1907.1">"D()!"</span></span><span class="koboSpan" id="kobo.1908.1">)
    wg.Done()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1909.1">This is the last function that is going to be executed. </span><span class="koboSpan" id="kobo.1909.2">Therefore, although it is blocked, it does not close any channels before exiting. </span><span class="koboSpan" id="kobo.1909.3">Additionally, being the last function means that it can be executed more than once, which is not true for functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.1910.1">A()</span></code><span class="koboSpan" id="kobo.1911.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1912.1">B()</span></code><span class="koboSpan" id="kobo.1913.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1914.1">C()</span></code><span class="koboSpan" id="kobo.1915.1"> because a channel can be closed only once.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1916.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1917.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1918.1">()</span></span><span class="koboSpan" id="kobo.1919.1"> {
    x := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1920.1">make</span></span><span class="koboSpan" id="kobo.1921.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1922.1">chan</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1923.1">struct</span></span><span class="koboSpan" id="kobo.1924.1">{})
    y := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1925.1">make</span></span><span class="koboSpan" id="kobo.1926.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1927.1">chan</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1928.1">struct</span></span><span class="koboSpan" id="kobo.1929.1">{})
    z := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1930.1">make</span></span><span class="koboSpan" id="kobo.1931.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1932.1">chan</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1933.1">struct</span></span><span class="koboSpan" id="kobo.1934.1">{})
    w := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1935.1">make</span></span><span class="koboSpan" id="kobo.1936.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1937.1">chan</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1938.1">struct</span></span><span class="koboSpan" id="kobo.1939.1">{})
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1940.1">We need to have as many channels</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.1941.1"> as the number of functions</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.1942.1"> we want to execute as goroutines.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1943.1">    wg.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1944.1">1</span></span><span class="koboSpan" id="kobo.1945.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1946.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1947.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1948.1">()</span></span><span class="koboSpan" id="kobo.1949.1"> {
        D(w)
    }()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1950.1">This proves that the order of execution dictated by the Go code does not matter as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1951.1">D()</span></code><span class="koboSpan" id="kobo.1952.1"> is going to be executed last.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1953.1">    wg.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1954.1">1</span></span><span class="koboSpan" id="kobo.1955.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1956.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1957.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1958.1">()</span></span><span class="koboSpan" id="kobo.1959.1"> {
        D(w)
    }()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1960.1">go</span></span><span class="koboSpan" id="kobo.1961.1"> A(x, y)
    wg.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1962.1">1</span></span><span class="koboSpan" id="kobo.1963.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1964.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1965.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1966.1">()</span></span><span class="koboSpan" id="kobo.1967.1"> {
        D(w)
    }()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1968.1">go</span></span><span class="koboSpan" id="kobo.1969.1"> C(z, w)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1970.1">go</span></span><span class="koboSpan" id="kobo.1971.1"> B(y, z)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1972.1">Although we run </span><code class="inlineCode"><span class="koboSpan" id="kobo.1973.1">C()</span></code><span class="koboSpan" id="kobo.1974.1"> before </span><code class="inlineCode"><span class="koboSpan" id="kobo.1975.1">B()</span></code><span class="koboSpan" id="kobo.1976.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1977.1">C()</span></code><span class="koboSpan" id="kobo.1978.1"> is going to finish after </span><code class="inlineCode"><span class="koboSpan" id="kobo.1979.1">B()</span></code><span class="koboSpan" id="kobo.1980.1"> has finished.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1981.1">    wg.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1982.1">1</span></span><span class="koboSpan" id="kobo.1983.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1984.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1985.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1986.1">()</span></span><span class="koboSpan" id="kobo.1987.1"> {
        D(w)
    }()
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1988.1">// This triggers the process</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1989.1">close</span></span><span class="koboSpan" id="kobo.1990.1">(x)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1991.1">The closing of the first channel is what triggers the execution of the goroutines because this unblocks </span><code class="inlineCode"><span class="koboSpan" id="kobo.1992.1">A()</span></code><span class="koboSpan" id="kobo.1993.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1994.1">    wg.Wait()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1995.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1996.1">defineOrder.go</span></code><span class="koboSpan" id="kobo.1997.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1998.1">$ </span></span><span class="koboSpan" id="kobo.1999.1">go run defineOrder.go
A()!
</span><span class="koboSpan" id="kobo.1999.2">B()!
</span><span class="koboSpan" id="kobo.1999.3">C()!
</span><span class="koboSpan" id="kobo.1999.4">D()! </span><span class="koboSpan" id="kobo.1999.5">D()! </span><span class="koboSpan" id="kobo.1999.6">D()! </span><span class="koboSpan" id="kobo.1999.7">D()!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2000.1">So, the four functions, which</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.2001.1"> are executed</span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.2002.1"> as goroutines, are executed in the desired order, and, in the case of the last function, the desired number of times.</span></p>
<h1 class="heading-1" id="_idParaDest-246"><span class="koboSpan" id="kobo.2003.1">Handling UNIX signals</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2004.1">UNIX signals offer a very handy</span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.2005.1"> way of interacting asynchronously with applications and server processes. </span><span class="koboSpan" id="kobo.2005.2">UNIX signal handling in Go requires the use of channels that are used exclusively for this task. </span><span class="koboSpan" id="kobo.2005.3">The presented program handles </span><code class="inlineCode"><span class="koboSpan" id="kobo.2006.1">SIGINT</span></code><span class="koboSpan" id="kobo.2007.1"> (which is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2008.1">syscall.SIGINT</span></code><span class="koboSpan" id="kobo.2009.1"> in Go) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2010.1">SIGINFO</span></code><span class="koboSpan" id="kobo.2011.1"> separately and uses a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2012.1">default</span></code><span class="koboSpan" id="kobo.2013.1"> case in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2014.1">switch</span></code><span class="koboSpan" id="kobo.2015.1"> block for handling the remaining signals. </span><span class="koboSpan" id="kobo.2015.2">The implementation of that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2016.1">switch</span></code><span class="koboSpan" id="kobo.2017.1"> block allows you to differentiate between the various signals according to your needs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2018.1">There exists a dedicated channel that receives all signals, as defined by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2019.1">signal.Notify()</span></code><span class="koboSpan" id="kobo.2020.1"> function. </span><span class="koboSpan" id="kobo.2020.2">Go channels can have a capacity—the capacity of this particular channel is 1 in order to be able to receive and keep </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2021.1">one signal at a time</span></strong><span class="koboSpan" id="kobo.2022.1">. </span><span class="koboSpan" id="kobo.2022.2">This makes perfect sense as a signal can terminate a program and there is no need to try to handle another signal at the same time. </span><span class="koboSpan" id="kobo.2022.3">There is usually an anonymous function that is executed as a goroutine and performs the signal handling and nothing else. </span><span class="koboSpan" id="kobo.2022.4">The main task of that goroutine is to listen to the channel for data. </span><span class="koboSpan" id="kobo.2022.5">Once a signal is received, it is sent to that channel, read by the goroutine, and stored into a variable—at this point, the channel can receive more signals. </span><span class="koboSpan" id="kobo.2022.6">That variable is processed by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2023.1">switch</span></code><span class="koboSpan" id="kobo.2024.1"> statement.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2025.1">Some signals cannot be caught, and the operating system cannot ignore them. </span><span class="koboSpan" id="kobo.2025.2">So, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2026.1">SIGKILL</span></code><span class="koboSpan" id="kobo.2027.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2028.1">SIGSTOP</span></code><span class="koboSpan" id="kobo.2029.1"> signals cannot be blocked, caught, or ignored; the reason for this is that they allow privileged users as well as the UNIX kernel to terminate any process they desire.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2030.1">Create a text file by typing</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.2031.1"> the following code—a good filename for it would be </span><code class="inlineCode"><span class="koboSpan" id="kobo.2032.1">signals.go</span></code><span class="koboSpan" id="kobo.2033.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2034.1">package</span></span><span class="koboSpan" id="kobo.2035.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2036.1">import</span></span><span class="koboSpan" id="kobo.2037.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2038.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2039.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2040.1">"os/signal"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2041.1">"syscall"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2042.1">"time"</span></span><span class="koboSpan" id="kobo.2043.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2044.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2045.1">handleSignal</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2046.1">(sig os.Signal)</span></span><span class="koboSpan" id="kobo.2047.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2048.1">"handleSignal() Caught:"</span></span><span class="koboSpan" id="kobo.2049.1">, sig)
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2050.1">handleSignal()</span></code><span class="koboSpan" id="kobo.2051.1"> is a separate function for handling signals. </span><span class="koboSpan" id="kobo.2051.2">However, you can also handle signals inline, in the branches of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2052.1">switch</span></code><span class="koboSpan" id="kobo.2053.1"> statement.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2054.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2055.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2056.1">()</span></span><span class="koboSpan" id="kobo.2057.1"> {
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2058.1">"Process ID: %d\n"</span></span><span class="koboSpan" id="kobo.2059.1">, os.Getpid())
    sigs := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2060.1">make</span></span><span class="koboSpan" id="kobo.2061.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2062.1">chan</span></span><span class="koboSpan" id="kobo.2063.1"> os.Signal, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2064.1">1</span></span><span class="koboSpan" id="kobo.2065.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2066.1">We create a channel with data of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2067.1">os.Signal</span></code><span class="koboSpan" id="kobo.2068.1"> because all channels must have a type.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2069.1">    signal.Notify(sigs)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2070.1">The previous statement means handling all signals that can be handled.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2071.1">    start := time.Now()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2072.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2073.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2074.1">()</span></span><span class="koboSpan" id="kobo.2075.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2076.1">for</span></span><span class="koboSpan" id="kobo.2077.1"> {
            sig := &lt;-sigs
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2078.1">Wait until you read data (&lt;-) from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2079.1">sigs</span></code><span class="koboSpan" id="kobo.2080.1"> channel and store it in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2081.1">sig</span></code><span class="koboSpan" id="kobo.2082.1"> variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2083.1">switch</span></span><span class="koboSpan" id="kobo.2084.1"> sig {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2085.1">Depending on the read value, act accordingly. </span><span class="koboSpan" id="kobo.2085.2">This is how you differentiate between signals.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2086.1">case</span></span><span class="koboSpan" id="kobo.2087.1"> syscall.SIGINT:
                duration := time.Since(start)
                fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2088.1">"Execution time:"</span></span><span class="koboSpan" id="kobo.2089.1">, duration)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2090.1">For the handling of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2091.1">syscall.SIGINT</span></code><span class="koboSpan" id="kobo.2092.1">, we calculate the time that has passed since the beginning of the program execution and print it on the screen.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2093.1">case</span></span><span class="koboSpan" id="kobo.2094.1"> syscall.SIGINFO:
                handleSignal(sig)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2095.1">The code of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2096.1">syscall.SIGINFO</span></code><span class="koboSpan" id="kobo.2097.1"> case calls</span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.2098.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2099.1">handleSignal()</span></code><span class="koboSpan" id="kobo.2100.1"> function—it is up to the developer to decide on the details of the implementation.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2101.1">On Linux machines, you should replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.2102.1">syscall.SIGINFO</span></code><span class="koboSpan" id="kobo.2103.1"> with another signal such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2104.1">syscall.SIGUSR1</span></code><span class="koboSpan" id="kobo.2105.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2106.1">syscall.SIGUSR2</span></code><span class="koboSpan" id="kobo.2107.1"> because </span><code class="inlineCode"><span class="koboSpan" id="kobo.2108.1">syscall.SIGINFO</span></code><span class="koboSpan" id="kobo.2109.1"> is not available on Linux (</span><a href="https://github.com/golang/go/issues/1653"><span class="url"><span class="koboSpan" id="kobo.2110.1">https://github.com/golang/go/issues/1653</span></span></a><span class="koboSpan" id="kobo.2111.1">).</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.2112.1">// do not use return here because the goroutine exits</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2113.1">// but the time.Sleep() will continue to work!</span></span><span class="koboSpan" id="kobo.2114.1">
                os.Exit(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2115.1">0</span></span><span class="koboSpan" id="kobo.2116.1">)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2117.1">default</span></span><span class="koboSpan" id="kobo.2118.1">:
                fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2119.1">"Caught:"</span></span><span class="koboSpan" id="kobo.2120.1">, sig)
            }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2121.1">If there is no match, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2122.1">default</span></code><span class="koboSpan" id="kobo.2123.1"> case handles the rest of the values and just prints a message.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2124.1">        }
    }()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2125.1">for</span></span><span class="koboSpan" id="kobo.2126.1"> {
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2127.1">"+"</span></span><span class="koboSpan" id="kobo.2128.1">)
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2129.1">10</span></span><span class="koboSpan" id="kobo.2130.1"> * time.Second)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2131.1">The endless for loop at the end of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2132.1">main()</span></code><span class="koboSpan" id="kobo.2133.1"> function is for emulating the operation of a real program. </span><span class="koboSpan" id="kobo.2133.2">Without an endless </span><code class="inlineCode"><span class="koboSpan" id="kobo.2134.1">for</span></code><span class="koboSpan" id="kobo.2135.1"> loop, the program exits almost immediately.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2136.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2137.1">signals.go</span></code><span class="koboSpan" id="kobo.2138.1"> and interacting with it creates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2139.1">$ </span></span><span class="koboSpan" id="kobo.2140.1">go run signals.go
Process ID: 70153
+^CExecution time: 631.533125ms
+Caught: user defined signal 1
+Caught: urgent I/O condition
+signal: killed
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2141.1">The second line of output was generated by pressing </span><em class="keystroke"><span class="koboSpan" id="kobo.2142.1">Ctrl</span></em><span class="koboSpan" id="kobo.2143.1"> + </span><em class="keystroke"><span class="koboSpan" id="kobo.2144.1">C</span></em><span class="koboSpan" id="kobo.2145.1"> on the keyboard, which, on UNIX machines, sends the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2146.1">syscall.SIGINT</span></code><span class="koboSpan" id="kobo.2147.1"> signal to the program. </span><span class="koboSpan" id="kobo.2147.2">The third line of output was caused by executing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2148.1">kill -USR1 74252</span></code><span class="koboSpan" id="kobo.2149.1"> on a different terminal. </span><span class="koboSpan" id="kobo.2149.2">The last line of the output was generated by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2150.1">kill -9 74252</span></code><span class="koboSpan" id="kobo.2151.1"> command. </span><span class="koboSpan" id="kobo.2151.2">As the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2152.1">KILL</span></code><span class="koboSpan" id="kobo.2153.1"> signal (which is also represented by the number 9) cannot</span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.2154.1"> be handled, it terminates the program, and the shell prints the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2155.1">killed</span></code><span class="koboSpan" id="kobo.2156.1"> message.</span></p>
<h2 class="heading-2" id="_idParaDest-247"><span class="koboSpan" id="kobo.2157.1">Handling two signals</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2158.1">If you want to handle a limited</span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.2159.1"> number of signals instead of all of them, you should replace the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2160.1">signal.Notify(sigs)</span></code><span class="koboSpan" id="kobo.2161.1"> statement with a statement like the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2162.1">signal.Notify(sigs, syscall.SIGINT, syscall.SIGINFO)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2163.1">After that, you need to make the appropriate changes to the code of the goroutine responsible for signal handling in order to identify and handle </span><code class="inlineCode"><span class="koboSpan" id="kobo.2164.1">syscall.SIGINT</span></code><span class="koboSpan" id="kobo.2165.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2166.1">syscall.SIGINFO</span></code><span class="koboSpan" id="kobo.2167.1">—the current version (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2168.1">signals.go</span></code><span class="koboSpan" id="kobo.2169.1">) already handles both of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2170.1">The next section talks about shared memory and shared variables, which is a very handy way of making goroutines communicate with each other with the use of channels.</span></p>
<h1 class="heading-1" id="_idParaDest-248"><span class="koboSpan" id="kobo.2171.1">Shared memory and shared variables</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2172.1">Shared memory and shared variables</span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.2173.1"> are huge</span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.2174.1"> topics in concurrent programming and the most common ways for UNIX threads to communicate with each other. </span><span class="koboSpan" id="kobo.2174.2">The same principles apply to Go and goroutines, which is what this section is about. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2175.1">A mutex variable, which is the abbreviation for a mutual exclusion variable, is mainly used for thread synchronization and for protecting shared data when multiple writes or a write and a read can occur at the same time</span></strong><span class="koboSpan" id="kobo.2176.1">. </span><span class="koboSpan" id="kobo.2176.2">A mutex works like a buffered channel with a capacity of one, which allows, at most, one goroutine to access a shared variable at any given time. </span><span class="koboSpan" id="kobo.2176.3">This means that there is no way for two or more goroutines to be able to update that variable simultaneously. </span><span class="koboSpan" id="kobo.2176.4">Go offers the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2177.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2178.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2179.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2180.1"> data types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2181.1">A </span><em class="italic"><span class="koboSpan" id="kobo.2182.1">critical section</span></em><span class="koboSpan" id="kobo.2183.1"> of a concurrent</span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.2184.1"> program is the code</span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.2185.1"> that cannot be executed simultaneously by all processes, threads, or, in this case, goroutines. </span><span class="koboSpan" id="kobo.2185.2">It is the code that needs to be protected by mutexes. </span><span class="koboSpan" id="kobo.2185.3">Therefore, identifying the critical sections of your code makes the whole programming process so much simpler that you should pay particular attention to this task. </span><span class="koboSpan" id="kobo.2185.4">A critical section cannot be embedded into another critical section when both critical sections use the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.2186.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2187.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2188.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2189.1"> variable. </span><span class="koboSpan" id="kobo.2189.2">However, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2190.1">avoid at almost any cost the spreading of mutexes across functions because that makes it really hard to see whether you are embedding or not</span></strong><span class="koboSpan" id="kobo.2191.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-249"><span class="koboSpan" id="kobo.2192.1">The sync.Mutex type</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2193.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2194.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2195.1"> type is the Go</span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.2196.1"> implementation of a mutex. </span><span class="koboSpan" id="kobo.2196.2">Its definition, which can be found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2197.1">mutex.go</span></code><span class="koboSpan" id="kobo.2198.1"> file of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2199.1">sync</span></code><span class="koboSpan" id="kobo.2200.1"> directory, is as follows (you do not need to know the definition of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2201.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2202.1"> in order to use it):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2203.1">type</span></span><span class="koboSpan" id="kobo.2204.1"> Mutex </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2205.1">struct</span></span><span class="koboSpan" id="kobo.2206.1"> {
    state </span><span class="hljs-type"><span class="koboSpan" id="kobo.2207.1">int32</span></span><span class="koboSpan" id="kobo.2208.1">
    sema  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2209.1">uint32</span></span><span class="koboSpan" id="kobo.2210.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2211.1">The definition of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2212.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2213.1"> is nothing special. </span><span class="koboSpan" id="kobo.2213.2">All of the interesting work is done by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2214.1">sync.Lock()</span></code><span class="koboSpan" id="kobo.2215.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2216.1">sync.Unlock()</span></code><span class="koboSpan" id="kobo.2217.1"> functions, which can lock and unlock a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2218.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2219.1"> variable, respectively. </span><span class="koboSpan" id="kobo.2219.2">Locking a mutex means that nobody else can lock it until it has been released using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2220.1">sync.Unlock()</span></code><span class="koboSpan" id="kobo.2221.1"> function. </span><span class="koboSpan" id="kobo.2221.2">All these are illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2222.1">mutex.go</span></code><span class="koboSpan" id="kobo.2223.1">, which contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2224.1">package</span></span><span class="koboSpan" id="kobo.2225.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2226.1">import</span></span><span class="koboSpan" id="kobo.2227.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2228.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2229.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2230.1">"strconv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2231.1">"sync"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2232.1">"time"</span></span><span class="koboSpan" id="kobo.2233.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2234.1">var</span></span><span class="koboSpan" id="kobo.2235.1"> m sync.Mutex
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2236.1">var</span></span><span class="koboSpan" id="kobo.2237.1"> v1 </span><span class="hljs-type"><span class="koboSpan" id="kobo.2238.1">int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2239.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2240.1">change</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2241.1">()</span></span><span class="koboSpan" id="kobo.2242.1"> {
    m.Lock()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2243.1">defer</span></span><span class="koboSpan" id="kobo.2244.1"> m.Unlock()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2245.1">This function makes changes to the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2246.1">v1</span></code><span class="koboSpan" id="kobo.2247.1">. </span><span class="koboSpan" id="kobo.2247.2">The critical section begins here.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2248.1">    time.Sleep(time.Second)
    v1 = v1 + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2249.1">1</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2250.1">if</span></span><span class="koboSpan" id="kobo.2251.1"> v1 == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2252.1">10</span></span><span class="koboSpan" id="kobo.2253.1"> {
        v1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2254.1">0</span></span><span class="koboSpan" id="kobo.2255.1">
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2256.1">"* "</span></span><span class="koboSpan" id="kobo.2257.1">)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2258.1">This is the end of the critical section. </span><span class="koboSpan" id="kobo.2258.2">Now, another goroutine can lock the mutex.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2259.1">}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2260.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2261.1">read</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2262.1">()</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2263.1">int</span></span><span class="koboSpan" id="kobo.2264.1"> {
    m.Lock()
    a := v1
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2265.1">defer</span></span><span class="koboSpan" id="kobo.2266.1"> m.Unlock()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2267.1">return</span></span><span class="koboSpan" id="kobo.2268.1"> a
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2269.1">This function is used for reading the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2270.1">v1</span></code><span class="koboSpan" id="kobo.2271.1">—therefore, it should use a mutex to make the process concurrently safe. </span><span class="koboSpan" id="kobo.2271.2">Most specifically, we want to make sure that nobody is going to change the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2272.1">v1</span></code><span class="koboSpan" id="kobo.2273.1"> while we are reading it. </span><span class="koboSpan" id="kobo.2273.2">The rest of the program contains the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2274.1">main()</span></code><span class="koboSpan" id="kobo.2275.1"> function—feel free to see the entire code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2276.1">mutex.go</span></code><span class="koboSpan" id="kobo.2277.1"> in the GitHub repository of the book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2278.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2279.1">mutex.go</span></code><span class="koboSpan" id="kobo.2280.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2281.1">$ </span></span><span class="koboSpan" id="kobo.2282.1">go run -race mutex.go 10
0 -&gt; 1-&gt; 2-&gt; 3-&gt; 4-&gt; 5-&gt; 6-&gt; 7-&gt; 8-&gt; 9* -&gt; 0-&gt; 0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2283.1">The previous output shows that due to the use of a mutex, goroutines cannot access shared data and, therefore, there</span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.2284.1"> are no hidden race conditions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2285.1">The next subsection shows what could happen if we forget to unlock a mutex.</span></p>
<h2 class="heading-2" id="_idParaDest-250"><span class="koboSpan" id="kobo.2286.1">What happens if you forget to unlock a mutex?</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2287.1">Forgetting to unlock</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.2288.1"> a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2289.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2290.1"> mutex creates a panic situation, even in the simplest kind of a program. </span><span class="koboSpan" id="kobo.2290.2">The same applies to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2291.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2292.1"> mutex, which is presented in the next section. </span><span class="koboSpan" id="kobo.2292.2">Let us now see a code example to understand this unpleasant situation a lot better—this is part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2293.1">forgetMutex.go</span></code><span class="koboSpan" id="kobo.2294.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2295.1">var</span></span><span class="koboSpan" id="kobo.2296.1"> m sync.Mutex
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2297.1">var</span></span><span class="koboSpan" id="kobo.2298.1"> w sync.WaitGroup
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2299.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2300.1">function</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2301.1">()</span></span><span class="koboSpan" id="kobo.2302.1"> {
    m.Lock()
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2303.1">"Locked!"</span></span><span class="koboSpan" id="kobo.2304.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2305.1">Here, we lock a mutex without releasing it afterward. </span><span class="koboSpan" id="kobo.2305.2">This means that if we run </span><code class="inlineCode"><span class="koboSpan" id="kobo.2306.1">function()</span></code><span class="koboSpan" id="kobo.2307.1"> as a goroutine more than once, all instances after the first one are going to be blocked waiting to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2308.1">Lock()</span></code><span class="koboSpan" id="kobo.2309.1"> the shared mutex. </span><span class="koboSpan" id="kobo.2309.2">In our case, we run two goroutines—feel free to see the entire code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2310.1">forgetMutex.go</span></code><span class="koboSpan" id="kobo.2311.1"> for more details. </span><span class="koboSpan" id="kobo.2311.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2312.1">forgetMutex.go</span></code><span class="koboSpan" id="kobo.2313.1"> generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2314.1">Locked!
</span><span class="koboSpan" id="kobo.2314.2">fatal error: all goroutines are asleep - deadlock!
</span><span class="koboSpan" id="kobo.2314.3">goroutine 1 [semacquire]:
sync.runtime_Semacquire(0x140000021a0?)
    /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/sema.go:62 +0x2c
sync.(*WaitGroup).Wait(0x100fa1710)
    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/waitgroup.go:116 +0x74
main.main()
    ~/go/src/github.com/mactsouk/mGo4th/ch08/forgetMutex.go:29 +0x5c
goroutine 34 [sync.Mutex.Lock]:
sync.runtime_SemacquireMutex(0x0?, 0x0?, 0x0?)
    /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/sema.go:77 +0x28
sync.(*Mutex).lockSlow(0x100fa1520)
    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/mutex.go:171 +0x174
sync.(*Mutex).Lock(...)
    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/mutex.go:90
main.function()
    ~/go/src/github.com/mactsouk/mGo4th/ch08/forgetMutex.go:12 +0x84
main.main.func1()
    ~/go/src/github.com/mactsouk/mGo4th/ch08/forgetMutex.go:20 +0x50
created by main.main in goroutine 1
    ~/go/src/github.com/mactsouk/mGo4th/ch08/forgetMutex.go:18 +0x34
exit status 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2315.1">As expected, the program crashes because of the deadlock. </span><span class="koboSpan" id="kobo.2315.2">To avoid such situations, always remember to unlock any mutexes</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.2316.1"> created in your program as soon as possible.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2317.1">Let us now discuss </span><code class="inlineCode"><span class="koboSpan" id="kobo.2318.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2319.1">, which is an improved version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2320.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2321.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-251"><span class="koboSpan" id="kobo.2322.1">The sync.RWMutex type</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2323.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2324.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2325.1"> data type</span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.2326.1"> is an improved version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2327.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2328.1"> and is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2329.1">rwmutex.go</span></code><span class="koboSpan" id="kobo.2330.1"> file of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2331.1">sync</span></code><span class="koboSpan" id="kobo.2332.1"> directory of the Go Standard library as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2333.1">type</span></span><span class="koboSpan" id="kobo.2334.1"> RWMutex </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2335.1">struct</span></span><span class="koboSpan" id="kobo.2336.1"> {
    w           Mutex
    writerSem   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2337.1">uint32</span></span><span class="koboSpan" id="kobo.2338.1">
    readerSem   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2339.1">uint32</span></span><span class="koboSpan" id="kobo.2340.1">
    readerCount </span><span class="hljs-type"><span class="koboSpan" id="kobo.2341.1">int32</span></span><span class="koboSpan" id="kobo.2342.1">
    readerWait  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2343.1">int32</span></span><span class="koboSpan" id="kobo.2344.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2345.1">In other words, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2346.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2347.1"> is based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.2348.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2349.1"> with the necessary additions and improvements. </span><span class="koboSpan" id="kobo.2349.2">So, you might ask, how does </span><code class="inlineCode"><span class="koboSpan" id="kobo.2350.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2351.1"> improve </span><code class="inlineCode"><span class="koboSpan" id="kobo.2352.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2353.1">? </span><span class="koboSpan" id="kobo.2353.2">Although a single function is allowed to perform write operations with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2354.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2355.1"> mutex, you can have multiple readers owning a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2356.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2357.1"> mutex—this means that read operations are usually faster with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2358.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2359.1">. </span><span class="koboSpan" id="kobo.2359.2">However, there is one important detail that you should be aware of: until all of the readers of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2360.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2361.1"> mutex unlock it, you cannot lock it for writing, which is the small price you have to pay for the performance improvement you get for allowing multiple readers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2362.1">The functions that can help you work with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2363.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2364.1"> are </span><code class="inlineCode"><span class="koboSpan" id="kobo.2365.1">RLock()</span></code><span class="koboSpan" id="kobo.2366.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2367.1">RUnlock()</span></code><span class="koboSpan" id="kobo.2368.1">, which are used for locking and unlocking the mutex for reading purposes, respectively. </span><span class="koboSpan" id="kobo.2368.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2369.1">Lock()</span></code><span class="koboSpan" id="kobo.2370.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2371.1">Unlock()</span></code><span class="koboSpan" id="kobo.2372.1"> functions used in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2373.1">sync.Mutex</span></code><span class="koboSpan" id="kobo.2374.1"> should still be used when you want to lock and unlock a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2375.1">sync.RWMutex</span></code><span class="koboSpan" id="kobo.2376.1"> mutex for writing purposes. </span><span class="koboSpan" id="kobo.2376.2">Finally, it should be apparent that you should not make changes to any shared variables inside an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2377.1">RLock()</span></code><span class="koboSpan" id="kobo.2378.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2379.1">RUnlock()</span></code><span class="koboSpan" id="kobo.2380.1"> block of code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2381.1">All these are illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2382.1">rwMutex.go</span></code><span class="koboSpan" id="kobo.2383.1">—the important code is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2384.1">var</span></span><span class="koboSpan" id="kobo.2385.1"> Password *secret
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2386.1">var</span></span><span class="koboSpan" id="kobo.2387.1"> wg sync.WaitGroup
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2388.1">type</span></span><span class="koboSpan" id="kobo.2389.1"> secret </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2390.1">struct</span></span><span class="koboSpan" id="kobo.2391.1"> {
    RWM      sync.RWMutex
    password </span><span class="hljs-type"><span class="koboSpan" id="kobo.2392.1">string</span></span><span class="koboSpan" id="kobo.2393.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2394.1">This is the shared variable</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.2395.1"> of the program—you can share any type of variable you want.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2396.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2397.1">Change</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2398.1">(pass </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2399.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2400.1">)</span></span><span class="koboSpan" id="kobo.2401.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2402.1">if</span></span><span class="koboSpan" id="kobo.2403.1"> Password == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2404.1">nil</span></span><span class="koboSpan" id="kobo.2405.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2406.1">"Password is nil!"</span></span><span class="koboSpan" id="kobo.2407.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2408.1">return</span></span><span class="koboSpan" id="kobo.2409.1">
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2410.1">"Change() function"</span></span><span class="koboSpan" id="kobo.2411.1">)
    Password.RWM.Lock()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2412.1">This is the beginning of the critical section.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2413.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2414.1">"Change() Locked"</span></span><span class="koboSpan" id="kobo.2415.1">)
    time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2416.1">4</span></span><span class="koboSpan" id="kobo.2417.1"> * time.Second)
    Password.password = pass
    Password.RWM.Unlock()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2418.1">This is the end of the critical section.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2419.1">    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2420.1">"Change() UnLocked"</span></span><span class="koboSpan" id="kobo.2421.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2422.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2423.1">Change()</span></code><span class="koboSpan" id="kobo.2424.1"> function makes changes to the shared variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.2425.1">Password</span></code><span class="koboSpan" id="kobo.2426.1"> and, therefore, needs to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2427.1">Lock()</span></code><span class="koboSpan" id="kobo.2428.1"> function, which can be held by a single writer only.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2429.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2430.1">show</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.2431.1">()</span></span><span class="koboSpan" id="kobo.2432.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2433.1">defer</span></span><span class="koboSpan" id="kobo.2434.1"> wg.Done()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2435.1">defer</span></span><span class="koboSpan" id="kobo.2436.1"> Password.RWM.RUnlock()
    Password.RWM.RLock()
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2437.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2438.1">Show function locked!"</span></span><span class="koboSpan" id="kobo.2439.1">)
    time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2440.1">2</span></span><span class="koboSpan" id="kobo.2441.1"> * time.Second)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2442.1">"Pass value:"</span></span><span class="koboSpan" id="kobo.2443.1">, Password.password)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2444.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2445.1">show()</span></code><span class="koboSpan" id="kobo.2446.1"> function reads</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.2447.1"> the shared variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.2448.1">Password</span></code><span class="koboSpan" id="kobo.2449.1"> and therefore it is allowed to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2450.1">RLock()</span></code><span class="koboSpan" id="kobo.2451.1"> function, which can be held by multiple readers. </span><span class="koboSpan" id="kobo.2451.2">Inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.2452.1">main()</span></code><span class="koboSpan" id="kobo.2453.1">, three </span><code class="inlineCode"><span class="koboSpan" id="kobo.2454.1">show()</span></code><span class="koboSpan" id="kobo.2455.1"> functions are executed as goroutines before a call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2456.1">Change()</span></code><span class="koboSpan" id="kobo.2457.1"> function, which also runs as a goroutine. </span><span class="koboSpan" id="kobo.2457.2">The key point here is that no race conditions are going to happen. </span><span class="koboSpan" id="kobo.2457.3">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2458.1">rwMutex.go</span></code><span class="koboSpan" id="kobo.2459.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2460.1">$ </span></span><span class="koboSpan" id="kobo.2461.1">go run rwMutex.go
Change() function
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2462.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2463.1">Change()</span></code><span class="koboSpan" id="kobo.2464.1"> function is executed but cannot acquire the mutex because it is already taken by one or more </span><code class="inlineCode"><span class="koboSpan" id="kobo.2465.1">show()</span></code><span class="koboSpan" id="kobo.2466.1"> goroutines.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2467.1">Show function locked!
</span><span class="koboSpan" id="kobo.2467.2">Show function locked!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2468.1">The previous output verifies that two </span><code class="inlineCode"><span class="koboSpan" id="kobo.2469.1">show()</span></code><span class="koboSpan" id="kobo.2470.1"> goroutines have successfully taken the mutex for reading.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2471.1">Change() function
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2472.1">Here, we can see a second </span><code class="inlineCode"><span class="koboSpan" id="kobo.2473.1">Change()</span></code><span class="koboSpan" id="kobo.2474.1"> function running and waiting to get the mutex.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2475.1">Pass value: myPass
Pass value: myPass
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2476.1">This is the output from the two </span><code class="inlineCode"><span class="koboSpan" id="kobo.2477.1">show()</span></code><span class="koboSpan" id="kobo.2478.1"> goroutines.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2479.1">Change() Locked
Change() UnLocked
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2480.1">Here we see that one </span><code class="inlineCode"><span class="koboSpan" id="kobo.2481.1">Change()</span></code><span class="koboSpan" id="kobo.2482.1"> goroutine finishes its job.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2483.1">Show function locked!
</span><span class="koboSpan" id="kobo.2483.2">Pass value: 54321
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2484.1">After that another </span><code class="inlineCode"><span class="koboSpan" id="kobo.2485.1">show()</span></code><span class="koboSpan" id="kobo.2486.1"> goroutine finishes.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2487.1">Change() Locked
Change() UnLocked
Current password value: 123456
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2488.1">Lastly, the second </span><code class="inlineCode"><span class="koboSpan" id="kobo.2489.1">Change()</span></code><span class="koboSpan" id="kobo.2490.1"> goroutine finishes. </span><span class="koboSpan" id="kobo.2490.2">The last output line is for making sure that the password value has changed—please look at the full code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2491.1">rwMutex.go</span></code><span class="koboSpan" id="kobo.2492.1"> for more details.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2493.1">Bear in mind that the output you are going to get might be different due to the way the scheduler works. </span><span class="koboSpan" id="kobo.2493.2">This is the nature of concurrent programming and these programs do not have any mechanism</span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.2494.1"> to ensure the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2495.1">show()</span></code><span class="koboSpan" id="kobo.2496.1"> function should be scheduled first.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2497.1">The next subsection discusses the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2498.1">atomic</span></code><span class="koboSpan" id="kobo.2499.1"> package for avoiding race conditions.</span></p>
<h2 class="heading-2" id="_idParaDest-252"><span class="koboSpan" id="kobo.2500.1">The atomic package</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2501.1">An atomic operation is an operation</span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.2502.1"> that is completed in a single step relative to other threads or, in this case, to other goroutines. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2503.1">This means that an atomic operation cannot be interrupted in the middle of it.</span></strong><span class="koboSpan" id="kobo.2504.1"> The Go Standard library offers the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2505.1">atomic</span></code><span class="koboSpan" id="kobo.2506.1"> package, which, in some simple cases, can help you avoid using a mutex. </span><span class="koboSpan" id="kobo.2506.2">With the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2507.1">atomic</span></code><span class="koboSpan" id="kobo.2508.1"> package, you can have atomic counters accessed by multiple goroutines without synchronization issues and without worrying about race conditions. </span><span class="koboSpan" id="kobo.2508.2">However, mutexes are more versatile than atomic operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2509.1">As illustrated in the code that follows, when using an atomic variable, all reading and writing operations of an atomic variable must be done using the functions provided by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2510.1">atomic</span></code><span class="koboSpan" id="kobo.2511.1"> package in order to avoid race conditions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2512.1">The code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2513.1">atomic.go</span></code><span class="koboSpan" id="kobo.2514.1"> is as follows, which is made smaller by hardcoding some values:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2515.1">package</span></span><span class="koboSpan" id="kobo.2516.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2517.1">import</span></span><span class="koboSpan" id="kobo.2518.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2519.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2520.1">"sync"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2521.1">"sync/atomic"</span></span><span class="koboSpan" id="kobo.2522.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2523.1">type</span></span><span class="koboSpan" id="kobo.2524.1"> atomCounter </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2525.1">struct</span></span><span class="koboSpan" id="kobo.2526.1"> {
    val </span><span class="hljs-type"><span class="koboSpan" id="kobo.2527.1">int64</span></span><span class="koboSpan" id="kobo.2528.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2529.1">This is a structure for holding the desired </span><code class="inlineCode"><span class="koboSpan" id="kobo.2530.1">int64</span></code><span class="koboSpan" id="kobo.2531.1"> atomic variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2532.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.2533.1">(c *atomCounter)</span></span><span class="koboSpan" id="kobo.2534.1"> Value() </span><span class="hljs-type"><span class="koboSpan" id="kobo.2535.1">int64</span></span><span class="koboSpan" id="kobo.2536.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2537.1">return</span></span><span class="koboSpan" id="kobo.2538.1"> atomic.LoadInt64(&amp;c.val)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2539.1">This is a helper function that returns the current value of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2540.1">int64</span></code><span class="koboSpan" id="kobo.2541.1"> atomic variable using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2542.1">atomic.LoadInt64()</span></code><span class="koboSpan" id="kobo.2543.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2544.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2545.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2546.1">()</span></span><span class="koboSpan" id="kobo.2547.1"> {
    X := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2548.1">100</span></span><span class="koboSpan" id="kobo.2549.1">
    Y := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2550.1">4</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2551.1">var</span></span><span class="koboSpan" id="kobo.2552.1"> waitGroup sync.WaitGroup
    counter := atomCounter{}
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2553.1">for</span></span><span class="koboSpan" id="kobo.2554.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2555.1">0</span></span><span class="koboSpan" id="kobo.2556.1">; i &lt; X; i++ {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2557.1">We are creating lots of goroutines</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.2558.1"> that change the shared variable—as stated before, the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2559.1">atomic</span></code><span class="koboSpan" id="kobo.2560.1"> package for working with the shared variable offers a simple way of avoiding race conditions when changing the value of the shared variable.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2561.1">        waitGroup.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2562.1">1</span></span><span class="koboSpan" id="kobo.2563.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2564.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2565.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2566.1">()</span></span><span class="koboSpan" id="kobo.2567.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2568.1">defer</span></span><span class="koboSpan" id="kobo.2569.1"> waitGroup.Done()
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2570.1">for</span></span><span class="koboSpan" id="kobo.2571.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2572.1">0</span></span><span class="koboSpan" id="kobo.2573.1">; i &lt; Y; i++ {
                atomic.AddInt64(&amp;counter.val, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2574.1">1</span></span><span class="koboSpan" id="kobo.2575.1">)
            }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2576.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2577.1">atomic.AddInt64()</span></code><span class="koboSpan" id="kobo.2578.1"> function changes the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2579.1">val</span></code><span class="koboSpan" id="kobo.2580.1"> field of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2581.1">counter</span></code><span class="koboSpan" id="kobo.2582.1"> structure variable in a safe way.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2583.1">        }()
    }
    waitGroup.Wait()
    fmt.Println(counter.Value())
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2584.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2585.1">atomic.go</span></code><span class="koboSpan" id="kobo.2586.1"> while checking for race conditions produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2587.1">$ </span></span><span class="koboSpan" id="kobo.2588.1">go run -race atomic.go
400
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2589.1">So, the atomic variable is modified </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.2590.1">by multiple goroutines without any issues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2591.1">The next subsection shows how to share memory using goroutines.</span></p>
<h2 class="heading-2" id="_idParaDest-253"><span class="koboSpan" id="kobo.2592.1">Sharing memory using goroutines</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2593.1">This subsection illustrates</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.2594.1"> how to share</span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.2595.1"> data using a dedicated goroutine. </span><span class="koboSpan" id="kobo.2595.2">Although shared memory is the traditional way that threads communicate with each other, Go comes with built-in synchronization features that allow a single goroutine to own a shared piece of data. </span><span class="koboSpan" id="kobo.2595.3">This means that other goroutines must send messages to this single goroutine that owns the shared data, which prevents the corruption of the data. </span><span class="koboSpan" id="kobo.2595.4">Such</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.2596.1"> a goroutine is called a monitor goroutine. </span><span class="koboSpan" id="kobo.2596.2">In Go terminology, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2597.1">this is sharing by communicating instead of communicating by sharing</span></strong><span class="koboSpan" id="kobo.2598.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2599.1">Personally, I prefer to use a monitor goroutine instead of traditional shared memory techniques because the implementation with the monitor goroutine is safer, closer to the Go philosophy, and easier to understand.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2600.1">The logic of the program can be found in the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2601.1">monitor()</span></code><span class="koboSpan" id="kobo.2602.1"> function. </span><span class="koboSpan" id="kobo.2602.2">More specifically, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2603.1">select</span></code><span class="koboSpan" id="kobo.2604.1"> statement orchestrates the operation of the entire program. </span><span class="koboSpan" id="kobo.2604.2">When you have a read request, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2605.1">read()</span></code><span class="koboSpan" id="kobo.2606.1"> function attempts to read from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2607.1">readValue</span></code><span class="koboSpan" id="kobo.2608.1"> channel, which is controlled by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2609.1">monitor()</span></code><span class="koboSpan" id="kobo.2610.1"> function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2611.1">This returns the current value of the value variable. </span><span class="koboSpan" id="kobo.2611.2">On the other hand, when you want to change the stored value, you call </span><code class="inlineCode"><span class="koboSpan" id="kobo.2612.1">set()</span></code><span class="koboSpan" id="kobo.2613.1">. </span><span class="koboSpan" id="kobo.2613.2">This writes to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2614.1">writeValue</span></code><span class="koboSpan" id="kobo.2615.1"> channel, which is also handled by the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.2616.1">select</span></code><span class="koboSpan" id="kobo.2617.1"> statement. </span><span class="koboSpan" id="kobo.2617.2">As a result, no one can deal with the shared variable without using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2618.1">monitor()</span></code><span class="koboSpan" id="kobo.2619.1"> function, which is in charge.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2620.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2621.1">monitor.go</span></code><span class="koboSpan" id="kobo.2622.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2623.1">package</span></span><span class="koboSpan" id="kobo.2624.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2625.1">import</span></span><span class="koboSpan" id="kobo.2626.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2627.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2628.1">"math/rand"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2629.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2630.1">"strconv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2631.1">"sync"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2632.1">"time"</span></span><span class="koboSpan" id="kobo.2633.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2634.1">var</span></span><span class="koboSpan" id="kobo.2635.1"> readValue = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2636.1">make</span></span><span class="koboSpan" id="kobo.2637.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2638.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2639.1">int</span></span><span class="koboSpan" id="kobo.2640.1">)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2641.1">var</span></span><span class="koboSpan" id="kobo.2642.1"> writeValue = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2643.1">make</span></span><span class="koboSpan" id="kobo.2644.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2645.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2646.1">int</span></span><span class="koboSpan" id="kobo.2647.1">)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2648.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2649.1">set</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2650.1">(newValue </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2651.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2652.1">)</span></span><span class="koboSpan" id="kobo.2653.1"> {
    writeValue &lt;- newValue
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2654.1">This function sends data to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2655.1">writeValue</span></code><span class="koboSpan" id="kobo.2656.1"> channel.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2657.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2658.1">read</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2659.1">()</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2660.1">int</span></span><span class="koboSpan" id="kobo.2661.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2662.1">return</span></span><span class="koboSpan" id="kobo.2663.1"> &lt;-readValue
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2664.1">When the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2665.1">read()</span></code><span class="koboSpan" id="kobo.2666.1"> function is called, it reads from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2667.1">readValue</span></code><span class="koboSpan" id="kobo.2668.1"> channel—this reading happens inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2669.1">monitor()</span></code><span class="koboSpan" id="kobo.2670.1"> function.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2671.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2672.1">monitor</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2673.1">()</span></span><span class="koboSpan" id="kobo.2674.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2675.1">var</span></span><span class="koboSpan" id="kobo.2676.1"> value </span><span class="hljs-type"><span class="koboSpan" id="kobo.2677.1">int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2678.1">for</span></span><span class="koboSpan" id="kobo.2679.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2680.1">select</span></span><span class="koboSpan" id="kobo.2681.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2682.1">case</span></span><span class="koboSpan" id="kobo.2683.1"> newValue := &lt;-writeValue:
            value = newValue
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2684.1">"%d "</span></span><span class="koboSpan" id="kobo.2685.1">, value)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2686.1">case</span></span><span class="koboSpan" id="kobo.2687.1"> readValue &lt;- value:
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2688.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2689.1">monitor()</span></code><span class="koboSpan" id="kobo.2690.1"> function contains the logic </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.2691.1">of the program</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.2692.1"> with the endless </span><code class="inlineCode"><span class="koboSpan" id="kobo.2693.1">for</span></code><span class="koboSpan" id="kobo.2694.1"> loop and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2695.1">select</span></code><span class="koboSpan" id="kobo.2696.1"> statement. </span><span class="koboSpan" id="kobo.2696.2">The first case receives data from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2697.1">writeValue</span></code><span class="koboSpan" id="kobo.2698.1"> channel, sets the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2699.1">value</span></code><span class="koboSpan" id="kobo.2700.1"> variable accordingly, and prints that new value. </span><span class="koboSpan" id="kobo.2700.2">The second case sends the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2701.1">value</span></code><span class="koboSpan" id="kobo.2702.1"> variable to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2703.1">readValue</span></code><span class="koboSpan" id="kobo.2704.1"> channel. </span><span class="koboSpan" id="kobo.2704.2">As all traffic goes through </span><code class="inlineCode"><span class="koboSpan" id="kobo.2705.1">monitor()</span></code><span class="koboSpan" id="kobo.2706.1"> and its </span><code class="inlineCode"><span class="koboSpan" id="kobo.2707.1">select</span></code><span class="koboSpan" id="kobo.2708.1"> block, there is no way to have a race condition because there is a single instance of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2709.1">monitor()</span></code><span class="koboSpan" id="kobo.2710.1"> running.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2711.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2712.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2713.1">()</span></span><span class="koboSpan" id="kobo.2714.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2715.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2716.1">len</span></span><span class="koboSpan" id="kobo.2717.1">(os.Args) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.2718.1">2</span></span><span class="koboSpan" id="kobo.2719.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2720.1">"Please give an integer!"</span></span><span class="koboSpan" id="kobo.2721.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2722.1">return</span></span><span class="koboSpan" id="kobo.2723.1">
    }
    n, err := strconv.Atoi(os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2724.1">1</span></span><span class="koboSpan" id="kobo.2725.1">])
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2726.1">if</span></span><span class="koboSpan" id="kobo.2727.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2728.1">nil</span></span><span class="koboSpan" id="kobo.2729.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2730.1">return</span></span><span class="koboSpan" id="kobo.2731.1">
    }
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2732.1">"Going to create %d random numbers.\n"</span></span><span class="koboSpan" id="kobo.2733.1">, n)
    rand.Seed(time.Now().Unix())
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2734.1">go</span></span><span class="koboSpan" id="kobo.2735.1"> monitor()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2736.1">It is important that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2737.1">monitor()</span></code><span class="koboSpan" id="kobo.2738.1"> function is executed first because that is the goroutine that orchestrates the flow of the program.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2739.1">var</span></span><span class="koboSpan" id="kobo.2740.1"> wg sync.WaitGroup
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2741.1">for</span></span><span class="koboSpan" id="kobo.2742.1"> r := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2743.1">0</span></span><span class="koboSpan" id="kobo.2744.1">; r &lt; n; r++ {
        wg.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2745.1">1</span></span><span class="koboSpan" id="kobo.2746.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2747.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2748.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2749.1">()</span></span><span class="koboSpan" id="kobo.2750.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2751.1">defer</span></span><span class="koboSpan" id="kobo.2752.1"> wg.Done()
            set(rand.Intn(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2753.1">10</span></span><span class="koboSpan" id="kobo.2754.1"> * n))
        }()
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2755.1">When the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2756.1">for</span></code><span class="koboSpan" id="kobo.2757.1"> loop ends, it means that we have created the desired number of random numbers.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2758.1">    wg.Wait()
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2759.1">"\nLast value: %d\n"</span></span><span class="koboSpan" id="kobo.2760.1">, read())
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2761.1">Lastly, we wait for all </span><code class="inlineCode"><span class="koboSpan" id="kobo.2762.1">set()</span></code><span class="koboSpan" id="kobo.2763.1"> goroutines to finish before printing the last random number.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2764.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2765.1">monitor.go</span></code><span class="koboSpan" id="kobo.2766.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2767.1">$ </span></span><span class="koboSpan" id="kobo.2768.1">go run monitor.go 10
Going to create 10 random numbers.
</span><span class="koboSpan" id="kobo.2768.2">98 22 5 84 20 26 45 36 0 16 
Last value: 16
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2769.1">So, 10 random numbers are created by 10 goroutines and all these goroutines send their output to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2770.1">monitor()</span></code><span class="koboSpan" id="kobo.2771.1"> function, which is also executed as a goroutine. </span><span class="koboSpan" id="kobo.2771.2">Apart from receiving the results, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2772.1">monitor()</span></code><span class="koboSpan" id="kobo.2773.1"> function</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.2774.1"> prints them on the screen, so all this output</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.2775.1"> is generated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2776.1">monitor()</span></code><span class="koboSpan" id="kobo.2777.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2778.1">The next section discusses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2779.1">go</span></code><span class="koboSpan" id="kobo.2780.1"> statement in more detail.</span></p>
<h1 class="heading-1" id="_idParaDest-254"><span class="koboSpan" id="kobo.2781.1">Closured variables and the go statement</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2782.1">In this section, we are going</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.2783.1"> to talk about</span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.2784.1"> closured variables, which are variables inside closures, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2785.1">go</span></code><span class="koboSpan" id="kobo.2786.1"> statement. </span><span class="koboSpan" id="kobo.2786.2">Notice that closured variables in goroutines are evaluated when the goroutine actually runs and when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2787.1">go</span></code><span class="koboSpan" id="kobo.2788.1"> statement is executed in order to create a new goroutine. </span><span class="koboSpan" id="kobo.2788.2">This means that closured variables are going to be replaced by their values when the Go scheduler decides to execute the relevant code. </span><span class="koboSpan" id="kobo.2788.3">This is illustrated in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2789.1">main()</span></code><span class="koboSpan" id="kobo.2790.1"> function of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2791.1">goClosure.go</span></code><span class="koboSpan" id="kobo.2792.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2793.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2794.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2795.1">()</span></span><span class="koboSpan" id="kobo.2796.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2797.1">for</span></span><span class="koboSpan" id="kobo.2798.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2799.1">0</span></span><span class="koboSpan" id="kobo.2800.1">; i &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2801.1">20</span></span><span class="koboSpan" id="kobo.2802.1">; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2803.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2804.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2805.1">()</span></span><span class="koboSpan" id="kobo.2806.1"> {
            fmt.Print(i, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2807.1">" "</span></span><span class="koboSpan" id="kobo.2808.1">)
        }()
    }
    time.Sleep(time.Second)
    fmt.Println()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2809.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2810.1">goClosure.go</span></code><span class="koboSpan" id="kobo.2811.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2812.1">$ </span></span><span class="koboSpan" id="kobo.2813.1">go run goClosure.go 
3 7 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2814.1">The program mostly prints</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.2815.1"> the number 21, which</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.2816.1"> is the last value of the variable of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2817.1">for</span></code><span class="koboSpan" id="kobo.2818.1"> loop, and not the other numbers. </span><span class="koboSpan" id="kobo.2818.2">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.2819.1">i</span></code><span class="koboSpan" id="kobo.2820.1"> is a closured variable, it is evaluated at the time of execution. </span><span class="koboSpan" id="kobo.2820.2">As the goroutines begin but wait for the Go scheduler to allow them to get executed, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2821.1">for</span></code><span class="koboSpan" id="kobo.2822.1"> loop ends, so the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2823.1">i</span></code><span class="koboSpan" id="kobo.2824.1"> that is being used is 21. </span><span class="koboSpan" id="kobo.2824.2">Lastly, the same issue also applies to Go channels, so be careful.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2825.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2826.1">goClosure.go</span></code><span class="koboSpan" id="kobo.2827.1"> with the Go race detector reveals the issue:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2828.1">$ </span></span><span class="koboSpan" id="kobo.2829.1">go run -race goClosure.go
5 4 5 5 ==================
WARNING: DATA RACE
Read at 0x00c00011e028 by goroutine 6:
  main.main.func1()
      ~/go/src/github.com/mactsouk/mGo4th/ch08/goClosure.go:11 +0x34
Previous write at 0x00c00011e028 by main goroutine:
  main.main()
      ~/go/src/github.com/mactsouk/mGo4th/ch08/goClosure.go:9 +0x5c
Goroutine 6 (running) created at:
  main.main()
      ~/go/src/github.com/mactsouk/mGo4th/ch08/goClosure.go:10 +0x44
==================
8 8 6 10 12 11 15 15 15 18 20 20 21 15 21 21 21
Found 1 data race(s)
exit status 66
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2830.1">Now, let us correct </span><code class="inlineCode"><span class="koboSpan" id="kobo.2831.1">goClosure.go</span></code><span class="koboSpan" id="kobo.2832.1"> and present it to you—the new name is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2833.1">goClosureCorrect.go</span></code><span class="koboSpan" id="kobo.2834.1"> and its </span><code class="inlineCode"><span class="koboSpan" id="kobo.2835.1">main()</span></code><span class="koboSpan" id="kobo.2836.1"> function is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2837.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2838.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2839.1">()</span></span><span class="koboSpan" id="kobo.2840.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2841.1">for</span></span><span class="koboSpan" id="kobo.2842.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2843.1">0</span></span><span class="koboSpan" id="kobo.2844.1">; i &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2845.1">20</span></span><span class="koboSpan" id="kobo.2846.1">; i++ {
        i := i
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2847.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2848.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2849.1">()</span></span><span class="koboSpan" id="kobo.2850.1"> {
            fmt.Print(i, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2851.1">" "</span></span><span class="koboSpan" id="kobo.2852.1">)
        }()
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2853.1">This is one way of correcting</span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.2854.1"> the issue. </span><span class="koboSpan" id="kobo.2854.2">The valid</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.2855.1"> yet bizarre </span><code class="inlineCode"><span class="koboSpan" id="kobo.2856.1">i := i</span></code><span class="koboSpan" id="kobo.2857.1"> statement creates a new instance of the variable for the goroutine that holds the correct value. </span><span class="koboSpan" id="kobo.2857.2">Although this is a valid approach, this kind of variable shadowing is not considered a good practice.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2858.1">Variable shadowing in Go occurs when a variable</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.2859.1"> declared in a nested scope has the same name as a variable in an outer scope. </span><span class="koboSpan" id="kobo.2859.2">While variable shadowing can be intentional and useful in certain situations, it can also lead to confusion and introduce subtle bugs. </span><span class="koboSpan" id="kobo.2859.3">In practice, it is recommended to avoid unnecessary variable shadowing and choose meaningful variable names that minimize the likelihood of unintentional shadowing.</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2860.1">    time.Sleep(time.Second)
    fmt.Println()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2861.1">for</span></span><span class="koboSpan" id="kobo.2862.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2863.1">0</span></span><span class="koboSpan" id="kobo.2864.1">; i &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2865.1">20</span></span><span class="koboSpan" id="kobo.2866.1">; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2867.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2868.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2869.1">(x </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2870.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2871.1">)</span></span><span class="koboSpan" id="kobo.2872.1"> {
            fmt.Print(x, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2873.1">" "</span></span><span class="koboSpan" id="kobo.2874.1">)
        }(i)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2875.1">This is a totally different way of correcting the race condition: pass the current value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2876.1">i</span></code><span class="koboSpan" id="kobo.2877.1"> to the anonymous function as a parameter and everything is OK. </span><span class="koboSpan" id="kobo.2877.2">As explained in </span><em class="chapterRef"><span class="koboSpan" id="kobo.2878.1">Chapter 15</span></em><span class="koboSpan" id="kobo.2879.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2880.1">Changes in Recent Go Versions</span></em><span class="koboSpan" id="kobo.2881.1">, this issue does not exist in Go 1.22.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2882.1">    time.Sleep(time.Second)
    fmt.Println()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2883.1">Testing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2884.1">goClosureCorrect.go</span></code><span class="koboSpan" id="kobo.2885.1"> with</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.2886.1"> the race detector generates the expected</span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.2887.1"> output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2888.1">$ </span></span><span class="koboSpan" id="kobo.2889.1">go run -race goClosureCorrect.go
0 1 2 4 3 5 6 9 8 7 10 11 13 12 14 16 15 17 18 20 19
0 1 2 3 4 5 6 7 8 10 9 12 13 11 14 15 16 17 18 19 20
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2890.1">The next section presents the functionality of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2891.1">context</span></code><span class="koboSpan" id="kobo.2892.1"> package.</span></p>
<h1 class="heading-1" id="_idParaDest-255"><span class="koboSpan" id="kobo.2893.1">The context package</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2894.1">The main purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2895.1">context</span></code><span class="koboSpan" id="kobo.2896.1"> package is to define</span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.2897.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2898.1">Context</span></code><span class="koboSpan" id="kobo.2899.1"> type and support cancellation. </span><span class="koboSpan" id="kobo.2899.2">Yes, you heard that right; there are times when, for some reason, you want to abandon what you are doing. </span><span class="koboSpan" id="kobo.2899.3">However, it would be very helpful to be able to include some extra information about your cancellation decisions. </span><span class="koboSpan" id="kobo.2899.4">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2900.1">context</span></code><span class="koboSpan" id="kobo.2901.1"> package allows you to do exactly that.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2902.1">If you take a look at the source code of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2903.1">context</span></code><span class="koboSpan" id="kobo.2904.1"> package, you will realize that its implementation is pretty simple—even the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2905.1">Context</span></code><span class="koboSpan" id="kobo.2906.1"> type is pretty simple, yet the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2907.1">context</span></code><span class="koboSpan" id="kobo.2908.1"> package is very important.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2909.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2910.1">Context</span></code><span class="koboSpan" id="kobo.2911.1"> type is an interface with four methods: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2912.1">Deadline()</span></code><span class="koboSpan" id="kobo.2913.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2914.1">Done()</span></code><span class="koboSpan" id="kobo.2915.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2916.1">Err()</span></code><span class="koboSpan" id="kobo.2917.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2918.1">Value()</span></code><span class="koboSpan" id="kobo.2919.1">. </span><span class="koboSpan" id="kobo.2919.2">The good news is that you do not need to implement all of these functions of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2920.1">Context</span></code><span class="koboSpan" id="kobo.2921.1"> interface—you just need to modify a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2922.1">Context</span></code><span class="koboSpan" id="kobo.2923.1"> variable using methods such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2924.1">context.WithCancel()</span></code><span class="koboSpan" id="kobo.2925.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2926.1">context.WithDeadline()</span></code><span class="koboSpan" id="kobo.2927.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2928.1">context.WithTimeout()</span></code><span class="koboSpan" id="kobo.2929.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2930.1">All three of these methods return a derived </span><code class="inlineCode"><span class="koboSpan" id="kobo.2931.1">Context</span></code><span class="koboSpan" id="kobo.2932.1"> (the child) and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2933.1">CancelFunc()</span></code><span class="koboSpan" id="kobo.2934.1"> function. </span><span class="koboSpan" id="kobo.2934.2">Calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2935.1">CancelFunc()</span></code><span class="koboSpan" id="kobo.2936.1"> function removes the parent’s reference to the child and stops any associated timers. </span><span class="koboSpan" id="kobo.2936.2">As a side effect, this means that the Go garbage collector is free to garbage collect the child goroutines that no longer have associated parent goroutines. </span><span class="koboSpan" id="kobo.2936.3">For garbage collection to work correctly, the parent goroutine needs to keep a reference to each child goroutine. </span><span class="koboSpan" id="kobo.2936.4">If a child goroutine ends without the parent knowing about it, then a memory leak occurs until the parent is canceled as well.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2937.1">The example that follows showcases the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2938.1">context</span></code><span class="koboSpan" id="kobo.2939.1"> package. </span><span class="koboSpan" id="kobo.2939.2">The program contains four functions, including the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2940.1">main()</span></code><span class="koboSpan" id="kobo.2941.1"> function. </span><span class="koboSpan" id="kobo.2941.2">Functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2942.1">f1()</span></code><span class="koboSpan" id="kobo.2943.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2944.1">f2()</span></code><span class="koboSpan" id="kobo.2945.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2946.1">f3()</span></code><span class="koboSpan" id="kobo.2947.1"> each require just one parameter (which is a time delay) because everything else they need is defined inside their function body. </span><span class="koboSpan" id="kobo.2947.2">In this example, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2948.1">context.Background()</span></code><span class="koboSpan" id="kobo.2949.1"> to initialize an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.2950.1">Context</span></code><span class="koboSpan" id="kobo.2951.1">. </span><span class="koboSpan" id="kobo.2951.2">The other function that can create an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.2952.1">Context</span></code><span class="koboSpan" id="kobo.2953.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2954.1">context.TODO()</span></code><span class="koboSpan" id="kobo.2955.1">, which is presented later on in this chapter.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2956.1">package</span></span><span class="koboSpan" id="kobo.2957.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2958.1">import</span></span><span class="koboSpan" id="kobo.2959.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2960.1">"context"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2961.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2962.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2963.1">"strconv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2964.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2965.1">time"</span></span><span class="koboSpan" id="kobo.2966.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2967.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2968.1">f1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2969.1">(t </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2970.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2971.1">)</span></span><span class="koboSpan" id="kobo.2972.1"> {
    c1 := context.Background()
    c1, cancel := context.WithCancel(c1)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2973.1">defer</span></span><span class="koboSpan" id="kobo.2974.1"> cancel()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2975.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2976.1">WithCancel()</span></code><span class="koboSpan" id="kobo.2977.1"> method returns</span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.2978.1"> a copy of the parent context with a new </span><code class="inlineCode"><span class="koboSpan" id="kobo.2979.1">Done</span></code><span class="koboSpan" id="kobo.2980.1"> channel. </span><span class="koboSpan" id="kobo.2980.2">Notice that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2981.1">cancel</span></code><span class="koboSpan" id="kobo.2982.1"> variable, which is a function, is one of the return values of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2983.1">context.CancelFunc()</span></code><span class="koboSpan" id="kobo.2984.1">. </span><span class="koboSpan" id="kobo.2984.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2985.1">context.WithCancel()</span></code><span class="koboSpan" id="kobo.2986.1"> function uses an existing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2987.1">Context</span></code><span class="koboSpan" id="kobo.2988.1"> and creates a child with cancellation. </span><span class="koboSpan" id="kobo.2988.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2989.1">context.WithCancel()</span></code><span class="koboSpan" id="kobo.2990.1"> function also returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2991.1">Done</span></code><span class="koboSpan" id="kobo.2992.1"> channel that can be closed, either when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2993.1">cancel()</span></code><span class="koboSpan" id="kobo.2994.1"> function is called, as shown in the preceding code, or when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2995.1">Done</span></code><span class="koboSpan" id="kobo.2996.1"> channel of the parent context is closed.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2997.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2998.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2999.1">()</span></span><span class="koboSpan" id="kobo.3000.1"> {
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3001.1">4</span></span><span class="koboSpan" id="kobo.3002.1"> * time.Second)
        cancel()
    }()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3003.1">select</span></span><span class="koboSpan" id="kobo.3004.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3005.1">case</span></span><span class="koboSpan" id="kobo.3006.1"> &lt;-c1.Done():
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3007.1">"f1() Done:"</span></span><span class="koboSpan" id="kobo.3008.1">, c1.Err())
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3009.1">return</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3010.1">case</span></span><span class="koboSpan" id="kobo.3011.1"> r := &lt;-time.After(time.Duration(t) * time.Second):
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3012.1">"f1():"</span></span><span class="koboSpan" id="kobo.3013.1">, r)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3014.1">return</span></span><span class="koboSpan" id="kobo.3015.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3016.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3017.1">f1()</span></code><span class="koboSpan" id="kobo.3018.1"> function creates and executes a goroutine. </span><span class="koboSpan" id="kobo.3018.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3019.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.3020.1"> call simulates the time it would take a real goroutine to do its job. </span><span class="koboSpan" id="kobo.3020.2">In this case, it is 4 seconds, but you can put any time period you want. </span><span class="koboSpan" id="kobo.3020.3">If the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3021.1">c1</span></code><span class="koboSpan" id="kobo.3022.1"> context calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3023.1">Done()</span></code><span class="koboSpan" id="kobo.3024.1"> function in less than 4 seconds, the goroutine will not have enough time to finish.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3025.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3026.1">f2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3027.1">(t </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3028.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3029.1">)</span></span><span class="koboSpan" id="kobo.3030.1"> {
    c2 := context.Background()
    c2, cancel := context.WithTimeout(c2, time.Duration(t)*time.Second)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3031.1">defer</span></span><span class="koboSpan" id="kobo.3032.1"> cancel()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3033.1">The cancel variable in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3034.1">f2()</span></code><span class="koboSpan" id="kobo.3035.1"> comes</span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.3036.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3037.1">context.WithTimeout()</span></code><span class="koboSpan" id="kobo.3038.1">, which requires two parameters: a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3039.1">Context</span></code><span class="koboSpan" id="kobo.3040.1"> parameter and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3041.1">time.Duration</span></code><span class="koboSpan" id="kobo.3042.1"> parameter. </span><span class="koboSpan" id="kobo.3042.2">When the timeout period expires, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3043.1">cancel()</span></code><span class="koboSpan" id="kobo.3044.1"> function is called automatically.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3045.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3046.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3047.1">()</span></span><span class="koboSpan" id="kobo.3048.1"> {
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3049.1">4</span></span><span class="koboSpan" id="kobo.3050.1"> * time.Second)
        cancel()
    }()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3051.1">select</span></span><span class="koboSpan" id="kobo.3052.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3053.1">case</span></span><span class="koboSpan" id="kobo.3054.1"> &lt;-c2.Done():
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3055.1">"f2() Done:"</span></span><span class="koboSpan" id="kobo.3056.1">, c2.Err())
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3057.1">return</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3058.1">case</span></span><span class="koboSpan" id="kobo.3059.1"> r := &lt;-time.After(time.Duration(t) * time.Second):
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3060.1">"f2():"</span></span><span class="koboSpan" id="kobo.3061.1">, r)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3062.1">return</span></span><span class="koboSpan" id="kobo.3063.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3064.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3065.1">f3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3066.1">(t </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3067.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3068.1">)</span></span><span class="koboSpan" id="kobo.3069.1"> {
    c3 := context.Background()
    deadline := time.Now().Add(time.Duration(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3070.1">2</span></span><span class="koboSpan" id="kobo.3071.1">*t) * time.Second)
    c3, cancel := context.WithDeadline(c3, deadline)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3072.1">defer</span></span><span class="koboSpan" id="kobo.3073.1"> cancel()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3074.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3075.1">cancel</span></code><span class="koboSpan" id="kobo.3076.1"> variable in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3077.1">f3()</span></code><span class="koboSpan" id="kobo.3078.1"> comes from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3079.1">context.WithDeadline()</span></code><span class="koboSpan" id="kobo.3080.1">, which requires two parameters: a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3081.1">Context</span></code><span class="koboSpan" id="kobo.3082.1"> variable and a time in the future that signifies the deadline of the operation. </span><span class="koboSpan" id="kobo.3082.2">When the deadline passes, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3083.1">cancel()</span></code><span class="koboSpan" id="kobo.3084.1"> function is called automatically.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3085.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3086.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3087.1">()</span></span><span class="koboSpan" id="kobo.3088.1"> {
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3089.1">4</span></span><span class="koboSpan" id="kobo.3090.1"> * time.Second)
        cancel()
    }()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3091.1">select</span></span><span class="koboSpan" id="kobo.3092.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3093.1">case</span></span><span class="koboSpan" id="kobo.3094.1"> &lt;-c3.Done():
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3095.1">"f3() Done:"</span></span><span class="koboSpan" id="kobo.3096.1">, c3.Err())
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3097.1">return</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3098.1">case</span></span><span class="koboSpan" id="kobo.3099.1"> r := &lt;-time.After(time.Duration(t) * time.Second):
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3100.1">"f3():"</span></span><span class="koboSpan" id="kobo.3101.1">, r)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3102.1">return</span></span><span class="koboSpan" id="kobo.3103.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3104.1">The logic of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3105.1">f3()</span></code><span class="koboSpan" id="kobo.3106.1"> is the same as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3107.1">f1()</span></code><span class="koboSpan" id="kobo.3108.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3109.1">f2()</span></code><span class="koboSpan" id="kobo.3110.1">—the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3111.1">select</span></code><span class="koboSpan" id="kobo.3112.1"> block orchestrates the process.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3113.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3114.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3115.1">()</span></span><span class="koboSpan" id="kobo.3116.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3117.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3118.1">len</span></span><span class="koboSpan" id="kobo.3119.1">(os.Args) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.3120.1">2</span></span><span class="koboSpan" id="kobo.3121.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3122.1">"Need a delay!"</span></span><span class="koboSpan" id="kobo.3123.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3124.1">return</span></span><span class="koboSpan" id="kobo.3125.1">
    }
    delay, err := strconv.Atoi(os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.3126.1">1</span></span><span class="koboSpan" id="kobo.3127.1">])
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3128.1">if</span></span><span class="koboSpan" id="kobo.3129.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3130.1">nil</span></span><span class="koboSpan" id="kobo.3131.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3132.1">return</span></span><span class="koboSpan" id="kobo.3133.1">
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3134.1">"Delay:"</span></span><span class="koboSpan" id="kobo.3135.1">, delay)
    f1(delay)
    f2(delay)
    f3(delay)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3136.1">The three functions are executed</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.3137.1"> in sequence by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3138.1">main()</span></code><span class="koboSpan" id="kobo.3139.1"> function. </span><span class="koboSpan" id="kobo.3139.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.3140.1">useContext.go</span></code><span class="koboSpan" id="kobo.3141.1"> produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3142.1">$ </span></span><span class="koboSpan" id="kobo.3143.1">go run useContext.go 3
Delay: 3
f1(): 2023-08-28 16:23:22.300595 +0300 EEST m=+3.001225751
f2(): 2023-08-28 16:23:25.302122 +0300 EEST m=+6.002730959
f3(): 2023-08-28 16:23:28.303326 +0300 EEST m=+9.00391262
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3144.1">The long lines of the output are the return values of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3145.1">time.After()</span></code><span class="koboSpan" id="kobo.3146.1"> and show the times that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3147.1">After()</span></code><span class="koboSpan" id="kobo.3148.1"> sent the current time on the returned channel. </span><span class="koboSpan" id="kobo.3148.2">All of them denote a normal operation of the program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3149.1">If you define a bigger delay, then the output is going to be similar to the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3150.1">$ </span></span><span class="koboSpan" id="kobo.3151.1">go run useContext.go 13
Delay: 13
f1() Done: context canceled
f2() Done: context canceled
f3() Done: context canceled
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3152.1">The point here is that the operation</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.3153.1"> of the program is canceled when there are delays in its execution.</span></p>
<h2 class="heading-2" id="_idParaDest-256"><span class="koboSpan" id="kobo.3154.1">About context.WithCancelCause</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3155.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3156.1">context.WithCancelCause()</span></code><span class="koboSpan" id="kobo.3157.1"> method was introduced</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.3158.1"> in Go 1.21. </span><span class="koboSpan" id="kobo.3158.2">Its main advantage is that it gives you customization capabilities, which are not offered by the other methods of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3159.1">context</span></code><span class="koboSpan" id="kobo.3160.1"> package. </span><span class="koboSpan" id="kobo.3160.2">Apart from that, it behaves like </span><code class="inlineCode"><span class="koboSpan" id="kobo.3161.1">WithCancel()</span></code><span class="koboSpan" id="kobo.3162.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3163.1">Similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3164.1">context.WithCancelCause()</span></code><span class="koboSpan" id="kobo.3165.1">, there exists </span><code class="inlineCode"><span class="koboSpan" id="kobo.3166.1">context.WithTimeoutCause()</span></code><span class="koboSpan" id="kobo.3167.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3168.1">context.WithDeadlineCause()</span></code><span class="koboSpan" id="kobo.3169.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3170.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3171.1">withCancelCause.go</span></code><span class="koboSpan" id="kobo.3172.1"> program illustrates the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3173.1">context.WithCancelCause()</span></code><span class="koboSpan" id="kobo.3174.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3175.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3176.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3177.1">()</span></span><span class="koboSpan" id="kobo.3178.1"> {
    ctx := context.Background()
    ctx, cancel := context.WithCancelCause(ctx)
    cancel(errors.New(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3179.1">"Canceled by timeout"</span></span><span class="koboSpan" id="kobo.3180.1">))
    err := takingTooLong(ctx)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3181.1">if</span></span><span class="koboSpan" id="kobo.3182.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3183.1">nil</span></span><span class="koboSpan" id="kobo.3184.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3185.1">return</span></span><span class="koboSpan" id="kobo.3186.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3187.1">The implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3188.1">main()</span></code><span class="koboSpan" id="kobo.3189.1"> contains two important elements. </span><span class="koboSpan" id="kobo.3189.2">First, we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.3190.1">context.WithCancelCause()</span></code><span class="koboSpan" id="kobo.3191.1">, which returns a context, and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3192.1">CancelCauseFunc()</span></code><span class="koboSpan" id="kobo.3193.1"> function, which behaves like </span><code class="inlineCode"><span class="koboSpan" id="kobo.3194.1">CancelFunc()</span></code><span class="koboSpan" id="kobo.3195.1"> while allowing us to define and customize the cancellation cause giving clearer context to the error situation—in this case, the cancellation cause is defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3196.1">errors.New("Canceled by timeout")</span></code><span class="koboSpan" id="kobo.3197.1">. </span><span class="koboSpan" id="kobo.3197.2">After that, we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.3198.1">takingTooLong()</span></code><span class="koboSpan" id="kobo.3199.1"> with the context that we have just defined. </span><span class="koboSpan" id="kobo.3199.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.3200.1">takingTooLong()</span></code><span class="koboSpan" id="kobo.3201.1"> returns an error that is not </span><code class="inlineCode"><span class="koboSpan" id="kobo.3202.1">nil</span></code><span class="koboSpan" id="kobo.3203.1">, we print that error.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3204.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3205.1">takingTooLong</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3206.1">(ctx context.Context)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3207.1">error</span></span><span class="koboSpan" id="kobo.3208.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3209.1">select</span></span><span class="koboSpan" id="kobo.3210.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3211.1">case</span></span><span class="koboSpan" id="kobo.3212.1"> &lt;-time.After(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3213.1">3</span></span><span class="koboSpan" id="kobo.3214.1"> * time.Second):
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3215.1">"Done!"</span></span><span class="koboSpan" id="kobo.3216.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3217.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.3218.1">nil</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3219.1">case</span></span><span class="koboSpan" id="kobo.3220.1"> &lt;-ctx.Done():
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3221.1">"Canceled!"</span></span><span class="koboSpan" id="kobo.3222.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3223.1">return</span></span><span class="koboSpan" id="kobo.3224.1"> context.Cause(ctx)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3225.1">The previous function returns either </span><code class="inlineCode"><span class="koboSpan" id="kobo.3226.1">nil</span></code><span class="koboSpan" id="kobo.3227.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3228.1">context.Cause(ctx)</span></code><span class="koboSpan" id="kobo.3229.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3230.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.3231.1">withCancelCause.go</span></code><span class="koboSpan" id="kobo.3232.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3233.1">$ </span></span><span class="koboSpan" id="kobo.3234.1">go run withCancelCause.go
Canceled!
</span><span class="koboSpan" id="kobo.3234.2">Canceled by timeout
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3235.1">So, as the second part of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3236.1">select</span></code><span class="koboSpan" id="kobo.3237.1"> block is executed, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3238.1">takingTooLong()</span></code><span class="koboSpan" id="kobo.3239.1"> prints </span><code class="inlineCode"><span class="koboSpan" id="kobo.3240.1">Canceled!</span></code><span class="koboSpan" id="kobo.3241.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3242.1">main()</span></code><span class="koboSpan" id="kobo.3243.1"> prints the cancellation reason according to the initialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3244.1">context.WithCancelCause()</span></code><span class="koboSpan" id="kobo.3245.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3246.1">We are not completely done</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.3247.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3248.1">context</span></code><span class="koboSpan" id="kobo.3249.1"> as the next chapter is going to use it to timeout HTTP interactions on the client side of the connection. </span><span class="koboSpan" id="kobo.3249.2">The next section discusses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3250.1">semaphore</span></code><span class="koboSpan" id="kobo.3251.1"> package, which is not part of the standard library.</span></p>
<h1 class="heading-1" id="_idParaDest-257"><span class="koboSpan" id="kobo.3252.1">The semaphore package</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3253.1">This last section of this chapter</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.3254.1"> presents the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3255.1">semaphore</span></code><span class="koboSpan" id="kobo.3256.1"> package, which is provided by the Go team. </span><span class="koboSpan" id="kobo.3256.2">A semaphore is a construct that can limit or control the access to a shared resource. </span><span class="koboSpan" id="kobo.3256.3">As we are talking about Go, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.3257.1">a semaphore can limit the access of goroutines to a shared resource</span></strong><span class="koboSpan" id="kobo.3258.1"> but, originally, semaphores were used for limiting access to threads. </span><span class="koboSpan" id="kobo.3258.2">Semaphores can have weights that limit the number of threads or goroutines that can have access to a resource.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3259.1">The process is supported via the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3260.1">Acquire()</span></code><span class="koboSpan" id="kobo.3261.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3262.1">Release()</span></code><span class="koboSpan" id="kobo.3263.1"> methods, which are defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3264.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.3265.1">(s *Weighted)</span></span><span class="koboSpan" id="kobo.3266.1"> Acquire(ctx context.Context, n </span><span class="hljs-type"><span class="koboSpan" id="kobo.3267.1">int64</span></span><span class="koboSpan" id="kobo.3268.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.3269.1">error</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3270.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.3271.1">(s *Weighted)</span></span><span class="koboSpan" id="kobo.3272.1"> Release(n </span><span class="hljs-type"><span class="koboSpan" id="kobo.3273.1">int64</span></span><span class="koboSpan" id="kobo.3274.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3275.1">The second parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3276.1">Acquire()</span></code><span class="koboSpan" id="kobo.3277.1"> defines the weight of the semaphore. </span><span class="koboSpan" id="kobo.3277.2">As we are going to use an external package, we need to put the code inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.3278.1">~/go/src</span></code><span class="koboSpan" id="kobo.3279.1"> in order to use Go modules: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3280.1">~/go/src/github.com/mactsouk/mGo4th/ch08/semaphore</span></code><span class="koboSpan" id="kobo.3281.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3282.1">Now, let us present the code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3283.1">semaphore.go</span></code><span class="koboSpan" id="kobo.3284.1">, which shows an implementation of a worker pool using semaphores:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3285.1">package</span></span><span class="koboSpan" id="kobo.3286.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3287.1">import</span></span><span class="koboSpan" id="kobo.3288.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.3289.1">"context"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3290.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3291.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3292.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3293.1">strconv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3294.1">"time"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.3295.1">"golang.org/x/sync/semaphore"</span></span><span class="koboSpan" id="kobo.3296.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3297.1">var</span></span><span class="koboSpan" id="kobo.3298.1"> Workers = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3299.1">4</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3300.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3301.1">Workers</span></code><span class="koboSpan" id="kobo.3302.1"> variable specifies the maximum number</span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.3303.1"> of goroutines that can be executed by this program.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3304.1">var</span></span><span class="koboSpan" id="kobo.3305.1"> sem = semaphore.NewWeighted(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3306.1">int64</span></span><span class="koboSpan" id="kobo.3307.1">(Workers))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3308.1">This is where we define the semaphore with a weight identical to the maximum number of goroutines that can be executed concurrently. </span><span class="koboSpan" id="kobo.3308.2">This means that no more than </span><code class="inlineCode"><span class="koboSpan" id="kobo.3309.1">Workers</span></code><span class="koboSpan" id="kobo.3310.1"> goroutines can acquire the semaphore at the same time.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3311.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3312.1">worker</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3313.1">(n </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3314.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3315.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3316.1">int</span></span><span class="koboSpan" id="kobo.3317.1"> {
    square := n * n
    time.Sleep(time.Second)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3318.1">return</span></span><span class="koboSpan" id="kobo.3319.1"> square
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3320.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3321.1">worker()</span></code><span class="koboSpan" id="kobo.3322.1"> function is run as part of a goroutine. </span><span class="koboSpan" id="kobo.3322.2">However, as we are using a semaphore, there is no need to return the results to a channel.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3323.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3324.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3325.1">()</span></span><span class="koboSpan" id="kobo.3326.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3327.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3328.1">len</span></span><span class="koboSpan" id="kobo.3329.1">(os.Args) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.3330.1">2</span></span><span class="koboSpan" id="kobo.3331.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3332.1">"Need #jobs!"</span></span><span class="koboSpan" id="kobo.3333.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3334.1">return</span></span><span class="koboSpan" id="kobo.3335.1">
    }
    nJobs, err := strconv.Atoi(os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.3336.1">1</span></span><span class="koboSpan" id="kobo.3337.1">])
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3338.1">if</span></span><span class="koboSpan" id="kobo.3339.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3340.1">nil</span></span><span class="koboSpan" id="kobo.3341.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3342.1">return</span></span><span class="koboSpan" id="kobo.3343.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3344.1">The previous code reads the number of jobs that we want to run.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.3345.1">// Where to store the results</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3346.1">var</span></span><span class="koboSpan" id="kobo.3347.1"> results = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3348.1">make</span></span><span class="koboSpan" id="kobo.3349.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.3350.1">int</span></span><span class="koboSpan" id="kobo.3351.1">, nJobs)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3352.1">// Needed by Acquire()</span></span><span class="koboSpan" id="kobo.3353.1">
    ctx := context.TODO()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3354.1">for</span></span><span class="koboSpan" id="kobo.3355.1"> i := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3356.1">range</span></span><span class="koboSpan" id="kobo.3357.1"> results {
        err = sem.Acquire(ctx, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3358.1">1</span></span><span class="koboSpan" id="kobo.3359.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3360.1">if</span></span><span class="koboSpan" id="kobo.3361.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3362.1">nil</span></span><span class="koboSpan" id="kobo.3363.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3364.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3365.1">Cannot acquire semaphore:"</span></span><span class="koboSpan" id="kobo.3366.1">, err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3367.1">break</span></span><span class="koboSpan" id="kobo.3368.1">
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3369.1">In this part, we try to acquire the semaphore</span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.3370.1"> as many times as the number of jobs defined by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3371.1">nJobs</span></code><span class="koboSpan" id="kobo.3372.1">. </span><span class="koboSpan" id="kobo.3372.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.3373.1">nJobs</span></code><span class="koboSpan" id="kobo.3374.1"> is bigger than </span><code class="inlineCode"><span class="koboSpan" id="kobo.3375.1">Workers</span></code><span class="koboSpan" id="kobo.3376.1">, then the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3377.1">Acquire()</span></code><span class="koboSpan" id="kobo.3378.1"> call is going to block and wait for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3379.1">Release()</span></code><span class="koboSpan" id="kobo.3380.1"> calls in order to unblock.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3381.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3382.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3383.1">(i </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3384.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3385.1">)</span></span><span class="koboSpan" id="kobo.3386.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3387.1">defer</span></span><span class="koboSpan" id="kobo.3388.1"> sem.Release(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3389.1">1</span></span><span class="koboSpan" id="kobo.3390.1">)
            temp := worker(i)
            results[i] = temp
        }(i)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3391.1">This is where we run the goroutines that do the job and write the results to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3392.1">results</span></code><span class="koboSpan" id="kobo.3393.1"> slice. </span><span class="koboSpan" id="kobo.3393.2">As each goroutine writes to a different slice element, there are not any race conditions.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3394.1">    err = sem.Acquire(ctx, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3395.1">int64</span></span><span class="koboSpan" id="kobo.3396.1">(Workers))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3397.1">if</span></span><span class="koboSpan" id="kobo.3398.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3399.1">nil</span></span><span class="koboSpan" id="kobo.3400.1"> {
        fmt.Println(err)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3401.1">This is a clever trick: we acquire all of the tokens so that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3402.1">sem.Acquire()</span></code><span class="koboSpan" id="kobo.3403.1"> call blocks until all workers/goroutines have finished. </span><span class="koboSpan" id="kobo.3403.2">This is similar in functionality to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3404.1">Wait()</span></code><span class="koboSpan" id="kobo.3405.1"> call.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3406.1">for</span></span><span class="koboSpan" id="kobo.3407.1"> k, v := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3408.1">range</span></span><span class="koboSpan" id="kobo.3409.1"> results {
        fmt.Println(k, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3410.1">"-&gt;"</span></span><span class="koboSpan" id="kobo.3411.1">, v)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3412.1">The last part of the program is about printing the results. </span><span class="koboSpan" id="kobo.3412.2">After writing the code, we need to run the following commands to get the required Go modules:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3413.1">$ </span></span><span class="koboSpan" id="kobo.3414.1">go mod init
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3415.1">$ </span></span><span class="koboSpan" id="kobo.3416.1">go mod tidy
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3417.1">$ </span></span><span class="koboSpan" id="kobo.3418.1">mod download golang.org/x/sync
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3419.1">Apart from the first command, these commands were indicated by the output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3420.1">go mod init</span></code><span class="koboSpan" id="kobo.3421.1">, so you do not have to remember anything.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3422.1">Lastly, running </span><code class="inlineCode"><span class="koboSpan" id="kobo.3423.1">semaphore.go</span></code><span class="koboSpan" id="kobo.3424.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3425.1">$ </span></span><span class="koboSpan" id="kobo.3426.1">go run semaphore.go 3
0 -&gt; 0
1 -&gt; 1
2 -&gt; 4
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3427.1">Each line in the output shows</span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.3428.1"> the input value and the output value separated by -&gt;. </span><span class="koboSpan" id="kobo.3428.2">The use of the semaphore keeps things in order.</span></p>
<h1 class="heading-1" id="_idParaDest-258"><span class="koboSpan" id="kobo.3429.1">Making the statistics application concurrent</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3430.1">In this section of this chapter, we are going</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.3431.1"> to convert the statistics application into a concurrent application that uses goroutines. </span><span class="koboSpan" id="kobo.3431.2">However, instead of using channels, we are going to use a different approach that prevents deadlocks, while making the overall design of the program much simpler. </span><span class="koboSpan" id="kobo.3431.3">Apart from that, there is also a version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3432.1">stats.go</span></code><span class="koboSpan" id="kobo.3433.1"> named </span><code class="inlineCode"><span class="koboSpan" id="kobo.3434.1">statsNC.go</span></code><span class="koboSpan" id="kobo.3435.1"> that does not create any goroutines and processes the input files sequentially.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3436.1">We are only going to present the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3437.1">main()</span></code><span class="koboSpan" id="kobo.3438.1"> function of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3439.1">stats.go</span></code><span class="koboSpan" id="kobo.3440.1"> because this is where the logic of the utility is found. </span><span class="koboSpan" id="kobo.3440.2">However, minor additional changes exist for taking advantage of goroutines. </span><span class="koboSpan" id="kobo.3440.3">The most time-consuming part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3441.1">stats.go</span></code><span class="koboSpan" id="kobo.3442.1"> is the normalization of the time series.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3443.1">What is impressive is that we converted </span><code class="inlineCode"><span class="koboSpan" id="kobo.3444.1">stats.go</span></code><span class="koboSpan" id="kobo.3445.1"> into a concurrent application using a minimal amount of changes that mainly have to do with goroutine synchronization—this is a good indication of great design.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3446.1">The implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3447.1">main()</span></code><span class="koboSpan" id="kobo.3448.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3449.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3450.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3451.1">()</span></span><span class="koboSpan" id="kobo.3452.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3453.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3454.1">len</span></span><span class="koboSpan" id="kobo.3455.1">(os.Args) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3456.1">1</span></span><span class="koboSpan" id="kobo.3457.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3458.1">"Need one or more file paths!"</span></span><span class="koboSpan" id="kobo.3459.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3460.1">return</span></span><span class="koboSpan" id="kobo.3461.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3462.1">var</span></span><span class="koboSpan" id="kobo.3463.1"> waitGroup sync.WaitGroup
    files = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3464.1">make</span></span><span class="koboSpan" id="kobo.3465.1">(DFslice, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3466.1">len</span></span><span class="koboSpan" id="kobo.3467.1">(os.Args))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3468.1">So far, we have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3469.1">sync.WaitGroup</span></code><span class="koboSpan" id="kobo.3470.1"> variable </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.3471.1">for synchronizing the goroutines. </span><span class="koboSpan" id="kobo.3471.2">Additionally, we have a slice variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.3472.1">files</span></code><span class="koboSpan" id="kobo.3473.1"> that has as many elements as the length of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3474.1">os.Args</span></code><span class="koboSpan" id="kobo.3475.1"> slice—</span><code class="inlineCode"><span class="koboSpan" id="kobo.3476.1">files[0]</span></code><span class="koboSpan" id="kobo.3477.1"> is not going to be used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3478.1">The remaining code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3479.1">main()</span></code><span class="koboSpan" id="kobo.3480.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3481.1">for</span></span><span class="koboSpan" id="kobo.3482.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.3483.1">1</span></span><span class="koboSpan" id="kobo.3484.1">; i &lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3485.1">len</span></span><span class="koboSpan" id="kobo.3486.1">(os.Args); i++ {
        waitGroup.Add(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3487.1">1</span></span><span class="koboSpan" id="kobo.3488.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3489.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3490.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3491.1">(x </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3492.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3493.1">)</span></span><span class="koboSpan" id="kobo.3494.1"> {
            process(os.Args[x], x)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3495.1">defer</span></span><span class="koboSpan" id="kobo.3496.1"> waitGroup.Done()
        }(i)
    }
    waitGroup.Wait()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3497.1">What do we have here? </span><span class="koboSpan" id="kobo.3497.2">There is an anonymous function that runs as a goroutine. </span><span class="koboSpan" id="kobo.3497.3">That anonymous function requires a single parameter, which is </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.3498.1">the index of the command line argument that is being processed</span></strong><span class="koboSpan" id="kobo.3499.1">. </span><span class="koboSpan" id="kobo.3499.2">There is a handy property that comes with that index: that index is unique, which means that we can use that unique index when we put data into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3500.1">files</span></code><span class="koboSpan" id="kobo.3501.1"> slice—this process takes place inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.3502.1">process()</span></code><span class="koboSpan" id="kobo.3503.1">. </span><span class="koboSpan" id="kobo.3503.2">This resolves any potential race conditions as each goroutine uses a different place in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3504.1">files</span></code><span class="koboSpan" id="kobo.3505.1">. </span><span class="koboSpan" id="kobo.3505.2">Keep in mind that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3506.1">files[0]</span></code><span class="koboSpan" id="kobo.3507.1"> is not being used but we have decided to make </span><code class="inlineCode"><span class="koboSpan" id="kobo.3508.1">files</span></code><span class="koboSpan" id="kobo.3509.1"> bigger than needed in order to put the data for the first command line argument in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3510.1">files[1]</span></code><span class="koboSpan" id="kobo.3511.1">, and so on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3512.1">Apart from that, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3513.1">sync</span></code><span class="koboSpan" id="kobo.3514.1"> to wait for all goroutines to finish before exiting the program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3515.1">In order to compare </span><code class="inlineCode"><span class="koboSpan" id="kobo.3516.1">stats.go</span></code><span class="koboSpan" id="kobo.3517.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3518.1">statsNC.go</span></code><span class="koboSpan" id="kobo.3519.1">, we are going to use bigger datasets, which are all stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3520.1">./ch08/dataset</span></code><span class="koboSpan" id="kobo.3521.1"> directory. </span><span class="koboSpan" id="kobo.3521.2">The sizes of the three data files can be seen in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3522.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.3523.1">wc</span></span><span class="koboSpan" id="kobo.3524.1"> dataset/*
 1518653 1518653 4119086 dataset/1.5M
 2531086 2531086 6918628 dataset/2.5M
 4049739 4049739 11037714 dataset/4.0M
 8099478 8099478 22075428 total
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3525.1">A quick and dirty way to calculate the execution time of a program is using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3526.1">time(1)</span></code><span class="koboSpan" id="kobo.3527.1"> UNIX utility. </span><span class="koboSpan" id="kobo.3527.2">Using that utility, we are going to compare the execution time of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3528.1">./ch05/stats.go</span></code><span class="koboSpan" id="kobo.3529.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3530.1">./ch05/stats.go</span></code><span class="koboSpan" id="kobo.3531.1"> and see what happens:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3532.1">$ </span></span><span class="koboSpan" id="kobo.3533.1">time go run stats.go ./dataset/* ./dataset/* ./dataset/*
real    0m1.240s
user    0m6.259s
sys     0m0.528s
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.3534.1">$ </span></span><span class="koboSpan" id="kobo.3535.1">time go run statsNC.go ./dataset/* ./dataset/* ./dataset/*
real    0m3.267s
user    0m7.766s
sys     0m0.535s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3536.1">What is important in the output</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.3537.1"> is the values in the lines that begin with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3538.1">real</span></code><span class="koboSpan" id="kobo.3539.1">. </span><span class="koboSpan" id="kobo.3539.2">The concurrent version is about </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.3540.1">three times faster</span></strong><span class="koboSpan" id="kobo.3541.1"> than the non-concurrent version when processing nine files. </span><span class="koboSpan" id="kobo.3541.2">Imagine using even bigger datasets and having to process 1,000 datasets instead of just nine!</span></p>
<h1 class="heading-1" id="_idParaDest-259"><span class="koboSpan" id="kobo.3542.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3543.1">In this important chapter, we talked about Go concurrency, goroutines, channels, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3544.1">select</span></code><span class="koboSpan" id="kobo.3545.1"> keyword, shared memory, and mutexes, as well as timing out goroutines and the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3546.1">context</span></code><span class="koboSpan" id="kobo.3547.1"> package. </span><span class="koboSpan" id="kobo.3547.2">Bear in mind that although goroutines can process data and execute commands, they cannot communicate with each other directly but they can communicate in other ways, including channels, local sockets, and shared memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3548.1">Remember that OS threads are controlled by the OS scheduler, whereas goroutines executed in one or more OS threads are controlled by the Go runtime. </span><span class="koboSpan" id="kobo.3548.2">The correct terminology for when a goroutine or an OS thread is executed and then paused is </span><em class="italic"><span class="koboSpan" id="kobo.3549.1">context-switched on and off</span></em><span class="koboSpan" id="kobo.3550.1">, respectively. </span><span class="koboSpan" id="kobo.3550.2">Keep in mind that the Go scheduler checks the global queue from time to time in order to find out whether there are any goroutines waiting to be assigned to a local queue. </span><span class="koboSpan" id="kobo.3550.3">If both the global queue and a given local queue are empty, then </span><em class="italic"><span class="koboSpan" id="kobo.3551.1">work-stealing</span></em><span class="koboSpan" id="kobo.3552.1"> takes place.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3553.1">The main advantage of concurrency is that it allows the splitting of bigger tasks into smaller ones and the execution of each smaller task concurrently. </span><span class="koboSpan" id="kobo.3553.2">Additionally, concurrency does a great job in distributing multiple HTTP requests among different goroutines. </span><span class="koboSpan" id="kobo.3553.3">Lastly, concurrency makes better use of modern CPUs with multiple cores and virtual environments. </span><span class="koboSpan" id="kobo.3553.4">However, concurrency adds complexity to the software design and the code, which affects readability and maintainability. </span><span class="koboSpan" id="kobo.3553.5">For that reason, you might need to add concurrency last in your code, as we did with the statistics application. </span><span class="koboSpan" id="kobo.3553.6">One other concern of concurrency is the risk of consuming all available resources making other services unreliable or even unavailable. </span><span class="koboSpan" id="kobo.3553.7">Lastly, concurrent code is harder to benchmark—if you want to compare two concurrent implementations, it is better to compare their sequential versions that tell more about the actual algorithms and code efficiency.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3554.1">What is important to remember is that the rational use of concurrency and goroutines is going to allow you to write powerful Go applications. </span><span class="koboSpan" id="kobo.3554.2">Feel free to experiment with the concepts and the examples of this chapter to better understand goroutines, channels, and shared memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3555.1">The next chapter is all about web services and working with the HTTP protocol in Go. </span><span class="koboSpan" id="kobo.3555.2">Among other things, we are going to convert the statistics application into a web service.</span></p>
<h1 class="heading-1" id="_idParaDest-260"><span class="koboSpan" id="kobo.3556.1">Exercises</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3557.1">Try to implement a concurrent version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3558.1">wc(1)</span></code><span class="koboSpan" id="kobo.3559.1"> that uses a buffered channel.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3560.1">Try to implement a concurrent version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3561.1">wc(1)</span></code><span class="koboSpan" id="kobo.3562.1"> that uses shared memory.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3563.1">Try to implement a concurrent version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3564.1">wc(1)</span></code><span class="koboSpan" id="kobo.3565.1"> that uses semaphores.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3566.1">Try to implement a concurrent version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3567.1">wc(1)</span></code><span class="koboSpan" id="kobo.3568.1"> that saves its output to a file.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-261"><span class="koboSpan" id="kobo.3569.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3570.1">The documentation page of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3571.1">sync</span></code><span class="koboSpan" id="kobo.3572.1">: </span><a href="https://pkg.go.dev/sync"><span class="url"><span class="koboSpan" id="kobo.3573.1">https://pkg.go.dev/sync</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3574.1">Learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3575.1">semaphore</span></code><span class="koboSpan" id="kobo.3576.1"> package: </span><a href="https://pkg.go.dev/golang.org/x/sync/semaphore"><span class="url"><span class="koboSpan" id="kobo.3577.1">https://pkg.go.dev/golang.org/x/sync/semaphore</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3578.1">Coroutines for Go: </span><a href="https://research.swtch.com/coro"><span class="url"><span class="koboSpan" id="kobo.3579.1">https://research.swtch.com/coro</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3580.1">Learn more about the Go scheduler by reading a series of posts: </span><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html"><span class="url"><span class="koboSpan" id="kobo.3581.1">https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3582.1">The implementation of the Go scheduler: </span><a href="https://go.dev/src/runtime/proc.go "><span class="url"><span class="koboSpan" id="kobo.3583.1">https://go.dev/src/runtime/proc.go</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.3584.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3585.1">Join our community’s Discord space for discussions with the authors and other readers:</span></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.3586.1">https://discord.gg/FzuQbc8zd6</span></span></a></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.3587.1"><img alt="" role="presentation" src="../Images/QR_Code2286825896190168453.png"/></span></span></a></p>
</div>
</body></html>