["```go\nfunc main() {\n    fmt.Print(\"You are using \", runtime.Compiler, \" \")\n    fmt.Println(\"on a\", runtime.GOARCH, \"machine\")\n    fmt.Println(\"Using Go version\", runtime.Version()) \n```", "```go\n fmt.Printf(\"GOMAXPROCS: %d\\n\", runtime.GOMAXPROCS(0))\n} \n```", "```go\nYou are using gc on a arm64 machine\nUsing Go version go1.21.0\nGOMAXPROCS: 10 \n```", "```go\n$ GOMAXPROCS=100; go run maxprocs.go\nYou are using gc on a amd64 machine\nUsing Go version go1.21.0\nGOMAXPROCS: 100 \n```", "```go\nfunc main() {\n    go func(x int) {\n        fmt.Printf(\"%d \", x)\n    }(10) \n```", "```go\n go printme(15) \n```", "```go\n time.Sleep(time.Second)\n    fmt.Println(\"Exiting...\")\n} \n```", "```go\n$ go run create.go \n10 * 15\nExiting... \n```", "```go\n$ go run create.go\n* 15\n10 Exiting... \n```", "```go\nfmt.Printf(\"Going to create %d goroutines.\\n\", count)\nfor i := 0; i < count; i++ { \n```", "```go\n go func(x int) {\n        fmt.Printf(\"%d \", x)\n    }(i)\n}\ntime.Sleep(time.Second)\nfmt.Println(\"\\nExiting...\") \n```", "```go\n$ go run multiple.go 15\nGoing to create 15 goroutines.\n3 0 8 4 5 6 7 11 9 12 14 13 1 2 10 \nExiting... \n```", "```go\ntype WaitGroup struct {\n    noCopy noCopy\n    state1 [3]uint32\n} \n```", "```go\nvar waitGroup sync.WaitGroup\nfmt.Printf(\"%#v\\n\", waitGroup) \n```", "```go\nfor i := 0; i < count; i++ {\n    waitGroup.Add(1) \n```", "```go\n go func(x int) {\n        defer waitGroup.Done() \n```", "```go\n fmt.Printf(\"%d \", x)\n    }(i)\n}\nfmt.Printf(\"%#v\\n\", waitGroup)\nwaitGroup.Wait() \n```", "```go\nfmt.Println(\"\\nExiting...\") \n```", "```go\n$ go run varGoroutines.go 15\nGoing to create 10 goroutines.\nsync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x0}, sema:0x0}\nsync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0xa00000000}, sema:0x0}\n14 8 9 10 11 5 0 4 1 2 3 6 13 12 7 \nExiting... \n```", "```go\n$ go run addDone.go\nGoing to create 20 goroutines.\nsync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x0}, sema:0x0}\nsync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x1300000000}, sema:0x0}\n19 3 4 5 6 7 8 9 10 11 12 13 14 15 16 2 1 17 18 0\nExiting...\npanic: sync: negative WaitGroup counter\ngoroutine 20 [running]:\nsync.(*WaitGroup).Add(0x1?, 0x1?)\n    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/waitgroup.go:62 +0x108\nsync.(*WaitGroup).Done(0x0?)\n    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/waitgroup.go:87 +0x20\nmain.main.func1(0x0?)\n    ~/go/src/github.com/mactsouk/mGo4th/ch08/addDone.go:26 +0x9c\ncreated by main.main in goroutine 1\n    ~/go/src/github.com/mactsouk/mGo4th/ch08/addDone.go:23 +0xec\nexit status 2 \n```", "```go\n$ go run addDone.go 1\nGoing to create 20 goroutines.\nsync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x0}, sema:0x0}\nsync.WaitGroup{noCopy:sync.noCopy{}, state:atomic.Uint64{_:atomic.noCopy{}, _:atomic.align64{}, v:0x1500000000}, sema:0x0}\n19 1 2 11 12 13 14 15 16 17 18 6 3 4 5 8 7 9 0 10 fatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [semacquire]:\nsync.runtime_Semacquire(0x0?)\n    /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/sema.go:62 +0x2c\nsync.(*WaitGroup).Wait(0x14000128030)\n    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/waitgroup.go:116 +0x78\nmain.main()\n    ~/go/src/github.com/mactsouk/mGo4th/code/ch08/addDone.go:38 +0x230\nexit status 2 \n```", "```go\nvar waitGroup sync.WaitGroup\nfor i := start; i <= end; i++ {\n    waitGroup.Add(1)\n\n    go func(n int) {\n        filepath := filepath.Join(path, fmt.Sprintf(\"%s%d\", filename, n))\n        defer waitGroup.Done()\n        createFile(filepath)\n    }(i)\n}\nwaitGroup.Wait() \n```", "```go\n$ go run randomFiles.go \nUsage: randomFiles firstInt lastInt filename directory \n```", "```go\n$ go run randomFiles.go 3 5 masterGo /tmp\n/tmp/masterGo3 created!\n/tmp/masterGo5 created!\n/tmp/masterGo4 created! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"sync\"\n)\nfunc writeToChannel(c chan int, x int) {\n    c <- x\n    close(c)\n} \n```", "```go\nfunc printer(ch chan bool) {\n    ch <- true\n} \n```", "```go\nfunc main() {\n    c := make(chan int, 1) \n```", "```go\n var waitGroup sync.WaitGroup\n    waitGroup.Add(1)\n    go func(c chan int) {\n        defer waitGroup.Done()\n        writeToChannel(c, 10)\n        fmt.Println(\"Exit.\")\n    }(c)\n    fmt.Println(\"Read:\", <-c) \n```", "```go\n _, ok := <-c\n    if ok {\n        fmt.Println(\"Channel is open!\")\n    } else {\n        fmt.Println(\"Channel is closed!\")\n    } \n```", "```go\n waitGroup.Wait()\n    var ch chan bool = make(chan bool)\n    for i := 0; i < 5; i++ {\n        go printer(ch)\n    } \n```", "```go\n // Range on channels\n// IMPORTANT: As the channel ch is not closed,\n// the range loop does not exit on its own.\n    n := 0\nfor i := range ch { \n```", "```go\n fmt.Println(i)\n        if i == true {\n            n++\n        }\n        if n > 2 {\n            fmt.Println(\"n:\", n)\n            close(ch)\n            break\n        }\n    } \n```", "```go\n for i := 0; i < 5; i++ {\n        fmt.Println(<-ch)\n    }\n} \n```", "```go\nExit.\nRead: 10 \n```", "```go\nChannel is closed!\ntrue\ntrue\ntrue \n```", "```go\nn: 3\nfalse\nfalse\nfalse\nfalse\nfalse \n```", "```go\nfunc main() {\n    willClose := make(chan complex64, 10) \n```", "```go\n // Write some data to the channel\n    willClose <- -1\n    willClose <- 1i \n```", "```go\n // Read data and empty channel\n    <-willClose\n    <-willClose\n    close(willClose) \n```", "```go\n // Read again - this is a closed channel\n    read := <-willClose\n    fmt.Println(read)\n} \n```", "```go\n(0+0i) \n```", "```go\nfunc printer(ch chan<- bool) {\n    ch <- true\n} \n```", "```go\nfunc writeToChannel(c chan<- int, x int) {\n    fmt.Println(\"1\", x)\n    c <- x\n    fmt.Println(\"2\", x)\n} \n```", "```go\nfunc f2(out <-chan int, in chan<- int) {\n    x := <-out\n    fmt.Println(\"Read (f2):\", x)\n    in <- x\n    return\n} \n```", "```go\n$ go run -race channels.go \nExit.\nRead: 10\nChannel is closed!\ntrue\ntrue\ntrue\nn: 3\n==================\nWARNING: DATA RACE\nWrite at 0x00c000094010 by main goroutine:\n  runtime.recvDirect()\n      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/chan.go:348 +0x7c\n  main.main()\n      ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:54 +0x444\nPrevious read at 0x00c000094010 by goroutine 10:\n  runtime.chansend1()\n      /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/chan.go:146 +0x2c\n  main.printer()\n      ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:14 +0x34\n  main.main.func3()\n      ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:40 +0x34\nGoroutine 10 (running) created at:\n  main.main()\n      ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:40 +0x2b8\n==================\nfalse\nfalse\nfalse\nfalse\nfalse\npanic: send on closed channel\ngoroutine 36 [running]:\nmain.printer(0x0?)\n    ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:14 +0x38\ncreated by main.main in goroutine 1\n    ~/go/src/github.com/mactsouk/mGo4th/ch08/channels.go:40 +0x2bc\nexit status 2 \n```", "```go\nfunc printer(ch chan<- bool, times int) {\n    for i := 0; i < times; i++ {\n        ch <- true\n    }\n    close(ch)\n}\nfunc main() {\n    // This is an unbuffered channel\nvar ch chan bool = make(chan bool)\n    // Write 5 values to channel with a single goroutine\ngo printer(ch, 5)\n    // IMPORTANT: As the channel ch is closed,\n// the range loop is going to exit on its own.\nfor val := range ch {\n        fmt.Print(val, \" \")\n    }\n    fmt.Println()\n    for i := 0; i < 15; i++ {\n        fmt.Print(<-ch, \" \")\n    }\n    fmt.Println()\n} \n```", "```go\ntrue true true true true \nfalse false false false false false false false false false false false false false false \n```", "```go\n wg.Add(1)\n    go func() {\n        gen(0, 2*n, createNumber, end)\n        wg.Done()\n    }() \n```", "```go\nfunc gen(min, max int, createNumber chan int, end chan bool) {\n    time.Sleep(time.Second)\n    for {\n        select {\n        case createNumber <- rand.Intn(max-min) + min:\n        case <-end:\n            fmt.Println(\"Ended!\")\n            // return \n```", "```go\n case <-time.After(4 * time.Second):\n            fmt.Println(\"time.After()!\")\n            return\n        }\n    }\n} \n```", "```go\n$ go run select.go 10\nGoing to create 10 random numbers.\n13 0 2 8 12 4 13 15 14 19 Ended!\ntime.After()!\nExiting... \n```", "```go\nfunc main() {\n    c1 := make(chan string)\n    go func() {\n        time.Sleep(3 * time.Second)\n        c1 <- \"c1 OK\"\n    }() \n```", "```go\n select {\n    case res := <-c1:\n        fmt.Println(res)\n    case <-time.After(time.Second):\n        fmt.Println(\"timeout c1\")\n    } \n```", "```go\n c2 := make(chan string)\n    go func() {\n        time.Sleep(3 * time.Second)\n        c2 <- \"c2 OK\"\n    }()\n    select {\n    case res := <-c2:\n        fmt.Println(res)\n    case <-time.After(4 * time.Second):\n        fmt.Println(\"timeout c2\")\n    }\n} \n```", "```go\n$ go run timeOut1.go \ntimeout c1\nc2 OK \n```", "```go\nfunc timeout(t time.Duration) {\n    temp := make(chan int)\n    go func() {\n        time.Sleep(5 * time.Second)\n        defer close(temp)\n    }()\n    select {\n    case <-temp:\n        result <- false\ncase <-time.After(t):\n        result <- true\n    }\n} \n```", "```go\n$ go run timeOut2.go 100\nTimeout period is 100ms\nTime out! \n```", "```go\n$ go run timeOut2.go 5500 \nTimeout period is 5.5s\nOK \n```", "```go\npackage main\nfunc main() {\n    var c chan string \n```", "```go\n close(c)\n} \n```", "```go\npanic: close of nil channel\ngoroutine 1 [running]:\nmain.main()\n    ~/go/src/github.com/mactsouk/mGo4th/ch08/closeNil.go:5 +0x20\nexit status 2 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() {\n    numbers := make(chan int, 5) \n```", "```go\n counter := 10\nfor i := 0; i < counter; i++ {\n        select {\n        // This is where the processing takes place\ncase numbers <- i * i:\n            fmt.Println(\"About to process\", i)\n        default:\n            fmt.Print(\"No space for \", i, \" \")\n        } \n```", "```go\n }\n    fmt.Println()\n    for {\n        select {\n        case num := <-numbers:\n            fmt.Print(\"*\", num, \" \")\n        default:\n            fmt.Println(\"Nothing left to read!\")\n            return\n        }\n    }\n} \n```", "```go\n$ go run bufChannel.go \nAbout to process 0\n. . .\nAbout to process 4\nNo space for 5 No space for 6 No space for 7 No space for 8 No space for 9 \n*0 *1 *4 *9 *16 Nothing left to read! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"math/rand\"\n\"sync\"\n\"time\"\n)\nvar wg sync.WaitGroup \n```", "```go\nfunc add(c chan int) {\n    sum := 0\n    t := time.NewTimer(time.Second)\n    for {\n        select {\n        case input := <-c:\n            sum = sum + input\n        case <-t.C:\n            c = nil\n            fmt.Println(sum)\n            wg.Done()\n        }\n    }\n} \n```", "```go\nfunc send(c chan int) {\n    for {\n        c <- rand.Intn(10)\n    }\n}\nfunc main() {\n    c := make(chan int)\n    rand.Seed(time.Now().Unix())\n    wg.Add(1)\n    go add(c)\n    go send(c)\n    wg.Wait()\n} \n```", "```go\n$ go run nilChannel.go \n11168960 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"runtime\"\n\"strconv\"\n\"sync\"\n\"time\"\n)\ntype Client struct {\n    id      int\n    integer int\n} \n```", "```go\ntype Result struct {\n    job    Client\n    square int\n} \n```", "```go\nvar size = runtime.GOMAXPROCS(0)\nvar clients = make(chan Client, size)\nvar data = make(chan Result, size) \n```", "```go\nfunc worker(wg *sync.WaitGroup) {\n    for c := range clients {\n        square := c.integer * c.integer\n        output := Result{c, square}\n        data <- output\n        time.Sleep(time.Second)\n    }\n    wg.Done()\n} \n```", "```go\nfunc create(n int) {\n    for i := 0; i < n; i++ {\n        c := Client{i, i}\n        clients <- c\n    }\n    close(clients)\n} \n```", "```go\nfunc main() {\n    if len(os.Args) != 3 {\n        fmt.Println(\"Need #jobs and #workers!\")\n        return\n    }\n    nJobs, err := strconv.Atoi(os.Args[1])\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    nWorkers, err := strconv.Atoi(os.Args[2])\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n go create(nJobs) \n```", "```go\n finished := make(chan interface{}) \n```", "```go\n go func() {\n        for d := range data {\n            fmt.Printf(\"Client ID: %d\\tint: \", d.job.id)\n            fmt.Printf(\"%d\\tsquare: %d\\n\", d.job.integer, d.square)\n        }\n        finished <- true \n```", "```go\n }()\n    var wg sync.WaitGroup\n    for i := 0; i < nWorkers; i++ {\n        wg.Add(1)\n        go worker(&wg)\n    }\n    wg.Wait()\n    close(data) \n```", "```go\n fmt.Printf(\"Finished: %v\\n\", <-finished)\n} \n```", "```go\n$ go run wPools.go 8 5\nClient ID: 0    int: 0    square: 0\nClient ID: 1    int: 1    square: 1\nClient ID: 2    int: 2    square: 4\nClient ID: 3    int: 3    square: 9\nClient ID: 4    int: 4    square: 16\nClient ID: 5    int: 5    square: 25\nClient ID: 6    int: 6    square: 36\nFinished: true \n```", "```go\nvar wg sync.WaitGroup\nfunc A(a, b chan struct{}) {\n    <-a\n    fmt.Println(\"A()!\")\n    time.Sleep(time.Second)\n    close(b)\n} \n```", "```go\nfunc B(a, b chan struct{}) {\n    <-a\n    fmt.Println(\"B()!\")\n    time.Sleep(3 * time.Second)\n    close(b)\n} \n```", "```go\nfunc C(a, b chan struct{}) {\n    <-a\n    fmt.Println(\"C()!\")\n    close(b)\n} \n```", "```go\nfunc D(a chan struct{}) {\n    <-a\n    fmt.Println(\"D()!\")\n    wg.Done()\n} \n```", "```go\nfunc main() {\n    x := make(chan struct{})\n    y := make(chan struct{})\n    z := make(chan struct{})\n    w := make(chan struct{}) \n```", "```go\n wg.Add(1)\n    go func() {\n        D(w)\n    }() \n```", "```go\n wg.Add(1)\n    go func() {\n        D(w)\n    }()\n    go A(x, y)\n    wg.Add(1)\n    go func() {\n        D(w)\n    }()\n    go C(z, w)\n    go B(y, z) \n```", "```go\n wg.Add(1)\n    go func() {\n        D(w)\n    }()\n    // This triggers the process\nclose(x) \n```", "```go\n wg.Wait()\n} \n```", "```go\n$ go run defineOrder.go\nA()!\nB()!\nC()!\nD()! D()! D()! D()! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"os/signal\"\n\"syscall\"\n\"time\"\n)\nfunc handleSignal(sig os.Signal) {\n    fmt.Println(\"handleSignal() Caught:\", sig)\n} \n```", "```go\nfunc main() {\n    fmt.Printf(\"Process ID: %d\\n\", os.Getpid())\n    sigs := make(chan os.Signal, 1) \n```", "```go\n signal.Notify(sigs) \n```", "```go\n start := time.Now()\n    go func() {\n        for {\n            sig := <-sigs \n```", "```go\n switch sig { \n```", "```go\n case syscall.SIGINT:\n                duration := time.Since(start)\n                fmt.Println(\"Execution time:\", duration) \n```", "```go\n case syscall.SIGINFO:\n                handleSignal(sig) \n```", "```go\n // do not use return here because the goroutine exits\n// but the time.Sleep() will continue to work!\n                os.Exit(0)\n            default:\n                fmt.Println(\"Caught:\", sig)\n            } \n```", "```go\n }\n    }()\n    for {\n        fmt.Print(\"+\")\n        time.Sleep(10 * time.Second)\n    }\n} \n```", "```go\n$ go run signals.go\nProcess ID: 70153\n+^CExecution time: 631.533125ms\n+Caught: user defined signal 1\n+Caught: urgent I/O condition\n+signal: killed \n```", "```go\nsignal.Notify(sigs, syscall.SIGINT, syscall.SIGINFO) \n```", "```go\ntype Mutex struct {\n    state int32\n    sema  uint32\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"strconv\"\n\"sync\"\n\"time\"\n)\nvar m sync.Mutex\nvar v1 int\nfunc change() {\n    m.Lock()\n    defer m.Unlock() \n```", "```go\n time.Sleep(time.Second)\n    v1 = v1 + 1\nif v1 == 10 {\n        v1 = 0\n        fmt.Print(\"* \")\n    } \n```", "```go\n}\nfunc read() int {\n    m.Lock()\n    a := v1\n    defer m.Unlock()\n    return a\n} \n```", "```go\n$ go run -race mutex.go 10\n0 -> 1-> 2-> 3-> 4-> 5-> 6-> 7-> 8-> 9* -> 0-> 0 \n```", "```go\nvar m sync.Mutex\nvar w sync.WaitGroup\nfunc function() {\n    m.Lock()\n    fmt.Println(\"Locked!\")\n} \n```", "```go\nLocked!\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [semacquire]:\nsync.runtime_Semacquire(0x140000021a0?)\n    /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/sema.go:62 +0x2c\nsync.(*WaitGroup).Wait(0x100fa1710)\n    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/waitgroup.go:116 +0x74\nmain.main()\n    ~/go/src/github.com/mactsouk/mGo4th/ch08/forgetMutex.go:29 +0x5c\ngoroutine 34 [sync.Mutex.Lock]:\nsync.runtime_SemacquireMutex(0x0?, 0x0?, 0x0?)\n    /opt/homebrew/Cellar/go/1.21.0/libexec/src/runtime/sema.go:77 +0x28\nsync.(*Mutex).lockSlow(0x100fa1520)\n    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/mutex.go:171 +0x174\nsync.(*Mutex).Lock(...)\n    /opt/homebrew/Cellar/go/1.21.0/libexec/src/sync/mutex.go:90\nmain.function()\n    ~/go/src/github.com/mactsouk/mGo4th/ch08/forgetMutex.go:12 +0x84\nmain.main.func1()\n    ~/go/src/github.com/mactsouk/mGo4th/ch08/forgetMutex.go:20 +0x50\ncreated by main.main in goroutine 1\n    ~/go/src/github.com/mactsouk/mGo4th/ch08/forgetMutex.go:18 +0x34\nexit status 2 \n```", "```go\ntype RWMutex struct {\n    w           Mutex\n    writerSem   uint32\n    readerSem   uint32\n    readerCount int32\n    readerWait  int32\n} \n```", "```go\nvar Password *secret\nvar wg sync.WaitGroup\ntype secret struct {\n    RWM      sync.RWMutex\n    password string\n} \n```", "```go\nfunc Change(pass string) {\n    if Password == nil {\n        fmt.Println(\"Password is nil!\")\n        return\n    }\n    fmt.Println(\"Change() function\")\n    Password.RWM.Lock() \n```", "```go\n fmt.Println(\"Change() Locked\")\n    time.Sleep(4 * time.Second)\n    Password.password = pass\n    Password.RWM.Unlock() \n```", "```go\n fmt.Println(\"Change() UnLocked\")\n} \n```", "```go\nfunc show () {\n    defer wg.Done()\n    defer Password.RWM.RUnlock()\n    Password.RWM.RLock()\n    fmt.Println(\"Show function locked!\")\n    time.Sleep(2 * time.Second)\n    fmt.Println(\"Pass value:\", Password.password)\n} \n```", "```go\n$ go run rwMutex.go\nChange() function \n```", "```go\nShow function locked!\nShow function locked! \n```", "```go\nChange() function \n```", "```go\nPass value: myPass\nPass value: myPass \n```", "```go\nChange() Locked\nChange() UnLocked \n```", "```go\nShow function locked!\nPass value: 54321 \n```", "```go\nChange() Locked\nChange() UnLocked\nCurrent password value: 123456 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"sync\"\n\"sync/atomic\"\n)\ntype atomCounter struct {\n    val int64\n} \n```", "```go\nfunc (c *atomCounter) Value() int64 {\n    return atomic.LoadInt64(&c.val)\n} \n```", "```go\nfunc main() {\n    X := 100\n    Y := 4\nvar waitGroup sync.WaitGroup\n    counter := atomCounter{}\n    for i := 0; i < X; i++ { \n```", "```go\n waitGroup.Add(1)\n        go func() {\n            defer waitGroup.Done()\n            for i := 0; i < Y; i++ {\n                atomic.AddInt64(&counter.val, 1)\n            } \n```", "```go\n }()\n    }\n    waitGroup.Wait()\n    fmt.Println(counter.Value())\n} \n```", "```go\n$ go run -race atomic.go\n400 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"math/rand\"\n\"os\"\n\"strconv\"\n\"sync\"\n\"time\"\n)\nvar readValue = make(chan int)\nvar writeValue = make(chan int)\nfunc set(newValue int) {\n    writeValue <- newValue\n} \n```", "```go\nfunc read() int {\n    return <-readValue\n} \n```", "```go\nfunc monitor() {\n    var value int\nfor {\n        select {\n        case newValue := <-writeValue:\n            value = newValue\n            fmt.Printf(\"%d \", value)\n        case readValue <- value:\n        }\n    }\n} \n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Println(\"Please give an integer!\")\n        return\n    }\n    n, err := strconv.Atoi(os.Args[1])\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Printf(\"Going to create %d random numbers.\\n\", n)\n    rand.Seed(time.Now().Unix())\n    go monitor() \n```", "```go\n var wg sync.WaitGroup\n    for r := 0; r < n; r++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            set(rand.Intn(10 * n))\n        }()\n    } \n```", "```go\n wg.Wait()\n    fmt.Printf(\"\\nLast value: %d\\n\", read())\n} \n```", "```go\n$ go run monitor.go 10\nGoing to create 10 random numbers.\n98 22 5 84 20 26 45 36 0 16 \nLast value: 16 \n```", "```go\nfunc main() {\n    for i := 0; i <= 20; i++ {\n        go func() {\n            fmt.Print(i, \" \")\n        }()\n    }\n    time.Sleep(time.Second)\n    fmt.Println()\n} \n```", "```go\n$ go run goClosure.go \n3 7 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 21 \n```", "```go\n$ go run -race goClosure.go\n5 4 5 5 ==================\nWARNING: DATA RACE\nRead at 0x00c00011e028 by goroutine 6:\n  main.main.func1()\n      ~/go/src/github.com/mactsouk/mGo4th/ch08/goClosure.go:11 +0x34\nPrevious write at 0x00c00011e028 by main goroutine:\n  main.main()\n      ~/go/src/github.com/mactsouk/mGo4th/ch08/goClosure.go:9 +0x5c\nGoroutine 6 (running) created at:\n  main.main()\n      ~/go/src/github.com/mactsouk/mGo4th/ch08/goClosure.go:10 +0x44\n==================\n8 8 6 10 12 11 15 15 15 18 20 20 21 15 21 21 21\nFound 1 data race(s)\nexit status 66 \n```", "```go\nfunc main() {\n    for i := 0; i <= 20; i++ {\n        i := i\n        go func() {\n            fmt.Print(i, \" \")\n        }()\n    } \n```", "```go\n time.Sleep(time.Second)\n    fmt.Println()\n    for i := 0; i <= 20; i++ {\n        go func(x int) {\n            fmt.Print(x, \" \")\n        }(i)\n    } \n```", "```go\n time.Sleep(time.Second)\n    fmt.Println()\n} \n```", "```go\n$ go run -race goClosureCorrect.go\n0 1 2 4 3 5 6 9 8 7 10 11 13 12 14 16 15 17 18 20 19\n0 1 2 3 4 5 6 7 8 10 9 12 13 11 14 15 16 17 18 19 20 \n```", "```go\npackage main\nimport (\n    \"context\"\n\"fmt\"\n\"os\"\n\"strconv\"\n\"time\"\n)\nfunc f1(t int) {\n    c1 := context.Background()\n    c1, cancel := context.WithCancel(c1)\n    defer cancel() \n```", "```go\n go func() {\n        time.Sleep(4 * time.Second)\n        cancel()\n    }()\n    select {\n    case <-c1.Done():\n        fmt.Println(\"f1() Done:\", c1.Err())\n        return\ncase r := <-time.After(time.Duration(t) * time.Second):\n        fmt.Println(\"f1():\", r)\n    }\n    return\n} \n```", "```go\nfunc f2(t int) {\n    c2 := context.Background()\n    c2, cancel := context.WithTimeout(c2, time.Duration(t)*time.Second)\n    defer cancel() \n```", "```go\n go func() {\n        time.Sleep(4 * time.Second)\n        cancel()\n    }()\n    select {\n    case <-c2.Done():\n        fmt.Println(\"f2() Done:\", c2.Err())\n        return\ncase r := <-time.After(time.Duration(t) * time.Second):\n        fmt.Println(\"f2():\", r)\n    }\n    return\n}\nfunc f3(t int) {\n    c3 := context.Background()\n    deadline := time.Now().Add(time.Duration(2*t) * time.Second)\n    c3, cancel := context.WithDeadline(c3, deadline)\n    defer cancel() \n```", "```go\n go func() {\n        time.Sleep(4 * time.Second)\n        cancel()\n    }()\n    select {\n    case <-c3.Done():\n        fmt.Println(\"f3() Done:\", c3.Err())\n        return\ncase r := <-time.After(time.Duration(t) * time.Second):\n        fmt.Println(\"f3():\", r)\n    }\n    return\n} \n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Println(\"Need a delay!\")\n        return\n    }\n    delay, err := strconv.Atoi(os.Args[1])\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"Delay:\", delay)\n    f1(delay)\n    f2(delay)\n    f3(delay)\n} \n```", "```go\n$ go run useContext.go 3\nDelay: 3\nf1(): 2023-08-28 16:23:22.300595 +0300 EEST m=+3.001225751\nf2(): 2023-08-28 16:23:25.302122 +0300 EEST m=+6.002730959\nf3(): 2023-08-28 16:23:28.303326 +0300 EEST m=+9.00391262 \n```", "```go\n$ go run useContext.go 13\nDelay: 13\nf1() Done: context canceled\nf2() Done: context canceled\nf3() Done: context canceled \n```", "```go\nfunc main() {\n    ctx := context.Background()\n    ctx, cancel := context.WithCancelCause(ctx)\n    cancel(errors.New(\"Canceled by timeout\"))\n    err := takingTooLong(ctx)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n} \n```", "```go\nfunc takingTooLong(ctx context.Context) error {\n    select {\n    case <-time.After(3 * time.Second):\n        fmt.Println(\"Done!\")\n        return nil\ncase <-ctx.Done():\n        fmt.Println(\"Canceled!\")\n        return context.Cause(ctx)\n    }\n} \n```", "```go\n$ go run withCancelCause.go\nCanceled!\nCanceled by timeout \n```", "```go\nfunc (s *Weighted) Acquire(ctx context.Context, n int64) error\nfunc (s *Weighted) Release(n int64) \n```", "```go\npackage main\nimport (\n    \"context\"\n\"fmt\"\n\"os\"\n\"strconv\"\n\"time\"\n\"golang.org/x/sync/semaphore\"\n)\nvar Workers = 4 \n```", "```go\nvar sem = semaphore.NewWeighted(int64(Workers)) \n```", "```go\nfunc worker(n int) int {\n    square := n * n\n    time.Sleep(time.Second)\n    return square\n} \n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Println(\"Need #jobs!\")\n        return\n    }\n    nJobs, err := strconv.Atoi(os.Args[1])\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n // Where to store the results\nvar results = make([]int, nJobs)\n    // Needed by Acquire()\n    ctx := context.TODO()\n    for i := range results {\n        err = sem.Acquire(ctx, 1)\n        if err != nil {\n            fmt.Println(\"Cannot acquire semaphore:\", err)\n            break\n        } \n```", "```go\n go func(i int) {\n            defer sem.Release(1)\n            temp := worker(i)\n            results[i] = temp\n        }(i)\n    } \n```", "```go\n err = sem.Acquire(ctx, int64(Workers))\n    if err != nil {\n        fmt.Println(err)\n    } \n```", "```go\n for k, v := range results {\n        fmt.Println(k, \"->\", v)\n    }\n} \n```", "```go\n$ go mod init\n$ go mod tidy\n$ mod download golang.org/x/sync \n```", "```go\n$ go run semaphore.go 3\n0 -> 0\n1 -> 1\n2 -> 4 \n```", "```go\nfunc main() {\n    if len(os.Args) == 1 {\n        fmt.Println(\"Need one or more file paths!\")\n        return\n    }\n    var waitGroup sync.WaitGroup\n    files = make(DFslice, len(os.Args)) \n```", "```go\n for i := 1; i < len(os.Args); i++ {\n        waitGroup.Add(1)\n        go func(x int) {\n            process(os.Args[x], x)\n            defer waitGroup.Done()\n        }(i)\n    }\n    waitGroup.Wait()\n} \n```", "```go\n$ wc dataset/*\n 1518653 1518653 4119086 dataset/1.5M\n 2531086 2531086 6918628 dataset/2.5M\n 4049739 4049739 11037714 dataset/4.0M\n 8099478 8099478 22075428 total \n```", "```go\n$ time go run stats.go ./dataset/* ./dataset/* ./dataset/*\nreal    0m1.240s\nuser    0m6.259s\nsys     0m0.528s\n$ time go run statsNC.go ./dataset/* ./dataset/* ./dataset/*\nreal    0m3.267s\nuser    0m7.766s\nsys     0m0.535s \n```"]