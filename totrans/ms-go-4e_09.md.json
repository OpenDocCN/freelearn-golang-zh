["```go\ntype Response struct {\n    Status     string // e.g. \"200 OK\"\n    StatusCode int // e.g. 200\n    Proto      string // e.g. \"HTTP/1.0\"\n    ProtoMajor int // e.g. 1\n    ProtoMinor int // e.g. 0\n    Header Header\n    Body io.ReadCloser \n    ContentLength int64\n    TransferEncoding []string\n    Close bool\n    Uncompressed bool\n    Trailer Header \n    Request *Request\n    TLS *tls.ConnectionState\n} \n```", "```go\ntype Request struct {\n    Method string\n    URL *url.URL\n    Proto  string\n    ProtoMajor int\n    ProtoMinor int\n    Header Header\n    Body io.ReadCloser\n    GetBody func() (io.ReadCloser, error)\n    ContentLength int64\n    TransferEncoding []string\n    Close bool\n    Host string\n    Form url.Values\n    PostForm url.Values\n    MultipartForm *multipart.Form\n    Trailer Header\n    RemoteAddr string\n    RequestURI string\n    TLS *tls.ConnectionState\n    Cancel <-chan struct{}\n    Response *Response\n} \n```", "```go\ntype Transport struct {\n    Proxy func(*Request) (*url.URL, error)\n    DialContext func(ctx context.Context, network, addr string) (net.Conn, error)\n    Dial func(network, addr string) (net.Conn, error)\n    DialTLSContext func(ctx context.Context, network, addr string) (net.Conn, error)\n    DialTLS func(network, addr string) (net.Conn, error)\n    TLSClientConfig *tls.Config\n    TLSHandshakeTimeout time.Duration\n    DisableKeepAlives bool\n    DisableCompression bool\n    MaxIdleConns int\n    MaxIdleConnsPerHost int\n    MaxConnsPerHost int\n    IdleConnTimeout time.Duration\n    ResponseHeaderTimeout time.Duration\n    ExpectContinueTimeout time.Duration\n    TLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper\n    ProxyConnectHeader Header\n    GetProxyConnectHeader func(ctx context.Context, proxyURL *url.URL, target string) (Header, error)\n    MaxResponseHeaderBytes int64\n    WriteBufferSize int\n    ReadBufferSize int\n    ForceAttemptHTTP2 bool\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"net/http\"\n\"os\"\n\"time\"\n)\nfunc myHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Serving: %s\\n\", r.URL.Path)\n    fmt.Printf(\"Served: %s\\n\", r.Host)\n} \n```", "```go\nfunc timeHandler(w http.ResponseWriter, r *http.Request) {\n    t := time.Now().Format(time.RFC1123)\n    Body := \"The current time is:\"\n    fmt.Fprintf(w, \"<h1 align=\\\"center\\\">%s</h1>\", Body)\n    fmt.Fprintf(w, \"<h2 align=\\\"center\\\">%s</h2>\\n\", t)\n    fmt.Fprintf(w, \"Serving: %s\\n\", r.URL.Path)\n    fmt.Printf(\"Served time for: %s\\n\", r.Host)\n} \n```", "```go\nfunc main() {\n    PORT := \":8001\" \n```", "```go\n arguments := os.Args\n    if len(arguments) != 1 {\n        PORT = \":\" + arguments[1]\n    }\n    fmt.Println(\"Using port number: \", PORT) \n```", "```go\n http.HandleFunc(\"/time\", timeHandler)\n    http.HandleFunc(\"/\", myHandler) \n```", "```go\n err := http.ListenAndServe(PORT, nil)\n    if err != nil {\n        fmt.Fprintln(os.Stderr, err)\n        os.Exit(1)\n    }\n} \n```", "```go\n$ go run wwwServer.go\nUsing port number:  :8001\nServed: localhost:8001\nServed time for: localhost:8001\nServed: localhost:8001 \n```", "```go\n$ curl localhost:8001\nServing: / \n```", "```go\n$ curl localhost:8001/time\n<h1 align=\"center\">The current time is:</h1><h2 align=\"center\">Thu, 31 Aug 2023 22:37:37 EEST</h2>\nServing: /time \n```", "```go\n$ curl localhost:8001/doesNotExist\nServing: /doesNotExist \n```", "```go\n$ cd ~/go/src/github.com/mactsouk/mGo4th/ch09/server\n$ touch handlers.go\n$ touch stats.go \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"log\"\n\"net/http\"\n\"strconv\"\n\"strings\"\n) \n```", "```go\nconst PORT = \":1234\" \n```", "```go\nfunc defaultHandler(w http.ResponseWriter, r *http.Request) {\n    log.Println(\"Serving:\", r.URL.Path, \"from\", r.Host)\n    w.WriteHeader(http.StatusOK)\n    body := \"Thanks for visiting!\\n\"\n    fmt.Fprintf(w, \"%s\", body)\n} \n```", "```go\nfunc deleteHandler(w http.ResponseWriter, r *http.Request) {\n    // Get dataset\n    paramStr := strings.Split(r.URL.Path, \"/\")\n    fmt.Println(\"Path:\", paramStr)\n    if len(paramStr) < 3 {\n        w.WriteHeader(http.StatusNotFound)\n        fmt.Fprintln(w, \"Not found:\", r.URL.Path)\n        return\n    } \n```", "```go\n log.Println(\"Serving:\", r.URL.Path, \"from\", r.Host) \n```", "```go\n dataset := paramStr[2]\n    err := deleteEntry(dataset)\n    if err != nil {\n        fmt.Println(err)\n        Body := err.Error() + \"\\n\"\n        w.WriteHeader(http.StatusNotFound)\n        fmt.Fprintf(w, \"%s\", Body)\n        return\n    } \n```", "```go\n body := dataset + \" deleted!\\n\"\n    w.WriteHeader(http.StatusOK)\n    fmt.Fprintf(w, \"%s\", body)\n} \n```", "```go\nfunc listHandler(w http.ResponseWriter, r *http.Request) {\n    log.Println(\"Serving:\", r.URL.Path, \"from\", r.Host)\n    w.WriteHeader(http.StatusOK)\n    body := list()\n    fmt.Fprintf(w, \"%s\", body)\n} \n```", "```go\nfunc statusHandler(w http.ResponseWriter, r *http.Request) {\n    log.Println(\"Serving:\", r.URL.Path, \"from\", r.Host)\n    w.WriteHeader(http.StatusOK)\n    body := fmt.Sprintf(\"Total entries: %d\\n\", len(data))\n    fmt.Fprintf(w, \"%s\", body)\n} \n```", "```go\nfunc insertHandler(w http.ResponseWriter, r *http.Request) {\n    paramStr := strings.Split(r.URL.Path, \"/\")\n    fmt.Println(\"Path:\", paramStr)\n    if len(paramStr) < 4 {\n        w.WriteHeader(http.StatusBadRequest)\n        fmt.Fprintln(w, \"Not enough arguments: \"+r.URL.Path)\n        return\n    } \n```", "```go\n dataset := paramStr[2]\n    // These are string values\n    dataStr := paramStr[3:]\n    data := make([]float64, 0)\n    for _, v := range dataStr {\n        val, err := strconv.ParseFloat(v, 64)\n        if err == nil {\n            data = append(data, val)\n        }\n    } \n```", "```go\n entry := process(dataset, data)\n    err := insert(&entry)\n    if err != nil {\n        w.WriteHeader(http.StatusNotModified)\n        Body := \"Failed to add record\\n\"\n        fmt.Fprintf(w, \"%s\", Body)\n    } else {\n        Body := \"New record added successfully\\n\"\n        w.WriteHeader(http.StatusOK)\n        fmt.Fprintf(w, \"%s\", Body)\n    }\n    log.Println(\"Serving:\", r.URL.Path, \"from\", r.Host)\n} \n```", "```go\nfunc searchHandler(w http.ResponseWriter, r *http.Request) {\n    // Get Search value from URL\n    paramStr := strings.Split(r.URL.Path, \"/\")\n    fmt.Println(\"Path:\", paramStr)\n    if len(paramStr) < 3 {\n        w.WriteHeader(http.StatusNotFound)\n        fmt.Fprintln(w, \"Not found: \"+r.URL.Path)\n        return\n    }\n    var body string\n    dataset := paramStr[2] \n```", "```go\n t := search(dataset)\n    if t == nil {\n        w.WriteHeader(http.StatusNotFound)\n        body = \"Could not be found: \" + dataset + \"\\n\"\n    } else {\n        w.WriteHeader(http.StatusOK)\n        body = fmt.Sprintf(\"%s %d %f %f\\n\", t.Name, t.Len, t.Mean, t.StdDev)\n    }\n    log.Println(\"Serving:\", r.URL.Path, \"from\", r.Host)\n    fmt.Fprintf(w, \"%s\", body)\n} \n```", "```go\nfunc main() {\n    err := readJSONFile(JSONFILE)\n    if err != nil && err != io.EOF {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    createIndex() \n```", "```go\n mux := http.NewServeMux()\n    s := &http.Server{\n        Addr:         PORT,\n        Handler:      mux,\n        IdleTimeout:  10 * time.Second,\n        ReadTimeout:  time.Second,\n        WriteTimeout: time.Second,\n    } \n```", "```go\n mux.Handle(\"/list\", http.HandlerFunc(listHandler))\n    mux.Handle(\"/insert/\", http.HandlerFunc(insertHandler))\n    mux.Handle(\"/insert\", http.HandlerFunc(insertHandler))\n    mux.Handle(\"/search\", http.HandlerFunc(searchHandler))\n    mux.Handle(\"/search/\", http.HandlerFunc(searchHandler))\n    mux.Handle(\"/delete/\", http.HandlerFunc(deleteHandler))\n    mux.Handle(\"/status\", http.HandlerFunc(statusHandler))\n    mux.Handle(\"/\", http.HandlerFunc(defaultHandler)) \n```", "```go\n fmt.Println(\"Ready to serve at\", PORT)\n    err = s.ListenAndServe()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n} \n```", "```go\n$ go run stats.go handlers.go\nReady to serve at :1234\n2023/08/31 17:10:10 Serving: /list from localhost:1234\nPath: [ delete d1]\n2023/08/31 17:10:20 Serving: /delete/d1 from localhost:1234\nPath: [ delete d2]\n2023/08/31 17:10:22 Serving: /delete/d2 from localhost:1234\nPath: [ delete d1]\n2023/08/31 17:10:23 Serving: /delete/d1 from localhost:1234\nd1 cannot be found!\n2023/08/31 17:11:01 Serving: /status from localhost:1234\nPath: [ search d3]\n2023/08/31 17:11:26 Serving: /search/d3 from localhost:1234\nPath: [ search d2]\n2023/08/31 17:11:29 Serving: /search/d2 from localhost:1234\nPath: [ search d5]\n2023/08/31 17:11:30 Serving: /search/d5 from localhost:1234\nPath: [ search d4]\n2023/08/31 17:11:32 Serving: /search/d4 from localhost:1234\nPath: [ insert v1 1.0 2 3 4 5 ]\n2023/08/31 17:16:23 Serving: /insert/v1/1.0/2/3/4/5/ from localhost:1234\nPath: [ insert v1 1.0 2 3 4 5 ]\n2023/08/31 17:16:34 Serving: /insert/v1/1.0/2/3/4/5/ from localhost:1234\nPath: [ insert v2 1.0 2 3 4 5 -5 -3 ]\n2023/08/31 17:17:21 Serving: /insert/v2/1.0/2/3/4/5/-5/-3/ from localhost:1234 \n```", "```go\n$ curl localhost:1234/list\nd6    4    2.325000    1.080220\nd4    5    2.860000    1.441666\nd1    6    2.216667    1.949715\nd2    9    1.000000    0.000000\nd0    12    0.333333    0.942809 \n```", "```go\n$ curl localhost:1234/delete/d1\nd1 deleted! \n```", "```go\n$ curl localhost:1234/delete/d2\nd2 deleted!\n$ curl localhost:1234/delete/d1\nd1 cannot be found! \n```", "```go\n$ curl localhost:1234/status\nTotal entries: 3 \n```", "```go\n$ curl localhost:1234/search/d3\nCould not be found: d3\n$ curl localhost:1234/search/d4\nd4 5 2.860000 1.44166 \n```", "```go\n$ curl localhost:1234/delete\n<a href=\"/delete/\">Moved Permanently</a>. \n```", "```go\n$ curl localhost:1234/insert/v1/1.0/2/3/4/5/\nNew record added successfully\n$ curl localhost:1234/insert/v2/1.0/2/3/4/5/-5/-3/\nNew record added successfully \n```", "```go\nFROM golang:alpine AS builder\n# Install git.\n# Git is required for fetching the dependencies.\nRUN apk update && apk add --no-cache git\nRUN mkdir $GOPATH/src/server\nADD ./stats.go $GOPATH/src/server\nADD ./handlers.go $GOPATH/src/server\nWORKDIR $GOPATH/src/server\nRUN go mod init\nRUN go mod tidy\nRUN mkdir /pro\nRUN go build -o /pro/server stats.go handlers.go\nFROM alpine:latest\nRUN mkdir /pro\nCOPY --from=builder /pro/server /pro/server\nEXPOSE 1234\nWORKDIR /pro\nCMD [\"/pro/server\"] \n```", "```go\n$ docker build -f buildDocker -t goapp .\n. . .\nSuccessfully built 56d0b84b0ab5\nSuccessfully tagged goapp:latest \n```", "```go\nversion: \"3\"\nservices:\ngoapp:\n**image:****goapp**\n**container_name:****goapp**\nrestart: always\nports:\n- 1234:1234\nnetworks:\n- services\nnetworks:\nservices:\ndriver: bridge \n```", "```go\n$ docker-compose up\n[+] Running 2/0\n  Network server_services  Created  0.0s\n  Container goapp          Created  0.0s\nAttaching to goapp\ngoapp  | Ready to serve at :1234\ngoapp  | 2023/08/31 13:32:54 Serving: /status from think:1234 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"io\"\n\"net/http\"\n\"os\"\n\"path/filepath\"\n)\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Printf(\"Usage: %s URL\\n\", filepath.Base(os.Args[0]))\n        return\n    } \n```", "```go\n URL := os.Args[1]\n    data, err := http.Get(URL) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n        return\n    }\n    _, err = io.Copy(os.Stdout, data.Body) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n        return\n    }\n    data.Body.Close()\n} \n```", "```go\n$ go run simpleClient.go https://www.golang.org\n<!DOCTYPE html>\n<html lang=\"en\" data-theme=\"auto\">\n<head>\n<link rel=\"preconnect\" href=\"https://www.googletagmanager.com\">\n...\n</body>\n</html> \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"net/http\"\n\"net/http/httputil\"\n\"net/url\"\n\"os\"\n\"path/filepath\"\n\"strings\"\n\"time\"\n)\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Printf(\"Usage: %s URL\\n\", filepath.Base(os.Args[0]))\n        return\n    } \n```", "```go\n URL, err := url.Parse(os.Args[1])\n    if err != nil {\n        fmt.Println(\"Error in parsing:\", err)\n        return\n    } \n```", "```go\n c := &http.Client{\n        Timeout: 15 * time.Second,\n    }\n    request, err := http.NewRequest(http.MethodGet, URL.String(), nil)\n    if err != nil {\n        fmt.Println(\"Get:\", err)\n        return\n    } \n```", "```go\n httpData, err := c.Do(request)\n    if err != nil {\n        fmt.Println(\"Error in Do():\", err)\n        return\n    } \n```", "```go\n fmt.Println(\"Status code:\", httpData.Status) \n```", "```go\n header, _ := httputil.DumpResponse(httpData, false)\n    fmt.Print(string(header)) \n```", "```go\n contentType := httpData.Header.Get(\"Content-Type\")\n    characterSet := strings.SplitAfter(contentType, \"charset=\")\n    if len(characterSet) > 1 {\n        fmt.Println(\"Character Set:\", characterSet[1])\n    } \n```", "```go\n if httpData.ContentLength == -1 {\n        fmt.Println(\"ContentLength is unknown!\")\n    } else {\n        fmt.Println(\"ContentLength:\", httpData.ContentLength)\n    } \n```", "```go\n length := 0\nvar buffer [1024]byte\n    r := httpData.Body\n    for {\n        n, err := r.Read(buffer[0:])\n        if err != nil {\n            fmt.Println(err)\n                break\n        }\n        length = length + n\n    }\n    fmt.Println(\"Calculated response data length:\", length)\n} \n```", "```go\n$ go run wwwClient.go https://www.golang.org\nStatus code: 200 OK \n```", "```go\nHTTP/2.0 200 OK\nCache-Control: private\nContent-Security-Policy: connect-src 'self' www.google-analytics.com stats.g.doubleclick.net ; default-src 'self' ; font-src 'self' fonts.googleapis.com fonts.gstatic.com data: ; frame-ancestors 'self' ; frame-src 'self' www.google.com feedback.googleusercontent.com www.googletagmanager.com scone-pa.clients6.google.com www.youtube.com player.vimeo.com ; img-src 'self' www.google.com www.google-analytics.com ssl.gstatic.com www.gstatic.com gstatic.com data: * ; object-src 'none' ; script-src 'self' 'sha256-n6OdwTrm52KqKm6aHYgD0TFUdMgww4a0GQlIAVrMzck=' 'sha256-4ryYrf7Y5daLOBv0CpYtyBIcJPZkRD2eBPdfqsN3r1M=' 'sha256-sVKX08+SqOmnWhiySYk3xC7RDUgKyAkmbXV2GWts4fo=' www.google.com apis.google.com www.gstatic.com gstatic.com support.google.com www.googletagmanager.com www.google-analytics.com ssl.google-analytics.com tagmanager.google.com ; style-src 'self' 'unsafe-inline' fonts.googleapis.com feedback.googleusercontent.com www.gstatic.com gstatic.com tagmanager.google.com ;\nContent-Type: text/html; charset=utf-8\nDate: Fri, 01 Sep 2023 19:12:13 GMT\nServer: Google Frontend\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\nVary: Accept-Encoding\nX-Cloud-Trace-Context: 63a0ba25023e0ff4d5b5ccb87ef286bc \n```", "```go\nCharacter Set: utf-8\nContentLength is unknown!\nEOF\nCalculated response data length: 61870 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"net/http\"\n\"os\"\n\"golang.org/x/sync/errgroup\"\n)\nfunc main() {\n    if len(os.Args) == 1 {\n        fmt.Println(\"Not enough arguments!\")\n        return\n    }\n    g := new(errgroup.Group) \n```", "```go\n for _, url := range os.Args[1:] {\n        url := url\n        g.Go(func() error {\n            resp, err := http.Get(url)\n            if err != nil {\n                return err\n            }\n            defer resp.Body.Close()\n            fmt.Println(url, \"is OK.\")\n            return nil\n        })\n    }\n    err := g.Wait()\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Everything went fine!\")\n} \n```", "```go\n$ go mod init\n$ go mod tidy \n```", "```go\n$ go run eGroup.go https://golang.org https://www.mtsoukalos.eu/\nhttps://www.mtsoukalos.eu/ is OK.\nhttps://golang.org is OK.\nEverything went fine! \n```", "```go\n$ go run eGroup.go https://golang.org https://www.mtsoukalos.eu/\nhttps://golang.org is OK.\nError: Get \"https://www.mtsoukalos.eu/\": tls: failed to verify certificate: x509: certificate signed by unknown authority \n```", "```go\n$ cd ~/go/src/github.com/mactsouk/mGo4th/ch09/client\n$ go mod init\n$ ~/go/bin/cobra init\n$ ~/go/bin/cobra add search\n$ ~/go/bin/cobra add insert\n$ ~/go/bin/cobra add delete\n$ ~/go/bin/cobra add status\n$ ~/go/bin/cobra add list \n```", "```go\nfunc init() {\n    rootCmd.PersistentFlags().StringP(\"server\", \"S\", \"localhost\", \"Server\")\n    rootCmd.PersistentFlags().StringP(\"port\", \"P\", \"1234\", \"Port number\")\n    viper.BindPFlag(\"server\", rootCmd.PersistentFlags().Lookup(\"server\"))\n    viper.BindPFlag(\"port\", rootCmd.PersistentFlags().Lookup(\"port\"))\n} \n```", "```go\nSERVER := viper.GetString(\"server\")\nPORT := viper.GetString(\"port\") \n```", "```go\n// Create request\nURL := \"http://\" + SERVER + \":\" + PORT + \"/status\" \n```", "```go\ndata, err := http.Get(URL)\nif err != nil {\n    fmt.Println(err)\n    return\n} \n```", "```go\n// Check HTTP Status Code\nif data.StatusCode != http.StatusOK {\n    fmt.Println(\"Status code:\", data.StatusCode)\n    return\n} \n```", "```go\n// Read data\nresponseData, err := io.ReadAll(data.Body)\nif err != nil {\n    fmt.Println(err)\n    return\n}\nfmt.Print(string(responseData)) \n```", "```go\nURL := \"http://\" + SERVER + \":\" + PORT + \"/list\" \n```", "```go\n SERVER := viper.GetString(\"server\")\n        PORT := viper.GetString(\"port\")\n        dataset, _ := cmd.Flags().GetString(\"dataset\")\n        if dataset == \"\" {\n            fmt.Println(\"Number is empty!\")\n            return\n        } \n```", "```go\n URL := \"http://\" + SERVER + \":\" + PORT + \"/delete/\" + dataset \n```", "```go\n data, err := http.Get(URL)\n        if err != nil {\n            fmt.Println(err)\n            return\n        } \n```", "```go\n if data.StatusCode != http.StatusOK {\n            fmt.Println(\"Status code:\", data.StatusCode)\n            return\n        } \n```", "```go\n responseData, err := io.ReadAll(data.Body)\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        fmt.Print(string(responseData)) \n```", "```go\nURL := \"http://\" + SERVER + \":\" + PORT + \"/search/\" + dataset \n```", "```go\n insertCmd.Flags().StringP(\"dataset\", \"d\", \"\", \"Dataset name\")\n    insertCmd.Flags().StringP(\"values\", \"v\", \"\", \"List of values\") \n```", "```go\n SERVER := viper.GetString(\"server\")\n    PORT := viper.GetString(\"port\") \n```", "```go\n dataset, _ := cmd.Flags().GetString(\"dataset\")\n        if dataset == \"\" {\n            fmt.Println(\"Dataset is empty!\")\n            return\n        }\n        values, _ := cmd.Flags().GetString(\"values\")\n        if values == \"\" {\n            fmt.Println(\"No data!\")\n            return\n        } \n```", "```go\n VALS := strings.Split(values, \",\")\n        vSend := \"\"\nfor _, v := range VALS {\n            _, err := strconv.ParseFloat(v, 64)\n            if err == nil {\n                vSend = vSend + \"/\" + v\n            }\n        } \n```", "```go\n URL := \"http://\" + SERVER + \":\" + PORT + \"/insert/\"\n        URL = URL + \"/\" + dataset + \"/\" + vSend + \"/\" \n```", "```go\ndata, err := http.Get(URL)\nif err != nil {\n    fmt.Println(\"**\", err)\n    return\n} \n```", "```go\nif data.StatusCode != http.StatusOK {\n    fmt.Println(\"Status code:\", data.StatusCode)\n    return\n} \n```", "```go\nresponseData, err := io.ReadAll(data.Body)\nif err != nil {\n    fmt.Println(\"*\", err)\n    return\n}\nfmt.Print(string(responseData)) \n```", "```go\n$ go run main.go list\nList of entries:\nd6    4    2.325000    1.080220\nd4    5    2.860000    1.441666\nd2    9    1.000000    0.000000\nv1    5    3.000000    1.414214\nv2    7    1.000000    3.422614 \n```", "```go\n$ go run main.go status\nTotal entries: 5 \n```", "```go\n$ go run main.go search -d v1\nv1 5 3.000000 1.414214 \n```", "```go\n$ go run main.go search -d notThere\nStatus code: 404 \n```", "```go\n$ go run main.go delete -d v1\nv1 deleted! \n```", "```go\n$ go run main.go insert -d n1 -v 1,2,3,-4,0,0\nNew record added successfully \n```", "```go\nvar timeout = time.Duration(time.Second)\nfunc Timeout(network, host string) (net.Conn, error) {\n    conn, err := net.DialTimeout(network, host, timeout)\n    if err != nil {\n        return nil, err\n    }\n    conn.SetDeadline(time.Now().Add(timeout))\n    return conn, nil\n} \n```", "```go\nt := http.Transport{\n    Dial: Timeout,\n}\nclient := http.Client{\n        Transport: &t,\n} \n```", "```go\n$ go run withDeadline.go http://www.golang.org\nTimeout value: 1s\n<!DOCTYPE html>\n... \n```", "```go\n$ go run withDeadline.go http://localhost:80\nTimeout value: 1s\nGet \"http://localhost:80\": read tcp 127.0.0.1:52492->127.0.0.1:80: i/o timeout \n```", "```go\npackage main\nimport (\n    \"context\"\n\"fmt\"\n\"io\"\n\"net/http\"\n\"os\"\n\"strconv\"\n\"time\"\n)\nvar delay int = 5 \n```", "```go\nfunc main() {\n    if len(os.Args) == 1 {\n        fmt.Println(\"Need a URL and a delay!\")\n        os.Exit(1)\n    }\n    url := os.Args[1]\n    if len(os.Args) == 3 {\n      t, err := strconv.Atoi(os.Args[2])\n      if err != nil {\n         fmt.Println(err)\n         return\n      }\n      delay = t\n   }\n    fmt.Println(\"Delay:\", delay) \n```", "```go\n ctx, cncl := context.WithTimeout(context.Background(), time.Second * time.Duration(delay))\n    defer cncl()\n    req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    res, err := http.DefaultClient.Do(req.WithContext(ctx))\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer res.Body.Close()\n    body, err := io.ReadAll(res.Body)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(string(body))\n} \n```", "```go\n$ go run timeoutClient.go http://localhost:1234 5\nDelay: 5\nGet \"http://localhost:1234\": context deadline exceeded \n```", "```go\nfunc main() {\n    PORT := \":8001\"\n    arguments := os.Args\n    if len(arguments) != 1 {\n        PORT = \":\" + arguments[1]\n    }\n    fmt.Println(\"Using port number: \", PORT)\n    m := http.NewServeMux()\n    srv := &http.Server{\n        Addr:         PORT,\n        Handler:      m,\n        ReadTimeout:  3 * time.Second,\n        WriteTimeout: 3 * time.Second,\n    } \n```", "```go\n m.HandleFunc(\"/time\", timeHandler)\n    m.HandleFunc(\"/\", myHandler)\n    err := srv.ListenAndServe()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n} \n```"]