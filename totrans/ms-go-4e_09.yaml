- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core subject of this chapter is working with HTTP using the `net/http` package—keep
    in mind that all web services require a web server to operate. Additionally, in
    this chapter, we are going to convert the statistics application into a web application
    that accepts HTTP connections and create a command line client to work with it.
    In the last part of the chapter, we are going to learn how to time out HTTP connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, this chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: The `net/http` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the statistics application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing web clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a client for the statistics service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timing out HTTP connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The net/http package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http` package offers functions that allow you to develop web servers
    and clients. For example, `http.Get()` and `http.NewRequest()` are used by clients
    to make HTTP requests, whereas `http.ListenAndServe()` is used to start web servers
    by specifying the IP address and the TCP port that the server listens to. Additionally,
    `http.HandleFunc()` defines supported URLs as well as the functions that are going
    to handle these URLs.
  prefs: []
  type: TYPE_NORMAL
- en: The next three subsections describe three important data structures of the `net/http`
    package—you can use these descriptions as a reference while reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The http.Response type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `http.Response` struct embodies the response from an HTTP request—both
    `http.Client` and `http.Transport` return `http.Response` values once the response
    headers have been received. Its definition can be found at [https://go.dev/src/net/http/response.go](https://go.dev/src/net/http/response.go):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You do not have to use all the structure fields, but it is good to know that
    they exist. However, some of them, such as `Status`, `StatusCode`, and `Body`,
    are more important than others. The Go source file, as well as the output of `go
    doc http.Response`, contains more information about the purpose of each field,
    which is also the case with most `struct` data types found in the standard Go
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The http.Request type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `http.Request` structure represents an HTTP request as constructed by a
    client in order to be sent or received by an HTTP server. The public fields of
    `http.Request` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Body` field holds the body of the request. After reading the body of a
    request, you are allowed to call `GetBody()`, which returns a new copy of the
    body—this is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now present the `http.Transport` structure.
  prefs: []
  type: TYPE_NORMAL
- en: The http.Transport type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definition of `http.Transport`, which gives you more control over your
    HTTP connections, is fairly long and complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that `http.Transport` is **low-level** compared to `http.Client`.
    The latter implements a high-level HTTP client—each `http.Client` contains a `Transport`
    field. If its value is `nil`, then `DefaultTransport` is used. You do not need
    to use `http.Transport` in all of your programs, and you are not required to deal
    with all of its fields all the time. To learn more about `DefaultTransport`, type
    `go doc http.DefaultTransport`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now learn how to develop a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents a simple web server developed in Go to better understand
    the principles behind such applications. Although a web server programmed in Go
    can do many things efficiently and securely, if what you really need is a powerful
    web server that supports modules, multiple websites, and virtual hosts, then you
    would be better off using a web server such as Apache, Nginx, or Caddy that is
    written in Go. Those powerful web servers typically are in front of Go application
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might ask why the presented web server uses HTTP instead of secure HTTP
    (HTTPS). The answer to this question is simple: most Go web servers are deployed
    as Docker images and are hidden behind web servers, such as Caddy and Nginx, that
    provide the secure HTTP operation part using the appropriate security credentials.
    It does not make any sense to use the secure HTTP protocol along with the required
    security credentials without knowing how, and under which domain name, an application
    is going to be deployed.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a common practice in microservices as well as regular web applications
    that are deployed as Docker images. So this is a design decision that is a common
    practice for such cases. However, your requirements might differ.
  prefs: []
  type: TYPE_NORMAL
- en: The `net/http` package offers functions and data types that allow you to develop
    powerful web servers and clients. The `http.Set()` and `http.Get()` methods can
    be used to make HTTP and HTTPS requests, whereas `http.ListenAndServe()` is used
    for creating web servers given the user-specified handler function or functions
    that handle incoming requests. As most web services require support for multiple
    endpoints, you end up needing multiple discrete functions to handle incoming requests,
    which also leads to the better design of your services.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to define the supported endpoints, as well as the handler function
    that responds to each client request, is with the use of `http.HandleFunc()`,
    which can be called multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this quick and somewhat theoretical introduction, it is time to begin
    talking about more practical topics, beginning with the implementation of a simple
    web server, as illustrated in `wwwServer.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a handler function that sends a message back to the client using the
    `w http.ResponseWriter`, which is an interface that implements `io.Writer` and
    is used to send the server response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is another handler function called `timeHandler` that returns the current
    time in the HTML format. All `fmt.Fprintf()` calls send data back to the HTTP
    client, whereas the output of `fmt.Printf()` is printed on the terminal that the
    web server runs on. The first argument of `fmt.Fprintf()` is the `w http.ResponseWriter`,
    which implements `io.Writer` and, therefore, can accept data for writing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is where you define the port number that your web server is going to listen
    to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you use port number `0`, you are going to get a randomly selected free port,
    which is pretty handy for testing or when you do not want to specify the port
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want to use the predefined port number (`8001`), then you should
    provide `wwwServer.go` with your own port number as a command line argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, the web server supports the `/time` URL as well as `/`. The `/` path matches
    every URL not matched by other handlers. The fact that we associate `myHandler()`
    with `/` makes `myHandler()` the default handler function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `http.ListenAndServe()` call begins the HTTP server using the predefined
    port number. As there is no hostname given in the `PORT` string, the web server
    is going to listen to all available network interfaces. The port number and the
    hostname should be separated with a colon (`:`), which should be there even if
    there is no hostname—in that case, the server listens to all available network
    interfaces and, therefore, all supported hostnames. This is the reason that the
    value of `PORT` is `:8001` instead of just `8001`.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the `net/http` package is the `ServeMux` struct (`go doc http.ServeMux`),
    which is an HTTP request multiplexer that provides a slightly different way of
    defining handler functions and endpoints than the default one, which is used in
    `wwwServer.go`. So if we do not create and configure our own `ServeMux` variable,
    then `http.HandleFunc()` uses `DefaultServeMux`, which is the default `ServeMux`.
    So in this case, we are going to implement the web service using the default Go
    router—this is the reason that the second parameter of `http.ListenAndServe()`
    is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `wwwServer.go` and interacting with it using `curl(1)` produces the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that as `wwwServer.go` does not terminate automatically, you need to stop
    it on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `curl(1)` side, the interaction looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this first case, we visit the `/` path of the web server, and we are served
    by `myHandler()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we visit `/time`, and we get HTML output back from `timeHandler()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this last case, we visit `/doesNotExist`, which does not exist. As this cannot
    be matched by any other path, it is served by the default handler, which is the
    `myHandler()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is about making the statistics application a web application!
  prefs: []
  type: TYPE_NORMAL
- en: Updating the statistics application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, the statistics application is going to work as a web service. The
    two main tasks that need to be performed are defining the API along with the endpoints
    and implementing the API. A third task that needs to be determined concerns data
    exchange between the application server and its clients. There exist many approaches
    regarding data exchange between the server and its clients. We are going to discuss
    the following four ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using plain text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a hybrid approach that combines plain text and JSON data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As JSON is explored in *Chapter 11*, *Working with REST APIs*, and HTML might
    not be the best option for a service because you need to separate the data from
    the HTML tags and parse the data, we are going to use the first approach. Therefore,
    the service is going to work with plain text data. We begin by defining the API
    that supports the operation of the statistics application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The API has support for the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/list`: This lists all available entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/insert/name/d1/d2/d3/.../`: This inserts a new dataset. Later in this chapter,
    we are going to see how to extract the desired information from a URL that contains
    user data and parameters. The key point here is that the number of elements in
    a dataset varies so the URL is going to contain a variable number of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/delete/name/`: This deletes an entry based on the name of the dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/search/name/`: This searches for an entry based on the dataset name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/status`: This is an extra URL that returns the number of entries in the statistics
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of endpoints does not follow standard REST conventions—all these are
    going to be presented in *Chapter 11*, *Working with REST APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, **we are not using the default Go router**, which means that we
    define and configure our own `http.NewServeMux()` variable. This changes the way
    we provide handler functions: a handler function with the `func(http.ResponseWriter,
    *http.Request)` signature has to be converted into an `http.HandlerFunc` type
    and used by the `ServeMux` type and its own `Handle()` method. Therefore, when
    using a different `ServeMux` than the default one, we should do that conversion
    explicitly by calling `http.HandlerFunc()`, which makes the `http.HandlerFunc`
    type act as an adapter that allows the use of ordinary functions as HTTP handlers,
    provided that they have the required signature. This is not a problem when using
    the default Go router (`DefaultServeMux`) because the `http.HandleFunc()` function
    does that conversion automatically and internally. However, you can also use the
    `HandleFunc()` method from the `ServeMux` type to do the same implicit conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: To make things clearer, the `http.HandlerFunc` type has support for a method
    named `HandlerFunc()`—both the type and method are defined in the `http` package.
    The similarly named `http.HandleFunc()` function (without an `r`) is used with
    the default Go router.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, for the `/time` endpoint and the `timeHandler()` handler function,
    you should call `mux.Handle()` as `mux.Handle("/time", http.HandlerFunc(timeHandler))`.
    If you were using `http.HandleFunc()` and, as a consequence, `DefaultServeMux`,
    then you should have called `http.HandleFunc("/time", timeHandler)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of the next subsection is the implementation of the HTTP endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new version of the statistics application is going to be created inside
    `~/go/src`: `~/go/src/github.com/mactsouk/mGo4th/ch09/server`. As expected, you
    also need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you use the GitHub repository of the book, you are not going to need to create
    the server from scratch, as the Go code is already there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `stats.go` file holds the code that defines the operation of the web server.
    Usually, handlers are put in a separate external package, but for reasons of simplicity,
    we have decided to put handlers in a separate file named `handlers.go` within
    the same package. The contents of the `handlers.go` file, which contains all functionality
    related to the serving of the clients, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All required packages for `handlers.go` are imported, even if some of them have
    already been imported by `stats.go`. Note that the name of the package is `main`,
    which is also the case for `stats.go`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is the default port number that the HTTP server listens to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the default handler, which serves all requests that are not a match
    for any of the other handlers. Next is the handler for deleting entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is the handler function for the `/delete` path, which begins by splitting
    the URL in order to read the desired information. If we do not have enough parameters,
    we should send an error message back to the client with the appropriate HTTP code,
    which in this case is `http.StatusNotFound`. You can use any HTTP code you want
    as long as it makes sense. The `WriteHeader()` method sends back a header with
    the provided status code, before writing the body of the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is where the HTTP server sends data to log files—this mainly happens for
    debugging reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As the delete process is based on the dataset name, all that is required is
    a valid dataset name. This is where the parameter is read after splitting the
    provided URL. If the `deleteEntry()` function returns an error, then we construct
    a fitting response and send it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we know that the delete operation was successful, so we send
    a proper message to the client as well as the `http.StatusOK` status code. Type
    `go doc http.StatusOK` for the list of codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the implementation of `listHandler()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `list()` helper function that is used in the `/list` path cannot fail. Therefore,
    `http.StatusOK` is always returned when serving `/list`. However, sometimes the
    return value of `list()` can be the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement `statusHandler()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines the handler function for `/status`. It just returns
    information about the total number of entries found in the statistics application.
    It can be used to verify that the web service works fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we present the implementation of the `insertHandler()` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As before, we need to split the given URL in order to extract the information.
    In this case, we need at least four elements, as we are trying to insert a new
    dataset into the statistics service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we initialize the `dataset` variable and read the data
    elements, which have a variable length. In this case, we also need to convert
    the data elements into `float64` values because they are read as text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the end of the handler for `/insert`. The last part of the implementation
    of `insertHandler()` deals with the return value of `insert()`. If there was not
    an error, then `http.StatusOK` is sent to the client. In the opposite case, `http.StatusNotModified`
    is returned to signify that there was not a change in the statistics application.
    It is the job of the client to examine the status code of the interaction, but
    it is the job of the server to send an appropriate status code back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement `searchHandler()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we extract the dataset name from the URL, as we did with `/delete`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The last function of `handlers.go` ends here and is about the `/search` endpoint.
    The `search()` helper function checks whether the given input exists in the data
    records or not and acts accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the implementation of the `main()` function, which can be found
    in `stats.go`, is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This first part of `main()` relates to the proper initialization of the statistics
    application. Internally, data is stored in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we store the parameters of the HTTP server in the `http.Server` structure
    and use our own `http.NewServeMux()` instead of the default one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is the list of the supported URLs. Note that `/search` and `/search/` are
    both handled by the same handler function even though `/search` is going to fail,
    as it does not include the required data. On the other hand, `/delete/` is handled
    differently—this will be apparent when testing the application. As we are using
    `http.NewServeMux()` and not the default Go router, we need to use `http.HandlerFunc()`
    when defining the handler functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier in this chapter, each `mux.Handle()` call can be replaced
    by an equivalent `mux.HandleFunc()` call. So `mux.Handle("/list", http.HandlerFunc(listHandler))`
    is going to become `mux.HandleFunc("/list", listHandler)`. The same applies to
    all the other `mux.Handle()` calls.
  prefs: []
  type: TYPE_NORMAL
- en: The `ListenAndServe()` method starts the HTTP server using the parameters defined
    previously in the `http.Server` structure. The rest of `stats.go` contains helper
    functions related to the operation of the web service. Note that it is important
    to save and update the contents of the application as often as possible because
    this is a live application, and you might lose data if it crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command allows you to execute the application—you need to provide
    both files in `go run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client side, which is `curl(1)`, we have the following interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we get all entries from the statistics application by visiting `/list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The previous command is going to work if `d1` is in the list of existing datasets.
    If your list is empty or `d1` does not exist, you should include it before deleting
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the previous part, we tried to delete the `d1` and `d2` datasets. Trying
    to delete `d1` again fails.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we visit `/status` and get back the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we search for `d3`, which does not exist, and then for `d4`, which exists.
    In the latter case, the web service returns the data of `d4`. Now, let us try
    and visit `/delete` instead of `/delete/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The presented message was generated by the Go router and tells us that we should
    try `/delete/` instead because `/delete` was moved permanently. This is the kind
    of message that we get by not specifically defining both `/delete` and `/delete/`
    in the routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us insert two datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands are going to work if both `v1` and `v2` do not already
    exist. If we try to insert a dataset with a name that already exists, we get no
    response back other than `304 – Not Modified`.
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks like it is working OK. We can now put the statistics web service
    online and interact with it using multiple HTTP requests, as the `http` package
    uses multiple goroutines to interact with clients—in practice, this means that
    the statistics application runs concurrently! However, in its current version,
    there is no protection against data races, which might take place if we try to
    insert the same dataset more than once at the exact same time.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we are going to create a command line client for the
    statistics server. Additionally, *Chapter 12*, *Code Testing and Profiling*, shows
    how to test your code.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to build Docker images for server applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section shows how to convert a Go application into a Docker image—the kind
    of application we are going to use is an HTTP server that interacts with the outer
    world. In our case, it is going to be the statistical web service that we have
    just developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of `buildDocker`, which contains the steps to create a Docker
    image, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can use the `buildDocker` file to build a Docker image, named
    `goapp`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of `docker-compose.yml`, which allows us to use a Docker image,
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What is important in the `docker-compose.yml` file is to use the `goapp` image
    name that was created in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the `docker-compose.yml` at hand, we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: After that, we are free to interact with the web service using `curl(1)` or
    any other similar tool. When done, we can use *Ctrl* + *C* to stop the Docker
    image from running.
  prefs: []
  type: TYPE_NORMAL
- en: The main disadvantage of this particular web service is that once you disable
    the Docker image, all data is lost—the solution to this problem is simple. You
    can either store the data in an external database or link the internal Docker
    data file to a file in the local filesystem. Implementing either of these two
    solutions is beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about HTTP servers, the next section shows how to develop HTTP
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: Developing web clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section shows how to develop HTTP clients, starting with a simplistic
    version and continuing with a more advanced one. In this simplistic version, all
    of the work is done by the `http.Get()` call, which is pretty convenient when
    you do not want to deal with lots of options and parameters. However, this type
    of call gives you no flexibility over the process. Notice that `http.Get()` returns
    an `http.Response` value. All this is illustrated in `simpleClient.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `filepath.Base()` function returns the last element of a path. When given
    `os.Args[0]` as its parameter, it returns the name of the executable binary file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the previous two statements, we get the URL and its data using `http.Get()`,
    which returns an `*http.Response` and an `error` variable. The `*http.Response`
    value contains all the information, so you do not need to make any additional
    calls to `http.Get()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `io.Copy()` function reads from the `data.Body` reader, which contains
    the body of the server response, and writes the data to `os.Stdout`. As `os.Stdout`
    is always open, you do not need to open it for writing. Therefore, all data is
    written to standard output, which is usually the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Last, we close the `data.Body` reader to make the work of garbage collection
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with `simpleClient.go` produces the following kind of output, which
    in this case is abbreviated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Although `simpleClient.go` does the job of verifying that the given URL exists
    and is reachable, it offers no control over the process. The next subsection develops
    an advanced HTTP client that processes the server response.
  prefs: []
  type: TYPE_NORMAL
- en: Using http.NewRequest() to improve the client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the web client of the previous section is relatively simplistic and does
    not give you any flexibility, in this subsection, you will learn how to read a
    URL without using the `http.Get()` function and by having more options. However,
    the extra flexibility comes at a cost, as you must write more code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `wwwClient.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Although using `filepath.Base()` is not necessary, it makes your output more
    professional.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `url.Parse()` function parses a string into a URL structure. This means
    that if the given argument is not a valid URL, `url.Parse()` is going to notice.
    As usual, we need to check the `error` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `http.NewRequest()` function returns an `http.Request` object when provided
    with a method, a URL, and an optional body. The `http.MethodGet` parameter defines
    that we want to retrieve the data using a `GET` HTTP method, whereas `URL.String()`
    returns the `string` value of an `http.URL` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `http.Do()` function sends an HTTP request (`http.Request`) using an `http.Client`
    and gets an `http.Response` back. So `http.Do()` does the job of `http.Get()`
    in a more detailed way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`httpData.Status` holds the HTTP status code of the response—this is important
    because it allows you to understand what really happened with the request.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `httputil.DumpResponse()` function is used here to get the response from
    the server and is mainly used for debugging purposes. The second argument of `httputil.DumpResponse()`
    is a Boolean value that specifies whether the function is going to include the
    body or not in its output—in our case, it is set to `false`, which excludes the
    response body from the output and only prints the header. If you want to do the
    same on the server side, you should use `httputil.DumpRequest()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we find out about the character set of the response by searching the
    value of `Content-Type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we try to get the content length from the response by reading `httpData.ContentLength`.
    However, if the value is not set, we print a relevant message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the last part of the program, we use a technique for discovering the size
    of the server HTTP response on our own. If we wanted to display the HTML output
    on our screen, we could have printed the contents of the `r` buffer variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with `wwwClient.go` and visiting [https://www.golang.org](https://www.golang.org)
    produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The previous is the output of `fmt.Println("Status code:", httpData.Status)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we see the output of the `fmt.Print(string(header))` statement with the
    header data of the HTTP server response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the output is about the character set of the interaction (`utf-8`)
    and the content length of the response (`61870`), as calculated by the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Let us now see a technique to fetch multiple addresses concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Using errGroup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to use the `errGroup` package to fetch multiple
    URLs concurrently, using the `golang.org/x/sync/errgroup` external package. For
    that reason, `eGroup.go` is located at `~/go/src/github.com/mactsouk/mGo4th/ch09/eGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `eGroup.go` is presented in two parts. The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We use the `errgroup.Group` variable, which is a collection of goroutines that
    work on parts of the same bigger task. In general, the `errgroup` package provides
    synchronization, error propagation, and `Context` cancelation for goroutines that
    work on subtasks of the same task that we want to treat as a group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `eGroup.go` comes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this part, we use `g.Go()` to call the desired function as a goroutine. Additionally,
    we use a **closured variable** for the `url` variable so that each goroutine processes
    the desired URL correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, we need to run the following two commands first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `eGroup.go` on my macOS machine generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the same command on my Arch Linux machine produces a different output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The next section shows how to create a command line client for the statistics
    web service we developed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a client for the statistics service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this subsection, we create a command line utility that interacts with the
    statistics web service that was developed earlier in this chapter. This version
    of the statistics client is going to be created using the `cobra` package, and
    as expected, it is going to go under `~/go/src`: `~/go/src/github.com/mactsouk/mGo4th/ch09/client`.
    The previous directory contains the final version of the client. The initial steps
    for creating the client are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: So, we have a command line utility with five commands, named `search`, `insert`,
    `delete`, `status`, and `list`. After that, we need to implement the commands
    and define their local parameters in order to interact with the statistics server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us see the implementations of the commands, starting from the implementation
    of the `init()` function of the `root.go` file because this is where the global
    command line parameters are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: So, we define two global parameters named `server` and `port`, which are the
    hostname and the port number of the server, respectively. Both parameters have
    an alias and are handled by `viper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now examine the implementation of the `status` command as found in `status.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'All commands read the values of the `server` and `port` command line parameters
    to get information about the server, and the `status` command is no exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: After that, we construct the full URL of the request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Then, we send a `GET` request to the server using `http.Get()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: After that, we check the HTTP status code of the request to make sure that everything
    is OK.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is OK, we read the entire body of the server response, which
    is a byte slice, and print it onscreen as a string. The implementation of `list`
    is almost identical to the implementation of `status`. The only differences are
    that the implementation is found in `list.go` and that the full URL is constructed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, let us see how the `delete` command is implemented in `delete.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Apart from reading the values of the `server` and `port` global parameters,
    we read the value of the `dataset` parameter. If `dataset` has no value, the command
    returns this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we construct the full URL of the request before connecting to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The previous code sends the client request to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If there is an error in the server response, the `delete` command prints the
    HTTP error and terminates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If everything was fine, the server response text is printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `init()` function of `delete.go` contains the definition of the local `dataset`
    command line parameter to get the dataset name to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us learn more about the `search` command and how it is implemented
    in `search.go`. The implementation is the same as in `delete` except for the full
    request URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The `search` command also supports the `dataset` command line parameter in getting
    the dataset name to search for—this is defined in the `init()` function of `search.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last command that is presented is the `insert` command, which supports
    two local command line parameters that are defined in the `init()` function in
    `insert.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: These two parameters are needed to get the required user input. However, the
    value of the `values` parameter is expected to be a comma-separated list of floating-point
    values—this is the way we define how to get all the elements of a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `insert` command is implemented using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: First, we read the `server` and `port` global parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Then, we get the values of the two local command line parameters. If either
    one of them has an empty value, the command returns without sending the request
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is very important, as it checks whether the given dataset
    elements are valid `float64` values, and then it creates a string of the `/value1/value2/.
    . ./valueN/` form. This `string` value is attached to the end of the URL that
    holds the server request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create the server request in two steps for readability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Then, we send the request to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Checking the HTTP status code is always a good practice. Therefore, if everything
    is OK with the server response, we continue by reading the data. Otherwise, we
    print the status code, and we exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: After reading the body of the server response, which is stored in a byte slice,
    we print it onscreen as a string using `string(responseData)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client application generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This is the output of the `list` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The output of the `status` command informs us about the number of entries in
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows the use of the `search` command when successfully
    finding a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows the use of the `search` command when not finding a
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This is the output of the `delete` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the operation of the `insert` command. If you try to insert the same
    dataset name more than once, the server output is going to be `Status code: 304`.'
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to time out HTTP connections.
  prefs: []
  type: TYPE_NORMAL
- en: Timing out HTTP connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents techniques for timing out HTTP connections that take too
    long to finish and work either on the server or the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Using SetDeadline()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SetDeadline()` function is used by `net` to set the read and write deadlines
    of network connections. Due to the way that `SetDeadline()` works, you need to
    call `SetDeadline()` before any read or write operation. Keep in mind that Go
    uses deadlines to implement timeouts, so you do not need to reset the timeout
    every time your application receives or sends any data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `SetDeadline()` is illustrated in `withDeadline.go` and, more specifically,
    in the implementation of the `Timeout()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `timeout` global variable defines the timeout period used in the `SetDeadline()`
    call. The previous function is used in the following code inside `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: So, `http.Transport` uses `Timeout()` in the `Dial` field, and `http.Client`
    uses `http.Transport`. When you call the `client.Get()` method with the desired
    URL, which is not shown here, `Timeout` is automatically used because of the `http.Transport`
    definition. So, if the `Timeout` function returns before the server response is
    received, we have a timeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `withDeadline.go` produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The call was successful and took less than 1 second to finish, so there was
    no timeout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This time, we have a timeout, as the server took too long to answer.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we show how to time out a connection using the `context` package.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the timeout period on the client side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section presents a technique for timing out network connections that take
    too long to finish **on the client side**. So if the client does not receive a
    response from the server in the desired time, it closes the connection. The `timeoutClient.go`
    source file illustrates the technique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we define a global variable named `delay` that holds the
    delay value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The URL is read directly because it is already a string value, whereas the delay
    period is converted into a numeric value using `strconv.Atoi()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the `main()` implementation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: First, we initialize the `ctx` context, and then we associate that context with
    the HTTP request using `http.NewRequestWithContext()`. If the timeout period is
    exceeded, the `context.Context` created with `WithTimeout()` is going to expire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with `timeoutClient.go` and having a timeout situation generates the
    following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection shows how to time out an HTTP request on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the timeout period on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section presents a technique for timing out network connections that take
    too long to finish **on the server side**. This is much more important than the
    client side, as a server with too many open connections might not be able to process
    additional requests unless some of the already open connections close. This usually
    happens for two reasons. The first reason is software bugs, and the second reason
    is when a server experiences a **Denial of Service** (**DoS**) attack!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function in `timeoutServer.go` shows the technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This is where the timeout periods are defined. Note that you can define timeout
    periods for both reading and writing processes. The value of the `ReadTimeout`
    field specifies the maximum duration allowed to read the entire client request,
    including the body, whereas the value of the `WriteTimeout` field specifies the
    maximum time duration before timing out the sending of the client response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the parameters in the definition of `http.Server`, the rest of the
    code is as usual: it contains the handler functions and calls `ListenAndServe()`
    to start the HTTP server.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with `timeoutServer.go` generates no output. However, if a client connects
    to it without sending any requests, the client connection will end after 3 seconds.
    The same will happen if it takes the client more than 3 seconds to receive the
    server response.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to work with HTTP and how to create Docker images
    from Go code, as well as how to develop HTTP clients and servers. We have also
    converted the statistics application into a web application and programmed a command
    line client for it. Additionally, we learned how to time out HTTP connections.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to begin developing powerful and concurrent HTTP applications
    —however, we are not done yet with HTTP. *Chapter 11*, *Working with REST APIs*,
    is going to connect the dots and show how to develop powerful RESTful servers
    and clients.
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to learn about working with TCP/IP, TCP, UDP, and WebSocket,
    which are the subjects of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modify `wwwClient.go` to save the HTML output to an external file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `sync.Mutex` in order to avoid race conditions in the statistics application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a simple version of `ab(1)` using goroutines and channels. `ab(1)`
    is an Apache HTTP server benchmarking tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Caddy server: [https://caddyserver.com/](https://caddyserver.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nginx server: [https://nginx.org/en/](https://nginx.org/en/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `net/http` package: [https://pkg.go.dev/net/http](https://pkg.go.dev/net/http)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official Docker Go images: [https://hub.docker.com/_/golang/](https://hub.docker.com/_/golang/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  prefs: []
  type: TYPE_NORMAL
