<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer155">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 class="chapterTitle" id="_idParaDest-283"><span class="koboSpan" id="kobo.2.1">Working with TCP/IP and WebSocket</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">TCP/IP is the foundation of the Internet and, therefore, being able to create TCP/IP servers and clients is essential when developing network services. </span><span class="koboSpan" id="kobo.3.2">This chapter teaches you how to work with the lower-level protocols of TCP/IP, which are TCP and UDP, with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4.1">net</span></code><span class="koboSpan" id="kobo.5.1"> package, so that you can develop TCP/IP servers and clients and have more control over their functionality. </span><span class="koboSpan" id="kobo.5.2">The Go code of the TCP and UDP utilities included in this chapter allows us to create our own advanced TCP/IP services as the core principles and logic of TCP/IP remain the same.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">Additionally, this chapter illustrates the development of servers and clients for the WebSocket protocol, which is based on HTTP, and shows how to interact with RabbitMQ, which is an open-source </span><em class="italic"><span class="koboSpan" id="kobo.7.1">message broker</span></em><span class="koboSpan" id="kobo.8.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">The WebSocket protocol provides full-duplex communication channels over a single TCP connection. </span><span class="koboSpan" id="kobo.9.2">On the other hand, message brokers such as RabbitMQ and Apache Kafka are famous for their speed, which is the main reason for including them in a workflow that processes lots of data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.10.1">In more detail, this chapter covers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">TCP/IP</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.13.1">net</span></code><span class="koboSpan" id="kobo.14.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Developing a TCP client</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Developing a TCP server</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Developing a UDP client</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Developing a UDP server</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Developing concurrent TCP servers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Creating a WebSocket server</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Creating a WebSocket client</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Working with RabbitMQ</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-284"><span class="koboSpan" id="kobo.23.1">TCP/IP</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.24.1">TCP/IP is a family </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.25.1">of protocols that help the Internet operate. </span><span class="koboSpan" id="kobo.25.2">Its name comes from its two most well-known protocols: TCP and IP.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.26.1">TCP stands for</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.27.1"> Transmission Control Protocol. </span><span class="koboSpan" id="kobo.27.2">TCP software transmits data between machines using segments, which are also called TCP packets. </span><span class="koboSpan" id="kobo.27.3">The main characteristic of TCP is that it is a </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.28.1">reliable protocol</span></strong><span class="koboSpan" id="kobo.29.1">, which means that it makes sure that every packet is delivered without requiring any extra code from the programmer. </span><span class="koboSpan" id="kobo.29.2">If there is no proof of packet delivery, TCP resends that packet. </span><span class="koboSpan" id="kobo.29.3">Among other things, TCP packets can be used to establish connections, transfer data, send acknowledgments, and close connections.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.30.1">When a TCP connection is established between two machines, a full-duplex virtual circuit, similar to a telephone call, is created between those two machines. </span><span class="koboSpan" id="kobo.30.2">The two machines constantly communicate to make sure that data is sent and received correctly. </span><span class="koboSpan" id="kobo.30.3">If the connection fails for some reason, the two machines try to find the problem and report it to the relevant application. </span><span class="koboSpan" id="kobo.30.4">The TCP header of each packet includes the source port and destination port fields. </span><span class="koboSpan" id="kobo.30.5">These two fields, plus the source and destination IP addresses, are combined to uniquely identify every single TCP connection. </span><span class="koboSpan" id="kobo.30.6">All these details are handled by TCP/IP, as long as you provide the required details without any extra effort.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.31.1">When creating TCP/IP server processes, remember that port numbers 0-1024 have restricted access and can only be used by the root user, which means that you need administrative privileges to use any port in that range. </span><span class="koboSpan" id="kobo.31.2">Running a process with root privileges is a security risk and must be avoided.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.32.1">IP stands for Internet Protocol. </span><span class="koboSpan" id="kobo.32.2">The main characteristic of IP is that it is not a reliable protocol by nature. </span><span class="koboSpan" id="kobo.32.3">IP encapsulates the data that travels over a TCP/IP network because it is responsible for delivering packets from the source host to the destination host according to the IP addresses. </span><span class="koboSpan" id="kobo.32.4">IP must find an addressing method for sending a packet to its destination effectively. </span><span class="koboSpan" id="kobo.32.5">Although there are dedicated devices, called routers, that perform IP routing, every TCP/IP device has to perform some basic routing. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.33.1">The first version of the IP protocol is now called IPv4 to differentiate it from the latest version of the IP protocol, which is called IPv6. </span><span class="koboSpan" id="kobo.33.2">The main problem with IPv4 is that it is about to run out of available IP addresses, which is the main reason for creating the IPv6 protocol. </span><span class="koboSpan" id="kobo.33.3">This happened because an IPv4 address is represented using 32 bits only, which allows a total number of 2</span><sup class="superscript"><span class="koboSpan" id="kobo.34.1">32</span></sup><span class="koboSpan" id="kobo.35.1"> (4,294,967,296) different IP addresses. </span><span class="koboSpan" id="kobo.35.2">On the other hand, IPv6 uses 128 bits to define each one of its addresses. </span><span class="koboSpan" id="kobo.35.3">The format of an IPv4 address is </span><code class="inlineCode"><span class="koboSpan" id="kobo.36.1">10.20.32.245</span></code><span class="koboSpan" id="kobo.37.1"> (four parts with values from 0 to 255 separated by dots), while the format of an IPv6 address is </span><code class="inlineCode"><span class="koboSpan" id="kobo.38.1">3fce:1706:4523:3:150:f8ff:fe21:56cf</span></code><span class="koboSpan" id="kobo.39.1"> (eight parts separated by colons).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.40.1">UDP (User Datagram Protocol) is based on IP, which means that it is also unreliable. </span><span class="koboSpan" id="kobo.40.2">UDP is simpler than TCP, mainly because UDP is not reliable by design. </span><span class="koboSpan" id="kobo.40.3">As a result, UDP messages can be lost, duplicated, or arrive out of order. </span><span class="koboSpan" id="kobo.40.4">Furthermore, packets can arrive faster than the recipient can process them. </span><span class="koboSpan" id="kobo.40.5">So, UDP is used when speed is more important than</span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.41.1"> reliability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.42.1">This chapter implements both TCP and UDP software—TCP and UDP services are the basis of the Internet. </span><span class="koboSpan" id="kobo.42.2">But first, let us talk about the handy </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">nc(1)</span></code><span class="koboSpan" id="kobo.44.1"> utility.</span></p>
<h2 class="heading-2" id="_idParaDest-285"><span class="koboSpan" id="kobo.45.1">The nc(1) command line utility</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.46.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">nc(1)</span></code><span class="koboSpan" id="kobo.48.1"> utility, which</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.49.1"> is also called </span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">netcat(1)</span></code><span class="koboSpan" id="kobo.51.1">, is</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.52.1"> very </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.53.1">convenient when you want to test TCP/IP servers and clients: </span><code class="inlineCode"><span class="koboSpan" id="kobo.54.1">nc(1)</span></code><span class="koboSpan" id="kobo.55.1"> is a utility for everything that involves TCP and UDP as well as IPv4 and IPv6, including but not limited to opening TCP connections, sending and receiving UDP messages, and acting as a TCP server.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.56.1">You can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">nc(1)</span></code><span class="koboSpan" id="kobo.58.1"> as a client for a TCP service that runs on a machine with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">10.10.1.123</span></code><span class="koboSpan" id="kobo.60.1"> IP address and listens to port number </span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">1234</span></code><span class="koboSpan" id="kobo.62.1">, as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.63.1">$ </span></span><span class="koboSpan" id="kobo.64.1">nc 10.10.1.123 1234
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.65.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.66.1">-l</span></code><span class="koboSpan" id="kobo.67.1"> option tells </span><code class="inlineCode"><span class="koboSpan" id="kobo.68.1">netcat(1)</span></code><span class="koboSpan" id="kobo.69.1"> to act as a server, which means that when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">-l</span></code><span class="koboSpan" id="kobo.71.1"> option is given, </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">netcat(1)</span></code><span class="koboSpan" id="kobo.73.1"> starts listening for incoming connections at the given port number. </span><span class="koboSpan" id="kobo.73.2">By default, </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">nc(1)</span></code><span class="koboSpan" id="kobo.75.1"> uses the TCP protocol. </span><span class="koboSpan" id="kobo.75.2">However, if you execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">nc(1)</span></code><span class="koboSpan" id="kobo.77.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">-u</span></code><span class="koboSpan" id="kobo.79.1"> flag, it uses the UDP protocol, either as a client or as a server. </span><span class="koboSpan" id="kobo.79.2">Finally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">-v</span></code><span class="koboSpan" id="kobo.81.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">-vv</span></code><span class="koboSpan" id="kobo.83.1"> options tell </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">netcat(1)</span></code><span class="koboSpan" id="kobo.85.1"> to generate verbose output, which can be practical when you want to troubleshoot network connections.</span></p>
<h1 class="heading-1" id="_idParaDest-286"><span class="koboSpan" id="kobo.86.1">The net package</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.87.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">net</span></code><span class="koboSpan" id="kobo.89.1"> package of the </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.90.1">Go Standard Library is all about TCP/IP, UDP, domain name resolution, and UNIX domain sockets. </span><span class="koboSpan" id="kobo.90.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.91.1">net.Dial()</span></code><span class="koboSpan" id="kobo.92.1"> function is used to connect to a network as a client, whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.93.1">net.Listen()</span></code><span class="koboSpan" id="kobo.94.1"> function is used to tell a Go program to accept incoming network connections and thus act as a server. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.95.1">The return value for both </span><code class="inlineCode"><span class="koboSpan" id="kobo.96.1">net.Dial()</span></code><span class="koboSpan" id="kobo.97.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">net.Listen()</span></code><span class="koboSpan" id="kobo.99.1"> is of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">net.Conn</span></code><span class="koboSpan" id="kobo.101.1"> data type, which implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">io.Reader</span></code><span class="koboSpan" id="kobo.103.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.104.1">io.Writer</span></code><span class="koboSpan" id="kobo.105.1"> interfaces—this means that you can both read and write to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">net.Conn</span></code><span class="koboSpan" id="kobo.107.1"> connection using code related to file I/O. </span><span class="koboSpan" id="kobo.107.2">The first parameter of both </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">net.Dial()</span></code><span class="koboSpan" id="kobo.109.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">net.Listen()</span></code><span class="koboSpan" id="kobo.111.1"> is the network type, but this is where their similarities end.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.112.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.113.1">net.Dial()</span></code><span class="koboSpan" id="kobo.114.1"> function is used to connect to a remote server. </span><span class="koboSpan" id="kobo.114.2">The first parameter of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.115.1">net.Dial()</span></code><span class="koboSpan" id="kobo.116.1"> function defines the network protocol that is going to be used, while the second parameter defines the server address, which must also include the port number. </span><span class="koboSpan" id="kobo.116.2">Valid values for the first parameter are </span><code class="inlineCode"><span class="koboSpan" id="kobo.117.1">tcp</span></code><span class="koboSpan" id="kobo.118.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.119.1">tcp4</span></code><span class="koboSpan" id="kobo.120.1"> (IPv4-only), </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">tcp6</span></code><span class="koboSpan" id="kobo.122.1"> (IPv6-only), </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">udp</span></code><span class="koboSpan" id="kobo.124.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.125.1">udp4</span></code><span class="koboSpan" id="kobo.126.1"> (IPv4-only), </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">udp6</span></code><span class="koboSpan" id="kobo.128.1"> (IPv6-only), </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">ip</span></code><span class="koboSpan" id="kobo.130.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">ip4</span></code><span class="koboSpan" id="kobo.132.1"> (IPv4-only), </span><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">ip6</span></code><span class="koboSpan" id="kobo.134.1"> (IPv6-only), </span><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">unix</span></code><span class="koboSpan" id="kobo.136.1"> (UNIX sockets), </span><code class="inlineCode"><span class="koboSpan" id="kobo.137.1">unixgram</span></code><span class="koboSpan" id="kobo.138.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.139.1">unixpacket</span></code><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">On the other hand, valid values for </span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">net.Listen()</span></code><span class="koboSpan" id="kobo.142.1"> are </span><code class="inlineCode"><span class="koboSpan" id="kobo.143.1">tcp</span></code><span class="koboSpan" id="kobo.144.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.145.1">tcp4</span></code><span class="koboSpan" id="kobo.146.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.147.1">tcp6</span></code><span class="koboSpan" id="kobo.148.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">unix</span></code><span class="koboSpan" id="kobo.150.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.151.1">unixpacket</span></code><span class="koboSpan" id="kobo.152.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.153.1">Execute the </span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">go doc net.Listen</span></code><span class="koboSpan" id="kobo.155.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">go doc net.Dial</span></code><span class="koboSpan" id="kobo.157.1"> commands for detailed information regarding these two functions.</span></p>
<h1 class="heading-1" id="_idParaDest-287"><span class="koboSpan" id="kobo.158.1">Developing a TCP client</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.159.1">This section is about </span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.160.1">developing TCP clients. </span><span class="koboSpan" id="kobo.160.2">The two subsections that follow present two equivalent ways of developing TCP clients.</span></p>
<h2 class="heading-2" id="_idParaDest-288"><span class="koboSpan" id="kobo.161.1">Developing a TCP client with net.Dial()</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.162.1">First, we are</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.163.1"> going to present the most widely used way, which</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.164.1"> is implemented in </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">tcpC.go</span></code><span class="koboSpan" id="kobo.166.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.167.1">package</span></span><span class="koboSpan" id="kobo.168.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.169.1">import</span></span><span class="koboSpan" id="kobo.170.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.171.1">"bufio"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.172.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.173.1">"net"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.174.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.175.1">"strings"</span></span><span class="koboSpan" id="kobo.176.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.177.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.178.1">import</span></code><span class="koboSpan" id="kobo.179.1"> block contains packages such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.180.1">bufio</span></code><span class="koboSpan" id="kobo.181.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.182.1">fmt</span></code><span class="koboSpan" id="kobo.183.1"> that also work with file I/O operations.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.184.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.185.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.186.1">()</span></span><span class="koboSpan" id="kobo.187.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.188.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.189.1">len</span></span><span class="koboSpan" id="kobo.190.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.191.1">1</span></span><span class="koboSpan" id="kobo.192.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.193.1">"Please provide host:port."</span></span><span class="koboSpan" id="kobo.194.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.195.1">return</span></span><span class="koboSpan" id="kobo.196.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.197.1">First, we read the details of the TCP server we want to connect to.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.198.1">    connect := arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.199.1">1</span></span><span class="koboSpan" id="kobo.200.1">]
    c, err := net.Dial(</span><span class="hljs-string"><span class="koboSpan" id="kobo.201.1">"tcp"</span></span><span class="koboSpan" id="kobo.202.1">, connect)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.203.1">if</span></span><span class="koboSpan" id="kobo.204.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.205.1">nil</span></span><span class="koboSpan" id="kobo.206.1"> {
        fmt.Println(err)
        os.Exit(</span><span class="hljs-number"><span class="koboSpan" id="kobo.207.1">5</span></span><span class="koboSpan" id="kobo.208.1">)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.209.1">With the connection details, we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">net.Dial()</span></code><span class="koboSpan" id="kobo.211.1">—its first parameter is the protocol we want to use, which in this case is </span><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">tcp</span></code><span class="koboSpan" id="kobo.213.1">, and its second parameter contains the connection details. </span><span class="koboSpan" id="kobo.213.2">A successful </span><code class="inlineCode"><span class="koboSpan" id="kobo.214.1">net.Dial()</span></code><span class="koboSpan" id="kobo.215.1"> call returns an open connection (a </span><code class="inlineCode"><span class="koboSpan" id="kobo.216.1">net.Conn</span></code><span class="koboSpan" id="kobo.217.1"> interface), which is a </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.218.1">generic </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.219.1">stream-oriented network connection.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.220.1">    reader := bufio.NewReader(os.Stdin)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.221.1">for</span></span><span class="koboSpan" id="kobo.222.1"> {
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.223.1">"&gt;&gt; "</span></span><span class="koboSpan" id="kobo.224.1">)
        text, _ := reader.ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.225.1">'\n'</span></span><span class="koboSpan" id="kobo.226.1">)
        fmt.Fprintf(c, </span><span class="hljs-string"><span class="koboSpan" id="kobo.227.1">"%s\n"</span></span><span class="koboSpan" id="kobo.228.1">, text)
        message, _ := bufio.NewReader(c).ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.229.1">'\n'</span></span><span class="koboSpan" id="kobo.230.1">)
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.231.1">"-&gt;: "</span></span><span class="koboSpan" id="kobo.232.1"> + message)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.233.1">if</span></span><span class="koboSpan" id="kobo.234.1"> strings.TrimSpace(</span><span class="hljs-type"><span class="koboSpan" id="kobo.235.1">string</span></span><span class="koboSpan" id="kobo.236.1">(text)) == </span><span class="hljs-string"><span class="koboSpan" id="kobo.237.1">"STOP"</span></span><span class="koboSpan" id="kobo.238.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.239.1">"TCP client exiting..."</span></span><span class="koboSpan" id="kobo.240.1">)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.241.1">return</span></span><span class="koboSpan" id="kobo.242.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.243.1">The last part of the TCP client keeps reading user input until the word </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">STOP</span></code><span class="koboSpan" id="kobo.245.1"> is given as input—in this case, the client waits for the server response before terminating after </span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">STOP</span></code><span class="koboSpan" id="kobo.247.1"> because this is how the </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">for</span></code><span class="koboSpan" id="kobo.249.1"> loop is constructed. </span><span class="koboSpan" id="kobo.249.2">This mainly happens because the server might have a useful answer for us, and we do not want to miss that. </span><span class="koboSpan" id="kobo.249.3">All given user input is sent (written) to the open TCP connection using </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">fmt.Fprintf()</span></code><span class="koboSpan" id="kobo.251.1">, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">bufio.NewReader()</span></code><span class="koboSpan" id="kobo.253.1"> is used to read data from the TCP connection, just like you would do with a regular file.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.254.1">Bear in mind that the reason for not checking the </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">error</span></code><span class="koboSpan" id="kobo.256.1"> value returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">reader.ReadString('\n')</span></code><span class="koboSpan" id="kobo.258.1"> is simplicity. </span><span class="koboSpan" id="kobo.258.2">We should never ignore errors.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.259.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">tcpC.go</span></code><span class="koboSpan" id="kobo.261.1"> to connect to a TCP server, which in this case is implemented with </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">nc(1)</span></code><span class="koboSpan" id="kobo.263.1"> as </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">nc -l 1234</span></code><span class="koboSpan" id="kobo.265.1">, produces the next kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.266.1">$ </span></span><span class="koboSpan" id="kobo.267.1">go run tcpC.go localhost:1234
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.268.1">&gt;</span></span><span class="koboSpan" id="kobo.269.1">&gt; Hello!
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.270.1">-&gt;</span></span><span class="koboSpan" id="kobo.271.1">: Hi from nc -l 1234
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.272.1">&gt;</span></span><span class="koboSpan" id="kobo.273.1">&gt; STOP
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.274.1">-&gt;</span></span><span class="koboSpan" id="kobo.275.1">: Bye!
</span><span class="koboSpan" id="kobo.275.2">TCP client exiting...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.276.1">Lines beginning with </span><code class="inlineCode"><span class="koboSpan" id="kobo.277.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.278.1"> denote user input, whereas lines beginning with </span><code class="inlineCode"><span class="koboSpan" id="kobo.279.1">-&gt;</span></code><span class="koboSpan" id="kobo.280.1"> signify server messages. </span><span class="koboSpan" id="kobo.280.2">After sending </span><code class="inlineCode"><span class="koboSpan" id="kobo.281.1">STOP</span></code><span class="koboSpan" id="kobo.282.1">, we wait for the server response and then the client ends the TCP connection. </span><span class="koboSpan" id="kobo.282.2">The previous code demonstrates how to create a proper TCP client in Go </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.283.1">with </span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.284.1">some extra logic and functionality in it (the </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">STOP</span></code><span class="koboSpan" id="kobo.286.1"> keyword).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.287.1">The next subsection shows a different way of creating a TCP client.</span></p>
<h2 class="heading-2" id="_idParaDest-289"><span class="koboSpan" id="kobo.288.1">Developing a TCP client that uses net.DialTCP()</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.289.1">This subsection</span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.290.1"> presents an alternative way </span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.291.1">to develop a TCP client. </span><span class="koboSpan" id="kobo.291.2">The difference lies in the Go functions that are being used to establish the TCP connection, which are </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">net.DialTCP()</span></code><span class="koboSpan" id="kobo.293.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">net.ResolveTCPAddr()</span></code><span class="koboSpan" id="kobo.295.1">, and not in the functionality of the client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.296.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">otherTCPclient.go</span></code><span class="koboSpan" id="kobo.298.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.299.1">package</span></span><span class="koboSpan" id="kobo.300.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.301.1">import</span></span><span class="koboSpan" id="kobo.302.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.303.1">"bufio"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.304.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.305.1">"net"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.306.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.307.1">"strings"</span></span><span class="koboSpan" id="kobo.308.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.309.1">Although we are working with TCP/IP connections, we need packages such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">bufio</span></code><span class="koboSpan" id="kobo.311.1"> because UNIX treats network connections as files, so we are basically working with I/O operations over networks.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.312.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.313.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.314.1">()</span></span><span class="koboSpan" id="kobo.315.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.316.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.317.1">len</span></span><span class="koboSpan" id="kobo.318.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.319.1">1</span></span><span class="koboSpan" id="kobo.320.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.321.1">"Please provide a server:port string!"</span></span><span class="koboSpan" id="kobo.322.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.323.1">return</span></span><span class="koboSpan" id="kobo.324.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.325.1">We need to read the details of the TCP server we want to connect to, including the desired port number. </span><span class="koboSpan" id="kobo.325.2">The utility cannot operate with default parameters when working with TCP/IP </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.326.1">unless</span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.327.1"> we are developing a very specialized TCP client.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.328.1">    connect := arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.329.1">1</span></span><span class="koboSpan" id="kobo.330.1">]
    tcpAddr, err := net.ResolveTCPAddr(</span><span class="hljs-string"><span class="koboSpan" id="kobo.331.1">"tcp4"</span></span><span class="koboSpan" id="kobo.332.1">, connect)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.333.1">if</span></span><span class="koboSpan" id="kobo.334.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.335.1">nil</span></span><span class="koboSpan" id="kobo.336.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.337.1">"ResolveTCPAddr:"</span></span><span class="koboSpan" id="kobo.338.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.339.1">return</span></span><span class="koboSpan" id="kobo.340.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.341.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">net.ResolveTCPAddr()</span></code><span class="koboSpan" id="kobo.343.1"> function is specific to TCP connections, hence its name, and resolves the given address to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">*net.TCPAddr</span></code><span class="koboSpan" id="kobo.345.1"> value, which is a structure that represents the address of a TCP endpoint—in this case, the endpoint is the TCP server we are going to connect to.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.346.1">    conn, err := net.DialTCP(</span><span class="hljs-string"><span class="koboSpan" id="kobo.347.1">"tcp4"</span></span><span class="koboSpan" id="kobo.348.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.349.1">nil</span></span><span class="koboSpan" id="kobo.350.1">, tcpAddr)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.351.1">if</span></span><span class="koboSpan" id="kobo.352.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.353.1">nil</span></span><span class="koboSpan" id="kobo.354.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.355.1">"DialTCP:"</span></span><span class="koboSpan" id="kobo.356.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.357.1">return</span></span><span class="koboSpan" id="kobo.358.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.359.1">With the TCP endpoint at hand, we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">net.DialTCP()</span></code><span class="koboSpan" id="kobo.361.1"> to connect to the server. </span><span class="koboSpan" id="kobo.361.2">Apart from the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">net.ResolveTCPAddr()</span></code><span class="koboSpan" id="kobo.363.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">net.DialTCP()</span></code><span class="koboSpan" id="kobo.365.1">, the rest of the code that has to do with the TCP client and TCP server interaction is exactly the same.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.366.1">    reader := bufio.NewReader(os.Stdin)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.367.1">for</span></span><span class="koboSpan" id="kobo.368.1"> {
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.369.1">"&gt;&gt; "</span></span><span class="koboSpan" id="kobo.370.1">)
        text, _ := reader.ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.371.1">'\n'</span></span><span class="koboSpan" id="kobo.372.1">)
        fmt.Fprintf(conn, text+</span><span class="hljs-string"><span class="koboSpan" id="kobo.373.1">"\n"</span></span><span class="koboSpan" id="kobo.374.1">)
        message, _ := bufio.NewReader(conn).ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.375.1">'\n'</span></span><span class="koboSpan" id="kobo.376.1">)
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.377.1">"-&gt;: "</span></span><span class="koboSpan" id="kobo.378.1"> + message)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.379.1">if</span></span><span class="koboSpan" id="kobo.380.1"> strings.TrimSpace(</span><span class="hljs-type"><span class="koboSpan" id="kobo.381.1">string</span></span><span class="koboSpan" id="kobo.382.1">(text)) == </span><span class="hljs-string"><span class="koboSpan" id="kobo.383.1">"STOP"</span></span><span class="koboSpan" id="kobo.384.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.385.1">"TCP client exiting..."</span></span><span class="koboSpan" id="kobo.386.1">)
            conn.Close()
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.387.1">return</span></span><span class="koboSpan" id="kobo.388.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.389.1">Lastly, an infinite </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">for</span></code><span class="koboSpan" id="kobo.391.1"> loop is used to interact with the TCP server. </span><span class="koboSpan" id="kobo.391.2">The TCP client reads user data, which is sent to the server. </span><span class="koboSpan" id="kobo.391.3">After that, it reads data from the TCP server. </span><span class="koboSpan" id="kobo.391.4">Once</span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.392.1"> again, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.393.1">STOP</span></code><span class="koboSpan" id="kobo.394.1"> keyword </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.395.1">terminates the TCP connection on the client side using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.396.1">Close()</span></code><span class="koboSpan" id="kobo.397.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.398.1">Working with </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">otherTCPclient.go</span></code><span class="koboSpan" id="kobo.400.1"> and interacting with a TCP server process produces the next kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.401.1">$ </span></span><span class="koboSpan" id="kobo.402.1">go run otherTCPclient.go localhost:1234
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.403.1">&gt;</span></span><span class="koboSpan" id="kobo.404.1">&gt; Hello!
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.405.1">-&gt;</span></span><span class="koboSpan" id="kobo.406.1">: Hi from nc -l 1234
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.407.1">&gt;</span></span><span class="koboSpan" id="kobo.408.1">&gt; STOP
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.409.1">-&gt;</span></span><span class="koboSpan" id="kobo.410.1">: Thanks </span><span class="hljs-con-keyword"><span class="koboSpan" id="kobo.411.1">for</span></span><span class="koboSpan" id="kobo.412.1"> connecting!
</span><span class="koboSpan" id="kobo.412.2">TCP client exiting...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.413.1">The interaction is the same as with </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">tcpC.go</span></code><span class="koboSpan" id="kobo.415.1">—we have just learned a different way of developing TCP clients. </span><span class="koboSpan" id="kobo.415.2">If you want my opinion, I prefer the implementation found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">tcpC.go</span></code><span class="koboSpan" id="kobo.417.1"> because it uses more generic functions. </span><span class="koboSpan" id="kobo.417.2">However, this is just personal taste.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.418.1">The next section shows how to program TCP servers.</span></p>
<h1 class="heading-1" id="_idParaDest-290"><span class="koboSpan" id="kobo.419.1">Developing a TCP server</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.420.1">This section </span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.421.1">presents two ways of developing TCP servers that can interact with TCP clients, just as we did with the TCP client.</span></p>
<h2 class="heading-2" id="_idParaDest-291"><span class="koboSpan" id="kobo.422.1">Developing a TCP server with net.Listen()</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.423.1">The TCP server </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.424.1">presented in this section, which uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">net.Listen()</span></code><span class="koboSpan" id="kobo.426.1">, returns</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.427.1"> the current date and time to the client in a single network packet. </span><span class="koboSpan" id="kobo.427.2">In practice, this means that after accepting a client connection, the server gets the time and date from the operating system and sends that data back to the client. </span><span class="koboSpan" id="kobo.427.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">net.Listen()</span></code><span class="koboSpan" id="kobo.429.1"> function listens for connections, whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">net.Accept()</span></code><span class="koboSpan" id="kobo.431.1"> method waits for the next connection and returns a generic </span><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">net.Conn</span></code><span class="koboSpan" id="kobo.433.1"> variable with the client information. </span><span class="koboSpan" id="kobo.433.2">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">tcpS.go</span></code><span class="koboSpan" id="kobo.435.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.436.1">package</span></span><span class="koboSpan" id="kobo.437.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.438.1">import</span></span><span class="koboSpan" id="kobo.439.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.440.1">"bufio"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.441.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.442.1">"net"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.443.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.444.1">"strings"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.445.1">"time"</span></span><span class="koboSpan" id="kobo.446.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.447.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.448.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.449.1">()</span></span><span class="koboSpan" id="kobo.450.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.451.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.452.1">len</span></span><span class="koboSpan" id="kobo.453.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.454.1">1</span></span><span class="koboSpan" id="kobo.455.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.456.1">"Please provide port number"</span></span><span class="koboSpan" id="kobo.457.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.458.1">return</span></span><span class="koboSpan" id="kobo.459.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.460.1">The TCP server should know about the port number it is going to use—this is given as a command line argument.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.461.1">    PORT := </span><span class="hljs-string"><span class="koboSpan" id="kobo.462.1">":"</span></span><span class="koboSpan" id="kobo.463.1"> + arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.464.1">1</span></span><span class="koboSpan" id="kobo.465.1">]
    l, err := net.Listen(</span><span class="hljs-string"><span class="koboSpan" id="kobo.466.1">"tcp"</span></span><span class="koboSpan" id="kobo.467.1">, PORT)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.468.1">if</span></span><span class="koboSpan" id="kobo.469.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.470.1">nil</span></span><span class="koboSpan" id="kobo.471.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.472.1">return</span></span><span class="koboSpan" id="kobo.473.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.474.1">defer</span></span><span class="koboSpan" id="kobo.475.1"> l.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.476.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">net.Listen()</span></code><span class="koboSpan" id="kobo.478.1"> function listens for connections and is what makes that particular program a server process. </span><span class="koboSpan" id="kobo.478.2">If the second parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.479.1">net.Listen()</span></code><span class="koboSpan" id="kobo.480.1"> contains a port number without an IP address or a hostname, </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">net.Listen()</span></code><span class="koboSpan" id="kobo.482.1"> listens to all available IP addresses of the local system, which is the case here.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.483.1">This is a personal preference; although it is considered a bad practice to have variable names such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.484.1">PORT</span></code><span class="koboSpan" id="kobo.485.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.486.1">SERVER</span></code><span class="koboSpan" id="kobo.487.1">, this is my own way of signifying important or global variables.</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.488.1">    c, err := l.Accept()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.489.1">if</span></span><span class="koboSpan" id="kobo.490.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.491.1">nil</span></span><span class="koboSpan" id="kobo.492.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.493.1">return</span></span><span class="koboSpan" id="kobo.494.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.495.1">We call </span><code class="inlineCode"><span class="koboSpan" id="kobo.496.1">Accept()</span></code><span class="koboSpan" id="kobo.497.1"> and wait for a client connection—</span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">Accept()</span></code><span class="koboSpan" id="kobo.499.1"> blocks until a new connection comes. </span><span class="koboSpan" id="kobo.499.2">There is something unusual with this particular TCP server: it can only serve the first </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.500.1">TCP</span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.501.1"> client that is going to connect to it because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">Accept()</span></code><span class="koboSpan" id="kobo.503.1"> call is outside of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">for</span></code><span class="koboSpan" id="kobo.505.1"> loop and therefore is </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.506.1">called only once</span></strong><span class="koboSpan" id="kobo.507.1">. </span><span class="koboSpan" id="kobo.507.2">Each individual client should be served by a different </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">Accept()</span></code><span class="koboSpan" id="kobo.509.1"> call, which is not happening here. </span><span class="koboSpan" id="kobo.509.2">Correcting that is left as an exercise for the reader.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.510.1">for</span></span><span class="koboSpan" id="kobo.511.1"> {
        netData, err := bufio.NewReader(c).ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.512.1">'\n'</span></span><span class="koboSpan" id="kobo.513.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.514.1">if</span></span><span class="koboSpan" id="kobo.515.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.516.1">nil</span></span><span class="koboSpan" id="kobo.517.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.518.1">return</span></span><span class="koboSpan" id="kobo.519.1">
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.520.1">if</span></span><span class="koboSpan" id="kobo.521.1"> strings.TrimSpace(</span><span class="hljs-type"><span class="koboSpan" id="kobo.522.1">string</span></span><span class="koboSpan" id="kobo.523.1">(netData)) == </span><span class="hljs-string"><span class="koboSpan" id="kobo.524.1">"STOP"</span></span><span class="koboSpan" id="kobo.525.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.526.1">"Exiting TCP server!"</span></span><span class="koboSpan" id="kobo.527.1">)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.528.1">return</span></span><span class="koboSpan" id="kobo.529.1">
        }
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.530.1">"-&gt; "</span></span><span class="koboSpan" id="kobo.531.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.532.1">string</span></span><span class="koboSpan" id="kobo.533.1">(netData))
        t := time.Now()
        myTime := t.Format(time.RFC3339) + </span><span class="hljs-string"><span class="koboSpan" id="kobo.534.1">"\n"</span></span><span class="koboSpan" id="kobo.535.1">
        c.Write([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.536.1">byte</span></span><span class="koboSpan" id="kobo.537.1">(myTime))
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.538.1">This endless </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">for</span></code><span class="koboSpan" id="kobo.540.1"> loop keeps interacting with the same TCP client until the word </span><code class="inlineCode"><span class="koboSpan" id="kobo.541.1">STOP</span></code><span class="koboSpan" id="kobo.542.1"> is sent from the client. </span><span class="koboSpan" id="kobo.542.2">As it happened with the TCP clients, </span><code class="inlineCode"><span class="koboSpan" id="kobo.543.1">bufio.NewReader()</span></code><span class="koboSpan" id="kobo.544.1"> is used to read data from the network connection, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">Write()</span></code><span class="koboSpan" id="kobo.546.1"> is used to send data to the TCP client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.547.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.548.1">tcpS.go</span></code><span class="koboSpan" id="kobo.549.1"> and interacting with a TCP client produces the next kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.550.1">$ </span></span><span class="koboSpan" id="kobo.551.1">go run tcpS.go 1234
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.552.1">-&gt; </span></span><span class="koboSpan" id="kobo.553.1">Hello!
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.554.1">-&gt; </span></span><span class="koboSpan" id="kobo.555.1">Have to leave now!
</span><span class="koboSpan" id="kobo.555.2">Exiting TCP server!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.556.1">The server connection ended automatically with the client connection because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.557.1">for</span></code><span class="koboSpan" id="kobo.558.1"> loop concluded when </span><code class="inlineCode"><span class="koboSpan" id="kobo.559.1">bufio.NewReader(c).ReadString('\n')</span></code><span class="koboSpan" id="kobo.560.1"> had nothing more to read. </span><span class="koboSpan" id="kobo.560.2">The client was </span><code class="inlineCode"><span class="koboSpan" id="kobo.561.1">nc(1)</span></code><span class="koboSpan" id="kobo.562.1">, which produced the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.563.1">$ </span></span><span class="koboSpan" id="kobo.564.1">nc localhost 1234
Hello!
</span><span class="koboSpan" id="kobo.564.2">2023-10-09T20:02:55+03:00
Have to leave now!
</span><span class="koboSpan" id="kobo.564.3">2023-10-09T20:03:01+03:00
STOP
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.565.1">We have ended the connection using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">STOP</span></code><span class="koboSpan" id="kobo.567.1"> keyword.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.568.1">So, we now</span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.569.1"> know</span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.570.1"> how to develop a TCP server in Go. </span><span class="koboSpan" id="kobo.570.2">As with the TCP client, there is an alternative way to develop a TCP server, which is presented in the next subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-292"><span class="koboSpan" id="kobo.571.1">Developing a TCP server that uses net.ListenTCP()</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.572.1">This time, this </span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.573.1">alternative version of the </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.574.1">TCP server implements the echo service. </span><span class="koboSpan" id="kobo.574.2">Put simply, the TCP server sends back to the client the data that was received by the client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.575.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.576.1">otherTCPserver.go</span></code><span class="koboSpan" id="kobo.577.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.578.1">package</span></span><span class="koboSpan" id="kobo.579.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.580.1">import</span></span><span class="koboSpan" id="kobo.581.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.582.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.583.1">fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.584.1">"net"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.585.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.586.1">"strings"</span></span><span class="koboSpan" id="kobo.587.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.588.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.589.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.590.1">()</span></span><span class="koboSpan" id="kobo.591.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.592.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.593.1">len</span></span><span class="koboSpan" id="kobo.594.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.595.1">1</span></span><span class="koboSpan" id="kobo.596.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.597.1">"Please provide a port number!"</span></span><span class="koboSpan" id="kobo.598.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.599.1">return</span></span><span class="koboSpan" id="kobo.600.1">
    }
    SERVER := </span><span class="hljs-string"><span class="koboSpan" id="kobo.601.1">"localhost"</span></span><span class="koboSpan" id="kobo.602.1"> + </span><span class="hljs-string"><span class="koboSpan" id="kobo.603.1">":"</span></span><span class="koboSpan" id="kobo.604.1"> + arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.605.1">1</span></span><span class="koboSpan" id="kobo.606.1">]
    s, err := net.ResolveTCPAddr(</span><span class="hljs-string"><span class="koboSpan" id="kobo.607.1">"tcp"</span></span><span class="koboSpan" id="kobo.608.1">, SERVER)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.609.1">if</span></span><span class="koboSpan" id="kobo.610.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.611.1">nil</span></span><span class="koboSpan" id="kobo.612.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.613.1">return</span></span><span class="koboSpan" id="kobo.614.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.615.1">The previous code gets the TCP port number value as a command line argument, which is used in </span><code class="inlineCode"><span class="koboSpan" id="kobo.616.1">net.ResolveTCPAddr()</span></code><span class="koboSpan" id="kobo.617.1">—this is required for defining the TCP port number the TCP server is going </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.618.1">to</span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.619.1"> listen to.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.620.1">That function only works with TCP, hence its name.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.621.1">    l, err := net.ListenTCP(</span><span class="hljs-string"><span class="koboSpan" id="kobo.622.1">"tcp"</span></span><span class="koboSpan" id="kobo.623.1">, s)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.624.1">if</span></span><span class="koboSpan" id="kobo.625.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.626.1">nil</span></span><span class="koboSpan" id="kobo.627.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.628.1">return</span></span><span class="koboSpan" id="kobo.629.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.630.1">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.631.1">net.ListenTCP()</span></code><span class="koboSpan" id="kobo.632.1"> only works with TCP and is what makes that program a TCP server ready to accept incoming connections.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.633.1">    buffer := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.634.1">make</span></span><span class="koboSpan" id="kobo.635.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.636.1">byte</span></span><span class="koboSpan" id="kobo.637.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.638.1">1024</span></span><span class="koboSpan" id="kobo.639.1">)
    conn, err := l.Accept()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.640.1">if</span></span><span class="koboSpan" id="kobo.641.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.642.1">nil</span></span><span class="koboSpan" id="kobo.643.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.644.1">return</span></span><span class="koboSpan" id="kobo.645.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.646.1">As before, due to the place where </span><code class="inlineCode"><span class="koboSpan" id="kobo.647.1">Accept()</span></code><span class="koboSpan" id="kobo.648.1"> is called, this particular implementation can work with a single client only. </span><span class="koboSpan" id="kobo.648.2">This is used for reasons of simplicity. </span><span class="koboSpan" id="kobo.648.3">The concurrent TCP server that is developed later on in this chapter puts the </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">Accept()</span></code><span class="koboSpan" id="kobo.650.1"> call inside an endless </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">for</span></code><span class="koboSpan" id="kobo.652.1"> loop.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.653.1">for</span></span><span class="koboSpan" id="kobo.654.1"> {
        n, err := conn.Read(buffer)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.655.1">if</span></span><span class="koboSpan" id="kobo.656.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.657.1">nil</span></span><span class="koboSpan" id="kobo.658.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.659.1">return</span></span><span class="koboSpan" id="kobo.660.1">
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.661.1">if</span></span><span class="koboSpan" id="kobo.662.1"> strings.TrimSpace(</span><span class="hljs-type"><span class="koboSpan" id="kobo.663.1">string</span></span><span class="koboSpan" id="kobo.664.1">(buffer[</span><span class="hljs-number"><span class="koboSpan" id="kobo.665.1">0</span></span><span class="koboSpan" id="kobo.666.1">:n])) == </span><span class="hljs-string"><span class="koboSpan" id="kobo.667.1">"STOP"</span></span><span class="koboSpan" id="kobo.668.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.669.1">"Exiting TCP server!"</span></span><span class="koboSpan" id="kobo.670.1">)
            conn.Close()
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.671.1">return</span></span><span class="koboSpan" id="kobo.672.1">
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.673.1">You need to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.674.1">strings.TrimSpace()</span></code><span class="koboSpan" id="kobo.675.1"> in order to remove any space characters from your input and compare the result with </span><code class="inlineCode"><span class="koboSpan" id="kobo.676.1">STOP</span></code><span class="koboSpan" id="kobo.677.1">, which has a special meaning in this implementation. </span><span class="koboSpan" id="kobo.677.2">Once the </span><code class="inlineCode"><span class="koboSpan" id="kobo.678.1">STOP</span></code><span class="koboSpan" id="kobo.679.1"> keyword is received from the client, the server closes the connection using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.680.1">Close()</span></code><span class="koboSpan" id="kobo.681.1"> method.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.682.1">        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.683.1">"&gt; "</span></span><span class="koboSpan" id="kobo.684.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.685.1">string</span></span><span class="koboSpan" id="kobo.686.1">(buffer[</span><span class="hljs-number"><span class="koboSpan" id="kobo.687.1">0</span></span><span class="koboSpan" id="kobo.688.1">:n</span><span class="hljs-number"><span class="koboSpan" id="kobo.689.1">-1</span></span><span class="koboSpan" id="kobo.690.1">]), </span><span class="hljs-string"><span class="koboSpan" id="kobo.691.1">"\n"</span></span><span class="koboSpan" id="kobo.692.1">)
        _, err = conn.Write(buffer)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.693.1">if</span></span><span class="koboSpan" id="kobo.694.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.695.1">nil</span></span><span class="koboSpan" id="kobo.696.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.697.1">return</span></span><span class="koboSpan" id="kobo.698.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.699.1">All previous code is </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.700.1">for</span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.701.1"> interacting with the TCP client until the client decides to close the connection. </span><span class="koboSpan" id="kobo.701.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">otherTCPserver.go</span></code><span class="koboSpan" id="kobo.703.1"> and interacting with a TCP client produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.704.1">$ </span></span><span class="koboSpan" id="kobo.705.1">go run otherTCPserver.go 1234
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.706.1">&gt; </span></span><span class="koboSpan" id="kobo.707.1">Hello from the client!
</span><span class="koboSpan" id="kobo.707.2">Exiting TCP server!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.708.1">The first line that begins with </span><code class="inlineCode"><span class="koboSpan" id="kobo.709.1">&gt;</span></code><span class="koboSpan" id="kobo.710.1"> is the client message, whereas the second line is the server output when getting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.711.1">STOP</span></code><span class="koboSpan" id="kobo.712.1"> message from the client. </span><span class="koboSpan" id="kobo.712.2">Therefore, the TCP server processes client requests as programmed and exits when it gets the </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">STOP</span></code><span class="koboSpan" id="kobo.714.1"> message, which is the desired behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.715.1">The next section is about developing UDP clients.</span></p>
<h1 class="heading-1" id="_idParaDest-293"><span class="koboSpan" id="kobo.716.1">Developing a UDP client</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.717.1">This section </span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.718.1">demonstrates how to develop a UDP client that can interact with UDP services. </span><span class="koboSpan" id="kobo.718.2">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">udpC.go</span></code><span class="koboSpan" id="kobo.720.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.721.1">package</span></span><span class="koboSpan" id="kobo.722.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.723.1">import</span></span><span class="koboSpan" id="kobo.724.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.725.1">"bufio"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.726.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.727.1">"net"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.728.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.729.1">"strings"</span></span><span class="koboSpan" id="kobo.730.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.731.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.732.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.733.1">()</span></span><span class="koboSpan" id="kobo.734.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.735.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.736.1">len</span></span><span class="koboSpan" id="kobo.737.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.738.1">1</span></span><span class="koboSpan" id="kobo.739.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.740.1">"Please provide a host:port string"</span></span><span class="koboSpan" id="kobo.741.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.742.1">return</span></span><span class="koboSpan" id="kobo.743.1">
    }
    CONNECT := arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.744.1">1</span></span><span class="koboSpan" id="kobo.745.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.746.1">This is how we get the UDP server details from the user.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.747.1">    s, err := net.ResolveUDPAddr(</span><span class="hljs-string"><span class="koboSpan" id="kobo.748.1">"udp4"</span></span><span class="koboSpan" id="kobo.749.1">, CONNECT)
    c, err := net.DialUDP(</span><span class="hljs-string"><span class="koboSpan" id="kobo.750.1">"udp4"</span></span><span class="koboSpan" id="kobo.751.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.752.1">nil</span></span><span class="koboSpan" id="kobo.753.1">, s)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.754.1">The previous two lines declare that we are using UDP and that we want to connect to the UDP server that is specified by the return value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">net.ResolveUDPAddr()</span></code><span class="koboSpan" id="kobo.756.1">. </span><span class="koboSpan" id="kobo.756.2">The actual connection is initiated using </span><code class="inlineCode"><span class="koboSpan" id="kobo.757.1">net.DialUDP()</span></code><span class="koboSpan" id="kobo.758.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.759.1">if</span></span><span class="koboSpan" id="kobo.760.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.761.1">nil</span></span><span class="koboSpan" id="kobo.762.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.763.1">return</span></span><span class="koboSpan" id="kobo.764.1">
    }
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.765.1">"The UDP server is %s\n"</span></span><span class="koboSpan" id="kobo.766.1">, c.RemoteAddr().String())
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.767.1">defer</span></span><span class="koboSpan" id="kobo.768.1"> c.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.769.1">This part of the program finds the details of the UDP server by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">RemoteAddr()</span></code><span class="koboSpan" id="kobo.771.1"> method.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.772.1">    reader := bufio.NewReader(os.Stdin)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.773.1">for</span></span><span class="koboSpan" id="kobo.774.1"> {
        
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.775.1">"&gt;&gt; "</span></span><span class="koboSpan" id="kobo.776.1">)
        text, _ := reader.ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.777.1">'\n'</span></span><span class="koboSpan" id="kobo.778.1">)
        data := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.779.1">byte</span></span><span class="koboSpan" id="kobo.780.1">(text + </span><span class="hljs-string"><span class="koboSpan" id="kobo.781.1">"\n"</span></span><span class="koboSpan" id="kobo.782.1">)
        _, err = c.Write(data)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.783.1">Data is read from the user using </span><code class="inlineCode"><span class="koboSpan" id="kobo.784.1">bufio.NewReader(os.Stdin)</span></code><span class="koboSpan" id="kobo.785.1"> and is written to the UDP server using </span><code class="inlineCode"><span class="koboSpan" id="kobo.786.1">Write()</span></code><span class="koboSpan" id="kobo.787.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.788.1">if</span></span><span class="koboSpan" id="kobo.789.1"> strings.TrimSpace(</span><span class="hljs-type"><span class="koboSpan" id="kobo.790.1">string</span></span><span class="koboSpan" id="kobo.791.1">(data)) == </span><span class="hljs-string"><span class="koboSpan" id="kobo.792.1">"STOP"</span></span><span class="koboSpan" id="kobo.793.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.794.1">"Exiting UDP client!"</span></span><span class="koboSpan" id="kobo.795.1">)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.796.1">return</span></span><span class="koboSpan" id="kobo.797.1">
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.798.1">If the input read from the user is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.799.1">STOP</span></code><span class="koboSpan" id="kobo.800.1"> keyword, then the connection is terminated.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.801.1">if</span></span><span class="koboSpan" id="kobo.802.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.803.1">nil</span></span><span class="koboSpan" id="kobo.804.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.805.1">return</span></span><span class="koboSpan" id="kobo.806.1">
        }
        buffer := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.807.1">make</span></span><span class="koboSpan" id="kobo.808.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.809.1">byte</span></span><span class="koboSpan" id="kobo.810.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.811.1">1024</span></span><span class="koboSpan" id="kobo.812.1">)
        n, _, err := c.ReadFromUDP(buffer)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.813.1">Data is read from </span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.814.1">the UDP connection using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.815.1">ReadFromUDP()</span></code><span class="koboSpan" id="kobo.816.1"> method.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.817.1">if</span></span><span class="koboSpan" id="kobo.818.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.819.1">nil</span></span><span class="koboSpan" id="kobo.820.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.821.1">return</span></span><span class="koboSpan" id="kobo.822.1">
        }
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.823.1">"Reply: %s\n"</span></span><span class="koboSpan" id="kobo.824.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.825.1">string</span></span><span class="koboSpan" id="kobo.826.1">(buffer[</span><span class="hljs-number"><span class="koboSpan" id="kobo.827.1">0</span></span><span class="koboSpan" id="kobo.828.1">:n]))
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.829.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.830.1">for</span></code><span class="koboSpan" id="kobo.831.1"> loop is going to keep going forever until the </span><code class="inlineCode"><span class="koboSpan" id="kobo.832.1">STOP</span></code><span class="koboSpan" id="kobo.833.1"> keyword is received as input or the program is terminated in some other way.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.834.1">Working with </span><code class="inlineCode"><span class="koboSpan" id="kobo.835.1">udpC.go</span></code><span class="koboSpan" id="kobo.836.1"> is as simple as follows—the client side is implemented using </span><code class="inlineCode"><span class="koboSpan" id="kobo.837.1">nc(1)</span></code><span class="koboSpan" id="kobo.838.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.839.1">$ </span></span><span class="koboSpan" id="kobo.840.1">go run udpC.go localhost:1234
The UDP server is 127.0.0.1:1234
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.841.1">127.0.0.1:1234</span></code><span class="koboSpan" id="kobo.842.1"> is the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.843.1">c.RemoteAddr().String()</span></code><span class="koboSpan" id="kobo.844.1">, which shows the details of the UDP server we have connected to.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.845.1">&gt;</span></span><span class="koboSpan" id="kobo.846.1">&gt; Hello!
</span><span class="koboSpan" id="kobo.846.2">Reply: Hi from the server.
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.847.1">Our client sent </span><code class="inlineCode"><span class="koboSpan" id="kobo.848.1">Hello!</span></code><span class="koboSpan" id="kobo.849.1"> to the UDP server and received </span><code class="inlineCode"><span class="koboSpan" id="kobo.850.1">Hi from the server.</span></code><span class="koboSpan" id="kobo.851.1"> back.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.852.1">&gt;</span></span><span class="koboSpan" id="kobo.853.1">&gt; Have to leave now :)
Reply: OK - bye from nc -l -u 1234
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.854.1">Our client sent </span><code class="inlineCode"><span class="koboSpan" id="kobo.855.1">Have to leave now :)</span></code><span class="koboSpan" id="kobo.856.1"> to the UDP server and received </span><code class="inlineCode"><span class="koboSpan" id="kobo.857.1">OK - bye from nc -l -u 1234</span></code><span class="koboSpan" id="kobo.858.1"> back. </span><span class="koboSpan" id="kobo.858.2">The UDP server started using </span><code class="inlineCode"><span class="koboSpan" id="kobo.859.1">nc -l -u 1234</span></code><span class="koboSpan" id="kobo.860.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.861.1">&gt;</span></span><span class="koboSpan" id="kobo.862.1">&gt; STOP
Exiting UDP client!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.863.1">Finally, after sending the </span><code class="inlineCode"><span class="koboSpan" id="kobo.864.1">STOP</span></code><span class="koboSpan" id="kobo.865.1"> keyword to the server, the client prints </span><code class="inlineCode"><span class="koboSpan" id="kobo.866.1">Exiting UDP client!</span></code><span class="koboSpan" id="kobo.867.1"> and terminates—the message is defined in the Go code and can be anything you want.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.868.1">The next section is </span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.869.1">about programming a UDP server.</span></p>
<h1 class="heading-1" id="_idParaDest-294"><span class="koboSpan" id="kobo.870.1">Developing a UDP server</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.871.1">This section </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.872.1">shows how to develop a UDP server, which generates and returns random numbers to its clients. </span><span class="koboSpan" id="kobo.872.2">The code for the UDP server (</span><code class="inlineCode"><span class="koboSpan" id="kobo.873.1">udpS.go</span></code><span class="koboSpan" id="kobo.874.1">) is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.875.1">package</span></span><span class="koboSpan" id="kobo.876.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.877.1">import</span></span><span class="koboSpan" id="kobo.878.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.879.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.880.1">"math/rand"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.881.1">"net"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.882.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.883.1">"strconv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.884.1">"strings"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.885.1">"time"</span></span><span class="koboSpan" id="kobo.886.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.887.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.888.1">random</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.889.1">(min, max </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.890.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.891.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.892.1">int</span></span><span class="koboSpan" id="kobo.893.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.894.1">return</span></span><span class="koboSpan" id="kobo.895.1"> rand.Intn(max-min) + min
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.896.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.897.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.898.1">()</span></span><span class="koboSpan" id="kobo.899.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.900.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.901.1">len</span></span><span class="koboSpan" id="kobo.902.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.903.1">1</span></span><span class="koboSpan" id="kobo.904.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.905.1">"Please provide a port number!"</span></span><span class="koboSpan" id="kobo.906.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.907.1">return</span></span><span class="koboSpan" id="kobo.908.1">
    }
    PORT := </span><span class="hljs-string"><span class="koboSpan" id="kobo.909.1">":"</span></span><span class="koboSpan" id="kobo.910.1"> + arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.911.1">1</span></span><span class="koboSpan" id="kobo.912.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.913.1">The UDP port number the server is going to listen to is provided as a command line argument.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.914.1">    s, err := net.ResolveUDPAddr(</span><span class="hljs-string"><span class="koboSpan" id="kobo.915.1">"udp4"</span></span><span class="koboSpan" id="kobo.916.1">, PORT)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.917.1">if</span></span><span class="koboSpan" id="kobo.918.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.919.1">nil</span></span><span class="koboSpan" id="kobo.920.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.921.1">return</span></span><span class="koboSpan" id="kobo.922.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.923.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.924.1">net.ResolveUDPAddr()</span></code><span class="koboSpan" id="kobo.925.1"> function creates a UDP endpoint that the UDP server is going to listen to.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.926.1">    connection, err := net.ListenUDP(</span><span class="hljs-string"><span class="koboSpan" id="kobo.927.1">"udp4"</span></span><span class="koboSpan" id="kobo.928.1">, s)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.929.1">if</span></span><span class="koboSpan" id="kobo.930.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.931.1">nil</span></span><span class="koboSpan" id="kobo.932.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.933.1">return</span></span><span class="koboSpan" id="kobo.934.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.935.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.936.1">net.ListenUDP("udp4", s)</span></code><span class="koboSpan" id="kobo.937.1"> function call makes this process a server for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">udp4</span></code><span class="koboSpan" id="kobo.939.1"> protocol using the </span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.940.1">details specified by its second parameter.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.941.1">defer</span></span><span class="koboSpan" id="kobo.942.1"> connection.Close()
    buffer := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.943.1">make</span></span><span class="koboSpan" id="kobo.944.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.945.1">byte</span></span><span class="koboSpan" id="kobo.946.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.947.1">1024</span></span><span class="koboSpan" id="kobo.948.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.949.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.950.1">buffer</span></code><span class="koboSpan" id="kobo.951.1"> variable stores a byte slice with 1024 bytes and is used to read data from the connection with the UDP client.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.952.1">    rand.Seed(time.Now().Unix())
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.953.1">for</span></span><span class="koboSpan" id="kobo.954.1"> {
        n, addr, err := connection.ReadFromUDP(buffer)
        fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.955.1">"-&gt; "</span></span><span class="koboSpan" id="kobo.956.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.957.1">string</span></span><span class="koboSpan" id="kobo.958.1">(buffer[</span><span class="hljs-number"><span class="koboSpan" id="kobo.959.1">0</span></span><span class="koboSpan" id="kobo.960.1">:n</span><span class="hljs-number"><span class="koboSpan" id="kobo.961.1">-1</span></span><span class="koboSpan" id="kobo.962.1">]))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.963.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.964.1">ReadFromUDP()</span></code><span class="koboSpan" id="kobo.965.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.966.1">WriteToUDP()</span></code><span class="koboSpan" id="kobo.967.1"> methods are used to read data from a UDP connection and write data to a UDP connection, respectively. </span><span class="koboSpan" id="kobo.967.2">Additionally, due to the way UDP operates, the UDP server can serve multiple clients.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.968.1">if</span></span><span class="koboSpan" id="kobo.969.1"> strings.TrimSpace(</span><span class="hljs-type"><span class="koboSpan" id="kobo.970.1">string</span></span><span class="koboSpan" id="kobo.971.1">(buffer[</span><span class="hljs-number"><span class="koboSpan" id="kobo.972.1">0</span></span><span class="koboSpan" id="kobo.973.1">:n])) == </span><span class="hljs-string"><span class="koboSpan" id="kobo.974.1">"STOP"</span></span><span class="koboSpan" id="kobo.975.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.976.1">"Exiting UDP server!"</span></span><span class="koboSpan" id="kobo.977.1">)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.978.1">return</span></span><span class="koboSpan" id="kobo.979.1">
        }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.980.1">The UDP server terminates when any one of the clients sends the </span><code class="inlineCode"><span class="koboSpan" id="kobo.981.1">STOP</span></code><span class="koboSpan" id="kobo.982.1"> message. </span><span class="koboSpan" id="kobo.982.2">Aside from this, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.983.1">for</span></code><span class="koboSpan" id="kobo.984.1"> loop is going to keep running forever.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.985.1">        data := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.986.1">byte</span></span><span class="koboSpan" id="kobo.987.1">(strconv.Itoa(random(</span><span class="hljs-number"><span class="koboSpan" id="kobo.988.1">1</span></span><span class="koboSpan" id="kobo.989.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.990.1">1001</span></span><span class="koboSpan" id="kobo.991.1">)))
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.992.1">"data: %s\n"</span></span><span class="koboSpan" id="kobo.993.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.994.1">string</span></span><span class="koboSpan" id="kobo.995.1">(data))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.996.1">A byte slice is stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.997.1">data</span></code><span class="koboSpan" id="kobo.998.1"> variable and used to write the desired data to the client.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.999.1">        _, err = connection.WriteToUDP(data, addr)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1000.1">if</span></span><span class="koboSpan" id="kobo.1001.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1002.1">nil</span></span><span class="koboSpan" id="kobo.1003.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1004.1">return</span></span><span class="koboSpan" id="kobo.1005.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1006.1">Working with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1007.1">udpS.go</span></code><span class="koboSpan" id="kobo.1008.1"> is as simple as the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1009.1">$ </span></span><span class="koboSpan" id="kobo.1010.1">go run udpS.go 1234
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1011.1">-&gt; </span></span><span class="koboSpan" id="kobo.1012.1">Hello from client!
</span><span class="koboSpan" id="kobo.1012.2">data: 403
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1013.1">Lines beginning </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.1014.1">with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1015.1">-&gt;</span></code><span class="koboSpan" id="kobo.1016.1"> show data coming from a client. </span><span class="koboSpan" id="kobo.1016.2">Lines beginning with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1017.1">data:</span></code><span class="koboSpan" id="kobo.1018.1"> show random numbers generated by the UDP server—in this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1019.1">403</span></code><span class="koboSpan" id="kobo.1020.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1021.1">-&gt; </span></span><span class="koboSpan" id="kobo.1022.1">Going to terminate the connection now.
</span><span class="koboSpan" id="kobo.1022.2">data: 154
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1023.1">The previous two lines show another interaction with a UDP client.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1024.1">-&gt; </span></span><span class="koboSpan" id="kobo.1025.1">STOP
Exiting UDP server!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1026.1">Once the UDP server receives the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1027.1">STOP</span></code><span class="koboSpan" id="kobo.1028.1"> keyword from the client, it closes the connection and exits.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1029.1">On the client side, which uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.1030.1">udpC.go</span></code><span class="koboSpan" id="kobo.1031.1">, we have the following interaction:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1032.1">$ </span></span><span class="koboSpan" id="kobo.1033.1">go run udpC.go localhost:1234
The UDP server is 127.0.0.1:1234
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1034.1">&gt;</span></span><span class="koboSpan" id="kobo.1035.1">&gt; Hello from client!
</span><span class="koboSpan" id="kobo.1035.2">Reply: 403
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1036.1">The client sends the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1037.1">Hello from client!</span></code><span class="koboSpan" id="kobo.1038.1"> message to the server and receives </span><code class="inlineCode"><span class="koboSpan" id="kobo.1039.1">403</span></code><span class="koboSpan" id="kobo.1040.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1041.1">&gt;</span></span><span class="koboSpan" id="kobo.1042.1">&gt; Going to terminate the connection now.
</span><span class="koboSpan" id="kobo.1042.2">Reply: 154
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1043.1">The client sends </span><code class="inlineCode"><span class="koboSpan" id="kobo.1044.1">Going to terminate the connection now.</span></code><span class="koboSpan" id="kobo.1045.1"> to the server and receives the random number</span><code class="inlineCode"><span class="koboSpan" id="kobo.1046.1"> 154</span></code><span class="koboSpan" id="kobo.1047.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1048.1">&gt;</span></span><span class="koboSpan" id="kobo.1049.1">&gt; STOP
Exiting UDP client!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1050.1">When the client gets </span><code class="inlineCode"><span class="koboSpan" id="kobo.1051.1">STOP</span></code><span class="koboSpan" id="kobo.1052.1"> as user input, it terminates the UDP connection and exits.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1053.1">The next section shows</span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.1054.1"> how to develop a concurrent TCP server that uses goroutines for serving its clients.</span></p>
<h1 class="heading-1" id="_idParaDest-295"><span class="koboSpan" id="kobo.1055.1">Developing concurrent TCP servers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1056.1">This section</span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.1057.1"> teaches you a pattern for developing concurrent TCP servers, which are servers that use separate goroutines to serve their clients following a successful </span><code class="inlineCode"><span class="koboSpan" id="kobo.1058.1">Accept()</span></code><span class="koboSpan" id="kobo.1059.1"> call. </span><span class="koboSpan" id="kobo.1059.2">Therefore, such servers can serve multiple TCP clients at the same time. </span><span class="koboSpan" id="kobo.1059.3">This is how real-world production servers and services are implemented.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1060.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1061.1">concTCP.go</span></code><span class="koboSpan" id="kobo.1062.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1063.1">package</span></span><span class="koboSpan" id="kobo.1064.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1065.1">import</span></span><span class="koboSpan" id="kobo.1066.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1067.1">"bufio"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1068.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1069.1">"net"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1070.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1071.1">os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1072.1">"strconv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1073.1">"strings"</span></span><span class="koboSpan" id="kobo.1074.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1075.1">var</span></span><span class="koboSpan" id="kobo.1076.1"> count = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1077.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1078.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1079.1">handleConnection</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1080.1">(c net.Conn, myCount </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1081.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1082.1">)</span></span><span class="koboSpan" id="kobo.1083.1"> {
    fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1084.1">"."</span></span><span class="koboSpan" id="kobo.1085.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1086.1">The previous statement is not required—it just informs us that a new client has been connected.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1087.1">    netData, err := bufio.NewReader(c).ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1088.1">'\n'</span></span><span class="koboSpan" id="kobo.1089.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1090.1">if</span></span><span class="koboSpan" id="kobo.1091.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1092.1">nil</span></span><span class="koboSpan" id="kobo.1093.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1094.1">return</span></span><span class="koboSpan" id="kobo.1095.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1096.1">for</span></span><span class="koboSpan" id="kobo.1097.1"> {
     
        temp := strings.TrimSpace(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1098.1">string</span></span><span class="koboSpan" id="kobo.1099.1">(netData))
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1100.1">if</span></span><span class="koboSpan" id="kobo.1101.1"> temp == </span><span class="hljs-string"><span class="koboSpan" id="kobo.1102.1">"STOP"</span></span><span class="koboSpan" id="kobo.1103.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1104.1">break</span></span><span class="koboSpan" id="kobo.1105.1">
        }
        fmt.Println(temp)
        counter := </span><span class="hljs-string"><span class="koboSpan" id="kobo.1106.1">"Client number: "</span></span><span class="koboSpan" id="kobo.1107.1"> + strconv.Itoa(myCount) + </span><span class="hljs-string"><span class="koboSpan" id="kobo.1108.1">"\n"</span></span><span class="koboSpan" id="kobo.1109.1">
        c.Write([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1110.1">byte</span></span><span class="koboSpan" id="kobo.1111.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1112.1">string</span></span><span class="koboSpan" id="kobo.1113.1">(counter)))
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1114.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1115.1">for</span></code><span class="koboSpan" id="kobo.1116.1"> loop makes sure that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1117.1">handleConnection()</span></code><span class="koboSpan" id="kobo.1118.1"> is not going to exit automatically. </span><span class="koboSpan" id="kobo.1118.2">Once again, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1119.1">STOP</span></code><span class="koboSpan" id="kobo.1120.1"> keyword stops the goroutine of the current client connection—however, the server </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.1121.1">process, as well as all other active client connections, is going to keep running.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1122.1">defer</span></span><span class="koboSpan" id="kobo.1123.1"> c.Close()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1124.1">This is the end of the function that is executed as a goroutine to serve clients. </span><span class="koboSpan" id="kobo.1124.2">All you need in order to serve a client is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1125.1">net.Conn</span></code><span class="koboSpan" id="kobo.1126.1"> parameter with the TCP client details. </span><span class="koboSpan" id="kobo.1126.2">After reading the client data, the server sends back a message to the current TCP client indicating the total number of TCP clients that have been served so far.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1127.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1128.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1129.1">()</span></span><span class="koboSpan" id="kobo.1130.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1131.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1132.1">len</span></span><span class="koboSpan" id="kobo.1133.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1134.1">1</span></span><span class="koboSpan" id="kobo.1135.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1136.1">"Please provide a port number!"</span></span><span class="koboSpan" id="kobo.1137.1">)
        
        os.Exit(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1138.1">5</span></span><span class="koboSpan" id="kobo.1139.1">)
    }
    PORT := </span><span class="hljs-string"><span class="koboSpan" id="kobo.1140.1">":"</span></span><span class="koboSpan" id="kobo.1141.1"> + arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1142.1">1</span></span><span class="koboSpan" id="kobo.1143.1">]
    l, err := net.Listen(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1144.1">"tcp4"</span></span><span class="koboSpan" id="kobo.1145.1">, PORT)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1146.1">if</span></span><span class="koboSpan" id="kobo.1147.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1148.1">nil</span></span><span class="koboSpan" id="kobo.1149.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1150.1">return</span></span><span class="koboSpan" id="kobo.1151.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1152.1">defer</span></span><span class="koboSpan" id="kobo.1153.1"> l.Close()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1154.1">for</span></span><span class="koboSpan" id="kobo.1155.1"> {
        c, err := l.Accept()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1156.1">if</span></span><span class="koboSpan" id="kobo.1157.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1158.1">nil</span></span><span class="koboSpan" id="kobo.1159.1"> {
            fmt.Println(err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1160.1">return</span></span><span class="koboSpan" id="kobo.1161.1">
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1162.1">go</span></span><span class="koboSpan" id="kobo.1163.1"> handleConnection(c, count)
        count++
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1164.1">Each time a new client connects to the server, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1165.1">count</span></code><span class="koboSpan" id="kobo.1166.1"> variable is increased. </span><span class="koboSpan" id="kobo.1166.2">Each TCP client is served by a separate goroutine that executes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1167.1">handleConnection()</span></code><span class="koboSpan" id="kobo.1168.1"> function. </span><span class="koboSpan" id="kobo.1168.2">This frees the server process and allows it to accept new connections. </span><span class="koboSpan" id="kobo.1168.3">Put simply, while multiple TCP clients are being served, the TCP server is free to interact with more TCP clients. </span><span class="koboSpan" id="kobo.1168.4">As before, new TCP clients are connected using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1169.1">Accept()</span></code><span class="koboSpan" id="kobo.1170.1"> function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1171.1">Working with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1172.1">concTCP.go</span></code><span class="koboSpan" id="kobo.1173.1"> produces the next kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1174.1">$ </span></span><span class="koboSpan" id="kobo.1175.1">go run concTCP.go 1234
.Hello
.Hi from  nc localhost 1234
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1176.1">The first line of output is from the first TCP client, whereas the second line is from the second TCP client. </span><span class="koboSpan" id="kobo.1176.2">This means that the concurrent TCP server works as expected. </span><span class="koboSpan" id="kobo.1176.3">Therefore, when you want to be able to serve multiple TCP clients in your TCP services, you can use the</span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.1177.1"> presented technique and code as a template for developing your own concurrent TCP servers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1178.1">The sections that follow concern the WebSocket protocol.</span></p>
<h1 class="heading-1" id="_idParaDest-296"><span class="koboSpan" id="kobo.1179.1">Creating a WebSocket server</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1180.1">The WebSocket</span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.1181.1"> protocol is a computer communications protocol that provides full-duplex (transmission of data in two directions simultaneously) communication channels over a single TCP connection. </span><span class="koboSpan" id="kobo.1181.2">The WebSocket protocol is </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.1182.1">defined in RFC 6455 (</span><a href="https://tools.ietf.org/html/rfc6455"><span class="url"><span class="koboSpan" id="kobo.1183.1">https://tools.ietf.org/html/rfc6455</span></span></a><span class="koboSpan" id="kobo.1184.1">) and uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.1185.1">ws://</span></code><span class="koboSpan" id="kobo.1186.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1187.1">wss://</span></code><span class="koboSpan" id="kobo.1188.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1189.1">http://</span></code><span class="koboSpan" id="kobo.1190.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1191.1">https://</span></code><span class="koboSpan" id="kobo.1192.1">, respectively. </span><span class="koboSpan" id="kobo.1192.2">Therefore, the client should begin a WebSocket connection by using a URL that starts with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1193.1">ws://</span></code><span class="koboSpan" id="kobo.1194.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1195.1">In this section, we are going to develop a small yet fully functional WebSocket server using</span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.1196.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1197.1">gorilla/websocket</span></code><span class="koboSpan" id="kobo.1198.1"> (</span><a href="https://github.com/gorilla/websocket"><span class="url"><span class="koboSpan" id="kobo.1199.1">https://github.com/gorilla/websocket</span></span></a><span class="koboSpan" id="kobo.1200.1">) module. </span><span class="koboSpan" id="kobo.1200.2">The server implements the echo service, which means that it automatically returns the client input back to the client.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1201.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1202.1">https://pkg.go.dev/golang.org/x/net/websocket</span></code><span class="koboSpan" id="kobo.1203.1"> package offers another way of developing WebSocket clients and servers. </span><span class="koboSpan" id="kobo.1203.2">However, based on its documentation, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1204.1">pkg.go.dev/golang.org/x/net/websocket</span></code><span class="koboSpan" id="kobo.1205.1"> lacks some features and it is advised to use either </span><a href="https://pkg.go.dev/github.com/gorilla/websocket"><span class="url"><span class="koboSpan" id="kobo.1206.1">https://pkg.go.dev/github.com/gorilla/websocket</span></span></a><span class="koboSpan" id="kobo.1207.1">, the one used here, or </span><a href="https://pkg.go.dev/nhooyr.io/websocket"><span class="url"><span class="koboSpan" id="kobo.1208.1">https://pkg.go.dev/nhooyr.io/websocket</span></span></a><span class="koboSpan" id="kobo.1209.1"> instead.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1210.1">You might ask why to use the WebSocket protocol instead of HTTP. </span><span class="koboSpan" id="kobo.1210.2">The advantages of the WebSocket</span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.1211.1"> protocol include the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1212.1">A WebSocket connection is a full-duplex, bidirectional communications channel. </span><span class="koboSpan" id="kobo.1212.2">This means that a server does not need to wait to read from a client to send data to the client and vice versa.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1213.1">WebSocket connections are raw TCP sockets, which means that they do not have the overhead required to establish an HTTP connection.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1214.1">WebSocket connections can also be used to send HTTP data. </span><span class="koboSpan" id="kobo.1214.2">However, plain HTTP connections cannot work as WebSocket connections.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1215.1">WebSocket connections live until they are killed, so there is no need to reopen them all the time.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1216.1">WebSocket connections can be used for real-time web applications.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1217.1">Data can be sent from the server to the client at any time, without the client even requesting it.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1218.1">WebSocket is part of the HTML5 specification, which means that it is supported by all modern web browsers.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1219.1">Before showing the server implementation, it would be good for you to know that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1220.1">websocket.Upgrader</span></code><span class="koboSpan" id="kobo.1221.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1222.1">gorilla/websocket</span></code><span class="koboSpan" id="kobo.1223.1"> package upgrades an HTTP server connection to the WebSocket protocol and allows you to define the parameters of the upgrade. </span><span class="koboSpan" id="kobo.1223.2">After that, your HTTP connection is a WebSocket connection, which means that you will not be allowed to execute statements that work with the HTTP protocol.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1224.1">The next subsection</span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.1225.1"> shows the implementation of the server.</span></p>
<h2 class="heading-2" id="_idParaDest-297"><span class="koboSpan" id="kobo.1226.1">The implementation of the server</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1227.1">This subsection </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.1228.1">presents the implementation of the WebSocket server that implements the echo service, which can be really handy when testing network connections.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1229.1">The code is put inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.1230.1">~/go/src/github.com/mactsouk/mGo4th/ch10/ws</span></code><span class="koboSpan" id="kobo.1231.1">. </span><span class="koboSpan" id="kobo.1231.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1232.1">server</span></code><span class="koboSpan" id="kobo.1233.1"> directory contains the implementation of the server whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1234.1">client</span></code><span class="koboSpan" id="kobo.1235.1"> directory contains the implementation of the WebSocket client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1236.1">The implementation of the WebSocket server can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1237.1">server.go</span></code><span class="koboSpan" id="kobo.1238.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1239.1">package</span></span><span class="koboSpan" id="kobo.1240.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1241.1">import</span></span><span class="koboSpan" id="kobo.1242.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1243.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1244.1">"log"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1245.1">"net/http"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1246.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1247.1">"time"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1248.1">"github.com/gorilla/websocket"</span></span><span class="koboSpan" id="kobo.1249.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1250.1">This is the external package used for working with the WebSocket protocol.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1251.1">var</span></span><span class="koboSpan" id="kobo.1252.1"> PORT = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1253.1">":1234"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1254.1">var</span></span><span class="koboSpan" id="kobo.1255.1"> upgrader = websocket.Upgrader{
    ReadBufferSize:  </span><span class="hljs-number"><span class="koboSpan" id="kobo.1256.1">1024</span></span><span class="koboSpan" id="kobo.1257.1">,
    WriteBufferSize: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1258.1">1024</span></span><span class="koboSpan" id="kobo.1259.1">,
    CheckOrigin: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1260.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1261.1">(r *http.Request)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1262.1">bool</span></span><span class="koboSpan" id="kobo.1263.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1264.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1265.1">true</span></span><span class="koboSpan" id="kobo.1266.1">
    },
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1267.1">This is where the parameters of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1268.1">websocket.Upgrader</span></code><span class="koboSpan" id="kobo.1269.1"> are defined. </span><span class="koboSpan" id="kobo.1269.2">They are going to be used shortly.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1270.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1271.1">rootHandler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1272.1">(w http.ResponseWriter, r *http.Request)</span></span><span class="koboSpan" id="kobo.1273.1"> {
    fmt.Fprintf(w, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1274.1">"Welcome!\n"</span></span><span class="koboSpan" id="kobo.1275.1">)
    fmt.Fprintf(w, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1276.1">"Please use /ws for WebSocket!"</span></span><span class="koboSpan" id="kobo.1277.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1278.1">This is a regular HTTP handler function.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1279.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1280.1">wsHandler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1281.1">(w http.ResponseWriter, r *http.Request)</span></span><span class="koboSpan" id="kobo.1282.1"> {
    log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1283.1">"Connection from:"</span></span><span class="koboSpan" id="kobo.1284.1">, r.Host)
    ws, err := upgrader.Upgrade(w, r, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1285.1">nil</span></span><span class="koboSpan" id="kobo.1286.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1287.1">if</span></span><span class="koboSpan" id="kobo.1288.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1289.1">nil</span></span><span class="koboSpan" id="kobo.1290.1"> {
        log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1291.1">"upgrader.Upgrade:"</span></span><span class="koboSpan" id="kobo.1292.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1293.1">return</span></span><span class="koboSpan" id="kobo.1294.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1295.1">defer</span></span><span class="koboSpan" id="kobo.1296.1"> ws.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1297.1">A WebSocket server application calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1298.1">Upgrader.Upgrade</span></code><span class="koboSpan" id="kobo.1299.1"> method to get a WebSocket connection from an HTTP request handler. </span><span class="koboSpan" id="kobo.1299.2">After a successful call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1300.1">Upgrader.Upgrade</span></code><span class="koboSpan" id="kobo.1301.1">, the server begins </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.1302.1">working with the WebSocket connection and the WebSocket client.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1303.1">for</span></span><span class="koboSpan" id="kobo.1304.1"> {
        mt, message, err := ws.ReadMessage()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1305.1">if</span></span><span class="koboSpan" id="kobo.1306.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1307.1">nil</span></span><span class="koboSpan" id="kobo.1308.1"> {
            log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1309.1">"From"</span></span><span class="koboSpan" id="kobo.1310.1">, r.Host, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1311.1">"read"</span></span><span class="koboSpan" id="kobo.1312.1">, err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1313.1">break</span></span><span class="koboSpan" id="kobo.1314.1">
        }
        log.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1315.1">"Received: "</span></span><span class="koboSpan" id="kobo.1316.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1317.1">string</span></span><span class="koboSpan" id="kobo.1318.1">(message))
        err = ws.WriteMessage(mt, message)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1319.1">if</span></span><span class="koboSpan" id="kobo.1320.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1321.1">nil</span></span><span class="koboSpan" id="kobo.1322.1"> {
            log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1323.1">"WriteMessage:"</span></span><span class="koboSpan" id="kobo.1324.1">, err)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1325.1">break</span></span><span class="koboSpan" id="kobo.1326.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1327.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1328.1">for</span></code><span class="koboSpan" id="kobo.1329.1"> loop in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1330.1">wsHandler()</span></code><span class="koboSpan" id="kobo.1331.1"> handles all incoming messages for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1332.1">/ws</span></code><span class="koboSpan" id="kobo.1333.1">—you can use any technique you want to serve incoming requests. </span><span class="koboSpan" id="kobo.1333.2">Additionally, in the presented implementation, only the client is allowed to close an existing WebSocket connection unless there is a network issue, or the server process is killed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1334.1">Last, remember that in a WebSocket connection, you cannot use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1335.1">fmt.Fprintf()</span></code><span class="koboSpan" id="kobo.1336.1"> statements to send data to the WebSocket client—if you use any of these, or any other call that can implement the same functionality, the WebSocket connection fails and you are not going to be able to send or receive any data. </span><span class="koboSpan" id="kobo.1336.2">Therefore, the only way to send and receive data in a WebSocket connection implemented with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1337.1">gorilla/websocket</span></code><span class="koboSpan" id="kobo.1338.1"> is through </span><code class="inlineCode"><span class="koboSpan" id="kobo.1339.1">WriteMessage()</span></code><span class="koboSpan" id="kobo.1340.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1341.1">ReadMessage()</span></code><span class="koboSpan" id="kobo.1342.1"> calls, respectively. </span><span class="koboSpan" id="kobo.1342.2">Of course, you can always implement the desired functionality on your own by working with raw network data, but implementing this goes beyond the scope of this book.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1343.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1344.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1345.1">()</span></span><span class="koboSpan" id="kobo.1346.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1347.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1348.1">len</span></span><span class="koboSpan" id="kobo.1349.1">(arguments) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.1350.1">1</span></span><span class="koboSpan" id="kobo.1351.1"> {
        PORT = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1352.1">":"</span></span><span class="koboSpan" id="kobo.1353.1"> + arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1354.1">1</span></span><span class="koboSpan" id="kobo.1355.1">]
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1356.1">If there is not a command line argument, the default port number stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1357.1">PORT</span></code><span class="koboSpan" id="kobo.1358.1"> global variable is used. </span><span class="koboSpan" id="kobo.1358.2">Otherwise, the given value is used.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1359.1">    mux := http.NewServeMux()
    s := &amp;http.Server{
        Addr:         PORT,
        Handler:      mux,
        IdleTimeout:  </span><span class="hljs-number"><span class="koboSpan" id="kobo.1360.1">10</span></span><span class="koboSpan" id="kobo.1361.1"> * time.Second,
        ReadTimeout:  time.Second,
        WriteTimeout: time.Second,
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1362.1">These are the details</span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.1363.1"> of the HTTP server that also handles WebSocket connections.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1364.1">    mux.Handle(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1365.1">"/"</span></span><span class="koboSpan" id="kobo.1366.1">, http.HandlerFunc(rootHandler))
    mux.Handle(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1367.1">"/ws"</span></span><span class="koboSpan" id="kobo.1368.1">, http.HandlerFunc(wsHandler))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1369.1">The endpoint used for WebSocket can be anything you want—in this case, it is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1370.1">/ws</span></code><span class="koboSpan" id="kobo.1371.1">. </span><span class="koboSpan" id="kobo.1371.2">Additionally, you can have multiple endpoints that work with the WebSocket protocol.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1372.1">    log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1373.1">"Listening to TCP Port"</span></span><span class="koboSpan" id="kobo.1374.1">, PORT)
    err := s.ListenAndServe()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1375.1">if</span></span><span class="koboSpan" id="kobo.1376.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1377.1">nil</span></span><span class="koboSpan" id="kobo.1378.1"> {
        log.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1379.1">return</span></span><span class="koboSpan" id="kobo.1380.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1381.1">The presented code uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.1382.1">log.Println()</span></code><span class="koboSpan" id="kobo.1383.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1384.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.1385.1"> for printing messages—as this is a server process, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1386.1">log.Println()</span></code><span class="koboSpan" id="kobo.1387.1"> is a much better choice than </span><code class="inlineCode"><span class="koboSpan" id="kobo.1388.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.1389.1"> because logging information is sent to files that can be examined at a later time. </span><span class="koboSpan" id="kobo.1389.2">However, during development, you might prefer </span><code class="inlineCode"><span class="koboSpan" id="kobo.1390.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.1391.1"> calls and avoid writing to your log files because you can see your data on screen immediately without having to look elsewhere. </span><span class="koboSpan" id="kobo.1391.2">Additionally, if you are going to run the server as a Docker image, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1392.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.1393.1"> makes more sense. </span><span class="koboSpan" id="kobo.1393.2">However, you should bear in mind that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1394.1">log</span></code><span class="koboSpan" id="kobo.1395.1"> package also prints to the screen by default.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1396.1">The server implementation is short, yet fully functional. </span><span class="koboSpan" id="kobo.1396.2">The single most important call in the code is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1397.1">Upgrader.Upgrade</span></code><span class="koboSpan" id="kobo.1398.1"> because this is what upgrades an HTTP connection to a WebSocket connection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1399.1">Getting and running the code from GitHub requires the following steps—most of the steps have to do with module initialization and downloading the required packages:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1400.1">$ </span></span><span class="koboSpan" id="kobo.1401.1">go mod init
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1402.1">$ </span></span><span class="koboSpan" id="kobo.1403.1">go mod tidy
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1404.1">$ </span></span><span class="koboSpan" id="kobo.1405.1">go run server.go
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1406.1">To test that server, we</span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.1407.1"> need to have a client. </span><span class="koboSpan" id="kobo.1407.2">As we have not developed our own client so far, we are going to test the WebSocket server using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1408.1">websocat</span></code><span class="koboSpan" id="kobo.1409.1"> utility.</span></p>
<h2 class="heading-2" id="_idParaDest-298"><span class="koboSpan" id="kobo.1410.1">Using websocat</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1411.1">websocat</span></code><span class="koboSpan" id="kobo.1412.1"> is a command line</span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.1413.1"> utility that can help you test </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.1414.1">WebSocket connections. </span><span class="koboSpan" id="kobo.1414.2">However, as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1415.1">websocat</span></code><span class="koboSpan" id="kobo.1416.1"> is not installed by default, you need to install it on your machine using your package manager of choice. </span><span class="koboSpan" id="kobo.1416.2">You can use it as follows, provided that there is a WebSocket server at the desired address:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1417.1">$ </span></span><span class="koboSpan" id="kobo.1418.1">websocat ws://localhost:1234/ws
Hello from websocat!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1419.1">This is what we type and send to the server.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1420.1">Hello from websocat!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1421.1">This is what we get back from the WebSocket server, which implements the echo service—different WebSocket servers implement different functionality.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1422.1">Bye!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1423.1">Again, the previous line is user input given to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1424.1">websocat</span></code><span class="koboSpan" id="kobo.1425.1">.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1426.1">Bye!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1427.1">And the last line is the data sent back from the server. </span><span class="koboSpan" id="kobo.1427.2">The connection was closed by pressing </span><em class="keystroke"><span class="koboSpan" id="kobo.1428.1">Ctrl</span></em><span class="koboSpan" id="kobo.1429.1"> + </span><em class="keystroke"><span class="koboSpan" id="kobo.1430.1">D</span></em><span class="koboSpan" id="kobo.1431.1"> on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1432.1">websocat</span></code><span class="koboSpan" id="kobo.1433.1"> client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1434.1">Should you wish for verbose output from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1435.1">websocat</span></code><span class="koboSpan" id="kobo.1436.1">, you can execute it with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1437.1">-v</span></code><span class="koboSpan" id="kobo.1438.1"> flag:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1439.1">$ </span></span><span class="koboSpan" id="kobo.1440.1">websocat -v ws://localhost:1234/ws
[INFO  websocat::lints] Auto-inserting the line mode
[INFO  websocat::stdio_threaded_peer] get_stdio_peer (threaded)
[INFO  websocat::ws_client_peer] get_ws_client_peer
[INFO  websocat::ws_client_peer] Connected to ws
Hello from websocat!
</span><span class="koboSpan" id="kobo.1440.2">Hello from websocat!
</span><span class="koboSpan" id="kobo.1440.3">Bye!
</span><span class="koboSpan" id="kobo.1440.4">Bye!
</span><span class="koboSpan" id="kobo.1440.5">[INFO  websocat::sessionserve] Forward finished
[INFO  websocat::ws_peer] Received WebSocket close message
[INFO  websocat::sessionserve] Reverse finished
[INFO  websocat::sessionserve] Both directions finished
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1441.1">In both cases, the output from our WebSocket server should be similar to the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1442.1">$ </span></span><span class="koboSpan" id="kobo.1443.1">go run server.go
2023/10/09 20:29:16 Listening to TCP Port :1234
2023/10/09 20:29:24 Connection from: localhost:1234
2023/10/09 20:29:31 Received: Hello from websocat!
</span><span class="koboSpan" id="kobo.1443.2">2023/10/09 20:29:53 Received: Bye!
</span><span class="koboSpan" id="kobo.1443.3">2023/10/09 20:30:01 From localhost:1234 read websocket: close 1005 (no status)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1444.1">The next </span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.1445.1">subsection </span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.1446.1">shows how to develop a WebSocket client in Go.</span></p>
<h1 class="heading-1" id="_idParaDest-299"><span class="koboSpan" id="kobo.1447.1">Creating a WebSocket client</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1448.1">This subsection shows </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.1449.1">how to program a WebSocket client in Go. </span><span class="koboSpan" id="kobo.1449.2">The client reads user data, sends it to the server, and reads the server response. </span><span class="koboSpan" id="kobo.1449.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1450.1">client</span></code><span class="koboSpan" id="kobo.1451.1"> directory contains the implementation of the WebSocket client. </span><span class="koboSpan" id="kobo.1451.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1452.1">gorilla/websocket</span></code><span class="koboSpan" id="kobo.1453.1"> package is going to help us develop the WebSocket client.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1454.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1455.1">./client/client.go</span></code><span class="koboSpan" id="kobo.1456.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1457.1">package</span></span><span class="koboSpan" id="kobo.1458.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1459.1">import</span></span><span class="koboSpan" id="kobo.1460.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1461.1">"bufio"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1462.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1463.1">fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1464.1">"log"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1465.1">"net/url"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1466.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1467.1">"os/signal"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1468.1">"syscall"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1469.1">"time"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1470.1">"github.com/gorilla/websocket"</span></span><span class="koboSpan" id="kobo.1471.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1472.1">var</span></span><span class="koboSpan" id="kobo.1473.1"> (
    SERVER       = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1474.1">""</span></span><span class="koboSpan" id="kobo.1475.1">
    PATH         = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1476.1">""</span></span><span class="koboSpan" id="kobo.1477.1">
    TIMESWAIT    = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1478.1">0</span></span><span class="koboSpan" id="kobo.1479.1">
    TIMESWAITMAX = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1480.1">5</span></span><span class="koboSpan" id="kobo.1481.1">
    in           = bufio.NewReader(os.Stdin)
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1482.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1483.1">in</span></code><span class="koboSpan" id="kobo.1484.1"> variable is just a shortcut for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1485.1">bufio.NewReader(os.Stdin)</span></code><span class="koboSpan" id="kobo.1486.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1487.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1488.1">getInput</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1489.1">(input </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1490.1">chan</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1491.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1492.1">)</span></span><span class="koboSpan" id="kobo.1493.1"> {
    result, err := in.ReadString(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1494.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1495.1">\n'</span></span><span class="koboSpan" id="kobo.1496.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1497.1">if</span></span><span class="koboSpan" id="kobo.1498.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1499.1">nil</span></span><span class="koboSpan" id="kobo.1500.1"> {
        log.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1501.1">return</span></span><span class="koboSpan" id="kobo.1502.1">
    }
    input &lt;- result
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1503.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1504.1">getInput()</span></code><span class="koboSpan" id="kobo.1505.1"> function, which</span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.1506.1"> is executed as a goroutine, gets user input that is transferred to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1507.1">main()</span></code><span class="koboSpan" id="kobo.1508.1"> function via the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1509.1">input</span></code><span class="koboSpan" id="kobo.1510.1"> channel. </span><span class="koboSpan" id="kobo.1510.2">Each time the program reads some user input, the old goroutine ends and a new </span><code class="inlineCode"><span class="koboSpan" id="kobo.1511.1">getInput()</span></code><span class="koboSpan" id="kobo.1512.1"> goroutine begins in order to get new user input.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1513.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1514.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1515.1">()</span></span><span class="koboSpan" id="kobo.1516.1"> {
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1517.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1518.1">len</span></span><span class="koboSpan" id="kobo.1519.1">(arguments) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.1520.1">3</span></span><span class="koboSpan" id="kobo.1521.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1522.1">"Need SERVER + PATH!"</span></span><span class="koboSpan" id="kobo.1523.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1524.1">return</span></span><span class="koboSpan" id="kobo.1525.1">
    }
    SERVER = arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1526.1">1</span></span><span class="koboSpan" id="kobo.1527.1">]
    PATH = arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1528.1">2</span></span><span class="koboSpan" id="kobo.1529.1">]
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1530.1">"Connecting to:"</span></span><span class="koboSpan" id="kobo.1531.1">, SERVER, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1532.1">"at"</span></span><span class="koboSpan" id="kobo.1533.1">, PATH)
    interrupt := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1534.1">make</span></span><span class="koboSpan" id="kobo.1535.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1536.1">chan</span></span><span class="koboSpan" id="kobo.1537.1"> os.Signal, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1538.1">1</span></span><span class="koboSpan" id="kobo.1539.1">)
    signal.Notify(interrupt, os.Interrupt)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1540.1">The WebSocket client handles UNIX interrupts with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1541.1">interrupt</span></code><span class="koboSpan" id="kobo.1542.1"> channel. </span><span class="koboSpan" id="kobo.1542.2">When the appropriate signal is caught (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1543.1">syscall.SIGINT</span></code><span class="koboSpan" id="kobo.1544.1">), the WebSocket connection with the server is closed with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1545.1">websocket.CloseMessage</span></code><span class="koboSpan" id="kobo.1546.1"> message. </span><span class="koboSpan" id="kobo.1546.2">This is how professional tools work!</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1547.1">    input := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1548.1">make</span></span><span class="koboSpan" id="kobo.1549.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1550.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1551.1">string</span></span><span class="koboSpan" id="kobo.1552.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1553.1">1</span></span><span class="koboSpan" id="kobo.1554.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1555.1">go</span></span><span class="koboSpan" id="kobo.1556.1"> getInput(input)
    URL := url.URL{Scheme: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1557.1">"ws"</span></span><span class="koboSpan" id="kobo.1558.1">, Host: SERVER, Path: PATH}
    c, _, err := websocket.DefaultDialer.Dial(URL.String(), </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1559.1">nil</span></span><span class="koboSpan" id="kobo.1560.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1561.1">if</span></span><span class="koboSpan" id="kobo.1562.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1563.1">nil</span></span><span class="koboSpan" id="kobo.1564.1"> {
        log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1565.1">"Error:"</span></span><span class="koboSpan" id="kobo.1566.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1567.1">return</span></span><span class="koboSpan" id="kobo.1568.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1569.1">defer</span></span><span class="koboSpan" id="kobo.1570.1"> c.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1571.1">The WebSocket connection begins with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1572.1">websocket.DefaultDialer.Dial()</span></code><span class="koboSpan" id="kobo.1573.1">. </span><span class="koboSpan" id="kobo.1573.2">Everything that goes </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.1574.1">to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1575.1">input</span></code><span class="koboSpan" id="kobo.1576.1"> channel is transferred to the WebSocket server using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1577.1">WriteMessage()</span></code><span class="koboSpan" id="kobo.1578.1"> method.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1579.1">    done := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1580.1">make</span></span><span class="koboSpan" id="kobo.1581.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1582.1">chan</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1583.1">struct</span></span><span class="koboSpan" id="kobo.1584.1">{})
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1585.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1586.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1587.1">()</span></span><span class="koboSpan" id="kobo.1588.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1589.1">defer</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1590.1">close</span></span><span class="koboSpan" id="kobo.1591.1">(done)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1592.1">for</span></span><span class="koboSpan" id="kobo.1593.1"> {
            _, message, err := c.ReadMessage()
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1594.1">if</span></span><span class="koboSpan" id="kobo.1595.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1596.1">nil</span></span><span class="koboSpan" id="kobo.1597.1"> {
                log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1598.1">"ReadMessage() error:"</span></span><span class="koboSpan" id="kobo.1599.1">, err)
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1600.1">return</span></span><span class="koboSpan" id="kobo.1601.1">
            }
            log.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1602.1">"Received: %s"</span></span><span class="koboSpan" id="kobo.1603.1">, message)
        }
    }()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1604.1">Another goroutine, which this time is implemented using an anonymous Go function, is responsible for reading data from the WebSocket connection using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1605.1">ReadMessage()</span></code><span class="koboSpan" id="kobo.1606.1"> method.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1607.1">for</span></span><span class="koboSpan" id="kobo.1608.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1609.1">select</span></span><span class="koboSpan" id="kobo.1610.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1611.1">case</span></span><span class="koboSpan" id="kobo.1612.1"> &lt;-time.After(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1613.1">4</span></span><span class="koboSpan" id="kobo.1614.1"> * time.Second):
            log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1615.1">"Please give me input!"</span></span><span class="koboSpan" id="kobo.1616.1">, TIMESWAIT)
            TIMESWAIT++
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1617.1">if</span></span><span class="koboSpan" id="kobo.1618.1"> TIMESWAIT &gt; TIMESWAITMAX {
                syscall.Kill(syscall.Getpid(), syscall.SIGINT)
            }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1619.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1620.1">syscall.Kill(syscall.Getpid(), syscall.SIGINT)</span></code><span class="koboSpan" id="kobo.1621.1"> statement sends the interrupt signal to the program using Go code. </span><span class="koboSpan" id="kobo.1621.2">According to the logic of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1622.1">client.go</span></code><span class="koboSpan" id="kobo.1623.1">, the interrupt signal makes the program close the WebSocket connection with the server and terminate its execution. </span><span class="koboSpan" id="kobo.1623.2">This only happens if the current number of timeout periods is bigger than a predefined global value, which in this case is equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1624.1">5</span></code><span class="koboSpan" id="kobo.1625.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1626.1">case</span></span><span class="koboSpan" id="kobo.1627.1"> &lt;-done:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1628.1">return</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1629.1">case</span></span><span class="koboSpan" id="kobo.1630.1"> t := &lt;-input:
            err := c.WriteMessage(websocket.TextMessage, []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1631.1">byte</span></span><span class="koboSpan" id="kobo.1632.1">(t))
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1633.1">if</span></span><span class="koboSpan" id="kobo.1634.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1635.1">nil</span></span><span class="koboSpan" id="kobo.1636.1"> {
                log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1637.1">"Write error:"</span></span><span class="koboSpan" id="kobo.1638.1">, err)
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1639.1">return</span></span><span class="koboSpan" id="kobo.1640.1">
            }
            TIMESWAIT = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1641.1">0</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1642.1">If you get user </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.1643.1">input, the current number of the timeout periods (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1644.1">TIMESWAIT</span></code><span class="koboSpan" id="kobo.1645.1">) is reset and the new input is read.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1646.1">go</span></span><span class="koboSpan" id="kobo.1647.1"> getInput(input)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1648.1">case</span></span><span class="koboSpan" id="kobo.1649.1"> &lt;-interrupt:
            log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1650.1">"Caught interrupt signal - quitting!"</span></span><span class="koboSpan" id="kobo.1651.1">)
            err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1652.1">""</span></span><span class="koboSpan" id="kobo.1653.1">))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1654.1">Just before we close the client connection, we send </span><code class="inlineCode"><span class="koboSpan" id="kobo.1655.1">websocket.CloseMessage</span></code><span class="koboSpan" id="kobo.1656.1"> to the server in order to end the connection the right way.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1657.1">if</span></span><span class="koboSpan" id="kobo.1658.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1659.1">nil</span></span><span class="koboSpan" id="kobo.1660.1"> {
                log.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1661.1">"Write close error:"</span></span><span class="koboSpan" id="kobo.1662.1">, err)
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1663.1">return</span></span><span class="koboSpan" id="kobo.1664.1">
            }
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1665.1">select</span></span><span class="koboSpan" id="kobo.1666.1"> {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1667.1">case</span></span><span class="koboSpan" id="kobo.1668.1"> &lt;-done:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1669.1">case</span></span><span class="koboSpan" id="kobo.1670.1"> &lt;-time.After(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1671.1">2</span></span><span class="koboSpan" id="kobo.1672.1"> * time.Second):
            }
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1673.1">return</span></span><span class="koboSpan" id="kobo.1674.1">
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1675.1">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.1676.1">./client/client.go</span></code><span class="koboSpan" id="kobo.1677.1"> is in a separate directory, we need to run the next commands in order to collect the required dependencies and run it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1678.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1679.1">cd</span></span><span class="koboSpan" id="kobo.1680.1"> client
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1681.1">$ </span></span><span class="koboSpan" id="kobo.1682.1">go mod init
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1683.1">$ </span></span><span class="koboSpan" id="kobo.1684.1">go mod tidy
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1685.1">Interacting with the WebSocket server produces the next kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1686.1">$ </span></span><span class="koboSpan" id="kobo.1687.1">go run client.go localhost:1234 ws
Connecting to: localhost:1234 at ws
Hello there!
</span><span class="koboSpan" id="kobo.1687.2">2023/10/09 20:36:25 Received: Hello there!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1688.1">The previous two lines show user input as well as the server response.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1689.1">2023/10/09 20:36:29 Please give me input! </span><span class="koboSpan" id="kobo.1689.2">0
2023/10/09 20:36:33 Please give me input! </span><span class="koboSpan" id="kobo.1689.3">1
2023/10/09 20:36:37 Please give me input! </span><span class="koboSpan" id="kobo.1689.4">2
2023/10/09 20:36:41 Please give me input! </span><span class="koboSpan" id="kobo.1689.5">3
2023/10/09 20:36:45 Please give me input! </span><span class="koboSpan" id="kobo.1689.6">4
2023/10/09 20:36:49 Please give me input! </span><span class="koboSpan" id="kobo.1689.7">5
2023/10/09 20:36:49 Caught interrupt signal - quitting!
</span><span class="koboSpan" id="kobo.1689.8">2023/10/09 20:36:49 ReadMessage() error: websocket: close 1000 (normal)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1690.1">The last lines of</span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.1691.1"> output show how the automatic timeout process works.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1692.1">The WebSocket server generated the following output for the previous interaction:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1693.1">2023/10/09 20:36:22 Connection from: localhost:1234
2023/10/09 20:36:25 Received: Hello there!
</span><span class="koboSpan" id="kobo.1693.2">2023/10/09 20:36:49 From localhost:1234 read websocket: close 1000 (normal)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1694.1">However, if a WebSocket server cannot be found at the address provided, the WebSocket client produces the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1695.1">$ </span></span><span class="koboSpan" id="kobo.1696.1">go run client.go localhost:1234 ws
Connecting to: localhost:1234 at ws
2023/10/09 08:11:20 Error: dial tcp [::1]:1234: connect: connection refused
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1697.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1698.1">connection refused</span></code><span class="koboSpan" id="kobo.1699.1"> message indicates that there is no process listening to port number </span><code class="inlineCode"><span class="koboSpan" id="kobo.1700.1">1234</span></code><span class="koboSpan" id="kobo.1701.1"> on </span><code class="inlineCode"><span class="koboSpan" id="kobo.1702.1">localhost</span></code><span class="koboSpan" id="kobo.1703.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1704.1">The next section of </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.1705.1">the chapter is about working with the RabbitMQ message broker.</span></p>
<h1 class="heading-1" id="_idParaDest-300"><span class="koboSpan" id="kobo.1706.1">Working with RabbitMQ</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1707.1">In the last section of </span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.1708.1">this chapter, we are going to learn how to work with RabbitMQ. </span><span class="koboSpan" id="kobo.1708.2">RabbitMQ is an open-source message broker that is particularly handy when you want to exchange information asynchronously and need a place where messages can be stored safely until they are read. </span><span class="koboSpan" id="kobo.1708.3">RabbitMQ enables you to exchange information, which is the main reason that you do not need to use it directly unless you want to perform administrative tasks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1709.1">RabbitMQ uses the AMQP protocol. </span><span class="koboSpan" id="kobo.1709.2">AMQP, which stands for Advanced Message Queuing Protocol, is an open protocol for message-oriented middleware. </span><span class="koboSpan" id="kobo.1709.3">The characteristic features of AMQP are message orientation, queuing, routing, reliability, and security. </span><span class="koboSpan" id="kobo.1709.4">AMQP works with binary data and transmits data in frames. </span><span class="koboSpan" id="kobo.1709.5">There exist nine types of frames (open connection, close connection, transfer data, etc.) depending on the task that you want to perform.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1710.1">If you must choose between RabbitMQ and Kafka, which both do a similar job, you should begin by considering their differences. </span><span class="koboSpan" id="kobo.1710.2">First, Kafka is faster than RabbitMQ. </span><span class="koboSpan" id="kobo.1710.3">Second, RabbitMQ works with the push model whereas Kafka works with a pull-based approach. </span><span class="koboSpan" id="kobo.1710.4">Third, Kafka offers support for batching whereas RabbitMQ does not. </span><span class="koboSpan" id="kobo.1710.5">Last, RabbitMQ does not have a limit on the payload size whereas Kafka has some restrictions on the payload size. </span><span class="koboSpan" id="kobo.1710.6">The key thing to remember is that if speed is your main concern, then Kafka might be a better choice, whereas if payload size and simplicity are your main concerns, then RabbitMQ is a more rational choice.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1711.1">Data is stored in queues. </span><span class="koboSpan" id="kobo.1711.2">A queue in RabbitMQ is a FIFO (First In, First Out) structure that supports two operations: adding elements and getting elements. </span><span class="koboSpan" id="kobo.1711.3">Queues have names, which means that you should know the name of the queue you want to interact with either as a message producer or a message consumer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1712.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1713.1">github.com/rabbitmq/amqp091-go</span></code><span class="koboSpan" id="kobo.1714.1"> Go module does the job of connecting to RabbitMQ using the AMQP protocol, provided that you supply the correct connection details.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1715.1">All files for this </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.1716.1">section, including source files and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1717.1">docker-compose.yml</span></code><span class="koboSpan" id="kobo.1718.1"> file for running RabbitMQ, are located in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1719.1">~/go/src/github.com/mactsouk/mGo4th/ch10/MQ</span></code><span class="koboSpan" id="kobo.1720.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-301"><span class="koboSpan" id="kobo.1721.1">Running RabbitMQ</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1722.1">In this first subsection, we</span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.1723.1"> are going to learn how to execute RabbitMQ using Docker—this is the cleanest solution for running RabbitMQ on your machine because it only requires the use of a single Docker image. </span><span class="koboSpan" id="kobo.1723.2">The contents of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1724.1">docker-compose.yml</span></code><span class="koboSpan" id="kobo.1725.1"> file, which can be found inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.1726.1">~/go/src/github.com/mactsouk/mGo4th/ch10/MQ/</span></code><span class="koboSpan" id="kobo.1727.1">, are the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1728.1">version:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1729.1">"3.6"</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1730.1">services:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1731.1">rabbitmq:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1732.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1733.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1734.1">rabbitmq:3.12-management'</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1735.1">container_name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1736.1">rabbit</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1737.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1738.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1739.1">'5672:5672'</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1740.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1741.1">'15672:15672'</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1742.1">environment:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1743.1">AMQP_URL:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1744.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1745.1">amqp://rabbitmq?connection_attempts=5&amp;retry_delay=5'</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1746.1">RABBITMQ_DEFAULT_USER:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1747.1">"guest"</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1748.1">RABBITMQ_DEFAULT_PASS:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1749.1">"guest"</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1750.1">networks:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1751.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1752.1">rabbit</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1753.1">networks:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1754.1">rabbit:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1755.1">driver:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1756.1">bridge</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1757.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1758.1">docker-compose.yml</span></code><span class="koboSpan" id="kobo.1759.1"> is as simple as using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1760.1">docker-compose up</span></code><span class="koboSpan" id="kobo.1761.1"> from inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.1762.1">~/go/src/github.com/mactsouk/mGo4th/ch10/MQ/</span></code><span class="koboSpan" id="kobo.1763.1">. </span><span class="koboSpan" id="kobo.1763.2">If the relevant Docker image is not present on the active machine, it is going to be downloaded first.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1764.1">Now that we have RabbitMQ up and running, let us learn how to send data to RabbitMQ (producer) and read </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.1765.1">data from a RabbitMQ queue (consumer).</span></p>
<h2 class="heading-2" id="_idParaDest-302"><span class="koboSpan" id="kobo.1766.1">Writing to RabbitMQ</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1767.1">The code of the</span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.1768.1"> RabbitMQ producer is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1769.1">sendMQ.go</span></code><span class="koboSpan" id="kobo.1770.1"> and is located under the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1771.1">producer</span></code><span class="koboSpan" id="kobo.1772.1"> directory. </span><span class="koboSpan" id="kobo.1772.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1773.1">sendMQ.go</span></code><span class="koboSpan" id="kobo.1774.1"> source file is presented in two parts. </span><span class="koboSpan" id="kobo.1774.2">The first part contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1775.1">package</span></span><span class="koboSpan" id="kobo.1776.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1777.1">import</span></span><span class="koboSpan" id="kobo.1778.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1779.1">"fmt"</span></span><span class="koboSpan" id="kobo.1780.1">
    amqp </span><span class="hljs-string"><span class="koboSpan" id="kobo.1781.1">"github.com/rabbitmq/amqp091-go"</span></span><span class="koboSpan" id="kobo.1782.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1783.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1784.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1785.1">()</span></span><span class="koboSpan" id="kobo.1786.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1787.1">"RabbitMQ producer"</span></span><span class="koboSpan" id="kobo.1788.1">)
    conn, err := amqp.Dial(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1789.1">"amqp://guest:guest@localhost:5672/"</span></span><span class="koboSpan" id="kobo.1790.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1791.1">if</span></span><span class="koboSpan" id="kobo.1792.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1793.1">nil</span></span><span class="koboSpan" id="kobo.1794.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1795.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1796.1">amqp.Dial():"</span></span><span class="koboSpan" id="kobo.1797.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1798.1">return</span></span><span class="koboSpan" id="kobo.1799.1">
    }
    ch, err := conn.Channel()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1800.1">if</span></span><span class="koboSpan" id="kobo.1801.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1802.1">nil</span></span><span class="koboSpan" id="kobo.1803.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1804.1">return</span></span><span class="koboSpan" id="kobo.1805.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1806.1">defer</span></span><span class="koboSpan" id="kobo.1807.1"> ch.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1808.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1809.1">amqp.Dial()</span></code><span class="koboSpan" id="kobo.1810.1"> call initiates a connection to RabbitMQ, whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1811.1">Channel()</span></code><span class="koboSpan" id="kobo.1812.1"> call opens a channel to that connection and makes it ready for use.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1813.1">The connection string (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1814.1">amqp://guest:guest@localhost:5672/</span></code><span class="koboSpan" id="kobo.1815.1">) can be split into three logical parts. </span><span class="koboSpan" id="kobo.1815.2">The first part (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1816.1">amqp://</span></code><span class="koboSpan" id="kobo.1817.1">) is the protocol that is used, the second part contains the user credentials, and the third part contains the name of the server and the port number (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1818.1">localhost:5672/</span></code><span class="koboSpan" id="kobo.1819.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1820.1">The second part comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1821.1">    q, err := ch.QueueDeclare(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1822.1">"Go"</span></span><span class="koboSpan" id="kobo.1823.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1824.1">false</span></span><span class="koboSpan" id="kobo.1825.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1826.1">false</span></span><span class="koboSpan" id="kobo.1827.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1828.1">false</span></span><span class="koboSpan" id="kobo.1829.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1830.1">false</span></span><span class="koboSpan" id="kobo.1831.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1832.1">nil</span></span><span class="koboSpan" id="kobo.1833.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1834.1">if</span></span><span class="koboSpan" id="kobo.1835.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1836.1">nil</span></span><span class="koboSpan" id="kobo.1837.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1838.1">return</span></span><span class="koboSpan" id="kobo.1839.1">
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1840.1">"Queue:"</span></span><span class="koboSpan" id="kobo.1841.1">, q)
    message := </span><span class="hljs-string"><span class="koboSpan" id="kobo.1842.1">"Writing to RabbitMQ!"</span></span><span class="koboSpan" id="kobo.1843.1">
    err = ch.PublishWithContext(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1844.1">nil</span></span><span class="koboSpan" id="kobo.1845.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1846.1">""</span></span><span class="koboSpan" id="kobo.1847.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1848.1">"Go"</span></span><span class="koboSpan" id="kobo.1849.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1850.1">false</span></span><span class="koboSpan" id="kobo.1851.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1852.1">false</span></span><span class="koboSpan" id="kobo.1853.1">,
        amqp.Publishing{ContentType: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1854.1">"text/plain"</span></span><span class="koboSpan" id="kobo.1855.1">, Body: []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1856.1">byte</span></span><span class="koboSpan" id="kobo.1857.1">(message)},
    )
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1858.1">if</span></span><span class="koboSpan" id="kobo.1859.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1860.1">nil</span></span><span class="koboSpan" id="kobo.1861.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1862.1">return</span></span><span class="koboSpan" id="kobo.1863.1">
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1864.1">"Message published to Queue!"</span></span><span class="koboSpan" id="kobo.1865.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1866.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1867.1">QueueDeclare()</span></code><span class="koboSpan" id="kobo.1868.1"> defines the queue that we are going to use. </span><span class="koboSpan" id="kobo.1868.2">If the queue name specified by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1869.1">QueueDeclare()</span></code><span class="koboSpan" id="kobo.1870.1"> does not already exist, it is going to be created. </span><span class="koboSpan" id="kobo.1870.2">This means that typos in queue </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.1871.1">names are not caught. </span><span class="koboSpan" id="kobo.1871.2">In this case, the queue is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1872.1">Go</span></code><span class="koboSpan" id="kobo.1873.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1874.1">The plain text data we want to send is kept in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1875.1">message</span></code><span class="koboSpan" id="kobo.1876.1"> variable. </span><span class="koboSpan" id="kobo.1876.2">After that, we specify the format of the data we are going to put in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1877.1">amqp.Publishing{}</span></code><span class="koboSpan" id="kobo.1878.1"> structure, which in this case is plain text (the JSON format is also supported). </span><span class="koboSpan" id="kobo.1878.2">The contents of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1879.1">message</span></code><span class="koboSpan" id="kobo.1880.1"> variable are converted into a byte slice and put into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1881.1">Body</span></code><span class="koboSpan" id="kobo.1882.1"> field of an anonymous </span><code class="inlineCode"><span class="koboSpan" id="kobo.1883.1">amqp.Publishing{}</span></code><span class="koboSpan" id="kobo.1884.1"> structure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1885.1">That </span><code class="inlineCode"><span class="koboSpan" id="kobo.1886.1">amqp.Publishing{}</span></code><span class="koboSpan" id="kobo.1887.1"> structure is one of the parameters of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1888.1">ch.PublishWithContext()</span></code><span class="koboSpan" id="kobo.1889.1"> call, which sends the structure to RabbitMQ.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1890.1">The current version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1891.1">sendMQ.go</span></code><span class="koboSpan" id="kobo.1892.1"> just writes a message to the predefined queue using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1893.1">Publish()</span></code><span class="koboSpan" id="kobo.1894.1"> and exits. </span><span class="koboSpan" id="kobo.1894.2">This means that in order to send multiple messages to RabbitMQ, we have to execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.1895.1">sendMQ.go</span></code><span class="koboSpan" id="kobo.1896.1"> multiple times.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1897.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1898.1">sendMQ.go</span></code><span class="koboSpan" id="kobo.1899.1"> generates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1900.1">$ </span></span><span class="koboSpan" id="kobo.1901.1">go run sendMQ.go
RabbitMQ producer
Queue: {Go 0 0}
Message published to Queue!
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1902.1">$ </span></span><span class="koboSpan" id="kobo.1903.1">go run sendMQ.go
RabbitMQ producer
Queue: {Go 1 0}
Message published to Queue!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1904.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1905.1">{Go 1 0}</span></code><span class="koboSpan" id="kobo.1906.1"> output means that we currently have two messages in the RabbitMQ queue.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1907.1">The next subsection </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.1908.1">shows how to consume messages from a RabbitMQ queue.</span></p>
<h2 class="heading-2" id="_idParaDest-303"><span class="koboSpan" id="kobo.1909.1">Reading from RabbitMQ</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1910.1">The code of the RabbitMQ </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.1911.1">consumer is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1912.1">readMQ.go</span></code><span class="koboSpan" id="kobo.1913.1"> and is located under the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1914.1">consumer</span></code><span class="koboSpan" id="kobo.1915.1"> directory. </span><span class="koboSpan" id="kobo.1915.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1916.1">readMQ.go</span></code><span class="koboSpan" id="kobo.1917.1"> source file is also presented in two parts. </span><span class="koboSpan" id="kobo.1917.2">The first part contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1918.1">package</span></span><span class="koboSpan" id="kobo.1919.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1920.1">import</span></span><span class="koboSpan" id="kobo.1921.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1922.1">"fmt"</span></span><span class="koboSpan" id="kobo.1923.1">
    amqp </span><span class="hljs-string"><span class="koboSpan" id="kobo.1924.1">"github.com/rabbitmq/amqp091-go"</span></span><span class="koboSpan" id="kobo.1925.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1926.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1927.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1928.1">()</span></span><span class="koboSpan" id="kobo.1929.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1930.1">"RabbitMQ consumer"</span></span><span class="koboSpan" id="kobo.1931.1">)
    conn, err := amqp.Dial(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1932.1">"amqp://guest:guest@localhost:5672/"</span></span><span class="koboSpan" id="kobo.1933.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1934.1">if</span></span><span class="koboSpan" id="kobo.1935.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1936.1">nil</span></span><span class="koboSpan" id="kobo.1937.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1938.1">"Failed Initializing Broker Connection"</span></span><span class="koboSpan" id="kobo.1939.1">)
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1940.1">panic</span></span><span class="koboSpan" id="kobo.1941.1">(err)
    }
    ch, err := conn.Channel()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1942.1">if</span></span><span class="koboSpan" id="kobo.1943.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1944.1">nil</span></span><span class="koboSpan" id="kobo.1945.1"> {
        fmt.Println(err)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1946.1">defer</span></span><span class="koboSpan" id="kobo.1947.1"> ch.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1948.1">As in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1949.1">sendMQ.go</span></code><span class="koboSpan" id="kobo.1950.1">, we define the connection details, and we open the connection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1951.1">The second part is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1952.1">    msgs, err := ch.Consume(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1953.1">"Go"</span></span><span class="koboSpan" id="kobo.1954.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1955.1">""</span></span><span class="koboSpan" id="kobo.1956.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1957.1">true</span></span><span class="koboSpan" id="kobo.1958.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1959.1">false</span></span><span class="koboSpan" id="kobo.1960.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1961.1">false</span></span><span class="koboSpan" id="kobo.1962.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1963.1">false</span></span><span class="koboSpan" id="kobo.1964.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1965.1">nil</span></span><span class="koboSpan" id="kobo.1966.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1967.1">if</span></span><span class="koboSpan" id="kobo.1968.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1969.1">nil</span></span><span class="koboSpan" id="kobo.1970.1"> {
        fmt.Println(err)
    }
    forever := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1971.1">make</span></span><span class="koboSpan" id="kobo.1972.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1973.1">chan</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1974.1">bool</span></span><span class="koboSpan" id="kobo.1975.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1976.1">go</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1977.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1978.1">()</span></span><span class="koboSpan" id="kobo.1979.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1980.1">for</span></span><span class="koboSpan" id="kobo.1981.1"> d := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1982.1">range</span></span><span class="koboSpan" id="kobo.1983.1"> msgs {
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1984.1">"Received: %s\n"</span></span><span class="koboSpan" id="kobo.1985.1">, d.Body)
        }
    }()
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1986.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1987.1">Connected to the RabbitMQ server!"</span></span><span class="koboSpan" id="kobo.1988.1">)
    &lt;-forever
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1989.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1990.1">Consume()</span></code><span class="koboSpan" id="kobo.1991.1"> method reads messages from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1992.1">Go</span></code><span class="koboSpan" id="kobo.1993.1"> queue using a goroutine. </span><span class="koboSpan" id="kobo.1993.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1994.1">forever</span></code><span class="koboSpan" id="kobo.1995.1"> channel blocks the program and prevents it from exiting. </span><span class="koboSpan" id="kobo.1995.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1996.1">Body</span></code><span class="koboSpan" id="kobo.1997.1"> field of the received message, which is a structure, contains the data we want.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1998.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1999.1">readMQ.go</span></code><span class="koboSpan" id="kobo.2000.1">, after </span><code class="inlineCode"><span class="koboSpan" id="kobo.2001.1">sendMQ.go</span></code><span class="koboSpan" id="kobo.2002.1"> has put some messages in RabbitMQ, generates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2003.1">$ </span></span><span class="koboSpan" id="kobo.2004.1">go run readMQ.go
RabbitMQ consumer
Connected to the RabbitMQ server!
</span><span class="koboSpan" id="kobo.2004.2">Received: Writing to RabbitMQ!
</span><span class="koboSpan" id="kobo.2004.3">Received: Writing to RabbitMQ!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2005.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2006.1">readMQ.go</span></code><span class="koboSpan" id="kobo.2007.1"> utility </span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.2008.1">keeps running and waits for new messages, which means that we need to end it on our own by pressing </span><em class="keystroke"><span class="koboSpan" id="kobo.2009.1">Ctrl</span></em><span class="koboSpan" id="kobo.2010.1"> + </span><em class="keystroke"><span class="koboSpan" id="kobo.2011.1">C</span></em><span class="koboSpan" id="kobo.2012.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-304"><span class="koboSpan" id="kobo.2013.1">How to remove a module</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2014.1">This is not directly r</span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.2015.1">elated to RabbitMQ, but it is a useful tip. </span><span class="koboSpan" id="kobo.2015.2">The current version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2016.1">go.mod</span></code><span class="koboSpan" id="kobo.2017.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2018.1">consumer</span></code><span class="koboSpan" id="kobo.2019.1"> directory is the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2020.1">module github.com/mactsouk/mGo4th/ch10/MQ/consumer
go 1.21.1
require github.com/rabbitmq/amqp091-go v1.8.1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2021.1">You can remove a module from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2022.1">go.mod</span></code><span class="koboSpan" id="kobo.2023.1"> using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2024.1">none</span></code><span class="koboSpan" id="kobo.2025.1"> as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2026.1">$ </span></span><span class="koboSpan" id="kobo.2027.1">go get github.com/rabbitmq/amqp091-go@none
go: removed github.com/rabbitmq/amqp091-go v1.8.1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2028.1">After that, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2029.1">go.mod</span></code><span class="koboSpan" id="kobo.2030.1"> is going to look as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2031.1">module github.com/mactsouk/mGo4th/ch10/MQ/consumer
go 1.21.1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2032.1">If you want to </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.2033.1">bring </span><code class="inlineCode"><span class="koboSpan" id="kobo.2034.1">go.mod</span></code><span class="koboSpan" id="kobo.2035.1"> back into its previous state, you can run </span><code class="inlineCode"><span class="koboSpan" id="kobo.2036.1">go mod tidy</span></code><span class="koboSpan" id="kobo.2037.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-305"><span class="koboSpan" id="kobo.2038.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2039.1">This chapter was all about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2040.1">net</span></code><span class="koboSpan" id="kobo.2041.1"> package, TCP/IP, TCP, and UDP, which implement low-level connections, as well as WebSocket and RabbitMQ.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2042.1">WebSocket gives us an alternative way of creating services. </span><span class="koboSpan" id="kobo.2042.2">As a rule of thumb, WebSocket is better when we want to exchange lots of data, and we want the connection to remain open all the time and exchange data in full duplex. </span><span class="koboSpan" id="kobo.2042.3">However, if we are not sure about what to choose, it is recommended to begin with a TCP/IP service and see how it goes before upgrading it to the WebSocket protocol.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2043.1">Lastly, RabbitMQ is a rational choice when we want to store and retrieve a large amount of data to an external data store.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2044.1">Go can help you create all kinds of concurrent servers and clients.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2045.1">We are now ready to begin developing our own services! </span><span class="koboSpan" id="kobo.2045.2">The next chapter is about REST APIs, exchanging JSON data over HTTP, and developing RESTful clients and servers—Go is widely used for developing RESTful clients and servers.</span></p>
<h1 class="heading-1" id="_idParaDest-306"><span class="koboSpan" id="kobo.2046.1">Exercises</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2047.1">Develop a concurrent TCP server that generates random numbers in a predefined range.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2048.1">Develop a concurrent TCP server that generates random numbers in a range that is given by the TCP client. </span><span class="koboSpan" id="kobo.2048.2">This can be used as a way of randomly picking values from a set.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2049.1">Add UNIX signal processing to the concurrent TCP server developed in this chapter to gracefully stop the server process when a given signal is received.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2050.1">Write a client program that reads a message from a RabbitMQ server and posts it to a TCP server.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2051.1">Develop a WebSocket server that creates a variable number of random integers that are sent to the client. </span><span class="koboSpan" id="kobo.2051.2">The number of random integers is specified by the client in the initial client message.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-307"><span class="koboSpan" id="kobo.2052.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2053.1">The WebSocket protocol: </span><a href="https://tools.ietf.org/rfc/rfc6455.txt"><span class="url"><span class="koboSpan" id="kobo.2054.1">https://tools.ietf.org/rfc/rfc6455.txt</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2055.1">Wikipedia WebSocket: </span><a href="https://en.wikipedia.org/wiki/WebSocket"><span class="url"><span class="koboSpan" id="kobo.2056.1">https://en.wikipedia.org/wiki/WebSocket</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2057.1">Gorilla WebSocket package: </span><a href="https://github.com/gorilla/websocket"><span class="url"><span class="koboSpan" id="kobo.2058.1">https://github.com/gorilla/websocket</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2059.1">Gorilla WebSocket docs: </span><a href="https://www.gorillatoolkit.org/pkg/websocket"><span class="url"><span class="koboSpan" id="kobo.2060.1">https://www.gorillatoolkit.org/pkg/websocket</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2061.1">RabbitMQ Go module: </span><a href="https://github.com/rabbitmq/amqp091-go"><span class="url"><span class="koboSpan" id="kobo.2062.1">https://github.com/rabbitmq/amqp091-go</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2063.1">Learn more about AMQP at </span><a href="https://www.amqp.org/"><span class="url"><span class="koboSpan" id="kobo.2064.1">https://www.amqp.org/</span></span></a><span class="koboSpan" id="kobo.2065.1"> and </span><a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol "><span class="url"><span class="koboSpan" id="kobo.2066.1">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.2067.1">Leave a review!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2068.1">Enjoying this book? </span><span class="koboSpan" id="kobo.2068.2">Help readers like you by leaving an Amazon review. </span><span class="koboSpan" id="kobo.2068.3">Scan the QR code below to get a free eBook of your choice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2069.1"><img alt="" role="presentation" src="../Images/Review_QR_Code.png"/></span></p> </div>
</body></html>