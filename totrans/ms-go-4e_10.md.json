["```go\n$ nc 10.10.1.123 1234 \n```", "```go\npackage main\nimport (\n    \"bufio\"\n\"fmt\"\n\"net\"\n\"os\"\n\"strings\"\n) \n```", "```go\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Please provide host:port.\")\n        return\n    } \n```", "```go\n connect := arguments[1]\n    c, err := net.Dial(\"tcp\", connect)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(5)\n    } \n```", "```go\n reader := bufio.NewReader(os.Stdin)\n    for {\n        fmt.Print(\">> \")\n        text, _ := reader.ReadString('\\n')\n        fmt.Fprintf(c, \"%s\\n\", text)\n        message, _ := bufio.NewReader(c).ReadString('\\n')\n        fmt.Print(\"->: \" + message)\n        if strings.TrimSpace(string(text)) == \"STOP\" {\n            fmt.Println(\"TCP client exiting...\")\n            return\n        }\n    }\n} \n```", "```go\n$ go run tcpC.go localhost:1234\n>> Hello!\n->: Hi from nc -l 1234\n>> STOP\n->: Bye!\nTCP client exiting... \n```", "```go\npackage main\nimport (\n    \"bufio\"\n\"fmt\"\n\"net\"\n\"os\"\n\"strings\"\n) \n```", "```go\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Please provide a server:port string!\")\n        return\n    } \n```", "```go\n connect := arguments[1]\n    tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", connect)\n    if err != nil {\n        fmt.Println(\"ResolveTCPAddr:\", err)\n        return\n    } \n```", "```go\n conn, err := net.DialTCP(\"tcp4\", nil, tcpAddr)\n    if err != nil {\n        fmt.Println(\"DialTCP:\", err)\n        return\n    } \n```", "```go\n reader := bufio.NewReader(os.Stdin)\n    for {\n        fmt.Print(\">> \")\n        text, _ := reader.ReadString('\\n')\n        fmt.Fprintf(conn, text+\"\\n\")\n        message, _ := bufio.NewReader(conn).ReadString('\\n')\n        fmt.Print(\"->: \" + message)\n        if strings.TrimSpace(string(text)) == \"STOP\" {\n            fmt.Println(\"TCP client exiting...\")\n            conn.Close()\n            return\n        }\n    }\n} \n```", "```go\n$ go run otherTCPclient.go localhost:1234\n>> Hello!\n->: Hi from nc -l 1234\n>> STOP\n->: Thanks for connecting!\nTCP client exiting... \n```", "```go\npackage main\nimport (\n    \"bufio\"\n\"fmt\"\n\"net\"\n\"os\"\n\"strings\"\n\"time\"\n)\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Please provide port number\")\n        return\n    } \n```", "```go\n PORT := \":\" + arguments[1]\n    l, err := net.Listen(\"tcp\", PORT)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer l.Close() \n```", "```go\n c, err := l.Accept()\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n for {\n        netData, err := bufio.NewReader(c).ReadString('\\n')\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        if strings.TrimSpace(string(netData)) == \"STOP\" {\n            fmt.Println(\"Exiting TCP server!\")\n            return\n        }\n        fmt.Print(\"-> \", string(netData))\n        t := time.Now()\n        myTime := t.Format(time.RFC3339) + \"\\n\"\n        c.Write([]byte(myTime))\n    }\n} \n```", "```go\n$ go run tcpS.go 1234\n-> Hello!\n-> Have to leave now!\nExiting TCP server! \n```", "```go\n$ nc localhost 1234\nHello!\n2023-10-09T20:02:55+03:00\nHave to leave now!\n2023-10-09T20:03:01+03:00\nSTOP \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"net\"\n\"os\"\n\"strings\"\n)\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Please provide a port number!\")\n        return\n    }\n    SERVER := \"localhost\" + \":\" + arguments[1]\n    s, err := net.ResolveTCPAddr(\"tcp\", SERVER)\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n l, err := net.ListenTCP(\"tcp\", s)\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n buffer := make([]byte, 1024)\n    conn, err := l.Accept()\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n for {\n        n, err := conn.Read(buffer)\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        if strings.TrimSpace(string(buffer[0:n])) == \"STOP\" {\n            fmt.Println(\"Exiting TCP server!\")\n            conn.Close()\n            return\n        } \n```", "```go\n fmt.Print(\"> \", string(buffer[0:n-1]), \"\\n\")\n        _, err = conn.Write(buffer)\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n    }\n} \n```", "```go\n$ go run otherTCPserver.go 1234\n> Hello from the client!\nExiting TCP server! \n```", "```go\npackage main\nimport (\n    \"bufio\"\n\"fmt\"\n\"net\"\n\"os\"\n\"strings\"\n)\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Please provide a host:port string\")\n        return\n    }\n    CONNECT := arguments[1] \n```", "```go\n s, err := net.ResolveUDPAddr(\"udp4\", CONNECT)\n    c, err := net.DialUDP(\"udp4\", nil, s) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Printf(\"The UDP server is %s\\n\", c.RemoteAddr().String())\n    defer c.Close() \n```", "```go\n reader := bufio.NewReader(os.Stdin)\n    for {\n\n        fmt.Print(\">> \")\n        text, _ := reader.ReadString('\\n')\n        data := []byte(text + \"\\n\")\n        _, err = c.Write(data) \n```", "```go\n if strings.TrimSpace(string(data)) == \"STOP\" {\n            fmt.Println(\"Exiting UDP client!\")\n            return\n        } \n```", "```go\n if err != nil {\n            fmt.Println(err)\n            return\n        }\n        buffer := make([]byte, 1024)\n        n, _, err := c.ReadFromUDP(buffer) \n```", "```go\n if err != nil {\n            fmt.Println(err)\n            return\n        }\n        fmt.Printf(\"Reply: %s\\n\", string(buffer[0:n]))\n    }\n} \n```", "```go\n$ go run udpC.go localhost:1234\nThe UDP server is 127.0.0.1:1234 \n```", "```go\n>> Hello!\nReply: Hi from the server. \n```", "```go\n>> Have to leave now :)\nReply: OK - bye from nc -l -u 1234 \n```", "```go\n>> STOP\nExiting UDP client! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"math/rand\"\n\"net\"\n\"os\"\n\"strconv\"\n\"strings\"\n\"time\"\n)\nfunc random(min, max int) int {\n    return rand.Intn(max-min) + min\n}\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Please provide a port number!\")\n        return\n    }\n    PORT := \":\" + arguments[1] \n```", "```go\n s, err := net.ResolveUDPAddr(\"udp4\", PORT)\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n connection, err := net.ListenUDP(\"udp4\", s)\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n defer connection.Close()\n    buffer := make([]byte, 1024) \n```", "```go\n rand.Seed(time.Now().Unix())\n    for {\n        n, addr, err := connection.ReadFromUDP(buffer)\n        fmt.Print(\"-> \", string(buffer[0:n-1])) \n```", "```go\n if strings.TrimSpace(string(buffer[0:n])) == \"STOP\" {\n            fmt.Println(\"Exiting UDP server!\")\n            return\n        } \n```", "```go\n data := []byte(strconv.Itoa(random(1, 1001)))\n        fmt.Printf(\"data: %s\\n\", string(data)) \n```", "```go\n _, err = connection.WriteToUDP(data, addr)\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n    }\n} \n```", "```go\n$ go run udpS.go 1234\n-> Hello from client!\ndata: 403 \n```", "```go\n-> Going to terminate the connection now.\ndata: 154 \n```", "```go\n-> STOP\nExiting UDP server! \n```", "```go\n$ go run udpC.go localhost:1234\nThe UDP server is 127.0.0.1:1234\n>> Hello from client!\nReply: 403 \n```", "```go\n>> Going to terminate the connection now.\nReply: 154 \n```", "```go\n>> STOP\nExiting UDP client! \n```", "```go\npackage main\nimport (\n    \"bufio\"\n\"fmt\"\n\"net\"\n\"os\"\n\"strconv\"\n\"strings\"\n)\nvar count = 0\nfunc handleConnection(c net.Conn, myCount int) {\n    fmt.Print(\".\") \n```", "```go\n netData, err := bufio.NewReader(c).ReadString('\\n')\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    for {\n\n        temp := strings.TrimSpace(string(netData))\n        if temp == \"STOP\" {\n            break\n        }\n        fmt.Println(temp)\n        counter := \"Client number: \" + strconv.Itoa(myCount) + \"\\n\"\n        c.Write([]byte(string(counter)))\n    } \n```", "```go\n defer c.Close()\n} \n```", "```go\nfunc main() {\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Please provide a port number!\")\n\n        os.Exit(5)\n    }\n    PORT := \":\" + arguments[1]\n    l, err := net.Listen(\"tcp4\", PORT)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer l.Close()\n    for {\n        c, err := l.Accept()\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        go handleConnection(c, count)\n        count++\n    }\n} \n```", "```go\n$ go run concTCP.go 1234\n.Hello\n.Hi from  nc localhost 1234 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"log\"\n\"net/http\"\n\"os\"\n\"time\"\n\"github.com/gorilla/websocket\"\n) \n```", "```go\nvar PORT = \":1234\"\nvar upgrader = websocket.Upgrader{\n    ReadBufferSize:  1024,\n    WriteBufferSize: 1024,\n    CheckOrigin: func(r *http.Request) bool {\n        return true\n    },\n} \n```", "```go\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Welcome!\\n\")\n    fmt.Fprintf(w, \"Please use /ws for WebSocket!\")\n} \n```", "```go\nfunc wsHandler(w http.ResponseWriter, r *http.Request) {\n    log.Println(\"Connection from:\", r.Host)\n    ws, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n        log.Println(\"upgrader.Upgrade:\", err)\n        return\n    }\n    defer ws.Close() \n```", "```go\n for {\n        mt, message, err := ws.ReadMessage()\n        if err != nil {\n            log.Println(\"From\", r.Host, \"read\", err)\n            break\n        }\n        log.Print(\"Received: \", string(message))\n        err = ws.WriteMessage(mt, message)\n        if err != nil {\n            log.Println(\"WriteMessage:\", err)\n            break\n        }\n    }\n} \n```", "```go\nfunc main() {\n    arguments := os.Args\n    if len(arguments) != 1 {\n        PORT = \":\" + arguments[1]\n    } \n```", "```go\n mux := http.NewServeMux()\n    s := &http.Server{\n        Addr:         PORT,\n        Handler:      mux,\n        IdleTimeout:  10 * time.Second,\n        ReadTimeout:  time.Second,\n        WriteTimeout: time.Second,\n    } \n```", "```go\n mux.Handle(\"/\", http.HandlerFunc(rootHandler))\n    mux.Handle(\"/ws\", http.HandlerFunc(wsHandler)) \n```", "```go\n log.Println(\"Listening to TCP Port\", PORT)\n    err := s.ListenAndServe()\n    if err != nil {\n        log.Println(err)\n        return\n    }\n} \n```", "```go\n$ go mod init\n$ go mod tidy\n$ go run server.go \n```", "```go\n$ websocat ws://localhost:1234/ws\nHello from websocat! \n```", "```go\nHello from websocat! \n```", "```go\nBye! \n```", "```go\nBye! \n```", "```go\n$ websocat -v ws://localhost:1234/ws\n[INFO  websocat::lints] Auto-inserting the line mode\n[INFO  websocat::stdio_threaded_peer] get_stdio_peer (threaded)\n[INFO  websocat::ws_client_peer] get_ws_client_peer\n[INFO  websocat::ws_client_peer] Connected to ws\nHello from websocat!\nHello from websocat!\nBye!\nBye!\n[INFO  websocat::sessionserve] Forward finished\n[INFO  websocat::ws_peer] Received WebSocket close message\n[INFO  websocat::sessionserve] Reverse finished\n[INFO  websocat::sessionserve] Both directions finished \n```", "```go\n$ go run server.go\n2023/10/09 20:29:16 Listening to TCP Port :1234\n2023/10/09 20:29:24 Connection from: localhost:1234\n2023/10/09 20:29:31 Received: Hello from websocat!\n2023/10/09 20:29:53 Received: Bye!\n2023/10/09 20:30:01 From localhost:1234 read websocket: close 1005 (no status) \n```", "```go\npackage main\nimport (\n    \"bufio\"\n\"fmt\"\n\"log\"\n\"net/url\"\n\"os\"\n\"os/signal\"\n\"syscall\"\n\"time\"\n\"github.com/gorilla/websocket\"\n)\nvar (\n    SERVER       = \"\"\n    PATH         = \"\"\n    TIMESWAIT    = 0\n    TIMESWAITMAX = 5\n    in           = bufio.NewReader(os.Stdin)\n) \n```", "```go\nfunc getInput(input chan string) {\n    result, err := in.ReadString('\\n')\n    if err != nil {\n        log.Println(err)\n        return\n    }\n    input <- result\n} \n```", "```go\nfunc main() {\n    arguments := os.Args\n    if len(arguments) != 3 {\n        fmt.Println(\"Need SERVER + PATH!\")\n        return\n    }\n    SERVER = arguments[1]\n    PATH = arguments[2]\n    fmt.Println(\"Connecting to:\", SERVER, \"at\", PATH)\n    interrupt := make(chan os.Signal, 1)\n    signal.Notify(interrupt, os.Interrupt) \n```", "```go\n input := make(chan string, 1)\n    go getInput(input)\n    URL := url.URL{Scheme: \"ws\", Host: SERVER, Path: PATH}\n    c, _, err := websocket.DefaultDialer.Dial(URL.String(), nil)\n    if err != nil {\n        log.Println(\"Error:\", err)\n        return\n    }\n    defer c.Close() \n```", "```go\n done := make(chan struct{})\n    go func() {\n        defer close(done)\n        for {\n            _, message, err := c.ReadMessage()\n            if err != nil {\n                log.Println(\"ReadMessage() error:\", err)\n                return\n            }\n            log.Printf(\"Received: %s\", message)\n        }\n    }() \n```", "```go\n for {\n        select {\n        case <-time.After(4 * time.Second):\n            log.Println(\"Please give me input!\", TIMESWAIT)\n            TIMESWAIT++\n            if TIMESWAIT > TIMESWAITMAX {\n                syscall.Kill(syscall.Getpid(), syscall.SIGINT)\n            } \n```", "```go\n case <-done:\n            return\ncase t := <-input:\n            err := c.WriteMessage(websocket.TextMessage, []byte(t))\n            if err != nil {\n                log.Println(\"Write error:\", err)\n                return\n            }\n            TIMESWAIT = 0 \n```", "```go\n go getInput(input)\n        case <-interrupt:\n            log.Println(\"Caught interrupt signal - quitting!\")\n            err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")) \n```", "```go\n if err != nil {\n                log.Println(\"Write close error:\", err)\n                return\n            }\n            select {\n            case <-done:\n            case <-time.After(2 * time.Second):\n            }\n            return\n        }\n    }\n} \n```", "```go\n$ cd client\n$ go mod init\n$ go mod tidy \n```", "```go\n$ go run client.go localhost:1234 ws\nConnecting to: localhost:1234 at ws\nHello there!\n2023/10/09 20:36:25 Received: Hello there! \n```", "```go\n2023/10/09 20:36:29 Please give me input! 0\n2023/10/09 20:36:33 Please give me input! 1\n2023/10/09 20:36:37 Please give me input! 2\n2023/10/09 20:36:41 Please give me input! 3\n2023/10/09 20:36:45 Please give me input! 4\n2023/10/09 20:36:49 Please give me input! 5\n2023/10/09 20:36:49 Caught interrupt signal - quitting!\n2023/10/09 20:36:49 ReadMessage() error: websocket: close 1000 (normal) \n```", "```go\n2023/10/09 20:36:22 Connection from: localhost:1234\n2023/10/09 20:36:25 Received: Hello there!\n2023/10/09 20:36:49 From localhost:1234 read websocket: close 1000 (normal) \n```", "```go\n$ go run client.go localhost:1234 ws\nConnecting to: localhost:1234 at ws\n2023/10/09 08:11:20 Error: dial tcp [::1]:1234: connect: connection refused \n```", "```go\nversion: \"3.6\"\nservices:\nrabbitmq:\nimage: 'rabbitmq:3.12-management'\ncontainer_name: rabbit\nports:\n- '5672:5672'\n- '15672:15672'\nenvironment:\nAMQP_URL: 'amqp://rabbitmq?connection_attempts=5&retry_delay=5'\nRABBITMQ_DEFAULT_USER: \"guest\"\nRABBITMQ_DEFAULT_PASS: \"guest\"\nnetworks:\n- rabbit\nnetworks:\nrabbit:\ndriver: bridge \n```", "```go\npackage main\nimport (\n    \"fmt\"\n    amqp \"github.com/rabbitmq/amqp091-go\"\n)\nfunc main() {\n    fmt.Println(\"RabbitMQ producer\")\n    conn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n    if err != nil {\n        fmt.Println(\"amqp.Dial():\", err)\n        return\n    }\n    ch, err := conn.Channel()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer ch.Close() \n```", "```go\n q, err := ch.QueueDeclare(\"Go\", false, false, false, false, nil)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"Queue:\", q)\n    message := \"Writing to RabbitMQ!\"\n    err = ch.PublishWithContext(nil, \"\", \"Go\", false, false,\n        amqp.Publishing{ContentType: \"text/plain\", Body: []byte(message)},\n    )\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"Message published to Queue!\")\n} \n```", "```go\n$ go run sendMQ.go\nRabbitMQ producer\nQueue: {Go 0 0}\nMessage published to Queue!\n$ go run sendMQ.go\nRabbitMQ producer\nQueue: {Go 1 0}\nMessage published to Queue! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n    amqp \"github.com/rabbitmq/amqp091-go\"\n)\nfunc main() {\n    fmt.Println(\"RabbitMQ consumer\")\n    conn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n    if err != nil {\n        fmt.Println(\"Failed Initializing Broker Connection\")\n        panic(err)\n    }\n    ch, err := conn.Channel()\n    if err != nil {\n        fmt.Println(err)\n    }\n    defer ch.Close() \n```", "```go\n msgs, err := ch.Consume(\"Go\", \"\", true, false, false, false, nil)\n    if err != nil {\n        fmt.Println(err)\n    }\n    forever := make(chan bool)\n    go func() {\n        for d := range msgs {\n            fmt.Printf(\"Received: %s\\n\", d.Body)\n        }\n    }()\n    fmt.Println(\"Connected to the RabbitMQ server!\")\n    <-forever\n} \n```", "```go\n$ go run readMQ.go\nRabbitMQ consumer\nConnected to the RabbitMQ server!\nReceived: Writing to RabbitMQ!\nReceived: Writing to RabbitMQ! \n```", "```go\nmodule github.com/mactsouk/mGo4th/ch10/MQ/consumer\ngo 1.21.1\nrequire github.com/rabbitmq/amqp091-go v1.8.1 \n```", "```go\n$ go get github.com/rabbitmq/amqp091-go@none\ngo: removed github.com/rabbitmq/amqp091-go v1.8.1 \n```", "```go\nmodule github.com/mactsouk/mGo4th/ch10/MQ/consumer\ngo 1.21.1 \n```"]