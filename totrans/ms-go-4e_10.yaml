- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with TCP/IP and WebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP/IP is the foundation of the Internet and, therefore, being able to create
    TCP/IP servers and clients is essential when developing network services. This
    chapter teaches you how to work with the lower-level protocols of TCP/IP, which
    are TCP and UDP, with the help of the `net` package, so that you can develop TCP/IP
    servers and clients and have more control over their functionality. The Go code
    of the TCP and UDP utilities included in this chapter allows us to create our
    own advanced TCP/IP services as the core principles and logic of TCP/IP remain
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, this chapter illustrates the development of servers and clients
    for the WebSocket protocol, which is based on HTTP, and shows how to interact
    with RabbitMQ, which is an open-source *message broker*.
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket protocol provides full-duplex communication channels over a single
    TCP connection. On the other hand, message brokers such as RabbitMQ and Apache
    Kafka are famous for their speed, which is the main reason for including them
    in a workflow that processes lots of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, this chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `net` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a TCP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a TCP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a UDP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a UDP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing concurrent TCP servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a WebSocket server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a WebSocket client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP/IP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TCP/IP is a family of protocols that help the Internet operate. Its name comes
    from its two most well-known protocols: TCP and IP.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP stands for Transmission Control Protocol. TCP software transmits data between
    machines using segments, which are also called TCP packets. The main characteristic
    of TCP is that it is a **reliable protocol**, which means that it makes sure that
    every packet is delivered without requiring any extra code from the programmer.
    If there is no proof of packet delivery, TCP resends that packet. Among other
    things, TCP packets can be used to establish connections, transfer data, send
    acknowledgments, and close connections.
  prefs: []
  type: TYPE_NORMAL
- en: When a TCP connection is established between two machines, a full-duplex virtual
    circuit, similar to a telephone call, is created between those two machines. The
    two machines constantly communicate to make sure that data is sent and received
    correctly. If the connection fails for some reason, the two machines try to find
    the problem and report it to the relevant application. The TCP header of each
    packet includes the source port and destination port fields. These two fields,
    plus the source and destination IP addresses, are combined to uniquely identify
    every single TCP connection. All these details are handled by TCP/IP, as long
    as you provide the required details without any extra effort.
  prefs: []
  type: TYPE_NORMAL
- en: When creating TCP/IP server processes, remember that port numbers 0-1024 have
    restricted access and can only be used by the root user, which means that you
    need administrative privileges to use any port in that range. Running a process
    with root privileges is a security risk and must be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: IP stands for Internet Protocol. The main characteristic of IP is that it is
    not a reliable protocol by nature. IP encapsulates the data that travels over
    a TCP/IP network because it is responsible for delivering packets from the source
    host to the destination host according to the IP addresses. IP must find an addressing
    method for sending a packet to its destination effectively. Although there are
    dedicated devices, called routers, that perform IP routing, every TCP/IP device
    has to perform some basic routing.
  prefs: []
  type: TYPE_NORMAL
- en: The first version of the IP protocol is now called IPv4 to differentiate it
    from the latest version of the IP protocol, which is called IPv6\. The main problem
    with IPv4 is that it is about to run out of available IP addresses, which is the
    main reason for creating the IPv6 protocol. This happened because an IPv4 address
    is represented using 32 bits only, which allows a total number of 2^(32) (4,294,967,296)
    different IP addresses. On the other hand, IPv6 uses 128 bits to define each one
    of its addresses. The format of an IPv4 address is `10.20.32.245` (four parts
    with values from 0 to 255 separated by dots), while the format of an IPv6 address
    is `3fce:1706:4523:3:150:f8ff:fe21:56cf` (eight parts separated by colons).
  prefs: []
  type: TYPE_NORMAL
- en: UDP (User Datagram Protocol) is based on IP, which means that it is also unreliable.
    UDP is simpler than TCP, mainly because UDP is not reliable by design. As a result,
    UDP messages can be lost, duplicated, or arrive out of order. Furthermore, packets
    can arrive faster than the recipient can process them. So, UDP is used when speed
    is more important than reliability.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter implements both TCP and UDP software—TCP and UDP services are the
    basis of the Internet. But first, let us talk about the handy `nc(1)` utility.
  prefs: []
  type: TYPE_NORMAL
- en: The nc(1) command line utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nc(1)` utility, which is also called `netcat(1)`, is very convenient when
    you want to test TCP/IP servers and clients: `nc(1)` is a utility for everything
    that involves TCP and UDP as well as IPv4 and IPv6, including but not limited
    to opening TCP connections, sending and receiving UDP messages, and acting as
    a TCP server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `nc(1)` as a client for a TCP service that runs on a machine with
    the `10.10.1.123` IP address and listens to port number `1234`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `-l` option tells `netcat(1)` to act as a server, which means that when
    the `-l` option is given, `netcat(1)` starts listening for incoming connections
    at the given port number. By default, `nc(1)` uses the TCP protocol. However,
    if you execute `nc(1)` with the `-u` flag, it uses the UDP protocol, either as
    a client or as a server. Finally, the `-v` and `-vv` options tell `netcat(1)`
    to generate verbose output, which can be practical when you want to troubleshoot
    network connections.
  prefs: []
  type: TYPE_NORMAL
- en: The net package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net` package of the Go Standard Library is all about TCP/IP, UDP, domain
    name resolution, and UNIX domain sockets. The `net.Dial()` function is used to
    connect to a network as a client, whereas the `net.Listen()` function is used
    to tell a Go program to accept incoming network connections and thus act as a
    server.
  prefs: []
  type: TYPE_NORMAL
- en: The return value for both `net.Dial()` and `net.Listen()` is of the `net.Conn`
    data type, which implements the `io.Reader` and `io.Writer` interfaces—this means
    that you can both read and write to a `net.Conn` connection using code related
    to file I/O. The first parameter of both `net.Dial()` and `net.Listen()` is the
    network type, but this is where their similarities end.
  prefs: []
  type: TYPE_NORMAL
- en: The `net.Dial()` function is used to connect to a remote server. The first parameter
    of the `net.Dial()` function defines the network protocol that is going to be
    used, while the second parameter defines the server address, which must also include
    the port number. Valid values for the first parameter are `tcp`, `tcp4` (IPv4-only),
    `tcp6` (IPv6-only), `udp`, `udp4` (IPv4-only), `udp6` (IPv6-only), `ip`, `ip4`
    (IPv4-only), `ip6` (IPv6-only), `unix` (UNIX sockets), `unixgram`, and `unixpacket`.
    On the other hand, valid values for `net.Listen()` are `tcp`, `tcp4`, `tcp6`,
    `unix`, and `unixpacket`.
  prefs: []
  type: TYPE_NORMAL
- en: Execute the `go doc net.Listen` and `go doc net.Dial` commands for detailed
    information regarding these two functions.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a TCP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is about developing TCP clients. The two subsections that follow
    present two equivalent ways of developing TCP clients.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a TCP client with net.Dial()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we are going to present the most widely used way, which is implemented
    in `tcpC.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `import` block contains packages such as `bufio` and `fmt` that also work
    with file I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, we read the details of the TCP server we want to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the connection details, we call `net.Dial()`—its first parameter is the
    protocol we want to use, which in this case is `tcp`, and its second parameter
    contains the connection details. A successful `net.Dial()` call returns an open
    connection (a `net.Conn` interface), which is a generic stream-oriented network
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the TCP client keeps reading user input until the word `STOP`
    is given as input—in this case, the client waits for the server response before
    terminating after `STOP` because this is how the `for` loop is constructed. This
    mainly happens because the server might have a useful answer for us, and we do
    not want to miss that. All given user input is sent (written) to the open TCP
    connection using `fmt.Fprintf()`, whereas `bufio.NewReader()` is used to read
    data from the TCP connection, just like you would do with a regular file.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that the reason for not checking the `error` value returned by
    `reader.ReadString('\n')` is simplicity. We should never ignore errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `tcpC.go` to connect to a TCP server, which in this case is implemented
    with `nc(1)` as `nc -l 1234`, produces the next kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Lines beginning with `>>` denote user input, whereas lines beginning with `->`
    signify server messages. After sending `STOP`, we wait for the server response
    and then the client ends the TCP connection. The previous code demonstrates how
    to create a proper TCP client in Go with some extra logic and functionality in
    it (the `STOP` keyword).
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection shows a different way of creating a TCP client.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a TCP client that uses net.DialTCP()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This subsection presents an alternative way to develop a TCP client. The difference
    lies in the Go functions that are being used to establish the TCP connection,
    which are `net.DialTCP()` and `net.ResolveTCPAddr()`, and not in the functionality
    of the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `otherTCPclient.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although we are working with TCP/IP connections, we need packages such as `bufio`
    because UNIX treats network connections as files, so we are basically working
    with I/O operations over networks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We need to read the details of the TCP server we want to connect to, including
    the desired port number. The utility cannot operate with default parameters when
    working with TCP/IP unless we are developing a very specialized TCP client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `net.ResolveTCPAddr()` function is specific to TCP connections, hence its
    name, and resolves the given address to a `*net.TCPAddr` value, which is a structure
    that represents the address of a TCP endpoint—in this case, the endpoint is the
    TCP server we are going to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the TCP endpoint at hand, we call `net.DialTCP()` to connect to the server.
    Apart from the use of `net.ResolveTCPAddr()` and `net.DialTCP()`, the rest of
    the code that has to do with the TCP client and TCP server interaction is exactly
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, an infinite `for` loop is used to interact with the TCP server. The
    TCP client reads user data, which is sent to the server. After that, it reads
    data from the TCP server. Once again, the `STOP` keyword terminates the TCP connection
    on the client side using the `Close()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with `otherTCPclient.go` and interacting with a TCP server process
    produces the next kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The interaction is the same as with `tcpC.go`—we have just learned a different
    way of developing TCP clients. If you want my opinion, I prefer the implementation
    found in `tcpC.go` because it uses more generic functions. However, this is just
    personal taste.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to program TCP servers.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a TCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents two ways of developing TCP servers that can interact with
    TCP clients, just as we did with the TCP client.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a TCP server with net.Listen()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TCP server presented in this section, which uses `net.Listen()`, returns
    the current date and time to the client in a single network packet. In practice,
    this means that after accepting a client connection, the server gets the time
    and date from the operating system and sends that data back to the client. The
    `net.Listen()` function listens for connections, whereas the `net.Accept()` method
    waits for the next connection and returns a generic `net.Conn` variable with the
    client information. The code of `tcpS.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The TCP server should know about the port number it is going to use—this is
    given as a command line argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `net.Listen()` function listens for connections and is what makes that particular
    program a server process. If the second parameter of `net.Listen()` contains a
    port number without an IP address or a hostname, `net.Listen()` listens to all
    available IP addresses of the local system, which is the case here.
  prefs: []
  type: TYPE_NORMAL
- en: This is a personal preference; although it is considered a bad practice to have
    variable names such as `PORT` and `SERVER`, this is my own way of signifying important
    or global variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We call `Accept()` and wait for a client connection—`Accept()` blocks until
    a new connection comes. There is something unusual with this particular TCP server:
    it can only serve the first TCP client that is going to connect to it because
    the `Accept()` call is outside of the `for` loop and therefore is **called only
    once**. Each individual client should be served by a different `Accept()` call,
    which is not happening here. Correcting that is left as an exercise for the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This endless `for` loop keeps interacting with the same TCP client until the
    word `STOP` is sent from the client. As it happened with the TCP clients, `bufio.NewReader()`
    is used to read data from the network connection, whereas `Write()` is used to
    send data to the TCP client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `tcpS.go` and interacting with a TCP client produces the next kind
    of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The server connection ended automatically with the client connection because
    the `for` loop concluded when `bufio.NewReader(c).ReadString(''\n'')` had nothing
    more to read. The client was `nc(1)`, which produced the next output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have ended the connection using the `STOP` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: So, we now know how to develop a TCP server in Go. As with the TCP client, there
    is an alternative way to develop a TCP server, which is presented in the next
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a TCP server that uses net.ListenTCP()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This time, this alternative version of the TCP server implements the echo service.
    Put simply, the TCP server sends back to the client the data that was received
    by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `otherTCPserver.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous code gets the TCP port number value as a command line argument,
    which is used in `net.ResolveTCPAddr()`—this is required for defining the TCP
    port number the TCP server is going to listen to.
  prefs: []
  type: TYPE_NORMAL
- en: That function only works with TCP, hence its name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `net.ListenTCP()` only works with TCP and is what makes that program
    a TCP server ready to accept incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As before, due to the place where `Accept()` is called, this particular implementation
    can work with a single client only. This is used for reasons of simplicity. The
    concurrent TCP server that is developed later on in this chapter puts the `Accept()`
    call inside an endless `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You need to use `strings.TrimSpace()` in order to remove any space characters
    from your input and compare the result with `STOP`, which has a special meaning
    in this implementation. Once the `STOP` keyword is received from the client, the
    server closes the connection using the `Close()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All previous code is for interacting with the TCP client until the client decides
    to close the connection. Running `otherTCPserver.go` and interacting with a TCP
    client produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first line that begins with `>` is the client message, whereas the second
    line is the server output when getting the `STOP` message from the client. Therefore,
    the TCP server processes client requests as programmed and exits when it gets
    the `STOP` message, which is the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is about developing UDP clients.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a UDP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section demonstrates how to develop a UDP client that can interact with
    UDP services. The code of `udpC.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is how we get the UDP server details from the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The previous two lines declare that we are using UDP and that we want to connect
    to the UDP server that is specified by the return value of `net.ResolveUDPAddr()`.
    The actual connection is initiated using `net.DialUDP()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This part of the program finds the details of the UDP server by calling the
    `RemoteAddr()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Data is read from the user using `bufio.NewReader(os.Stdin)` and is written
    to the UDP server using `Write()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the input read from the user is the `STOP` keyword, then the connection is
    terminated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Data is read from the UDP connection using the `ReadFromUDP()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop is going to keep going forever until the `STOP` keyword is received
    as input or the program is terminated in some other way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with `udpC.go` is as simple as follows—the client side is implemented
    using `nc(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`127.0.0.1:1234` is the value of `c.RemoteAddr().String()`, which shows the
    details of the UDP server we have connected to.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Our client sent `Hello!` to the UDP server and received `Hi from the server.`
    back.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Our client sent `Have to leave now :)` to the UDP server and received `OK -
    bye from nc -l -u 1234` back. The UDP server started using `nc -l -u 1234`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, after sending the `STOP` keyword to the server, the client prints `Exiting
    UDP client!` and terminates—the message is defined in the Go code and can be anything
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is about programming a UDP server.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a UDP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section shows how to develop a UDP server, which generates and returns
    random numbers to its clients. The code for the UDP server (`udpS.go`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The UDP port number the server is going to listen to is provided as a command
    line argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `net.ResolveUDPAddr()` function creates a UDP endpoint that the UDP server
    is going to listen to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `net.ListenUDP("udp4", s)` function call makes this process a server for
    the `udp4` protocol using the details specified by its second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `buffer` variable stores a byte slice with 1024 bytes and is used to read
    data from the connection with the UDP client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `ReadFromUDP()` and `WriteToUDP()` methods are used to read data from a
    UDP connection and write data to a UDP connection, respectively. Additionally,
    due to the way UDP operates, the UDP server can serve multiple clients.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The UDP server terminates when any one of the clients sends the `STOP` message.
    Aside from this, the `for` loop is going to keep running forever.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: A byte slice is stored in the `data` variable and used to write the desired
    data to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Working with `udpS.go` is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Lines beginning with `->` show data coming from a client. Lines beginning with
    `data:` show random numbers generated by the UDP server—in this case, `403`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The previous two lines show another interaction with a UDP client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Once the UDP server receives the `STOP` keyword from the client, it closes the
    connection and exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, which uses `udpC.go`, we have the following interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The client sends the `Hello from client!` message to the server and receives
    `403`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The client sends `Going to terminate the connection now.` to the server and
    receives the random number `154`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When the client gets `STOP` as user input, it terminates the UDP connection
    and exits.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to develop a concurrent TCP server that uses goroutines
    for serving its clients.
  prefs: []
  type: TYPE_NORMAL
- en: Developing concurrent TCP servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section teaches you a pattern for developing concurrent TCP servers, which
    are servers that use separate goroutines to serve their clients following a successful
    `Accept()` call. Therefore, such servers can serve multiple TCP clients at the
    same time. This is how real-world production servers and services are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `concTCP.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The previous statement is not required—it just informs us that a new client
    has been connected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop makes sure that `handleConnection()` is not going to exit automatically.
    Once again, the `STOP` keyword stops the goroutine of the current client connection—however,
    the server process, as well as all other active client connections, is going to
    keep running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is the end of the function that is executed as a goroutine to serve clients.
    All you need in order to serve a client is a `net.Conn` parameter with the TCP
    client details. After reading the client data, the server sends back a message
    to the current TCP client indicating the total number of TCP clients that have
    been served so far.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Each time a new client connects to the server, the `count` variable is increased.
    Each TCP client is served by a separate goroutine that executes the `handleConnection()`
    function. This frees the server process and allows it to accept new connections.
    Put simply, while multiple TCP clients are being served, the TCP server is free
    to interact with more TCP clients. As before, new TCP clients are connected using
    the `Accept()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with `concTCP.go` produces the next kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The first line of output is from the first TCP client, whereas the second line
    is from the second TCP client. This means that the concurrent TCP server works
    as expected. Therefore, when you want to be able to serve multiple TCP clients
    in your TCP services, you can use the presented technique and code as a template
    for developing your own concurrent TCP servers.
  prefs: []
  type: TYPE_NORMAL
- en: The sections that follow concern the WebSocket protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebSocket server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WebSocket protocol is a computer communications protocol that provides full-duplex
    (transmission of data in two directions simultaneously) communication channels
    over a single TCP connection. The WebSocket protocol is defined in RFC 6455 ([https://tools.ietf.org/html/rfc6455](https://tools.ietf.org/html/rfc6455))
    and uses `ws://` and `wss://` instead of `http://` and `https://`, respectively.
    Therefore, the client should begin a WebSocket connection by using a URL that
    starts with `ws://`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to develop a small yet fully functional WebSocket
    server using the `gorilla/websocket` ([https://github.com/gorilla/websocket](https://github.com/gorilla/websocket))
    module. The server implements the echo service, which means that it automatically
    returns the client input back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The `https://pkg.go.dev/golang.org/x/net/websocket` package offers another way
    of developing WebSocket clients and servers. However, based on its documentation,
    `pkg.go.dev/golang.org/x/net/websocket` lacks some features and it is advised
    to use either [https://pkg.go.dev/github.com/gorilla/websocket](https://pkg.go.dev/github.com/gorilla/websocket),
    the one used here, or [https://pkg.go.dev/nhooyr.io/websocket](https://pkg.go.dev/nhooyr.io/websocket)
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might ask why to use the WebSocket protocol instead of HTTP. The advantages
    of the WebSocket protocol include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A WebSocket connection is a full-duplex, bidirectional communications channel.
    This means that a server does not need to wait to read from a client to send data
    to the client and vice versa.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket connections are raw TCP sockets, which means that they do not have
    the overhead required to establish an HTTP connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket connections can also be used to send HTTP data. However, plain HTTP
    connections cannot work as WebSocket connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket connections live until they are killed, so there is no need to reopen
    them all the time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket connections can be used for real-time web applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data can be sent from the server to the client at any time, without the client
    even requesting it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket is part of the HTML5 specification, which means that it is supported
    by all modern web browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before showing the server implementation, it would be good for you to know that
    the `websocket.Upgrader` method of the `gorilla/websocket` package upgrades an
    HTTP server connection to the WebSocket protocol and allows you to define the
    parameters of the upgrade. After that, your HTTP connection is a WebSocket connection,
    which means that you will not be allowed to execute statements that work with
    the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection shows the implementation of the server.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This subsection presents the implementation of the WebSocket server that implements
    the echo service, which can be really handy when testing network connections.
  prefs: []
  type: TYPE_NORMAL
- en: The code is put inside `~/go/src/github.com/mactsouk/mGo4th/ch10/ws`. The `server`
    directory contains the implementation of the server whereas the `client` directory
    contains the implementation of the WebSocket client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the WebSocket server can be found in `server.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is the external package used for working with the WebSocket protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is where the parameters of `websocket.Upgrader` are defined. They are going
    to be used shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is a regular HTTP handler function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: A WebSocket server application calls the `Upgrader.Upgrade` method to get a
    WebSocket connection from an HTTP request handler. After a successful call to
    `Upgrader.Upgrade`, the server begins working with the WebSocket connection and
    the WebSocket client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop in `wsHandler()` handles all incoming messages for `/ws`—you
    can use any technique you want to serve incoming requests. Additionally, in the
    presented implementation, only the client is allowed to close an existing WebSocket
    connection unless there is a network issue, or the server process is killed.
  prefs: []
  type: TYPE_NORMAL
- en: Last, remember that in a WebSocket connection, you cannot use `fmt.Fprintf()`
    statements to send data to the WebSocket client—if you use any of these, or any
    other call that can implement the same functionality, the WebSocket connection
    fails and you are not going to be able to send or receive any data. Therefore,
    the only way to send and receive data in a WebSocket connection implemented with
    `gorilla/websocket` is through `WriteMessage()` and `ReadMessage()` calls, respectively.
    Of course, you can always implement the desired functionality on your own by working
    with raw network data, but implementing this goes beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If there is not a command line argument, the default port number stored in the
    `PORT` global variable is used. Otherwise, the given value is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: These are the details of the HTTP server that also handles WebSocket connections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint used for WebSocket can be anything you want—in this case, it is
    `/ws`. Additionally, you can have multiple endpoints that work with the WebSocket
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The presented code uses `log.Println()` instead of `fmt.Println()` for printing
    messages—as this is a server process, using `log.Println()` is a much better choice
    than `fmt.Println()` because logging information is sent to files that can be
    examined at a later time. However, during development, you might prefer `fmt.Println()`
    calls and avoid writing to your log files because you can see your data on screen
    immediately without having to look elsewhere. Additionally, if you are going to
    run the server as a Docker image, using `fmt.Println()` makes more sense. However,
    you should bear in mind that the `log` package also prints to the screen by default.
  prefs: []
  type: TYPE_NORMAL
- en: The server implementation is short, yet fully functional. The single most important
    call in the code is `Upgrader.Upgrade` because this is what upgrades an HTTP connection
    to a WebSocket connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting and running the code from GitHub requires the following steps—most
    of the steps have to do with module initialization and downloading the required
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: To test that server, we need to have a client. As we have not developed our
    own client so far, we are going to test the WebSocket server using the `websocat`
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: Using websocat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`websocat` is a command line utility that can help you test WebSocket connections.
    However, as `websocat` is not installed by default, you need to install it on
    your machine using your package manager of choice. You can use it as follows,
    provided that there is a WebSocket server at the desired address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is what we type and send to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is what we get back from the WebSocket server, which implements the echo
    service—different WebSocket servers implement different functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Again, the previous line is user input given to `websocat`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: And the last line is the data sent back from the server. The connection was
    closed by pressing *Ctrl* + *D* on the `websocat` client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you wish for verbose output from `websocat`, you can execute it with
    the `-v` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the output from our WebSocket server should be similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection shows how to develop a WebSocket client in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebSocket client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection shows how to program a WebSocket client in Go. The client reads
    user data, sends it to the server, and reads the server response. The `client`
    directory contains the implementation of the WebSocket client. The `gorilla/websocket`
    package is going to help us develop the WebSocket client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `./client/client.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `in` variable is just a shortcut for `bufio.NewReader(os.Stdin)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `getInput()` function, which is executed as a goroutine, gets user input
    that is transferred to the `main()` function via the `input` channel. Each time
    the program reads some user input, the old goroutine ends and a new `getInput()`
    goroutine begins in order to get new user input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The WebSocket client handles UNIX interrupts with the help of the `interrupt`
    channel. When the appropriate signal is caught (`syscall.SIGINT`), the WebSocket
    connection with the server is closed with the help of the `websocket.CloseMessage`
    message. This is how professional tools work!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The WebSocket connection begins with a call to `websocket.DefaultDialer.Dial()`.
    Everything that goes to the `input` channel is transferred to the WebSocket server
    using the `WriteMessage()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Another goroutine, which this time is implemented using an anonymous Go function,
    is responsible for reading data from the WebSocket connection using the `ReadMessage()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `syscall.Kill(syscall.Getpid(), syscall.SIGINT)` statement sends the interrupt
    signal to the program using Go code. According to the logic of `client.go`, the
    interrupt signal makes the program close the WebSocket connection with the server
    and terminate its execution. This only happens if the current number of timeout
    periods is bigger than a predefined global value, which in this case is equal
    to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If you get user input, the current number of the timeout periods (`TIMESWAIT`)
    is reset and the new input is read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Just before we close the client connection, we send `websocket.CloseMessage`
    to the server in order to end the connection the right way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As `./client/client.go` is in a separate directory, we need to run the next
    commands in order to collect the required dependencies and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Interacting with the WebSocket server produces the next kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The previous two lines show user input as well as the server response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The last lines of output show how the automatic timeout process works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WebSocket server generated the following output for the previous interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if a WebSocket server cannot be found at the address provided, the
    WebSocket client produces the next output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `connection refused` message indicates that there is no process listening
    to port number `1234` on `localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: The next section of the chapter is about working with the RabbitMQ message broker.
  prefs: []
  type: TYPE_NORMAL
- en: Working with RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section of this chapter, we are going to learn how to work with
    RabbitMQ. RabbitMQ is an open-source message broker that is particularly handy
    when you want to exchange information asynchronously and need a place where messages
    can be stored safely until they are read. RabbitMQ enables you to exchange information,
    which is the main reason that you do not need to use it directly unless you want
    to perform administrative tasks.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ uses the AMQP protocol. AMQP, which stands for Advanced Message Queuing
    Protocol, is an open protocol for message-oriented middleware. The characteristic
    features of AMQP are message orientation, queuing, routing, reliability, and security.
    AMQP works with binary data and transmits data in frames. There exist nine types
    of frames (open connection, close connection, transfer data, etc.) depending on
    the task that you want to perform.
  prefs: []
  type: TYPE_NORMAL
- en: If you must choose between RabbitMQ and Kafka, which both do a similar job,
    you should begin by considering their differences. First, Kafka is faster than
    RabbitMQ. Second, RabbitMQ works with the push model whereas Kafka works with
    a pull-based approach. Third, Kafka offers support for batching whereas RabbitMQ
    does not. Last, RabbitMQ does not have a limit on the payload size whereas Kafka
    has some restrictions on the payload size. The key thing to remember is that if
    speed is your main concern, then Kafka might be a better choice, whereas if payload
    size and simplicity are your main concerns, then RabbitMQ is a more rational choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data is stored in queues. A queue in RabbitMQ is a FIFO (First In, First Out)
    structure that supports two operations: adding elements and getting elements.
    Queues have names, which means that you should know the name of the queue you
    want to interact with either as a message producer or a message consumer.'
  prefs: []
  type: TYPE_NORMAL
- en: The `github.com/rabbitmq/amqp091-go` Go module does the job of connecting to
    RabbitMQ using the AMQP protocol, provided that you supply the correct connection
    details.
  prefs: []
  type: TYPE_NORMAL
- en: All files for this section, including source files and a `docker-compose.yml`
    file for running RabbitMQ, are located in `~/go/src/github.com/mactsouk/mGo4th/ch10/MQ`.
  prefs: []
  type: TYPE_NORMAL
- en: Running RabbitMQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this first subsection, we are going to learn how to execute RabbitMQ using
    Docker—this is the cleanest solution for running RabbitMQ on your machine because
    it only requires the use of a single Docker image. The contents of the `docker-compose.yml`
    file, which can be found inside `~/go/src/github.com/mactsouk/mGo4th/ch10/MQ/`,
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Running `docker-compose.yml` is as simple as using `docker-compose up` from
    inside `~/go/src/github.com/mactsouk/mGo4th/ch10/MQ/`. If the relevant Docker
    image is not present on the active machine, it is going to be downloaded first.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have RabbitMQ up and running, let us learn how to send data to RabbitMQ
    (producer) and read data from a RabbitMQ queue (consumer).
  prefs: []
  type: TYPE_NORMAL
- en: Writing to RabbitMQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code of the RabbitMQ producer is named `sendMQ.go` and is located under
    the `producer` directory. The `sendMQ.go` source file is presented in two parts.
    The first part contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `amqp.Dial()` call initiates a connection to RabbitMQ, whereas the `Channel()`
    call opens a channel to that connection and makes it ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: The connection string (`amqp://guest:guest@localhost:5672/`) can be split into
    three logical parts. The first part (`amqp://`) is the protocol that is used,
    the second part contains the user credentials, and the third part contains the
    name of the server and the port number (`localhost:5672/`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part comes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `QueueDeclare()` defines the queue that we are going to use. If the queue
    name specified by `QueueDeclare()` does not already exist, it is going to be created.
    This means that typos in queue names are not caught. In this case, the queue is
    named `Go`.
  prefs: []
  type: TYPE_NORMAL
- en: The plain text data we want to send is kept in the `message` variable. After
    that, we specify the format of the data we are going to put in the `amqp.Publishing{}`
    structure, which in this case is plain text (the JSON format is also supported).
    The contents of the `message` variable are converted into a byte slice and put
    into the `Body` field of an anonymous `amqp.Publishing{}` structure.
  prefs: []
  type: TYPE_NORMAL
- en: That `amqp.Publishing{}` structure is one of the parameters of the `ch.PublishWithContext()`
    call, which sends the structure to RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: The current version of `sendMQ.go` just writes a message to the predefined queue
    using `Publish()` and exits. This means that in order to send multiple messages
    to RabbitMQ, we have to execute `sendMQ.go` multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `sendMQ.go` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `{Go 1 0}` output means that we currently have two messages in the RabbitMQ
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection shows how to consume messages from a RabbitMQ queue.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from RabbitMQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code of the RabbitMQ consumer is named `readMQ.go` and is located under
    the `consumer` directory. The `readMQ.go` source file is also presented in two
    parts. The first part contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: As in `sendMQ.go`, we define the connection details, and we open the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The `Consume()` method reads messages from the `Go` queue using a goroutine.
    The `forever` channel blocks the program and prevents it from exiting. The `Body`
    field of the received message, which is a structure, contains the data we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `readMQ.go`, after `sendMQ.go` has put some messages in RabbitMQ, generates
    the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `readMQ.go` utility keeps running and waits for new messages, which means
    that we need to end it on our own by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: How to remove a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is not directly related to RabbitMQ, but it is a useful tip. The current
    version of `go.mod` in the `consumer` directory is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'You can remove a module from `go.mod` using `none` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, `go.mod` is going to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: If you want to bring `go.mod` back into its previous state, you can run `go
    mod tidy`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was all about the `net` package, TCP/IP, TCP, and UDP, which implement
    low-level connections, as well as WebSocket and RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket gives us an alternative way of creating services. As a rule of thumb,
    WebSocket is better when we want to exchange lots of data, and we want the connection
    to remain open all the time and exchange data in full duplex. However, if we are
    not sure about what to choose, it is recommended to begin with a TCP/IP service
    and see how it goes before upgrading it to the WebSocket protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, RabbitMQ is a rational choice when we want to store and retrieve a large
    amount of data to an external data store.
  prefs: []
  type: TYPE_NORMAL
- en: Go can help you create all kinds of concurrent servers and clients.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to begin developing our own services! The next chapter is about
    REST APIs, exchanging JSON data over HTTP, and developing RESTful clients and
    servers—Go is widely used for developing RESTful clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Develop a concurrent TCP server that generates random numbers in a predefined
    range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a concurrent TCP server that generates random numbers in a range that
    is given by the TCP client. This can be used as a way of randomly picking values
    from a set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add UNIX signal processing to the concurrent TCP server developed in this chapter
    to gracefully stop the server process when a given signal is received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a client program that reads a message from a RabbitMQ server and posts
    it to a TCP server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a WebSocket server that creates a variable number of random integers
    that are sent to the client. The number of random integers is specified by the
    client in the initial client message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The WebSocket protocol: [https://tools.ietf.org/rfc/rfc6455.txt](https://tools.ietf.org/rfc/rfc6455.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wikipedia WebSocket: [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gorilla WebSocket package: [https://github.com/gorilla/websocket](https://github.com/gorilla/websocket)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gorilla WebSocket docs: [https://www.gorillatoolkit.org/pkg/websocket](https://www.gorillatoolkit.org/pkg/websocket)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RabbitMQ Go module: [https://github.com/rabbitmq/amqp091-go](https://github.com/rabbitmq/amqp091-go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about AMQP at [https://www.amqp.org/](https://www.amqp.org/) and
    [https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Review_QR_Code.png)'
  prefs: []
  type: TYPE_IMG
