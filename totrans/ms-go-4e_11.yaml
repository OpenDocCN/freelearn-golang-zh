- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The subject of this chapter is the development of RESTful servers and clients
    with the Go programming language, which is one of the many areas where Go excels.
  prefs: []
  type: TYPE_NORMAL
- en: REST is an acronym for *REpresentational State Transfer* and is primarily an
    architecture for designing web services that offers a standardized efficient way
    for clients to access data and use the provided server functionality.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful services usually use the JSON format to exchange information, which
    is well supported by Go. REST is not tied to any operating system or system architecture
    and is not a protocol; however, to implement a RESTful service, we need to use
    a protocol such as HTTP or HTTPS as REST is an API convention built on the HTTP(S)
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Although we are already familiar with most of the presented Go code, the ideas
    behind REST and the way Go code serves them are going to be new. The epicenter
    of the development of RESTful servers is the definition of the appropriate Go
    structures and the execution of the necessary marshaling and unmarshaling operations
    for supporting the exchange of JSON data between the clients and the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This truly important and practical chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing RESTful servers and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a functional RESTful server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RESTful client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most modern web applications work by exposing their APIs and allowing clients
    to use these APIs to interact and communicate with them. Although REST is not
    tied to HTTP, most web services use HTTP as their underlying protocol. Additionally,
    although REST can work with any data format, usually REST means **JSON over HTTP**
    because most of the time, data is exchanged in JSON format in RESTful services.
    There are also times when data is exchanged in plain text format, usually when
    the exchanged data is simple and there is no practical need for JSON records.
    Due to the way a RESTful service works, it should have an architecture that follows
    the subsequent principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Client-server design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless implementation (each interaction does not depend on previous ones)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cacheable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniform interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'According to the HTTP protocol, we can perform the following operations on
    an HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST`: This is used for creating new resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: This is used for reading (getting) existing resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This is used for updating existing resources. As a convention, a `PUT`
    request should contain the full and updated version of an existing resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This is used for deleting existing resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: This is used for updating existing resources. A `PATCH` request only
    contains the modifications to an existing resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The important thing here is that everything you do, especially when it is out
    of the ordinary, must be well documented. As a reference, keep in mind that the
    HTTP methods supported by Go are defined as constants in the `net/http` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There also exist conventions regarding the returning HTTP status code of each
    client request. The most popular HTTP status codes as well as their meanings are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200` means that everything went well and the specified action was executed
    successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201` means that the wanted resource was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`202` means that the request was accepted and is currently being processed.
    This is usually used when an action takes too much time to complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`301` means that the requested resource has been moved permanently—the new
    URI should be part of the response. This is rarely used in RESTful services because
    API versioning is used instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400` means that there was a bad request and that you should change your initial
    request before sending it again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401` means that the client tried to access a protected request without authorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403` means that the client does not have the required permissions for accessing
    a resource even though the client is properly authorized. In UNIX terminology,
    `403` means that the current user does not have the required privileges to perform
    an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404` means that the resource was not found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`405` means that the client used a method that is not allowed by the type of
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500` means internal server error—it probably indicates a server failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to learn more about the HTTP protocol, you should visit RFC 7231
    at [https://datatracker.ietf.org/doc/html/rfc7231](https://datatracker.ietf.org/doc/html/rfc7231).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let me tell you a personal story. A couple of years ago, I was developing
    a small RESTful client for a project I was working on. The client connected to
    a given server in order to get a list of usernames. For each username, I had to
    get a list of login and logout times by hitting another endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: What I can tell you from my personal experience is that most of the Go code
    was not about interacting with the RESTful server but about taking care of the
    data, transforming it to the desired format, and storing it in a database—the
    two most tricky tasks that I needed to perform were getting a date and time in
    UNIX epoch format and truncating the information about the minutes and seconds
    from that epoch time, as well as inserting a new record into a database table
    after making sure that a record with the same data was not already stored in that
    database. So, expect that most of the code you are going to write is going to
    be about confronting the logic of the service, which is true not only for RESTful
    services but for all services in general.
  prefs: []
  type: TYPE_NORMAL
- en: The first section of this chapter contains general yet essential information
    about programming RESTful servers and clients.
  prefs: []
  type: TYPE_NORMAL
- en: Developing RESTful servers and clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is going to develop a RESTful server and a client for that server
    using the functionality of the Go standard library to understand how things really
    work behind the scenes. The functionality of the server is described in the following
    list of endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/add`: This endpoint is for adding new entries to the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/delete`: This endpoint is used for deleting an existing entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/get`: This endpoint is for getting information about an entry that already
    exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/time`: This endpoint returns the current date and time and is mainly used
    for testing the operation of the RESTful server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`: This endpoint is used for serving any request that is not a match to any
    other endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An alternative and more professional way of defining the endpoints would have
    been the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/users/` with the `GET` method: Get a list of all users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/users/:id` with the `GET` method: Get information about the user with the
    given ID value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/users/:id` with the `DELETE` method: Delete the user with the given ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/users/` with the `POST` method: Create a new user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/users/:id` with either the `PATCH` or the `PUT` method: Update the user with
    the given ID value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the alternative way is left as an exercise for the reader—it
    should not be that difficult to implement it given that the Go code for the handlers
    is going to be the same and you must only redefine the part where we specify the
    handling of the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection presents the implementation of the RESTful server.
  prefs: []
  type: TYPE_NORMAL
- en: A RESTful server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of the presented implementation is to understand how things work
    behind the scenes because the principles behind REST services remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: The logic behind each handler function is simple. Each function reads user input
    and decides whether the given input and HTTP method are the desired ones before
    processing any data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principles of each client interaction are also simple: The server should
    send appropriate error messages and HTTP codes back to the client so that everyone
    knows what really happened. Lastly, everything should be documented to communicate
    in a common language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the server, which is saved as `rServer.go`, is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a structure that holds user data, so the use of JSON tags is mandatory
    as the JSON data format is different from the one we use in Go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `user` global variable holds the user data of the current interaction—this
    is the input for the `/add`, `/get`, and `/delete` endpoints and their simplistic
    implementations. As this global variable is shared by the entire program, our
    code is not concurrently safe, which is fine for a RESTful server used as a proof
    of concept.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A RESTful server is just an HTTP server, so we need to define the TCP port number
    the server listens to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a global variable named `DATA` that holds the data
    of the service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the default handler of the service. On a production server, the default
    handler might print instructions about the operation of the server as well as
    the list of available endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`timeHandler()` is another simple handler that returns the current date and
    time—such modest handlers are usually used for testing the health of the server
    and are usually removed in the production version. A very popular endpoint with
    a similar purpose is `/health`, which is usually present in modern REST APIs with
    the purpose of providing a health status for the server, even in production.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the first time that you are seeing the `http.Error()` function. The
    `http.Error()` function sends a reply to the client request that includes the
    specified error message, which should be in plain text, as well as the desired
    HTTP code. You still need to write the data you want to send back to the client
    using an `fmt.Fprintf()` statement. However, `http.Error()` needs to be called
    last as we should not perform any more writes to `w` after using `http.Error()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We try to read all data from the client at once using `io.ReadAll()` and we
    make sure that we read the data without any errors by checking the value of the
    `d` variable returned by `io.ReadAll(r.Body)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After reading the data from the client, we put it into the `user` global variable
    – although using global variables is not considered a good practice, I personally
    prefer to use global variables for important settings or data that needs to be
    shared among a Go source file when dealing with relatively small Go source code
    files. Where you want to store the data and what to do with it is decided by the
    server. There is no rule on how to interpret the data. Therefore, **the client
    should communicate with the server according to the wishes of the server**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the given `Username` field is not empty, add the new structure to the `DATA`
    map. Data persistence is not implemented for this sample server—each time you
    restart the RESTful server, the `DATA` map is initialized from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of the `username` field is empty, then we cannot add it to the
    `DATA` map and the operation fails with an `http.StatusBadRequest` code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For the `/get` endpoint, we need to use `http.MethodGet`, so we have to make
    sure that this condition is met (`if r.Method != http.MethodGet`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After that, we still need to make sure that we can read the data from the client
    request without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then, we use the client data and put it into a `User` structure (the `user`
    global variable). Once again, I have to mention that using a global variable for
    storing the data is a personal preference that works well for smaller source code
    files but should be avoided for larger programs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the desired user record is found, we send it back to the client using the
    data stored in the `d` variable—remember that `d` was initialized in the `io.ReadAll(r.Body)`
    call and already contains a JSON record that is marshaled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, we inform the client that the desired record was not found and return
    `http.StatusNotFound`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `DELETE` HTTP method looks like a rational choice when deleting a resource,
    hence the `r.Method != http.MethodDelete` check.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Again, we read the client input and store it in the `d` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is considered a good practice to keep additional logging information when
    deleting resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For the delete process, we make sure that both the given username and password
    values are the same as the ones that exist in the `DATA` map before deleting the
    relevant entry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The previous code presents a technique for defining the TCP port number of a
    web server while having a default value at hand. So, if there are no command line
    arguments, the default value will be used. Otherwise, the value given as a command
    line argument is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block includes the details and the options for the web server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous code defines the endpoints of the web server—nothing special here
    as a RESTful server implements an HTTP server behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The last step is about running the web server with the predefined options, which
    is common practice. After that, we test the RESTful server using the `curl(1)`
    utility, which is very handy when we do not have a client and we want to test
    the operation of a RESTful server—the good thing is that `curl(1)` can send and
    receive JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a RESTful server, we need to add `-H ''Content-Type: application/json''`
    to `curl(1)` to specify that we are going to work using the JSON format. The `-d`
    option is used for passing data to a server and is equivalent to the `--data`
    option, whereas the `-v` option generates more verbose output if we need more
    details to understand what is going on.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first interaction with the RESTful server is to make sure that the server
    works as expected. The next interaction is for adding a new user to the server—the
    details of the user are in the `{"user": "mtsouk", "password" : "admin"}` JSON
    record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows that `curl(1)` has successfully connected to the server
    (`localhost`) using the desired TCP port (`1234`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows that `curl(1)` is going to send data using the `POST`
    method and the length of the data is 40 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The previous output tells us that the data was sent and that the body of the
    server response is `0` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the output tells us that after sending the data to the server,
    the connection was closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to add the same user, the RESTful server is not going to complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Although this behavior might not be perfect, it is good if it is documented.
    This is not allowed on a production server, but it is acceptable when experimenting.
    So, we are diverting from a standard practice here and you should not do that
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding command, we add another user as specified by `{"user": "mihalis",
    "password" : "admin"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows an erroneous interaction where `-H` is not followed
    by a value. Although the request is sent to the server, it is rejected because
    `/add` does not use the default HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This time, the curl command is correct, but the HTTP method used is not set
    correctly. Therefore, the request is not served.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The previous two interactions use `/get` to get information about an existing
    user. However, only the second user is found.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The last interaction successfully deletes the user specified by `{"user": "mtsouk",
    "password" : "admin"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output generated by the server process for all previous interactions would
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have a working RESTful server that has been tested with the help
    of the `curl(1)` utility. The next section is about developing a command line
    client for the RESTful server.
  prefs: []
  type: TYPE_NORMAL
- en: A RESTful client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection illustrates the development of a client for the RESTful server
    developed previously. However, in this case, the client acts as a testing program
    that tries the capabilities of the RESTful server—later in this chapter, you are
    going to learn how to write proper clients using the cobra library. So, the code
    of the client, which can be found in `rClient.go`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This same structure is found in the server implementation and is used for data
    exchange.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we predefine three `User` variables that are going to be used during testing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The previous constants define the endpoints that are going to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We prepare a request that is going to access `/delete` using the `DELETE` HTTP
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is the correct way to specify that we want to use JSON data when interacting
    with the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Then, we send the request and wait for the server response using the `Do()`
    method with a 15-second timeout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The reason for putting that `fmt.Print()` here is that we want to get informed
    about the server response even if there is an error in the interaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `resp.StatusCode` value specifies the response HTTP code from `/delete`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is going to access `/get` using the `GET` HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We specify that we are going to interact with the server using the JSON format
    using `Header.Set()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The previous statements define a timeout period for the HTTP client in case
    the server is too busy responding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The previous code sends the client request to the server using `c.Do(req)` and
    saves the server response in `resp` and the `error` value in `err`. If the value
    of `resp` is `nil`, then the server response is empty, which is an error condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The value of `resp.StatusCode`, which is specified and transferred by the RESTful
    server, determines whether the interaction was successful in an HTTP sense (logically)
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We are going to access `/add` using the `POST` HTTP method. We can use `http.MethodPost`
    instead of `POST`. As stated earlier in this chapter, there exist relevant global
    variables in http for the remaining HTTP methods (`http.MethodGet`, `http.MethodDelete`,
    `http.MethodPut`, etc.) and it is recommended that we use them for portability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As before, we specify that we are going to interact with the server using the
    JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we define a timeout period for the client in case the server is
    too busy replying.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `addEndpoint()` function is for testing the `/add` endpoint using the `POST`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We are going to access the `/time` endpoint using the `POST` HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As before, we define a timeout period for the client in case the server is too
    busy responding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `timeEndpoint()` function is for testing the `/time` endpoint—note that
    this endpoint does not require any data from the client, so the client request
    is empty. The server is going to return a string with the current time and date
    of the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We are going to access `/` using the `POST` HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It is considered a good practice to have a timeout period on the client side
    in case there are delays in the server response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `slashEndpoint()` function is for testing the default endpoint in the server—note
    that this endpoint does not require any data from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the implementation of the `main()` function, which uses all
    previous functions to visit the RESTful server endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `server` variable holds the server address and the port number that are
    going to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: All the previous code is used for testing the `/add` endpoint using various
    types of data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: All the previous code is used for testing the `/get` endpoint using various
    types of input. We only test for the return code because the HTTP code specifies
    the success or failure of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: All the previous code is used for testing the `/delete` endpoint using various
    types of input. Once again, we print the HTTP code of the interaction because
    the value of the HTTP code specifies the success or failure of the client request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The previous code tests the `/time` endpoint—it prints the HTTP code as well
    as the rest of the server response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the program tries to connect to an endpoint that does not exist
    to verify the correct operation of the default handler function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `rClient.go` and interacting with `rServer.go` produces the next kind
    of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The previous part is related to the testing of the `/add` endpoint. The first
    two users were successfully added, whereas the third user (`var u3 = User{"",
    "pass"}`) was not added because it does not contain all the required information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The previous part is related to the testing of the `/get` endpoint. The data
    of the first two users with the usernames `admin` and `tsoukalos` was successfully
    returned, whereas the user stored in the `u3` variable was not found.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The previous output is related to the testing of the `/delete` endpoint. The
    `admin` and `tsoukalos` users were deleted. However, trying to delete `admin`
    for the second time failed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the previous part is related to the testing of the `/time` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the output is related to the operation of the default handler.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to realize that `rClient.go` can successfully interact with
    every RESTful server that supports the same endpoints without knowing the implementation
    details of the RESTful server.
  prefs: []
  type: TYPE_NORMAL
- en: So far, both the RESTful server and the client can interact with each other.
    However, neither of them performs a real job. The next section shows how to develop
    a real-world RESTful server using `gorilla/mux` and a database backend for storing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a functional RESTful server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section illustrates how to develop a RESTful server in Go given a REST
    API. The biggest difference between the presented RESTful service and the statistics
    application created in *Chapter 9*, *Building Web Services*, is that the RESTful
    service uses JSON messages for interacting with its clients, whereas the statistics
    application interacts and works using plain text messages.
  prefs: []
  type: TYPE_NORMAL
- en: If you are thinking of using `net/http` for the implementation of the RESTful
    server, please do not do so without first thinking about the requirements of your
    server! This implementation uses the `gorilla/mux` package, which is a much better
    choice because it supports subrouters – more about that in the *Using gorilla/mux*
    subsection. However, `net/http` is still powerful and can be useful for many REST
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the RESTful server is to implement a login/authentication system.
    The purpose of the login system is to keep track of the users who are logged in,
    as well as their permissions. The system comes with a default administrator user
    named `admin`—the default password is also `admin` and you should change it. The
    application stores its data in an SQLite3 database, which means that if you restart
    it, the list of existing users is read from that database and is not lost.
  prefs: []
  type: TYPE_NORMAL
- en: The REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API of an application helps you implement the functionality that you have
    in mind. However, this is a job for the client, not the server. The job of the
    server is to facilitate the job of its clients as much as possible by supporting
    a simple yet fully working functionality through a properly defined and implemented
    REST API. Make sure that you understand that before trying to develop and use
    a RESTful server.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to define the endpoints that are going to be used, the HTTP codes
    that are going to be returned, as well as the allowed method or methods. Creating
    a RESTful server based on a REST API for production is a serious job that should
    not be taken lightly. Creating a prototype to test and validate your ideas and
    designs is going to save you lots of time in the long run. Always begin with a
    prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported endpoints as well as the supported HTTP methods and the parameters
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: This is used for catching and serving everything that is not a match.
    This endpoint works with all HTTP methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/getall`: This is used for getting the full contents of the database. Using
    this requires a user with administrative privileges. This endpoint might return
    multiple JSON records and works with the `GET` HTTP method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/getid/username`: This is used for getting the ID of a user identified by
    their username, which is passed to the endpoint. This command should be issued
    by a user with administrative privileges and supports the `GET` HTTP method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/username/ID`: This is used for deleting or getting information about the
    user with an ID equal to `ID`, depending on the HTTP method used. Therefore, the
    actual action that is going to be performed depends on the HTTP method used. The
    `DELETE` method deletes the user, whereas the `GET` method returns the user information.
    This endpoint should be issued by a user with administrative privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/logged`: This is used for getting a list of all logged-in users. This endpoint
    might return multiple JSON records and requires the use of the `GET` HTTP method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/update`: This is used for updating the username, password, or admin status
    of a user—the ID of the user in the database remains the same. This endpoint works
    with the `PUT` HTTP method only and the search for the user is based on the username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/login`: This is used for logging a user into the system, given a username
    and a password. This endpoint works with the `POST` HTTP method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/logout`: This is used for logging out a user, given a username and a password.
    This endpoint works with the `POST` HTTP method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/add`: This is used for adding a new user to the database. This endpoint works
    with the `POST` HTTP method and is issued by a user with administrative privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/time`: This is an endpoint used mainly for testing purposes. It is the only
    endpoint that does not work with JSON data, does not require a valid account,
    and works with all HTTP methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let us discuss the capabilities and the functionality of the `gorilla/mux`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Using gorilla/mux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gorilla/mux` package ([https://github.com/gorilla/mux](https://github.com/gorilla/mux))
    is a popular and powerful alternative to the default Go router that allows you
    to match incoming requests to their respective handler. Although there exist many
    differences between the default Go router (`http.ServeMux`) and `mux.Router` (the
    `gorilla/mux` router), the main difference is that `mux.Router` supports multiple
    conditions when matching a route with a handler function. This means that you
    can write less code to handle some options such as the HTTP method used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us begin by presenting some matching examples—this functionality is not
    supported by the default Go router:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r.HandleFunc("/url", UrlHandlerFunction)`: The previous command calls the
    `UrlHandlerFunction` function each time `/url` is visited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r.HandleFunc("/url", UrlHandlerFunction).Methods(http.MethodPut)`: This example
    shows how you can tell Gorilla to match a specific HTTP method (`PUT` in this
    case, which is defined by the use of `http.MethodPut`), which saves you from having
    to write code to do that manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mux.NotFoundHandler = http.HandlerFunc(handlers.DefaultHandler)`: With Gorilla,
    the right way to match anything that is not a match by any other path is by using
    `mux.NotFoundHandler`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mux.MethodNotAllowedHandler = notAllowed`: If a method is not allowed for
    an existing route, it is handled with the help of `MethodNotAllowedHandler`. This
    is specific to `gorilla/mux`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s.HandleFunc("/users/{id:[0-9]+}"), HandlerFunction)`: This last example shows
    that you can define a variable in a path using a name (`id`) and a pattern – Gorilla
    does the matching for you! If there is not a regular expression, then the match
    is going to be anything from the beginning slash to the next slash in the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let us talk about another capability of `gorilla/mux`, which is subrouters.
  prefs: []
  type: TYPE_NORMAL
- en: The use of subrouters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server implementation uses subrouters. A *subrouter* is a nested route that
    will only be examined for potential matches if the parent route matches the parameters
    of the subrouter. The good thing is that the parent route can contain conditions
    that are common among all paths that are defined under a subrouter, which includes
    hosts, path prefixes, and, as it happens in our case, HTTP request methods. As
    a result, our subrouters are divided based on the common request method of the
    endpoints that follow. Not only does this optimize the request matchings, but
    it also makes the structure of the code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the subrouter for the `DELETE` HTTP method is as simple as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The first statement is for defining the common characteristics of the subrouter,
    which in this case is the `http.MethodDelete` HTTP method, whereas the remaining
    statement, which in this case is the `deleteMux.HandleFunc(...)` one, is for defining
    the supported paths.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, `gorilla/mux` might be more difficult to use than the default Go router,
    but by now you should understand the benefits of the `gorilla/mux` package for
    working with HTTP services.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection briefly presents the Gin framework, which is an alternative
    to the `gorilla/mux` package.
  prefs: []
  type: TYPE_NORMAL
- en: The Gin HTTP framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gin is an open source web framework written in Go that can help you write powerful
    HTTP services. The Gin GitHub repository can be found at `https://github.com/gin-gonic/gin`.
    Gin uses `httprouter` as its HTTP router because `httprouter` is optimized for
    high performance and small memory usage. `httprouter` is an HTTP router, just
    like the default `mux` from the `net/http` package or the more advanced `gorilla/mux`.
    You can learn more about it at [https://github.com/julienschmidt/httprouter](https://github.com/julienschmidt/httprouter)
    and at [https://pkg.go.dev/github.com/julienschmidt/httprouter](https://pkg.go.dev/github.com/julienschmidt/httprouter).
  prefs: []
  type: TYPE_NORMAL
- en: Gin versus Gorilla
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest difference between Gin and `gorilla/mux` is that `gorilla/mux` is
    just an HTTP router and nothing more, whereas Gin can do what `gorilla/mux` can
    plus JSON marshaling and unmarshaling, validation, customized response writing,
    and so on. Put simply, Gin can do many more things than `gorilla/mux`. In practice,
    you can consider Gin as being a higher-level framework than `gorilla/mux` with
    more capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: So, the question here is which one should you choose. It is not bad to try both
    starting with `gorilla/mux`. If `gorilla/mux` cannot do your job, then you definitely
    need to use Gin. Put simply, if performance is critical, if you want middleware
    support, or if want minimalistic and fast routing, then use Gin.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will show you how we work with the SQLite database that
    supports the functionality of the RESTful server. The relevant file is `./server/restdb.go`.
  prefs: []
  type: TYPE_NORMAL
- en: The RESTful server itself knows nothing about the SQLite database. All related
    functionality is kept in the `restdb.go` file, which means that if you change
    the database, the handler functions do not have to know about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database name, the database table, and the `admin` user are created using
    the next `create_db.sql` SQL file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `create_db.sql` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that the `users` table is created and contains the desired entry
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to present the most important database-related functions, beginning
    with `OpenConnection()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As we need to interact with SQLite3 all the time, we created a helper function
    that returns an `*sql.DB` variable, which is an open connection to SQLite3\. `Filename`
    is a global variable that specifies the SQLite3 database file that is going to
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we present the `DeleteUser()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is how we use `OpenConnection()` to get a database connection
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `FindUserID()` helper function to make sure that the user with
    the given user ID exists in the database. If the user does not exist, the function
    stops and returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This is the actual SQL statement for deleting the user. We use `Prepare()` to
    construct the required SQL statement that we execute using `Exec()`. The `$1`
    in `Prepare()` denotes a parameter that is going to be given in `Exec()`. If we
    wanted to have more parameters, we should have named them `$2`, `$3`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This is where the implementation of the `DeleteUser()` function ends. The execution
    of the `stmt.Exec(ID)` statement is what deletes a user from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ListAllUsers()` function, which is presented next, returns a slice of
    `User` elements, which holds all users found in the RESTful server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As the `SELECT` query requires no parameters, we use `Query()` to run it instead
    of `Prepare()` and `Exec()`. Keep in mind that this is a query that most likely
    returns multiple records.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This is how we read the values from a single record returned by the SQL query.
    First, we define multiple variables for each one of the returned values and then
    we pass their pointers to `Scan()`. The `rows.Next()` method keeps returning records
    as long as there are new results in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: So, as mentioned before, a slice of `User` structures is returned from `ListAllUsers()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we are going to present the implementation of `IsUserValid()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a common pattern: we call `OpenConnection()` and wait to get a connection
    to use before continuing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pass our parameter to `Query()` without using `Prepare()` and `Exec()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create the required parameters to keep the return values of the SQL
    query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the `for` loop keeps running for as long as `rows.Next()` returns
    new records.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an important point: not only should the given user exist, but the given
    password should be the same as the one stored in the database for the given user
    to be valid.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: You can view the rest of the `restdb.go` source code on your own. Most functions
    are like the ones presented here. The code of `restdb.go` is going to be used
    in the implementation of the RESTful server that is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the RESTful server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to begin explaining the implementation of the RESTful server.
    The server code is split into three files that belong to the `main` package. So,
    apart from `restdb.go`, we have `main.go` and `handlers.go`.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for doing so is to not have to work with huge source code files
    and to separate the functionality of the server logically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part of `main.go`, which belongs to the `main()` function,
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: So, we define the default handler function. Although this is not necessary,
    it is a good practice to have such a handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The `MethodNotAllowedHandler` handler is executed when you try to visit an endpoint
    using an unsupported HTTP method. The actual implementation of the handler is
    found in `handlers.go`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `/time` endpoint is supported by all HTTP methods, so it does not belong
    to any subrouter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a subrouter for the `GET` HTTP method along with the supported
    endpoints. Remember that `gorilla/mux` is responsible for making sure that only
    `GET` requests are going to be served by the `getMux` subrouter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: After that, we define a subrouter for `PUT` requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Then, we define the subrouter for `POST` requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The last subrouter is for `DELETE` HTTP methods. The code in `gorilla/mux` is
    responsible for choosing the correct subrouter based on the details of the client
    request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP server is executed as a goroutine because the program supports signal
    handling—refer to *Chapter 8*, *Go Concurrency*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Last, we add signal handling for gracefully terminating the HTTP server. The
    `sig := <-sigs` statement prevents the `main()` function from exiting unless an
    `os.Interrupt` signal is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `handlers.go` file contains the implementations for the handler functions
    and is also part of the `main` package—its most important parts are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This handler is for the `/add` endpoint. The server reads the client input using
    `io.ReadAll()` and makes sure that the `io.ReadAll()` call was successful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Then, the code makes sure that the body of the client request is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: As the `/add` endpoint requires two `User` structures, the previous code uses
    `json.Unmarshal()` to put them into a `[]User` variable—this means that the client
    should send these two JSON records using an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: If the user issuing the command does not have administrative privileges, then
    the request fails. `IsUserAdmin()` is implemented in `restdb.go` as it has to
    do with the data stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, `InsertUser()` inserts the desired user into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Last, we present the handler for the `/getall` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we read the data from the client using `io.ReadAll(r.Body)` and
    we make sure that the process is error-free by examining the `err` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Here, we put the client data into a `User` variable. The `/getall` endpoint
    requires a single `User` record as input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Only admin users can visit `/getall` and get the list of all users, hence the
    use of `IsUserAdmin()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the code is about getting the desired data from the database
    and sending it to the client using the `SliceToJSON(ListAllUsers(), rw)` call.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to put each handler into a separate Go file. The general idea is that
    if you have many handler functions, using a separate file for each handler function
    is a good practice. Among other things, it allows multiple developers to work
    on multiple handler functions without bothering each other.
  prefs: []
  type: TYPE_NORMAL
- en: Before developing a proper command line client, it would be a good idea to test
    the RESTful server using `curl(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the RESTful server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection shows how to test the RESTful server using the `curl(1)` utility.
    You should test the RESTful server as much and as extensively as possible to find
    bugs or unwanted behavior. As we use three files for the server implementation,
    we need to run it as `go run main.go restdb.go handlers.go`. We begin by testing
    the `/time` handler, which works with all HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we test the default handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, we see what happens if we use an unsupported HTTP method with a supported
    endpoint—in this case, the `/getall` endpoint that works with `GET` only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Although the `/getall` endpoint requires a valid user to operate, the fact that
    we are using an HTTP method that is not supported by that endpoint takes precedence
    and the call fails for the right reasons.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to look at the output of the RESTful server and the log entries
    that it generates during testing. Not all information can be sent back to a client,
    but the server process is allowed to print anything we want. This can be very
    helpful for debugging a server process such as our RESTful server.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection tests all of the handlers that support the `GET` HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing GET handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we test the `/getall` endpoint—your output might vary depending on the
    contents of the SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The previous output is a list of all existing users found in the database in
    JSON format. You can always process the generated output with the `jq(1)` utility
    for a better-looking output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we test the `/logged` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we test the `/username/{id}` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, we test the `/getid/{username}` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: So, user `mihalis` has a user ID of `3`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we can get a list of existing users and a list of logged-in users and
    get information about specific users—all of these endpoints use the `GET` method.
    The next subsection tests all of the handlers that support the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing POST handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we test the `/add` endpoint by adding the `packt` user, which does not
    have admin privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The previous call passes an array of two JSON records to the server. The second
    record comes with the details of the `packt` user. The command is issued by the
    `admin` user as specified by the data in the first JSON record.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to add the same username more than once, the process is going to fail—this
    is revealed with the use of `-v` in the `curl(1)` command. The relevant error
    message is going to be `HTTP/1.1 400 Bad Request`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if we try to add a new user using the credentials of a user that
    is not an administrator, the server is going to generate the `Command issued by
    non-admin user: packt` message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we test the `/login` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The previous command is used for logging in the `packt` user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, we test the `/logout` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The previous command is used for logging out the `packt` user. You can use the
    `/logged` endpoint to verify the results of the previous two interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now test the only endpoint that supports the `PUT` HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the PUT handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we test the `/update` endpoint as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The previous command changes the password of the `admin` user from `admin` to
    `justChanged`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we try to change a user password using the credentials of a non-admin
    user (`packt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated log message is `Command issued by non-admin user: packt`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We might consider the fact that a non-admin user cannot even change their password
    as a flaw—it might be, but this is the way the RESTful server is implemented.
    The idea is that non-admin users should not issue dangerous commands directly.
    Additionally, this flaw can be easily fixed as follows: Generally speaking, regular
    users are not going to interact in this way with the server and are going to be
    offered a web interface for doing so. After that, an admin user can send the user
    request to the server. Therefore, this can be implemented in a different way that
    is more secure and does not give unnecessary privileges to regular users.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we are going to test the `DELETE` HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the DELETE handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the `DELETE` HTTP method, we need to test the `/username/{id}` endpoint.
    As this endpoint does not return any output, using `-v` in `curl(1)` is going
    to reveal the returned HTTP status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The `HTTP/1.1 200 OK` status code verifies that the user was deleted successfully.
    If we try to delete the same user again, the request is going to fail, and the
    returned message is going to be `HTTP/1.1 404 Not Found`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we know that the RESTful server works as expected. However, `curl(1)`
    is far from perfect for working with the RESTful server on a daily basis. The
    next section shows how to develop a command line client for the RESTful server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a RESTful client is much easier than programming a server mainly because
    you do not have to work with the database on the client side. The only thing that
    the client needs to do is send the right amount and kind of data to the server
    and receive back and interpret the server response. The full RESTful client implementation
    can be found in `./ch11/client` of the book GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported first-level cobra commands are going to be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list`: This command accesses the `/getall` endpoint and returns the list of
    all available users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: This command is for visiting the `/time` endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`: This command is for updating user records—the user ID cannot change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logged`: This command lists all logged-in users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: This command deletes an existing user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login`: This command is for logging in a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logout`: This command is for logging out a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add`: This command is for adding a new user to the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getid`: This command returns the ID of a user, identified by their username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search`: This command displays information about a given user, identified
    by their ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client like the one we are about to present is much better than working with
    `curl(1)` because it can process the received information but, most importantly,
    it can interpret the HTTP return codes and preprocess data before sending it to
    the server. The price you pay is the extra time needed for developing and debugging
    the RESTful client.
  prefs: []
  type: TYPE_NORMAL
- en: 'There exist two command line flags for passing the username and the password
    of the user issuing the command: `username` and `password`. As you are going to
    see in their implementations, they have the `-u` and `-p` shortcuts, respectively.
    Additionally, as the JSON record that holds user information has a small number
    of fields, all the fields are going to be given using the `data` flag or the `-d`
    shortcut—this is implemented in `./cmd/root.go`. Each command is going to read
    the desired flags only and the desired fields of the input JSON record—this is
    implemented in the source code file of each command. Lastly, the utility is going
    to return JSON records, when this makes sense, or a text message related to the
    endpoint that was visited. Now, let us continue with the structure of the client
    and the implementation of the commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the structure of the command line client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection uses the cobra utility to create the structure for the command
    line utility. But first, we are going to create a proper cobra project with Go
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'You do not need to execute the last command, but it makes sure that everything
    is fine so far. After that, we are ready to define the commands that the utility
    is going to support by running the following cobra commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the desired structure, we can begin implementing the commands
    and maybe remove some of the comments inserted by cobra, which is the subject
    of the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the RESTful client commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As there is no point in displaying the entire code, we are going to present
    the most characteristic code found in some of the commands, starting with `root.go`,
    which is where the next global variables are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: These global variables hold the values of the command line options of the utility
    and are accessible from anywhere in the utility code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: We define the `User` structure for sending and receiving data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We present the implementation of the `init()` function that holds the definitions
    of the command line options. The values of the command line flags are automatically
    stored in the variables that are passed as the first argument to `rootCmd.PersistentFlags().StringVarP()`.
    So, the `username` flag, which has the `-u` alias, stores its value in the `username`
    global variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part is the implementation of the `list` command as found in `list.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'This part is about the help messages that are displayed for the command. Although
    they are optional, it is good to have an accurate description of the command.
    We continue with the actual implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: First, we construct a `User` variable named `user` that holds the username and
    the password of the user issuing the command—the `user` variable is going to be
    passed to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: We need to encode the `user` variable before transferring it to the RESTful
    server, which is the purpose of the `ToJSON()` method. The implementation of the
    `ToJSON()` method is found in `root.go`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create the request using the `SERVER` and `PORT` global variables followed
    by the endpoint, using the desired HTTP method (`http.MethodGet`), and declare
    that we are going to send JSON data using the `Header.Set()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: After that, we send our data to the server using `Do()` and get the server response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: If the status code of the response is not `http.StatusOK`, then the request
    has failed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: If the status code is `http.StatusOK`, then we prepare to read a slice of `User`
    variables. As these variables hold JSON records, we need to decode them using
    `SliceFromJSON()`, which is defined in `root.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Last is the code of the `add` command, as found in `add.go`. The difference
    between `add` and `list` is that the `add` command needs to send two JSON records
    to the RESTful server; the first one holds the data of the user issuing the command,
    and the second holds the data for the user that is about to be added to the system.
    The `username` and `password` flags hold the data for the `Username` and `Password`
    fields of the first record, whereas the `data` command line flag holds the data
    for the second record.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: As before, we get the information about the user issuing the command and put
    it into a structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: As the `data` command line flag holds a `string` value, we need to convert that
    string value to a `User` structure—this is the purpose of the `json.Unmarshal()`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a slice of `User` variables that are going to be sent to the
    server. The order you put the structures in that slice is important: first, the
    user issuing the command, and then the data of the user that is going to be created.
    This was decided by the RESTful server.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Then, we encode that slice before sending it to the RESTful server through the
    HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: We prepare the request and send it to the server. The server is responsible
    for decoding the provided data and acting accordingly, in this case, by adding
    a new user to the system. The client just needs to visit the correct endpoint
    using the appropriate HTTP method (`http.MethodPost`) and check the returned HTTP
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The `add` command does not return any data back to the client—what interests
    us is the HTTP status code because this is what determines the success or failure
    of the command.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the commands have a similar implementation, which is not presented
    here. Feel free to look at the Go source code files in the `cmd` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Using the RESTful client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to use the command line utility to interact with the RESTful
    server. This type of utility can be used for administering a RESTful server, creating
    automated tasks, and carrying out CI/CD jobs. For reasons of simplicity, the client
    and the server reside on the same machine, and we mostly work with the default
    user (`admin`)—this makes the presented commands shorter. Additionally, we execute
    `go build -o rest-cli` to create a binary executable and avoid using `go` `run`
    `main.go` all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get the time from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we list all users. As the output depends on the contents of the database,
    we print a small part of the output. Note that the `list` command needs to be
    issued by a user with admin privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that you should use the active password of the `admin` user for
    the previous command to be executed correctly. In my case, the active password
    was also `admin` but this depends on your current status of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we test the `logged` command when issued with an invalid password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the command fails—this output is used for debugging purposes. After
    making sure that the command works as expected, you might want to print a more
    appropriate error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we test the `add` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to add the same user again is going to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to delete `newUser`—but first, we need to find the user
    ID of `newUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to continue testing the RESTful client and let me know if you find
    any bugs!
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple REST API versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A REST API can change and evolve over time. There exist various approaches
    on how to implement REST API versioning, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom HTTP header (`version-used`) to define the version used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a different subdomain for each version (`v1.servername` and `v2.servername`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a combination of `Accept` and `Content-Type` headers—this method is based
    on content negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a different path for each version (`/v1` and `/v2` if the RESTful server
    supports two REST API versions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a query parameter to reference the desired version (`..../endpoint?version=v1`
    or `..../endpoint?v=1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no correct answer for how to implement REST API versioning. Use what
    seems more natural to you and your users. What is important is to be consistent
    and use the same approach everywhere. Personally, I prefer to use `/v1/...` for
    supporting the endpoints of version 1, and `/v2/...` for supporting the endpoints
    of version 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The development of our RESTful servers and clients has come to an end here.
    With the knowledge presented in this chapter, you can create powerful RESTful
    services!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is widely used for developing RESTful clients and servers and this chapter
    illustrated how to program professional RESTful clients and servers in Go. Although
    you can develop a RESTful server using the Standard Go library, this can be a
    really tedious task. External packages such as `gorilla/mux`, which was used in
    this chapter, and Gin can save you time by providing advanced features that would
    otherwise require lots of code when implemented with the functionality offered
    by the standard Go library.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that defining a proper REST API and implementing a server and clients
    for it is a process that takes time and requires small adjustments and modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Behind an efficient and productive RESTful service are properly defined JSON
    records and HTTP endpoints that support the desired operations. Given these two
    items, the Go code should offer support for the exchange of the JSON records between
    the server and the clients.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about code testing, profiling, cross-compilation, and creating
    example functions. Among other things, we are going to write code for testing
    the HTTP handlers developed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to make `rServer.go` use Gin instead of `net/http`. Does `rClient.go` still
    work with the updated `rServer.go`? Why? Is that a good thing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the `server/restdb.go` file to support PostgreSQL instead of SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the `server/restdb.go` file to support MySQL instead of SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the handler functions from `server/handlers.go` into separate files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find more about `gorilla/mux` at [https://github.com/gorilla/mux](https://github.com/gorilla/mux)
    and [https://www.gorillatoolkit.org/pkg/mux](https://www.gorillatoolkit.org/pkg/mux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `go-querystring` library is for encoding Go structures into URL query parameters:
    [https://github.com/google/go-querystring](https://github.com/google/go-querystring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tutorial: Developing a RESTful API with Go and Gin: [https://go.dev/doc/tutorial/web-service-gin](https://go.dev/doc/tutorial/web-service-gin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to validate JSON input, have a look at the Go `validator` package
    at [https://github.com/go-playground/validator](https://github.com/go-playground/validator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might find the `jq(1)` command line utility pretty handy when working with
    JSON records: [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)
    and [https://jqplay.org/](https://jqplay.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Review_QR_Code.png)'
  prefs: []
  type: TYPE_IMG
